- en: Chapter 3. Working with Geometry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll be looking at ways to create and manipulate geometry
    with scripting. The following topics will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with selected objects and checking node type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing geometric data in polygonal models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing geometric data in NURBS objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating curves
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating new polygonal faces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating new modifiers (noise)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating novel primitives (tetrahedron)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll be looking at how to manipulate geometry within Maya
    via scripting. First off, we'll look at how to make sure that we have the right
    kind of object selected. From there, we'll look at how to retrieve information
    about particular kinds of geometry (both polygonal and NURBS).
  prefs: []
  type: TYPE_NORMAL
- en: We'll also be looking at how to create new geometry (both single faces and entire
    objects) and how to create per-vertex modifications to existing objects.
  prefs: []
  type: TYPE_NORMAL
- en: Working with selected objects and checking node type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Very often, you will want to make a script that only works on certain kinds
    of objects and the objects that already exist before the user invokes your script.
    In this case, you'll want to be able to not only determine what object(s) are
    currently selected but also to verify that the selected object(s) are of the appropriate
    type. In this example, we'll be creating a script that will verify that the currently
    selected object is, in fact, an instance of polygonal geometry and altering the
    user if it isn't.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new script and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If you run the preceding script with nothing selected, you should get an error
    indicating that you should select something. If you run it with something other
    than a polygon object selected, you'll also get an error, but indicating this
    you should select a polygonal object.
  prefs: []
  type: TYPE_NORMAL
- en: If you run it with a polygonal object, however, the script will print **FOUND
    POLYGON**.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The script consists of two functions—one (`currentSelectionPolygonal`) to test
    if a given object is polygonal geometry and another (`checkSelection`) to invoke
    that on the currently selected object. Because `checkSelection` is the entry point
    for the script, that's where we'll start.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing that we have to do is to get a list of what object or objects
    are currently selected. To do this, we''ll use the `ls` command. The `ls` command
    is short for *list* and another example of the bash scripting heritage of **Maya
    Embedded Language** (**MEL**) that carries over to the Python command list. The
    `ls` command can do a variety of things, but the most common way that you''re
    likely to use it is with the `selection` flag to return a list of the currently
    selected nodes, as in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that even though we''re essentially asking Maya a question, it is not
    necessary to use the `query` flag. In fact, using the query mode for the `ls`
    command will generate an error. Note that we store the result of the `ls` command
    into a variable named `selectedObjects`. This will give us a collection of objects
    as a Python list, with objects appearing in the order in which they were selected.
    First, we want to make sure that at least one object is selected by checking the
    length of `selectedObjs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If the user hasn't selected anything, we use the `error` command to both notify
    the user and stop the execution of the script. Adding meaningful error messages
    is a great way to give your users quality feedback. You can also use the `warning()`
    command to present the user with feedback without stopping the script. In both
    cases, the error (or warning) will show to the user in the same way as built-in
    errors (or warnings), appearing in the bottom of Maya's interface and with a red
    (or yellow) background.
  prefs: []
  type: TYPE_NORMAL
- en: Once we know that we have at least one object selected, we want to make sure
    that the given object is a polygonal one. Using `-1` as the index into the list
    allows us to count backwards from the end. In this case, that will give us the
    most recently selected object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We then pass that object to our `currentSelectionPolygonal` function, which
    will determine if it is, in fact, a polygonal object. This function will handle
    the check and return either `True` or `False`, depending on whether or not the
    object in question is polygonal geometry.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: It's generally a good idea to break up your scripts into distinct parts, with
    each one responsible for one distinct task. This makes your scripts much easier
    to write and maintain. However, it also requires that the different parts be able
    to communicate with each other. The `return` statement is one of the most common
    ways to do this. It causes the current function to stop and *return* to the previous
    scope. If you give it a value, that value is brought back along, allowing information
    to be passed from one function to another.
  prefs: []
  type: TYPE_NORMAL
- en: We can check the type of given node by using the `nodeType()` command, but there's
    a bit more to it than that. If we check the type of the selected object itself,
    we'll almost always get *transform*. This is due to the fact that most things
    you interact with in Maya are composed of two nodes, not one. There is generally
    a shape node, which holds all of the specific data associated with a given object
    (faces, vertices, and so on), and a transform object that holds the position,
    rotation, and scale (along with a few other things) common to all objects that
    appear on screen and can be moved. The shape node is always a child of its corresponding
    transform node.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you click on something in the interface, such as a polygonal object, you're
    actually clicking on the shape node, but Maya will automatically jump one step
    up the hierarchy to the transform node so that you can move it. That is often
    used to create controls for rigging by having the shape node for a curve be a
    child of some other transform, providing an easy way to grab bones inside a model
    by clicking on non-renderable curves (for example).
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what we actually need in order to test the geometry type is the shape node
    associated with the transform. There are a couple of ways to go about this, but
    the best is to use the `listRelatives()` command with `shapes=True`. This will
    give us the shape node associated with the input node (if any):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we''ve done this, we can test its type with `nodeType` to see what kind
    of geometry we have. If we have a polygonal object, it will result in `mesh`.
    If the node type is, in fact `mesh`, we return a value of `True`. If it''s anything
    other than `mesh`, we return `False` instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note that `return False` appears outside of an `else` block. This is mainly
    a stylistic choice. If you have a `return` statement inside a conditional (as
    we do here), it's a good idea to have a `return` statement that is outside the
    conditional that is guaranteed to be called, to ensure that there is no possible
    way that the function can fail to provide a return value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some people don''t like to have multiple return values in a single function
    though, and if you''re one of them, you could just as well create a variable and
    return that instead, as in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, for a more compact (but perhaps slightly less readable) approach, you could
    just return the result of the comparison itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: All of this would have the same result, in that the function would return `True`
    if and only if the object tested possessed a shape node of type `mesh`. At this
    point, we're done with the `currentSelectionPolygonal` function and can turn our
    attention back to `checkSelection`.
  prefs: []
  type: TYPE_NORMAL
- en: 'All that''s left is to check the return value and notify the user of the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can use the same technique of grabbing the shape node with `listRelatives`
    and testing its type to identify other kinds of objects. Some of the more useful
    ones to be aware of are `nurbsCurve` for NURBS curves and `nurbsSurface` for NURBS
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing geometric data in polygonal models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we'll be looking at how to get information about polygonal
    geometry, which will form the basis for more complex scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new scene and make sure that it contains one or more polygonal objects.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new script, name it `polyStats.py`, and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Running the preceding code will result in information about the currently selected
    polygonal object being printed.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `polyEvaluate` command is pretty straightforward and can be used to determine
    various information about a polygonal object. In this case, we're just grabbing
    the number of vertices, edges, and faces that the object contains.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Grabbing the number of components that an object contains isn't really all that
    useful, in and of itself. To perform the useful work, you'll likely want to access
    the components directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to do this, you''ll want to be understand that each object has a collection
    of components stored as a Python list, which are named as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Component | List name |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Vertices | vtx |'
  prefs: []
  type: TYPE_TB
- en: '| Edges | e |'
  prefs: []
  type: TYPE_TB
- en: '| Faces | f |'
  prefs: []
  type: TYPE_TB
- en: 'So, to select the first vertex for a given object (whose name is stored in
    a variable `obj`), you could do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You could similarly grab the first edge with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Or the first face with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the lists of components are just ordinary Python lists, you can also
    refer to collections of components by using a colon along with a start or a stop
    index (or both). For example, if we wanted to select vertices from `5` to `12`,
    we could do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This would work, but could quickly get awkward if you wanted to have the starting
    and ending indices as variables as well, which would result in something like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This would build up the proper value to pass to `cmds.select` (something like
    `polySurface5.vtx[5:12]`), but is a bit awkward to type. An easier way is to use
    Python's built-in string formatting capability, which can be used to fit variables
    into a specific string.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, start with an example of the string you want to end up with, as
    in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, identify each portion of the string that will change. In this case, we
    want to pass in three things—the name of the object, the start index, and the
    end index. For each one, replace the specific value with a number wrapped in curly
    braces, as in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you''ve done this, you can call `format()` on the string, passing in values
    to replace the curly-bracketed numbers, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The numbers inside the brackets serve as indices and tell Python which of the
    arguments passed into format should go where. In this case, we're saying that
    the first argument (the object name) should go at the start and that the next
    two should be placed inside the square brackets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of it all put together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Accessing geometric data in NURBS objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we'll be looking at how to retrieve information about NURBS
    surfaces, starting with the number of **control vertices** (**CVs**) they contain.
  prefs: []
  type: TYPE_NORMAL
- en: However, the number of CVs in a NURBS object isn't quite as straightforward
    as the number of vertices in a polygonal object. Although polygonal objects are
    relatively simple, with their shape determined directly by the position of the
    vertices, the curvature at any given point of a NURBS object is influenced by
    multiple points. The exact number of points that influence a given area depends
    on the degree of the surface.
  prefs: []
  type: TYPE_NORMAL
- en: To see how this works, we'll create a script that will determine the total number
    of CVs in each direction (`U` and `V`) of a NURBS surface, and we'll look at how
    to select a particular CV.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure that you have a scene containing at least one NURBS surface.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new file, name it `getNURBSinfo.py` (or similar), and add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Select a NURBS surface and run the script. You'll see the number of CVs in each
    of the parametric directions (`U` and `V`) output to the script editor.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we use the `getAttr` command to retrieve information about
    the selected object. The `getAttr` command is short for *get attribute* and can
    be used to retrieve the value of any attribute on a given node, making it useful
    in a wide range of circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this particular situation, we''re using it to get two things per direction
    along the surface—the number of spans and the degree, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The "degree" of a NURBS surface (or curve) is the number of points that influence
    each point along the geometry and ranges from 1 (linear) to 3\. Curves and surfaces
    with degree of 1 are linear and resemble polygonal geometry. Curves and surfaces
    with degrees of greater than 1 interpolate multiple points to generate curvature.
    The total number of CVs in a curve or surface is always equal to the number of
    spans plus the degree.
  prefs: []
  type: TYPE_NORMAL
- en: 'One easy way to understand that is to think of the simplest possible curve—a
    straight line. That curve would have a single span (one segment) and would be
    of degree 1 (linear), and it would still require two points (the start and the
    end) in order to be defined. In that case, we would have:'
  prefs: []
  type: TYPE_NORMAL
- en: '*(1 span) + (degree of 1) = 2 points*'
  prefs: []
  type: TYPE_NORMAL
- en: For more complex curves, more points would be needed, but it's the same principle—the
    minimum number will always be (degree of curve) plus one (since it's impossible
    to have a curve or a surface with zero spans).
  prefs: []
  type: TYPE_NORMAL
- en: 'So, to get the total number of CVs, we use `getAttr` twice, once to get the
    spans and again to get the degree, then we add the totals, as in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, to we''ll finish off the script by selecting the first and last CVs.
    Selecting a CV on a NURBS surface is quite similar to selecting a vertex of a
    polygon, with the two following key differences:'
  prefs: []
  type: TYPE_NORMAL
- en: We use `.cv` instead of `.vtx`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to specify two indices (one for `U` and one for `V`) instead of one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Selecting the first CV is pretty easy; we just use zero for both indices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Selecting the last CV is a bit more involved and requires that we string together
    a few different parts to make sure that we end up with something like `myObj.cv[8][8]`
    in the case that the surface has nine CVs in each direction. We need to subtract
    one from the total CV number and wrap that in `str()` so that Python will allow
    us to combine it with the text. Putting this all together gives us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we could use string formatting to build up the input, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The previously mentioned discussion is based on having working with a NURBS
    surface. If we were working with a curve instead, things would be much the same,
    but we would use a single index to specify the CV rather than two, as in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Also note that when we retrieve the values for degree and span, we do not specify
    `U` or `V` because curves have only one dimension rather than two.
  prefs: []
  type: TYPE_NORMAL
- en: Creating curves
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we'll be looking at how to create curves with code. This can
    be used for a number of different purposes, such as forming the basis for further
    modeling operation or creating custom controls for complex rigs.
  prefs: []
  type: TYPE_NORMAL
- en: We'll actually be making two curves in this example—a simple one that we create
    directly and a more complex one that we create one point at a time.
  prefs: []
  type: TYPE_NORMAL
- en: Here's what we'll end up with as our output and moving both curves away from
    the origin.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating curves](img/4657_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new file and name it `makeCurves.py` or similar. Add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: If you run the preceding code, you'll end up with two curves being created—a
    square and an astroid curve.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To make a new curve, we'll want to first understand what we're trying to make.
    In the case of the square, it's easy enough. We just need to have four points—each
    half of the width away from the origin in each combination of positive and negative
    ( (-,-), (-,+), (+,+), and (+,-)).
  prefs: []
  type: TYPE_NORMAL
- en: 'To actually make the curve, we''ll use the `curve` command and specify a list
    of points. We''ll also set the degree of our curve to `1`, that is, make it linear,
    which makes sense for a square. Putting that together gives us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Note that we specify five points rather than four. If we leave it at only four
    points, we would end up with three spans rather than four, leaving one of the
    sides of our square missing. One way to address this is to simply repeat the first
    point at the end of the point list to close the curve.
  prefs: []
  type: TYPE_NORMAL
- en: For a more complex example, we'll create an **astroid curve** using some fun
    math. To make this easier, we'll create a function that will accept a parameterized
    input and output a two-element tuple with the *X* and *Y* coordinates of the curve
    for that input. We'll also append points to the curve as we go, as it is sometimes
    an easier way to approach things for more complex curves.
  prefs: []
  type: TYPE_NORMAL
- en: 'The parameterized equations for the curve can be written as:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, theta ranges from 0 to 2pi. Putting the value in terms of Python gives
    us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have a function that will give us the curve we want, we''ll create
    a new curve and add points to it one at a time. First, we make the curve and set
    it to have a degree of three (cubic) so that it''s nice and smooth, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''ll step through our range of zero to (2 * pi) and add a new point
    to the existing curve:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We start by calculating our input as 1/32nd of (2 * pi) times our index and
    passing it into our curve function. We then use the `curve` command again, but
    with a couple of changes, namely:'
  prefs: []
  type: TYPE_NORMAL
- en: We specify the curve we're working on by passing it as the first argument
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use the `append=True` flag to let Maya know that the points should be added
    to the existing curve instead of creating a new one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We specify a single point using the output of our `curveFunction` for the *X*
    and *Y* coordinates and 0 for the *Z* coordinate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although you likely won't have a need for astroid curves in your own projects,
    there are plenty of situations where you may want to create curves in a step-by-step
    fashion. For example, you might want to create a curve based on an animation sequence,
    by adding a point for the position of a given object each frame. We'll see how
    to grab positions on a frame-by-frame basis when we look at scripting for animation.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For more information on the astroid curve, have a look at its entry on the Wolfram
    MathWorld website, [http://mathworld.wolfram.com/Astroid.html](http://mathworld.wolfram.com/Astroid.html).
    That's just one of the fun curves that the site explains, along with all sorts
    of other mathematical resources that you might find useful.
  prefs: []
  type: TYPE_NORMAL
- en: Creating new polygonal faces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we'll be looking at how to create new polygonal faces with
    code, both a simple quad and a more complex example that incorporates an internal
    hole.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new file, name it `polyCreate.py` (or similar), and add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: If you run the preceding script, you'll see two new objects created, both in
    the *XY* plane—one is a simple square and the other is a square with a hole in
    the center.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `polyCreateFacet` command is fairly straightforward and expects to receive
    an array of point positions. Each point should be stored in a tuple of three values,
    each one for the *X*, *Y*, and *Z* position of the vertex.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first example, we merely call the `polyCreateFacet` command directly
    and provide the four points that make up the corners of a 2-unit square centered
    at the origin and aligned in the *XY* plane. We have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: You can also create polygons with internal holes, but in order to do that, you'll
    need to signal to Maya that you're starting a hole. To do this, you'll need to
    feed the `polyCreateFacet` command a blank point as an empty tuple.
  prefs: []
  type: TYPE_NORMAL
- en: When creating more complex faces, it can be easier to create an array to hold
    the various points and push them onto it one at a time, rather than trying to
    have a single long argument to the `polyCreateFacet` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start, once again, with four points to define a square in the *XY* plane,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to get Maya to start creating a hole in the face we''re making, we
    next add an empty tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Now we can start adding the points for the hole. In this case, we'll add points
    to make a circular hole with 32 points. This's done easily enough with a little
    bit of trigonometry. Because we're making a hole with 32 segments, we divide one
    full rotation (in radians, so `math.pi * 2`) by `32` and multiply by our index
    to get the value we feed to the trigonometric functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Putting that all together give us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we''ll have an array of 37 tuples representing 36 points plus one blank
    entry to indicate the start of a cutout region. Passing that into the `polyCreateFacet`
    command gives us the final result. We use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When creating polygonal faces, the order in which the vertices are specified
    is important. It's likely obvious that adding vertices out of order would cause
    the resulting faces to be bent in unintended ways, but the order also affects
    the direction that the face or faces **normals** will point. Always be sure to
    specify your points around the outer edge of the face that you're creating, and
    in the counter-clockwise direction, which will cause the normals to point out
    of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want the normals to point in the other direction, either specify them
    in the opposite order or explicitly reverse the normals on the created faces using
    the `polyNormal` command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The `4` variable likely seems cryptic, but the `polyNormal` command can perform
    a few different specific functions (including a few deprecated options), and the
    `normalMode` flag is how to tell Maya which one you want. For details, be sure
    to consult the Python command documentation.
  prefs: []
  type: TYPE_NORMAL
- en: If you find yourself creating complex faces, such as our second example with
    the hole, you might want to ensure that you are left with faces of no more than
    four sides. You can certainly do it by creating the faces one at a time and joining
    them (which we will do in the custom primitive example, mentioned later), or you
    can create the shape as a single face, then triangulate it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To triangulate the resulting face, run the `polyTriangulate` command after
    creating it, as in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also have Maya attempt to combine the resulting triangles into quads
    by running the `polyQuad` command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Quadrangulation doesn't always work, but it also generally doesn't hurt anything.
    Leaving **ngons** in your meshes, on the other hand, can lead to all sorts of
    problems down the road and is best avoided.
  prefs: []
  type: TYPE_NORMAL
- en: Creating new modifiers (noise)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many 3D modeling and animation packages provide a way to add a bit of random
    noise to the vertices of an object, but Maya does not. This may seem like an oversight,
    but it also provides us with a great example project.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we''ll write a script to step through all of the vertices
    of a polygonal object and move each of them slightly. Here''s an example of what
    a simple polygonal sphere looks like both before and after applying the script
    that we''ll be developing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating new modifiers (noise)](img/4657_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new script, name it `addNoise.py`, and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: If you run this code with a polygonal object selected, you'll see that each
    of the vertices is moved by a small random amount (`0.2` units).
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First off, we''ll want to make sure that we have a polygonal object selected
    by:'
  prefs: []
  type: TYPE_NORMAL
- en: Grabbing the currently selected objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determining the shape node (if any) attached to the most recently selected object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing the shape node to make sure that it's a polygonal object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we''ve done that, we''ll want to loop through each of the vertices of
    the object, but first we''ll need to know how many vertices it contains. So, we
    use the `polyEvaluate` command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we''re ready to loop through the vertices and move each one. Because we''ll
    want each axis to be independent, we''ll start by creating a variable to hold
    the offsets for each:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we''re ready to loop through the object. For each pass, we''ll want to
    set the `randAmt` array to random variables, then apply those to the position
    of the vertex:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A note on how we're setting the random amount—we want to make sure that the
    values produced range between the input value (as the maximum) and its negative
    equivalent (as the minimum).
  prefs: []
  type: TYPE_NORMAL
- en: The `random.random()` function will produce a random number between 0 and 1\.
    Multiplying it by doubling the input will give us a value between 0 and (amt *
    2), and subtracting the input value will give us the proper range.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we''ll actually move the vertices by first selecting the individual vertex
    and moving it using the `move` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that Maya does also offer a `polyMoveVertex` command, which might seem
    like a better way to go about tweaking the position of each vertex. While that
    will absolutely work, it will run much slower due to the additional overhead of
    creating another **database availability group** (**DAG**) node for each moved
    vertex. If you would like to see for yourself, try commenting out the lines that
    select and move the vertices and adding the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Try running this and see how long it takes, then comment out this, re-enable
    the select and move lines and rerun the script. You'll likely see that the `polyMoveVertex`
    version takes a significantly longer time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we''ve run through all of the vertices and moved each one slightly, we''ll
    want to make sure that we finish up by selecting the original object, thereby
    setting the user up to take further actions on the object. Take a look at the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This example would only work on polygonal objects, but it would be easy to
    extend it to work with NURBS surface or even curves as well. To do this, we would
    need to do the following two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Test for the type of geometry (`nurbsSurface` or `nurbsCurve`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alter the point selection code to reference the appropriate type of point
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One further complication is that CVs of a NURBS surface have to be accessed
    in a two-dimensional array, rather than the flat array of the polygonal surfaces
    `vtx` list.
  prefs: []
  type: TYPE_NORMAL
- en: Creating novel primitives (tetrahedron)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we'll be creating a brand new (to Maya) geometric primitive—a
    tetrahedron. Tetrahedrons are simple in principle, but would require numerous
    steps to create using Maya's interface. As such, they make a great candidate for
    scripting.
  prefs: []
  type: TYPE_NORMAL
- en: We'll be creating a script that will create a tetrahedron of a given edge width
    as a polygonal mesh.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we start writing code, we'll want to make sure that we have a good grasp
    on the math behind tetrahedrons. A tetrahedron is the simplest regular polyhedron
    that consists of four faces, each of which is an equilateral triangle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each tetrahedron consists of only four points. For convenience, we''ll name
    the three around the base **A**, **B**, and **C**, and the point at the tip **D**,
    as in the following illustration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/4657_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To make the math easier, we'll set point **A** to the origin ([0,0,0]). Because
    every side of the base is of the same length, we can find point **B** by simply
    moving along the *x* axis by the desired edge length, giving us [length, 0, 0]
    for **B**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Point **C** is only slightly more involved. First, we note that every equilateral
    triangle can be split into two similar right triangles as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Finding the *X* coordinate of point **C** is easy; all we have to do is halve
    the edge length. The *Z* coordinate is in turn equal to the height of each of
    the half triangles in the previously mentioned illustration, which we don't yet
    know. However, we *do* know the length of the other two sides, that is, the shorter
    side is half of our edge length, and the hypotenuse is just the full edge length
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, by the Pythagorean theorem, we know that:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/4657_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Or, rewriting it a bit, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/4657_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we'll need the coordinates of the tip of the tetrahedron. We'll get
    those in a way similar to how we arrived at the coordinates for **C**, in that
    we'll use another right triangle, but this one will be slightly different; it
    will be the triangle formed by point **A**, point **D**, and the point in the
    center of the base (which we'll call point **E**).
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/4657_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, let's find point **E**. Because it's the center of the base, we can just
    average the *X* and *Z* coordinates of **A**, **B**, and **C**, and we'll have
    **E**'s location. Then, we can construct a triangle that will allow us to determine
    the vertical position of point **D**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/4657_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Point **D** will have the same *X* and *Z* coordinates as **E**, but needs to
    be raised by the proper amount along the *y* axis to create a proper tetrahedron.
    To find that distance, we'll use the triangle formed by **A**, **E**, and **D**.
    The hypotenuse is, once again, a full side of the tetrahedron, so that's easy.
    The shorter base (**A**-**E**) is the distance from **A** to the center of the
    base. To find that, we can use the distance formula, making the calculation simpler
    by choosing point **A** as the origin.
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/4657_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Because both the *X* and *Z* coordinates of point **A** are zero, we get the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/4657_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once we''ve done that, we know the lengths of two of the sides of the triangle,
    and we can calculate the third by using the Pythagorean theorem once again, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/4657_03_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have a good handle on how to create a tetrahedron, we're ready to
    actually write the script.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new script and name it `makeTetrahedron.py`. Add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Run this code, and you should end up with a tetrahedron with a side length of
    5 units, with the base centered at the origin.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/4657_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First off, we calculate all the points that we'll need, as outlined in the preceding
    *Getting ready* section. Each point is a three-element array of *X*, *Y*, and
    *Z* coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first two points are easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '`pointC` is a bit more complex and requires us to use the Pythagorean theorem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to calculate the position for `pointD`, we first determine the center
    of the base, which we''ll call `pointE`. Use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can determine `pointD` by setting the *X* and *Z* coordinates to
    those of `pointE` and using the Pythagorean theorem to determine the *Y* coordinate
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we''ve done that, we can create individual faces with the `polyCreateFacet`
    command. We''ll use the `polyCreateFacet` command four times, once for each of
    the tetrahedron''s faces. We''ll also store the result into an array so that we
    can select all of the faces for final processing later. We have the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we have all of our geometry created, but we''ll want to do a
    few things to finish off the object, namely:'
  prefs: []
  type: TYPE_NORMAL
- en: Combine all the faces into a single object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move the object so that the base is centered at the origin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the object's pivot point so that it is also centered at the base.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Freeze the transformations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First off, let''s combine the faces into a single object by selecting them.
    We start by replacing the current selection by the first face, then adding each
    of the additional three faces to the selection by using `add=True` in our call
    to `cmds.select()`.We have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have all the faces selected, we can combine them with `polyUnite`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: It will cause all of the faces to be combined into a single polygonal object,
    but it's only the start. If we leave things at that, we'll end up with disconnected
    faces and multiple vertices at each of the tetrahedron's four points. To finish
    off, we'll want to make sure that vertices that are on top of each other are merged.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we''ll start by selecting all of the vertices in our model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Note that we use the `vtx` list to select vertices, but we leave out both the
    start and end indices, having just a colon. That's an easy shorthand way to refer
    to the entire contents of a list and will cause all of the vertices in our model
    to be selected. Once we've done it, we tell Maya to merge nearby vertices with
    the `polyMergeVertex` command, passing in a small threshold distance.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: This tells Maya that any vertices that are less than 0.0001 units apart should
    be merged into a single vertex. At this point, we have a proper tetrahedron with
    four faces and four vertices. Because the rest of the operations we want to perform
    deal with the object as a whole (rather than its vertices), we switch back to
    the object mode by reselecting the object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have a single object, but we want to center it. Luckily, we still have
    `pointE`, which contains the *X* and *Z* coordinates of the base''s center, relative
    to the origin. So, we''ll start by moving the combined object in the negative
    direction on *X* and *Z* by the same amount:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have the object where we want it, but its pivot point is still located
    at what used to be the origin (`pointA`). To fix it, we''ll use the `xform` command
    to move the pivot point, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The `pivots` flag will move the object's pivot to the specified location. In
    this case, we're moving it by the same amount (but in the opposite direction)
    that we moved the object, resulting in the pivot remaining at the origin, even
    though the object itself has been moved.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we'll finish off by freezing the transformations so that our object
    starts off with 0,0,0 for its position, and we will delete the construction history.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Then, we're left with a fully-formed tetrahedron, centered at the origin and
    with a clean construction history and ready for further use.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A tetrahedron is a fairly simple object, but all of the principles we used to
    create it can easily be extended to more complex shapes with more inputs.
  prefs: []
  type: TYPE_NORMAL
