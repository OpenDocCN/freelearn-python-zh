- en: Chapter 8. Managing Customer Relations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is more to an entity framework and CherryPy application code than just
    merely browsing lists. The user must be able to add new instances and edit existing
    ones.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In this chapter, we will:'
  prefs: []
  type: TYPE_NORMAL
- en: See how to display instances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to add and edit instances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to provide auto complete functionality to attributes referring to other
    entities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to implement picklists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So let's get on with it...
  prefs: []
  type: TYPE_NORMAL
- en: A critical review
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have created an object relational framework in the form of an entity
    and relation modules, it is time for a critical reappraisal.
  prefs: []
  type: TYPE_NORMAL
- en: 'A couple of larger and smaller issues may hinder us in quickly prototyping
    and implementing a database-driven application:'
  prefs: []
  type: TYPE_NORMAL
- en: We already keep an administration of the additional properties of the entity
    attributes, for example, whether an attribute has a validator function. It might
    be a good idea to store things like the preferred representation of an attribute's
    value as well. We also want to have the possibility of keeping a record of allowed
    values, so we can implement picklists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although the framework is flexible enough for a developer to quickly implement
    a database-driven application, it does not have any functionality to let an end
    user alter the database schema. It is not possible to add an attribute to an entity,
    for example. Even if this were possible, we would still need some authorization
    scheme to limit this functionality to authorized users only.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following chapters, we will tackle these limitations one-by-one and
    each step will bring us closer to implementing our final example: a customer relations
    management application. Some parts of this process require us to perform some
    pretty sophisticated Python tricks, but these parts are clearly flagged and may
    be skipped.'
  prefs: []
  type: TYPE_NORMAL
- en: Designing a Customer Relationship Management application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our first revision of CRM will start off with a bare bones implementation.
    It is about as simple as the books application and its data model is illustrated
    in the next diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing a Customer Relationship Management application](img/3746OS_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The web application will serve a single company and the users are typically
    the sales representatives and back office employees. In this basic form, an Account
    is the company we are interested in with a couple of attributes like name and
    the type of business. We also keep records of Contacts; these are people that
    may be associated with an Account. These Contacts have attributes like name, gender,
    and so on. Both Accounts and Contacts may have any number of addresses.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action implementing a basic CRM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Have a look at the following code (available as `crm1.py)`. It will define
    the entities identified in the previous section and the result, when run, will
    have a familiar look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action implementing a basic CRM](img/3746_08_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We've added a little bit of CSS styling to order the elements on the page, but
    in the final revision, we will give it a much more attractive look. Clicking on
    the **Add new** button will allow you to add a new entity.
  prefs: []
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These humble beginnings in implementing CRM were accomplished by the code in
    `crm1.py:`
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter8/crm1.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The first part is all about defining the entities and the relations between
    them according to the data model we sketched earlier. The concept is pretty much
    the same as for the books application, but for one important detail, the use of
    a **picklist** to limit the allowable choices for gender (highlighted). We will
    study these picklists in detail later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next part creates the actual CherryPy application, with a `Browse` page
    for each entity (highlighted):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter8/crm1.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The final part defines a `Root` class with an `index()` method that will force
    the user to identify himself/herself first (highlighted) and will then redirect
    the user to the [/entities](http:///entities) page, served by the `entities()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: This method will serve up a basepage with a navigation section that will allow
    the user to select a browse page for a type of entity and a content division which
    is initially empty, but will act as a container for either the chosen browse component
    or any edit or add page.
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter8/crm1.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Adding and editing values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Until now, we did not look closely at the `Display` class, although it is used
    in various incarnations within the application that we set up with CherryPy. The
    `Display` class combines a number of functions. It:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Until now, we did not look closely at the `Display` class, although it is used
    in various incarnations within the application that we set up with CherryPy. The
    `Display` class combines a number of functions. It:'
  prefs: []
  type: TYPE_NORMAL
- en: Displays detailed values of an instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allows those values to be edited
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displays a form that allows us to add a completely new instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processes the input from the edit and add forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The reason to bundle these functions is twofold: displaying the labels and
    values for reading, editing, or adding an instance shares a lot of common logic,
    and by processing the results within the same class method, we can refer to the
    `action` attribute of a`<form>` element in a way that allows us to mount an instance
    of the `Display` class from anywhere in the application tree.'
  prefs: []
  type: TYPE_NORMAL
- en: Time for action adding an instance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To understand the `Display` class, let us create a very simple application.
    Type in the following code and run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter8/crmcontact.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'When you point your browser to `http://localhost:8080`, you will be presented
    with an empty list of contacts that you may expand by clicking the **Add** button.
    This will present you with the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action adding an instance](img/3746_08_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here you may enter new values, and when you click the add button, a new contact
    will be added to the database, after which, you will return to the list of contacts,
    but now with an extra one added.
  prefs: []
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the application tree that we constructed, we mounted several instances of
    the `Display` class, each with its own initialization parameters. These parameters
    are merely stored in the instance by the `__init__()` method for referral later:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter8/display.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The most important parameter is `entity`. This will be the `Entity` class that
    we want `Display` to be able to add or edit.
  prefs: []
  type: TYPE_NORMAL
- en: '`__init__()` also takes an `edit` or `add` parameter that when set will determine
    the type of activity this instance of `Display` will perform. If neither is given,
    an instance will just be displayed without the possibility of altering its attributes.
    In the stripped down `crmcontact.py` application, we created a `ContactBrowser`
    class that holds references to two different instances of the `Display` class.
    The one in the `add` class variable is created with an `add` attribute set to
    `True`, while the one in the `edit` variable is created with an `edit` attribute
    set to `True`. The **Add new** button in the browser is equipped with a click
    handler that will replace the browse list with the form that will be served by
    the `Display` instance that was created with the `add` argument.'
  prefs: []
  type: TYPE_NORMAL
- en: Time for action editing an instance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We also want to open a form that will allow the user to edit an existing instance
    when double-clicked in the browse list. In the stripped down application that
    we created in the previous section, we merely created the `ContactBrowser` class
    as a subclass of `Browse`. If we want to add an additional double-click handler
    to the browse list element, we will have to override the `index()` method.
  prefs: []
  type: TYPE_NORMAL
- en: In the definition of the `ContactBrowser` class, add the following to the definition
    of the `index()` method (the complete code is available as `crmcontactedit.py):`
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter8/crmcontactedit.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The code merely gathers the output from the original `index()` method of the
    `Browse` class (highlighted) and adds a`<script>` element to it that will add
    a double-click handler to each`<tr>` element in the browse list. This click handler
    will replace the body with the form served by the edit URL, which will be passed
    an `id` parameter equal to the `id` attribute of the`<tr>` element.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run `crmcontactedit.py`, you will be presented with the same list of
    contacts as before and if it is empty, you may first need to add one or more contacts.
    Once these are present, you can double-click on any of them to be presented with
    an edit screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action editing an instance](img/3746_08_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This looks very similar to the add screen, but changing values here and clicking
    the **Edit** button will alter instead of adding a contact and returning you to
    the list of contacts.
  prefs: []
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us have a look at how the `Display` class handles the editing of instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'All interaction by an instance of the `Display` class is provided by a single
    method: `index()` (full code is available in `display.py):`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter8/display.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Depending on the parameters passed to the index() method and the information
    stored when the `Display` instance was initialized, `index()` performs different
    but similar actions.
  prefs: []
  type: TYPE_NORMAL
- en: When called without the `add` or `edit` parameter, `index()` is called to display,
    edit, or add an instance and the first part of the code is skipped.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `add` and `edit` parameters to `index()` are different from the ones passed
    to `__init__()`.
  prefs: []
  type: TYPE_NORMAL
- en: First, we check if the `id` parameter is present (highlighted). If not, we're
    expected to present an empty form to let the user enter the attributes for an
    all new instance. However, if an `id` parameter is present, we have to display
    a form with values.
  prefs: []
  type: TYPE_NORMAL
- en: To present such a form, we retrieve the entity with the given ID and check which
    columns we have to display and see if such a column is an attribute of the entity
    we are dealing with (highlighted). If so, we append to the `kv` list a`<label>`
    element with the display name of the column and an`<input>` or`<select>` element,
    depending on whether we are dealing with an unrestricted text field or a picklist.
    If we are dealing with a picklist, the available choices are added as`<option>`
    elements.
  prefs: []
  type: TYPE_NORMAL
- en: If the column to display is not an attribute of the entity but another entity
    class, we are dealing with a relation. Here we also add a`<label>` element and
    an`<input>` field, but we also add JavaScript code to the `autocomplete` variable
    that when executed will convert this`<input>` element into an autocomplete widget,
    which will retrieve its choices from the `autocomplete()` method in this same
    `Display` instance.
  prefs: []
  type: TYPE_NORMAL
- en: Only if this `Display` instance was initialized to perform the edit function
    (highlighted), we append a submit button and set the `action` variable to edit
    (the last part of the URL the values of the`<form>` element will be submitted
    to). We also add an extra hidden input element that holds the ID of the instance
    we are editing.
  prefs: []
  type: TYPE_NORMAL
- en: Constructing the empty form to add a new instance is almost the same exercise,
    only in this case, no values are filled in any of the`<input>` elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final lines of code (highlighted) are shared again and used to deliver
    the`<form>` element based on the components just created for either an edit/display
    form or an empty add form together with any JavaScript generated to implement
    the autocomplete features. A typical sample of HTML generated for an edit form
    may look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If the `index()` method of `Display` is called with either the `add` or the
    `edit` parameter present (typically the result of clicking a submit button in
    a generated edit or add form), different code is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter8/display.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Only one of `edit` or `add` should be present; if both are present we raise
    an exception. If the user is not authenticated, editing an instance or adding
    a new one is not allowed, and we unceremoniously redirect him/her to the homepage
    (highlighted).
  prefs: []
  type: TYPE_NORMAL
- en: If the `add` parameter is present, we will be creating a brand new instance.
    The first item of order is to check all incoming parameters to see if they are
    either an attribute of the entity that we will be creating (highlighted) or the
    name of a related entity. If not, an exception is raised.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to create the new entity (highlighted) and establish any relations.
  prefs: []
  type: TYPE_NORMAL
- en: Adding relations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the things we silently glossed over in the previous sections was the
    functionality to define relations between entities. Sure, the implementation of
    the `Display` class did allow for the creation of new instances, but we did not
    address how to define a relation, even though `Display` is already perfectly capable
    of showing columns that point to related entities like authors.
  prefs: []
  type: TYPE_NORMAL
- en: We could have hardcoded this behavior into specific implementations of `Display`
    like we did earlier when we implemented the first version of the books application,
    but this doesn't play well with the idea of creating components that can figure
    out those things for themselves, leaving the developer of the web application
    with fewer things to worry about.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous incarnation of the `relation` module was not quite up to this:
    we could define and administer a relation all right, but we''d have to do that
    by referring explicitly to an instance of a `Relation` class.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Because this isn''t intuitive, we created a second version of the `relation`
    module that allows us to use the `add()` method inserted into the class definition
    of an `Entity` by the metaclass that creates a new relation. We do not have to
    care about the details: if we use `add()` to establish a relation between two
    entities, this is all taken care of.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that we can complete the add functionality of the `Display` class.
    For each column that refers to another entity (for example, the `Author` column
    of a book), we now implement some way for the user to make a choice, for example,
    with the autocomplete functionality, and process this choice in a rather simple
    manner: if it is empty, we do not add a relation, if it refers to a existing entity,
    add the relation and if not, create the related entity first before adding it.'
  prefs: []
  type: TYPE_NORMAL
- en: We now have the functionality to refer to existing related items by their primary
    attribute or define a new one. However, for the end user, it might be very convenient
    to have auto completion on input fields that refer to related entities. This not
    only may save time, it also prevents inadvertently adding new entities when a
    typing error is made.
  prefs: []
  type: TYPE_NORMAL
- en: 'In previous chapters, we already encountered auto completion with the help
    of jQuery UI''s autocomplete widget and we implemented the server-side functionality
    to retrieve lists of possible completions. All we have to do now is to make this
    functionality available in a manner that is independent from the actual related
    entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter8/display.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The HTML and JavaScript that is generated by the `index()` method of the `Display`
    class will ensure that the preceding `autocomplete()` method will be called with
    the name of the entity of which we want to retrieve column values.
  prefs: []
  type: TYPE_NORMAL
- en: Any related class that the instance we are editing refers to is stored in the
    `self.columns` instance variable, just like the names of the regular attributes.
    The highlighted line, therefore, collects those column names that are actually
    classes and creates a dictionary indexed by name, which holds the corresponding
    classes as values.
  prefs: []
  type: TYPE_NORMAL
- en: When we use the name of the related entity passed to the `autocomplete()` method
    as the index, we will get hold of the class. This class is used in the next line
    to retrieve all column values for the column marked as the primary column. The
    final code to return a JSON encoded list of all those values that start with the
    term argument is the same as implemented earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Dictionary comprehensions are a new addition to Python 3.x, so it might be
    enlightening to write out the highlighted line in the example code in a more traditional
    manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Picklists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we examined the code to generate a form to edit an instance, we did not
    look into the details of implementing picklists. Picklists are a great way to
    reduce input errors. Anywhere a limited list of values is permitted, we can use
    a picklist, thereby preventing the user from inadvertently entering a value that
    is not allowed. In doing so, we can also associate each possible value with a
    meaningful label.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We already have the possibility to add a validation function, but this function
    only checks the input; it does not provide us with a list of possible choices.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action implementing picklists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What we need is a way to indicate that an entity attribute is a picklist. Run
    the following code (available as `fruit.py)` and point your browser to [http://localhost:8080](http://localhost:8080).
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter8/fruit.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Click the **Add** button to create a new fruit instance. The `color` and `taste`
    attributes are defined as picklists, and clicking on the **Color** attribute,
    for example, may look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action implementing picklists](img/3746_08_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the `entity.py` file, we added a `Picklist` class to store the available
    choices and their values:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter8/entity.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `Picklist` class is primarily a container for an `OrderedDict` (highlighted)
    and may be initialized either by a list or by passing any number of keywords to
    the `__init__()` method. However, the order of these keywords is not preserved,
    so even though we defined the color attribute of the fruit entity with this validate
    argument `validate= Picklist(Yellow=1,Green=2,Orange=0)`, the order in the drop-down
    box was **Orange, Green**, and **Yellow**.
  prefs: []
  type: TYPE_NORMAL
- en: So although convenient, passing keywords makes the use of an `OrderedDict` rather
    pointless. Therefore, the `__init__()` method also accepts a list of tuples of
    key/value pairs and if present, uses this list to initialize the dictionary. Now
    if we would use `validate= Picklist([('Yellow',1),('Green',2),('Orange',0)])`,
    the order would be preserved, as shown in the following screenshot. It has the
    added benefit of allowing us to specify any string as a key and not just strings
    that are valid Python identifiers.
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened?](img/3746_08_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We already saw in the `index()` method of the `Display` class how to retrieve
    a list of possible choices. An `Entity` itself also needs to know how to deal
    with attributes that are picklists, for example, when it updates such an attribute.
    The `__setattr__()` method of the `AbstractEntity` class will have to be adapted
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter8/entity.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The added lines (highlighted) check whether any validator is a `Picklist`,
    and if it is, tries to retrieve the value associated with the key. If this fails,
    it checks if the value that is entered is one of the values allowed. This way,
    it is valid to update a picklist attribute both with a key as well as a value.
    Given a `fruit` instance of the `Fruit` class defined earlier, the following lines
    are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We learned a lot in this chapter about how to present the end user with forms
    to manipulate instances in a way that does not need any hardcoded information.
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, we covered how to display instances, add, and edit them, how to
    provide autocomplete functionality to attributes referring to other entities,
    and how to implement picklists.
  prefs: []
  type: TYPE_NORMAL
- en: All these items helped us to design and implement the first revision of a CRM
    application. Of course, there is more to a CRM application than just Accounts
    and Contacts and that is what we will look into in the next chapter.
  prefs: []
  type: TYPE_NORMAL
