- en: Chapter 8. Managing Customer Relations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章 管理客户关系
- en: There is more to an entity framework and CherryPy application code than just
    merely browsing lists. The user must be able to add new instances and edit existing
    ones.
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 实体框架和CherryPy应用代码不仅仅是浏览列表。用户必须能够添加新实例并编辑现有实例。
- en: 'In this chapter, we will:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: See how to display instances
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看如何显示实例
- en: How to add and edit instances
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何添加和编辑实例
- en: How to provide auto complete functionality to attributes referring to other
    entities
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何为引用其他实体的属性提供自动完成功能
- en: How to implement picklists
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何实现选择列表
- en: So let's get on with it...
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始吧...
- en: A critical review
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一次批判性回顾
- en: Now that we have created an object relational framework in the form of an entity
    and relation modules, it is time for a critical reappraisal.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个以实体和关系模块形式存在的对象关系框架，是时候进行一次批判性的评估了。
- en: 'A couple of larger and smaller issues may hinder us in quickly prototyping
    and implementing a database-driven application:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一些较大和较小的问题可能会阻碍我们快速原型设计和实现数据库驱动的应用：
- en: We already keep an administration of the additional properties of the entity
    attributes, for example, whether an attribute has a validator function. It might
    be a good idea to store things like the preferred representation of an attribute's
    value as well. We also want to have the possibility of keeping a record of allowed
    values, so we can implement picklists
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经对实体属性的附加属性进行了管理，例如，一个属性是否有验证函数。存储诸如属性值的首选表示这样的信息可能是个好主意。我们还希望有记录允许值的可能性，这样我们就可以实现选择列表
- en: Although the framework is flexible enough for a developer to quickly implement
    a database-driven application, it does not have any functionality to let an end
    user alter the database schema. It is not possible to add an attribute to an entity,
    for example. Even if this were possible, we would still need some authorization
    scheme to limit this functionality to authorized users only.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管框架足够灵活，可以让开发者快速实现数据库驱动的应用，但它没有让最终用户更改数据库架构的功能。例如，无法向实体添加属性。即使这可能实现，我们仍然需要一个授权方案来限制此功能仅对授权用户可用。
- en: 'In the following chapters, we will tackle these limitations one-by-one and
    each step will bring us closer to implementing our final example: a customer relations
    management application. Some parts of this process require us to perform some
    pretty sophisticated Python tricks, but these parts are clearly flagged and may
    be skipped.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将逐一解决这些限制，每一步都会让我们更接近实现最终示例：客户关系管理应用。这个过程的一些部分需要我们执行一些相当复杂的Python技巧，但这些部分会被明确标记，并且可以跳过。
- en: Designing a Customer Relationship Management application
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计客户关系管理应用
- en: 'Our first revision of CRM will start off with a bare bones implementation.
    It is about as simple as the books application and its data model is illustrated
    in the next diagram:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对CRM的第一个修订版将从裸骨实现开始。它和书籍应用一样简单，其数据模型在下图中展示：
- en: '![Designing a Customer Relationship Management application](img/3746OS_08_01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![设计客户关系管理应用](img/3746OS_08_01.jpg)'
- en: The web application will serve a single company and the users are typically
    the sales representatives and back office employees. In this basic form, an Account
    is the company we are interested in with a couple of attributes like name and
    the type of business. We also keep records of Contacts; these are people that
    may be associated with an Account. These Contacts have attributes like name, gender,
    and so on. Both Accounts and Contacts may have any number of addresses.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 网络应用将服务于单一公司，用户通常是销售代表和后台员工。在这个基本形式中，账户是我们感兴趣的公司，具有一些属性，如名称和业务类型。我们还记录了联系人；这些人与账户相关联。这些联系人具有姓名、性别等属性。账户和联系人都可以有任意数量的地址。
- en: Time for action implementing a basic CRM
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施基本CRM的时间
- en: 'Have a look at the following code (available as `crm1.py)`. It will define
    the entities identified in the previous section and the result, when run, will
    have a familiar look:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的代码（作为`crm1.py`提供），它将定义前一部分中标识的实体，当运行时，结果将看起来很熟悉：
- en: '![Time for action implementing a basic CRM](img/3746_08_002.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![实施基本CRM的时间](img/3746_08_002.jpg)'
- en: We've added a little bit of CSS styling to order the elements on the page, but
    in the final revision, we will give it a much more attractive look. Clicking on
    the **Add new** button will allow you to add a new entity.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经添加了一些CSS样式来排列页面上的元素，但在最终修订中，我们将给它一个更加吸引人的外观。点击**添加新**按钮将允许您添加一个新的实体。
- en: What just happened?
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: These humble beginnings in implementing CRM were accomplished by the code in
    `crm1.py:`
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现CRM的这些朴素开始中，是通过`crm1.py`中的代码完成的：
- en: '**Chapter8/crm1.py**'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**Chapter8/crm1.py**'
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first part is all about defining the entities and the relations between
    them according to the data model we sketched earlier. The concept is pretty much
    the same as for the books application, but for one important detail, the use of
    a **picklist** to limit the allowable choices for gender (highlighted). We will
    study these picklists in detail later in this chapter.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分是关于根据我们之前绘制的数据模型定义实体及其之间的关系。这个概念与书籍应用程序几乎相同，但有一个重要的细节，即使用**下拉列表**来限制性别（突出显示）的可选选择。我们将在本章后面详细研究这些下拉列表。
- en: 'The next part creates the actual CherryPy application, with a `Browse` page
    for each entity (highlighted):'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分创建实际的CherryPy应用程序，为每个实体创建一个`Browse`页面（突出显示）：
- en: '**Chapter8/crm1.py**'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**Chapter8/crm1.py**'
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The final part defines a `Root` class with an `index()` method that will force
    the user to identify himself/herself first (highlighted) and will then redirect
    the user to the [/entities](http:///entities) page, served by the `entities()`
    method.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的部分定义了一个带有`index()`方法的`Root`类，该方法将强制用户首先进行自我识别（突出显示），然后会将用户重定向到由`entities()`方法提供的[/entities](http:///entities)页面。
- en: This method will serve up a basepage with a navigation section that will allow
    the user to select a browse page for a type of entity and a content division which
    is initially empty, but will act as a container for either the chosen browse component
    or any edit or add page.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法将提供包含导航部分的基页，用户可以通过它选择实体类型的浏览页面，以及一个最初为空的内容区域，但将作为所选浏览组件或任何编辑或添加页面的容器。
- en: '**Chapter8/crm1.py**'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**Chapter8/crm1.py**'
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Adding and editing values
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加和编辑值
- en: 'Until now, we did not look closely at the `Display` class, although it is used
    in various incarnations within the application that we set up with CherryPy. The
    `Display` class combines a number of functions. It:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们没有仔细查看`Display`类，尽管它在用CherryPy设置的应用程序的各种形态中都被使用。`Display`类结合了多个功能。它：
- en: 'Until now, we did not look closely at the `Display` class, although it is used
    in various incarnations within the application that we set up with CherryPy. The
    `Display` class combines a number of functions. It:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们没有仔细查看`Display`类，尽管它在用CherryPy设置的应用程序的各种形态中都被使用。`Display`类结合了多个功能。它：
- en: Displays detailed values of an instance
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示实例的详细值
- en: Allows those values to be edited
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许编辑这些值
- en: Displays a form that allows us to add a completely new instance
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示一个表单，允许我们添加一个全新的实例
- en: Processes the input from the edit and add forms
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理来自编辑和添加表单的输入
- en: 'The reason to bundle these functions is twofold: displaying the labels and
    values for reading, editing, or adding an instance shares a lot of common logic,
    and by processing the results within the same class method, we can refer to the
    `action` attribute of a`<form>` element in a way that allows us to mount an instance
    of the `Display` class from anywhere in the application tree.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些功能捆绑在一起的原因有两个：显示标签和值以供阅读、编辑或添加实例共享很多共同逻辑，并且通过在同一个类方法中处理结果，我们可以以允许我们在应用程序树中的任何位置挂载`Display`类实例的方式引用`<form>`元素的`action`属性。
- en: Time for action adding an instance
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加实例的行动时间
- en: 'To understand the `Display` class, let us create a very simple application.
    Type in the following code and run it:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解`Display`类，让我们创建一个非常简单的应用程序。输入以下代码并运行它：
- en: '**Chapter8/crmcontact.py**'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**Chapter8/crmcontact.py**'
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When you point your browser to `http://localhost:8080`, you will be presented
    with an empty list of contacts that you may expand by clicking the **Add** button.
    This will present you with the following screen:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将浏览器指向`http://localhost:8080`时，您将看到一个空的联系人列表，您可以通过点击**添加**按钮来扩展它。这将显示以下屏幕：
- en: '![Time for action adding an instance](img/3746_08_003.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![添加实例的行动时间](img/3746_08_003.jpg)'
- en: Here you may enter new values, and when you click the add button, a new contact
    will be added to the database, after which, you will return to the list of contacts,
    but now with an extra one added.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里你可以输入新值，当你点击添加按钮时，一个新的联系人将被添加到数据库中，之后你将返回到联系人列表，但现在多了一个新添加的联系人。
- en: What just happened?
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: 'In the application tree that we constructed, we mounted several instances of
    the `Display` class, each with its own initialization parameters. These parameters
    are merely stored in the instance by the `__init__()` method for referral later:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们构建的应用程序树中，我们挂载了几个`Display`类的实例，每个实例都有自己的初始化参数。这些参数仅通过`__init__()`方法存储在实例中，以供以后参考：
- en: '**Chapter8/display.py**'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**第8章/display.py**'
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The most important parameter is `entity`. This will be the `Entity` class that
    we want `Display` to be able to add or edit.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的参数是`entity`。这将是我们希望`Display`能够添加或编辑的`Entity`类。
- en: '`__init__()` also takes an `edit` or `add` parameter that when set will determine
    the type of activity this instance of `Display` will perform. If neither is given,
    an instance will just be displayed without the possibility of altering its attributes.
    In the stripped down `crmcontact.py` application, we created a `ContactBrowser`
    class that holds references to two different instances of the `Display` class.
    The one in the `add` class variable is created with an `add` attribute set to
    `True`, while the one in the `edit` variable is created with an `edit` attribute
    set to `True`. The **Add new** button in the browser is equipped with a click
    handler that will replace the browse list with the form that will be served by
    the `Display` instance that was created with the `add` argument.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__()`还接受一个`edit`或`add`参数，当设置时，将确定此`Display`实例将执行的活动类型。如果没有给出任何一个，实例将仅显示，没有更改其属性的可能性。在简化的`crmcontact.py`应用程序中，我们创建了一个`ContactBrowser`类，该类包含对两个不同的`Display`类实例的引用。`add`类变量中的实例使用`add`属性设置为`True`创建，而`edit`变量中的实例使用`edit`属性设置为`True`创建。浏览器中的**添加新**按钮配备了点击处理程序，该处理程序将用由带有`add`参数创建的`Display`实例提供的表单替换浏览列表。'
- en: Time for action editing an instance
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编辑实例的时间
- en: We also want to open a form that will allow the user to edit an existing instance
    when double-clicked in the browse list. In the stripped down application that
    we created in the previous section, we merely created the `ContactBrowser` class
    as a subclass of `Browse`. If we want to add an additional double-click handler
    to the browse list element, we will have to override the `index()` method.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望打开一个表单，允许用户在浏览列表中双击时编辑现有实例。在上一节中创建的简化应用程序中，我们仅创建了`ContactBrowser`类作为`Browse`类的子类。如果我们想向浏览列表元素添加一个额外的双击处理程序，我们必须重写`index()`方法。
- en: In the definition of the `ContactBrowser` class, add the following to the definition
    of the `index()` method (the complete code is available as `crmcontactedit.py):`
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ContactBrowser`类的定义中，向`index()`方法的定义中添加以下内容（完整的代码可在`crmcontactedit.py`中找到）：`
- en: '**Chapter8/crmcontactedit.py**'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**第8章/crmcontactedit.py**'
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The code merely gathers the output from the original `index()` method of the
    `Browse` class (highlighted) and adds a`<script>` element to it that will add
    a double-click handler to each`<tr>` element in the browse list. This click handler
    will replace the body with the form served by the edit URL, which will be passed
    an `id` parameter equal to the `id` attribute of the`<tr>` element.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 代码只是收集了`Browse`类原始`index()`方法的输出（突出显示），并向其中添加了一个`<script>`元素，该元素将为浏览列表中的每个`<tr>`元素添加一个双击处理程序。此点击处理程序将用由编辑URL提供的表单替换主体，该表单将传递一个`id`参数，其值等于`<tr>`元素的`id`属性。
- en: 'If you run `crmcontactedit.py`, you will be presented with the same list of
    contacts as before and if it is empty, you may first need to add one or more contacts.
    Once these are present, you can double-click on any of them to be presented with
    an edit screen:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行`crmcontactedit.py`，你将看到与之前相同的联系人列表，如果它是空的，你可能首先需要添加一个或多个联系人。一旦这些联系人存在，你可以双击任何一个来打开编辑屏幕：
- en: '![Time for action editing an instance](img/3746_08_004.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![编辑实例的时间](img/3746_08_004.jpg)'
- en: This looks very similar to the add screen, but changing values here and clicking
    the **Edit** button will alter instead of adding a contact and returning you to
    the list of contacts.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来非常类似于添加屏幕，但在这里更改值并点击**编辑**按钮将修改而不是添加联系人并返回联系人列表。
- en: What just happened?
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: Let us have a look at how the `Display` class handles the editing of instances.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`Display`类是如何处理实例编辑的。
- en: 'All interaction by an instance of the `Display` class is provided by a single
    method: `index()` (full code is available in `display.py):`'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`Display`类的实例的所有交互都由一个单独的方法提供：`index()`（完整代码可在`display.py`中找到）：`'
- en: '**Chapter8/display.py**'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**Chapter8/display.py**'
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Depending on the parameters passed to the index() method and the information
    stored when the `Display` instance was initialized, `index()` performs different
    but similar actions.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 根据`index()`方法传递的参数和初始化`Display`实例时存储的信息，`index()`执行不同的但相似的操作。
- en: When called without the `add` or `edit` parameter, `index()` is called to display,
    edit, or add an instance and the first part of the code is skipped.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有`add`或`edit`参数被调用时，`index()`函数被用来显示、编辑或添加一个实例，并且代码的前一部分被跳过。
- en: Note
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `add` and `edit` parameters to `index()` are different from the ones passed
    to `__init__()`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`index()`函数的`add`和`edit`参数与传递给`__init__()`的参数不同。'
- en: First, we check if the `id` parameter is present (highlighted). If not, we're
    expected to present an empty form to let the user enter the attributes for an
    all new instance. However, if an `id` parameter is present, we have to display
    a form with values.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查`id`参数是否存在（突出显示）。如果没有，我们预计将展示一个空表单，让用户输入新实例的属性。然而，如果存在`id`参数，我们必须显示一个带有值的表单。
- en: To present such a form, we retrieve the entity with the given ID and check which
    columns we have to display and see if such a column is an attribute of the entity
    we are dealing with (highlighted). If so, we append to the `kv` list a`<label>`
    element with the display name of the column and an`<input>` or`<select>` element,
    depending on whether we are dealing with an unrestricted text field or a picklist.
    If we are dealing with a picklist, the available choices are added as`<option>`
    elements.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示这样的表单，我们检索具有给定ID的实体，并检查我们必须显示哪些列，并查看这样的列是否是我们正在处理的实体的属性（突出显示）。如果是这样，我们将一个带有列显示名称的`<label>`元素和一个`<input>`或`<select>`元素追加到`kv`列表中，具体取决于我们是否处理一个不受限制的文本字段或一个选择列表。如果我们处理一个选择列表，可用的选项将被添加为`<option>`元素。
- en: If the column to display is not an attribute of the entity but another entity
    class, we are dealing with a relation. Here we also add a`<label>` element and
    an`<input>` field, but we also add JavaScript code to the `autocomplete` variable
    that when executed will convert this`<input>` element into an autocomplete widget,
    which will retrieve its choices from the `autocomplete()` method in this same
    `Display` instance.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要显示的列不是实体的属性而是另一个实体类，我们正在处理一个关系。在这里，我们也添加了一个`<label>`元素和一个`<input>`字段，但我们还向`autocomplete`变量中添加了JavaScript代码，当执行时，将这个`<input>`元素转换成一个自动完成小部件，它将从同一个`Display`实例的`autocomplete()`方法中检索其选项。
- en: Only if this `Display` instance was initialized to perform the edit function
    (highlighted), we append a submit button and set the `action` variable to edit
    (the last part of the URL the values of the`<form>` element will be submitted
    to). We also add an extra hidden input element that holds the ID of the instance
    we are editing.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当这个`Display`实例被初始化为执行编辑功能（突出显示）时，我们才追加一个提交按钮并将`action`变量设置为编辑（`<form>`元素的值将被提交到URL的最后部分）。我们还添加了一个额外的隐藏输入元素，它包含我们正在编辑的实例的ID。
- en: Constructing the empty form to add a new instance is almost the same exercise,
    only in this case, no values are filled in any of the`<input>` elements.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 构建空表单以添加新实例几乎是一项相同的练习，只是在这次操作中，没有任何`<input>`元素中填写了值。
- en: 'The final lines of code (highlighted) are shared again and used to deliver
    the`<form>` element based on the components just created for either an edit/display
    form or an empty add form together with any JavaScript generated to implement
    the autocomplete features. A typical sample of HTML generated for an edit form
    may look like this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的最后几行（突出显示）再次被共享并用于根据刚刚创建的组件来传递`<form>`元素，无论是编辑/显示表单还是空白的添加表单，以及任何用于实现自动完成功能的JavaScript代码。一个典型的用于编辑表单生成的HTML示例可能如下所示：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If the `index()` method of `Display` is called with either the `add` or the
    `edit` parameter present (typically the result of clicking a submit button in
    a generated edit or add form), different code is executed:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`Display`类的`index()`方法被调用时带有`add`或`edit`参数（通常是点击生成的编辑或添加表单中的提交按钮的结果），则会执行不同的代码：
- en: '**Chapter8/display.py**'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**Chapter8/display.py**'
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Only one of `edit` or `add` should be present; if both are present we raise
    an exception. If the user is not authenticated, editing an instance or adding
    a new one is not allowed, and we unceremoniously redirect him/her to the homepage
    (highlighted).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 只应有一个`edit`或`add`参数存在；如果两者都存在，我们将引发异常。如果用户未认证，则不允许编辑实例或添加新实例，并且我们将他/她无礼地重定向到主页（突出显示）。
- en: If the `add` parameter is present, we will be creating a brand new instance.
    The first item of order is to check all incoming parameters to see if they are
    either an attribute of the entity that we will be creating (highlighted) or the
    name of a related entity. If not, an exception is raised.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在`add`参数，我们将创建一个新的实例。首要任务是检查所有传入的参数，看它们是否是我们将要创建的实体的属性（突出显示）或相关实体的名称。如果不是，将引发异常。
- en: The next step is to create the new entity (highlighted) and establish any relations.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建新的实体（突出显示）并建立任何关系。
- en: Adding relations
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加关系
- en: One of the things we silently glossed over in the previous sections was the
    functionality to define relations between entities. Sure, the implementation of
    the `Display` class did allow for the creation of new instances, but we did not
    address how to define a relation, even though `Display` is already perfectly capable
    of showing columns that point to related entities like authors.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们默默地忽略了一件事，那就是定义实体之间关系的功能。当然，`Display`类的实现确实允许创建新实例，但我们没有解决如何定义关系的问题，尽管`Display`已经完全能够显示指向相关实体（如作者）的列。
- en: We could have hardcoded this behavior into specific implementations of `Display`
    like we did earlier when we implemented the first version of the books application,
    but this doesn't play well with the idea of creating components that can figure
    out those things for themselves, leaving the developer of the web application
    with fewer things to worry about.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以将这种行为硬编码到`Display`的具体实现中，就像我们之前在实现图书应用的第一版时做的那样，但这与创建能够自己处理这些事情的组件的想法不太相符，这会让网络应用的开发者有更少的事情要担心。
- en: 'The previous incarnation of the `relation` module was not quite up to this:
    we could define and administer a relation all right, but we''d have to do that
    by referring explicitly to an instance of a `Relation` class.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的`relation`模块版本并不完全符合这个要求：我们可以定义和管理关系，但我们必须通过明确引用`Relation`类的一个实例来做这件事。
- en: 'Because this isn''t intuitive, we created a second version of the `relation`
    module that allows us to use the `add()` method inserted into the class definition
    of an `Entity` by the metaclass that creates a new relation. We do not have to
    care about the details: if we use `add()` to establish a relation between two
    entities, this is all taken care of.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这并不直观，我们创建了一个`relation`模块的第二版，允许我们使用由创建新关系的元类插入到`Entity`类定义中的`add()`方法。我们不必关心细节：如果我们使用`add()`在两个实体之间建立关系，所有这些都会得到处理。
- en: 'This means that we can complete the add functionality of the `Display` class.
    For each column that refers to another entity (for example, the `Author` column
    of a book), we now implement some way for the user to make a choice, for example,
    with the autocomplete functionality, and process this choice in a rather simple
    manner: if it is empty, we do not add a relation, if it refers to a existing entity,
    add the relation and if not, create the related entity first before adding it.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以完成`Display`类的添加功能。对于每个指向另一个实体（例如，书的`Author`列）的列，我们现在实现了一种让用户进行选择的方式，例如，使用自动完成功能，并以相对简单的方式处理这个选择：如果它是空的，我们不添加关系；如果它指向一个现有实体，添加关系；如果不是，首先创建相关实体，然后再添加它。
- en: We now have the functionality to refer to existing related items by their primary
    attribute or define a new one. However, for the end user, it might be very convenient
    to have auto completion on input fields that refer to related entities. This not
    only may save time, it also prevents inadvertently adding new entities when a
    typing error is made.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了通过其主属性引用现有相关项或定义新属性的功能。然而，对于最终用户来说，在引用相关实体的输入字段上实现自动完成可能非常方便。这不仅可能节省时间，还可以防止在输入错误时意外添加新实体。
- en: 'In previous chapters, we already encountered auto completion with the help
    of jQuery UI''s autocomplete widget and we implemented the server-side functionality
    to retrieve lists of possible completions. All we have to do now is to make this
    functionality available in a manner that is independent from the actual related
    entity:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们已经遇到了使用jQuery UI的自动完成小部件的自动完成，并实现了检索可能完成列表的服务器端功能。我们现在需要以独立于实际相关实体的方式提供此功能：
- en: '**Chapter8/display.py**'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**第8章/display.py**'
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The HTML and JavaScript that is generated by the `index()` method of the `Display`
    class will ensure that the preceding `autocomplete()` method will be called with
    the name of the entity of which we want to retrieve column values.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`Display`类的`index()`方法生成的HTML和JavaScript将确保调用`autocomplete()`方法，并传入我们想要检索列值的实体名称。'
- en: Any related class that the instance we are editing refers to is stored in the
    `self.columns` instance variable, just like the names of the regular attributes.
    The highlighted line, therefore, collects those column names that are actually
    classes and creates a dictionary indexed by name, which holds the corresponding
    classes as values.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在编辑的实例所引用的任何相关类都存储在`self.columns`实例变量中，就像常规属性的名称一样。因此，高亮行收集了那些实际上是类的列名称，并创建了一个按名称索引的字典，其中包含相应的类作为值。
- en: When we use the name of the related entity passed to the `autocomplete()` method
    as the index, we will get hold of the class. This class is used in the next line
    to retrieve all column values for the column marked as the primary column. The
    final code to return a JSON encoded list of all those values that start with the
    term argument is the same as implemented earlier.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用传递给`autocomplete()`方法的关联实体名称作为索引时，我们将获取该类。这个类在下一行用于检索标记为主列的所有列值。返回一个JSON编码的值列表的最终代码与之前实现的方式相同。
- en: Note
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Dictionary comprehensions are a new addition to Python 3.x, so it might be
    enlightening to write out the highlighted line in the example code in a more traditional
    manner:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 字典推导式是Python 3.x的新增功能，因此将示例代码中的高亮行以更传统的方式写出来可能会有所启发：
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Picklists
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择列表
- en: When we examined the code to generate a form to edit an instance, we did not
    look into the details of implementing picklists. Picklists are a great way to
    reduce input errors. Anywhere a limited list of values is permitted, we can use
    a picklist, thereby preventing the user from inadvertently entering a value that
    is not allowed. In doing so, we can also associate each possible value with a
    meaningful label.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们检查生成编辑实例表单的代码时，我们没有深入研究实现选择列表的细节。选择列表是一种减少输入错误的好方法。在任何允许有限值列表的地方，我们都可以使用选择列表，从而防止用户意外输入不允许的值。这样做，我们还可以将每个可能的值与一个有意义的标签关联起来。
- en: Note
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We already have the possibility to add a validation function, but this function
    only checks the input; it does not provide us with a list of possible choices.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了添加验证函数的可能性，但这个函数只检查输入；它不为我们提供一个可能的选项列表。
- en: Time for action implementing picklists
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现选择列表的行动时间
- en: What we need is a way to indicate that an entity attribute is a picklist. Run
    the following code (available as `fruit.py)` and point your browser to [http://localhost:8080](http://localhost:8080).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的是一个方法来指示实体属性是一个选择列表。运行以下代码（作为`fruit.py`提供）并将您的浏览器指向[http://localhost:8080](http://localhost:8080)。
- en: '**Chapter8/fruit.py**'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**第8章/fruit.py**'
- en: '[PRE11]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Click the **Add** button to create a new fruit instance. The `color` and `taste`
    attributes are defined as picklists, and clicking on the **Color** attribute,
    for example, may look like this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**添加**按钮创建一个新的水果实例。`color`和`taste`属性被定义为选择列表，例如，点击**颜色**属性可能看起来像这样：
- en: '![Time for action implementing picklists](img/3746_08_005.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![实现选择列表的行动时间](img/3746_08_005.jpg)'
- en: What just happened?
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: 'In the `entity.py` file, we added a `Picklist` class to store the available
    choices and their values:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在`entity.py`文件中，我们添加了一个`Picklist`类来存储可用的选项及其值：
- en: '**Chapter8/entity.py**'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**第8章/entity.py**'
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `Picklist` class is primarily a container for an `OrderedDict` (highlighted)
    and may be initialized either by a list or by passing any number of keywords to
    the `__init__()` method. However, the order of these keywords is not preserved,
    so even though we defined the color attribute of the fruit entity with this validate
    argument `validate= Picklist(Yellow=1,Green=2,Orange=0)`, the order in the drop-down
    box was **Orange, Green**, and **Yellow**.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`Picklist`类主要是一个`OrderedDict`（突出显示）的容器，可以通过列表或传递任意数量的关键字到`__init__()`方法来初始化。然而，这些关键字的顺序不会被保留，因此尽管我们使用这个验证参数`validate=
    Picklist(Yellow=1,Green=2,Orange=0)`定义了水果实体的颜色属性，但在下拉框中的顺序是**橙，绿，黄**。'
- en: So although convenient, passing keywords makes the use of an `OrderedDict` rather
    pointless. Therefore, the `__init__()` method also accepts a list of tuples of
    key/value pairs and if present, uses this list to initialize the dictionary. Now
    if we would use `validate= Picklist([('Yellow',1),('Green',2),('Orange',0)])`,
    the order would be preserved, as shown in the following screenshot. It has the
    added benefit of allowing us to specify any string as a key and not just strings
    that are valid Python identifiers.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，尽管传递关键字很方便，但它使得使用`OrderedDict`变得毫无意义。因此，`__init__()`方法也接受一个键值对元组的列表，如果存在，则使用此列表初始化字典。现在如果我们使用`validate=
    Picklist([('Yellow',1),('Green',2),('Orange',0)])`，顺序将被保留，如下面的截图所示。它还有一个额外的优点，即允许我们指定任何字符串作为键，而不仅仅是有效的Python标识符。
- en: '![What just happened?](img/3746_08_006.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![发生了什么？](img/3746_08_006.jpg)'
- en: 'We already saw in the `index()` method of the `Display` class how to retrieve
    a list of possible choices. An `Entity` itself also needs to know how to deal
    with attributes that are picklists, for example, when it updates such an attribute.
    The `__setattr__()` method of the `AbstractEntity` class will have to be adapted
    as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在`Display`类的`index()`方法中看到了如何检索可能的选项列表。`Entity`本身也需要知道如何处理选择列表类型的属性，例如，当它更新这样的属性时。`AbstractEntity`类的`__setattr__()`方法需要如下调整：
- en: '**Chapter8/entity.py**'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**第8章/entity.py**'
- en: '[PRE13]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The added lines (highlighted) check whether any validator is a `Picklist`,
    and if it is, tries to retrieve the value associated with the key. If this fails,
    it checks if the value that is entered is one of the values allowed. This way,
    it is valid to update a picklist attribute both with a key as well as a value.
    Given a `fruit` instance of the `Fruit` class defined earlier, the following lines
    are equivalent:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 添加的行（突出显示）检查是否有任何验证器是`Picklist`，如果是，则尝试检索与键关联的值。如果失败，它检查输入的值是否是允许的值之一。这样，就可以使用键或值来更新选择列表属性。给定前面定义的`Fruit`类的`fruit`实例，以下行是等效的：
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Summary
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We learned a lot in this chapter about how to present the end user with forms
    to manipulate instances in a way that does not need any hardcoded information.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学到了很多关于如何向最终用户提供表单来操作实例的知识，而无需任何硬编码信息。
- en: Specifically, we covered how to display instances, add, and edit them, how to
    provide autocomplete functionality to attributes referring to other entities,
    and how to implement picklists.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们涵盖了如何显示实例、添加和编辑它们，如何为引用其他实体的属性提供自动完成功能，以及如何实现选择列表。
- en: All these items helped us to design and implement the first revision of a CRM
    application. Of course, there is more to a CRM application than just Accounts
    and Contacts and that is what we will look into in the next chapter.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些项目都帮助我们设计和实现了CRM应用的第一版。当然，CRM应用不仅仅是账户和联系人，这就是我们在下一章要探讨的内容。
