<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;More Advanced Functions"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. More Advanced Functions</h1></div></div></div><p>In <a class="link" href="ch07.html" title="Chapter 7. Basic Function Definitions">Chapter 7</a>, <span class="emphasis"><em>Basic Function Definitions</em></span>, we looked at the core features of defining a function which returns a single result. Even functions with an implicit <code class="literal">return</code> statement at the end of the suite of statements, or a function with a <code class="literal">return</code> statement that has no expression, return a result: the <code class="literal">None</code> object is the default return value. In this chapter, we'll look at functions which generate multiple results. A generator function defines an iterable: it can be used with a <code class="literal">for</code> statement. This means that the generator doesn't produce a single object with all of the items in the result; instead it produces each item of the result separately.</p><p>Python offers generator expressions and comprehensions which complement the idea of generator functions. We can write simple expressions that represent a sequence of values which is generated one item at a time. We can use generator expressions to create <code class="literal">list</code>, <code class="literal">set</code>, or <code class="literal">dict</code> objects via a comprehension.</p><p>We'll review the <code class="literal">for</code> statement and its relationship with iterable data. This will help us understand how generator functions work. We'll also look at some functions which work as well with collection objects as with generator functions. This includes built-in reduction functions such as <code class="literal">max()</code>, <code class="literal">min()</code>, and <code class="literal">sum()</code>. It also includes higher-order functions such as <code class="literal">map()</code>, <code class="literal">filter()</code>, <code class="literal">functools.reduce()</code>, and the functions of the <code class="literal">itertools</code> module.</p><p>This<a class="indexterm" id="id450"/> chapter will skim over some concepts of functional programming. An entire book could be written about functional programming in Python. See <a class="ulink" href="https://www.packtpub.com/application-development/functional-python-programming">https://www.packtpub.com/application-development/functional-python-programming</a> for more information. We'll focus on the essentials.</p><div class="section" title="Using the for statement with iterable collections"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec71"/>Using the for statement with iterable collections</h1></div></div></div><p>Python<a class="indexterm" id="id451"/> allows us to use the <code class="literal">for</code> statement with any kind of collection. We can write a statement like <code class="literal">for x in coll</code> to process <code class="literal">list</code>, <code class="literal">set</code>, or the keys of a <code class="literal">dict</code>. This works because all of the Python collections have common abstract base classes, defined in the <code class="literal">collections.abc</code> module.</p><p>This works via a common feature of the base classes, <code class="literal">Sequence</code>, <code class="literal">Set</code>, and <code class="literal">Mapping</code>. The <code class="literal">Iterable</code> mix in the class is part of each class definition. The implementation of this abstraction <a class="indexterm" id="id452"/>is our guarantee that all of the built-in collections will cooperate with the <code class="literal">for</code> statement.</p><p>Let's open up the internals to see how it works. We'll use this compound <code class="literal">for</code> statement as a concrete example:</p><div class="informalexample"><pre class="programlisting">for x in coll:
    print(x)</pre></div><p>Conceptually, this compound statement starts with something very much like this assignment: <code class="literal">coll_i=iter(coll)</code>. This will get an iterator object for the <code class="literal">coll</code> collection. This <code class="literal">iter()</code> function will leverage the special method <code class="literal">__iter__()</code> to produce the iterator object. We can summarize how this works with a simple rule: if the variable <code class="literal">coll</code> doesn't reference a proper collection, a <code class="literal">TypeError</code> exception will be raised.</p><p>Given the resulting iterator object, <code class="literal">coll_i</code>, the <code class="literal">for</code> statement can then evaluate <code class="literal">x=next(coll_i)</code> to get each item from the iterator. This will leverage the special method <code class="literal">coll_i.__next__()</code> to produce an item from the original collection.</p><p>If the evaluation of <code class="literal">next(coll_i)</code> returns an item, this is assigned to <code class="literal">x</code> and the suite of statements is executed with this value bound to the <code class="literal">x</code> variable. We'll see the value of <code class="literal">x</code> printed.</p><p>If <code class="literal">next(coll_i)</code> raises a <code class="literal">StopIteration</code> exception, the underlying collection is out of items, and the loop will finish normally. In the case of any another exception being raised, this simply propagates according to the standard exception rules. (We'll look at exceptions in <a class="link" href="ch09.html" title="Chapter 9. Exceptions">Chapter 9</a>, <span class="emphasis"><em>Exceptions</em></span>.)</p><div class="section" title="Iterators and iterable collections"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec72"/>Iterators and iterable collections</h2></div></div></div><p>A collection<a class="indexterm" id="id453"/> is iterable when it implements the <code class="literal">__iter__()</code> special <a class="indexterm" id="id454"/>method. Almost universally, this means that it will be a subclass of the <code class="literal">Iterable</code> class defined in the <code class="literal">collections.abc</code> module. The presence of this special method means that evaluating <code class="literal">iter()</code> on a collection object will return an iterator object.</p><p>The iterator for a collection must implement the <code class="literal">__next__()</code> and <code class="literal">__iter__()</code> special methods. Generally, an iterator object implements the <code class="literal">__iter__()</code> method by returning itself as the result. Having this tautological redundancy available means that we can not only create an explicit iterator but also provide the iterator to a <code class="literal">for</code> statement without causing an exception; the <code class="literal">for</code> statement's processing can evaluate <code class="literal">iter(object)</code> without the overheads of checking to see if the object is already an iterator.</p><p>What if we have a sequence of items which has a header that we'd like to ignore? This often happens when a source data file includes a heading line that must be processed separately. We can leverage an explicit iterator object to discard items from a sequential collection.</p><p>We might write something like this:</p><div class="informalexample"><pre class="programlisting">source_iter= iter(source)
heading= next(source_iter)
for data in source_iter:
    print(data)</pre></div><p>In this<a class="indexterm" id="id455"/> example, we've created an iterator, <code class="literal">source_iter</code>, based on a source<a class="indexterm" id="id456"/> collection or generator, unimaginatively named <code class="literal">source</code>. When we evaluated <code class="literal">next(source_iter)</code>, we consumed the first item from the collection, which we then assigned to the <code class="literal">heading</code> variable. We can then use the iterator object in the <code class="literal">for</code> statement to consume the rest of the items in that iterator.</p><p>In effect, the preceding example is nearly identical to this:</p><div class="informalexample"><pre class="programlisting">heading, *rest = source
for data in rest:
    print(data)</pre></div><p>This second example actually makes a shallow copy of the source collection and assigns this copy to the <code class="literal">rest</code> variable. We've nearly doubled the amount of memory used. For a small list, this doesn't matter. For a larger collection, this can become a problem.</p><p>If the source is an open file or a generator based on an open file, materializing the data in the <code class="literal">rest</code> collection could be impossible. Files too big to fit into memory are part of their own unique problem, sometimes called "big data". Using the <code class="literal">iter()</code> function explicitly allows us to avoid the risky attempt to create a large collection that may not fit in memory.</p></div></div></div>
<div class="section" title="Consequences and next steps"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec72"/>Consequences and next steps</h1></div></div></div><p>There<a class="indexterm" id="id457"/> are three important consequences to the way a <code class="literal">for</code> statement uses <code class="literal">coll_i= iter(x)</code> and <code class="literal">x=next(coll_i)</code>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We can write generator expressions which implicitly have the required interface to work as an <code class="literal">Iterable</code> class</li><li class="listitem" style="list-style-type: disc">Python gives us a way to write generator functions which will work as an <code class="literal">Iterable</code> class</li><li class="listitem" style="list-style-type: disc">We can create our own classes which implement the special method names required to implement the <code class="literal">Iterable</code> abstract base class</li></ul></div><p>We'll start<a class="indexterm" id="id458"/> by writing generator expressions. We can use these to create <code class="literal">list</code>, <code class="literal">set</code>, and mapping "comprehensions." A <span class="strong"><strong>comprehension</strong></span> is an expression<a class="indexterm" id="id459"/> that defines the contents of a collection.</p><p>We'll look at writing generator functions. The <code class="literal">yield</code> statement changes the semantics of a function from being "simple" (or "ordinary") to being a generator.</p><p>While class definitions are the subject of <a class="link" href="ch11.html" title="Chapter 11. Class Definitions">Chapter 11</a>, <span class="emphasis"><em>Class Definitions</em></span>, we won't dig deeply into how we can create our own unique collections. Python already offers so many collections that defining our own is not really necessary.</p></div>
<div class="section" title="Using generator expressions and comprehensions"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec73"/>Using generator expressions and comprehensions</h1></div></div></div><p>We can think of simple generator expressions as an operator with three operands. The syntax<a class="indexterm" id="id460"/> for these three operands parallels the <code class="literal">for</code> statement:</p><div class="informalexample"><pre class="programlisting">(expression for target in source)</pre></div><p>We <a class="indexterm" id="id461"/>specify an <span class="emphasis"><em>expression</em></span> which is evaluated for each value assigned to a <span class="emphasis"><em>target</em></span> variable from a <span class="emphasis"><em>source</em></span>. There are more complex generators, which we'll look at later.</p><p>Generator expressions can be used freely in Python. They can be used anywhere in a sequence or a collection that is meaningful.</p><p>It's important to note that a generator expression is lazy, or "non-strict." It doesn't actually calculate anything until some consuming operation demands values from it. To see this, we can try to evaluate a generator expression at the REPL:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; (2*x+1 for x in range(5))
&lt;generator object &lt;genexpr&gt; at 0x1023981e0&gt;</pre></div><p>Python tells us only that we've created a generator object. Since we didn't write an expression to consume the values, all we saw was the object, passively waiting to be evaluated.</p><p>The best way to explore a generator expression is to apply a function, such as <code class="literal">list()</code> or <code class="literal">tuple()</code>, that will consume the generator's values and build a collection object from them. Here's an example:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; tuple(2*x+1 for x in range(5))
(1, 3, 5, 7, 9)</pre></div><p>In this example, the <code class="literal">tuple()</code> function consumed values from the generator object and created a <code class="literal">tuple</code> object from those values. Rather than display the generator object, the REPL shows us the <code class="literal">tuple</code> which was created from the generated values.</p><p>We <a class="indexterm" id="id462"/>can use generator expressions for a wide variety of processing. There are several patterns <a class="indexterm" id="id463"/>in the <code class="literal">itertools</code> module.</p><div class="section" title="Limitations of generator expressions"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec73"/>Limitations of generator expressions</h2></div></div></div><p>Generator expressions have a few limitations. The most obvious limitation is that some language<a class="indexterm" id="id464"/> features are only available as Python statements. If we need to perform exception handling, context management, or exiting a loop early via a <code class="literal">break</code> statement, we can't write a generator expression. We have to resort to writing a complete generator function.</p><p>A less obvious limitation is that a generator expression behaves very much like a sequence. But it can only do that trick once. After the generator terminates the first time, it behaves like an empty sequence every time it's referenced after that. Here's a concrete example:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; x= (2*x+1 for x in range(20))
&gt;&gt;&gt; sum(x)
400
&gt;&gt;&gt; sum(x)
0</pre></div><p>In this example, we assigned a generator expression to a variable, <code class="literal">x</code>. When we compute <code class="literal">sum(x)</code>, the <code class="literal">sum()</code> function consumes all of the values produced by the generator expression: the sum is 400 in this example. Once we've used the generator, it is still valid, but it no longer generates values. All subsequent evaluations of <code class="literal">sum(x)</code> will produce 0.</p><p>There's no special exception to warn us that we're reusing an iterator that has already been exhausted. In some cases, a program may appear broken because we're using a generator expression instead of a <code class="literal">list</code> or <code class="literal">tuple</code> sequence. The fix is almost always to convert the generator into a <code class="literal">tuple</code> object so that it can be used twice. We can change to <code class="literal">x= tuple(2*x+1 for x in range(20))</code> to see the difference.</p><p>When working with a generator function or expression, <code class="literal">iter(some_function)</code> will return the generator object because it is an iterator. In the case of a collection object, <code class="literal">iter(some_collection)</code> will create an iterator object that has a reference to the collection. The result will be a distinct object. A function can use <code class="literal">iter(param) is iter(param)</code> to detect the difference between a generator function and a concrete collection.</p><p>In some cases, we might include the statement <code class="literal">assert iter(param) is not iter(param), "Collection object required"</code> to raise an exception if a generator function is <a class="indexterm" id="id465"/>provided as an argument to a function which traverses a collection more than once.</p></div><div class="section" title="Using multiple loops and conditions"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec74"/>Using multiple loops and conditions</h2></div></div></div><p>The <a class="indexterm" id="id466"/>body of a generator can include multiple <code class="literal">for</code> clauses. This allows<a class="indexterm" id="id467"/> us to iterate over multiple dimensions. We can write expressions like this:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; deck= list((r,s) for s in '♣♦♥♠' for r in range(1,14))
&gt;&gt;&gt; deck # doctest: +ELLIPSIS
[(1, '♣'), (2, '♣'), (3, '♣'), ... (11, '♠'), (12, '♠'), (13, '♠')]
&gt;&gt;&gt; len(deck)
52</pre></div><p>The generator expression has two <code class="literal">for</code> clauses: <code class="literal">for s in '♣♦♥♠'</code> and <code class="literal">for r in range(1,14)</code>. It's clear from the results that the <code class="literal">for</code> clause on the right executes most frequently. This follows the nesting rules we'd see if we rewrote this as nested <code class="literal">for</code> statements. The <code class="literal">for</code> clause on the right is like an innermost <code class="literal">for</code> statement.</p><p>Additionally, the body of a generator can include <code class="literal">if</code> clauses. These can be used to filter values created by the <code class="literal">for</code> clauses. Here's an example of conditional processing in a generator expression:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; list(x for x in range(36) if x%5 == 0 or x%7 == 0)
[0, 5, 7, 10, 14, 15, 20, 21, 25, 28, 30, 35]</pre></div><p>In this example, the expression is just the target variable, <code class="literal">x</code>. The source is <code class="literal">range(36)</code>, numbers that include zero and 35. We've included an <code class="literal">if</code> clause that will pass only those values which are multiples of five or seven. All other values will be rejected. In order to see a result, we collected the values from the generator into a <code class="literal">list</code> object.</p></div><div class="section" title="Writing comprehensions"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec75"/>Writing comprehensions</h2></div></div></div><p>We can leverage <a class="indexterm" id="id468"/>a variation of the generator expression to create <code class="literal">list</code>, <code class="literal">set</code>, or <code class="literal">dict</code> objects. These are called comprehensions, and represent tangible objects, built from lazy generators.</p><p>Here are some simple examples:</p><div class="informalexample"><pre class="programlisting">[2*x+1 for x in range(5)]
{x for x in range(36) if x%5 == 0 or x%7 == 0}
{n: 2*n**2-3*n-14 for n in range(-5,6)}</pre></div><p>The first example uses the <code class="literal">[]</code> to create a <code class="literal">list</code> comprehension. This will create a list of odd values from one to nine. The second example uses <code class="literal">{}</code> to create a <code class="literal">set</code> comprehension. This will be a set based on multiples of five or seven.</p><p>The third example creates a <code class="literal">dict</code> comprehension. The <code class="literal">{}</code> are used to bracket the expression. The use of the <code class="literal">:</code> character to separate key and value distinguishes a <code class="literal">dict</code> comprehension from a <code class="literal">set</code> comprehension. This dictionary provides a mapping from values of <span class="emphasis"><em>n</em></span>.</p><p>This last <a class="indexterm" id="id469"/>example could be used as an optimization for a deeply-nested expression. Looking up a value in a mapping is faster than repeatedly recalculating. Using the <code class="literal">@lru_cache</code> decorator gives similar performance benefits.</p></div></div>
<div class="section" title="Defining generator functions with the yield statement"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec74"/>Defining generator functions with the yield statement</h1></div></div></div><p>A<a class="indexterm" id="id470"/> generator function has properties<a class="indexterm" id="id471"/> similar to a generator expression. Rather than a single expression, a generator function is a full Python function. It has all of the features of the functions described in <a class="link" href="ch07.html" title="Chapter 7. Basic Function Definitions">Chapter 7</a>, <span class="emphasis"><em>Basic Function Definitions</em></span>. It has the additional characteristic of being an iterator, capable of generating a sequence of items.</p><p>When we use a <code class="literal">yield</code> statement, the semantics of the function are changed. Without a <code class="literal">yield</code>, a function will return a single value. With a <code class="literal">yield</code> statement, a function will behave like an iterator, providing multiple values to a consumer.</p><p>Here's an example of a generator function that applies a range of values to a model to compute a domain of results. We'll apply the model to a sequence of input values to compute the results for each input:</p><div class="informalexample"><pre class="programlisting">def model_iter(until):
    for n in range(0, until):
        yield n*(n+1)//2</pre></div><p>This <code class="literal">model_iter()</code> function accepts a single argument, <code class="literal">until</code>, which is the number of values generated by this function. The body of the function includes a <code class="literal">for</code> statement which will set the <code class="literal">n</code> variable to values defined by the <code class="literal">range()</code> object.</p><p>The essential feature of this function is the <code class="literal">yield</code> statement. Each value created by the <code class="literal">yield</code> statement will be part of the sequence of items emitted by this statement.</p><p>Here's one way to use this function:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; list(model_iter(6))
[0, 1, 3, 6, 10, 15]</pre></div><p>In this example, we've collected the results into a single <code class="literal">list</code> object. Creating a <code class="literal">list</code> object is just one of the many things we can do. We could just as easily sum the results of the model to compute the mean value for the given range.</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; mean = sum(model_iter(6))/6
&gt;&gt;&gt; round(mean, 4)
5.8333</pre></div><p>In this<a class="indexterm" id="id472"/> example, we provided the<a class="indexterm" id="id473"/> results of the <code class="literal">model_iter()</code> generator to the <code class="literal">sum()</code> function. This avoids building a large collection of results. The <code class="literal">sum()</code> function will consume all of the values yielded by the generator function. We can process thousands or millions of values with this kind of construct because a large <code class="literal">list</code> or <code class="literal">set</code> is not materialized in memory. Only the individual items are processed.</p></div>
<div class="section" title="Using the higher-order functions"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec75"/>Using the higher-order functions</h1></div></div></div><p>A function <a class="indexterm" id="id474"/>which accepts a function as an argument, or<a class="indexterm" id="id475"/> returns a function as a result, is called a <span class="strong"><strong>higher-order function</strong></span>. Python has a number of higher-order functions. The most commonly-used of these functions are <code class="literal">map()</code>, <code class="literal">filter()</code>, and <code class="literal">sorted()</code>. The <code class="literal">itertools</code> module contains numerous additional higher-order functions.</p><p>The <code class="literal">map()</code> and <code class="literal">filter()</code> functions are generators; their results must be consumed. Both of them apply a function to a collection of values. In the case of <code class="literal">map()</code>, the results of the function are yielded. In the case of <code class="literal">filter()</code>, if the result of the function is true, the original value is yielded.</p><p>Here's how we can apply a very simple function—so simple we coded it as a lambda—to a sequence of values:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; mapping= map( lambda x: 2*x**2-2, range(5) )
&gt;&gt;&gt; list(mapping)
[-2, 0, 6, 16, 30]</pre></div><p>The function is just an expression, <code class="literal">2*x**2-2</code>. We've applied this function to values given by the <code class="literal">range()</code> object. The result is a generator, and we need to consume the values. We've used <code class="literal">list()</code> to create a collection that we can print. The values are the result of applying the given function to each value in the source collection.</p><p>Here's how we can apply a simple logical test to a sequence of values using <code class="literal">filter()</code>:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; fb= filter( lambda n: n%5==0 or n%7==0, range(16) )
&gt;&gt;&gt; [n for n in fb]
[0, 5, 7, 10, 14, 15]</pre></div><p>We've defined a simple function as a lambda; the function, <code class="literal">n%5==0 or n%7==0</code>, is true for multiples of five or seven. We've applied that filter to values produced by a <code class="literal">range()</code> object. The result includes only the values for which the given function is <code class="literal">True</code>. All other values are rejected.</p><p>We <a class="indexterm" id="id476"/>used a <code class="literal">list</code> comprehension to gather the values into a <code class="literal">list</code> object. This <code class="literal">list</code> comprehension did no calculation and no filtering, so it's equivalent to <code class="literal">list(fb)</code>.</p><p>We can implement the simple versions of <code class="literal">map()</code> and <code class="literal">filter()</code> using generator expressions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">map(function, iterable)</code> is the same as <code class="literal">(function(x) for x in iterable)</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">filter(function, iterable)</code> is the same as <code class="literal">(x for x in iterable if function(x))</code></li></ul></div><p>The <code class="literal">map()</code> function<a class="indexterm" id="id477"/> can handle additional iterables, providing more sophistication than the generator expression.</p><p>The <code class="literal">sorted()</code> function<a class="indexterm" id="id478"/> is similar to <code class="literal">map()</code> and <code class="literal">filter()</code>. The <code class="literal">sorted()</code> function follows a different design pattern for its parameters. The <code class="literal">map()</code> and <code class="literal">filter()</code> functions accept a function first, followed by an item to process. The <code class="literal">sorted()</code> function accepts an item to sort first, and an optional function which defines the keys on which to sort, as well as an optional reverse Boolean value used to reverse the sense of the key comparisons. We'll look at sorted in detail in the <span class="emphasis"><em>Three ways to sort a sequence</em></span> section later.</p><p>The <code class="literal">itertools</code> module contains a large number of generator functions that can be combined to create sophisticated processing. For more information on how this module works, the<a class="indexterm" id="id479"/> book, <span class="emphasis"><em>Functional Python Programming</em></span>, <span class="emphasis"><em>Steven Lott</em></span>, <span class="emphasis"><em>Packt Publishing</em></span>, devotes two chapters to the subject (<a class="ulink" href="https://www.packtpub.com/application-development/functional-python-programming">https://www.packtpub.com/application-development/functional-python-programming</a>).</p><div class="section" title="Writing our own higher-order functions"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec76"/>Writing our own higher-order functions</h2></div></div></div><p>Perhaps<a class="indexterm" id="id480"/> the simplest kind of higher-order function is based on a generator expression. Since a generator expression is lazy, its behavior is more like a function than an object which contains relevant data. A function which returns a generator relies on some other piece of programming to actually consume the data which is yielded by the generator.</p><p>A common file input requirement is to strip trailing punctuation and ignore blank lines. We'll assume a language which follows the Python rule for comments.</p><p>Here's an example of a function that returns a generator:</p><div class="informalexample"><pre class="programlisting">def text_cleaner( source ):
    stripped = (line.strip() for line in source)
    partitioned = (line.partition("#") for line in stripped)
    decommented = (data.rstrip() for data, sharp, comment in partitioned)
    non_empty = (line for line in decommented if line)
    return non_empty</pre></div><p>We've <a class="indexterm" id="id481"/>broken down the processing into four separate generator functions. The result of the function is the fourth of these generators, but this depends on the others to yield its results. Since generators are lazy, no processing happens until a function or statement consumes the data yielded by the generator. We must use the result of this function with a <code class="literal">for</code> statement or a <code class="literal">list()</code> or <code class="literal">tuple()</code> function to consume the data.</p><p>When a consuming process iterates over the result of this function, it will receive individual lines of text from the <code class="literal">non_empty</code> generator expression. The <code class="literal">non_empty</code> generator filters the lines created by the <code class="literal">decommented</code> generator expression. The <code class="literal">decommented</code> generator in turn relies on the <code class="literal">partitioned</code> and <code class="literal">stripped</code> generator expressions to remove comments and whitespace.</p><p>What's important here is that the pipeline of processing is the return value from the <code class="literal">text_cleaner()</code> function. This function does not process any data. This function returns a generator expression that will process some data.</p><p>Each of these generators can be also rewritten to use <code class="literal">map()</code> or <code class="literal">filter()</code>. We'll leave that as an exercise for the reader.</p><p>We can use the <code class="literal">text_cleaner()</code> function like this:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; text = '''
... # options
... db=name # database
...  task=delete # task
... '''.splitlines()
&gt;&gt;&gt; for line in text_cleaner(text):
...    print(line)
db=name
task=delete</pre></div><p>We've created some text with comments and data. The format of the data appears to be <code class="literal">name=value</code> settings. The <code class="literal">text_cleaner()</code> function isn't sensitive to the format of the data, only to the presence of comments and whitespace. We applied the <code class="literal">splitlines()</code> function to make the block of text behave like a file.</p><p>The result of <code class="literal">text_cleaner()</code> is a function which strips away comments, leading and trailing spaces, and leaves us with just the meaningful content of the file. In this example, we used a <code class="literal">for</code> statement to consume the data yielded by the generator function.</p><p>This can be part of a more complex process that uses these <code class="literal">name=value</code> lines as configuration parameters.</p><p>What's important <a class="indexterm" id="id482"/>about generator functions is that they are completely lazy. They don't create giant data structures in memory. They process the minimum amount of data to satisfy the consumer's requests. This reduces overheads. Additionally, each generator can be kept relatively simple, allowing an expressive composition to be built from simple pieces.</p></div></div>
<div class="section" title="Using the built-in reductions &#x2013; max, min, and reduce"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec76"/>Using the built-in reductions – max, min, and reduce</h1></div></div></div><p>We have<a class="indexterm" id="id483"/> two other built-in higher-order functions that can accept functions as arguments. These can be characterized as reductions: they reduce a collection of values to a single value. There's a third built-in reduction, sum, but it's not a proper higher-order function: we can't tailor its operation by plugging in a function.</p><p>The <code class="literal">max()</code> and <code class="literal">min()</code> reductions follow the design pattern for the <code class="literal">sorted()</code> function: they accept an iterable object first, and they can be customized with an optional key function. We'll show the default behavior first, then we'll show how to customize this with the key function:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; data = ["21", "3", "35", "4"]
&gt;&gt;&gt; min(data)
'21'
&gt;&gt;&gt; min(data, key=int)
'3'</pre></div><p>In the first example, the string objects were compared using string comparison. This leads to the anomaly of seeing <code class="literal">"21"</code> appear to be less than <code class="literal">"3"</code>. In fact, a string beginning with <code class="literal">"2"</code> is sorted before a string beginning with <code class="literal">"3"</code>, but this may not be what the program needs to show as output.</p><p>In the second example, we provided the <code class="literal">int()</code> function for min to use when comparing items. This means that the strings are compared as integers, not as strings. This selects <code class="literal">"3"</code> as the string with the minimal integer value.</p><p>Note that we did not write <code class="literal">min(data, key=int())</code>. We're not evaluating the <code class="literal">int</code> function. We're providing the <code class="literal">int</code> function as an object which the <code class="literal">min()</code> function will use.</p><p>Additionally, there's a generic <code class="literal">functools.reduce()</code> function which can be used to build new kinds of reductions. This function accepts a two-valued function, an iterable and an initial value. It can compute a wide variety of reductions.</p></div>
<div class="section" title="Three ways to sort a sequence"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec77"/>Three ways to sort a sequence</h1></div></div></div><p>Python<a class="indexterm" id="id484"/> offers us three common approaches to the general problem of sorting a <code class="literal">list</code> of complex items.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We can sort with the <code class="literal">sorted()</code> generator function. This will duplicate an object as part of sorting.</li><li class="listitem" style="list-style-type: disc">We can sort a list with its <code class="literal">sort()</code> method and a key function. This will mutate the <code class="literal">list</code> into the requested order.</li><li class="listitem" style="list-style-type: disc">We <a class="indexterm" id="id485"/>can create an intermediate sequence of objects which can be sorted easily. This is sometimes called the <span class="strong"><strong>wrap-sort-unwrap</strong></span> design pattern.</li></ul></div><p>In order to look at each of these in some detail, we need a collection of complex objects which we can sort. We'll use a simple dataset based on a case study in the <span class="emphasis"><em>NIST Engineering Statistics Handbook</em></span>, section 7.1.6. See <a class="ulink" href="http://www.itl.nist.gov/div898/handbook">http://www.itl.nist.gov/div898/handbook</a> for more information.</p><p>We've got metrics data that—after a little re-organization and cleanup—looks like this:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; data
[['2013-09-10', '289'], ['2013-09-11', '616'],
. . . ,
['2013-12-07', '752'], ['2013-12-08', '739']]</pre></div><p>We have a list-of-list structure with 90 pairs. Since the date strings are formatted nicely as <code class="literal">yyyy-mm-dd</code>, we can easily sort this into date order using the <code class="literal">sorted(data)</code> function, or the <code class="literal">data.sort()</code> method. Note that <code class="literal">sorted(data)</code> will create a duplicate of the <code class="literal">data</code> object. The <code class="literal">data.sort()</code> method will mutate the <code class="literal">data</code> object in place.</p><p>How can we put the data into order by count? We can apply a key function to the <code class="literal">sorted()</code> function or <code class="literal">sort()</code> method. We'll look at these first. As an alternative, we can use the wrap-sort-unwrap design pattern.</p><div class="section" title="Sorting via a key function"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec77"/>Sorting via a key function</h2></div></div></div><p>Putting<a class="indexterm" id="id486"/> the metrics data into order by count requires us to use a function which will change the way items are compared. In this case, we need a more complex key function that does two things. It must select the second item of each two item data points, and it must convert the second item to a proper integer value.</p><p>We can sort by count using either of these examples:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; data.sort(key=lambda x: int(x[1]))
&gt;&gt;&gt; by_count= sorted(data, key=lambda x: int(x[1]))</pre></div><p>Both examples use a lambda that performs the integer conversion of the second item in each two-item list. The first example updates the data object. The second example creates a new object <a class="indexterm" id="id487"/>which is a clone of the data object, put into order.</p></div><div class="section" title="Sorting via wrapping and unwrapping"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec78"/>Sorting via wrapping and unwrapping</h2></div></div></div><p>The wrap-sort-unwrap design pattern can be done with a pair of generator expressions. The <a class="indexterm" id="id488"/>first will create two-tuples from each original piece of data. The first item in each new two-tuple is the proper sort key. The second generator will select the second item from each of those two-tuples to recover the original object.</p><p>The whole sequence looks like this:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; wrapped = [(int(x[1]), x) for x in data]
&gt;&gt;&gt; wrapped.sort()
&gt;&gt;&gt; by_count = [x[1] for x in wrapped]</pre></div><p>In the first step, we turned each piece of original data into a two-tuple of <code class="literal">(sort key, original item)</code>. We've used a <code class="literal">list</code> comprehension to create a new object that we can sort, leaving the original object undisturbed. Once we've done this, the default sort operation works correctly. Once the data is sorted, we can recover the original items easily. In this case, we created yet another list object using a <code class="literal">list</code> comprehension.</p><p>In both cases, we can tweak this slightly to the <code class="literal">map()</code> function instead of with generator expressions. For example, we can wrap items using <code class="literal">map(lambda item: (int(item[1]), item), data)</code>.</p><p>Note that the <code class="literal">map()</code> function is a generator: it's lazy. A <code class="literal">list</code> comprehension consumes data and creates a tangible object. We can't easily switch from <code class="literal">list</code> to generator with a simple copy-and-paste. We'll need to either create a <code class="literal">list</code> object from the map generator, or use <code class="literal">sorted()</code>, which creates a <code class="literal">list</code> from a generator.</p><p>The wrap-sort-unwrap is often used when the wrap function is quite complex. We might have a generator which performs database lookups, file merges, or extremely complex calculations as part of the ordering. In these cases, a simple lambda might be difficult to write.</p></div></div>
<div class="section" title="Functional programming design patterns"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec78"/>Functional programming design patterns</h1></div></div></div><p>The <a class="indexterm" id="id489"/>presence of higher-order functions in Python allows us to leverage a great many functional programming design patterns. To learn more about these design patterns, a good place to start is the <code class="literal">itertools</code> module. The functions in this module provide many examples of how we can write simple functions that do sophisticated processing.</p><p>Additionally, we can use some of the features in the <code class="literal">functools</code> module. This contains the general-purpose <code class="literal">reduce()</code> function. It also contains some functions that can help us write decorators. A decorator, as we'll see in <a class="link" href="ch13.html" title="Chapter 13. Metaprogramming and Decorators">Chapter 13</a>, <span class="emphasis"><em>Metaprogramming and Decorators</em></span>, is another kind of higher-order function: it's a function that modifies the definition<a class="indexterm" id="id490"/> of an original function. This is another aspect of functional programming.</p><p>Most importantly, we have two ways to approach algorithms:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We can<a class="indexterm" id="id491"/> process items in large collections of data, creating additional collections that are copies, subsets, or transformations.</li><li class="listitem" style="list-style-type: disc">We can process items by iterating through a large collection of data as if we're creating additional collections. Instead of actually creating copies, subsets, or transformations, we can use iterators, filter functions, and mapping functions.</li></ul></div><p>When we have alternatives, we can choose a variation that is succinct and expressive.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec79"/>Summary</h1></div></div></div><p>In this chapter, we've seen a number of the advanced features of functions. We've looked at the essential generator expression and how this is used as part of a comprehension. A <code class="literal">list</code> comprehension assembles a <code class="literal">list</code> from the generated values. Similarly, a <code class="literal">set</code> comprehension creates a <code class="literal">set</code>. A dictionary comprehension creates a <code class="literal">dict</code> structure from the keys and values in a generator expression.</p><p>We've looked at using the <code class="literal">yield</code> statement to create a generator function. This allows us to use all of the various Python statement features when creating a generator. Since a generator is iterable, it works with a <code class="literal">for</code> loop so that we can write a simple loop to process multiple values created by an iterator.</p><p>We've also looked at higher-order functions. These are functions which take functions as arguments or produce functions as a result. With higher-order functions, we can refactor our algorithms into functions that can be combined to create the desired behavior.</p><p>In <a class="link" href="ch09.html" title="Chapter 9. Exceptions">Chapter 9</a>, <span class="emphasis"><em>Exceptions</em></span>, we'll look at how Python raises exceptions, how we can capture those exceptions, and what kind of exceptional processing we need to write.</p></div></body></html>