- en: Chapter 6. Storing and Plotting Arduino Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sensors that are connected to Arduino produce lots of analog and digital data.
    Analog sensors produce data points as numerical information while digital sensors
    produce Boolean values, that is, 1 (on) or 0 (off). Until now, we printed this
    data as a string on the command prompt or displayed it in a GUI. The data was
    being printed in real time and it was not being saved for any further analysis.
    Instead of using the string format, if the data is printed as a plot or graph,
    it will provide useful information for us to rapidly understand it and derive
    conclusions. Plots are even more useful for real-time applications as they can
    provide information regarding the system's behavior for better understanding of
    the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter is organized around two major sections: storing the Arduino sensor
    data and plotting this data. We will start by creating and manipulating files
    using Python. After that, we will work with methods for storing Arduino data in
    the CSV file format. In the second section, you will be introduced to the Python
    plotting library, `matplotlib`. Then, we will work with examples that deal with
    plotting data from a saved file and also from real-time sensor readings. In the
    end, we will try to integrate the `matplotlib` plots with the `Tkinter` window
    that we created in the previous chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: In terms of hardware components, we will be working with familiar sensors such
    as a potentiometer and the PIR motion sensor, which we used in the previous chapters,
    so, you will not have to learn or buy any additional sensors for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Working with files in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python provides built-in methods to create and modify files. File-related Python
    operations are useful in a large number of programming exercises. These methods
    are provided by standard Python modules and do not require installation of additional
    packages.
  prefs: []
  type: TYPE_NORMAL
- en: The open() method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `open()` method is a default method that is available in Python and it
    is one of the most widely used functions to manipulate files. Now, the first step
    of dealing with a file is to open it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will create a `test.txt` file in the same folder in which you
    started the Python interpreter or the location from where the code is being executed.
    The preceding command uses the `w` mode that opens a file for writing or creates
    a new one if it doesn''t exist. The other modes that can be used with the `open()`
    function are displayed in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Mode | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `w` | This opens or creates a file for writing only. It overwrites an existing
    file. |'
  prefs: []
  type: TYPE_TB
- en: '| `w+` | This opens or creates a file for writing and reading. It overwrites
    an existing file. |'
  prefs: []
  type: TYPE_TB
- en: '| `r` | This opens a file for reading only. |'
  prefs: []
  type: TYPE_TB
- en: '| `r+` | This opens a file for reading and writing. |'
  prefs: []
  type: TYPE_TB
- en: '| `a` | This opens a file for appending. It starts appending from the end of
    the document. |'
  prefs: []
  type: TYPE_TB
- en: '| `a+` | This opens a file for appending and reading. It starts appending from
    the end of the document. |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Make sure that you have the proper read and write permissions for the files
    if you are utilizing these modes in a Unix or Linux environment.
  prefs: []
  type: TYPE_NORMAL
- en: The write() method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once the file is open in one of the writing or appending modes, you can start
    writing to the file object using this method. The `write()` method only takes
    a string as an input argument. Any other data format needs to be converted into
    a string before it is written:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we are writing the `Hello World!` string that ends with a new
    line character, `\n`. This new line character has been explained in the previous
    chapter and you can obtain more information about it at [http://en.wikipedia.org/wiki/Newline](http://en.wikipedia.org/wiki/Newline).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use the `writelines()` method if you want to write a sequence
    of strings to the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The close() method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `close()` method closes the file and free system resources that are occupied
    by the file. Once they are closed, you can''t use the file object as it has been
    flushed already. It is a good practice to close the file once you are done working
    with a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The read() method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This `read()` method reads the content of an opened file from the beginning
    to the end. To use this method, you need to open the file with one of the reading
    compatible modes such as `w+`, `r`, `r+`, or `a+`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'As the `read()` method grabs the entire contents of the file into memory, you
    can use it with the optional size parameter to avoid any memory congestion while
    working with large files. As an alternative method, you can use the `readlines()`
    method to read the content of an opened file line by line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding example, each string is printed as an element
    of a list that you can access individually. You can play around with these methods
    to get familiar with creating and modifying files. These exercises will be handy
    for the upcoming coding exercises.
  prefs: []
  type: TYPE_NORMAL
- en: The with statement – Python context manager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Although the `with` statement can be used to cover the execution of a code
    block that is defined by a context manager, it is widely used in Python to deal
    with files. Execute the following command on the Python interactive prompt, assuming
    that you have already executed the previous commands and have the `test.txt` file
    with some data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'On execution, you will be able to see each line of the file printed on the
    command prompt. The `with` statement while used with the `open()` method creates
    a context manager, which executes the wrapped code while automatically taking
    care of closing the file. This is the recommended method to work with files in
    Python and we will be utilizing it in all of our exercises. You can learn more
    about the Python context manager on the following websites:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.python.org/2/reference/compound_stmts.html#with](https://docs.python.org/2/reference/compound_stmts.html#with)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://preshing.com/20110920/the-python-with-statement-by-example/](http://preshing.com/20110920/the-python-with-statement-by-example/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using CSV files to store data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now you know methods to open, manipulate, and close files using Python. In the
    previous examples, we used the Python interpreter and string data to get familiar
    with these methods. But when it comes to saving a large number of numerical values
    from sensor data, the **comma separated values** (**CSV**) file format is one
    of the most widely used file formats other than text. As the name states, values
    are separated and stored using commas or other delimiters such as a space or tab.
    Python has a built-in module to deal with CSV files.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin with, use the following code snippet to create a Python file and run
    your first CSV program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You can also open the `csvWriter.py` file from this chapter's code folder, which
    contains the same code. After executing the code, you will be able to find a file
    named `example.csv` in the same location as this file, which will contain the
    data separated with commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in the code, the CSV module offers the `writer()` function on
    the opened file that initializes a `writer` object. The `writer` object takes
    a sequence or array of data (integer, float, string, and so on) as input and joins
    the values of this array using the delimiter character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, since we are not using a delimiter option, the program
    will take the default character comma as the delimiter. If you want to use space
    as the delimiter character, you can use the following `writer()` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: To write each element of a list to a new line of this `writer` object, we use
    the `writerow()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, Python CSV module also provides the `reader()` function to read
    a CSV file. Check out the following example to learn more about this function,
    or you can open the `csvReader.py` file from the next chapter''s code folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `reader()` function creates a `reader` object to iterate over lines in the
    opened CSV file. The reader object retrieves each element of a row by splitting
    it using the delimiter. You can access each line of the file by iterating over
    the object using the `for` loop as displayed in the preceding code snippet, or
    use the `next()` method every time you want to access the next line. On execution
    of the previous code, you will be able to see three separate array lists that
    are printed with three individual elements.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To open the CSV files externally, you can use a spreadsheet program such as
    Microsoft Excel, OpenOffice Calc, or Apple Numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Storing Arduino data in a CSV file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous two sections, you learned methods to store values in a CSV file.
    Although the data required for the file was already initialized in the code, the
    same code could be modified to store Arduino input data.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin with storing Arduino data, let''s create a circuit that produces these
    values for us. We used a motion sensor in the project of [Chapter 3](ch03.html
    "Chapter 3. The First Project – Motion-triggered LEDs"), *The First Project –
    Motion-triggered LEDs*, and a potentiometer in the exercise of [Chapter 4](ch04.html
    "Chapter 4. Diving into Python-Arduino Prototyping"), *Diving into Python-Arduino
    Prototyping*. We will be using these two sensors to provide us with digital and
    analog input values respectively. To develop the circuit required for this exercise,
    connect the potentiometer to the analog pin 0 and the PIR motion sensor to digital
    pin 11, as displayed in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Storing Arduino data in a CSV file](img/5938OS_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Connect other Arduino pins such as 5V and the ground, as shown in the preceding
    Fritzing diagram. As we are going to use `pyFirmata` to interface Python with
    the Arduino board, you will have to upload the **StandardFirmata** sketch to the
    Arduino board using the method described in [Chapter 3](ch03.html "Chapter 3. The
    First Project – Motion-triggered LEDs"), *The First Project – Motion-triggered
    LEDs*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you are working with prototyping, you really don't need large, powerful,
    and computation-intensive databases to deal with information. The easiest and
    quickest way to work with sensor data in this phase is by using CSV files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have your Arduino board ready with the appropriate connections, use
    the following code snippet to create a Python file and run it. You can also open
    the `csvArduinoStore.py` file from this chapter''s code folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: While the code is running, rotate the knob of the potentiometer and wave your
    hand in front of the motion sensors. This action will help you to generate and
    measure distinct values from these sensors. Meanwhile, the program will log this
    data in the `SensorDataStore.csv` file. When complete, open the `SensorDataStore.csv`
    file using any text viewer or spreadsheet program and you will be able to see
    these sensor values stored in the file. Now, let's try to understand the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can observe from the code, we are not utilizing a new module to interface
    the Arduino board or store sensor values to the file. Instead, we have utilized
    the same methods that we used in the previous exercises. The code has two distinct
    components: Python-Arduino interfacing and storing data to a CSV file. By skipping
    the explanation of `pyFirmata` methods to interface the Arduino board, let''s
    focus on the code that is associated with storing the sensor data. The first line
    that we will write to the CSV file using `writerow()` is the header line that
    explains the content of the columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Later, we will obtain the readings from the sensors and write them to the CSV
    file, as shown in the following code snippet. We will repeat this process 25 times
    as defined by the variable, `i`. You can change the value of `i` according to
    your requirements.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The next question is how can you utilize this coding exercise in your custom
    projects? The program has three main sections that can be customized to accomplish
    your project requirements, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Arduino pins**: You can change the Arduino pin numbers and the number of
    pins to be utilized. You can do this by adding additional sensor values to the
    row object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The CSV file**: The name of the file and its location can be changed from
    `SensorDataStore.csv` to the one that is specific to your application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The number of data points**: We have collected 25 different pairs of data
    points while running the `while` loop for 25 iterations. You can change this value.
    You can also change the time delay between each successive point from one second,
    as used in the program, to the value that you need.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started with matplotlib
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `matplotlib` library is one of the most popular and widely supported Python
    plotting libraries. Although `matplotlib` is inspired by MATLAB, it is independent
    of MATLAB. Similar to other Python libraries that we have been using, it is an
    open source Python library. The `matplotlib` library assists in creating 2D plots
    from simple lines of code from easy to use built-in functions and methods. The
    `matplotlib` library is extensively used in Python-based applications for data
    visualization and analysis. It utilizes `NumPy` (the short form of numerical Python)
    and `SciPy` (short form of scientific Python) packages for mathematical calculations
    for the analysis. These packages are major dependencies for `matplotlib` including
    `freetype` and `pyparsing`. Make sure that you have these packages preinstalled
    on your system if you are using any other installation methods besides the ones
    mentioned in the next section. You can obtain more information about the `matplotlib`
    library from its official website ([http://matplotlib.org/](http://matplotlib.org/)).
  prefs: []
  type: TYPE_NORMAL
- en: Configuring matplotlib on Windows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we install `matplotlib` on Windows, make sure that you have your Windows
    operating system with the latest version of Python 2.x distribution. In [Chapter
    1](ch01.html "Chapter 1. Getting Started with Python and Arduino"), *Getting Started
    with Python and Arduino*, we installed Setuptools to download and install additional
    Python packages. Make sure that you have Setuptools installed and configured properly.
    Before we advance further, we will have to install dependencies for `matplotlib`.
    Open the command prompt and use the following command to install the `dateutil`
    and `pyparsing` packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Once you have successfully installed these packages, download and install the
    precompiled `NumPy` package from [http://sourceforge.net/projects/numpy/](http://sourceforge.net/projects/numpy/).
    Make sure that you choose the appropriate installation files for Python 2.7 and
    the type of your Windows operating system.
  prefs: []
  type: TYPE_NORMAL
- en: Now, your computer should have satisfied all the prerequisites for `matplotlib`.
    Download and install the precompiled `matplotlib` package from [http://matplotlib.org/downloads.html](http://matplotlib.org/downloads.html).
  prefs: []
  type: TYPE_NORMAL
- en: In this installation process, we have avoided the usage of Setuptools for `NumPy`
    and `matplotlib` because of some known issues related to `matplotlib` in the Windows
    operating system. If you can figure out ways to install these packages using Setuptools,
    then you can skip the preceding manual steps.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring matplotlib on Mac OS X
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Installation of `matplotlib` on Mac OS X can be difficult depending upon the
    version of Mac OS X and the availability of dependencies. Make sure that you have
    Setuptools installed as described in [Chapter 1](ch01.html "Chapter 1. Getting
    Started with Python and Arduino"), *Getting Started with Python and Arduino*.
    Assuming that you already have Setuptools and `pip`, run the following command
    on the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing this command will lead to one of the following three possibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: Successful installation of the latest `matplotlib` version
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notification that the requirements are already satisfied but the installed version
    is older than the current version, which is 1.3 at the moment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Error while installing the `matplotlib` package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you encounter the first possibility, then you can advance to the next section;
    otherwise follow the troubleshooting instructions. You can check your `matplotlib`
    version using the following commands on the Python interactive prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Upgrading matplotlib
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you encounter the second possibility, which states that the existing version
    of the `matplotlib` is older than the current version, use the following command
    to upgrade the `matplotlib` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Go through the next section in case you end up with errors during this upgrade.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting installation errors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you encounter any errors during the `matplotlib` installation via `pip`,
    it is most likely that you are missing some dependency packages. Follow these
    steps one by one to troubleshoot the errors.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'After every step, use one of the following commands to check whether the error
    is resolved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Install Xcode from Apple's App Store. Open Xcode and navigate to the **Download**
    tab in **Preferences…**. Download and install **Command Line Tools** from **Preferences…**.
    This step should solve any compilation-related errors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Install `homebrew` using the following command in the terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Install the following packages using `homebrew`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you still receive an error with the `freetype` package, try to create a
    link for `freetype` using the following command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you receive any further errors after performing the preceding steps, go to
    the `matplotlib` forums at [http://matplotlib.1069221.n5.nabble.com/](http://matplotlib.1069221.n5.nabble.com/)
    for those specific errors.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you use `matplotlib` in Mac OS X, you need to set up the appropriate drawing
    backend as shown in the following code snippet:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can learn more about drawing backends for `matplotlib` at [http://matplotlib.org/faq/usage_faq.html#what-is-a-backend](http://matplotlib.org/faq/usage_faq.html#what-is-a-backend).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Setting up matplotlib on Ubuntu
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The installation of `matplotlib` and the required dependencies is a very straightforward
    process on Ubuntu. We can perform this operation without using Setuptools and
    with the help of the Ubuntu package manager. The following simple command should
    do the trick for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: When prompted to select dependencies, click on **Yes** to install them all.
    You should be able to find the `matplotlib` package in other popular Linux distributions
    too.
  prefs: []
  type: TYPE_NORMAL
- en: Plotting random numbers using matplotlib
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `matplotlib` library provides a collection of basic plotting-related functions
    and methods via the `pyplot` framework. The `pyplot` framework contains functions
    for creating figures, drawing plots, setting up titles, setting up axes, and many
    additional plotting methods. One of the import functions provided by `pyplot`
    is `figure()`. This initializes an empty figure canvas that can be selected for
    your plot or a set of plots:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: You can similarly create multiple figures by specifying a number as the parameter,
    that is, `figure(2)`. If a figure with this number already exists, the method
    activates the existing figure that can then be further used for plotting.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `matplotlib` library provides the `plot()` method to create line charts.
    The `plot()` method takes a list or an array data structure that is made up of
    integer or floating point numbers as input. If two arrays are used as inputs,
    `plot()` utilizes them as values for the *x* axis and the *y* axis. If only one
    list or array is provided, `plot()` assumes it to be the sequence values for the
    *y* axis and uses auto-generated incremental values for the *x* axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The third optional parameter that is supported by the `plot()` method is for
    the format string. These parameters help users to change the style of line and
    markers with different colors. In our example, we are using the solid line style.
    So, the `plot()` function for our plot looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `plot()` function provides a selection from a large collection of styles
    and colors. To find more information about these parameters, use Python''s `help()`
    function on the `plot()` function of `matplotlib`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This `help()` function will provide the necessary information to create plotting
    styles with different markers, line styles, and colors. You can exit this help
    menu by typing `q` at the prompt.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, as we have explored plotting sufficiently, let''s create your first Python
    plot using the following code snippet. The program containing this code is also
    located in this chapter''s code folder with the name `plotBasic.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In the previous exercise, we randomly generated a dataset for the *y* axis using
    the `randint()` method. You can see a plot depicting this data with the solid
    line style in an opened window after running the program. As you can see in the
    code snippet, we used the additional `pyplot` methods such as `title()`, `xlabel()`,
    `ylabel()`, and `plot()`. These methods are self-explanatory and they are largely
    used to make your plots more informative and meaningful.
  prefs: []
  type: TYPE_NORMAL
- en: 'At end of the example, we used one of the most important `pyplot` methods called
    `show()`. The `show()` method displays the generated plots in a figure. This method
    is not mandatory to display figures when running from Python''s interactive prompt.
    The following screenshot illustrates the plot of randomly generated values using
    `matplotlib`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Plotting random numbers using matplotlib](img/5938OS_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Plotting data from a CSV file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the beginning of the chapter, we created a CSV file from Arduino data. We
    will be using that `SensorDataStore.csv` file for this section. If you recall,
    we used two different sensors to log the data. Hence, we have two arrays of values,
    one from a digital sensor and another from the analog one. Now, in the previous
    example, we just plotted one set of values for the *y* axis. So, how are we going
    to plot two arrays separately and in a meaningful way?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating a new Python program using the following lines of
    code or by opening the `plotCSV.py` file from this chapter''s code folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In this program, we have created two arrays of sensor values—`pValues` and `mValues`—by
    reading the `SensorDataStore.csv` file row by row. Here, `pValues` and `mValues`
    represent the sensor data for the potentiometer and the motion sensor respectively.
    Once we had these two lists, we plotted them using the `matplotlib` methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `matplotlib` library provides various ways to plot different arrays of
    values. You can individually plot them in two different figures using `figure()`,
    that is, `figure(1)` and `figure(2)`, or plot both in a single plot in which they
    overlay each other. The `pyplot` method also offers a third meaningful alternative
    by allowing multiple plots in a single figure via the `subplot()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is structured as `subplot(nrows, ncols, plot_number)`, which creates
    grids on the figure canvas using row and column numbers, that is, `nrows` and
    `ncols` respectively. This method places the plot on the specific cell that is
    provided by the `plot_number` parameter. For example, through `subplot(2, 1, 1)`,
    we created a table of two rows and one column and placed the first subplot in
    the first cell of the table. Similarly, the next set of values was used for the
    second subplot and was placed in the second cell, that is, row 2 and column 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In the first subplot, we have used the `plot()` method to create a plot using
    the analog value from the potentiometer, that is, `pValues`. While in the second
    subplot, we created a bar chart instead of a line chart to display the digital
    values from the motion sensor. The bar chart functionality was provided by the
    `bar()` method.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the code snippet, we have utilized an additional `pyplot()`
    method called `xlim()`. The `xlim([x_minimum, x_maximum])` or `ylim([y_minimum,
    y_maximum])` methods are used to confine the plot between the given maximum and
    minimum values of the particular axes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we displayed these subplots in the figure using the `show()` method,
    we used the `tight_layout()` function to organize the title and label texts in
    the figure. The `tight_layout()` function is a very important `matplotlib` module
    that nicely fit the subplot parameters in one figure. You can check the effects
    of this module by commenting that line and running the code again. The following
    screenshot shows these subplots with labels and a title in one figure object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Plotting data from a CSV file](img/5938OS_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Plotting real-time Arduino data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, while dealing with GUI and Arduino data, you must have
    noticed that the code was updating the interface with every new value that was
    obtained from the Arduino sensors. Similarly, in this exercise, we will be redrawing
    the plot every time we receive new values from Arduino. Basically, we will be
    plotting and updating a real-time chart instead of plotting the entire set of
    sensor values as we did in the previous exercise.
  prefs: []
  type: TYPE_NORMAL
- en: We will be using the same Arduino circuit that you built in the previous exercises.
    Here, we will utilize only the potentiometer section of the circuit to obtain
    the analog sensor values. Now, before we explain the new methods used in this
    exercise, let's first open the program file for this exercise. You can find the
    program file from this chapter's folder; it is named `plotLive.py`. In the code,
    change the appropriate parameters for the Arduino board and execute the code.
    While the code is running, rotate the knob of the potentiometer to observe the
    real-time changes in the plot.
  prefs: []
  type: TYPE_NORMAL
- en: On running the program, you will get a screen similar to the following screenshot
    that shows a plot from real-time Arduino data.
  prefs: []
  type: TYPE_NORMAL
- en: '![Plotting real-time Arduino data](img/5938OS_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: One can make various conclusions about the potentiometer's knob rotation or
    some other sensor behavior by just looking at the plot. These types of plots are
    widely used in the graphical dashboard for real-time monitoring applications.
    Now, let's try to understand the methods that are used in the following code snippet
    to make this possible.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The real-time plotting in this exercise is achieved by using a combination
    of the `pyplot` functions `ion()`, `draw()`, `set_xdata()`, and `set_data()`.
    The `ion()` method initializes the interactive mode of `pyplot`. The interactive
    mode helps to dynamically change the *x* and *y* values of the plots in the figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Once the interactive mode is set to `True`, the plot will only be drawn when
    the `draw()` method is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like the previous Arduino interfacing exercises, at the beginning of the
    code, we initialized the Arduino board using `pyFirmata` and the setup pins to
    obtain the sensor values. As you can see in the following line of code, after
    setting up the Arduino board and `pyplot` interactive mode, we initialized the
    plot with a set of blank data, `0` in our case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This array for *y* values, `pData`, is then used to append values from the
    sensor in the `while` loop. The `while` loop keeps appending the newest values
    to this data array and redraws the plot with these updated arrays for the *x*
    and *y* values. In this example, we are appending new sensor values at the end
    of the array while simultaneously removing the first element of the array to limit
    the size of the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The `set_xdata()` and `set_ydata()` methods are used to update the *x* and
    *y* axes data from these arrays. These updated values are plotted using the `draw()`
    method on each iteration of the `while` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: You will also notice that we are utilizing an `xrange()` function to generate
    a range of values according to the provided length, which is `25` in our case.
    The code snippet, `[i for i in xrange(25)]`, will generate a list of 25 integer
    numbers that start incrementally at 0 and end at 24.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating plots in the Tkinter window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Due to the powerful integration capabilities of Python, it is very convenient
    to interface the plots generated by the `matplotlib` library with the `Tkinter`
    graphical interface. In the last exercise of the previous chapter, we integrated
    `Tkinter` with `pyFirmata` to implement the project of [Chapter 3](ch03.html "Chapter 3. The
    First Project – Motion-triggered LEDs"), *The First Project – Motion-triggered
    LEDs*, with the GUI. In this exercise, we will extend this integration further
    by utilizing `matplotlib`. We will perform this action by utilizing the same Arduino
    circuit that we have been using in this chapter and expand the code that we used
    in the previous exercise. Meanwhile, we are not introducing any new methods in
    this exercise; instead we will be utilizing what you learned until now. Open the
    `plotTkinter.py` file from this chapter's code folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned earlier, the program utilizes three major Python libraries and
    interfaces them with each other to develop an excellent Python-Arduino application.
    The first interfacing point is between `Tkinter` and `matplotlib`. As you can
    see in the following lines of code, we have initialized three button objects,
    `startButton`, `pauseButton`, and `exitButton`, for the **Start**, **Pause**,
    and **Exit** buttons respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The **Start** and **Exit** buttons provide control points for `matplotlib`
    operations such as updating the plot and closing the plot through their respective
    `onStartButtonPress()` and `onExitButtonPress()` functions. The `onStartButtonPress()`
    function also consists of the interfacing point between the `matplotlib` and `pyFirmata`
    libraries. As you can observe from the following code snippet, we will start updating
    the plot using the `draw()` method and the `Tkinter` window using the `update()`
    method for each observation from the analog pin a0, which is obtained using the
    `read()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The `onExitButtonPress()` function implements the `exit` function as described
    by the name itself. It closes the `pyplot` figure and the `Tkinter` window before
    disengaging the Arduino board from the serial port.
  prefs: []
  type: TYPE_NORMAL
- en: Now, execute the program after making the appropriate changes to the Arduino
    port parameter. You should be able to see a window on your screen that is similar
    to the one displayed in the following screenshot. With this code, you can now
    control your real-time plots using the **Start** and **Pause** buttons. Click
    on the **Start** button and start rotating the potentiometer knob. When you click
    on the **Pause** button, you can observe that the program has stopped plotting
    new values. While **Pause** is pressed, even rotating the knob will not result
    in any updates to the plot.
  prefs: []
  type: TYPE_NORMAL
- en: 'As soon as you click on the **Start** button again, you will again see the
    plot get updated with real-time values, discarding the values generated while
    paused. Click on the **Exit** button to safely close the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Integrating plots in the Tkinter window](img/5938OS_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we introduced two major Python programming paradigms: creating,
    reading, and writing files using Python while also storing data into these files
    and plotting sensor values and updating plots in real time. We also explored methods
    to store and plot real-time Arduino sensor data. Besides helping you in your Arduino
    projects, these methods can also be used in your everyday Python projects. Throughout
    the chapter, using simple exercises, we interfaced the newly learned CSV and `matplotlib`
    modules with the `Tkinter` and `pyFirmata` modules that we learned in the previous
    chapters. In the next chapter, you will be introduced to your second project—a
    portable unit that measures and displays environmental data such as temperature,
    humidity, and ambient light. We will be utilizing the concepts that we have learned
    so far to build this project.'
  prefs: []
  type: TYPE_NORMAL
