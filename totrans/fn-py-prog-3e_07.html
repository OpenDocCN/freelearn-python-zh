<html><head></head><body>
<section id="chapter-7-complex-stateless-objects" class="level2 chapterHead" data-number="0.11">&#13;
<h2 class="chapterHead" data-number="0.11"><span class="titlemark"> 7</span><br/>&#13;
<span id="x1-1530007"/>Complex Stateless Objects</h2>&#13;
<p>Many of the examples we’ve looked at have either been functions using atomic (or scalar) objects, or relatively simple structures built from small tuples. We can often exploit Python’s immutable <span class="obeylines-h"><span class="verb"><code class="inlineCode">typing.NamedTuple</code></span></span> as a way to build complex data structures. The class-like syntax seems much easier to read than the older <span class="obeylines-h"><span class="verb"><code class="inlineCode">collections.namedtuple</code></span></span> syntax.</p>&#13;
<p>One of the beneficial features of object-oriented programming<span id="dx1-153001"/> is the ability to create complex data structures incrementally. In some respects, an object can be viewed as a cache for results of functions; this will often fit well with functional design patterns. In other cases, the object paradigm provides for property methods that include sophisticated calculations to derive data from an object’s properties. Using properties of an otherwise immutable class is also a good fit for functional design ideas.</p>&#13;
<p>In this chapter, we’ll look at the following:</p>&#13;
<ul>&#13;
<li><p>How we create and use <span class="obeylines-h"><span class="verb"><code class="inlineCode">NamedTuple</code></span></span> and frozen <span class="obeylines-h"><span class="verb"><code class="inlineCode">@dataclass</code></span></span> definitions.</p></li>&#13;
<li><p>Ways that immutable <span class="obeylines-h"><span class="verb"><code class="inlineCode">NamedTuple</code></span></span> or frozen <span class="obeylines-h"><span class="verb"><code class="inlineCode">@dataclass</code></span></span> objects can be used instead of stateful object classes.</p></li>&#13;
<li><p>How to use the popular third-party <span class="obeylines-h"><span class="verb"><code class="inlineCode">pyrsistent</code></span></span> package instead of stateful object classes. This is not part of the standard library, and requires a separate install.</p></li>&#13;
<li><p>Some techniques to write generic functions outside any polymorphic class definition. While we can rely on callable classes to create a polymorphic class hierarchy, in some cases, this might be a needless overhead in a functional design. This will touch on using the <span class="obeylines-h"><span class="verb"><code class="inlineCode">match</code></span></span> statement for identifying types or structures.</p></li>&#13;
</ul>&#13;
<p>While frozen dataclasses and <span class="obeylines-h"><span class="verb"><code class="inlineCode">NamedTuple</code></span></span> subclasses are nearly equivalent, a frozen dataclass omits the sequence features that a <span class="obeylines-h"><span class="verb"><code class="inlineCode">NamedTuple</code></span></span> includes. Iterating over the members of a <span class="obeylines-h"><span class="verb"><code class="inlineCode">NamedTuple</code></span></span> object is a confusing feature; a dataclass doesn’t suffer from this potential problem.</p>&#13;
<p>We’ll start our journey by looking at using <span class="obeylines-h"><span class="verb"><code class="inlineCode">NamedTuple</code></span></span> subclasses. <span id="x1-153002r153"/></p>&#13;
<section id="using-tuples-to-collect-data" class="level3 sectionHead" data-number="0.11.1">&#13;
<h3 class="sectionHead" data-number="0.11.1"><span class="titlemark">7.1 </span> <span id="x1-1540001"/>Using tuples to collect data</h3>&#13;
<p>In <a href="Chapter_03.xhtml#x1-510003"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 3</span></a>, <a href="Chapter_03.xhtml#x1-510003"><span class="cmti-10x-x-109">Functions, Iterators, and Generators</span></a>, we showed two common techniques to work with tuples. We’ve also hinted<span id="dx1-154001"/> at a third way to handle complex<span id="dx1-154002"/> structures. We can go with any of the following techniques, depending on the circumstances:</p>&#13;
<ul>&#13;
<li><p>Use lambdas (or functions created with the <span class="obeylines-h"><span class="verb"><code class="inlineCode">def</code></span></span> statement) to select a named item based on the index</p></li>&#13;
<li><p>Use lambdas (or <span class="obeylines-h"><span class="verb"><code class="inlineCode">def</code></span></span> functions) with multiple positional parameters coupled with <span class="obeylines-h"><span class="verb"><code class="inlineCode">*args</code></span></span> to assign a tuple of items to parameter names</p></li>&#13;
<li><p>Use a <span class="obeylines-h"><span class="verb"><code class="inlineCode">NamedTuple</code></span></span> class to select an item by attribute name or index</p></li>&#13;
</ul>&#13;
<p>Our trip data, introduced in <a href="Chapter_04.xhtml#x1-740004"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 4</span></a>, <a href="Chapter_04.xhtml#x1-740004"><span class="cmti-10x-x-109">Working with Collections</span></a>, has a rather complex structure. The data started as an ordinary time series of position reports. To compute the distances covered, we transposed the data into a sequence of legs with a start position, end position, and distance as a nested three-tuple.</p>&#13;
<p>Each item in the sequence of legs looks as follows as a three-tuple:</p>&#13;
<pre>&gt;&gt;&gt; some_leg = (&#13;
... (37.549016, -76.330295),&#13;
... (37.840832, -76.273834),&#13;
... 17.7246&#13;
... )&#13;
</pre>&#13;
<p>The first two items are the starting and ending points. The third item is the distance between the points. This is a short trip between two points on the Chesapeake Bay.</p>&#13;
<p>A nested tuple of tuples<span id="dx1-154009"/> can be rather difficult to read; for example, expressions such as <span class="obeylines-h"><span class="verb"><code class="inlineCode">some_leg[0][0]</code></span></span> aren’t very informative.</p>&#13;
<p>Let’s look at the three alternatives<span id="dx1-154010"/> for selecting values out of a tuple. The first technique involves defining some simple selection functions that can pick items from a tuple by index position:</p>&#13;
<div id="tcolobox-154" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; start = lambda leg: leg[0] &#13;
&gt;&gt;&gt; end = lambda leg: leg[1] &#13;
&gt;&gt;&gt; distance = lambda leg: leg[2] &#13;
 &#13;
&gt;&gt;&gt; latitude = lambda pt: pt[0] &#13;
&gt;&gt;&gt; longitude = lambda pt: pt[1]</code></pre>&#13;
&#13;
</div>&#13;
<p>With these definitions, we can use <span class="obeylines-h"><span class="verb"><code class="inlineCode">latitude(start(some_leg))</code></span></span> to refer to a specific piece of data. It looks like this code example:</p>&#13;
<pre>&gt;&gt;&gt; latitude(start(some_leg))&#13;
37.549016&#13;
</pre>&#13;
<p>It’s awkward to provide type hints for lambdas. The following shows how this becomes complex-looking:</p>&#13;
<pre id="listing-149" class="lstlisting"><code>from collections.abc import Callable &#13;
from typing import TypeAlias &#13;
 &#13;
Point: TypeAlias = tuple[float, float] &#13;
Leg: TypeAlias = tuple[Point, Point, float] &#13;
 &#13;
start: Callable[[Leg], Point] = lambda leg: leg[0]</code></pre>&#13;
<p>The type hint must be provided<span id="dx1-154028"/> as part of the assignment statement. This tells <span class="keyWord">mypy </span>that the object named <span class="obeylines-h"><span class="verb"><code class="inlineCode">start</code></span></span> is a callable<span id="dx1-154029"/> function that accepts a single parameter of a type named <span class="obeylines-h"><span class="verb"><code class="inlineCode">Leg</code></span></span> and returns a result of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">Point</code></span></span> type. A function created with the <span class="obeylines-h"><span class="verb"><code class="inlineCode">def</code></span></span> statement will usually have an easier-to-read type hint.</p>&#13;
<p>A variation on this first technique for collecting complex data uses the <span class="obeylines-h"><span class="verb"><code class="inlineCode">*parameter</code></span></span> notation to conceal some details of the index positions. The following are some selection functions that are evaluated with the <span class="obeylines-h"><span class="verb"><code class="inlineCode">*</code></span></span> notation:</p>&#13;
<div id="tcolobox-155" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; start_s = lambda start, end, distance: start &#13;
&gt;&gt;&gt; end_s = lambda start, end, distance: end &#13;
&gt;&gt;&gt; distance_s = lambda start, end, distance: distance &#13;
 &#13;
&gt;&gt;&gt; latitude_s = lambda lat, lon: lat &#13;
&gt;&gt;&gt; longitude_s = lambda lat, lon: lon</code></pre>&#13;
&#13;
</div>&#13;
<p>With these definitions, we can extract specific pieces of data from a tuple. We’ve used the <span class="obeylines-h"><span class="verb"><code class="inlineCode">_s</code></span></span> suffix to emphasize the need to use star, <span class="obeylines-h"><span class="verb"><code class="inlineCode">*</code></span></span>, when evaluating these lambdas. It looks like this code example:</p>&#13;
<div id="tcolobox-156" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; longitude_s(*start_s(*some_leg)) &#13;
-76.330295</code></pre>&#13;
&#13;
</div>&#13;
<p>This has the advantage of a little more clarity in the function definitions. The association between position and name is given by the list of parameter names. It can look a little odd to see the <span class="obeylines-h"><span class="verb"><code class="inlineCode">*</code></span></span> operator in front of the tuple arguments to these selection functions. This operator is useful because it maps each item in a tuple to a parameter of the function.</p>&#13;
<p>While these are very functional, the syntax for selecting individual attributes can be confusing. Python offers two object-oriented alternatives, <span class="obeylines-h"><span class="verb"><code class="inlineCode">NamedTuple</code></span></span> and the frozen <span class="obeylines-h"><span class="verb"><code class="inlineCode">@dataclass</code></span></span>. <span id="x1-154040r161"/></p>&#13;
</section>&#13;
<section id="using-namedtuple-to-collect-data" class="level3 sectionHead" data-number="0.11.2">&#13;
<h3 class="sectionHead" data-number="0.11.2"><span class="titlemark">7.2 </span> <span id="x1-1550002"/>Using NamedTuple to collect data</h3>&#13;
<p>The second technique for collecting<span id="dx1-155001"/> data into a complex structure is <span class="obeylines-h"><span class="verb"><code class="inlineCode">typing.NamedTuple</code></span></span>. The idea is to create<span id="dx1-155002"/> a class that is an immutable tuple with named attributes. There are two variations available:</p>&#13;
<ul>&#13;
<li><p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">namedtuple</code></span></span> function in the <span class="obeylines-h"><span class="verb"><code class="inlineCode">collections</code></span></span> module.</p></li>&#13;
<li><p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">NamedTuple</code></span></span> base class in the <span class="obeylines-h"><span class="verb"><code class="inlineCode">typing</code></span></span> module. We’ll use this almost exclusively because it allows explicit type hinting.</p></li>&#13;
</ul>&#13;
<p>In the following examples, we’ll use nested <span class="obeylines-h"><span class="verb"><code class="inlineCode">NamedTuple</code></span></span> classes such as the following:</p>&#13;
<pre id="listing-150" class="lstlisting"><code>from typing import NamedTuple &#13;
 &#13;
class PointNT(NamedTuple): &#13;
    latitude: float &#13;
    longitude: float &#13;
 &#13;
class LegNT(NamedTuple): &#13;
    start: PointNT &#13;
    end: PointNT &#13;
    distance: float</code></pre>&#13;
<p>This changes the data structure from simple anonymous tuples to named tuples with type hints provided for each attribute. Here’s an example:</p>&#13;
<div id="tcolobox-157" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; first_leg = LegNT( &#13;
...     PointNT(29.050501, -80.651169), &#13;
...     PointNT(27.186001, -80.139503), &#13;
...     115.1751) &#13;
&gt;&gt;&gt; first_leg.start.latitude &#13;
29.050501</code></pre>&#13;
&#13;
</div>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">first_leg</code></span></span> object was built as the <span class="obeylines-h"><span class="verb"><code class="inlineCode">LegNT</code></span></span> subclass of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">NamedTuple</code></span></span> class. This object contains two other named tuple objects and a float value. Using <span class="obeylines-h"><span class="verb"><code class="inlineCode">first_leg.start.latitude</code></span></span> will fetch a particular piece of data from inside the tuple structure. The change from prefix function names to postfix attribute<span id="dx1-155020"/> names can be seen as a helpful emphasis. It can also be seen as a confusing shift in the syntax.</p>&#13;
<div id="tcolobox-158" class="packt_tip">&#13;
&#13;
&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">NT</code></span></span> suffix in the names is <span class="keyWord">not </span>a recommended practice.</p>&#13;
<p>We’ve included the suffix in the book to emphatically distinguish among similar-looking solutions to the problem of defining a useful class.</p>&#13;
<p>In actual applications, we’d choose one definition, and use the simplest, clearest names possible, avoiding needless suffixes that clutter up textbooks like this one.</p>&#13;
&#13;
</div>&#13;
<p>Replacing simple <span class="obeylines-h"><span class="verb"><code class="inlineCode">tuple()</code></span></span> functions with appropriate <span class="obeylines-h"><span class="verb"><code class="inlineCode">LegNT()</code></span></span> or <span class="obeylines-h"><span class="verb"><code class="inlineCode">PointNT()</code></span></span> function calls is important. This changes the processing that builds the data structure. It provides an explicitly named structure with type hints that can be checked by the <span class="keyWord">mypy </span>tool.</p>&#13;
<p>For example, take a look at the following code snippet to create point pairs from source data:</p>&#13;
<pre id="listing-151" class="lstlisting"><code>from collections.abc import Iterable, Iterator &#13;
from Chapter04.ch04_ex1 import pick_lat_lon &#13;
 &#13;
def float_lat_lon_tuple( &#13;
        row_iter: Iterable[list[str]] &#13;
) -&gt; Iterator[tuple[float, float]]: &#13;
    lat_lon_iter = (pick_lat_lon(*row) for row in row_iter) &#13;
    return ( &#13;
        (float(lat), float(lon)) &#13;
        for lat, lon in lat_lon_iter &#13;
    )</code></pre>&#13;
<p>This requires an iterable object whose individual items are a list of strings. A CSV reader, or KML reader, can do this. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">pick_lat_lon()</code></span></span> function picks two values from the row. The generator expression applies the <span class="obeylines-h"><span class="verb"><code class="inlineCode">pick_lat_lon()</code></span></span> function to the data source. The final generator expression<span id="dx1-155032"/> creates a somewhat more useful two-tuple from the two string values.</p>&#13;
<p>The preceding code would be changed to the following code snippet to create <span class="obeylines-h"><span class="verb"><code class="inlineCode">Point</code></span></span> objects:</p>&#13;
<pre id="listing-152" class="lstlisting"><code>from Chapter04.ch04_ex1 import pick_lat_lon &#13;
from typing import Iterable, Iterator &#13;
 &#13;
def float_lat_lon( &#13;
    row_iter: Iterable[list[str]] &#13;
) -&gt; Iterator[PointNT]: &#13;
              #------ &#13;
    lat_lon_iter = (pick_lat_lon(*row) for row in row_iter) &#13;
    return ( &#13;
        PointNT(float(lat), float(lon)) &#13;
        #------ &#13;
        for lat, lon in lat_lon_iter &#13;
    )</code></pre>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">PointNT()</code></span></span> constructor has been injected into the code. The data type that is returned is revised to be <span class="obeylines-h"><span class="verb"><code class="inlineCode">Iterator[PointNT]</code></span></span>. It’s clear that this function builds <span class="obeylines-h"><span class="verb"><code class="inlineCode">Point</code></span></span> objects instead of anonymous two-tuples of floating-point coordinates.</p>&#13;
<p>Similarly, we can introduce the following to build the complete trip of <span class="obeylines-h"><span class="verb"><code class="inlineCode">LegNT</code></span></span> objects:</p>&#13;
<pre id="listing-153" class="lstlisting"><code>from collections.abc import Iterable, Iterator &#13;
from typing import cast, TextIO &#13;
import urllib.request &#13;
from Chapter04.ch04_ex1 import legs, haversine, row_iter_kml &#13;
 &#13;
source_url = "file:./Winter%202012-2013.kml" &#13;
def get_trip(url: str=source_url) -&gt; list[LegNT]: &#13;
    with urllib.request.urlopen(url) as source: &#13;
        path_iter = float_lat_lon(row_iter_kml(source)) &#13;
        pair_iter = legs(path_iter) &#13;
        trip_iter = ( &#13;
            LegNT(start, end, round(haversine(start, end), 4)) &#13;
            for start, end in pair_iter &#13;
        ) &#13;
        trip = list(trip_iter) &#13;
    return trip</code></pre>&#13;
<p>The processing is defined as a sequence<span id="dx1-155062"/> of generator expressions, each one of which is lazy and operates on a single object. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">path_iter</code></span></span> object uses two generator functions, <span class="obeylines-h"><span class="verb"><code class="inlineCode">row_iter_kml()</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">float_lat_lon()</code></span></span>, to read the rows from a KML file, pick fields, and convert them to <span class="obeylines-h"><span class="verb"><code class="inlineCode">Point</code></span></span> objects. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">pair_iter()</code></span></span> object uses the <span class="obeylines-h"><span class="verb"><code class="inlineCode">legs()</code></span></span> generator function to yield overlapping pairs of <span class="obeylines-h"><span class="verb"><code class="inlineCode">Point</code></span></span> objects showing the start and end of each leg.</p>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">trip_iter</code></span></span> generator expression creates the final <span class="obeylines-h"><span class="verb"><code class="inlineCode">LegNT</code></span></span> objects from pairs of <span class="obeylines-h"><span class="verb"><code class="inlineCode">Point</code></span></span> objects. These generated objects are consumed by the <span class="obeylines-h"><span class="verb"><code class="inlineCode">list()</code></span></span> function to create a single list of legs. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">haversine()</code></span></span> function from <a href="Chapter_04.xhtml#x1-740004"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 4</span></a>, <a href="Chapter_04.xhtml#x1-740004"><span class="cmti-10x-x-109">Working</span> <span class="cmti-10x-x-109">with Collections</span></a>, is used to compute the distance.</p>&#13;
<div id="tcolobox-159" class="packt_tip">&#13;
&#13;
&#13;
<p>The rounding is applied in this function for two reasons. First, as a practical matter, 0.0001 nautical miles is about 20 cm (7 inches). Pragmatically, rounding to 0.001 nautical miles involves fewer digits that offer a false sense of precision. Second–and more important–it makes the unit testing more reliable across platforms if we avoid looking at all the digits of a floating-point number.</p>&#13;
&#13;
</div>&#13;
<p>The final <span class="obeylines-h"><span class="verb"><code class="inlineCode">trip</code></span></span> object is a sequence of <span class="obeylines-h"><span class="verb"><code class="inlineCode">LegNT</code></span></span> instances. It will look as follows when we try to print it:</p>&#13;
<div id="tcolobox-160" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; source_url = "file:./Winter%202012-2013.kml" &#13;
&gt;&gt;&gt; trip = get_trip(source_url) &#13;
 &#13;
&gt;&gt;&gt; trip[0].start &#13;
PointNT(latitude=37.54901619777347, longitude=-76.33029518659048) &#13;
&gt;&gt;&gt; trip[0].end &#13;
PointNT(latitude=37.840832, longitude=-76.273834) &#13;
&gt;&gt;&gt; trip[0].distance &#13;
17.7246</code></pre>&#13;
&#13;
</div>&#13;
<div id="tcolobox-161" class="packt_tip">&#13;
&#13;
&#13;
<p>It’s important to note that the <span class="obeylines-h"><span class="verb"><code class="inlineCode">haversine()</code></span></span> function was written to use simple tuples. We’ve reused this function with a <span class="obeylines-h"><span class="verb"><code class="inlineCode">NamedTuple</code></span></span> class instance. As we carefully preserved the order of the arguments, this small change in representation from anonymous tuple to named tuple was handled gracefully by Python.</p>&#13;
&#13;
</div>&#13;
<p>Since this is a class<span id="dx1-155073"/> definition, we can easily add methods and properties. This ability to add features to a <span class="obeylines-h"><span class="verb"><code class="inlineCode">NamedTuple</code></span></span> makes them particularly useful for computing derived values. We can, for example, more directly implement the distance computation as part of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">Point</code></span></span> class, as shown in the following code:</p>&#13;
<pre id="listing-154" class="lstlisting"><code>import math &#13;
 &#13;
class PointE(NamedTuple): &#13;
    latitude: float &#13;
    longitude: float &#13;
 &#13;
    def distance(self, other: "PointE", R: float = 360*60/math.tau) -&gt; float: &#13;
        """Equirectangular, ’flat-earth’ distance.""" &#13;
        Δϕ = ( &#13;
            math.radians(self.latitude) - math.radians(other.latitude) &#13;
        ) &#13;
        Δλ = ( &#13;
            math.radians(self.longitude) - math.radians(other.longitude) &#13;
        ) &#13;
        mid_ϕ = ( &#13;
            (math.radians(self.latitude) - math.radians(other.latitude)) &#13;
            / 2 &#13;
        ) &#13;
        x = R * Δλ * math.cos(mid_ϕ) &#13;
        y = R * Δϕ &#13;
        return math.hypot(x, y)</code></pre>&#13;
<p>Given this definition<span id="dx1-155095"/> of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">PointE</code></span></span> class, we have encapsulated the functions for working with points and distances. This can be helpful because it gives the reader a single place to look for the relevant attributes and methods.</p>&#13;
<div id="tcolobox-162" class="packt_tip">&#13;
&#13;
&#13;
<p>Within the body of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">PointE</code></span></span> class, we can’t easily refer to the class. The class name doesn’t exist within the body of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">class</code></span></span> statement. The <span class="keyWord">mypy </span>tool lets us use a string instead of a class name to resolve these rare cases when a class needs to refer to itself.</p>&#13;
&#13;
</div>&#13;
<p>We can use this class as shown in the following example:</p>&#13;
<div id="tcolobox-163" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; start = PointE(latitude=38.330166, longitude=-76.458504) &#13;
&gt;&gt;&gt; end = PointE(latitude=38.976334, longitude=-76.473503) &#13;
 &#13;
# Apply the distance() method of the start object... &#13;
&gt;&gt;&gt; leg = LegNT(start, end, round(start.distance(end), 4)) &#13;
&gt;&gt;&gt; leg.start == start &#13;
True &#13;
&gt;&gt;&gt; leg.end == end &#13;
True &#13;
&gt;&gt;&gt; leg.distance &#13;
38.7805</code></pre>&#13;
&#13;
</div>&#13;
<p>In most cases, the <span class="obeylines-h"><span class="verb"><code class="inlineCode">NamedTuple</code></span></span> class definition adds clarity. The use of <span class="obeylines-h"><span class="verb"><code class="inlineCode">NamedTuple</code></span></span> will lead to a change from function-like prefix syntax to object-like suffix syntax. <span id="x1-155108r162"/></p>&#13;
</section>&#13;
<section id="using-frozen-dataclasses-to-collect-data" class="level3 sectionHead" data-number="0.11.3">&#13;
<h3 class="sectionHead" data-number="0.11.3"><span class="titlemark">7.3 </span> <span id="x1-1560003"/>Using frozen dataclasses to collect data</h3>&#13;
<p>The third technique for collecting<span id="dx1-156001"/> data into a complex structure is the frozen <span class="obeylines-h"><span class="verb"><code class="inlineCode">@dataclass</code></span></span>. The idea is to create a class that is an immutable collection of named attributes.</p>&#13;
<p>Following the example from the previous section, we can have nested dataclasses such as the following:</p>&#13;
<pre id="listing-155" class="lstlisting"><code>from dataclasses import dataclass &#13;
 &#13;
@dataclass(frozen=True) &#13;
class PointDC: &#13;
    latitude: float &#13;
    longitude: float &#13;
 &#13;
@dataclass(frozen=True) &#13;
class LegDC: &#13;
    start: PointDC &#13;
    end: PointDC &#13;
    distance: float</code></pre>&#13;
<p>We’ve used a decorator, <span class="obeylines-h"><span class="verb"><code class="inlineCode">@dataclass(frozen=True)</code></span></span>, in front of the class definition to create an immutable (known as ”frozen”) dataclass. The decorator will add a number of functions for us, building a fairly sophisticated class definition without our having to provide anything other than the attributes. For more information on decorators, see <a href="Chapter_12.xhtml#x1-25000012"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 12</span></a>, <a href="Chapter_12.xhtml#x1-25000012"><span class="cmti-10x-x-109">Decorator Design</span> <span class="cmti-10x-x-109">Techniques</span></a>.</p>&#13;
<p>This also changes the data structure from simple anonymous tuples to a class definition with type hints provided for each attribute. Here’s an example:</p>&#13;
<div id="tcolobox-164" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; first_leg = LegDC( &#13;
...     PointDC(29.050501, -80.651169), &#13;
...     PointDC(27.186001, -80.139503), &#13;
...     115.1751) &#13;
&gt;&gt;&gt; first_leg.start.latitude &#13;
29.050501</code></pre>&#13;
&#13;
</div>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">first_leg</code></span></span> object was built as the <span class="obeylines-h"><span class="verb"><code class="inlineCode">LegDC</code></span></span> instance. This object contains<span id="dx1-156021"/> two other <span class="obeylines-h"><span class="verb"><code class="inlineCode">PointDC</code></span></span> objects and a float value. Using <span class="obeylines-h"><span class="verb"><code class="inlineCode">first_leg.start.latitude</code></span></span> will fetch a particular attribute of the object.</p>&#13;
<div id="tcolobox-165" class="packt_tip">&#13;
&#13;
&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">DC</code></span></span> suffix in the names is <span class="keyWord">not </span>a recommended practice.</p>&#13;
<p>We’ve included the suffix in the book to emphatically distinguish among similar-looking solutions to the problem of defining a useful class.</p>&#13;
<p>In actual applications, we’d choose one definition, and use the simplest, clearest names possible, avoiding needless suffixes that clutter up textbooks like this one.</p>&#13;
&#13;
</div>&#13;
<p>Replacing a <span class="obeylines-h"><span class="verb"><code class="inlineCode">()</code></span></span> tuple construction with appropriate <span class="obeylines-h"><span class="verb"><code class="inlineCode">LegDC()</code></span></span> or <span class="obeylines-h"><span class="verb"><code class="inlineCode">PointDC()</code></span></span> constructors builds a more sophisticated data structure than anonymous tuples. It provides an explicitly named structure with type hints that can be checked<span id="dx1-156022"/> by the <span class="keyWord">mypy </span>tool.</p>&#13;
<p>Comparing frozen dataclasses with <span class="obeylines-h"><span class="verb"><code class="inlineCode">NamedTuple</code></span></span> instances can lead to a ”Which is better?” discussion. There are a few tradeoffs here. Most notably, a <span class="obeylines-h"><span class="verb"><code class="inlineCode">NamedTuple</code></span></span> object is extremely simple: it ties up relatively little memory and offers few methods. A dataclass, on the other hand, can have a great deal of built-in functionality, and can tie up more memory. We can manage this using the <span class="obeylines-h"><span class="verb"><code class="inlineCode">slots=True</code></span></span> argument with the <span class="obeylines-h"><span class="verb"><code class="inlineCode">@dataclass</code></span></span> decorator, something we’ll address later in this section.</p>&#13;
<p>Additionally, a <span class="obeylines-h"><span class="verb"><code class="inlineCode">NamedTuple</code></span></span> object is a sequence of values. We can use an iterator over the tuple’s attributes, a processing option that seems to create nothing but confusion. Iterating over the values without using the names subverts the essential design concept of naming the members of the tuple.</p>&#13;
<p>A simple procedure for evaluating<span id="dx1-156023"/> memory use is to create millions of instances of a class and see how much memory is allocated for the Python runtime. This works out best because Python object size involves a recursive walk through all of the associated objects, each of which has its own complex sizing computation. Generally, we only care about aggregate memory use for a large collection of objects, so it’s more effective to measure that directly.</p>&#13;
<p>Here is one class definition to support a script designed to evaluate the size of 1,000,000 <span class="obeylines-h"><span class="verb"><code class="inlineCode">NamedTuple</code></span></span> objects:</p>&#13;
<pre id="listing-156" class="lstlisting"><code>from typing import NamedTuple &#13;
 &#13;
class LargeNT(NamedTuple): &#13;
  a: str &#13;
  b: int &#13;
  c: float &#13;
  d: complex</code></pre>&#13;
<p>We can then define a function to create a million objects, assigning them to a variable, <span class="obeylines-h"><span class="verb"><code class="inlineCode">big_sequence</code></span></span>. The function can then report the amount of memory allocated by the Python runtime. This function will involve some odd-looking overheads. The documentation for the <span class="obeylines-h"><span class="verb"><code class="inlineCode">getallocatedblocks()</code></span></span> function advises us to clear the type cache with the <span class="obeylines-h"><span class="verb"><code class="inlineCode">sys._clear_type_cache()</code></span></span> function and force garbage collection via the <span class="obeylines-h"><span class="verb"><code class="inlineCode">gc.collect()</code></span></span> function to clean up the objects that are no longer referenced. These two steps should compact memory to the smallest size, and provide more repeatable reports on the use of storage by this sequence of objects.</p>&#13;
<p>The following function creates a million instances of a given type and displays the allocated memory:</p>&#13;
<pre id="listing-157" class="lstlisting"><code>from typing import Type, Any &#13;
 &#13;
def sizing(obj_type: Type[Any]) -&gt; None: &#13;
    big_sequence = [ &#13;
        obj_type(f"Hello, {i}", 42*i, 3.1415926*i, i+2j) &#13;
        for i in range(1_000_000) &#13;
    ] &#13;
    sys._clear_type_cache() &#13;
    gc.collect() &#13;
    print(f"{obj_type.__name__} {sys.getallocatedblocks()}") &#13;
    del big_sequence</code></pre>&#13;
<p>Evaluating this function<span id="dx1-156042"/> with different class definitions will reveal how much storage is occupied by 1,000,000 objects of that class. We can use <span class="obeylines-h"><span class="verb"><code class="inlineCode">sizing(LargeNT)</code></span></span> to see the space taken up by a <span class="obeylines-h"><span class="verb"><code class="inlineCode">NamedTuple</code></span></span> class.</p>&#13;
<p>We’ll need to define alternatives, of course. We can define a frozen dataclass. Additionally, we can use <span class="obeylines-h"><span class="verb"><code class="inlineCode">@dataclass(frozen=True,</code><code class="inlineCode"> slots=True)</code></span></span> to see what impact the use of <span class="obeylines-h"><span class="verb"><code class="inlineCode">__slots__</code></span></span> has on the object sizing. The bodies of the classes must all have the same attributes in the same order to simplify construction of the objects by the <span class="obeylines-h"><span class="verb"><code class="inlineCode">sizing()</code></span></span> function.</p>&#13;
<p>The actual results are highly implementation-specific, but the author’s results on macOS Python 3.10.0 show the following:</p>&#13;
<div class="tabular">&#13;
<table id="TBL-2" class="tabular">&#13;
<tbody>&#13;
<tr class="odd hline">&#13;
<td><hr/>&#13;
</td>&#13;
<td><hr/>&#13;
</td>&#13;
</tr>&#13;
<tr id="TBL-2-1-" class="even" style="vertical-align:baseline;">&#13;
<td id="TBL-2-1-1" class="td11" style="text-align: left; white-space: nowrap;"><span class="keyWord">Class Kind </span></td>&#13;
<td id="TBL-2-1-2" class="td11" style="text-align: right; white-space: nowrap;"><span class="keyWord">Blocks Allocated </span></td>&#13;
</tr>&#13;
<tr id="TBL-2-2-" class="odd" style="vertical-align:baseline;">&#13;
<td id="TBL-2-2-1" class="td11" style="text-align: left; white-space: nowrap;">LargeNT</td>&#13;
<td id="TBL-2-2-2" class="td11" style="text-align: right; white-space: nowrap;">5,035,408</td>&#13;
</tr>&#13;
<tr id="TBL-2-3-" class="even" style="vertical-align:baseline;">&#13;
<td id="TBL-2-3-1" class="td11" style="text-align: left; white-space: nowrap;">LargeDC</td>&#13;
<td id="TBL-2-3-2" class="td11" style="text-align: right; white-space: nowrap;">7,035,404</td>&#13;
</tr>&#13;
<tr id="TBL-2-4-" class="odd" style="vertical-align:baseline;">&#13;
<td id="TBL-2-4-1" class="td11" style="text-align: left; white-space: nowrap;">LargeDC_Slots</td>&#13;
<td id="TBL-2-4-2" class="td11" style="text-align: right; white-space: nowrap;">5,035,569</td>&#13;
</tr>&#13;
<tr id="TBL-2-5-" class="even" style="vertical-align:baseline;">&#13;
<td id="TBL-2-5-1" class="td11" style="text-align: left; white-space: nowrap;">Baseline</td>&#13;
<td id="TBL-2-5-2" class="td11" style="text-align: right; white-space: nowrap;">35,425</td>&#13;
</tr>&#13;
<tr class="odd hline">&#13;
<td><hr/>&#13;
</td>&#13;
<td><hr/>&#13;
</td>&#13;
</tr>&#13;
<tr id="TBL-2-6-" class="even" style="vertical-align:baseline;">&#13;
<td id="TBL-2-6-1" class="td11" style="text-align: left; white-space: nowrap;"/>&#13;
<td/>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div>&#13;
<p>This suggests that a <span class="obeylines-h"><span class="verb"><code class="inlineCode">@dataclass</code></span></span> will use about 40% more memory than a <span class="obeylines-h"><span class="verb"><code class="inlineCode">NamedTuple</code></span></span> or a <span class="obeylines-h"><span class="verb"><code class="inlineCode">@dataclass</code></span></span> with <span class="obeylines-h"><span class="verb"><code class="inlineCode">slots=True</code></span></span>.</p>&#13;
<p>This also suggests that a radically different design—one that uses iterators to avoid creating large in-memory collections—can use substantially less memory. What’s important is to have a correct solution in hand, and then explore alternative implementations to see which makes most effective use of the machine resources.</p>&#13;
<p>How to implement a complicated initialization is the most telling distinction among the various class definition approaches. We’ll look at that next. <span id="x1-156043r163"/></p>&#13;
</section>&#13;
<section id="complicated-object-initialization-and-property-computations" class="level3 sectionHead" data-number="0.11.4">&#13;
<h3 class="sectionHead" data-number="0.11.4"><span class="titlemark">7.4 </span> <span id="x1-1570004"/>Complicated object initialization and property computations</h3>&#13;
<p>When working<span id="dx1-157001"/> with data in unhelpful formats, it often becomes necessary to build Python objects from source data that has a different structure or different underlying object types. There are two overall ways to treat object creation:</p>&#13;
<ul>&#13;
<li><p>It’s part of the application as a whole. Data should be decomposed by a parser and recomposed into useful Python objects. This is the approach we’ve taken in previous examples.</p></li>&#13;
<li><p>It’s part of the object’s class definition. Source data should be provided more or less in its raw form, and the class definition will perform the necessary conversions.</p></li>&#13;
</ul>&#13;
<p>This distinction is never simple, nor crisp. Pragmatic considerations will identify the best approach for each unique case of building a Pythonic object from source data. The two examples that point to the distinct choices available are the following:</p>&#13;
<ul>&#13;
<li><p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">Point</code></span></span> class: The syntax for geographic points is highly variable. A common approach is simple floating-point degree numbers. However, some sources provide degrees and minutes. Others might provide separate degrees, minutes, and seconds. Further, there are also Open Location Codes, which encode latitude and longitude. (See <a href="https://maps.google.com/pluscodes/" class="url">https://maps.google.com/pluscodes/</a> for more information.) All of these various parsers should not be part of the class.</p></li>&#13;
<li><p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">LegNT</code></span></span> (or <span class="obeylines-h"><span class="verb"><code class="inlineCode">LegDC</code></span></span>) class: The leg includes two points and a distance. The distance can be seeded as a simple value. It can also be computed as a property. A third choice is to use a sophisticated object builder. In effect, our <span class="obeylines-h"><span class="verb"><code class="inlineCode">get_trip()</code></span></span> function (defined in <a href="#x1-1550002"><span class="cmti-10x-x-109">Using NamedTuple</span> <span class="cmti-10x-x-109">to collect data</span></a>) has implicitly included an object builder for <span class="obeylines-h"><span class="verb"><code class="inlineCode">LegNT</code></span></span> objects.</p></li>&#13;
</ul>&#13;
<p>Using <span class="obeylines-h"><span class="verb"><code class="inlineCode">LegNT(start,</code><code class="inlineCode"> end,</code><code class="inlineCode"> round(haversine(start,</code><code class="inlineCode"> end),</code><code class="inlineCode"> 4))</code></span></span> to create a <span class="obeylines-h"><span class="verb"><code class="inlineCode">LegNT</code></span></span> instance isn’t wrong, but it makes a number of assumptions that need to be challenged. Here are some of the assumptions:</p>&#13;
<ul>&#13;
<li><p>The application should always use <span class="obeylines-h"><span class="verb"><code class="inlineCode">haversine()</code></span></span> to compute distances.</p></li>&#13;
<li><p>The application should always pre-compute the distance. This is often an optimization question. Computing a distance once and saving it is helpful if every leg’s distance will be examined. If distances are not always needed, it can be less expensive to compute the distance only when required.</p></li>&#13;
<li><p>We always want to create <span class="obeylines-h"><span class="verb"><code class="inlineCode">LegNT</code></span></span> instances. We’ve already seen cases where we might want a <span class="obeylines-h"><span class="verb"><code class="inlineCode">@dataclass</code></span></span> implementation. In the next section, we’ll look at a <span class="obeylines-h"><span class="verb"><code class="inlineCode">pyrsistent.PRecord</code></span></span> implementation.</p></li>&#13;
</ul>&#13;
<p>One general way to encapsulate<span id="dx1-157002"/> the construction of <span class="obeylines-h"><span class="verb"><code class="inlineCode">LegNT</code></span></span> instances is to use a <span class="obeylines-h"><span class="verb"><code class="inlineCode">@classmethod</code></span></span> to handle complex initialization. Additionally, a <span class="obeylines-h"><span class="verb"><code class="inlineCode">@dataclass</code></span></span> provides some additional initialization techniques.</p>&#13;
<p>A slightly better way to define a <span class="obeylines-h"><span class="verb"><code class="inlineCode">NamedTuple</code></span></span> initialization is shown in the following example:</p>&#13;
<pre id="listing-158" class="lstlisting"><code>from typing import NamedTuple &#13;
 &#13;
class EagerLeg(NamedTuple): &#13;
    start: Point &#13;
    end: Point &#13;
    distance: float &#13;
 &#13;
    @classmethod &#13;
    def create(cls, start: Point, end: Point) -&gt; "EagerLeg": &#13;
        return cls( &#13;
            start=start, &#13;
            end=end, &#13;
            distance=round(haversine(start, end), 4) &#13;
        )</code></pre>&#13;
<p>Compare the above definition, which eagerly computes the distance, with the following, which lazily computes the distance:</p>&#13;
<pre id="listing-159" class="lstlisting"><code>from typing import NamedTuple &#13;
 &#13;
class LazyLeg(NamedTuple): &#13;
    start: Point &#13;
    end: Point &#13;
 &#13;
    @property &#13;
    def distance(self) -&gt; float: &#13;
        return round(haversine(self.start, self.end), 4) &#13;
 &#13;
    @classmethod &#13;
    def create(cls, start: Point, end: Point) -&gt; "LazyLeg": &#13;
        return cls( &#13;
            start=start, &#13;
            end=end &#13;
        )</code></pre>&#13;
<p>Both of these class definitions have an identical <span class="obeylines-h"><span class="verb"><code class="inlineCode">create()</code></span></span> method. We can use <span class="obeylines-h"><span class="verb"><code class="inlineCode">EagerLeg.create(start,</code><code class="inlineCode"> end)</code></span></span> or <span class="obeylines-h"><span class="verb"><code class="inlineCode">LazyLeg.create(start,</code><code class="inlineCode"> end)</code></span></span> without breaking anything else in the application.</p>&#13;
<p>What’s most important is that the decision<span id="dx1-157033"/> to compute values eagerly or lazily becomes a decision that we can alter at any time. We can replace these two definitions to see which has higher performance for our specific application’s needs. The distance computation, similarly, is now part of this class, making it easier to define a subclass to make a change to the application.</p>&#13;
<p>A dataclass offers a somewhat more complex and flexible interface for object construction: a <span class="obeylines-h"><span class="verb"><code class="inlineCode">__post_init__()</code></span></span> method. This method is evaluated after the object’s fields have their values assigned, permitting eager calculation of derived values. This, however, can’t work for frozen dataclasses. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">__post_init__()</code></span></span> method can only be used for non-frozen dataclasses to eagerly compute additional values from the provided initialization values.</p>&#13;
<p>For dataclasses, as well as <span class="obeylines-h"><span class="verb"><code class="inlineCode">NamedTuple</code></span></span> classes, a <span class="obeylines-h"><span class="verb"><code class="inlineCode">@classmethod</code></span></span> creator is a good design pattern for doing initialization that involves eagerly computing attribute values.</p>&#13;
<p>As a final note on initialization,<span id="dx1-157034"/> there are three different syntax forms for creating named tuple objects. Here are the three choices:</p>&#13;
<ul>&#13;
<li><p>We can provide the values positionally. This works well when the order of the parameters is obvious. It looks like this:</p>&#13;
<pre id="listing-160" class="lstlisting"><code>LegNT(start, end, round(haversine(start, end), 4))</code></pre></li>&#13;
<li><p>We can unpack a sequence using the <span class="obeylines-h"><span class="verb"><code class="inlineCode">*</code></span></span> operator. This, too, requires the ordering of parameters be obvious. For example:</p>&#13;
<pre id="listing-161" class="lstlisting"><code>PointNT(*map(float, pick_lat_lon(*row)))</code></pre></li>&#13;
<li><p>We can use explicit keyword assignment. This has the advantage of making the parameter names clear and avoids hidden assumptions about ordering. Here’s an example:</p>&#13;
<pre id="listing-162" class="lstlisting"><code>PointNT(longitude=float(row[0]), latitude=float(row[1]))</code></pre></li>&#13;
</ul>&#13;
<p>These examples show one way to package the initialization of complex objects. What’s important is to avoid state change in these objects. A complex initialization is done exactly once, providing a single, focused place to understand how the object’s state was established. For this reason, it’s imperative for the initialization to be expressive of the object’s purpose as well as flexible to permit change. <span id="x1-157038r164"/></p>&#13;
</section>&#13;
<section id="using-pyrsistent-to-collect-data" class="level3 sectionHead" data-number="0.11.5">&#13;
<h3 class="sectionHead" data-number="0.11.5"><span class="titlemark">7.5 </span> <span id="x1-1580005"/>Using pyrsistent to collect data</h3>&#13;
<p>In addition<span id="dx1-158001"/> to Python’s <span class="obeylines-h"><span class="verb"><code class="inlineCode">NamedTuple</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">@dataclass</code></span></span> definitions, we can also use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">pyrsistent</code></span></span> module to create more complex<span id="dx1-158002"/> object instances. The huge advantage offered by the <span class="obeylines-h"><span class="verb"><code class="inlineCode">pyrsistent</code></span></span> module is that the collections are immutable. Instead of updating in place, a change to a collection works through a general-purpose ”evolution” object that creates a new immutable object with the changed value. In effect, what appears to be a state-changing method is actually an operator creating a new object.</p>&#13;
<p>The following<span id="dx1-158003"/> example shows<span id="dx1-158004"/> how to import the <span class="obeylines-h"><span class="verb"><code class="inlineCode">pyrsistent</code></span></span> module and create a mapping structure with names and values:</p>&#13;
<div id="tcolobox-166" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; import pyrsistent &#13;
&gt;&gt;&gt; v = pyrsistent.pmap({"hello": 42, "world": 3.14159}) &#13;
&gt;&gt;&gt; v  # doctest: +SKIP &#13;
pmap({’hello’: 42, ’world’: 3.14159}) &#13;
&gt;&gt;&gt; v[’hello’] &#13;
42 &#13;
&gt;&gt;&gt; v[’world’] &#13;
3.14159</code></pre>&#13;
&#13;
</div>&#13;
<p>We can’t change the value of this object, but we can evolve an object <span class="obeylines-h"><span class="verb"><code class="inlineCode">v</code></span></span> to a new object, <span class="obeylines-h"><span class="verb"><code class="inlineCode">v2</code></span></span>. This object has the same starting values, but also includes a changed attribute value. It looks like this:</p>&#13;
<div id="tcolobox-167" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; v2 = v.set("another", 2.71828) &#13;
&gt;&gt;&gt; v2    # doctest: +SKIP &#13;
pmap({’hello’: 42, ’world’: 3.14159, ’another’: 2.71828})</code></pre>&#13;
&#13;
</div>&#13;
<p>The original object, <span class="obeylines-h"><span class="verb"><code class="inlineCode">v</code></span></span>, is immutable, and its value hasn’t changed:</p>&#13;
<div id="tcolobox-168" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; v    # doctest: +SKIP &#13;
pmap({’hello’: 42, ’world’: 3.14159})</code></pre>&#13;
&#13;
</div>&#13;
<p>It can help to think of this operation as having two parts. First, the original object is cloned. After the cloning, the changes are applied. In the above example, the <span class="obeylines-h"><span class="verb"><code class="inlineCode">set()</code></span></span> method was used to provide a new key and value. We can create the evolution separately and apply it to an object to create a clone with changes applied. This seems ideal for an application where an audit history of changes is required.</p>&#13;
<p>Note that we had to prevent<span id="dx1-158021"/> using two examples as unit test cases. This is because the order of the keys isn’t fixed. It’s easy to check that the keys and values match our expectations, but a simplistic comparison with a dictionary literal doesn’t <span class="cmti-10x-x-109">always </span>work.</p>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">PRecord</code></span></span> class is appropriate<span id="dx1-158022"/> for defining complex objects. These objects are similar in some ways to a <span class="obeylines-h"><span class="verb"><code class="inlineCode">NamedTuple</code></span></span>. We’ll revisit our waypoint and leg data model using <span class="obeylines-h"><span class="verb"><code class="inlineCode">PRecord</code></span></span> instances. The definitions are given in the following example:</p>&#13;
<pre id="listing-163" class="lstlisting"><code>from pyrsistent import PRecord, field &#13;
 &#13;
class PointPR(PRecord):  # type: ignore [type-arg] &#13;
    latitude = field(type=float) &#13;
    longitude = field(type=float) &#13;
 &#13;
class LegPR(PRecord):  # type: ignore [type-arg] &#13;
    start = field(type=PointPR) &#13;
    end = field(type=PointPR) &#13;
    distance = field(type=float)</code></pre>&#13;
<p>Each field definition uses the sophisticated <span class="obeylines-h"><span class="verb"><code class="inlineCode">field()</code></span></span> function to build the definition of the attribute. In addition to a sequence of types, this function can specify an invariant condition that must be true for the values, an initial value, whether or not the field is mandatory, a factory function that builds appropriate values, and a function to serialize the value into a string.</p>&#13;
<div id="tcolobox-169" class="packt_tip">&#13;
&#13;
&#13;
<p>The PR suffix in the names is <span class="keyWord">not </span>a recommended practice.</p>&#13;
<p>We’ve included the suffix in the book to emphatically distinguish among similar-looking solutions to the problem of defining a useful class.</p>&#13;
<p>In actual applications, we’d choose one definition, and use the simplest, clearest names possible, avoiding needless suffixes that clutter up textbooks like this one.</p>&#13;
&#13;
</div>&#13;
<p>As an extension to these definitions, we could convert the point value into a more useful format using a serializer<span id="dx1-158033"/> function. This requires<span id="dx1-158034"/> some formatting details because there’s a slight difference in the way latitudes and longitudes are displayed. Latitudes include ”N” or ”S” and longitudes include ”E” or ”W”:</p>&#13;
<pre id="listing-164" class="lstlisting"><code>from math import isclose, modf &#13;
 &#13;
def to_dm(format: dict[str, str], point: float) -&gt; str: &#13;
    """Use {"+": "N", "-": "S"} for latitude; {"+": "E", "-": "W"} for longitude.""" &#13;
    sign = "-" if point &lt; 0 else "+" &#13;
    ms, d = modf(abs(point)) &#13;
    ms = 60 * ms &#13;
    # Handle the 59.999 case: &#13;
    if isclose(ms, 60, rel_tol=1e-5): &#13;
        ms = 0.0 &#13;
        d += 1 &#13;
    return f"{d:3.0f}{ms:.3f}’{format.get(sign, sign)}"</code></pre>&#13;
<p>This function can be included as part of the field definition for the <span class="obeylines-h"><span class="verb"><code class="inlineCode">PointPR</code></span></span> class; we must provide the function as the <span class="obeylines-h"><span class="verb"><code class="inlineCode">serializer=</code></span></span> parameter of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">field()</code></span></span> factory:</p>&#13;
<pre id="listing-165" class="lstlisting"><code>from pyrsistent import PRecord, field &#13;
 &#13;
class PointPR_S(PRecord):  # type: ignore[type-arg] &#13;
    latitude = field( &#13;
        type=float, &#13;
        serializer=( &#13;
            lambda format, value: &#13;
                to_dm((format or {}) | {"+": "N", "-": "S"}, value) &#13;
        ) &#13;
    ) &#13;
    longitude = field( &#13;
        type=float, &#13;
        serializer=( &#13;
            lambda format, value: &#13;
                to_dm((format or {}) | {"+": "E", "-": "W"}, value) &#13;
        ) &#13;
    )</code></pre>&#13;
<p>This lets us print a point in a nicely formatted style:</p>&#13;
<div id="tcolobox-170" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; p = PointPR_S(latitude=32.842833333, longitude=-79.929166666) &#13;
&gt;&gt;&gt; p.serialize()  # doctest: +SKIP &#13;
{’latitude’: " 32Â°50.570’N", ’longitude’: " 79Â°55.750’W"}</code></pre>&#13;
&#13;
</div>&#13;
<p>These definitions<span id="dx1-158068"/> will provide nearly identical<span id="dx1-158069"/> processing capabilities to the <span class="obeylines-h"><span class="verb"><code class="inlineCode">NamedTuple</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">@dataclass</code></span></span> examples shown earlier. We can, however, leverage some additional features of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">pyrsistent</code></span></span> package to create <span class="obeylines-h"><span class="verb"><code class="inlineCode">PVector</code></span></span> objects, which will be immutable sequences of waypoints in a trip. This requires a few small changes to previous applications.</p>&#13;
<p>The definition of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">get_trip()</code></span></span> function using <span class="obeylines-h"><span class="verb"><code class="inlineCode">pyrsistent</code></span></span> can look like this:</p>&#13;
<pre id="listing-166" class="lstlisting"><code>from collections.abc import Iterable, Iterator &#13;
from typing import TextIO &#13;
import urllib.request &#13;
from Chapter04.ch04_ex1 import legs, haversine, row_iter_kml &#13;
from pyrsistent import pvector &#13;
from pyrsistent.typing import PVector &#13;
 &#13;
source_url = "file:./Winter%202012-2013.kml" &#13;
def get_trip_p(url: str=source_url) -&gt; PVector[LegPR]: &#13;
    with urllib.request.urlopen(url) as source: &#13;
        path_iter = float_lat_lon(row_iter_kml(source)) &#13;
        pair_iter = legs(path_iter) &#13;
        trip_iter = ( &#13;
            LegPR( &#13;
                start=PointPR.create(start._asdict()), &#13;
                end=PointPR.create(end._asdict()), &#13;
                distance=round(haversine(start, end), 4)) &#13;
            #-------------------------------------------- &#13;
            for start, end in pair_iter &#13;
        ) &#13;
        trip = pvector(trip_iter) &#13;
               #------ &#13;
    return trip</code></pre>&#13;
<p>The first change is relatively large. Instead of rewriting the <span class="obeylines-h"><span class="verb"><code class="inlineCode">float_lat_lon()</code></span></span> function to return a <span class="obeylines-h"><span class="verb"><code class="inlineCode">PointPR</code></span></span> object, we left this function alone. We used the <span class="obeylines-h"><span class="verb"><code class="inlineCode">PRecord.create()</code></span></span> method to convert a dictionary into a <span class="obeylines-h"><span class="verb"><code class="inlineCode">PointPR</code></span></span> instance. Given the two <span class="obeylines-h"><span class="verb"><code class="inlineCode">PointPR</code></span></span> objects and the distance, we can create a <span class="obeylines-h"><span class="verb"><code class="inlineCode">LegPR</code></span></span> object.</p>&#13;
<p>Earlier in this chapter, we showed<span id="dx1-158093"/> a version of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">legs()</code></span></span> function that returned <span class="obeylines-h"><span class="verb"><code class="inlineCode">typing.NamedTuple</code></span></span> instances with the raw data for each point along a leg. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">_asdict()</code></span></span> method of a <span class="obeylines-h"><span class="verb"><code class="inlineCode">NamedTuple</code></span></span> will translate<span id="dx1-158094"/> the tuple into a dictionary. The tuple’s attribute names will be keys in the dictionary. The transformation can be seen in the following example:</p>&#13;
<div id="tcolobox-171" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; p = PointNT(2, 3) &#13;
&gt;&gt;&gt; p._asdict() &#13;
{’latitude’: 2, ’longitude’: 3}</code></pre>&#13;
&#13;
</div>&#13;
<p>This can then be provided to the <span class="obeylines-h"><span class="verb"><code class="inlineCode">PointPR.create()</code></span></span> method to create a proper <span class="obeylines-h"><span class="verb"><code class="inlineCode">PointPR</code></span></span> instance that will be used in the rest of the application. The initial <span class="obeylines-h"><span class="verb"><code class="inlineCode">PointNT</code></span></span> object can be discarded, having served as a bridge between input parsing and building more useful Python objects. In the long run, it’s a good idea to revisit the underlying <span class="obeylines-h"><span class="verb"><code class="inlineCode">legs()</code></span></span> function to rewrite it to work with <span class="obeylines-h"><span class="verb"><code class="inlineCode">pyrsistent</code></span></span> record definitions.</p>&#13;
<p>Finally, instead of assembling a <span class="obeylines-h"><span class="verb"><code class="inlineCode">list</code></span></span> from the iterator, we assembled a <span class="obeylines-h"><span class="verb"><code class="inlineCode">PVector</code></span></span> instance, using the <span class="obeylines-h"><span class="verb"><code class="inlineCode">pvector()</code></span></span> function. This has many of the same properties as the built-in list class, but is immutable. Any changes will create a clone of the object.</p>&#13;
<p>These high-performance, immutable collections are helpful ways to be sure an application behaves in a functional manner. The handy serialization into JSON-friendly notation makes these class definitions ideal for applications that make use of JSON. Web servers, in particular, can benefit from using these class definitions. <span id="x1-158099r165"/></p>&#13;
</section>&#13;
<section id="avoiding-stateful-classes-by-using-families-of-tuples" class="level3 sectionHead" data-number="0.11.6">&#13;
<h3 class="sectionHead" data-number="0.11.6"><span class="titlemark">7.6 </span> <span id="x1-1590006"/>Avoiding stateful classes by using families of tuples</h3>&#13;
<p>In several previous examples, we’ve shown the idea of <span class="keyWord">wrap-unwrap </span>design patterns<span id="dx1-159001"/> that allow us to work with anonymous and named tuples. The point of this kind of design is to use immutable objects that wrap other immutable objects instead of mutable instance variables.</p>&#13;
<p>A common statistical<span id="dx1-159002"/> measure of correlation between two sets of data is the <span class="keyWord">Spearman’s rank correlation</span>. This compares the rankings of two variables. Rather than trying to compare values, which might have different units of measure, we’ll compare the relative orders. For more information, visit: <a href="https://www.itl.nist.gov/div898/software/dataplot/refman2/auxillar/partraco.htm" class="url">https://www.itl.nist.gov/div898/software/dataplot/refman2/auxillar/partraco.htm</a>.</p>&#13;
<p>Computing the Spearman’s rank correlation<span id="dx1-159003"/> requires assigning a rank value to each observation. It seems like we should be able to use <span class="obeylines-h"><span class="verb"><code class="inlineCode">enumerate(sorted())</code></span></span> to do this. Given two sets of possibly correlated data, we can transform each set into a sequence of rank values and compute a measure of correlation.</p>&#13;
<p>We’ll apply the wrap-unwrap design pattern to do this. We’ll wrap data items with their rank for the purposes of computing the correlation coefficient.</p>&#13;
<p>In <a href="Chapter_03.xhtml#x1-510003"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 3</span></a>, <a href="Chapter_03.xhtml#x1-510003"><span class="cmti-10x-x-109">Functions, Iterators, and Generators</span></a>, we showed how to parse a simple dataset. We’ll extract the four samples from that dataset as follows:</p>&#13;
<div id="tcolobox-172" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; from Chapter03.ch03_ex4 import ( &#13;
... series, head_map_filter, row_iter) &#13;
&gt;&gt;&gt; from pathlib import Path &#13;
 &#13;
&gt;&gt;&gt; source_path = Path("Anscombe.txt") &#13;
&gt;&gt;&gt; with source_path.open() as source: &#13;
...     data = list(head_map_filter(row_iter(source)))</code></pre>&#13;
&#13;
</div>&#13;
<p>The resulting collection<span id="dx1-159012"/> of data has four different series of data combined in each row. A <span class="obeylines-h"><span class="verb"><code class="inlineCode">series()</code></span></span> function was defined in <a href="Chapter_03.xhtml#x1-610001"><span class="cmti-10x-x-109">Generators for lists, dicts, and sets</span></a>, back in <a href="Chapter_03.xhtml#x1-510003"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 3</span></a>, <a href="Chapter_03.xhtml#x1-510003"><span class="cmti-10x-x-109">Functions, Iterators, and Generators</span></a>, to extract the pairs for a given series from the overall row.</p>&#13;
<p>The definition looked like this:</p>&#13;
<pre id="listing-167" class="lstlisting"><code>def series( &#13;
      n: int, &#13;
      row_iter: Iterable[list[SrcT]] &#13;
) -&gt; Iterator[tuple[SrcT, SrcT]]:</code></pre>&#13;
<p>The argument to this function is an iterable of some source type (usually a string). The result of this function is an iterable series of two-tuples from the source type. When working with CSV files, strings are the expectation. It’s much nicer for the result to be a named tuple.</p>&#13;
<p>Here’s a named tuple for each pair:</p>&#13;
<pre id="listing-168" class="lstlisting"><code>from typing import NamedTuple &#13;
 &#13;
class Pair(NamedTuple): &#13;
    x: float &#13;
    y: float</code></pre>&#13;
<p>We’ll introduce a transformation to convert anonymous tuples into named tuples or dataclasses:</p>&#13;
<pre id="listing-169" class="lstlisting"><code>from collections.abc import Callable, Iterable &#13;
from typing import TypeAlias &#13;
 &#13;
RawPairIter: TypeAlias = Iterable[tuple[float, float]] &#13;
 &#13;
pairs: Callable[[RawPairIter], list[Pair]] \ &#13;
    = lambda source: list(Pair(*row) for row in source)</code></pre>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">RawPairIter</code></span></span> type definition describes the intermediate output from the <span class="obeylines-h"><span class="verb"><code class="inlineCode">series()</code></span></span> function. This function emits an iterable sequence of two-tuples. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">pairs</code></span></span> lambda object is a callable that expects<span id="dx1-159029"/> an iterable and will produce a list of <span class="obeylines-h"><span class="verb"><code class="inlineCode">Pair</code></span></span> named tuples or dataclass instances.</p>&#13;
<p>The following shows how the <span class="obeylines-h"><span class="verb"><code class="inlineCode">pairs()</code></span></span> function and the <span class="obeylines-h"><span class="verb"><code class="inlineCode">series()</code></span></span> function are used to create pairs from the original data:</p>&#13;
<div id="tcolobox-173" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; series_I = pairs(series(0, data)) &#13;
&gt;&gt;&gt; series_II = pairs(series(1, data)) &#13;
&gt;&gt;&gt; series_III = pairs(series(2, data)) &#13;
&gt;&gt;&gt; series_IV = pairs(series(3, data))</code></pre>&#13;
&#13;
</div>&#13;
<p>Each of these series is a list of <span class="obeylines-h"><span class="verb"><code class="inlineCode">Pair</code></span></span> objects. Each <span class="obeylines-h"><span class="verb"><code class="inlineCode">Pair</code></span></span> object has <span class="obeylines-h"><span class="verb"><code class="inlineCode">x</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">y</code></span></span> attributes. The data looks as follows:</p>&#13;
<div id="tcolobox-174" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; from pprint import pprint &#13;
 &#13;
&gt;&gt;&gt; pprint(series_I) &#13;
[Pair(x=10.0, y=8.04), &#13;
 Pair(x=8.0, y=6.95), &#13;
 ... &#13;
 Pair(x=5.0, y=5.68)]</code></pre>&#13;
&#13;
</div>&#13;
<p>We’ll break the rank ordering problem into two parts. First, we’ll look at a generic, higher-order function that we can use to assign ranks to any attribute. For example, it can rank a sample according to either the the <span class="obeylines-h"><span class="verb"><code class="inlineCode">x</code></span></span> or <span class="obeylines-h"><span class="verb"><code class="inlineCode">y</code></span></span> attribute value of a <span class="obeylines-h"><span class="verb"><code class="inlineCode">Pair</code></span></span> object. Then, we’ll define a wrapper around the <span class="obeylines-h"><span class="verb"><code class="inlineCode">Pair</code></span></span> object that includes the various rank order values.</p>&#13;
<p>So far, this seems like a place where we can wrap each pair, sort them into order, then use a function like <span class="obeylines-h"><span class="verb"><code class="inlineCode">enumerate()</code></span></span> to assign ranks. It turns out that this approach isn’t really the proper algorithm for rank ordering.</p>&#13;
<p>While the essence of rank ordering<span id="dx1-159043"/> is being able to sort the samples, there’s another important part of this. When two observations have the same value, they should get the same rank. The general rule is to average the positions of equal observations. The sequence <span class="obeylines-h"><span class="verb"><code class="inlineCode">[0.8,</code><code class="inlineCode"> 1.2,</code><code class="inlineCode"> 1.2,</code><code class="inlineCode"> 2.3,</code><code class="inlineCode"> 18]</code></span></span> should have rank values of 1, 2.5, 2.5, 4, 5. The two ties with ranks of 2 and 3 have the midpoint value of 2.5 as their common rank.</p>&#13;
<p>A consequence of this is that we don’t really need to sort all of the data. We can, instead, create a dictionary with a given attribute value and all of the samples that share the attribute value. All these items have a common rank. Given this dictionary, the keys need to be processed in ascending order. For some collections of data, there may be significantly fewer keys than original sample objects being ranked.</p>&#13;
<p>The rank ordering function works in two passes:</p>&#13;
<ol>&#13;
<li><div id="x1-159045x1">&#13;
<p>First, it builds a dictionary listing samples with duplicate values. We can call this the <span class="obeylines-h"><span class="verb"><code class="inlineCode">build_duplicates()</code></span></span> phase.</p>&#13;
</div></li>&#13;
<li><div id="x1-159047x2">&#13;
<p>Second, it emits a sequence of values, in ranked order, with a mean rank order for the items with the same value. We can call this the <span class="obeylines-h"><span class="verb"><code class="inlineCode">rank_output()</code></span></span> phase.</p>&#13;
</div></li>&#13;
</ol>&#13;
<p>The following function implements the two-phase ordering via two embedded functions:</p>&#13;
<pre id="listing-170" class="lstlisting"><code>from collections import defaultdict &#13;
from collections.abc import Callable, Iterator, Iterable, Hashable &#13;
from typing import NamedTuple, TypeVar, Any, Protocol, cast &#13;
 &#13;
BaseT = TypeVar("BaseT", int, str, float) &#13;
DataT = TypeVar("DataT") &#13;
 &#13;
def rank( &#13;
    data: Iterable[DataT], &#13;
    key: Callable[[DataT], BaseT] &#13;
) -&gt; Iterator[tuple[float, DataT]]: &#13;
 &#13;
    def build_duplicates( &#13;
            duplicates: dict[BaseT, list[DataT]], &#13;
            data_iter: Iterator[DataT], &#13;
            key: Callable[[DataT], BaseT] &#13;
    ) -&gt; dict[BaseT, list[DataT]]: &#13;
        for item in data_iter: &#13;
            duplicates[key(item)].append(item) &#13;
        return duplicates &#13;
 &#13;
    def rank_output( &#13;
            duplicates: dict[BaseT, list[DataT]], &#13;
            key_iter: Iterator[BaseT], &#13;
            base: int=0 &#13;
    ) -&gt; Iterator[tuple[float, DataT]]: &#13;
        for k in key_iter: &#13;
            dups = len(duplicates[k]) &#13;
            for value in duplicates[k]: &#13;
                yield (base+1+base+dups)/2, value &#13;
            base += dups &#13;
 &#13;
    duplicates = build_duplicates( &#13;
        defaultdict(list), iter(data), key &#13;
    ) &#13;
    return rank_output( &#13;
        duplicates, &#13;
        iter(sorted(duplicates.keys())), &#13;
        0 &#13;
    )</code></pre>&#13;
<p>As we can see, this rank ordering<span id="dx1-159088"/> function has two internal functions to transform a list of samples to a list of two-tuples, each pair having the assigned rank and the original sample object.</p>&#13;
<p>To keep the data structure type hints simple, the base type of the sample tuple is defined as <span class="obeylines-h"><span class="verb"><code class="inlineCode">BaseT</code></span></span>, which can be any of the string, integer, or float types. The essential ingredient here is a simple, hashable, and comparable object.</p>&#13;
<p>Similarly, the <span class="obeylines-h"><span class="verb"><code class="inlineCode">DataT</code></span></span> type is any type for the raw samples; the claim is that it will be used consistently throughout the function, and it’s two internal functions. This is an intentionally vague claim, because any kind of <span class="obeylines-h"><span class="verb"><code class="inlineCode">NamedTuple</code></span></span>, dataclass, or <span class="obeylines-h"><span class="verb"><code class="inlineCode">PRecord</code></span></span> will work.</p>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">build_duplicates()</code></span></span> function works<span id="dx1-159089"/> with a stateful object to build the dictionary that maps keys to values. This implementation<span id="dx1-159090"/> relies on the tail-call optimization of a recursive algorithm. The arguments to <span class="obeylines-h"><span class="verb"><code class="inlineCode">build_duplicates()</code></span></span> expose the internal state as argument values. A base case for a recursive definition is when <span class="obeylines-h"><span class="verb"><code class="inlineCode">data_iter</code></span></span> is empty.</p>&#13;
<p>Similarly, the <span class="obeylines-h"><span class="verb"><code class="inlineCode">rank_output()</code></span></span> function could be defined recursively to emit the original collection of values as two-tuples with the assigned rank values. What’s shown is an optimized version with two nested <span class="obeylines-h"><span class="verb"><code class="inlineCode">for</code></span></span> statements. To make the rank value computation explicit, it includes the low end of the range (<span class="obeylines-h"><span class="verb"><code class="inlineCode">base+1</code></span></span>), the high end of the range (<span class="obeylines-h"><span class="verb"><code class="inlineCode">base+dups</code></span></span>), and computes the midpoint of these two values. If there is only a single duplicate, the rank value is <span class="obeylines-h"><span class="verb"><code class="inlineCode">(2*base+2)/2</code></span></span>, which has the advantage of being a general solution, resulting in <span class="obeylines-h"><span class="verb"><code class="inlineCode">base+1</code></span></span>, in spite of extra computations.</p>&#13;
<p>The dictionary of duplicates has the type hint of <span class="obeylines-h"><span class="verb"><code class="inlineCode">dict[BaseT,</code><code class="inlineCode"> list[tuple[BaseT,</code><code class="inlineCode"> ...]]]</code></span></span>, because it maps a sample attribute value, <span class="obeylines-h"><span class="verb"><code class="inlineCode">BaseT</code></span></span>, to lists of the original data item type, <span class="obeylines-h"><span class="verb"><code class="inlineCode">tuple[BaseT,</code><code class="inlineCode"> ...]</code></span></span>.</p>&#13;
<p>The following is how we can test this to be sure it works. The first example ranks individual values. The second example ranks a list of pairs, using a lambda to pick the key value from each pair:</p>&#13;
<div id="tcolobox-175" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; from pprint import pprint &#13;
 &#13;
&gt;&gt;&gt; data_1 = [(0.8,), (1.2,), (1.2,), (2.3,), (18.,)] &#13;
&gt;&gt;&gt; ranked_1 = list(rank(data_1, lambda row: row[0])) &#13;
&gt;&gt;&gt; pprint(ranked_1) &#13;
[(1.0, (0.8,)), (2.5, (1.2,)), (2.5, (1.2,)), (4.0, (2.3,)), (5.0, (18.0,))] &#13;
 &#13;
&gt;&gt;&gt; from random import shuffle &#13;
&gt;&gt;&gt; shuffle(data_1) &#13;
&gt;&gt;&gt; ranked_1s = list(rank(data_1, lambda row: row[0])) &#13;
&gt;&gt;&gt; ranked_1s == ranked_1 &#13;
True &#13;
 &#13;
&gt;&gt;&gt; data_2 = [(2., 0.8), (3., 1.2), (5., 1.2), (7., 2.3), (11., 18.)] &#13;
&gt;&gt;&gt; ranked_2 = list(rank(data_2, key=lambda x: x[1],)) &#13;
&gt;&gt;&gt; pprint(ranked_2) &#13;
[(1.0, (2.0, 0.8)), &#13;
 (2.5, (3.0, 1.2)), &#13;
 (2.5, (5.0, 1.2)), &#13;
 (4.0, (7.0, 2.3)), &#13;
 (5.0, (11.0, 18.0))]</code></pre>&#13;
&#13;
</div>&#13;
<p>The sample data included<span id="dx1-159113"/> two identical values. The resulting ranks split positions 2 and 3 to assign position 2.5 to both values. This confirms that the function implements the common statistical practice for computing the Spearman’s rank-order correlation between two sets of values.</p>&#13;
<div id="tcolobox-176" class="packt_tip">&#13;
&#13;
&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">rank()</code></span></span> function involves rearranging the input data as part of discovering duplicated values. If we want to rank on both the <span class="cmti-10x-x-109">x </span>and <span class="cmti-10x-x-109">y </span>values in each pair, we need to reorder the data twice.</p>&#13;
&#13;
</div>&#13;
<p><span id="x1-159114r158"/></p>&#13;
<section id="computing-spearmans-rank-order-correlation" class="level4 subsectionHead" data-number="0.11.6.1">&#13;
<h4 class="subsectionHead" data-number="0.11.6.1"><span class="titlemark">7.6.1 </span> <span id="x1-1600001"/>Computing Spearman’s rank-order correlation</h4>&#13;
<p>The Spearman rank-order correlation<span id="dx1-160001"/> is a comparison between the rankings of two variables. It neatly bypasses the magnitude of the values, and it can often find a correlation even when the relationship is not linear. The formula is as follows:</p>&#13;
<div class="math-display" style="text-align:center">&#13;
<img src="../Images/file63.jpg" class="math-display" alt=" 6∑ (rx − ry)2 ρ = 1− -----2------- n(n − 1) "/>&#13;
</div>&#13;
<p>This formula shows us that we’ll be summing the differences in rank <span class="italic">r</span><sub><span class="cmmi-8">x</span></sub>, and <span class="italic">r</span><sub><span class="cmmi-8">y</span></sub>, for all of the pairs of observed values. This requires<span id="dx1-160002"/> computing ranks on both <span class="cmti-10x-x-109">x </span>and <span class="cmti-10x-x-109">y </span>variables. This means merging the two rank values into a single, composite object with ranking combined with the original raw sample.</p>&#13;
<p>The target class could look like the following:</p>&#13;
<pre id="listing-171" class="lstlisting"><code>class Ranked_XY(NamedTuple): &#13;
    r_x: float &#13;
    r_y: float &#13;
    raw: Pair</code></pre>&#13;
<p>This can be built by first ranking on one variable, then computing a second ranking of the raw data. For a simple dataset with a few variables, this isn’t terrible. For more than a few variables, this becomes needlessly complicated. The function definitions, in particular for ranking, would all be nearly identical, suggesting a need to factor out the common code.</p>&#13;
<p>It works out much better to depend on using the <span class="obeylines-h"><span class="verb"><code class="inlineCode">pyrsistent</code></span></span> module to create, and evolve, the values in a dictionary that accumulate ranking values. We can use a <span class="obeylines-h"><span class="verb"><code class="inlineCode">PRecord</code></span></span> pair that has a dictionary of rankings and the original data. The dictionary of rankings is an immutable <span class="obeylines-h"><span class="verb"><code class="inlineCode">PMap</code></span></span>. This means that any attempt to make a change will lead to evolving a new instance.</p>&#13;
<p>The instance, after being evolved, is immutable. We can clearly separate the accumulation of state from processing objects that do not have any further state changes.</p>&#13;
<p>Here’s our <span class="obeylines-h"><span class="verb"><code class="inlineCode">PRecord</code></span></span> subclass that contains the ranking mapping and the original, raw data:</p>&#13;
<pre id="listing-172" class="lstlisting"><code>from pyrsistent import PRecord, field, PMap, pmap &#13;
 &#13;
class Ranked_XY(PRecord):  # type: ignore [type-arg] &#13;
    rank = field(type=PMap) &#13;
    raw = field(type=Pair)</code></pre>&#13;
<p>Within each <span class="obeylines-h"><span class="verb"><code class="inlineCode">Ranked_XY</code></span></span>, the <span class="obeylines-h"><span class="verb"><code class="inlineCode">PMap</code></span></span> dictionary provides a mapping from the variable name to the ranking value. The raw data is the original sample. We want to be able to use <span class="obeylines-h"><span class="verb"><code class="inlineCode">sample.rank[attribute_name]</code></span></span> to extract the ranking for a specific attribute.</p>&#13;
<p>We can reuse our generic <span class="obeylines-h"><span class="verb"><code class="inlineCode">rank()</code></span></span> function to build the essential<span id="dx1-160012"/> information that contains a ranking and the raw data. We can then merge each new ranking into a <span class="obeylines-h"><span class="verb"><code class="inlineCode">Ranked_XY</code></span></span> instance. The following function definition will compute rankings for two attributes:</p>&#13;
<pre id="listing-173" class="lstlisting"><code>def rank_xy(pairs: Sequence[Pair]) -&gt; Iterator[Ranked_XY]: &#13;
    data = list(Ranked_XY(rank=pmap(), raw=p) for p in pairs) &#13;
 &#13;
    for attribute_name in (’x’, ’y’): &#13;
        ranked = rank( &#13;
            data, &#13;
            lambda rxy: cast(float, getattr(rxy.raw, attribute_name)) &#13;
        ) &#13;
        data = list( &#13;
            original.set( &#13;
                rank=original.rank.set(attribute_name, r)  # type: ignore [arg-type] &#13;
            ) &#13;
            for r, original in ranked &#13;
        ) &#13;
 &#13;
    yield from iter(data)</code></pre>&#13;
<p>We’ve built an initial list of <span class="obeylines-h"><span class="verb"><code class="inlineCode">Ranked_XY</code></span></span> objects with empty ranking dictionaries. For each attribute of interest, we’ll use the previously defined <span class="obeylines-h"><span class="verb"><code class="inlineCode">rank()</code></span></span> function to create a sequence of rank values and raw objects. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">for</code></span></span> clause of the generator decomposes the ranking two-tuple into <span class="obeylines-h"><span class="verb"><code class="inlineCode">r</code></span></span>, the ranking, and <span class="obeylines-h"><span class="verb"><code class="inlineCode">original</code></span></span>, the raw source data.</p>&#13;
<p>From each pair of values from the underlying <span class="obeylines-h"><span class="verb"><code class="inlineCode">rank()</code></span></span> function, we’ve made two changes to the <span class="obeylines-h"><span class="verb"><code class="inlineCode">pyrsistent</code></span></span> module’s data structures. We’ve used the following expression to create a new dictionary of the previous rankings merged with this new ranking:</p>&#13;
<pre id="listing-174" class="lstlisting"><code>original.rank.set(attribute_name, r)</code></pre>&#13;
<p>The result of this becomes part of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">original.set(rank=...)</code></span></span> expression to create a new <span class="obeylines-h"><span class="verb"><code class="inlineCode">Rank_XY</code></span></span> object using the newly evolved rank, <span class="obeylines-h"><span class="verb"><code class="inlineCode">PMap</code></span></span> instance.</p>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">.set()</code></span></span> method is an ”evolver”: it creates a new object by applying a new state to an existing object. These changes<span id="dx1-160030"/> by evolution are important because they result in new, immutable objects.</p>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">#</code><code class="inlineCode"> type:</code><code class="inlineCode"> ignore</code><code class="inlineCode"> [arg-type]</code></span></span> comment is required to silence a <span class="keyWord">mypy</span> warning. The type information used internally by the <span class="obeylines-h"><span class="verb"><code class="inlineCode">pyrsistent</code></span></span> module isn’t visible to <span class="keyWord">mypy</span>.</p>&#13;
<p>A Python version of a rank correlation function depends on the <span class="obeylines-h"><span class="verb"><code class="inlineCode">sum()</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">len()</code></span></span> functions, as follows:</p>&#13;
<pre id="listing-175" class="lstlisting"><code>from collections.abc import Sequence &#13;
 &#13;
def rank_corr(pairs: Sequence[Pair]) -&gt; float: &#13;
    ranked = rank_xy(pairs) &#13;
    sum_d_2 = sum( &#13;
        (r.rank[’x’] - r.rank[’y’]) ** 2  # type: ignore[operator, index] &#13;
        for r in ranked &#13;
    ) &#13;
    n = len(pairs) &#13;
    return 1 - 6 * sum_d_2/(n * (n ** 2 - 1))</code></pre>&#13;
<p>We’ve created <span class="obeylines-h"><span class="verb"><code class="inlineCode">Rank_XY</code></span></span> objects for each <span class="obeylines-h"><span class="verb"><code class="inlineCode">Pair</code></span></span> object. Given this, we can then subtract the <span class="obeylines-h"><span class="verb"><code class="inlineCode">r_x</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">r_y</code></span></span> values from those pairs to compare their difference. We can then square and sum the differences.</p>&#13;
<p>See <a href="#x1-1590006"><span class="cmti-10x-x-109">Avoiding stateful classes by using families of tuples</span></a> earlier in this chapter for the definition of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">Pair</code></span></span> class.</p>&#13;
<p>Again, we’ve had to suppress <span class="keyWord">mypy </span>warnings related to the lack of detailed internal type hints in the <span class="obeylines-h"><span class="verb"><code class="inlineCode">pyrsistent</code></span></span> module. Because this works properly, we feel confident in silencing the warnings.</p>&#13;
<p>A good article on statistics will provide detailed guidance on what the coefficient means. A value around 0 means that there is no correlation between the data ranks of the two series of data points. A scatter plot shows a random scattering of points. A value around +1 or -1 indicates a strong relationship<span id="dx1-160041"/> between the two values. A graph of the pairs would show a clear line or simple curve.</p>&#13;
<p>The following is an example based on Anscombe’s quartet series:</p>&#13;
<div id="tcolobox-177" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; data = [Pair(x=10.0, y=8.04), &#13;
... Pair(x=8.0, y=6.95), &#13;
... Pair(x=13.0, y=7.58), Pair(x=9.0, y=8.81), &#13;
... Pair(x=11.0, y=8.33), Pair(x=14.0, y=9.96), &#13;
... Pair(x=6.0, y=7.24), Pair(x=4.0, y=4.26), &#13;
... Pair(x=12.0, y=10.84), Pair(x=7.0, y=4.82), &#13;
... Pair(x=5.0, y=5.68)] &#13;
&gt;&gt;&gt; round(pearson_corr(data), 3) &#13;
0.816</code></pre>&#13;
&#13;
</div>&#13;
<p>For this particular dataset, the correlation is strong.</p>&#13;
<p>In <a href="Chapter_04.xhtml#x1-740004"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 4</span></a>, <a href="Chapter_04.xhtml#x1-740004"><span class="cmti-10x-x-109">Working with Collections</span></a>, we showed how to compute the Pearson correlation coefficient. The function we showed, <span class="obeylines-h"><span class="verb"><code class="inlineCode">corr()</code></span></span>, worked with two separate sequences of values. We can use it with our sequence of <span class="obeylines-h"><span class="verb"><code class="inlineCode">Pair</code></span></span> objects as follows:</p>&#13;
<pre id="listing-176" class="lstlisting"><code>from collections.abc import Sequence &#13;
from Chapter04.ch04_ex4 import corr &#13;
 &#13;
def pearson_corr(pairs: Sequence[Pair]) -&gt; float: &#13;
    X = tuple(p.x for p in pairs) &#13;
    Y = tuple(p.y for p in pairs) &#13;
    return corr(X, Y)</code></pre>&#13;
<p>We’ve unwrapped the <span class="obeylines-h"><span class="verb"><code class="inlineCode">Pair</code></span></span> objects to get the raw values that we can use with the existing <span class="obeylines-h"><span class="verb"><code class="inlineCode">corr()</code></span></span> function. This provides a different correlation coefficient. The Pearson value is based on how well the standardized values compare between two sequences. For many datasets, the difference between the Pearson and Spearman correlations is relatively small. For some datasets, however, the differences can be quite large.</p>&#13;
<p>To see the importance of having multiple statistical tools for exploratory data analysis, compare the Spearman and Pearson correlations for the four sets of data in Anscombe’s quartet. <span id="x1-160059r166"/></p>&#13;
</section>&#13;
</section>&#13;
<section id="polymorphism-and-type-pattern-matching" class="level3 sectionHead" data-number="0.11.7">&#13;
<h3 class="sectionHead" data-number="0.11.7"><span class="titlemark">7.7 </span> <span id="x1-1610007"/>Polymorphism and type pattern matching</h3>&#13;
<p>Some functional programming<span id="dx1-161001"/> languages offer some clever approaches to the problem of working with statically<span id="dx1-161002"/> typed function definitions. The problem is that many functions we’d like to write are entirely generic with respect to data type. For example, most of our statistical functions are identical for <span class="obeylines-h"><span class="verb"><code class="inlineCode">int</code></span></span> or <span class="obeylines-h"><span class="verb"><code class="inlineCode">float</code></span></span> numbers, as long as the division returns a value that is a subclass of <span class="obeylines-h"><span class="verb"><code class="inlineCode">numbers.Real</code></span></span>. The types <span class="obeylines-h"><span class="verb"><code class="inlineCode">Decimal</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">Fraction</code></span></span>, and <span class="obeylines-h"><span class="verb"><code class="inlineCode">float</code></span></span> should all work almost identically. In many functional languages, sophisticated type or type-pattern matching rules are used by the compiler to allow a single generic definition to work for multiple data types.</p>&#13;
<p>Instead of the (possibly) complex features of statically typed functional languages, Python changes the approach dramatically. Python uses dynamic selection of the final implementation of an operator based on the data types being used. In Python, we always write generic definitions. The code isn’t bound to any specific data type. The Python runtime will locate the appropriate operations based on the types of the actual objects in use. The <span class="cmti-10x-x-109">6.1. Arithmetic</span> <span class="cmti-10x-x-109">conversions </span>and <span class="cmti-10x-x-109">3.3.8. Emulating numeric types </span>sections of the language reference manual and the <span class="obeylines-h"><span class="verb"><code class="inlineCode">numbers</code></span></span> module in the standard library provide details on how this mapping from operation to special method name works.</p>&#13;
<p>In Python, there’s no compiler to certify that our functions are expecting and producing the proper data types. We generally rely on unit testing and the <span class="keyWord">mypy </span>tool<span id="dx1-161003"/> for this kind of type checking.</p>&#13;
<p>In rare cases, we might need to have different behavior based on the types of data elements. We have two ways to tackle this:</p>&#13;
<ul>&#13;
<li><p>We can use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">match</code></span></span> statement to distinguish the different cases. This replaces sequences of <span class="obeylines-h"><span class="verb"><code class="inlineCode">isinstance()</code></span></span> functions to compare argument values against types.</p></li>&#13;
<li><p>We can create class hierarchies that provide alternative implementations for methods.</p></li>&#13;
</ul>&#13;
<p>In some cases, we’ll actually need to do both so that we can include appropriate data type conversions for an operation. Each class is responsible for the coercion of argument values to a type it can use. The alternative<span id="dx1-161004"/> is to return the special <span class="obeylines-h"><span class="verb"><code class="inlineCode">NotImplemented</code></span></span> object, which forces the Python runtime to continue to search for a class that implements the operation and handles the required data types.</p>&#13;
<p>The ranking example<span id="dx1-161005"/> in the previous section is tightly bound to the idea of applying rank-ordering to simple pairs. It’s bound to the <span class="obeylines-h"><span class="verb"><code class="inlineCode">Pair</code></span></span> class definition. While this is the way the Spearman correlation is defined, a multivariate dataset has a need to do rank-order correlation among all the variables.</p>&#13;
<p>The first thing we’ll need to do is generalize our idea of rank-order information. The following is a <span class="obeylines-h"><span class="verb"><code class="inlineCode">NamedTuple</code></span></span> value that handles a tuple of ranks and a raw data object:</p>&#13;
<pre id="listing-177" class="lstlisting"><code>from typing import NamedTuple, Any &#13;
 &#13;
class RankData(NamedTuple): &#13;
    rank_seq: tuple[float, ...] &#13;
    raw: Any</code></pre>&#13;
<p>We can provide a sequence of rankings, each computed with respect to a different variable within the raw data. We might have a data point that has a rank of 2 for the <span class="obeylines-h"><span class="verb"><code class="inlineCode">’key1’</code></span></span> attribute value and a rank of 7 for the <span class="obeylines-h"><span class="verb"><code class="inlineCode">’key2’</code></span></span> attribute value. A typical use of this kind of class definition is shown in this example:</p>&#13;
<div id="tcolobox-178" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; raw_data = {’key1’: 1, ’key2’: 2} &#13;
&gt;&gt;&gt; r = RankData((2, 7), raw_data) &#13;
&gt;&gt;&gt; r.rank_seq[0] &#13;
2 &#13;
&gt;&gt;&gt; r.raw &#13;
{’key1’: 1, ’key2’: 2}</code></pre>&#13;
&#13;
</div>&#13;
<p>The row of raw data in this example is a dictionary with two keys for the two attribute names. There are two rankings for this particular item in the overall list. An application can get the sequence of rankings as well as the original raw data item.</p>&#13;
<p>We’ll add some syntactic<span id="dx1-161018"/> sugar to our ranking<span id="dx1-161019"/> function. In many previous examples, we’ve required either an iterable or a concrete collection. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">for</code></span></span> statement is graceful about working with either one. However, we don’t always use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">for</code></span></span> statement, and for some functions, we’ve had to explicitly use <span class="obeylines-h"><span class="verb"><code class="inlineCode">iter()</code></span></span> to make an iterator from an iterable collection. (We’ve also been forced sometimes to use <span class="obeylines-h"><span class="verb"><code class="inlineCode">list()</code></span></span> to materialize an iterable into a concrete collection object.)</p>&#13;
<p>Looking back at the <span class="obeylines-h"><span class="verb"><code class="inlineCode">legs()</code></span></span> function shown in <a href="Chapter_04.xhtml#x1-740004"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 4</span></a>, <a href="Chapter_04.xhtml#x1-740004"><span class="cmti-10x-x-109">Working with</span> <span class="cmti-10x-x-109">Collections</span></a>, we saw this definition:</p>&#13;
<pre id="listing-178" class="lstlisting"><code>from collections.abc import Iterator, Iterable &#13;
from typing import Any, TypeVar &#13;
 &#13;
LL_Type = TypeVar(’LL_Type’) &#13;
 &#13;
def legs( &#13;
        lat_lon_iter: Iterator[LL_Type] &#13;
) -&gt; Iterator[tuple[LL_Type, LL_Type]]: &#13;
    begin = next(lat_lon_iter) &#13;
    for end in lat_lon_iter: &#13;
        yield begin, end &#13;
        begin = end</code></pre>&#13;
<p>This only works for an <span class="obeylines-h"><span class="verb"><code class="inlineCode">Iterator</code></span></span> object. If we want to use a sequence, we’re forced to insert <span class="obeylines-h"><span class="verb"><code class="inlineCode">iter(some_sequence)</code></span></span> to create an iterator from the sequence. This is annoying and error-prone.</p>&#13;
<p>The traditional way to handle this situation is with an <span class="obeylines-h"><span class="verb"><code class="inlineCode">isinstance()</code></span></span> check, as shown in the following code snippet:</p>&#13;
<pre id="listing-179" class="lstlisting"><code>from collections.abc import Iterator, Iterable, Sequence &#13;
from typing import Any, TypeVar &#13;
 &#13;
# Defined earlier &#13;
# LL_Type = TypeVar(’LL_Type’) &#13;
 &#13;
def legs_g( &#13;
        lat_lon_src: Iterator[LL_Type] | Sequence[LL_Type] &#13;
) -&gt; Iterator[tuple[LL_Type, LL_Type]]: &#13;
    if isinstance(lat_lon_src, Sequence): &#13;
        return legs_g(iter(lat_lon_src)) &#13;
    elif isinstance(lat_lon_src, Iterator): &#13;
        begin = next(lat_lon_src) &#13;
        for end in lat_lon_src: &#13;
            yield begin, end &#13;
            begin = end &#13;
    else: &#13;
        raise TypeError("not an Iterator or Sequence")</code></pre>&#13;
<p>This example<span id="dx1-161050"/> includes a type check to handle the small difference between a <span class="obeylines-h"><span class="verb"><code class="inlineCode">Sequence</code></span></span> object and an <span class="obeylines-h"><span class="verb"><code class="inlineCode">Iterator</code></span></span>. Specifically, when the argument<span id="dx1-161051"/> value is a sequence, the <span class="obeylines-h"><span class="verb"><code class="inlineCode">legs()</code></span></span> function uses <span class="obeylines-h"><span class="verb"><code class="inlineCode">iter()</code></span></span> to create an <span class="obeylines-h"><span class="verb"><code class="inlineCode">Iterator</code></span></span> from the <span class="obeylines-h"><span class="verb"><code class="inlineCode">Sequence</code></span></span>, and calls itself recursively with the derived value.</p>&#13;
<p>This can be done in a slightly nicer and more general manner with type matching. The idea is to handle the variable argument types with a <span class="obeylines-h"><span class="verb"><code class="inlineCode">match</code></span></span> statement that applies any needed conversions to a uniform type that can be processed:</p>&#13;
<pre id="listing-180" class="lstlisting"><code>from collections.abc import Sequence, Iterator, Iterable &#13;
from typing import Any, TypeVar &#13;
 &#13;
# Defined earlier &#13;
# LL_Type = TypeVar(’LL_Type’) &#13;
 &#13;
def legs_m( &#13;
        lat_lon_src: Iterator[LL_Type] | Sequence[LL_Type] &#13;
) -&gt; Iterator[tuple[LL_Type, LL_Type]]: &#13;
 &#13;
    match lat_lon_src: &#13;
        case Sequence(): &#13;
            lat_lon_iter = iter(lat_lon_src) &#13;
        case Iterator() as lat_lon_iter: &#13;
            pass &#13;
        case _: &#13;
            raise TypeError("not an Iterator or Sequence") &#13;
 &#13;
    begin = next(lat_lon_iter) &#13;
    for end in lat_lon_iter: &#13;
        yield begin, end &#13;
        begin = end</code></pre>&#13;
<p>This example has shown<span id="dx1-161074"/> how we can match types to make it possible to work with either sequences or iterators. A great many other type matching<span id="dx1-161075"/> capabilities can be implemented in a similar fashion. It may be helpful, for example, to work with string or float values, coercing the string values to float.</p>&#13;
<p>It turns out that a type check isn’t the only solution to this specific problem. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">iter()</code></span></span> function can be applied to iterators as well as concrete collections. When the <span class="obeylines-h"><span class="verb"><code class="inlineCode">iter()</code></span></span> function is applied to an iterator, it does nothing and returns the iterator. When applied to a collection, it creates an iterator from the collection.</p>&#13;
<p>The objective of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">match</code></span></span> statement is to avoid the need to use the built-in <span class="obeylines-h"><span class="verb"><code class="inlineCode">isinstance()</code></span></span> function. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">match</code></span></span> statement provides more matching alternatives with an easier-to-read syntax. <span id="x1-161076r168"/></p>&#13;
</section>&#13;
<section id="summary-6" class="level3 sectionHead" data-number="0.11.8">&#13;
<h3 class="sectionHead" data-number="0.11.8"><span class="titlemark">7.8 </span> <span id="x1-1620008"/>Summary</h3>&#13;
<p>In this chapter, we looked at different ways to use <span class="obeylines-h"><span class="verb"><code class="inlineCode">NamedTuple</code></span></span> subclasses to implement more complex data structures. The essential features of a <span class="obeylines-h"><span class="verb"><code class="inlineCode">NamedTuple</code></span></span> are a good fit with functional design. They can be created with a creation function and accessed by position as well as name.</p>&#13;
<p>Similarly, we looked at frozen dataclasses as an alternative to <span class="obeylines-h"><span class="verb"><code class="inlineCode">NamedTuple</code></span></span> objects. The use of a dataclass seems slightly superior to a <span class="obeylines-h"><span class="verb"><code class="inlineCode">NamedTuple</code></span></span> subclass because a dataclass doesn’t also behave like a sequence of attribute values.</p>&#13;
<p>We looked at how immutable objects can be used instead of stateful object definitions. The core technique for replacing state changes is to wrap objects in larger objects that contain derived values.</p>&#13;
<p>We also looked at ways to handle multiple data types in Python. For most arithmetic operations, Python’s internal method dispatch locates proper implementations. To work with collections, however, we might want to handle iterators and sequences slightly differently using the <span class="obeylines-h"><span class="verb"><code class="inlineCode">match</code></span></span> statement.</p>&#13;
<p>In the next two chapters, we’ll look at the <span class="obeylines-h"><span class="verb"><code class="inlineCode">itertools</code></span></span> module. This standard library module provides a number of functions that help us work with iterators in sophisticated ways. Many of these tools are examples of higher-order functions. They can help a functional design stay succinct and expressive. <span id="x1-162001r169"/></p>&#13;
</section>&#13;
<section id="exercises-6" class="level3 sectionHead" data-number="0.11.9">&#13;
<h3 class="sectionHead" data-number="0.11.9"><span class="titlemark">7.9 </span> <span id="x1-1630009"/>Exercises</h3>&#13;
<p>This chapter’s exercises are based on code available from Packt Publishing on GitHub. See <a href="https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition" class="url">https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition</a>.</p>&#13;
<p>In some cases, the reader will notice that the code provided on GitHub includes partial solutions to some of the exercises. These serve as hints, allowing the reader to explore alternative solutions.</p>&#13;
<p>In many cases, exercises will need unit test cases to confirm they actually solve the problem. These are often identical to the unit test cases already provided in the GitHub repository. The reader should replace the book’s example function name with their own solution to confirm that it works. <span id="x1-163001r167"/></p>&#13;
<section id="frozen-dictionaries" class="level4 subsectionHead" data-number="0.11.9.1">&#13;
<h4 class="subsectionHead" data-number="0.11.9.1"><span class="titlemark">7.9.1 </span> <span id="x1-1640001"/>Frozen dictionaries</h4>&#13;
<p>A dictionary with optional key values can be a source of confusing state change management. Python’s implementation of objects generally relies on an internal dictionary, named <span class="obeylines-h"><span class="verb"><code class="inlineCode">__dict__</code></span></span>, to keep an object’s attribute values. This is easy to mirror in application code, and it can create problems.</p>&#13;
<p>While dictionary updates can be confusing, the previously described use case seems rare. A much more common use of dictionaries is to load a mapping from a source, and then use the mapping during later processing. One example is a dictionary that contains translations from source encodings to more useful numeric values. It might use a mapping value like this: <span class="obeylines-h"><span class="verb"><code class="inlineCode">{"y":</code><code class="inlineCode"> 1,</code><code class="inlineCode"> "Y":</code><code class="inlineCode"> 1,</code><code class="inlineCode"> "n":</code><code class="inlineCode"> 0,</code><code class="inlineCode"> "N":</code><code class="inlineCode"> 0}</code></span></span>. In this case, the dictionary is created once, and does not change state after that. It’s effectively frozen.</p>&#13;
<p>Python doesn’t have a built-in frozen dictionary class. One approach to defining this class is to extend the built-in <span class="obeylines-h"><span class="verb"><code class="inlineCode">dict</code></span></span> class, adding a mode change. There would be two modes: “load” and “query.” A dictionary in “load” mode can have keys and values created. A dictionary in “query” mode, however, does not permit changes. This includes refusing to go back to “load” mode. This is an extra layer of stateful behavior that permits or denies the underlying mapping behavior.</p>&#13;
<p>The dictionary class has a long list of special methods like <span class="obeylines-h"><span class="verb"><code class="inlineCode">__setitem__()</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">update()</code></span></span> that change the internal state. The Python Language Reference, section 3.3.7 <span class="cmti-10x-x-109">Emulating Container Types</span>, provides a detailed list of methods that change the state of a mapping. Additionally, the Library Reference, in a section named <span class="cmti-10x-x-109">Mapping Types – dict</span>, provides a list of methods for the built-in <span class="obeylines-h"><span class="verb"><code class="inlineCode">dict</code></span></span> class. Finally, the <span class="obeylines-h"><span class="verb"><code class="inlineCode">collections.abc</code></span></span> module also defines some of the methods that mappings must implement.</p>&#13;
<p>Work out the list of methods that must be implemented with code like the following example:</p>&#13;
<pre id="listing-181" class="lstlisting"><code>    def some_method(self, *args: Any, **kwargs: Any) -&gt; None: &#13;
        if self.frozen: &#13;
            raise RuntimeError("mapping is frozen") &#13;
        else: &#13;
            super.some_method(*args, **kwargs)</code></pre>&#13;
<p>Given the list of methods that need this kind of wrapper, comment on the value of having a frozen mapping. Contrast the work required to implement this class with the possible confusion from a stateful dictionary. Provide a cost-benefit justification for either writing this class or setting the idea aside and looking for a better solution. Recall that dictionary key look-ups are very fast, relying on a hash computation instead of a lengthy search. <span id="x1-164006r171"/></p>&#13;
</section>&#13;
<section id="dictionary-like-sequences" class="level4 subsectionHead" data-number="0.11.9.2">&#13;
<h4 class="subsectionHead" data-number="0.11.9.2"><span class="titlemark">7.9.2 </span> <span id="x1-1650002"/>Dictionary-like sequences</h4>&#13;
<p>Python doesn’t have a built-in frozen dictionary class. One approach to defining this class is to leverage the <span class="obeylines-h"><span class="verb"><code class="inlineCode">bisect</code></span></span> module to build a list. The list is maintained in sorted order, and the <span class="obeylines-h"><span class="verb"><code class="inlineCode">bisect</code></span></span> module can do relatively rapid searches of a sorted list.</p>&#13;
<p>For an unsorted list, the complexity of finding a specific item in a sequence of <span class="italic">n </span>items is <span class="keyWord">O</span>(<span class="italic">n</span>). For a sorted list, the <span class="obeylines-h"><span class="verb"><code class="inlineCode">bisect</code></span></span> module can reduce this to <span class="keyWord">O</span>(log <sub><span class="cmr-8">2</span></sub><span class="italic">n</span>), a significant reduction in time for a large list. (And, of course, a dictionary’s hashed lookup is generally <span class="keyWord">O</span>(1), which is better still.)</p>&#13;
<p>The dictionary class has a long list of special methods like <span class="obeylines-h"><span class="verb"><code class="inlineCode">__setitem__()</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">update()</code></span></span> that change the internal state. The previous exercise provides some pointers for locating all of the special methods that are relevant to building a dictionary.</p>&#13;
<p>A function to build a sorted list can wrap <span class="obeylines-h"><span class="verb"><code class="inlineCode">bisect.insort_left()</code></span></span>. A function to query the sorted list can leverage <span class="obeylines-h"><span class="verb"><code class="inlineCode">bisect.bisect_left()</code></span></span> to locate and then return the value associated with a key that’s in the list, or raise a <span class="obeylines-h"><span class="verb"><code class="inlineCode">KeyError</code></span></span> exception for an item that’s not in the list.</p>&#13;
<p>Build a small demo application that creates a dictionary from a source file, then does several thousand randomized retrievals from that dictionary. Compare the time required to run the demo using the built-in <span class="obeylines-h"><span class="verb"><code class="inlineCode">dict</code></span></span> against the <span class="obeylines-h"><span class="verb"><code class="inlineCode">bisect</code></span></span>-based dictionary-like list.</p>&#13;
<p>Using the built-in <span class="obeylines-h"><span class="verb"><code class="inlineCode">sys.getallocatedblocks()</code></span></span>, compare the memory used by a list of values and the memory used by a dictionary of values. For this to be meaningful, the dictionary will need several thousand keys and values. A pool of random numbers and randomly generated strings can be useful for this comparison. <span id="x1-165001r172"/></p>&#13;
</section>&#13;
<section id="revise-the-rank_xy-function-to-use-native-types" class="level4 subsectionHead" data-number="0.11.9.3">&#13;
<h4 class="subsectionHead" data-number="0.11.9.3"><span class="titlemark">7.9.3 </span> <span id="x1-1660003"/>Revise the rank_xy() function to use native types</h4>&#13;
<p>In the <a href="#x1-1600001"><span class="cmti-10x-x-109">Computing Spearman’s rank-order correlation</span></a> section, we presented a <span class="obeylines-h"><span class="verb"><code class="inlineCode">rank_xy()</code></span></span> function that created a <span class="obeylines-h"><span class="verb"><code class="inlineCode">pyrsistent.PMap</code></span></span> object with various ranking positions. This was contained within a <span class="obeylines-h"><span class="verb"><code class="inlineCode">PRecord</code></span></span> subclass.</p>&#13;
<p>First, rewrite the function (and the type hints) to use either a named tuple or a dataclass instead of a <span class="obeylines-h"><span class="verb"><code class="inlineCode">PRecord</code></span></span> subclass. This replaces one immutable object with another.</p>&#13;
<p>Next, consider replacing the <span class="obeylines-h"><span class="verb"><code class="inlineCode">PMap</code></span></span> object with a native Python dictionary. Since dictionaries are mutable, what additional processing is needed to create a copy of a dictionary before adding a new ranking value?</p>&#13;
<p>After revising the <span class="obeylines-h"><span class="verb"><code class="inlineCode">PMap</code></span></span> object to a dictionary, compare the performance of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">pyrsistent</code></span></span> objects with native objects. What conclusions can you draw? <span id="x1-166001r173"/></p>&#13;
</section>&#13;
<section id="revise-the-rank_corr-function" class="level4 subsectionHead" data-number="0.11.9.4">&#13;
<h4 class="subsectionHead" data-number="0.11.9.4"><span class="titlemark">7.9.4 </span> <span id="x1-1670004"/>Revise the rank_corr() function</h4>&#13;
<p>In the <a href="#x1-1610007"><span class="cmti-10x-x-109">Polymorphism and type pattern matching</span></a> section, we presented a way to create <span class="obeylines-h"><span class="verb"><code class="inlineCode">RankedSample</code></span></span> objects that contain rankings and underlying <span class="obeylines-h"><span class="verb"><code class="inlineCode">Rank_Data</code></span></span> objects with the raw sample value.</p>&#13;
<p>Rewrite the <span class="obeylines-h"><span class="verb"><code class="inlineCode">rank_corr()</code></span></span> function to compute the rank correlations of any of the available values in the <span class="obeylines-h"><span class="verb"><code class="inlineCode">rank_seq</code></span></span> attribute of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">RankedSample</code></span></span> objects. <span id="x1-167001r174"/></p>&#13;
</section>&#13;
<section id="revise-the-legs-function-to-use-pyrsistent" class="level4 subsectionHead" data-number="0.11.9.5">&#13;
<h4 class="subsectionHead" data-number="0.11.9.5"><span class="titlemark">7.9.5 </span> <span id="x1-1680005"/>Revise the legs() function to use pyrsistent</h4>&#13;
<p>In the <a href="#x1-1580005"><span class="cmti-10x-x-109">Using pyrsistent to collect data</span></a> section, a number of functions were reused from earlier examples. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">legs()</code></span></span> function was called out specifically. The entire parsing pipeline, however, can be rewritten to use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">pyrsistent</code></span></span> variations on the fundamental, immutable object classes.</p>&#13;
<p>After doing the revision, explain any improvements in the code from using one module consistently for the data collections. Create an application that loads and computes distances for a trip several thousand times. Use each of the various representations and accumulate timing data to see which, if any, is faster.</p>&#13;
</section>&#13;
</section>&#13;
<section id="join-our-community-discord-space-7" class="level3 likesectionHead" data-number="0.11.10">&#13;
<h3 class="likesectionHead" data-number="0.11.10"><span id="x1-1690005"/>Join our community Discord space</h3>&#13;
<p>Join our Python Discord workspace to discuss and know more about the book: <a href="https://packt.link/dHrHU">https://packt.link/dHrHU</a></p>&#13;
<p><img src="../Images/file1.png" alt="PIC" width="85" height="85"/> <span id="x1-169001r160"/></p>&#13;
</section>&#13;
</section>&#13;
</body></html>