<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Robot Control and Simulation</h1>
                </header>
            
            <article>
                
<p>In this chapter, you will set up your ROS development environment specifically for programming GoPiGo3.<span> This understanding is going to be built by going from using the keys of your laptop keyboard to the more technical way of using ROS topics. </span>Finally, you will guess what topics will allow you to wire manual keyboard/topic-based control to internal programming logic (that is, smart behavior) that will make the robot capable of executing autonomous tasks. In this sense, 3D simulation in Gazebo is an essential tool for testing behavior during development before pushing the app to the physical robot, saving time and effort when it comes to field-based work.</p>
<p>By the end of this chapter, you will have l<span>earned how to set up the ROS environment for a real robot. Remote</span><span> control and autonomous control establish a qualitative difference in terms of robot software development. By experimenting with remote control by yourself, you will be ready to cross the frontier of what makes a robot really autonomous.</span></p>
<p><span>Finally, you will u</span><span>nderstand the usefulness of using simulation during the development of robotic applications by establishing a comparison with how the physical robot behaves. These observed differences will allow you to adjust the parameters of the virtual robot's simulation in Gazebo. The main advantage of this approach is that you can keep on developing and testing the software with the virtual model and then only test with the real hardware in the final development stage.</span></p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li class="mce-root">Setting up the GoPiGo3 development environment and making it capable of networking with <span>ROS on a</span> laptop</li>
<li class="mce-root">Case study 3 <span>–</span> remotely controlling the physical robot using the keyboard </li>
<li class="mce-root">Remotely controlling robots using ROS topics from the command line</li>
<li class="mce-root">Comparing the behavior of <span>both of the physical robot and the virtual model in Gazebo under manual remote control</span></li>
</ul>
<p>We will provide explanations of these concepts based on our third case study regarding robot drives (motors and encoders). Remember that the first two case studies were covered in <a href="0b20bdff-f1dc-42e8-ae83-fc290da31381.xhtml" target="_blank">Chapter 6</a>, <em>Programming in ROS <span>–</span> Commands and Tools</em>, and were as follows:</p>
<ul>
<li><strong>Case study 1</strong>: Publishing and reading the distance sensor</li>
<li><strong>Case study 2</strong>: Acquiring and visualizing images from the Pi camera</li>
</ul>
<p>By the end of this chapter, we will have our first complete version of the ROS package of GoPiGo3. This will be the basis that our smart robot behaviors will be built upon in the rest of this book.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>For this chapter, no additional hardware or software configuration will be needed. Just make sure that you have the following:</p>
<ul>
<li>GoPiGo3, as per the <em>Technical requirements</em> section of <a href="0b20bdff-f1dc-42e8-ae83-fc290da31381.xhtml" target="_blank">Chapter 6</a>, <em>Programming in ROS <span>–</span> Commands and Tools</em></li>
<li>A laptop, as per the <em>Configure your ROS Development Environment</em> section of <a href="f3ecc0de-28c4-4140-9a9c-ed351c68d121.xhtml" target="_blank">Chapter 3</a>, <em>Getting Started with ROS</em></li>
</ul>
<p>In the next section, we will prepare the ROS environment so that your laptop and the robot can communicate with each other under a unique ROS graph. Let's go over the code we'll need:</p>
<ul>
<li><strong>Code for this chapter (laptop)</strong>: In this chapter, we will make use of the code located in the <kbd>Chapter7_Robot_control_simulation</kbd> folder (<a href="https://github.com/PacktPublishing/Hands-On-ROS-for-Robotics-Programming/tree/master/Chapter7_Robot_control_simulation">https://github.com/PacktPublishing/Hands-On-ROS-for-Robotics-Programming/tree/master/Chapter7_Robot_control_simulation</a>). Copy its files to the ROS workspace so that they're available to you and leave the rest outside the <kbd>src</kbd> folder. This way, you will have a cleaner ROS environment:</li>
</ul>
<pre style="padding-left: 60px"><strong>$ cp -R ~/Hands-On-ROS-for-Robotics-Programming/Chapter7_Robot_control_simulation ~/catkin_ws/src</strong></pre>
<p style="padding-left: 60px">The code contains a new ROS package named <kbd>gazebo_control</kbd>. Rebuild the workspace so that it is known to your ROS installation:</p>
<pre style="padding-left: 60px"><strong>$ cd ~/catkin_ws</strong><br/><strong>$ catkin_make</strong><br/><strong>$ source ~/catkin_ws/devel/setup.bash</strong></pre>
<p style="padding-left: 60px">Check that the package has been correctly installed by selecting it and listing the files:</p>
<pre style="padding-left: 60px"><strong>$ roscd gazebo_control</strong><br/><strong>$ ls -la</strong></pre>
<ul>
<li><strong>Code for this chapter (GoPiGo3)</strong>: You will be using the same code that we developed in <a href="0b20bdff-f1dc-42e8-ae83-fc290da31381.xhtml" target="_blank">Chapter 6</a>, <em>Programming in ROS <span>–</span> Commands and Tools</em>. Remember that it corresponds to the ROS package called <kbd>mygopigo</kbd> that's located in the <span>Raspberry Pi.</span></li>
</ul>
<p>Now, you are ready to follow the explanations in this chapter and understand them in a practical way.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up the GoPiGo3 development environment</h1>
                </header>
            
            <article>
                
<p>In the previous chapter, you tried the ROS desktop version in the Raspberry Pi of GoPiGo3. For a serious development strategy, you should launch the minimum configuration of the application in the robot and launch all the accompanying development tasks within the laptop.</p>
<p>Remember that in <a href="f3ecc0de-28c4-4140-9a9c-ed351c68d121.xhtml" target="_blank">Chapter 3</a>, <em>Getting Started with ROS</em>, you run ROS on your laptop. Hence, the robot application itself was executed in such an environment, with no possibility to move a physical robot since we didn't establish a connection outside of the computer.</p>
<p>In this section, you will learn how to work simultaneously with the laptop and Raspberry Pi ROS environments when they're linked, that is, the Raspberry Pi controlling the GoPiGo3 robot and the laptop for CPU-intensive computing/visualization tasks.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">ROS networking between the robot and the remote computer</h1>
                </header>
            
            <article>
                
<p>To make two ROS environments, there are two prior conditions we need to meet:</p>
<ul>
<li>The robot and computer ROS environments need to know how to communicate with each other.</li>
<li>The master node (<kbd>roscore</kbd> process) should be unique and run in either.</li>
</ul>
<p>Let's learn how to accomplish both conditions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Communication between ROS environments</h1>
                </header>
            
            <article>
                
<p>The way that a computer is identified in a network is by means of its IP address, normally using the IPv4 protocol. In general, you can find the IP that's been assigned to your machine with the <kbd>ifconfig</kbd> command:</p>
<pre><strong>$ ifconfig</strong><br/><br/><strong>eth0: ...</strong><br/><strong>lo:   ...</strong><br/><strong>wlan0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500</strong><br/><strong>        inet addr: 192.168.1.58 netmask 255.255.255.0 broadcast 192.168.1.255</strong><br/><strong>        inet6 addr: fe80::7d9d:84a9:ec7:20cd prefixlen 64 scopeid 0x20&lt;link&gt;</strong><br/><br/><strong>        RX packets 212 bytes 46561 (46.5 KB)</strong><br/><strong>        RX errors 0 dropped 0 overruns 0 frame 0</strong><br/><strong>        TX packets 202 bytes 43986 (43.9 KB)</strong><br/><strong>        TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0</strong></pre>
<p>You should focus on the wireless interface, typically named <kbd>wlan0</kbd>, since you configured your robot for Wi-Fi access. The IP address is the 4 x 4 bytes field following the word <kbd>inet</kbd>. So, for the Raspberry Pi in GoPiGo3, this field is <kbd>192.168.1.58</kbd>.</p>
<p>Do the same for the laptop, opening in it a Terminal. If you are using a wired connection, you should look at <kbd>eth0</kbd> instead of <kbd>wlan0</kbd>. For our example case, the computer's IP is <kbd>192.168.1.54</kbd>. If there were too many network interfaces, the output could be too verbose. To focus on what you are looking for, you can filter the output, like this:</p>
<pre><strong>$ ifconfig | grep 'inet'</strong></pre>
<p>Once you have both IP addresses, you just have to indicate them using ROS environment variables. In the following subsections, we will show you how to configure each of the computers.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Robot network configuration</h1>
                </header>
            
            <article>
                
<p>Next, you have to follow three steps to set up the Raspberry Pi:</p>
<ol>
<li>Execute the following two commands in a Terminal to define the environment variables needed by ROS:</li>
</ol>
<pre style="padding-left: 60px"><strong><span>$ export ROS_HOSTNAME=192.168.1.58</span></strong><br/><strong><span>$ export ROS_MASTER_URI=http://${ROS_HOSTNAME}:11311</span></strong></pre>
<p style="padding-left: 60px">The first command sets the variable that allows ROS to know the IP of the <span>host </span>where it is currently running. The second line is the URL of the master node. Since <span>it is set to </span><kbd><span>ROS_HOSTNAME</span></kbd>, we are saying that it will run on the robot computer<span>. Port <kbd>11311</kbd> is the default that's set by ROS to communicate with the master node. Each subsequently launched node will be automatically assigned a new available port.</span></p>
<ol start="2">
<li>There is a way to abstract the IP number itself because, in Ubuntu systems, <kbd>avahi-daemon</kbd> (<a href="http://manpages.ubuntu.com/manpages/bionic/man8/avahi-daemon.8.html">http://manpages.ubuntu.com/manpages/bionic/man8/avahi-daemon.8.html</a>) allows you to point to a machine in the local network by simply appending <kbd>.local</kbd> to its hostname. For this, the configuration command will be as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ export ROS_HOSTNAME=gopigo3.local</strong></pre>
<p style="padding-left: 60px">The hostname can be found in the prompt of the Terminal and is usually in the format <kbd>user@hostname :~$</kbd>. If you have any doubts, you can ask for it in the Terminal by using <kbd>hostname</kbd> command:</p>
<pre style="padding-left: 60px"><strong>pi@gopigo3 :~$ hostname</strong><br/><strong>     gopigo3</strong></pre>
<ol start="3">
<li>Each new Terminal you launch will need this configuration. So, if we include it as additional lines in the <kbd>.bashrc</kbd> file, you won't have to care about doing this by hand:</li>
</ol>
<pre style="padding-left: 60px"><strong><span>$ echo export ROS_HOSTNAME=gopigo3.local &gt;&gt; ~/.bashrc</span></strong><br/><strong><span>$ echo export ROS_MASTER_URI=http://</span><span>${ROS_HOSTNAME}</span><span>:11311 &gt;&gt; ~/.bashrc</span></strong></pre>
<p style="padding-left: 60px">Check the result by listing the end of the file:</p>
<pre style="padding-left: 60px"><strong>$ tail <span>~/.bashrc</span></strong></pre>
<p>You should see the cited two configuration lines.</p>
<p>Now that the Raspberry Pi has been configured, we will do something similar for the laptop.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Laptop network configuration</h1>
                </header>
            
            <article>
                
<p>For the remote computer, these are the equivalent steps:</p>
<ol>
<li>Execute the following two commands in a Terminal to set the environment variables:</li>
</ol>
<pre style="padding-left: 60px"><strong><span>$ export ROS_HOSTNAME=192.168.1.54</span></strong><br/><strong><span>$ export ROS_MASTER_URI=http://gopigo3.local:11311</span></strong></pre>
<p style="padding-left: 60px">You specify its IP address as <span><kbd>192.168.1.54</kbd> in the first line, while in the second, we are stating that the ROS master is located in the robot, that is, </span><kbd><span>gopigo3.local</span></kbd><span>. This way, your system won't need to be reconfigured if the network is restarted and a different IP address is assigned to the Raspberry Pi.</span></p>
<ol start="2">
<li>As for the robot, add the following two lines to the <kbd>.bashrc</kbd> file to automate the configuration each time a new Terminal is launched:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ echo export ROS_HOSTNAME=rosbot.local &gt;&gt; ~/.bashrc</strong><br/><strong>$ echo export ROS_MASTER_URI=http://gopigo3.local:11311 &gt;&gt; ~/.bashrc</strong></pre>
<p>We are also showing the alternative for setting <kbd>ROS_HOSTNAME</kbd>, that is, using <span><kbd>rosbot.local</kbd> instead of the numeric IP address.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Launching the master node and connecting</h1>
                </header>
            
            <article>
                
<p>The following procedure allows us to establish a connection between the laptop and the Raspberry Pi:</p>
<ol>
<li>Launch the ROS master node in the robot by using the already familiar <kbd>roscore</kbd> command:</li>
</ol>
<pre style="padding-left: 60px"><strong>pi@gopigo3 :~$ roscore</strong></pre>
<ol start="2">
<li>Then, perform a basic check in the laptop<span> to find out if it is aware of the master node's existence:</span></li>
</ol>
<pre style="padding-left: 60px"><strong>bronquillo@rosbot:~$ rostopic list</strong><br/><strong> /rosout</strong><br/><strong> /rosout_agg</strong></pre>
<p><kbd>/rosout_agg</kbd> and <kbd>/rosout_agg</kbd> are the topics that are published by the master node.</p>
<p>If everything has gone well, you can <span>remotely </span>control your GoPiGo3. Close the Terminal before moving on to the next section to make sure <kbd>roscore</kbd> is off.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Case study 3 – remote control using the keyboard</h1>
                </header>
            
            <article>
                
<p>This case study will help you complete the first version of the GoPiGo3 ROS package. In the previous chapter, you were dealing with the distance sensor and the Pi camera, and we devoted one case study to each of them.</p>
<p>By including the motion functionality with the present robot drives, you will have a robot that is able to perform basic interactions with its environment:</p>
<ul>
<li><strong>Perception capabilities</strong> include detecting obstacles with the distance sensor and visual recognition of the surroundings with the Pi camera.</li>
<li><strong>Actuation capability</strong>, where the robot is able to move on the floor while being aware of the possible obstacles with the distance sensor and recognizing shapes and people with the image feed from its camera.</li>
</ul>
<p>Case study 3 focuses on actuation capability. In this section, you will learn how to remotely move the robot using a keyboard and a mouse.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running the gopigo3 node in the robot</h1>
                </header>
            
            <article>
                
<p>In this section, we are going to run a node in the Raspberry Pi that will provide the control capability:</p>
<ol>
<li> Launch the GoPiGo3 ROS package in the robot:</li>
</ol>
<pre style="padding-left: 60px"><strong><span>$ roslaunch mygopigo gopigo3.launch</span></strong></pre>
<p style="padding-left: 60px">This is the only command you need to run directly in the Raspberry Pi. Since you configured ROS so that the laptop can talk to the robot, the following commands can be run on the laptop.</p>
<div class="packt_infobox">When preceding a bash command with <kbd>T1</kbd>, <kbd>T2</kbd>, <kbd>T3</kbd>, or <kbd>T4</kbd>, we will <span>always</span> be referring to consecutive Terminals on the laptop.</div>
<p style="padding-left: 60px">2. Then, on your laptop, ensure that you have a single node, that is, <kbd>gopigo3</kbd>:</p>
<pre style="padding-left: 60px"><strong>T1 $ rosnode list</strong><br/><strong> /gopigo3</strong><br/><strong> /rosout</strong></pre>
<p style="padding-left: 60px">Remember that the <kbd>/rosout</kbd> topic corresponds to the master node.</p>
<p style="padding-left: 60px">3. Next, list all the available ROS topics to find out what their names are:</p>
<pre style="padding-left: 60px"><strong>T1 $ rostopic list</strong><br/><strong>/battery_voltage</strong><br/><strong>/cmd_vel</strong><br/><strong>...</strong><br/><strong>/motor/encoder/left</strong><br/><strong>/motor/encoder/right</strong><br/><strong>...</strong><br/><strong>/motor/status</strong><br/><strong>/odom</strong><br/><strong>/rosout</strong><br/><strong>/rosout_agg</strong><br/><strong>/servo/position/1</strong><br/><strong>/servo/position/2</strong><br/><strong>...</strong><br/><strong>/tf</strong></pre>
<p style="padding-left: 60px">Bear in mind that the three topics of interest are called <kbd>/battery_voltage</kbd>, <kbd>/cmd_vel</kbd>, and <kbd>/motor/status</kbd>. We will provide details about them later in this section.</p>
<p style="padding-left: 60px">4. To get additional information about these topics, you can use the <kbd>info</kbd> option of the <kbd>rosnode</kbd> command. This will tell you what the <kbd>gopigo3</kbd> node can do: </p>
<pre style="padding-left: 60px"><strong>T1 $ rosnode info gopigo3</strong><br/><strong>Node [/gopigo3]</strong><br/><strong>Publications: </strong><br/><strong> * /battery_voltage [std_msgs/Float64]</strong><br/><strong> * /joint_state [sensor_msgs/JointState]</strong><br/><strong> * /motor/encoder/left [std_msgs/Float64]</strong><br/><strong> * /motor/encoder/right [std_msgs/Float64]</strong><br/><strong> * /motor/status [gopigo3_node/MotorStatusLR]</strong><br/><strong>...</strong><br/><strong>Subscriptions: </strong><br/><strong> * /cmd_vel</strong><br/><strong> ...</strong><br/><strong> * /motor/dps/left</strong><br/><strong> * /motor/dps/right</strong><br/><strong> ...</strong></pre>
<p style="padding-left: 60px">Here, you can see that <kbd>/battery_voltage</kbd><span> and <strong><kbd>/motor/status</kbd> </strong>are</span> publishers (ob<span>jects in the code of the node that stream data to such topics), while </span><kbd>/cmd_vel</kbd><span> </span><span>is</span> a subscriber (<span>as well as an object that's declared in the node that allows us to consume data from an existing topic):</span></p>
<ul>
<li style="list-style-type: none">
<ul>
<li><span>Th</span>e publishers allow yo<span>u to get status information from the batte</span><span>ry level and the motors, respectively.</span></li>
<li><span>T</span>he <kbd>/cmd_vel</kbd> subscriber allows <span>the robot to accept motion commands for remote control.</span></li>
</ul>
</li>
</ul>
<p><span>In the next subsection, we will inspect the</span> publishers in order to un<span>derstand the structure of the messages they stream.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Inspecting published topics and messages</h1>
                </header>
            
            <article>
                
<p>Now that we've identified the three topics, let's take a look at them and get some robot-specific information:</p>
<ol>
<li>To find the last five values of the battery, run the following command in a Terminal. This will allow you to inspect the <span><kbd>/battery_voltage</kbd> </span>topic:</li>
</ol>
<pre style="padding-left: 60px"><strong>T1 $ rostopic echo battery_voltage -n 5</strong><br/><br/><strong>data: 9.568</strong><br/><strong>---</strong><br/><strong>data: 9.551</strong><br/><strong>---</strong><br/><strong>data: 9.594</strong><br/><strong>---</strong><br/><strong>data: 9.568</strong><br/><strong>---</strong><br/><strong>data: 9.586</strong></pre>
<p style="padding-left: 60px">You can infer that the voltage is about 9.6V on average, which means the batteries are charged.</p>
<ol start="2">
<li>Let's investigate how this topic is built:</li>
</ol>
<pre style="padding-left: 60px"><strong>T1 $ rostopic info battery_voltage</strong><br/><strong>      Type: std_msgs/Float64</strong></pre>
<p style="padding-left: 60px">It uses the <kbd>std_msgs/Float64</kbd> message type, which corresponds to a floating-point number that's 64 bits size. This message type is part of the ROS standard message library (<a href="http://wiki.ros.org/std_msgs">http://wiki.ros.org/std_msgs</a>). To find out what a ROS message is made up of, you can use the <kbd>rosmsg</kbd> command:</p>
<pre style="padding-left: 60px"><strong>T1 $ rosmsg info std_msgs/Float64</strong><br/><strong>       float64 data</strong></pre>
<ol start="3">
<li>There is another topic in this node, <kbd>/motor/status</kbd>, that makes use of a custom and more complex message:</li>
</ol>
<pre style="padding-left: 60px"><strong>T1 $ rostopic info motor/status</strong><br/><strong>      Type: mygopigo/MotorStatusLR</strong></pre>
<ol start="4">
<li>Let's find the structure of the message. Note that the definition of the message is declared within the <kbd>mygopigo</kbd> package under the <kbd>msg</kbd> folder:</li>
</ol>
<pre style="padding-left: 60px"><strong>T1 $ rosmsg info mygopigo/MotorStatusLR</strong><br/><br/><strong>  std_msgs/Header header</strong><br/><strong>  uint32 seq</strong><br/><strong>  time stamp</strong><br/><strong>  string frame_id</strong><br/><br/><strong>mygopigo/MotorStatus left</strong><br/><strong>  bool low_voltage</strong><br/><strong>  bool overloaded</strong><br/><strong>  int8 power</strong><br/><strong>  float32 encoder</strong><br/><strong>  float32 speed</strong><br/><br/><strong>mygopigo/MotorStatus right</strong><br/><strong>  bool low_voltage</strong><br/><strong>  bool overloaded</strong><br/><strong>  int8 power</strong><br/><strong>  float32 encoder</strong><br/><strong>  float32 speed</strong></pre>
<p style="padding-left: 60px">There are three parts to this:</p>
<ul>
<li style="list-style-type: none">
<ul>
<li>A header with the sequence number and the timestamp</li>
<li>Data from the left motor</li>
<li>Data from the right motor</li>
</ul>
</li>
</ul>
<p style="padding-left: 60px">If we take the content of the last published message, we can visualize this structure in practice:</p>
<pre style="padding-left: 60px"><strong>T1 $ rostopic echo motor/status -n 1</strong><br/><strong>header: </strong><br/><strong>  seq: 177</strong><br/><strong>  stamp: </strong><br/><strong>    secs: 1566220531</strong><br/><strong>    nsecs: 946445941</strong><br/><strong>  frame_id: ''</strong><br/><strong>left: </strong><br/><strong>  low_voltage: False</strong><br/><strong>  overloaded: False</strong><br/><strong>  power: -128</strong><br/><strong>  encoder: 0.0</strong><br/><strong>  speed: 0.0</strong><br/><strong>right: </strong><br/><strong>  low_voltage: False</strong><br/><strong>  overloaded: False</strong><br/><strong>  power: -128</strong><br/><strong>  encoder: 0.0</strong><br/><strong>  speed: 0.0</strong></pre>
<p style="padding-left: 60px">Here, you can see that the topic reports the <kbd>low_voltage</kbd> level warning, the motor <kbd>overload</kbd> warning, <kbd>power</kbd>, <kbd>encoder</kbd> data, and the current <kbd>speed</kbd>.</p>
<p>Now, let's proceed to the practical part of moving the robot.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Teleoperation package</h1>
                </header>
            
            <article>
                
<p><kbd>key_teleop</kbd> (<a href="http://wiki.ros.org/key_teleop">http://wiki.ros.org/key_teleop</a>) is a ROS-contributed package that provides a very simple mechanism for controlling a robot using the arrow keys of the keyboard. Clone the source code and install the package on your laptop as usual:</p>
<pre class="mce-root"><strong><span>$ cd ~/catkin_ws/src</span></strong><br/><strong><span>$ git clone https://github.com/ros-teleop/teleop_tools</span></strong><br/><strong><span>$ cd .. &amp;&amp; catkin_make</span></strong></pre>
<p class="mce-root">Another two packages are available here that are also part of the <kbd>teleop_tools</kbd> bundle:</p>
<ul>
<li class="mce-root"><kbd>joy_teleop</kbd>, a generic joystick interface for topics and actions</li>
<li class="mce-root"><kbd>mouse_teleop</kbd>, a pointing device (for example, mouse, touchpad, and so on) teleoperation utility</li>
</ul>
<p class="mce-root">Since you have built the whole repository, both of these are available to you.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running teleoperation on a laptop</h1>
                </header>
            
            <article>
                
<p>Since you've completed the <em>Running gopigo3 node in the robot</em> subsection, you should have the <kbd>gopigo3</kbd> node running as a result of the <kbd>$ roslaunch mygopigo gopigo3.launch</kbd><span> command. Let's learn how to achieve remote control of it:</span></p>
<ol>
<li>Launch the teleoperation node on your laptop:</li>
</ol>
<pre style="padding-left: 60px"><strong>T1 $ rosrun key_teleop key_teleop.py /key_vel:=/cmd_vel</strong></pre>
<p style="padding-left: 60px">The preceding command launches the <kbd>key_teleop</kbd> node, and the Terminal's prompt is substituted by an interface that looks similar to the one shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e17ef85c-6ac9-4447-9bfd-65b622b02626.png" style="width:21.25em;height:12.17em;"/></p>
<p style="padding-left: 60px">This gray window tells you how to move the robot using the arrow keys of the keyboard:</p>
<ul>
<li style="list-style-type: none">
<ul>
<li>The up arrow key moves the robot forward at 0.8 m/s. You can see the commanded speed in the interface.</li>
<li>The down arrow key moves the robot backward at -0.5 m/s (the minus sign means backward).</li>
<li>The left arrow key rotates the robot counter-clockwise (left) at 1 rad/s.</li>
<li>The right arrow key rotates the robot clockwise at -1 rad/s  (the min<span>us sign means rotation t</span>o the right).</li>
</ul>
</li>
</ul>
<div class="packt_infobox">So that you can effectively move it, be aware that the Terminal that you launched the <kbd>key_teleop</kbd> node from has to be the active <span>window</span>. If that's not the case, just click anywhere on it to make it the active one.</div>
<ol start="2">
<li>With the <kbd>T2</kbd> command, we can visualize the ROS graph as usual:</li>
</ol>
<pre style="padding-left: 60px"><strong>T2 $ rqt_graph</strong></pre>
<p style="padding-left: 60px">It should look as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1400 image-border" src="assets/1cfb3f28-184f-4f78-86fc-edb683002ae1.png" style="width:22.92em;height:3.42em;"/></p>
<p style="padding-left: 60px">The<kbd>  T1</kbd> command that was appended after the executable script of the node with the <kbd>/key_vel:=/cmd_vel</kbd><em> </em>assignment is what we call remapping. This technique allows two nodes to communicate, where the literal of the subscriber of the listener node, <kbd>/cmd_vel</kbd><span>, </span>does not match the literal of the publisher node, <kbd>/key_vel</kbd>. Hence, remapping consists of wiring the published topic of one node to the subscribed topic of another node. <span>This way, we know that the output from the <kbd>key_teleop</kbd></span><span> node is going to be the input of the <kbd>gopigo3</kbd> node.</span></p>
<p>Now, let's learn how to teleoperate the robot with the mouse instead of the keyboard.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Teleoperation with the mouse</h1>
                </header>
            
            <article>
                
<p>This procedure is equivalent to that of the keyboard:</p>
<ol>
<li>Write the following command in a third Terminal to apply the <kbd>mouse_teleop</kbd> package from the <kbd>teleop_tools</kbd> bundle:</li>
</ol>
<pre style="padding-left: 60px"><strong>T3 $ rosrun mouse_teleop mouse_teleop.py /mouse_vel:=/cmd_vel</strong></pre>
<p style="padding-left: 60px">In this case, the remapping topic is <kbd>/mouse_vel:=/cmd_vel</kbd>. </p>
<ol start="2">
<li>Refresh the <kbd>rqt_graph</kbd> window; you will see the following:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1401 image-border" src="assets/28ea3127-edeb-430e-b1b9-bdcff048da1f.png" style="width:24.67em;height:7.83em;"/></p>
<p style="padding-left: 60px">The preceding graph suggests that the robot simultaneously accepts commands from the mouse and the keyboard without any trouble. <span>This happens if we don't kill the keyboard control in the </span><kbd>T1</kbd> Term<span>inal before launching the mouse control command.</span></p>
<p style="padding-left: 60px"><span>On the other hand, if you kill the </span><kbd>T1</kbd> terminal, the robot will keep on working, but then you will only control it with the mouse since the process in <kbd>T3</kbd> ke<span>eps it live (the <kbd>key_teleop</kbd> node will disappear from <kbd>rqt_graph</kbd> if we refresh the window).</span></p>
<ol start="3">
<li>Finally, check if the mouse control works (restart the <kbd>T1</kbd> command if you killed it previously):</li>
</ol>
<ul>
<li style="list-style-type: none">
<ul>
<li>Select the window of <kbd>T1</kbd>. You will move GoPiGo3 with the arrow keys.</li>
<li>Select the new window that appeared by implementing the <kbd>T3</kbd> command. Now, you can move GoPiGo3 with the mouse (while the left button is being held down).</li>
</ul>
</li>
</ul>
<p>The following is the new window that appears for controlling the mouse:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1402 image-border" src="assets/1271a71c-ab5a-4efc-b57d-5315162bd5ac.png" style="width:22.92em;height:19.92em;"/></p>
<p>The blue line represents the forward (positive speed)-backward directions. In this case, it moves at -0.3 m/s (backward). The longer the line, the greater the speed. The red circular sector represents the same but for the rotation. It is positive when rotating left (counter-clockwise), at 15.08 degrees/second in this case.</p>
<p>This example illustrates two important concepts of ROS:</p>
<ul>
<li><strong>The concurrency of messages</strong>: If there two or more nodes that publish to a topic that is mapped to the subscriber of another node, this node will accept the messages from both and will try to execute all of them. This is a nice feature that you will exploit when working with ROS at an advanced level.</li>
<li><strong>The resilience of the runtime enviroment</strong>: The robot can work with partial functionality. It will only lose the functionality provided by the ROS nodes that die.</li>
</ul>
<p>At this point, it is important that you think of how ROS provides a high-level layer for programming robots compared to the usage of procedural languages such as C or Python. Furthermore, this also means that you will focus more on the robot's functionality and less on programming the code: you will integrate existing packages that provide the low-level layer (control commands from a keyboard or mouse, for example) and relate them via ROS topics to build the high-level layer (motion control of the robot with the keyboard and/or mouse).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Remote control using ROS topics</h1>
                </header>
            
            <article>
                
<p>In the previous section, you controlled the robot's publishing messages in the <kbd>/cmd_vel</kbd> topic using a human interface, the keyboard and the mouse. In this section, you will publish the messages directly using <kbd>rostopic</kbd> from the command line. This way, you will become familiar with this relevant topic and the structure of its messages. <span>It is crucial to understand ho</span>w <kbd>/cmd_vel</kbd> work<span>s under the hood since you will be using it in many of the advanced examples we'll be covering in the remaining chapters of this book.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The motion control topic – /cmd_vel</h1>
                </header>
            
            <article>
                
<p>Now that we've enjoyed playing with the robot, let's understand how this form of control works. The <kbd>/cmd_vel</kbd> topic that the gopigo3 node is subscribed to is the key to producing translations and rotations of the robot. Run the <kbd>rostopic</kbd> command while having the <kbd>gopigo3</kbd> node running in the robot to retrieve the information from the topic:</p>
<pre><strong>T1 $ rostopic info /cmd_vel</strong><br/><br/><strong>      Type: geometry_msgs/Twist</strong><br/><br/><strong>      Publishers: None</strong><br/><strong>      Subscribers: </strong><br/><strong>       * /gopigo3 (http://gopigo3.local:40605/)</strong></pre>
<p>The topic <kbd>/cmd_vel</kbd> uses the <kbd>geometry_msgs/Twist</kbd> type (64 bits) of the <kbd>geometry_msgs</kbd> message library (<a href="http://wiki.ros.org/geometry_msgs">http://wiki.ros.org/geometry_msgs</a>). This library provides messages for working with geometric primitives: points, vectors, and poses. The command is also telling you which nodes are subscribed to the topic, which is only <kbd>gopigo3</kbd> in our case. Now, let's retrieve the struc<span>ture of the message type:</span></p>
<pre><strong>T1 $ rosmsg info geometry_msgs/Twist </strong><br/><strong>      geometry_msgs/Vector3 linear</strong><br/><strong>        float64 x</strong><br/><strong>        float64 y</strong><br/><strong>        float64 z</strong><br/><strong>      geometry_msgs/Vector3 angular</strong><br/><strong>        float64 x</strong><br/><strong>        float64 y</strong><br/><strong>        float64 z</strong></pre>
<p>Here, we can see that it is composed of six 64-bit float numbers that will allow you to treat it as two vectors of three components each. The first three components form the linear vector and refer to the speed along the <span><em>X</em>, <em>Y</em>, and <em>Z</em> </span>axes, while the remaining three form the rotation vector, expressing the angular speed about each of those axes. Let's see how this works in practice.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using /cmd_vel to directly drive GoPiGo3</h1>
                </header>
            
            <article>
                
<p>Previously, we focused on the end user's perspective of controlling<span> the robot, that is, keyboard strokes or mouse clicks and displacement. Now, we are going to discover how to achieve the same kind of control from the developer's perspective, which is the one you need to build new applications in ROS. Let's get started:</span></p>
<ol>
<li>Rotate the robot at a 1 rad/s rate by publishing a message from the command line. Remember that the <kbd>gopigo3</kbd> node <span>must be running in the robot:</span></li>
</ol>
<pre style="padding-left: 60px"><strong>T1 $ rostopic pub /cmd_vel geometry_msgs/Twist  'angular: {z: 1}'</strong><br/><strong>      publishing and latching message. Press ctrl-C to terminate</strong></pre>
<ol start="2">
<li>As soon as you enter the command, apart from seeing GoPiGo3 rotating left (counter-clockwise), you will receive the accompanying information message about the command.</li>
<li>Since you did not specify a publishing frequency, ROS assumes that you want to keep that message latched, that is, <span>running forever. Check this by using</span> <kbd>rostopic</kbd> <span>in another Terminal:</span></li>
</ol>
<pre style="padding-left: 60px"><strong>T2 $ rostopic echo /cmd_vel</strong><br/><strong>      linear: </strong><br/><strong>        x: 0.0</strong><br/><strong>        y: 0.0</strong><br/><strong>        z: 0.0</strong><br/><strong>      angular: </strong><br/><strong>        x: 0.0</strong><br/><strong>        y: 0.0</strong><br/><strong>        z: 1.0</strong><br/><strong>      ---</strong></pre>
<ol start="4">
<li>How can we stop the robot? Easy <span>–</span> send a new message with the rotation set to zero:</li>
</ol>
<pre style="padding-left: 60px"><strong>T3 $ rostopic pub /cmd_vel geometry_msgs/Twist  'angular: {z: 0}'</strong></pre>
<p style="padding-left: 60px">You will see that GoPiGo3 stops and that <kbd>T2</kbd> throws a new set of six values, informing us that angular <kbd>z</kbd> is now equal to <kbd>0</kbd>.</p>
<ol start="5">
<li>The next step is to introduce a message update at a given rate. Stop the process in <kbd>T1</kbd> and write the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>T1 $ rostopic pub -r 0.5 /cmd_vel geometry_msgs/Twist  'angular: {z: 1}'</strong></pre>
<p style="padding-left: 60px">In <kbd>T2</kbd>, you should see a new message every 2 seconds (= 0.5 Hz frequency). The <kbd>-r</kbd> option (initial of rate) is the one you use to specify how often you want the message to be sent. Since you are keeping the same rotation speed, you won't appreciate any changes in the robot motion.</p>
<ol start="6">
<li>Go to another Terminal and publish a double speed (2 rad/s) in the <kbd>/cmd_vel</kbd> topic at the same frequency of 0.5 Hz:</li>
</ol>
<pre style="padding-left: 60px"><strong>T3 $ rostopic pub -r 0.5 /cmd_vel geometry_msgs/Twist  'angular: {z: 2}'</strong></pre>
<p style="padding-left: 60px">You will see GoPiGo3 alternating between angular speeds of 1 and 2 rad/s at the specified rate.</p>
<ol start="7">
<li>Go to <kbd>T4</kbd> and send a stop rotation command:</li>
</ol>
<pre style="padding-left: 60px"><strong>T4 $ rostopic pub -r 0.5 /cmd_vel geometry_msgs/Twist 'angular: {z: 0}'</strong></pre>
<p style="padding-left: 60px">Observe how the robot stops for a while every 2 seconds.</p>
<ol start="8">
<li>What if you want the robot to stop more often? Stop the process in <kbd>T4</kbd> and relaunch the command with a higher rate of 1 Hz:</li>
</ol>
<pre style="padding-left: 60px"><strong>T4 $ rostopic pub -r 1 /cmd_vel geometry_msgs/Twist  'angular: {z: 0}'</strong></pre>
<ol start="9">
<li>How do we make it stop for longer? Easy <span>–</span> specify a higher frequency, that is, 10 Hz. When using such a value, you will find that GoPiGo3 rotates very little, since 10 times every second, it receives a stop command, superseding the most recent effect of the speeds set in <kbd>T1</kbd> (1 rad/s) and <kbd>T3</kbd> (2 rad/s).</li>
</ol>
<ol start="10">
<li>Finally, how do we stop everything? Follow these steps:
<ol>
<li>Stop Terminal <kbd>T1</kbd>. This avoids new messages from being sent by setting the speed at 1 rad/s.</li>
<li>Stop Terminal <kbd>T3</kbd>. This cancels the speed commands of 2 rad/s. At this point, the robot only receives zero speed commands from the last Terminal. The robot has stopped, but ROS is still running some processes, although they're not visible as robot motions.</li>
<li>Stop Terminal <kbd>T4</kbd>. This makes sure that the gopigo3 node is now idle from any message that's published in the <kbd>/cmd_vel</kbd> topic.</li>
<li>You should check how <kbd>T2</kbd> (using the<kbd>$ rostopic echo /cmd_vel</kbd> command) stops providing updates. You can also kill this Terminal.</li>
</ol>
</li>
</ol>
<p>Try to think about what would happen if the first action you had made were to stop <kbd>T4</kbd>. Check this by applying the sequence to the physical robot and see what result you get.</p>
<p><span>In the next section, you will publis</span>h <kbd>geometry_msgs/Twist</kbd> mes<span>sages</span> in the<strong> </strong><kbd>/cmd_vel</kbd><span> topic to find about what the actual <em>X</em>, <em>Y</em>, and <em>Z</em> axes of your robot are.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Checking the X, Y, and Z axes of GoPiGo3</h1>
                </header>
            
            <article>
                
<p>Now, you will apply what you have learned to practically find the <em>X</em>, <em>Y</em>, and <em>Z</em> axes of your robot and their positive and negative direction. Apply the following command in <kbd>T1</kbd> and make sure you're ready with <kbd>T2</kbd> to stop it afterward to avoid the robot crashing into any obstacles:</p>
<pre><strong>T1 $ rostopic pub /cmd_vel geometry_msgs/Twist 'linear: {x: 0.1}'</strong><br/><strong>T2 $ rostopic pub /cmd_vel geometry_msgs/Twist  'linear: {x: 0}'</strong></pre>
<p>You should see GoPiGo3 advancing forward, that is, the distance sensor facing forward while the caster wheel is facing back. For the negative <em>X</em> axis, change the sign of the linear speed:</p>
<pre><strong>T1 $ rostopic pub /cmd_vel geometry_msgs/Twist 'linear: {x: -0.1}'</strong><br/><strong>T2 $ rostopic pub /cmd_vel geometry_msgs/Twist  'linear: {x: 0}'</strong></pre>
<p><span>You should find that GoPiGo is now advancing backward, that is, the distance sensor is facing backward. </span>To guess the direction of the remaining axis, <em>Y</em>, remember that, in the previous subsection, you checked that the rotation around the <em>Z</em> axis is positive when the robot rotates left (counter-clockwise). This means that the <em>Z</em> axis points up, to the ceiling. Since you have empirically found the orientation of the <em>X</em> and <em>Z</em> axes, you can easily infer that the Y axis points left.</p>
<p>Why haven't we checked the <em>Z</em> axis with <strong>rostopic pub</strong>? You have a robot moving on a plane, that is, the floor. If you tried to apply a linear speed command for the <em>Z</em> axis, you will see nothing, because... well, GoPiGo3 cannot fly!</p>
<p>It is left to you to deduce why a similar linear speed command for the <em>Y</em> axis will have no visible effect on GoPiGo3's motion.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Composing motions</h1>
                </header>
            
            <article>
                
<p>We have already learned how to find the actual X, Y, and Z axes of the robot. Go back to <a href="742e6846-70e4-4bd4-8576-f3e4f445df3f.xhtml" target="_blank">Chapter 4</a>, <em>Creating the Virtual Two-Wheeled ROS Robot</em>, the <em>Building a differential drive robot with URDF</em> <span>section, </span>if you need to remember how.</p>
<p>Keeping their orientations in mind, let's design a more complex trajectory by combining both translation (<span>linear <em>X</em>) </span>and rotation (<span>angular <em>Z</em></span>). The goal is to get GoPiGo3 to follow a circumferential path that has a 0.25 m radius at a speed of 45º/s:</p>
<ul>
<li>The angular <em>Z</em> speed is 45º/s = 0.785 rad/s. We just need to change units from sexagesimal degrees to radians.</li>
<li>The linear <em>X</em> speed can be obtained by multiplying the requested radius by the angular speed; that is, <em>0.25 m * 0.785 rad/s = 0.196 m</em>.</li>
</ul>
<p>Follows these steps to do so:</p>
<ol start="1">
<li>Apply these two values in a single <kbd>/cmd_vel</kbd> message:</li>
</ol>
<pre style="padding-left: 60px"><strong>T1 $ rostopic pub /cmd_vel geometry_msgs/Twist '{linear: {x: 0.196}, angular: {z: 0.785}}</strong>'</pre>
<ol start="2">
<li>To stop this process, you can send a message where all six components are equal to zero:</li>
</ol>
<pre style="padding-left: 60px"><strong>T2 $ rostopic pub -r 10 /cmd_vel geometry_msgs/Twist  '[0, 0, 0]' '[0, 0, 0]'</strong></pre>
<p style="padding-left: 60px">This is an alternative <kbd>geometry_msgs/Twist</kbd> message syntax, in which you specify a three-component vector for linear speed (following the order <em>X</em>, <em>Y</em>, <em>Z</em>) and another vector with the three components of the angular speed (also in the order <em>X</em>, <em>Y</em>, <em>Z</em>).</p>
<ol start="3">
<li>Finally, check how the superposition principle applies to motion composition b<span>y sending separate commands for the translation and rotation:</span></li>
</ol>
<pre style="padding-left: 60px"><strong>T1 $ rostopic pub /cmd_vel geometry_msgs/Twist 'linear: {x: 0.196}'</strong><br/><strong>T2 $ rostopic pub /cmd_vel geometry_msgs/Twist 'angular: {z: 0.785}'</strong></pre>
<p style="padding-left: 60px">The command in <kbd>T1</kbd> makes GoPiGo3 move forward at 0.196 m/s. Then, the command in <kbd>T2</kbd> adds an angular motion of 0.785 rad/s, thereby producing the trajectory for GoPiGo3 to evolve from a straight line to a circumference of 0.25 m radius, as expected.</p>
<p>Stop the robot and shut down the Raspberry Pi. In the next section, we'll switch to the Gazebo simulation environment, so we will only need the laptop. We will return to the virtual model of GoPiGo3 at the point we left it in <a href="74284adc-e0d7-4e40-a54b-e2e447b8e2fe.xhtml" target="_blank">Chapter 5</a>, <em>Simulating the Robot Behavior with Gazebo</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Remotely controlling both physical and virtual robots</h1>
                </header>
            
            <article>
                
<p>Up to this point, you have dealt with a piece of configuration where the ROS master node ran in the robot. For the rest of this chapter, you will only be working with the laptop. Due to this, you need to revert your configuration so that the master node can be located again on the desktop computer. Otherwise, you will receive an error and won't be able to launch any ROS environment.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reverting the ROS master to the local computer</h1>
                </header>
            
            <article>
                
<p>The solution to this is pretty simple; just follow these steps:</p>
<ol>
<li>Open your local <kbd>.bashrc</kbd> file and comment the line at the end that specifies what URL to point to in order to find the ROS master:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ nano ~./bashrc</strong><br/><strong>   ...</strong><br/><strong>   export ROS_HOSTNAME=rosbot.local</strong><br/><strong>  # THIS LINE IS NOW A COMMENT # export ROS_MASTER_URI=http://gopigo3.local:11311</strong></pre>
<div class="packt_tip">Be aware that, in place of <kbd>rosbot.local</kbd>, you should have your current hostname, <kbd>&lt;your-hostname&gt;.local</kbd>. Simply run <kbd>$ hostname</kbd> in a Terminal to recall it if you are in doubt and it hasn't been set correctly in your configuration file.</div>
<ol start="2">
<li>Close all the Terminals, open a new one, and check the <kbd>ROS_MASTER_URI</kbd> variable:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ echo $ROS_MASTER_URI</strong><br/><strong>    http://localhost:11311</strong></pre>
<p>You should find that the environment variable has reverted to the default server (localhost) and default port (<kbd>11311</kbd>). Now, we are ready to switch to the virtual robot.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Simulating GoPiGo3 with Gazebo</h1>
                </header>
            
            <article>
                
<p>Recall the Gazebo simulation we performed in <a href="74284adc-e0d7-4e40-a54b-e2e447b8e2fe.xhtml" target="_blank">Chapter 5</a>, <em>Simulating the Robot Behavior with Gazebo</em>, in the <em>Launching the GoPiGo model in Gazebo</em> section. Its files have been included in the sample code for this chapter so that we can use them as a starting point. Now, follow these steps:</p>
<ol>
<li>Launch the Gazebo environment with the GoPiGo3 model:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px"><strong>T1 $ roslaunch gazebo_control spawn.launch</strong></pre>
<p style="padding-left: 60px">Although you may find that the launch filename is different from what it was in the code of <a href="74284adc-e0d7-4e40-a54b-e2e447b8e2fe.xhtml" target="_blank">Chapter 5</a>, <em>Simulating the Robot Behavior with Gazebo</em>, its content is exactly the same, that is, <kbd>gopigo_gazebo.launch</kbd>.</p>
<ol start="2">
<li>Then, in another Terminal, list the relevant topics:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px"><strong>T2 $ rostopic list</strong><br/><strong>   /clock</strong><br/><strong>   /gazebo/link_states</strong><br/><strong>   /gazebo/model_states</strong><br/><strong>   /gazebo/parameter_descriptions</strong><br/><strong>   /gazebo/parameter_updates</strong><br/><strong>   /gazebo/set_link_state</strong><br/><strong>   /gazebo/set_model_state</strong><br/><strong>   /gazebo_gui/parameter_descriptions</strong><br/><strong>   /gazebo_gui/parameter_updates</strong><br/><strong>   /rosout</strong><br/><strong>   /rosout_agg</strong></pre>
<p style="padding-left: 60px">All the new ones correspond to Gazebo nodes.</p>
<ol start="3">
<li>In particular, the <kbd>/clock</kbd> <span>topic is where Gazebo publishes timestamps, thus allowing for a system with simulation-synchronized time. The parameter definition within the <kbd>spawn.launch</kbd> file for <kbd>/clock</kbd> is as follows:</span></li>
</ol>
<div>
<pre style="padding-left: 60px">&lt;launch&gt;<br/>      ...<br/><span>      &lt;</span><span>arg</span><span> </span><span>name</span><span>=</span><span>"use_sim_time"</span><span> </span><span>default</span><span>=</span><span>"true"</span><span>/&gt;<br/></span>      ...<br/>&lt;/launch&gt;</pre></div>
<ol start="4">
<li>The <kbd>use_sim_time</kbd><span> parameter asks ROS to simulate a clock whose timestamps are published on <kbd>/clock</kbd>. You can inspect the topic and its message type as usual:</span></li>
</ol>
<pre class="mce-root" style="padding-left: 60px"><strong>T2 $ rostopic info /clock</strong><br/><strong> Type: rosgraph_msgs/Clock</strong><br/><br/><strong> Publishers: </strong><br/><strong> * /gazebo (http://rosbot.local:37865/)</strong><br/><br/><strong> Subscribers: </strong><br/><strong> * /rosout (http://rosbot.local:34729/)</strong><br/><strong> * /gazebo (http://rosbot.local:37865/)</strong><br/><strong> * /gazebo_gui (http://rosbot.local:38297/)</strong><br/><br/><strong>T2 $ rosmsg info rosgraph_msgs/Clock</strong><br/><strong> time clock</strong><strong><br/></strong></pre>
<p>The clock message type belongs to the <kbd>rosgraph_msgs</kbd> package. Take a look at the following link to find out more about this package: <a href="http://wiki.ros.org/rosgraph_msgs">http://wiki.ros.org/rosgraph_msgs</a>. </p>
<p>Now that we've set up the environment, we can add a virtual controller that will allow us to control GoPiGo3 inside Gazebo in the same way we did before with the physical robot.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding the controller to the Gazebo model of the robot</h1>
                </header>
            
            <article>
                
<p class="mce-root">Here, we are going to use a mechanism called <strong><span>controller</span></strong> to transform speed <kbd>/cmd_vel</kbd> messages into motions for the left and right wheels of the robot. For the case of a two-wheeled robot, this is known as a <strong>differential drive controller</strong>. This name is due to the fact that straight paths are achieved by rotating the wheels at the same speed. Any difference between the left and right angular speeds will make the robot describe a circumferential path. The larger the difference, the lower the radius of such a circumference (a straight path corresponds to describing a sector of a circumference of infinite radius, that is, the infinitesimal speed difference between wheels).</p>
<p>Let's get to the practical part:</p>
<ol>
<li class="mce-root">To include the differential drive controller in your model of the robot, add the following snippet inside the <kbd>&lt;robot&gt;</kbd> tag of the <kbd>urdf/gopigo.gazebo</kbd> file:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px">&lt;gazebo&gt;<br/>    &lt;plugin filename="libgazebo_ros_diff_drive.so" name="differential_drive_controller"&gt;<br/>       &lt;alwaysOn&gt;true&lt;/alwaysOn&gt;<br/>       &lt;updateRate&gt;20&lt;/updateRate&gt;<br/>       &lt;leftJoint&gt;<strong>joint_left_wheel</strong>&lt;/leftJoint&gt;<br/>       &lt;rightJoint&gt;<strong>joint_right_wheel</strong>&lt;/rightJoint&gt;<br/>       &lt;wheelSeparation&gt;0.4&lt;/wheelSeparation&gt;<br/>       &lt;wheelDiameter&gt;0.2&lt;/wheelDiameter&gt;<br/>       &lt;torque&gt;0.1&lt;/torque&gt;<br/>       &lt;commandTopic&gt;<strong>cmd_vel</strong>&lt;/commandTopic&gt;<br/>       &lt;odometryTopic&gt;odom&lt;/odometryTopic&gt;<br/>       &lt;odometryFrame&gt;odom&lt;/odometryFrame&gt;<br/>       &lt;robotBaseFrame&gt;<strong>base_link</strong>&lt;/robotBaseFrame&gt;<br/>    &lt;/plugin&gt;<br/> &lt;/gazebo&gt;</pre>
<p style="padding-left: 60px">You must set these correspondences, as defined in the URDF model of your robot:</p>
<ul>
<li style="list-style-type: none">
<ul>
<li class="mce-root"><kbd>&lt;robotBaseFrame&gt;</kbd> to <kbd>base_link</kbd></li>
<li class="mce-root"><kbd>&lt;leftJoint&gt;</kbd> to <kbd>joint_left_wheel</kbd></li>
<li class="mce-root"><kbd>&lt;rightJoint&gt;</kbd> to <kbd>joint_right_wheel</kbd></li>
</ul>
</li>
</ul>
<div class="packt_infobox">The <kbd>&lt;torque&gt;</kbd> tag is where you specify the maximum torque each can exert. This is all you need to know to carry out the experiment we suggested in <a href="74284adc-e0d7-4e40-a54b-e2e447b8e2fe.xhtml" target="_blank">Chapter 5</a>, <em>Simulating the Robot Behavior with Gazebo, </em>in the last section, entitled <em>Guidelines for tuning the Gazebo model</em>.</div>
<ol start="2">
<li>Notice how you tell the controller what topics it will receive the motion commands in by setting the <kbd>&lt;commandTopic&gt;</kbd> tag to the ROS <kbd>/cmd_vel</kbd> topic:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px">...<br/>&lt;commandTopic&gt;<strong>cmd_vel</strong>&lt;/commandTopic&gt;<br/>...</pre>
<ol start="3">
<li class="mce-root">Then, stop and relaunch Gazebo to find the new features that the differential drive provides to the simulation:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px"><strong>T1 $ roslaunch gazebo_control spawn.launch</strong></pre>
<ol start="4">
<li class="mce-root">There are two new topics, <kbd>/cmd_vel</kbd> and <kbd>/tf</kbd>:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px"><strong>T2 $ rostopic list</strong><br/><strong>   ...</strong><br/><strong>   /cmd_vel</strong><br/><strong>   ...</strong><br/><strong>   /tf</strong></pre>
<ol start="5">
<li class="mce-root">Remember from the previous section that we controlled the physical GoPiGo3 with the <kbd>/cmd_vel</kbd> topic. Following the same steps, you can teleoperate the virtual robot with the keyboard (arrow keys):</li>
</ol>
<pre class="mce-root" style="padding-left: 60px"><strong>T2 $ rosrun key_teleop key_teleop.py /key_vel:=/cmd_vel</strong></pre>
<p class="mce-root" style="padding-left: 90px">Make sure you are on the window where you launched <kbd>T2</kbd> so that any keystrokes are caught and you can see the effect they have on the robot in Gazebo.</p>
<ol start="6">
<li class="mce-root">Visualize the ROS graph with <kbd>T3 $ rqt_graph</kbd>. You should obtain the result shown in the following diagram:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1403 image-border" src="assets/bca82557-588a-49bf-aa55-e7bf67e66a6e.png" style="width:23.17em;height:7.67em;"/></p>
<p style="padding-left: 60px">As before, the topic that's remapping <kbd>/key_vel:=/cmd_vel</kbd> in the <kbd>T2</kbd> Terminal allows the virtual robot to be controlled with the arrow keys.</p>
<p>Finally, we are going to join the physical and the virtual robot in the same ROS environment.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Real-world and simulation at once</h1>
                </header>
            
            <article>
                
<p>Since we will be working with the robot, we need to specify the ROS master in the laptop so that it's pointing to GoPiGo3. To do so, uncomment the following line in your local <kbd>.bashrc</kbd> file to switch back to that configuration:</p>
<pre>export ROS_MASTER_URI=http://gopigo3.local:11311</pre>
<p>Instead of killing the rest of the bash Terminals, you can reload the updated <kbd>.bashrc</kbd> in each of them:</p>
<pre><strong>$ source ~/.bashrc</strong></pre>
<p>Now, you are ready to execute ROS with both versions of GoPiGo3:</p>
<ol>
<li>First, launch the robot:<span><br/></span></li>
</ol>
<pre style="padding-left: 60px"><span><strong>$ roslaunch mygopigo gopigo3.launch</strong><br/></span></pre>
<ol start="2">
<li>Then, launch the rest of the ROS environment on the laptop. First, launch the keyboard control:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px"><strong>T1 $ rosrun key_teleop key_teleop.py /key_vel:=/cmd_vel<br/></strong></pre>
<ol start="3">
<li>Next, launch the virtual model:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px"><strong>T2 $ roslaunch gazebo_control spawn.launch</strong></pre>
<ol start="4">
<li>Finally,<span> </span>check the ROS graph:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px"><strong>T3 $ rqt_graph</strong></pre>
<p style="padding-left: 60px">If everything went well, you should see the following familiar graph:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1404 image-border" src="assets/1196fb4d-fc0c-4c20-b109-e048075edbd4.png" style="width:22.33em;height:9.42em;"/></p>
<p style="padding-left: 60px">This states that you should be able to simultaneously control the physical robot (the <kbd>gopigo3</kbd> node) and the virtual robot (the <kbd>gazebo</kbd> node) with the same keystrokes (the <kbd>key_teleop</kbd> node).</p>
<ol start="5">
<li>Check teleoperation by clicking the left or right arrow key of the laptop keyboard. Both the physical and virtual GoPiGo3 will rotate at the same time. A similar result will be obtained if you press the <em>up</em> or <em>down</em> arrow keys.</li>
</ol>
<div class="packt_tip">For the keystrokes to be effective, you need to have selected the Terminal window where you launched the <kbd>key_teleop.py</kbd> node, that is, <kbd>T2</kbd>.</div>
<p>Congratulations <span>– </span>you have successfully completed a whole tour of how to control a robot in ROS!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, you have achieved correspondence between the physical GoPiGo3 and its virtual model in Gazebo. You have checked how it doesn't matter whether you're controlling the actual robot or a virtual robot from the point of view of ROS. Since both are moved using the same topic, <kbd>/cmd_vel</kbd>, ROS does not care about which type of robot you're dealing with.</p>
<p>This fact explains how, from the point of view of ROS, you have the choice to test your code with a virtual robot and then safely apply it to <span>the physical robo</span><span>t. We just need</span> to launch the <span>ROS node of the </span>physical robot. This is useful <span>in three situations</span>. First, when you are developing a new application for an existing robot, you can debug the code with a virtual model in Gazebo. Second, when you do not have available the hardwar<span>e of the robot – because you are still deciding which one to buy – you can virtually play and test the robot prior to the buy decision. A</span>nd third, when you are designing a new robot, yo<span>u have the choice of launching its mechanical design and software development in parallel. When you do this, the developed code will send feedback to your mechanical design before carrying out any manufacturing activities. This iterative loop should benefit the final product by cutting its development costs.</span></p>
<p>In the next chapter, you will tackle the first autonomous task of the robot: to make it aware of its environment and be able to navigate to reach a predefined destination. These tasks will introduce you to the <strong>Simultaneous Localization and Mapping</strong> (<strong>SLAM</strong>) <span>technique</span>, <span>an algorithm that's intensively used in all kinds of autonomous vehicles, especially in self-driving cars.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>If you need to have two different computers communicating over ROS, where should you locate the ROS master node?</li>
</ol>
<p style="padding-left: 60px">A) In the one that has the more recent version of ROS.<br/>
B) The ROS master node will run in the first one where you launch the <kbd>roscore</kbd> process.<br/>
C) You can place the master wherever you want. In one of the computers, you run <kbd>roscore</kbd>, and in the other one, you tell ROS that the master node<span> is located in the other machine.</span></p>
<ol start="2">
<li>You have a physical robot named <kbd>mazinger_zeta</kbd> that accepts <kbd>geometry_msgs/Twist</kbd> messages in the <kbd>/walk</kbd> topic. What is the correct topic remapping command for remotely controlling the robot with the keyboard?</li>
</ol>
<p style="padding-left: 60px">A) <kbd>rosrun key_teleop key_teleop.py /walk:=/cmd_vel</kbd><br/>
B)<strong><kbd> rosrun key_teleop key_teleop.py /key_vel:=/walk</kbd></strong><br/>
C) <kbd>rosrun key_teleop key_teleop.py /walk:=/key_vel</kbd></p>
<ol start="3">
<li>If yo<span>u apply a speed command of 1 m/s to the <em>Y</em> axis, how will it move GoPiGo3?</span></li>
</ol>
<p style="padding-left: 60px">A) The robot will move left at 1 m/s<br/>
B) <span>Nothing will happen<br/></span><span>C) You need to specify a publishing frequency so that the command takes effect</span></p>
<ol start="4">
<li>What visible effect does this command have on the physical robot?</li>
</ol>
<pre style="padding-left: 60px"><strong>T1 $ rostopic pub /cmd_vel geometry_msgs/Twist 'angular: {z: 90}'</strong></pre>
<p style="padding-left: 60px">A) It will rotate at the maximum possible speed since this is lower than 90 radians/seconds.<br/>
<span>B) GoPiGo3 cannot move at such a large angular speed.<br/></span> C) S<span>ince it exceeds the maximum speed that GoPiGo3 can handle, the robot will stay still.</span></p>
<ol start="5">
<li>If you're controlling GoPiGo3 and the virtual robot with the keyboard simultaneously, what difference will you appreciate if you tell both of them to rotate at π rad/s every 2 seconds?</li>
</ol>
<p style="padding-left: 60px">A) Both will do a complete turn of 360º.<br/>
B) The virtual robot will rotate 360º but the physical robot will not complete the turn since there is the opposing force of the friction of the wheels against the floor.<br/>
C) The virtual robot will do exactly 360º, but the physical robot won't because of the wheel encoder's limited precision.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<ul>
<li>ROS networking and time synchronization: <a href="http://wiki.ros.org/ROS/NetworkSetup">http://wiki.ros.org/ROS/NetworkSetup</a></li>
<li><em>ROS Robot Programming: A handbook Written by TurtleBot3 Developers</em>, <span>YoonSeok Pyo, HanCheol Cho, RyuWoon Jung, TaeHoon Lim (2017</span><span>), </span>ROBOTIS <span>Co. Ltd, 1st edition: </span><a href="http://www.pishrobot.com/wp-content/uploads/2018/02/ROS-robot-programming-book-by-turtlebo3-developers-EN.pdf">http://www.pishrobot.com/wp-content/uploads/2018/02/ROS-robot-programming-book-by-turtlebo3-developers-EN.pdf</a><span>, Chapter: <em>Mobile Robots</em></span></li>
<li>Integrating sonar and IR sensor plugins into the robot model in Gazebo with ROS: <a href="https://medium.com/teamarimac/integrating-sonar-and-ir-sensor-plugin-to-robot-model-in-gazebo-with-ros-656fd9452607">https://medium.com/teamarimac/integrating-sonar-and-ir-sensor-plugin-to-robot-model-in-gazebo-with-ros-656fd9452607</a></li>
</ul>


            </article>

            
        </section>
    </body></html>