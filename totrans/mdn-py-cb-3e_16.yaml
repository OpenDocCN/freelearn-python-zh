- en: '16'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Dependencies and Virtual Environments
  prefs: []
  type: TYPE_NORMAL
- en: Python runs in an environment defined by the OS. There are some slight differences
    between Windows, macOS, and most Linux environments. We’ll set aside micro-controller
    environments, since the ability to tailor those environments is quite a bit more
    involved. We’ll try to minimize the OS differences to focus on the common aspects
    that are universally available.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several common aspects within run-time environments. We can divide
    these into two groups:'
  prefs: []
  type: TYPE_NORMAL
- en: Persistent
  prefs: []
  type: TYPE_NORMAL
- en: Aspects of the environment that change slowly.
  prefs: []
  type: TYPE_NORMAL
- en: The Python run-time in use. This includes a binary application and often includes
    a number of external libraries.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The standard libraries available. These are accessed via the importer, and are
    generally available via the import statement. They are generally found by their
    path, relative to the Python binary.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The other libraries installed as site packages. These are also accessed by the
    importer. These libraries are also found by their path, relative to the Python
    binary.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Libraries found by other mechanisms available in the sites package. Most notably,
    the PYTHONPATH environment variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transient
  prefs: []
  type: TYPE_NORMAL
- en: Aspects of the environment can change each time the Python run-time is started.
  prefs: []
  type: TYPE_NORMAL
- en: The environment variables defined by the shell in use. These are available through
    the os module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The current working directory and user information, defined by the OS. This
    is available through the os, os.path, and pathlib modules.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The command line used to start Python. This is available through several attributes
    of the sys module, including sys.argv, sys.stdout, sys.stdin, and sys.stderr.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The persistent environment is managed via OS-level commands, outside of our
    application programs. Changes to the persistent aspects of the environment are
    generally examined once when Python starts. This means an application we write
    can’t easily install a package and then use that package.
  prefs: []
  type: TYPE_NORMAL
- en: 'The persistent environment has two viewpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: The Actual Environment
  prefs: []
  type: TYPE_NORMAL
- en: ': A single site is handled by the system administrator and requires elevated
    privileges. For example, the Python run-time is often in a path owned by the root
    user and made visible through a common, system-wide value of the PATH environment
    variable.'
  prefs: []
  type: TYPE_NORMAL
- en: Virtual Environments
  prefs: []
  type: TYPE_NORMAL
- en: ': Any number of virtual environments are localized by individual users and
    require no special privileges. Multiple Python run-times and their associated
    site packages can be owned by a single user.'
  prefs: []
  type: TYPE_NORMAL
- en: Once upon a time — in the long-past olden days, when computer capabilities were
    tiny — a single actual environment was all that could be managed. Adding and changing
    the collection of installed packages required cooperation among Python users.
    An administrator with elevated privileges implemented any changes.
  prefs: []
  type: TYPE_NORMAL
- en: Now that computers are vastly more capable, each individual user can easily
    have multiple virtual environments. Indeed, we often build and test modules with
    numerous virtual environments reflecting different releases of the Python run-time.
    Each individual is able to manage their own virtual environments.
  prefs: []
  type: TYPE_NORMAL
- en: When working cooperatively, it becomes important to share the details of virtual
    environments so that multiple users can recreate a common virtual environment.
    The effort of sharing a single actual environment is shifted to each user having
    to prepare and manage their own virtual environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Environment management seems to parallel Ginsberg’s Theorem and the Laws of
    Thermodynamics:'
  prefs: []
  type: TYPE_NORMAL
- en: The overall environment management workload is neither created nor destroyed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any change to an environment requires work.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nothing is free from change (unless it’s utterly isolated from all external
    considerations).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While most Linux distributions come with Python pre-installed, there’s no compelling
    reason to use this version of Python for any purpose. It’s generally much easier
    to install a personal version of Python and manage virtual environments with that
    personal version. Having an individual Python installation permits ready updates
    to new releases without waiting for a Linux distribution to catch up with the
    state of the art.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two broad classes of tools involved in managing environments:'
  prefs: []
  type: TYPE_NORMAL
- en: OS-specific tools required to install the Python binary. This varies by OS and
    can be challenging to new developers. We’ll avoid the complications involved in
    these tools and refer readers to the [https://www.python.org/downloads/](https://www.python.org/downloads/)
    page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python-based tools, like PIP, used to install Python libraries. Since these
    tools depend on Python, the commands are universal for all OSs. This chapter will
    focus on these tools.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll look at the following recipes for managing virtual environments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Creating environments using the built-in venv](ch020_split_000.xhtml#x1-8650001)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Installing packages with a requirements.txt file](ch020_split_000.xhtml#x1-8730002)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Creating a pyproject.toml file](ch020_split_000.xhtml#x1-8790003)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Using pip-tools to manage the requirements.txt file](ch020_split_000.xhtml#x1-8850004)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Using Anaconda and the conda tool](ch020_split_001.xhtml#x1-8910005)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Using the poetry tool](ch020_split_001.xhtml#x1-8970006)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Coping with changes in dependencies](ch020_split_001.xhtml#x1-9030007)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll start with creating virtual environments using the built-in tools.
  prefs: []
  type: TYPE_NORMAL
- en: 16.1 Creating environments using the built-in venv
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once Python is installed, creating virtual environments unique to each project
    can be done with the internal venv module.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two principle use cases for a virtual environment:'
  prefs: []
  type: TYPE_NORMAL
- en: Manage the Python version. We might have distinct virtual environments for Python
    3.12 and Python 3.13\. In some cases, we may need to manage multiple minor releases
    of Python 3.13.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manage the mix of site-specific packages required by our project. Rather than
    trying to update the single actual environment, we can create new virtual environments
    as new releases of packages become available.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These two use cases overlap a great deal. Each release of Python will have distinct
    versions of the standard library packages and may have distinct versions of external
    site-specific packages.
  prefs: []
  type: TYPE_NORMAL
- en: The most important part of using a virtual environment is making sure that it
    has been activated. A number of scenarios will change the internal state of the
    browser, deactivating the virtual environment. Closing a terminal window and rebooting
    the computer are two of the most common ways to deactivate an environment.
  prefs: []
  type: TYPE_NORMAL
- en: Changing terminal windows or opening a new terminal window may start a shell
    environment in which the virtual environment is not active. This is easily remedied
    by activating the environment before starting to use it.
  prefs: []
  type: TYPE_NORMAL
- en: 16.1.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s important to note that Python must be installed. Python may not be present,
    and whatever Python version is part of the OS should not be used for development
    or experimentation. For macOS and Windows, it’s common to install a pre-built
    binary. This may involve downloading a disk image and running an installer or
    downloading an installer application and running it.
  prefs: []
  type: TYPE_NORMAL
- en: For Linux, it’s common to build Python from source for the given distribution.
    An alternative is to use an administrative tool like rpm, pkg, yum, or aptitude
    to install a pre-built Python for the specific distribution.
  prefs: []
  type: TYPE_NORMAL
- en: Most Python releases will include the pip and venv packages. Microcontroller
    Python and WASM-based Python are often difficult to update using desktop tools;
    they’re outside the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 16.1.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we’ll look at creating a virtual environment that can be used to install
    packages and resolve imports. Once the environment has been created, we’ll look
    at activating and deactivating it. The environment must be active in order to
    properly install and use packages.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to avoid putting a virtual environment under configuration control.
    Instead, the configuration details required to recreate the environment are put
    under configuration control.
  prefs: []
  type: TYPE_NORMAL
- en: When using tools like Git, a .gitignore file can be used to ignore any virtual
    environment details of a project. An alternative approach is to separate virtual
    environment definitions from specific project directories.
  prefs: []
  type: TYPE_NORMAL
- en: Create a virtual environment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, create the project directory. For very small projects, no additional
    files are needed. For most projects, src, tests, and docs directories are often
    helpful for organizing the project code, the test code, and the documentation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose between a ”concealed” or a visible file. In Linux and macOS, files with
    names that start with . are generally not shown by most commands. Since the virtual
    environment is not a directory we’ll ever work with, it’s often simplest to use
    the name .venv.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In some cases, we want the directory to be visible. Then, the venv name would
    be the best choice.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following command will create a virtual environment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The virtual environment will be in the .venv directory within the project directory.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After this is done, the virtual environment must be activated. Any time a new
    terminal window is opened, the environment in that window needs to be activated.
  prefs: []
  type: TYPE_NORMAL
- en: Activate and deactivate an environment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Activating a virtual environment requires an OS-specific command. The Python
    Standard Library documentation provides all of the variant commands. We’ll show
    the two most common variants:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For Linux and macOS, using bash or zsh, enter the following command to activate
    a virtual environment:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For Windows, enter the following command to activate a virtual environment:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the virtual environment has been activated, a number of environment variables
    will change. Most notably, the PATH environment variable will include the virtual
    environment’s bin directory. This will, for example, make the deactivate command
    available. Additionally, the prompt will change to include the virtual environment’s
    name. It might look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: On the first line, the default prompt shows the directory. On the second line,
    the prompt has (.venv) as a prefix to show that the virtual environment is now
    active.
  prefs: []
  type: TYPE_NORMAL
- en: Once the virtual environment has been activated, all further use of the pip
    command to install packages will be directed to the active environment. Any Python
    application that’s run will search the active environment to install packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'To deactivate an environment, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The activate command created this new command as part of the virtual environment,
    so it’s universally available for all OSs.
  prefs: []
  type: TYPE_NORMAL
- en: 16.1.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For most OSs, there are a few key environment variables that define a virtual
    environment. The PATH environment variable generally provides locations for finding
    the Python executable. In a Windows environment, this will also make the launcher,
    the py command, available.
  prefs: []
  type: TYPE_NORMAL
- en: The locations of the remaining Python elements are all relative to the executable.
    In particular, the standard library is an adjacent path, and this library has
    the sites package that handles all of the other details of locating installed
    packages.
  prefs: []
  type: TYPE_NORMAL
- en: The details of the virtual environment are defined by three directories and
    a configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: The configuration file, pyvenv.cfg, provides a few important settings. The three
    directories are bin, include, and lib. (For Windows, these names are Scripts,
    Include, and Lib). The bin directory has script files that perform activation
    of the virtual environment. Setting the PATH environment variable makes these
    scripts available. This includes the deactivate command. Additionally, the bin
    directory contains a pip executable command and a link to the proper python binary.
  prefs: []
  type: TYPE_NORMAL
- en: 16.1.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a number of options in the venv command. Of these, two seem to be
    particularly useful:'
  prefs: []
  type: TYPE_NORMAL
- en: The --without-pip option skips the installation of a venv-specific copy of PIP.
    It seems better to use python -m pip than to rely on the virtual environment installation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The --prompt option can set a nicer environment name than .venv.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We’ll often use a command like the following to activate an environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This will ensure the prompt becomes (ch17) instead of the vague and potentially
    confusing (.venv).
  prefs: []
  type: TYPE_NORMAL
- en: 16.1.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once a virtual environment is created, we can add external libraries. See [Installing
    packages with a requirements.txt file](ch020_split_000.xhtml#x1-8730002) for advice
    on managing dependencies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.2 Installing packages with a requirements.txt file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the significant strengths of Python is the vast ecosystem of packages
    available in libraries like the Python Package Index (PyPI) at [https://pypi.org](https://pypi.org).
    It’s easy to use the PIP tool to add libraries to an environment.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, this is — perhaps — too easy. All of the dependencies, starting
    with the libraries on which the Python run-time is built, are in a constant state
    of flux. Each has a distinct tempo for updates. In some cases, there is limited
    cooperation among the vast number of people involved.
  prefs: []
  type: TYPE_NORMAL
- en: 'To manage the constant change, it’s important for people developing applications
    to track dependencies carefully. We suggest decomposing dependencies into three
    levels of specificity:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Generic, name-only dependencies: For example, an application might need Beautiful
    Soup.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Filtered: As the Beautiful Soup project evolves, there may be versions with
    known bugs, or that are missing essential features. We might want to narrow the
    dependency to omit or exclude a specific version, or require a version that is
    >= 4.0.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pinned (or Locked): When it is time to build (and test) a specific virtual
    environment, it is essential to have a detailed list of the exact version numbers
    used for testing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we’re first exploring data or a problem domain or candidate solutions,
    we may download a great many packages into a development environment. As a project
    matures, the virtual environment contents will shift. In some cases, we’ll learn
    we don’t need a package; the unused packages will be ignored and should be removed.
    In other cases, the mix of packages will expand as new options are explored. Throughout
    this, the pinned version numbers may change to track acceptable versions of packages
    on which our project depends.
  prefs: []
  type: TYPE_NORMAL
- en: 16.2.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It works out well to record generic dependencies in places like a pyproject.toml
    file. (We’ll look at this in the [Creating a pyproject.toml file](ch020_split_000.xhtml#x1-8790003)
    recipe.)
  prefs: []
  type: TYPE_NORMAL
- en: The specific, pinned dependencies can be separated into a collection of requirements
    files. There are a number of dependency use cases, leading to a collection of
    closely related files.
  prefs: []
  type: TYPE_NORMAL
- en: The format for a requirements file is defined as part of the PIP documentation.
    See the [Requirements File Format](https://pip.pypa.io/en/stable/reference/requirements-file-format/)
    page of [https://packaging.python.org](https://packaging.python.org).
  prefs: []
  type: TYPE_NORMAL
- en: 16.2.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Gather the general requirements. It’s best to look at the import statements
    to discern what packages are direct dependencies. We might find that a project
    uses pydantic, beautifulsoup4, jupyterlab, matplotlot, pytest, and memray.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open a file named requirements.txt in the top-level directory of the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Each line of the file will have a requirements specifier with four pieces of
    information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The package name. Note that typo-squatting is a prevalent problem with open
    source; be sure to find the correct, current repository for a package, not a similar-looking
    name.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Any extras needed. If present, these are enclosed in [ ]. For example, rich [jupyter]
    might be used when using the rich package for text styling with Jupyter Lab.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A version specifier. This has a comparison (==, >=, etc.), and a version as
    a dotted sequence of numbers. For example, pillow>=10.2.0 selects any version
    of the pillow package at or after version 10.2.0, avoiding a known vulnerability
    with version 10.1.0.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If necessary, any further environment constraints separated by a ;. For example,
    sys_platform == ’win32’ might be used to provide a platform-specific requirement.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: While complex conditions can be created, they’re not often needed. It’s best
    to avoid writing version information unless a specific bug fix, missing feature,
    or compatibility problem surfaces.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The full set of rules for this file is in the [PEP 508](https://peps.python.org/pep-0508/)
    document.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Version specifiers are defined in the Python Packaging Guide. See the [Version
    specifiers](https://packaging.python.org/en/latest/specifications/version-specifiers)
    page of [https://packaging.python.org](https://packaging.python.org).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For example, here is the list of dependencies:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Activate the project’s virtual environment (if it’s not already activated):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the following command to install the latest versions of the named packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The PIP application will find matching versions of the various packages and
    install them. Because some of these packages have complex layers of dependencies,
    the installation can be rather time-consuming the first time it’s attempted.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This list of seven packages expands to about 111 packages in total that must
    be installed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For many projects, this is all that’s required to build a useful environment
    definition. In many cases, this base definition needs to have more specific version
    information provided. This is a separate recipe; see [Using pip-tools to manage
    the requirements.txt file](ch020_split_000.xhtml#x1-8850004).
  prefs: []
  type: TYPE_NORMAL
- en: 16.2.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The PIP application uses the -r option to parse a file with required packages.
    Within this file, we can have simple lists of packages, and complex rules for
    locating the proper version of a package. We can even have other -r options to
    incorporate other files of requirements. Using multiple files can help organize
    very complex projects.
  prefs: []
  type: TYPE_NORMAL
- en: When we name a package PIP, it will examine the target’s metadata to locate
    packages on which it depends. These transitive dependencies must be installed
    before the target package is installed. This means an internal lattice structure
    showing all of the dependencies must be built. This can involve downloading multiple
    copies of a package, as version constraints are resolved into a single, final
    list of packages to install.
  prefs: []
  type: TYPE_NORMAL
- en: 'While it’s easy to use PIP to manually install a single package, this leads
    to confusion about what a project needs and what’s currently installed in the
    virtual environment. Avoiding this requires a disciplined approach of always doing
    these two things when exploring a new package:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the package to the requirements.txt file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run python -m pip install -r requirements.txt to add packages to the current
    virtual environment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When removing packages from the requirements.txt file, we can generally proceed
    by deleting the virtual environment and creating an entirely new one. This leads
    to the following sequence of commands being used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Because PIP maintains a cache of downloaded files, this environment will be
    rebuilt relatively quickly. The use of requirements.txt ensures the environment
    is built in a repeatable fashion.
  prefs: []
  type: TYPE_NORMAL
- en: 16.2.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s very common to install components manually and uncover conflicts. For example,
    a colleague clones a repository and cannot run the unit test suite because the
    requirements.txt file is incomplete.
  prefs: []
  type: TYPE_NORMAL
- en: Another case is an audit of development environments. As new people join a team,
    they may install new releases of a package named in the requirements.txt file.
    To be confident everyone has the same version, it helps to freeze the version
    information for the packages in a virtual environment.
  prefs: []
  type: TYPE_NORMAL
- en: For both use cases, the python -m pip freeze command can be used. This will
    report all of the installed packages and the versions that were used. The output
    from this is in the same format as a requirements file.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use a command like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: These output files can be compared to locate differences and repair environments
    that are not consistent with expectations.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the output from the pip freeze subcommand can be used to replace
    a generic requirements.txt file with a file that specifically pins each and every
    package in use. While this is very easy, it’s not terribly flexible because it
    provides specific versions. There are better ways to build a requirements.txt
    file using pip-tools. We’ll look at this in [Using pip-tools to manage the requirements.txt
    file](ch020_split_000.xhtml#x1-8850004).
  prefs: []
  type: TYPE_NORMAL
- en: 16.2.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the [Creating environments using the built-in venv](ch020_split_000.xhtml#x1-8650001)
    recipe to see how to create a virtual environment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See the [Using pip-tools to manage the requirements.txt file](ch020_split_000.xhtml#x1-8850004)
    recipe for a way to manage dependencies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.3 Creating a pyproject.toml file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to a virtual environment and a clear list of dependencies, a project
    also benefits from an overall summary, in the form of a pyproject.toml file.
  prefs: []
  type: TYPE_NORMAL
- en: A pyproject.toml file is required by some Python tools and is helpful to have
    in general. It provides a central summary of the technical details of the project.
  prefs: []
  type: TYPE_NORMAL
- en: With the adoption of [PEP 621](https://peps.python.org/pep-0621/), this file
    has become the expected place for metadata about a project. It replaces the older
    setup.py module.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe is based on the [Sample Project](https://github.com/pypa/sampleproject)
    project in the packaging authority Git repository at [https://github.com/pypa](https://github.com/pypa).
    The recipe is also based on the [Packaging Python Projects](https://packaging.python.org/en/latest/tutorials/packaging-projects/),
    page, one of the Packaging Authority tutorials. See [https://packaging.python.org](https://packaging.python.org).
  prefs: []
  type: TYPE_NORMAL
- en: 16.3.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll assume the project is not a trivial single-file module but something
    larger. This means there will be a directory structure somewhat like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![YLRpdcisyimttoIEyoonronoeeuCApcndcuidssrEDrsfert.uttNMo.xpplsmPSEjp.ayeorE.eyrc.domcstkpujdtayle.gectoe.tmply
    ](img/file83.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.1: Project files'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve shown a common structure that applies broadly to many projects. The top-level
    name, Your Project, is a name that works for your collection of projects.
  prefs: []
  type: TYPE_NORMAL
- en: The name your_package inside the src directory is the name by which the package
    will be known when it is imported. This does not have to precisely match the overall
    project name, but it should have a clear relationship. As an example, the Beautiful
    Soup project has a PYPI entry with the name beautifulsoup4, but the imported package
    is named bs4 in your Python’s local site packages. The connection is clear.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve shown the README.md file with an extension that indicates it’s written
    in Markdown notation. Common alternatives are README.rst and README.
  prefs: []
  type: TYPE_NORMAL
- en: The LICENSE file can be a difficult choice. See [https://spdx.org/licenses/](https://spdx.org/licenses/)
    for a comprehensive list of open-source licenses. See [GNU License List](https://www.gnu.org/licenses/license-list.en.html)
    at [https://www.gnu.org](https://www.gnu.org) for advice on various open source
    licenses.
  prefs: []
  type: TYPE_NORMAL
- en: The content of the docs directory is often built using tools like Sphinx. We’ll
    address documentation in Chapter [17](ch021.xhtml#x1-91400017).
  prefs: []
  type: TYPE_NORMAL
- en: 16.3.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure the README.md has a summary of how to install and use the project.
    This is subject to change as the project evolves.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There are six essential questions: ”who?”, ”what?”, ”why?”, ”when?”, ”where?”,
    and ”how?” that can help write a short paragraph to describe the project. The
    C4 model offers additional help on how to describe software. See [C4 Model](https://c4model.com).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Determine which build system will be used. Choices include setuptools, hatch,
    and poetry. Parts of content of the pyproject.toml file will be unique to the
    build system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For this recipe, we’ll use setuptools as the build tool.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'There are numerous templates available for a pyproject.toml file. The [PYPA
    sample project](https://github.com/pypa/sampleproject/blob/main/pyproject.toml)
    example is comprehensive, and perhaps a bit daunting. There are two tables in
    the TOML that are required: [project] and [build-system]. The rest can be ignored
    when getting started.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here’s a short template for the [project] table:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The first six items need to have values replaced with facts about your project.
    The last two items, readme and license, don’t often change because they’re references
    to files in the project directory.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The name must be a valid identifier for a project. They are defined by [PEP-508](https://peps.python.org/pep-0508/).
    They are names made of letters, digits, and the special characters -, _, and ..
    Interestingly, they can’t include spaces or end with a punctuation mark. ch17-recipe3
    is acceptable, but ch17_ is invalid.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The dependencies must be a list of the direct requirements that must be installed
    in order for this project to work. These are the same kinds of dependency specifications
    provided in a requirements.txt file. See [Installing packages with a requirements.txt
    file](ch020_split_000.xhtml#x1-8730002) for more information.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Here’s a template for the [build-system] table. This uses the small, widely
    available setuptools tool:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It can help to open this file with tomllib to confirm it’s formatted properly.
    This can be done interactively in the Python console as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the file is invalid in some way, this will raise a tomllib.TOMLDecodeError
    exception. The exception will provide the line and column for the syntax error,
    or it will say ”at end of document” when a structure isn’t terminated properly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 16.3.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A number of tools make use of the pyproject.toml contents. There is a complicated
    relationship between PIP and the build tool named in the pyproject.toml file.
    For this recipe, we’re using setuptools.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram summarizes some of the steps involved in downloading
    and installing a library:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ysPPdBwtpPp1234r5r6oitYIouhakyip....ea.ea.uePPwierggP g c g bd cd ir-InleeIieaeusrsnpldltntctiescao
    TPsshrlatocaoateedtamkdocasqwellpalklluhssugaietegreeeseslr...hohookok ](img/file84.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.2: How PIP and the build tool collaborate'
  prefs: []
  type: TYPE_NORMAL
- en: This summary diagram is neither an exhaustive nor definitive look at how packages
    are installed. For more information, see [PEP-517](https://peps.python.org/pep-0517).
  prefs: []
  type: TYPE_NORMAL
- en: 'The processing begins with the pip install command, shown with a boundary icon.
    The PIP operation proceeds through the numbered steps:'
  prefs: []
  type: TYPE_NORMAL
- en: PIP starts by getting the compressed archive from a package index like PYPI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The archive is cached on the local computer for future use.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: PIP uses the get_requires_for_build_wheel build-tool hook to gather requirements.
    The build tool gets dependency information from the pyproject.toml file and provides
    this to PIP. The PIP tool will download these additional projects. These projects
    have their own requirements. The graph of requirements is resolved to identify
    all of the required installations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In some cases, a new wheel-format file is required. In other cases, the project
    provides a wheel-formatted file. The PIP tool can use the build_wheel build-tool
    hook to combine the downloaded files into an installable form.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Some distributions include the source files, and may include data files or scripts
    that aren’t trivially copied to the site-packages directory.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: PIP then installs the wheel in the virtual environment’s appropriate site-packages
    directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Possible build tools to build a package include setuptools, build, hatch, and
    poetry. All of these build tools can be used by PIP. They all make use of pyproject.toml.
  prefs: []
  type: TYPE_NORMAL
- en: 16.3.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to the dependencies required for the project to work, additional
    dependencies are often based on other things we may do with the project. Common
    additional use cases are running tests, developing new features, and fixing bugs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tools for these additional use cases are optional dependencies. They are generally
    listed in a separate table, with sub-tables for each use case. For example, we
    might add the following table with two sub-tables to list the tools used for testing,
    and additional tools for more general development:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: These additional lists permit someone to install the test suite to confirm the
    downloaded project passes all of its test cases. They also permit someone to download
    appropriate tools for maintaining the documentation and the detailed lists of
    dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Note that in these examples, none of the dependencies are named with a specific,
    pinned version. This is because we’re going to use pip-tools to build a requirements.txt
    file from the information available in the pyproject.toml file. See [Using pip-tools
    to manage the requirements.txt file](ch020_split_000.xhtml#x1-8850004).
  prefs: []
  type: TYPE_NORMAL
- en: Tools like flit and twine are often used to upload to a repository like PYPI.
    For enterprise developers, there may be an enterprise Python repository. These
    tools make use of additional tables in the pyproject.toml file.
  prefs: []
  type: TYPE_NORMAL
- en: The flit tool, for example, uses additional [tool.flit.sdist] and [tool.flit.external-data]
    tables to provide information required to perform an upload.
  prefs: []
  type: TYPE_NORMAL
- en: 16.3.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See [https://python-semantic-release.readthedocs.io/en/latest/](https://python-semantic-release.readthedocs.io/en/latest/)
    for the Python Semantic Release tool that can modify version names based on Git
    commit messages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See [Using TOML for configuration files](ch017.xhtml#x1-7230002) in Chapter [13](ch017.xhtml#x1-71500013)
    for more information on TOML files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See [Using pip-tools to manage the requirements.txt file](ch020_split_000.xhtml#x1-8850004)
    for our approach to refining the list of requirements into a line of pinned version
    numbers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [Hypermodern Python](https://github.com/cjolowicz/cookiecutter-hypermodern-python)
    project has a template usable with the Cookie-Cutter tool to build a directory
    structure. See [https://github.com/cjolowicz](https://github.com/cjolowicz). This
    template relies on Poetry for managing dependencies and virtual environments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Chapter [17](ch021.xhtml#x1-91400017) contains the [The bare minimum: a README.rst
    file](ch021.xhtml#x1-9150001) recipe to address the README file in more depth.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.4 Using pip-tools to manage the requirements.txt file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Above, we noted that a project’s dependencies have three levels of specificity:'
  prefs: []
  type: TYPE_NORMAL
- en: Generic
  prefs: []
  type: TYPE_NORMAL
- en: ': Name-only dependencies'
  prefs: []
  type: TYPE_NORMAL
- en: Filtered
  prefs: []
  type: TYPE_NORMAL
- en: ': With a very general constraint like >= 4.0'
  prefs: []
  type: TYPE_NORMAL
- en: Pinned
  prefs: []
  type: TYPE_NORMAL
- en: ': With a specific version like == 4.12.2'
  prefs: []
  type: TYPE_NORMAL
- en: How do we align these levels? One easy way is with the pip-tools package. This
    package includes the pip-compile tool, which will digest requirements, resolve
    dependencies, and create a derivative requirements.txt file with pinned version
    numbers.
  prefs: []
  type: TYPE_NORMAL
- en: A companion tool, pip-sync, can be used to ensure that the active virtual environment
    matches the requirements.txt file. This can be considerably faster than dropping
    and recreating a virtual environment.
  prefs: []
  type: TYPE_NORMAL
- en: 16.4.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'PIP-tools must be downloaded and installed. Generally, this is done with the
    following terminal command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This assumes the virtual environment is active; in the example, it’s named ch17\.
    Using the python -m pip command ensures that we will use the pip command that
    goes with the currently active virtual environment.
  prefs: []
  type: TYPE_NORMAL
- en: The pip-compile tool will locate requirements in a pyproject.toml or requirements.in
    file. From this information, it builds a detailed requirements.txt file that can
    be used with pip or pip-sync to create the virtual environment.
  prefs: []
  type: TYPE_NORMAL
- en: 16.4.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure the dependencies are in the pyproject.toml file. In some cases, an
    old requirements.txt file may have been used to get started. It’s a good idea
    to confirm that the information is in the pyproject.toml file because the requirements.txt
    file will be replaced.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first time you do this, it helps to delete any old requirements.txt file
    not created by pip-compile.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To build the core requirements.txt file, run the pip-compile command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will locate the dependencies in the pyproject.toml file. It will then locate
    all of the transitive requirements and build a set of requirements with conflicts
    resolved.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It will both write a requirements.txt file and also display this file on the
    console.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To build a requirements-test.txt file, run the pip-compile command with the
    --extra option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This creates a file with the optional dependencies from the test = [...] section
    of the [project.optional-dependencies] table.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To build a comprehensive requirements-dev.txt file that contains all of the
    extras, run the pip-compile command with the --all-extras option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This creates a file with all of the optional dependencies in the [project.optional-dependencies]
    table.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When needed, use the pip-sync command to rebuild the current virtual environment
    to match changes to one of the requirements.txt files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It’s common practice to use this with the tox tool. In the commands_pre section
    of a test environment description, use pip-sync requirements.txt to make sure
    the test virtual environment is synchronized with the package versions in the
    requirements.txt file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 16.4.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The pip-compile tool will look for information in three places:'
  prefs: []
  type: TYPE_NORMAL
- en: The pyproject.toml file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A requirements.in file, if present. This isn’t needed, since the same information
    is in the pyproject.toml file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any previously created requirements.txt file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using both the pyproject.toml and any previously created requirements.txt file
    allows the tool to properly reflect incremental changes. This means it can minimize
    the work required to analyze projects that haven’t changed much. When starting
    a new project, it’s sometimes helpful to delete the requirements.txt file entirely
    after making significant changes.
  prefs: []
  type: TYPE_NORMAL
- en: 16.4.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When making changes, there are two options that can help rebuild the requirements.txt
    details:'
  prefs: []
  type: TYPE_NORMAL
- en: The --rebuild option will clear caches and redo the analysis of dependencies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The --upgrade some-package option will look for upgrades for the named some-package
    package only. This prevents analysis of other packages that should be left alone.
    Multiple --upgrade options can be supplied to track multiple changes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These two commands let us manage incremental change, upgrade requirements.txt,
    rebuild the virtual environment, and test with new versions of packages. This
    ensures the description of the environment matches the actual environment. We
    can share the project with confidence.
  prefs: []
  type: TYPE_NORMAL
- en: There are times when packages have conflicting requirements. Assume our project
    depends on project A and project T. It turns out project A also requires project
    T. Problems can arise when our project requires T >= 10.11 that’s distinct from
    the version required by the A project, for example, T < 10.9\. This can be challenging
    to resolve.
  prefs: []
  type: TYPE_NORMAL
- en: We can hope our project’s limitation of T >= 10.11 is too specific; we can weaken
    the constraint and find a compatible version. In other cases, the requirements
    stated by project A might be too specific, and we need to consider making a change
    to the other project’s code. Ideally, this is a proper issue and pull request,
    but it may require forking the project to offer distinct constraints. The worst
    case requires re-engineering our project to change the nature of the dependencies
    or — perhaps — stop using project A.
  prefs: []
  type: TYPE_NORMAL
- en: 'In some cases, there are obscure errors in pyproject.toml and the pip-compile
    tool reports an infuriatingly opaque error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This is a problem with the formatting of the pyproject.toml file.
  prefs: []
  type: TYPE_NORMAL
- en: One way to uncover the problem is to attempt to do an ”editable” installation
    of the project in the current working directory. This will use the pip install
    command with the -e . option to use the current directory as the project to install.
  prefs: []
  type: TYPE_NORMAL
- en: 'It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This will report the specific error found in the pyproject.toml file. We can
    then repair the error and run pip-compile again.
  prefs: []
  type: TYPE_NORMAL
- en: 16.4.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For more background on projects as a whole, see the PYPA [Sample Project](https://github.com/pypa/sampleproject).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For information on licenses, see [SPDX](https://spdx.org/licenses/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [Installing packages with a requirements.txt file](ch020_split_000.xhtml#x1-8730002)
    recipe describes using a file to drive PIP installations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See [PEP-517](https://peps.python.org/pep-0517) for more information on how
    a build system works.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.5 Using Anaconda and the conda tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are some limitations on the kinds of packages the PIP tool can install.
    The most notable limitation involves projects that involve extension modules written
    in a compiled language like Rust or C. The variations among platforms — including
    hardware and OS — can make it difficult to distribute all the required variants
    of the package’s binary files.
  prefs: []
  type: TYPE_NORMAL
- en: In a Linux environment, where compilers like GNU CC are readily available, a
    package with an extension module can include source code. The PIP tool can use
    the compiler to build the necessary binaries.
  prefs: []
  type: TYPE_NORMAL
- en: For macOS and Windows, additional tools are required to create binaries. Free
    compilers are not as readily available as they are in a Linux environment, presenting
    a potential problem.
  prefs: []
  type: TYPE_NORMAL
- en: Conda solves the problems with binaries by making a wide selection of pre-built
    binaries available in their repository. It also makes sure a compiler is available
    on the target platform for the cases where a pre-built binary isn’t available.
  prefs: []
  type: TYPE_NORMAL
- en: The conda tool is a virtual environment manager and package installer. It fulfills
    the same use cases as PIP, combined with venv and pip-tools. This includes builds
    of packages that include binaries, often used for high-performance numeric applications.
    The command-line interface for conda is the same on all platforms, permitting
    simpler, more consistent documentation.
  prefs: []
  type: TYPE_NORMAL
- en: The Anaconda package index is curated by the Anaconda company. Check out their
    website, [https://anaconda.com](https://anaconda.com), for prices and fees. The
    packages provided have been integrated and tested. This testing takes time, and
    the official Anaconda distribution can lag behind what’s available in PYPI. Further,
    it’s a subset of what’s available on PYPI because it tends to focus on data analytics
    and data science.
  prefs: []
  type: TYPE_NORMAL
- en: A separate package index, conda-forge ( [https://conda-forge.org](https://conda-forge.org))
    is community based. This channel contains packages that more closely mirror what’s
    in PYPI. In many cases, we’ll install packages from this channel because we want
    something new, or we want something outside the curated subset available from
    Anaconda.
  prefs: []
  type: TYPE_NORMAL
- en: 16.5.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two ways to get the conda tool:'
  prefs: []
  type: TYPE_NORMAL
- en: Download and install the full Anaconda distribution. This is a large download,
    anywhere from 900 MB for Windows to over 1,000 MB for more Linux distributions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Download and install miniconda and use it to install only the desired packages.
    This is a much smaller download, generally about 100 MB.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the full Anaconda install, see [https://www.anaconda.com/download](https://www.anaconda.com/download).
    There are two varieties of the installer:'
  prefs: []
  type: TYPE_NORMAL
- en: Graphical
  prefs: []
  type: TYPE_NORMAL
- en: ': These installers use the OS interactive tools to support some configuration.'
  prefs: []
  type: TYPE_NORMAL
- en: Command-line
  prefs: []
  type: TYPE_NORMAL
- en: ': These installers are sophisticated shell archives that run in a terminal
    window. They provide the same options for installation as the graphical installer.
    There’s more typing and less pointing and clicking.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For a miniconda install, see [https://docs.conda.io/projects/miniconda/en/latest/index.html](https://docs.conda.io/projects/miniconda/en/latest/index.html).
    Each OS has slightly different kinds of installers:'
  prefs: []
  type: TYPE_NORMAL
- en: Windows
  prefs: []
  type: TYPE_NORMAL
- en: ': The installer is an executable program that uses the Windows installer.'
  prefs: []
  type: TYPE_NORMAL
- en: macOS
  prefs: []
  type: TYPE_NORMAL
- en: ': There are PKG images that can be downloaded and double-clicked to use a macOS
    UI. There are also command-line images that can be executed from the terminal
    window.'
  prefs: []
  type: TYPE_NORMAL
- en: Linux
  prefs: []
  type: TYPE_NORMAL
- en: ': These are shell-archive files that are started from a terminal window.'
  prefs: []
  type: TYPE_NORMAL
- en: While there are a lot of choices here, we recommend using a command-line installer
    for Miniconda.
  prefs: []
  type: TYPE_NORMAL
- en: See the [Miniconda](https://docs.conda.io/projects/miniconda/en/latest/index.html)
    page for recommended shell commands to use the curl program to fetch the image
    and then perform the installation.
  prefs: []
  type: TYPE_NORMAL
- en: Once the conda tool has been installed, it can be used to create and populate
    virtual environments. Note that the conda tool creates a base virtual environment.
    When conda is installed, the (base) environment should be shown as part of terminal
    window prompts. This serves as a visual cue that no other environment has been
    activated. It may help to exit and restart all terminal windows to be sure conda
    is working.
  prefs: []
  type: TYPE_NORMAL
- en: 16.5.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s essential that the conda tool is installed. See the Getting ready section
    of this recipe for advice on installing conda.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the conda create command to create a new virtual environment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note the commands are the same on all operating systems.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The virtual environment’s files are kept outside the project directory. For
    macOS, there will be a ~/miniconda3/envs directory that has all of the virtual
    environment files.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Use the conda activate command to activate this new virtual environment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the conda install command to install a list of packages in the virtual
    environment. Conda has its own conflict resolver that’s separate from the one
    used by the PIP tool or pip-compile. While we can use the requirements.txt file,
    we don’t really need all of those details. It’s often easier to provide the package
    name information as shown in this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To create a shareable definition of the current virtual environment, use the
    conda env export command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This uses the shell redirect feature to save the exported information into a
    YAML-formatted file that lists all of the requirements. This file can be used
    by conda env create to recreate this environment.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 16.5.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The virtual environment created by conda has the proper PATH environment variable
    set to point to a specific Python binary. The standard library packages and site-specific
    packages are located in nearby directories.
  prefs: []
  type: TYPE_NORMAL
- en: This parallels the virtual environments created by the built-in venv module.
    It follows the rules of [PEP-405](https://peps.python.org/pep-0405/), which defines
    the rules for virtual environments.
  prefs: []
  type: TYPE_NORMAL
- en: In order to work consistently, the conda command must be visible. This means
    a base conda installation must also be named in the system PATH environment variable.
    This is a crucial step in using conda. The Windows installer has the option to
    either update the system path or to create special command windows in which the
    necessary path setting has been made. Similarly, the macOS installer requires
    an extra step to make the conda command available to the zsh shell.
  prefs: []
  type: TYPE_NORMAL
- en: The Anaconda repositories may have pre-built binaries, which can be downloaded
    and used by the conda tool. In cases where binaries aren’t available, the conda
    tool will download the source and build the binaries as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 16.5.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the most common use cases is upgrading to the latest releases of packages.
    This is done with the conda update command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This will look for the version of the package available in the various channels
    being searched. It will compare the available version with what’s currently installed
    in the active virtual environment.
  prefs: []
  type: TYPE_NORMAL
- en: To collaborate politely with tools like tox for testing, it helps to use the
    pip freeze command to create a requirements.txt file. By default, tox uses pip
    to build virtual environments. The PIP tool will not overwrite packages installed
    by conda, allowing them to coexist peacefully.
  prefs: []
  type: TYPE_NORMAL
- en: Another choice is to use the tox-conda plug-in to allow the tox tool to use
    conda to create and manage virtual environments. See the tox-conda repository
    at [https://github.com/tox-dev/tox-conda](https://github.com/tox-dev/tox-conda).
  prefs: []
  type: TYPE_NORMAL
- en: Not all libraries and packages are part of the Anaconda-supported, curated library.
    In many cases, we’ll need to step outside Anaconda and use the community conda-forge
    channel in addition to the Anaconda channel.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll often need to use a command like the following to use the conda-forge
    channel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We can also use pip to add packages to a conda environment. It’s rarely needed,
    but it does work nicely.
  prefs: []
  type: TYPE_NORMAL
- en: 16.5.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See [Creating environments using the built-in venv](ch020_split_000.xhtml#x1-8650001)
    for more information on virtual environments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See [https://www.anaconda.com/download](https://www.anaconda.com/download) for
    the full Anaconda installation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See [https://docs.conda.io/projects/miniconda/en/latest/index.html](https://docs.conda.io/projects/miniconda/en/latest/index.html)
    for the Miniconda installation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.6 Using the poetry tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The combination of the venv, pip, and pip-tools packages allows us to create
    virtual environments and populate them with packages from the PYPI package index.
  prefs: []
  type: TYPE_NORMAL
- en: The poetry tool is a virtual environment manager and package installer combined
    into a single tool. It fulfills the same use cases as PIP, combined with venv
    and pip-tools. It also fulfills the same use cases as conda. The CLI is the same
    on all platforms, permitting simpler, more consistent documentation for developers
    using Poetry to manage environments.
  prefs: []
  type: TYPE_NORMAL
- en: There are some minor differences in the way Poetry enables a virtual environment.
    Rather than tweaking the current shell’s environment variables, it launches a
    sub-shell. The sub-shell has the required virtual environment settings.
  prefs: []
  type: TYPE_NORMAL
- en: 16.6.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Note that the Poetry tool must be installed in its own virtual environment,
    separate from any project managed by Poetry. This is best done by using the Poetry
    installer. This involves OS-specific commands to download and execute the installer.
    The installer is written in Python, which makes the task somewhat more consistent
    across OSs.
  prefs: []
  type: TYPE_NORMAL
- en: See [https://python-poetry.org/docs](https://python-poetry.org/docs) for details.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Download from [https://install.python-poetry.org](https://install.python-poetry.org).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Execute the downloaded Python script.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The recommended commands vary slightly between operating systems:'
  prefs: []
  type: TYPE_NORMAL
- en: 'macOS, Linux, and Windows Subsystem for Linux: The curl command is generally
    available for doing the download. This command can be used:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After this, the follow-on step will update the system PATH environment variable.
    The output from the installation will provide the location to use. These two examples
    are for macOS, where the file is in ~/.local/bin.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Edit the ~/.zshrc file to add the following line:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As an alternative, it is possible to define an alias for the location of the
    poetry command. This is often ~/.local/bin/poetry.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Windows Powershell: The Invoke-WebRequest Powershell command performs the download.
    The Python launcher, py, runs the appropriate version of Python:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The script for poetry is placed in the AppData\Roaming\Python\Scripts sub-directory.
    Either add this to the PATH environment variable or use the path explicitly, for
    example: AppData\Roaming\Python\Scripts\poetry --version.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Changing the current working directory with chdir means explicitly referring
    to your home directory’s AppData sub-directory.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once the poetry tool has been installed, it can be used to create and populate
    virtual environments.
  prefs: []
  type: TYPE_NORMAL
- en: 16.6.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the poetry new command to create a new project directory. This will not
    only create a virtual environment; it will also create a directory structure and
    create a pyproject.toml file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The virtual environment’s files are kept outside the project directory. For
    macOS, there will be a ~/Library/Caches/pypoetry directory that has all of the
    virtual environment files.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note that poetry tries to cooperate with other virtual environment tools. This
    means you can use a venv activate command to set the environment variables.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Rather than activate the environment within a shell’s environment, it’s often
    easier to start a sub-shell with the appropriate environment settings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the poetry shell command to start a shell that has the virtual environment
    activated:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Use the shell’s exit command to terminate this sub-shell and return to the previous
    environment.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Use the poetry add command to add packages to the environment. This will both
    update the pyproject.toml file and install the packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This also creates a poetry.lock file that defines the exact versions of each
    dependency.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 16.6.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The virtual environment created by poetry has the proper PATH environment variable
    set to point to a specific Python binary. The standard library packages and site-specific
    packages are located in nearby directories. Poetry properly leverages the information
    in the pyproject.toml file, reducing the number of additional files required to
    define the working environment.
  prefs: []
  type: TYPE_NORMAL
- en: In order to work consistently, the poetry command must be visible. This means
    either adding the poetry location to the system PATH environment variable or using
    an alias. This is a crucial step in using poetry.
  prefs: []
  type: TYPE_NORMAL
- en: The alternative to an alias is what is shown in the recipe, using ~/.local/bin/poetry
    explicitly. This is less than optimal, but it makes the relationship between the
    current working virtual environment and the poetry command more clear.
  prefs: []
  type: TYPE_NORMAL
- en: 16.6.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most common use cases for an environment and tool like Poetry is
    upgrading to the latest releases of packages. This is done with the poetry update
    command. A specific list of packages can be provided. With no parameters, all
    packages are examined.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This will look for the version of the pydantic package available in the various
    channels being searched and compare that version with what’s currently installed
    in the active virtual environment. This will also update the poetry.lock file
    after installing the updates.
  prefs: []
  type: TYPE_NORMAL
- en: To collaborate politely with tools like tox for testing, some additional options
    are required in the tox.ini file. One easy-to-use approach is to skip the default
    install procedure that tox uses and use poetry commands to run commands in a poetry-managed
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a suggestion of how to use poetry with tox:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Using poetry run means the command will be executed in the virtual environment.
    This makes it possible to use tox to define multiple environments, and rely on
    Poetry to assemble the various environments for testing purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 16.6.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See [https://python-poetry.org/docs](https://python-poetry.org/docs) for details
    on Poetry.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See [https://tox.wiki/en/4.15.1/](https://tox.wiki/en/4.15.1/) for details on
    Tox.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 16.7 Coping with changes in dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we noted in the [Installing packages with a requirements.txt file](ch020_split_000.xhtml#x1-8730002),
    all packages on which an application is built are in a constant state of flux.
    Each project has a distinct tempo for updates. To manage the constant change,
    it’s important for people developing applications to track dependencies carefully.
  prefs: []
  type: TYPE_NORMAL
- en: A common complaint about Python is sometimes summarized as dependency hell.
    This summarizes the work required to track and test with new dependencies, some
    of which may be in conflict. This work to manage change is essential; it’s the
    minimum required to maintain a viable product. Instead of adding features, it
    preserves functionality in a world of constant change.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two common cases where upgrades turn into more than simply installing
    and testing with upgraded packages:'
  prefs: []
  type: TYPE_NORMAL
- en: Changes that break our application in some way
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Incompatibilities among packages our application depends on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the first case, our software fails to work. In the second case, we can’t
    even build a virtual environment in which to test. This second case is often the
    most frustrating.
  prefs: []
  type: TYPE_NORMAL
- en: 16.7.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll consider a hypothetical project, the applepie application. This application
    has several dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: A single module from the apple project’s package, named apple.granny_smith
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some classes from the pie_filling project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Several classes from the pastry_crust project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An oven implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The general dependencies are named in the pyproject.toml file as a list of
    projects. We can imagine the detailed requirements.txt (or poetry.lock) file looks
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Using this framework for an application, we’ll look at what changes we need
    to make when we see changes in the dependencies. One change will remove needed
    functionality; the other change will be an incompatibility between releases of
    the pie_filling and pastry_crust projects. We’ll need to make appropriate changes
    in our application based on these changes occurring in the larger Python ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: 16.7.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll decompose this into two sub-recipes: one for a dependency that leads
    to a test failure, and the second for dependencies that are incompatible. We need
    to adjust our project so it continues to work in the presence of ongoing change.'
  prefs: []
  type: TYPE_NORMAL
- en: A change caused a test failure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To continue our example, the oven tool has had a significant change to the
    API. The new release, oven version 1.0, doesn’t have the same interface version
    0.9.1a had. The consequence is a failure in our code:'
  prefs: []
  type: TYPE_NORMAL
- en: Clarify what the failure is and what caused it. Ask ”why?” enough times to identify
    the root cause. There are several aspects of the failure that may need to be explored.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Be sure to understand the top layer of the problem: how the failure manifested
    itself. Ideally, a unit test failed. Another good avenue for detection is to use
    a tool like mypy or ruff to identify a potential for failure. Less helpful is
    an acceptance or system test that failed even though unit tests all passed. Perhaps
    the worst case is failure after deployment, in the hands of a customer.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Also, be sure to understand what changed. It’s common to introduce a number
    of version upgrades all at once. It may be necessary to reverse those changes
    and then upgrade each required package one at a time to identify the source of
    the failure.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Failures after a release often lead to problem reports in issue-tracking tools.
    Update any issue-tracking software with the root cause analysis.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Failures during testing should also lead to an internal report of a problem.
    The repair may require extensive rework, and it is generally helpful to track
    the reason for the rework.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Choose among the four kinds of fixes that are possible:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your code needs to be fixed. The change to oven version 1.0 is a clear improvement.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The change to oven introduced a bug, and you need to report the problem to the
    maintainers of oven or fix their code.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Revise the dependencies to pin oven version 0.9.1a in pyproject.toml to prevent
    upgrades.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Looking closely at the oven project, it may be clear it is no longer a good
    fit with this project, and it needs to be replaced.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: These are not exclusive choices. In some cases, multiple paths will be followed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There may be a pervasive change to our project required to accommodate the changes
    to oven 1.0\. This may be an opportunity to refactor our code to more carefully
    isolate this dependency to simplify making changes in the future.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When a project seems to have a bug, we have two choices: we can report the
    issue and hope it’s fixed, or we can clone the repository, make a fix, and submit
    a pull request to pull our changes into the next release. The benefit of open
    source is the reduced cost to begin a project. Ongoing maintenance, however, is
    an eternal feature of a landscape that thrives on innovation. While we benefit
    from other’s work in open source, we also need to contribute by proposing fixes.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In some cases, we will pin a specific version while we decide what to do about
    a dependency. We may pin an old version while choosing among alternatives and
    rewriting our project to replace the old oven with the new convection_cooker.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In effect, code that breaks due to an upgrade is a bug fix. It may be a bug
    fix for a project we require. More often, the fix is applied in our project to
    make use of a change in other projects. Managing changes to our application is
    the price we pay for innovation in the broad ecosystem of Python packages.
  prefs: []
  type: TYPE_NORMAL
- en: A changed dependency is incompatible with another dependency
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this case, the pastry_crust version 4.3 uses sugar version 2.0\. Sadly, the
    pie_filling version 3.1.4 uses the older sugar version 1.8.
  prefs: []
  type: TYPE_NORMAL
- en: Identify the root cause of the conflict, to the extent possible. Trying to discern
    why the pie_filling project team has not upgraded to sugar version 2.0 may be
    very difficult. A common observation is a lack of activity in the pie_filling
    project; but without knowing the principal contributors well, it’s difficult to
    ask why they aren’t making changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Be perfectly clear in identifying what changed. It’s common to introduce a number
    of version upgrades all at once. It may be necessary to reverse those changes
    and then upgrade each required package one at a time to identify the source of
    the failure. These conflicts are not in a direct dependency, but in an indirect
    dependency.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We value the idea of encapsulation and abstraction right up until we observe
    conflicting requirements that are encapsulated by a project. When these conflicts
    appear, the obscurity of encapsulation becomes a burden.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Document the conflict as an issue in issue-tracking software. Be sure to provide
    links to the conflicting projects and their issue trackers. The resolution may
    involve extended side-bar conversations with other projects to understand the
    nature of the conflicting requirements. It helps to keep notes on these conversations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Choose among the four kinds of fixes that are possible:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It’s unlikely any small change to your code will resolve the problem. The change
    required is replacing the pie_filling requirement with something else and making
    sweeping changes.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It’s possible that changes to the pie_filling project may correct the problem.
    This may involve a great deal of work on someone else’s project.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Revise the dependencies to pin pastry_crust version 4.2 in pyproject.toml to
    prevent upgrades.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Looking closely at the pie_filling project, it may be clear it is no longer
    a good fit for this project and needs to be replaced. This is a sweeping change
    to the project.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: These choices are not exclusive. In some cases, multiple paths will be followed.
    Perhaps the most popular choice is pinning the version that prevents the compatibility
    problem.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The rework to the pie_filling project can involve two activities: we can report
    the issue and hope they fix it, or we can clone their repository, make a fix,
    and submit a pull request to pull our changes into their next release. This kind
    of ongoing maintenance of open source software created by others is an eternal
    feature of a landscape that thrives on innovation.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Incompatibilities among the required supporting projects is an architectural
    problem. It’s rarely solved quickly. An important lesson learned from this kind
    of problem is that all architectural decisions need to be revocable: any choice
    needs to have an alternative, and the software needs to be written so that either
    alternative can be exercised.'
  prefs: []
  type: TYPE_NORMAL
- en: 16.7.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The essential step here is doing root cause analysis: asking ”why?” something
    fails to pass tests when upgrades are attempted.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, our applepie project’s dependencies may pin oven version 0.9.1a
    because version 1.0 introduced a failure. The pinned version may be appropriate
    for a few hours until the oven project fixes a bug, or it could remain in place
    for a much longer period of time. Our project may go through several releases
    before the problem with oven 1.0 is finally fixed by release 1.1.
  prefs: []
  type: TYPE_NORMAL
- en: It requires some discipline to review the requirements and make sure any pinned
    versions still need to be pinned.
  prefs: []
  type: TYPE_NORMAL
- en: 16.7.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One source of frustration with dependency hell is the lack of time budgeted
    for finding and fixing dependency problems. In an enterprise context, this is
    an acute problem because project sponsors and managers are often narrowly focused
    on budget and the time required to implement new features. Time to resolve dependency
    issues is rarely part of the budget because these problems are so difficult to
    anticipate.
  prefs: []
  type: TYPE_NORMAL
- en: A terrible situation can arise where fixing dependency problems is counted against
    a team’s velocity metric. This can happen when there are no ”story points” assigned
    to upgrading the dependencies and rerunning the test suite. In this case, the
    organization has created a perverse incentive to pin versions forever, without
    following the progress of other projects.
  prefs: []
  type: TYPE_NORMAL
- en: It’s imperative to have a periodic task to review each and every requirement.
    This task involves seeing what changes have been made and what may have been deprecated
    since the last review. This may lead to modifying project version constraints.
    For example, we may be able to relax the requirement from a strict oven==0.9.1a
    to a more lenient oven!=1.0.
  prefs: []
  type: TYPE_NORMAL
- en: A periodic task to review all requirements is an essential ingredient in managing
    change and innovation.
  prefs: []
  type: TYPE_NORMAL
- en: Look for updates as well as deprecations.
  prefs: []
  type: TYPE_NORMAL
- en: Allocate time to run tests with new versions and report the bugs discovered.
  prefs: []
  type: TYPE_NORMAL
- en: 16.7.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See [Using pip-tools to manage the requirements.txt file](ch020_split_000.xhtml#x1-8850004)
    for a very good dependency resolver.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See [Using Anaconda and the conda tool](ch020_split_001.xhtml#x1-8910005) for
    an approach to using the conda repository of curated, compatible software releases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '16.8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Join our community Discord space
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our Python Discord workspace to discuss and find out more about the book:
    [https://packt.link/dHrHU](https://packt.link/dHrHU)'
  prefs: []
  type: TYPE_NORMAL
- en: '![PIC](img/file1.png)'
  prefs: []
  type: TYPE_IMG
