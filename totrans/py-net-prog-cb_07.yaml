- en: Chapter 7. Programming Across Machine Boundaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Executing a remote shell command using telnet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copying a file to a remote machine by SFTP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Printing a remote machine's CPU information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing a Python package remotely
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running a MySQL command remotely
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transferring files to a remote machine over SSH
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring Apache remotely to host a website
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter promotes some interesting Python libraries. The recipes are presented
    aiming at the system administrators and advanced Python programmers who like to
    write code that connects to remote systems and executes commands. The chapter
    begins with lightweight recipes with a built-in Python library, `telnetlib`. It
    then brings `Paramiko`, a well-known remote access library. Finally, the powerful
    remote system administration library, `fabric`, is presented. The `fabric` library
    is loved by developers who regularly script for automatic deployments, for example,
    deploying web applications or building custom application binaries.
  prefs: []
  type: TYPE_NORMAL
- en: Executing a remote shell command using telnet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you need to connect an old network switch or router via telnet, you can do
    so from a Python script instead of using a bash script or an interactive shell.
    This recipe will create a simple telnet session. It will show you how to execute
    shell commands to the remote host.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You need to install the telnet server on your machine and ensure that it''s
    up and running. You can use a package manager that is specific to your operating
    system to install the telnet server package. For example, on Debian/Ubuntu, you
    can use `apt-get` or `aptitude` to install the `telnetd` package, as shown in
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us define a function that will take a user's login credentials from the
    command prompt and connect to a telnet server.
  prefs: []
  type: TYPE_NORMAL
- en: Upon successful connection, it will send the Unix `'ls'` command. Then, it will
    display the output of the command, for example, listing the contents of a directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 7.1 shows the code for a telnet session that executes a Unix command
    remotely as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run a telnet server on your local machine and run this code, it will
    ask you for your remote user account and password. The following output shows
    a telnet session executed on a Debian machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe relies on Python's built-in `telnetlib` networking library to create
    a telnet session. The `run_telnet_session()` function takes the username and password
    from the command prompt. The `getpass` module's `getpass()` function is used to
    get the password as this function won't let you see what is typed on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: In order to create a telnet session, you need to instantiate a `Telnet()` class,
    which takes a hostname parameter to initialize. In this case, `localhost` is used
    as the hostname. You can use the `argparse` module to pass a hostname to this
    script.
  prefs: []
  type: TYPE_NORMAL
- en: The telnet session's remote output can be captured with the `read_until()` method.
    In the first case, the login prompt is detected using this method. Then, the username
    with a new line feed is sent to the remote machine by the `write()` method (in
    this case, the same machine accessed as if it's remote). Similarly, the password
    was supplied to the remote host.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the `ls` command is sent to be executed. Finally, to disconnect from the
    remote host, the `exit` command is sent, and all session data received from the
    remote host is printed on screen using the `read_all()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Copying a file to a remote machine by SFTP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want to upload or copy a file from your local machine to a remote machine
    securely, you can do so via **Secure File Transfer Protocol** (**SFTP**).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe uses a powerful third-party networking library, `Paramiko`, to
    show you an example of file copying by SFTP, as shown in the following command.
    You can grab the latest code of `Paramiko` from GitHub ([https://github.com/paramiko/paramiko](https://github.com/paramiko/paramiko))
    or PyPI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe takes a few command-line inputs: the remote hostname, server port,
    source filename, and destination filename. For the sake of simplicity, we can
    use default or hard-coded values for these input parameters.'
  prefs: []
  type: TYPE_NORMAL
- en: In order to connect to the remote host, we need the username and password, which
    can be obtained from the user from the command line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 7.2 explains how to copy a file remotely by SFTP, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run this script, you will see an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe can take the various inputs for connecting to a remote machine and
    copying a file over SFTP.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe passes the command-line input to the `copy_file()` function. It
    then creates a SSH client calling the `SSHClient` class of `paramiko`. The client
    needs to load the system host keys. It then connects to the remote system, thus
    creating an instance of the `transport` class. The actual SFTP connection object,
    `sftp,` is created by calling the `SFTPClient.from_transport()` function of `paramiko`.
    This takes the `transport` instance as an input.
  prefs: []
  type: TYPE_NORMAL
- en: After the SFTP connection is ready, the local file is copied over this connection
    to the remote host using the `put()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, it's a good idea to clean up the SFTP connection and underlying objects
    by calling the `close()` method separately on each object.
  prefs: []
  type: TYPE_NORMAL
- en: Printing a remote machine's CPU information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, we need to run a simple command on a remote machine over SSH. For
    example, we need to query the remote machine's CPU or RAM information. This can
    be done from a Python script as shown in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You need to install the third-party package, `Paramiko`, as shown in the following
    command, from the source available from GitHub''s repository at [https://github.com/paramiko/paramiko](https://github.com/paramiko/paramiko):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can use the `paramiko` module to create a remote session to a Unix machine.
  prefs: []
  type: TYPE_NORMAL
- en: Then, from this session, we can read the remote machine's `/proc/cpuinfo` file
    to extract the CPU information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 7.3 gives the code for printing a remote machine''s CPU information,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this script will show the CPU information of a given host, in this
    case, the local machine, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we collect the connection parameters such as hostname, port, username,
    and password. These parameters are then passed to the `print_remote_cpu_info()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: This function creates an SSH client session by calling the `transport` class
    of `paramiko`. The connection is made thereafter using the supplied username and
    password. We can create a raw communication session using `open_channel()` on
    the SSH client. In order to execute a command on the remote host, `exec_command()`
    can be used.
  prefs: []
  type: TYPE_NORMAL
- en: After sending the command to the remote host, the response from the remote host
    can be caught by blocking the `recv_ready()` event of the session object. We can
    create two lists, `stdout_data` and `stderr_data`, and use them to store the remote
    output and error messages.
  prefs: []
  type: TYPE_NORMAL
- en: When the command exits in the remote machine, it can be detected using the `exit_status_ready()`
    method, and the remote session data can be concatenated using the `join()` string
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the session and client connection can be closed using the `close()`
    method on each object.
  prefs: []
  type: TYPE_NORMAL
- en: Installing a Python package remotely
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While dealing with the remote host in the previous recipes, you may have noticed
    that we need to do a lot of stuff related to the connection setup. For efficient
    execution, it is desirable that they become abstract and only the relevant high-level
    part is exposed to the programmers. It is cumbersome and slow to always explicitly
    set up connections to execute commands remotely.
  prefs: []
  type: TYPE_NORMAL
- en: Fabric ([http://fabfile.org/](http://fabfile.org/)), a third-party Python module,
    solves this problem. It only exposes as many APIs as can be used to efficiently
    interact with remote machines.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, a simple example of using Fabric will be shown.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need Fabric to be installed first. You can install Fabric using the Python
    packing tools, `pip` or `easy_install`, as shown in the following command. Fabric
    relies on the `paramiko` module, which will be installed automatically.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we will connect the remote host using the SSH protocol. So, it''s necessary
    to run the SSH server on the remote end. If you like to test with your local machine
    (pretending to access as a remote machine), you may install the `openssh` server
    package locally. On a Debian/Ubuntu machine, this can be done with the package
    manager, `apt-get`, as shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here's the code for installing a Python package using Fabric.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 7.4 gives the code for installing a Python package remotely as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Fabric scripts are run in a different way as compared to the normal Python scripts.
    All functions using the `fabric` library must be referred to a Python script called
    `fabfile.py`. There's no traditional `__main__` directive in this script. Instead,
    you can define your method using the Fabric APIs and execute these methods using
    the command-line tool, `fab`. So, instead of calling `python <script>.py`, you
    can run a Fabric script, which is defined in a `fabfile.py` script and located
    under the current directory, by calling `fab one_function_name another_function_name`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s create a `fabfile.py` script as shown in the following command.
    For the sake of simplicity, you can create a file shortcut or link from any file
    to a `fabfile.py` script. First, delete any previously created `fabfile.py` file
    and create a shortcut to `fabfile`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If you call the fabfile now, it will produce the following output after installing
    the Python package, `yolk`, remotely as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe demonstrates how a system administration task can be done remotely
    using a Python script. There are two functions present in this script. The `remote_server()`
    function sets up the Fabric `env` environment variables, for example, the hostname,
    user, password, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The other function, `install_package()`, calls the `run()` function. This takes
    the commands that you usually type in the command line. In this case, the command
    is `pip install yolk`. This installs the Python package, `yolk`, with `pip`. As
    compared to the previously described recipes, this method of running a remote
    command using Fabric is easier and more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: Running a MySQL command remotely
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you ever need to administer a MySQL server remotely, this recipe is for you.
    It will show you how to send database commands to a remote MySQL server from a
    Python script. If you need to set up a web application that relies on a backend
    database, this recipe can be used as a part of your web application setup process.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe also needs Fabric to be installed first. You can install Fabric
    using the Python packing tools, `pip` or `easy_install`, as shown in the following
    command. Fabric relies on the `paramiko` module, which will be installed automatically.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we will connect the remote host using the SSH protocol. So, it''s necessary
    to run the SSH server on the remote end. You also need to run a MySQL server on
    the remote host. On a Debian/Ubuntu machine, this can be done with the package
    manager, `apt-get`, as shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We defined the Fabric environment settings and a few functions for administering
    MySQL remotely. In these functions, instead of calling the `mysql` executable
    directly, we send the SQL commands to `mysql` via `echo`. This ensures that arguments
    are passed properly to the `mysql` executable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 7.5 gives the code for running MySQL commands remotely, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to run this script, you should create a shortcut, `fabfile.py`. From
    the command line, you can do this by typing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Then, you can call the `fab` executable in various forms.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command will show a list of databases (using the SQL query, `show
    databases`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The following command will create a new MySQL database. If you haven't defined
    the Fabric environment variable, `db_name`, a prompt will be shown to enter the
    target database name. This database will be created using the SQL command, `CREATE
    DATABASE <database_name> default character set utf8 collate utf8_unicode_ci;`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This Fabric command will show the size of a database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The following Fabric command will use the `mysqldump` and `mysql` executables
    to empty a database. This behavior of this function is similar to the truncating
    of a database, except it removes all the tables. The result is as if you created
    a fresh database without any tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This script defines a few functions that are used with Fabric. The first function,
    `remote_server()`, sets the environment variables. The local loopback IP (`127.0.0.1`)
    is put to the list of hosts. The local system user and MySQL login credentials
    are set and collected via `getpass()`.
  prefs: []
  type: TYPE_NORMAL
- en: The other function utilizes the Fabric `run()` function to send MySQL commands
    to the remote MySQL server by echoing the command to the `mysql` executable.
  prefs: []
  type: TYPE_NORMAL
- en: The `run_sql()` function is a generic function that can be used as a wrapper
    in other functions. For example, the `empty_db()` function calls it to execute
    the SQL commands. This can keep your code a bit more organized and cleaner.
  prefs: []
  type: TYPE_NORMAL
- en: Transferring files to a remote machine over SSH
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While automating a remote system administration task using Fabric, if you want
    to transfer files between your local machine and the remote machine with SSH,
    you can use the Fabric's built-in `get()` and `put()` functions. This recipe shows
    you how we can create custom functions to transfer files smartly by checking the
    disk space before and after the transfer.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe also needs Fabric to be installed first. You can install Fabric
    using Python packing tools, `pip` or `easy_install`, as shown in the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Here, we will connect the remote host using the SSH protocol. So, it's necessary
    to install and run the SSH server on the remote host.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us first set up the Fabric environment variables and then create two functions,
    one for downloading files and the other for uploading files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 7.6 gives the code for transferring files to a remote machine over
    SSH as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to run this script, you should create a shortcut, `fabfile.py`. From
    the command line, you can do this by typing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Then, you can call the `fab` executable in various forms.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, to log on to a remote server using your script, you can run the following
    Fabric function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give you a minimum shell-like environment. Then, you can download
    a file from a remote server to your local machine using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, to upload a file, you can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the local machine is used via SSH. So, you have to install
    the SSH server locally to run these scripts. Otherwise, you can modify the `remote_server()`
    function and point it to a remote server, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we used a few of Fabric's built-in functions to transfer files
    between local and remote machines. The `local()` function does an action on the
    local machine, whereas the remote actions are carried out by the `run()` function.
  prefs: []
  type: TYPE_NORMAL
- en: This is useful to check the available disk space on the target machine before
    uploading a file and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: This is achieved by using the Unix command, `df`. The source and destination
    file paths can be specified via the command prompt or can be hard coded in the
    source file in case of an unattended automatic execution.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Apache remotely to host a website
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fabric functions can be run as both regular and super users. If you need to
    host a website in a remote Apache web server, you need the administrative user
    privileges to create configuration files and restart the web server. This recipe
    introduces the Fabric `sudo()` function that runs commands in the remote machine
    as a superuser. Here, we would like to configure the Apache virtual host for running
    a website.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe needs Fabric to be installed first on your local machine. You can
    install Fabric using the Python packing tools, `pip` or `easy_install`, as shown
    in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we will connect the remote host using the SSH protocol. So, it''s necessary
    to install and run the SSH server on the remote host. It is also assumed that
    the Apache web server is installed and running on the remote server. On a Debian/Ubuntu
    machine, this can be done with the package manager, `apt-get`, as shown in the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we collect our Apache installation paths and some configuration parameters,
    such as web server user, group, virtual host configuration path, and initialization
    scripts. These parameters can be defined as constants.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we set up two functions, `remote_server()` and `setup_vhost()`, to execute
    the Apache configuration task using Fabric.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 7.7 gives the code for configuring Apache remotely to host a website
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to run this script, the following line should be appended on your
    host file, for example,. `/etc/hosts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'You should also create a shortcut, `fabfile.py`. From the command line, you
    can do this by typing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Then, you can call the `fab` executable in various forms.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, to log on to a remote server using your script, you can run the following
    Fabric function. This will result in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'After you run this recipe, you can open your browser and try to access the
    path you set up on the host file (for example, `/etc/hosts`). It should show the
    following output on your browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe sets up the initial Apache configuration parameters as constants
    and then defines two functions. In the `remote_server()` function, the usual Fabric
    environment parameters, for example, hosts, user, password, and so on, are placed.
  prefs: []
  type: TYPE_NORMAL
- en: The `setup_vhost()` function executes a series of privileged commands. First,
    it checks whether the website's document root path is already created using the
    `exists()` function. If it exists, it removes that path and creates it in the
    next step. Using `chown`, it ensures that the path is owned by the current user.
  prefs: []
  type: TYPE_NORMAL
- en: In the next step, it uploads a bare bone HTML file, `index.html`, to the document
    root path. After uploading the file, it reverts the permission of the files to
    the web server user.
  prefs: []
  type: TYPE_NORMAL
- en: After setting up the document root, the `setup_vhost()` function uploads the
    supplied `vhost.conf` file to the Apache site configuration path. Then, it sets
    its owner as the root user.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the script restarts the Apache service so that the configuration is
    activated. If the configuration is successful, you should see the sample output
    shown earlier when you open the URL, [http://abc.remote-server.org/](http://abc.remote-server.org/),
    in your browser.
  prefs: []
  type: TYPE_NORMAL
