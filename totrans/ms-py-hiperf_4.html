<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;Optimize Everything"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Optimize Everything</h1></div></div></div><p>The path to mastering performance in Python has just started. Profiling only takes us half way there. Measuring how our program is using the resources at its disposal only tells us where the problem is, not how to fix it. In the previous chapters, we saw some practical examples when going over the profilers. We did some optimization, but we never really explained a lot about it.</p><p>In this chapter, we will cover the process of optimization, and to do that, we need to start with the basics. We'll keep it inside the language for now: no external tools, just Python and the right way to use it.</p><p>We will cover the following topics in this chapter:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Memoization / lookup tables</li><li class="listitem" style="list-style-type: disc">Usage of default arguments</li><li class="listitem" style="list-style-type: disc">List comprehension</li><li class="listitem" style="list-style-type: disc">Generators</li><li class="listitem" style="list-style-type: disc">ctypes</li><li class="listitem" style="list-style-type: disc">String concatenation</li><li class="listitem" style="list-style-type: disc">Other tips and tricks of Python</li></ul></div><div class="section" title="Memoization / lookup tables"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec22"/>Memoization / lookup tables</h1></div></div></div><p>This is one of the <a id="id214" class="indexterm"/>most common techniques used to improve the performance of a piece of code (namely a function). We can save the results of expensive function calls associated with a specific set of input values and return the saved result (instead of redoing the whole computation) when the function is called with the remembered input. It might be confused with caching, since this is one type of memoization, although this term also refers to other types of optimization (such as HTTP caching, buffering, and so on).</p><p>This methodology is very powerful because in practice, it'll turn what should have been a potentially very expensive call into a <span class="emphasis"><em>O(1)</em></span> function call (for more information about this, refer to <a class="link" href="ch01.html" title="Chapter 1. Profiling 101">Chapter 1</a>, <span class="emphasis"><em>Profiling 101</em></span>) if the implementation is right. Normally, the parameters are used to create a unique key, which is then used on a dictionary to either save the result or obtain it if it's been already saved.</p><p>There is, of course, a trade-off to this technique. If we're going to remember the returned values of a memoized function, then we'll be exchanging memory space for speed. This is a very acceptable trade-off, unless the saved data becomes more than what the system can handle.</p><p>Classic use cases for this <a id="id215" class="indexterm"/>optimization are function calls that repeat the input parameters often. This will assure that most of the time, the memoized results are returned. If there are many function calls, but with different parameters, we'll only store results and spend our memory without any real benefit, as shown in the following image:</p><div class="mediaobject"><img src="graphics/B02088_04_01.jpg" alt="Memoization / lookup tables"/></div><p>You can clearly see how the blue bar (<span class="strong"><strong>Fixed params, memoized</strong></span>) is clearly the fastest use case, while the others are all similar due to their nature.</p><p>Here is the code that generates values for the preceding chart. To generate some sort of time-consuming function, the code will call either the <code class="literal">twoParams</code> function or the <code class="literal">twoParamsMemoized</code> function several hundred times under different conditions, and it will log the execution time:</p><div class="informalexample"><pre class="programlisting">import math

import time

import random

class Memoized:

  def __init__(self, fn):

    self.fn = fn

    self.results = {}

  def __call__(self, *args):

    key = ''.join(map(str, args[0]))

    try:

      return self.results[key]

    except KeyError:

      self.results[key] = self.fn(*args)

    return self.results[key]

@Memoized

def twoParamsMemoized(values, period):

  totalSum = 0

  for x in range(0, 100):

    for v in values:

      totalSum = math.pow((math.sqrt(v) * period), 4) + totalSum

  return totalSum

def twoParams(values, period):

  totalSum = 0

  for x in range(0, 100):

    for v in values:

      totalSum = math.pow((math.sqrt(v) * period), 4) + totalSum

  return totalSum

def performTest():

    valuesList = []

    for i in range(0, 10):

        valuesList.append(random.sample(xrange(1, 101), 10))

    start_time = time.clock()

    for x in range(0, 10):

      for values in valuesList:

          twoParamsMemoized(values, random.random())

    end_time = time.clock() - start_time

    print "Fixed params, memoized: %s" % (end_time)

    start_time = time.clock()

    for x in range(0, 10):

      for values in valuesList:

          twoParams(values, random.random())

    end_time = time.clock() - start_time

    print "Fixed params, without memoizing: %s" % (end_time)

    start_time = time.clock()

    for x in range(0, 10):

      for values in valuesList:

          twoParamsMemoized(random.sample(xrange(1,2000), 10), random.random())

    end_time = time.clock() - start_time

    print "Random params, memoized: %s" % (end_time)

    start_time = time.clock()

    for x in range(0, 10):

      for values in valuesList:

          twoParams(random.sample(xrange(1,2000), 10), random.random())

    end_time = time.clock() - start_time

    print "Random params, without memoizing: %s" % (end_time)

performTest()</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note11"/>Note</h3><p>The main insight to <a id="id216" class="indexterm"/>take from the preceding chart is that, just like with every aspect of programming, there is no silver bullet algorithm that will work for all cases. Memoization is clearly a very basic way of optimizing code, but clearly, it won't optimize anything given the right circumstances.</p></div></div><p>As for the code, there is not much to it. It is a very simple, non real-world example of the point I was trying to send across. The <code class="literal">performTest</code> function will take care of running a series of 10 tests for every use case and measure the total time each use case takes. Notice that we're not really using profilers at this point. We're just measuring time in a very basic and ad-hoc way, which works for us.</p><p>The input for both functions is simply a set of numbers on which they will run some math functions, just for the sake of doing something.</p><p>The other interesting bit about <a id="id217" class="indexterm"/>the arguments is that, since the first argument is a list of numbers, we can't just use the <code class="literal">args</code> parameter as a key inside the <code class="literal">Memoized</code> class' methods. This is why we have the following line:</p><div class="informalexample"><pre class="programlisting">key = ''.join(map(str, args[0]))</pre></div><p>This line will concatenate all the numbers from the first parameter into a single value, which will act as the key. The second parameter is not used here because it's always random, which would imply that the key will never be the same.</p><p>Another variation of the preceding method is to precalculate all values from the function during initialization (assuming we have a limited number of inputs, of course) initialization and then refer to the lookup table during execution. This approach has several preconditions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The number of input values must be finite; otherwise it's impossible to precalculate everything</li><li class="listitem" style="list-style-type: disc">The lookup table with all of its values, must fit into memory</li><li class="listitem" style="list-style-type: disc">Just like before, the input must be repeated, at least once, so the optimization both makes sense and is worth the extra effort</li></ul></div><p>There are different approaches when it comes to architecting the lookup table, all offering different types of optimizations. It all depends on the type of application and solution that you're trying to optimize. Here is a set of examples.</p><div class="section" title="Performing a lookup on a list or linked list"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec40"/>Performing a lookup on a list or linked list</h2></div></div></div><p>This solution <a id="id218" class="indexterm"/>works by iterating over an unsorted list and checking the key against <a id="id219" class="indexterm"/>each element, with the associated value as the result we're looking for.</p><p>This is obviously a very slow method of implementation, with a Big O notation of <span class="emphasis"><em>O(n)</em></span> for both the average and worst case scenarios. Still, given the right circumstances, it could prove to be faster than calling the actual function every time.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note12"/>Note</h3><p>In this case, using a <a id="id220" class="indexterm"/>linked list would improve the performance of the <a id="id221" class="indexterm"/>algorithm over using a simple list. However, it would still depend heavily on the type of linked list it is (doubly linked list, simple linked list with direct access to the first and last elements, and so on).</p></div></div></div><div class="section" title="Simple lookup on a dictionary"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec41"/>Simple lookup on a dictionary</h2></div></div></div><p>This method works <a id="id222" class="indexterm"/>using a one-dimensional dictionary lookup, indexed by a key consisting of the input parameters (enough of them create a unique key). In particular cases (like we covered earlier), this is probably one of the fastest lookups, even faster than binary search in some cases with a constant execution time (Big O notation of <span class="emphasis"><em>O(1)</em></span>).</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note13"/>Note</h3><p>Note that this approach is efficient as long as the key-generation algorithm is capable of generating unique keys every time. Otherwise, the performance could degrade over time due to the many collisions on the dictionaries.</p></div></div></div><div class="section" title="Binary search"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec42"/>Binary search</h2></div></div></div><p>This particular method <a id="id223" class="indexterm"/>is only possible if the list is sorted. This could potentially be an option depending on the values to sort. Yet sorting them would require extra effort that would hurt the performance of the entire effort. However, it presents very good results, even in long lists (average Big O notation of <span class="emphasis"><em>O(log n)</em></span>). It works by determining in which half of the list the value is and repeating until either the value is found or the algorithm is able to determine that the value is not in the list.</p><p>To put all of this into perspective, looking at the <code class="literal">Memoized</code> class mentioned earlier, it implements a simple lookup on a dictionary. However, this would be the place to implement either of the other algorithms.</p></div><div class="section" title="Use cases for lookup tables"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec43"/>Use cases for lookup tables</h2></div></div></div><p>There are some classic example use cases for this type of optimization, but the most common one is <a id="id224" class="indexterm"/>probably the optimization of trigonometric functions. Based on the computing time, these functions are really slow. When used repeatedly, they can cause some serious damage to your program's performance.</p><p>This is why it is normally recommended to precalculate the values of these functions. For functions that deal with an infinite domain universe of possible input values, this task becomes impossible. So, the developer is forced to sacrifice accuracy for performance by precalculating a discrete subdomain of the possible input values (that is, going from floating points down to integer numbers).</p><p>This approach might not be ideal in some cases, since some systems require both performance and accuracy. So, the solution is to meet in the middle and use some form of interpolation to calculate the required value, based on the ones that have been precalculated. It will provide better accuracy. Even though it won't be as performant as using the lookup table directly, it should prove to be faster than doing the trigonometric calculation every time.</p><p>Let's look at some examples of this; for instance, for the following trigonometric function:</p><div class="informalexample"><pre class="programlisting">def complexTrigFunction(x):
  return math.sin(x) * math.cos(x)**2</pre></div><p>We'll take a look at how simple precalculation won't be accurate enough and how some form of interpolation will result in a better level of accuracy.</p><p>The following code <a id="id225" class="indexterm"/>will precalculate the values for the function in a range from <code class="literal">-1000</code> to <code class="literal">1000</code> (only integer values). Then it'll try to do the same calculation (only for a smaller range) for floating point numbers:</p><div class="informalexample"><pre class="programlisting">import math
import time
from collections import defaultdict
import itertools

trig_lookup_table = defaultdict(lambda: 0) 


def drange(start, stop, step):
    assert(step != 0)
    sample_count = math.fabs((stop - start) / step)
    return itertools.islice(itertools.count(start, step), sample_count)


def complexTrigFunction(x):
  return math.sin(x) * math.cos(x)**2


def lookUpTrig(x):
  return trig_lookup_table[int(x)]


for x in range(-1000, 1000):
  trig_lookup_table[x] = complexTrigFunction(x)

trig_results = []
lookup_results = []

init_time = time.clock()
for x in drange(-100, 100, 0.1):
  trig_results.append(complexTrigFunction(x))
print "Trig results: %s" % (time.clock() - init_time)

init_time = time.clock()
for x in drange(-100, 100, 0.1):
  lookup_results.append(lookUpTrig(x))
print "Lookup results: %s" % (time.clock() - init_time)

for idx in range(0, 200):
  print "%s\t%s" % (trig_results [idx], lookup_results[idx])</pre></div><p>The results from the preceding code will help demonstrate how the simple lookup table approach is not accurate enough (see the following chart). However, it compensates for this with speed, as the <a id="id226" class="indexterm"/>original function takes 0.001526 seconds to run while the lookup table only takes 0.000717 seconds.</p><div class="mediaobject"><img src="graphics/B02088_04_02.jpg" alt="Use cases for lookup tables"/></div><p>The preceding chart shows how the lack of interpolation hurts the accuracy. You can see how, even though both plots are quite similar, the results from the lookup table execution aren't as accurate as the <a id="id227" class="indexterm"/>
<code class="literal">trig</code> function used directly. So, now, let's take another look at the same problem. However, this time, we'll add some basic interpolation (we'll limit the rage of values from <code class="literal">-PI</code> to <code class="literal">PI</code>):</p><div class="informalexample"><pre class="programlisting">import math
import time
from collections import defaultdict
import itertools

trig_lookup_table = defaultdict(lambda: 0) 

def drange(start, stop, step):
    assert(step != 0)
    sample_count = math.fabs((stop - start) / step)
    return itertools.islice(itertools.count(start, step), sample_count)

def complexTrigFunction(x):
  return math.sin(x) * math.cos(x)**2


reverse_indexes = {}
for x in range(-1000, 1000):
  trig_lookup_table[x] = complexTrigFunction(math.pi * x / 1000)


complex_results = []
lookup_results = []

init_time = time.clock()
for x in drange(-10, 10, 0.1):
  complex_results .append(complexTrigFunction(x))
print "Complex trig function: %s" % (time.clock() - init_time)

init_time = time.clock()
factor = 1000 / math.pi
for x in drange(-10 * factor, 10 * factor, 0.1 * factor):
  lookup_results.append(trig_lookup_table[int(x)])
print "Lookup results: %s" % (time.clock() - init_time)

for idx in range(0, len(lookup_results )):
  print "%s\t%s" % (complex_results [idx], lookup_results [idx])</pre></div><p>As you might've noticed in the previous chart, the resulting plot is periodic (especially because we've limited the range from <code class="literal">-PI</code> to <code class="literal">PI</code>). So, we'll focus on a particular range of values that will generate one single segment of the plot.</p><p>The output of the preceding script also shows that the interpolation solution is still faster than the original <a id="id228" class="indexterm"/>trigonometric function, although not as fast as it was earlier:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Interpolation solution</p>
</th><th style="text-align: left" valign="bottom">
<p>Original function</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>0.000118 seconds</p>
</td><td style="text-align: left" valign="top">
<p>0.000343 seconds</p>
</td></tr></tbody></table></div><p>The following chart is a bit different from the previous one, especially because it shows (in green) the error percentage between the interpolated value and the original one:</p><div class="mediaobject"><img src="graphics/B02088_04_03.jpg" alt="Use cases for lookup tables"/></div><p>The biggest error we have is around 12 percent (which represents the peaks we see on the chart). However, it's for the smallest values, such as -0.000852248551417 versus -0.000798905501416. This is a case where the error percentage needs to be contextualized to see if it really matters. In our case, since the values related to that error are so small, we can ignore that error in practice.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note14"/>Note</h3><p>There are other use cases for lookup tables, such as in image processing. However, for the <a id="id229" class="indexterm"/>sake of this book, the preceding example should be enough to demonstrate their benefits and the trade-off implied in their usage.</p></div></div></div></div></div>
<div class="section" title="Usage of default arguments"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec23"/>Usage of default arguments</h1></div></div></div><p>Another optimization <a id="id230" class="indexterm"/>technique, one that is contrary to memoization, is not particularly generic. Instead, it is directly tied to how the Python interpreter works.</p><p>Default arguments can be used to determine values once at function creation time, instead of at run time.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip03"/>Tip</h3><p>This can only be done for functions or objects that will not be changed during program execution.</p></div></div><p>Let's look at an example of how this optimization can be applied. The following code shows two versions of the same function, which does some random trigonometric calculation:</p><div class="informalexample"><pre class="programlisting">import math 

#original function
def degree_sin(deg):
    return math.sin(deg * math.pi / 180.0)

#optimized function, the factor variable is calculated during function creation time, 
#and so is the lookup of the math.sin method.
def degree_sin(deg, factor=math.pi/180.0, sin=math.sin):
    return sin(deg * factor)</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note15"/>Note</h3><p>This optimization can be problematic if not correctly documented. Since it uses attributes to precompute terms that should not change during the program's execution, it could lead to the creation of a confusing API.</p></div></div><p>With a quick and simple test, we can double-check the performance gain from this optimization:</p><div class="informalexample"><pre class="programlisting">import time
import math

def degree_sin(deg):
  return math.sin(deg * math.pi / 180.0) * math.cos(deg * math.pi / 180.0)


def degree_sin_opt(deg, factor=math.pi/180.0, sin=math.sin, cos = math.cos):
  return sin(deg * factor) * cos(deg * factor)


normal_times = []
optimized_times = []


for y in range(100):
  init = time.clock()
   for x in range(1000):
    degree_sin(x)
  normal_times.append(time.clock() - init)


  init = time.clock()
  for x in range(1000):
    degree_sin_opt(x)
  optimized_times.append(time.clock() - init)


print "Normal function: %s" % (reduce(lambda x, y: x + y, normal_times, 0) / 100)
print "Optimized function: %s" % (reduce(lambda x, y: x + y, optimized_times, 0 ) / 100)</pre></div><p>The preceding code <a id="id231" class="indexterm"/>measures the time it takes for the script to finish each of the versions of the function to run its code for a range of <code class="literal">1000</code>. It saves those measurements, and finally, it creates an average for each case. The result is displayed in the following chart:</p><div class="mediaobject"><img src="graphics/B02088_04_04.jpg" alt="Usage of default arguments"/></div><p>It clearly isn't an amazing <a id="id232" class="indexterm"/>optimization. However, it does shave off some microseconds from our execution time, so we'll keep it in mind. Just remember that this optimization could cause problems if you're working as part of an OS developer team.</p></div>
<div class="section" title="List comprehension and generators"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec24"/>List comprehension and generators</h1></div></div></div><p>List comprehension <a id="id233" class="indexterm"/>is a special construct provided by Python to generate <a id="id234" class="indexterm"/>lists by writing in the way a mathematician would, by describing its content instead of writing about the way the content should be generated (with a classic <code class="literal">for</code> loop).</p><p>Let's see an example of this to better understand how it works:</p><div class="informalexample"><pre class="programlisting">#using list comprehension to generate a list of the first 50 multiples of 2
multiples_of_two = [x for x in range(100) if x % 2 == 0]

#now let's see the same list, generated using a for-loop
multiples_of_two = []
for x in range(100):
  if x % 2 == 0:
    multiples_of_two.append(x)</pre></div><p>Now, list comprehension is not meant to replace <code class="literal">for</code> loops altogether. They are a great help when dealing with loops that, like the earlier one, are creating a list. However, they aren't particularly recommended for those <code class="literal">for</code> loops that you write because of their side effects. This means you're not creating a list. You're most likely calling a function inside it or doing some other calculation that does not translate into a list. For these cases, a list comprehension expression would actually hurt readability.</p><p>To understand why these expressions are more performant than regular <code class="literal">for</code> loops, we need to do some disassembling and read a bit of bytecode. We can do this because, even though Python is an interpreted language, it is still being translated into bytecode by the compiler. This bytecode is the one that is interpreted. So, using the <code class="literal">dis</code> module, we can turn that bytecode into <a id="id235" class="indexterm"/>something that humans can read, and analyze its execution.</p><p>Let's look at the code then:</p><div class="informalexample"><pre class="programlisting">import dis
import timeit

programs = dict(
    loop="""
multiples_of_two = []
for x in range(100):
  if x % 2 == 0:
    multiples_of_two.append(x)
""",
    comprehension='multiples_of_two = [x for x in range(100) if x % 2 == 0]',
)

for name, text in programs.iteritems():
    print name, timeit.Timer(stmt=text).timeit()
    code = compile(text, '&lt;string&gt;', 'exec')
    dis.disassemble(code)</pre></div><p>That code will <a id="id236" class="indexterm"/>output two things:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The time each piece of code takes to run</li><li class="listitem" style="list-style-type: disc">The set of instructions generated by the interpreter, thanks to the <code class="literal">dis</code> module</li></ul></div><p>Here is a screenshot of how that output would look (in your system, the time might change, but the rest should be pretty similar):</p><div class="mediaobject"><img src="graphics/B02088_04_05.jpg" alt="List comprehension and generators"/></div><p>First things first; the output proves that the list comprehension version of the code is, indeed, faster. Now, let's <a id="id237" class="indexterm"/>take a closer look at both lists of instructions, side by side, to try to understand them better:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>The for loop instructions</p>
</th><th style="text-align: left" valign="bottom">
<p>Comments</p>
</th><th style="text-align: left" valign="bottom">
<p>The list comprehension instructions</p>
</th><th style="text-align: left" valign="bottom">
<p>Comments</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">BUILD_LIST</code>
</p>
</td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>
<code class="literal">BUILD_LIST</code>
</p>
</td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">STORE_NAME</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The definition of our "multiples_of_two" list</p>
</td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SETUP_LOOP</code>
</p>
</td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">LOAD_NAME</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Range function</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">LOAD_NAME</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Range function</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">LOAD_CONST</code>
</p>
</td><td style="text-align: left" valign="top">
<p>100 (the attribute for the range)</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">LOAD_CONST</code>
</p>
</td><td style="text-align: left" valign="top">
<p>100 (the attribute for the range)</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">CALL_FUNCTION</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Calls range</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">CALL_FUNCTION</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Calls range</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">GET_ITER</code>
</p>
</td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>
<code class="literal">GET_ITER</code>
</p>
</td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">FOR_ITER</code>
</p>
</td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>
<code class="literal">FOR_ITER</code>
</p>
</td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">STORE_NAME</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Our temp variable x</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">STORE_NAME</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Our temp variable <code class="literal">x</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">LOAD_NAME</code>
</p>
</td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>
<code class="literal">LOAD_NAME</code>
</p>
</td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">LOAD_CONST</code>
</p>
</td><td rowspan="4" style="text-align: left" valign="top">
<p>
<span class="emphasis"><em>X % 2 == 0</em></span>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">LOAD_CONST</code>
</p>
</td><td rowspan="4" style="text-align: left" valign="top">
<p>
<span class="emphasis"><em>X % 2 == 0</em></span>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">BINARY_MODULO</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">BINARY_MODULO</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">LOAD_CONST</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">LOAD_CONST</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">COMPARE_OP</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">COMPARE_OP</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">POP_JUMP_IF_FALSE</code>
</p>
</td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>
<code class="literal">POP_JUMP_IF_FALSE</code>
</p>
</td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">LOAD_NAME</code>
</p>
</td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>
<code class="literal">LOAD_NAME</code>
</p>
</td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">LOAD_ATTR</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Lookup for the append method</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">LIST_APPEND</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Appends the value to the list</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">LOAD_NAME</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Loads the value of <span class="emphasis"><em>X</em></span>
</p>
</td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">CALL_FUNCTION</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Appends the actual value to the list</p>
</td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">POP_TOP</code>
</p>
</td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">JUMP_ABSOLUTE</code>
</p>
</td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>
<code class="literal">JUMP_ABSOLUTE</code>
</p>
</td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">JUMP_ABSOLUTE</code>
</p>
</td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>
<code class="literal">STORE_NAME</code>
</p>
</td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">POP_BLOCK</code>
</p>
</td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>
<code class="literal">LOAD_CONST</code>
</p>
</td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">LOAD_CONST</code>
</p>
</td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>
<code class="literal">RETURN_VALUE</code>
</p>
</td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">RETURN_VALUE</code>
</p>
</td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td></tr></tbody></table></div><p>From the preceding table, you can see how the <code class="literal">for</code> loop generates a longer list of instructions. The instructions generated by the comprehension code almost looks like a subset of the ones generated <a id="id238" class="indexterm"/>by the <code class="literal">for</code> loop, with the major difference of how the values are added. For the <code class="literal">for</code> loop, they are added one by one, using three instructions (<code class="literal">LOAD_ATTR</code>, <code class="literal">LOAD_NAME</code>, and <code class="literal">CALL_FUNCTION</code>). On the other hand, for the list <a id="id239" class="indexterm"/>comprehension column, this is done with one single, optimized instruction (<code class="literal">LIST_APPEND</code>).</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip04"/>Tip</h3><p>This is the reason why when generating a list, the <code class="literal">for</code> loop should not be your weapon of choice. This is because the list comprehension you're writing is more efficient and sometimes, even writes more readable code.</p></div></div><p>That being said, remember to not abuse these expressions by replacing every <code class="literal">for</code> loop, even the ones that do other things (side effects). In these cases, list comprehension expressions are not optimized and will take longer than a regular <code class="literal">for</code> loop.</p><p>Finally, there is one more related consideration to take into account: when generating big lists, comprehension expressions might not be the best solution. This is because they still need to generate every single value. So, if you're generating a list of 100k items, there is a better way. You can use generator expressions. Instead of returning a list, they return a generator object, which has a similar API to what lists have. However, every time you request a new item, that item will be dynamically generated.</p><p>The main difference between a generator object and a list object is that the first one doesn't support random access. So, you can't really use the brackets notation for anything. However, you can use the generator object to iterate over your list:</p><div class="informalexample"><pre class="programlisting">my_list = (x**2 for x in range(100))
#you can't do this
print my_list[1]

#but you can do this
for number in my_list:
  print number</pre></div><p>Another key difference between lists and generator objects is that you can only iterate once over the latter, while you can do the same as many times as you like over a list. This is a key difference because it will limit the usage of your efficiently generated list. So, take it into account when deciding to go with a list comprehension expression or a generator expression.</p><p>This approach might <a id="id240" class="indexterm"/>add a little overhead when accessing the values, but it'll be faster when creating the list. Here is a comparison of both list comprehension and generator expressions when creating lists of different lengths:</p><div class="mediaobject"><img src="graphics/B02088_04_06.jpg" alt="List comprehension and generators"/></div><p>The chart clearly shows that the performance of the generator expressions is better than the list comprehension <a id="id241" class="indexterm"/>expressions for lengthier lists. For smaller lists, the list comprehension ones are better.</p></div>
<div class="section" title="ctypes"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec25"/>ctypes</h1></div></div></div><p>The ctypes <a id="id242" class="indexterm"/>library allows the developer to reach under the hood of Python and tap into the power of the C language. This is only possible with the official interpreter (CPython) because it is written in C. Other versions of it, such as PyPy or Jython, do not provide access to this library.</p><p>This interface to C can be used to do many things, since you literally have the ability to load pre-compiled code and use it from C. This means you have access to libraries such as <code class="literal">kernel32.dll</code> and <code class="literal">msvcrt.dll</code> for Windows systems, and <code class="literal">libc.so.6</code> for Linux systems.</p><p>For our particular case, we'll focus on ways to optimize our code, showing how to load a custom C library <a id="id243" class="indexterm"/>and how to load a system library to take advantage of its optimized code. For full details on how to use this library, refer to the official documentation at <a class="ulink" href="https://docs.python.org/2/library/ctypes.html">https://docs.python.org/2/library/ctypes.html</a>.</p><div class="section" title="Loading your own custom C library"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec44"/>Loading your own custom C library</h2></div></div></div><p>Sometimes, no <a id="id244" class="indexterm"/>matter how many optimization techniques we use on our code, they won't be enough to help us achieve the best possible time. In these cases, we can always write the sensitive code outside our program, in C, compile it into a library, and import it into our Python code.</p><p>Let's look at an example of how we can do this and what type of performance boost we are expecting.</p><p>The problem to solve is a very simple one, something really basic. We'll write the code to generate a list of prime numbers, from a list of 1 million integers.</p><p>The Python code for that could be as follows:</p><div class="informalexample"><pre class="programlisting">import math
import time


def check_prime(x):
  values = xrange(2, int(math.sqrt(x)))
  for i in values:
    if x % i == 0:
      return False 

  return True


init = time.clock()
numbers_py = [x for x in xrange(1000000) if check_prime(x)]
print "%s" % (time.clock() - init)</pre></div><p>The preceding code is simple enough. Yes, we could easily improve it by changing the list comprehension expression for a generator. However, for the sake of showing the improvement from the C code, let's not do that. Now, the C code is taking 4.5 seconds on average to run.</p><p>Let's now write the <code class="literal">check_prime</code> function in C, and let's export it into a shared library (<code class="literal">.so</code> file):</p><div class="informalexample"><pre class="programlisting">#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
 
int check_prime(int a)
{
  int c;
  for ( c = 2 ; c &lt;= sqrt(a) ; c++ ) { 
    if ( a%c == 0 )
     return 0;
  }

  return 1;

}</pre></div><p>To generate the library file, use the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$gcc -shared -o check_primes.so -fPIC check_primes.c </strong></span>
</pre></div><p>Then, we can edit <a id="id245" class="indexterm"/>our Python script to run both versions of the function and compare the times, like this:</p><div class="informalexample"><pre class="programlisting">import time
import ctypes
import math

check_primes_types = ctypes.CDLL('./check_prime.so').check_prime

def check_prime(x):
  values = xrange(2, int(math.sqrt(x)))
  for i in values:
    if x % i == 0:
      return False 

  return True


init = time.clock()
numbers_py = [x for x in xrange(1000000) if check_prime(x)]
print "Full python version: %s seconds" % (time.clock() - init)

init = time.clock()
numbers_c = [x for x in xrange(1000000) if check_primes_types(x)]
print "C version: %s seconds" % (time.clock() - init)
print len(numbers_py)</pre></div><p>The preceding code gives the following output:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Full Python version</p>
</th><th style="text-align: left" valign="bottom">
<p>C version</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>4.49 seconds</p>
</td><td style="text-align: left" valign="top">
<p>1.04 seconds</p>
</td></tr></tbody></table></div><p>The performance <a id="id246" class="indexterm"/>boost is pretty good. It has gone from 4.5 seconds down to just 1 second!</p></div><div class="section" title="Loading a system library"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec45"/>Loading a system library</h2></div></div></div><p>At times, there <a id="id247" class="indexterm"/>is no need to code your C function. The system's libraries probably have it for you already. All you have to do is import that library and use the function.</p><p>Let's see another simple example to demonstrate the concept.</p><p>The following line generates a list of 1 million random numbers, taking 0.9 seconds:</p><div class="informalexample"><pre class="programlisting">randoms = [random.randrange(1, 100) for x in xrange(1000000)]While this one, takes only 0.3 seconds:
randoms = [(libc.rand() % 100) for x in xrange(1000000)]</pre></div><p>Here is the full code that runs both lines and prints out the times:</p><div class="informalexample"><pre class="programlisting">import time
import random
from ctypes import cdll


libc = cdll.LoadLibrary('libc.so.6') #linux systems
#libc = cdll.msvcrt #windows systems

init = time.clock()
randoms = [random.randrange(1, 100) for x in xrange(1000000)]
print "Pure python: %s seconds" % (time.clock() - init)

init = time.clock()
randoms = [(libc.rand() % 100) for x in xrange(1000000)]
print "C version : %s seconds" % (time.clock() - init)</pre></div></div></div>
<div class="section" title="String concatenation"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec26"/>String concatenation</h1></div></div></div><p>Python strings <a id="id248" class="indexterm"/>deserve a separate portion of this chapter because they're not like strings in other languages. In Python, strings are immutable, which means that once you create one you can't really change its value.</p><p>This is a relatively confusing affirmation, since we're used to doing things such as concatenation or replacement on string variables. However, what the average Python developer doesn't realize is that there is a lot more going on behind the curtains than they think.</p><p>Since string objects are immutable, every time we do anything to change its content, we're actually creating a whole new string with new content and pointing our variable to that new string. So, we must be careful when working with strings to make sure we actually want to do that.</p><p>There is a very simple way to check the preceding scenario. The following code will create a set of variables <a id="id249" class="indexterm"/>with the same string (we'll write the string every time). Then, using the <code class="literal">id</code> function (which, in CPython, returns the memory address where the value the variable points to is stored), we'll compare them to each other. If strings were mutable, then all objects would be different, and thus, the returned values should be different. Let's look at the code:</p><div class="informalexample"><pre class="programlisting">a = "This is a string"
b = "This is a string"

print id(a) == id(b)  #prints  True

print id(a) == id("This is a string") #prints True

print id(b) == id("This is another String") #prints False</pre></div><p>As the comments on the code state, the output will be <code class="literal">True</code>, <code class="literal">True</code>, and <code class="literal">False</code>, thus showing how the system is actually reusing the <code class="literal">This is a string</code> string every time we write it.</p><p>The following image tries to represent the same idea in a more graphical way:</p><div class="mediaobject"><img src="graphics/B02088_04_07.jpg" alt="String concatenation"/></div><p>Although we wrote the string twice, internally, both variables are referencing the same block of memory (containing the actual string). If we assign another value to one of them, we would not be changing the string content. We would just be pointing our variable to another memory address.</p><div class="mediaobject"><img src="graphics/B02088_04_08.jpg" alt="String concatenation"/></div><p>The same thing happens in the preceding case, where we have a variable <code class="literal">b</code> pointing directly to variable <code class="literal">a</code>. Still, if we try to modify <code class="literal">b</code>, we would just be creating a new string once again.</p><div class="mediaobject"><img src="graphics/B02088_04_09.jpg" alt="String concatenation"/></div><p>Finally, what happens if <a id="id250" class="indexterm"/>we change the value of both our variables from our example? What happens to the <code class="literal">hello world</code> string stored in memory? Well, if there are no other references to it, the <span class="strong"><strong>Garbage Collector</strong></span> will eventually take care of it, releasing that memory.</p><p>That being said, immutable objects are not all that bad. They are actually good for performance if used right, since they can be used as dictionary keys, for instance, or even shared between different variable bindings (since the same block of memory is used every time you reference the same string). This means that the string <code class="literal">hey there</code> will be the same exact object every time you use that string, no matter what variable it is stored in (like we saw earlier).</p><p>With this in mind, think about what would happen for some common cases, such as the following one:</p><div class="informalexample"><pre class="programlisting">full_doc = ""
for word in word_list:
  full_doc += word</pre></div><p>The preceding code will generate a new string for <code class="literal">full_doc</code> for every item in the <code class="literal">word_list</code> list. This is not really efficient memory usage, is it? This is a very common case when we're trying to recreate a string from different parts. There is a better, more memory efficient way of doing it:</p><div class="informalexample"><pre class="programlisting">full_doc = "".join(world_list)</pre></div><p>The alternative is easier to <a id="id251" class="indexterm"/>read, faster to write, and more efficient, both memory and time wise. The following code shows the time each option takes. With the right command, we can also see that the <code class="literal">for</code> loop alternative uses a bit more memory:</p><div class="informalexample"><pre class="programlisting">import time
import sys

option = sys.argv[1]

words =  [str(x) for x in xrange(1000000)]

if option == '1':
  full_doc = ""
  init = time.clock()
  for w in words:
    full_doc += w
  print "Time using for-loop: %s seconds" % (time.clock() - init)
else:
  init = time.clock()
  full_doc = "".join(words)
  print "Time using join: %s seconds" % (time.clock() - init)</pre></div><p>With the following commands we can execute the script and measure the memory used, using the Linux utility <code class="literal">time</code>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">#for the for-loop version:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ /usr/bin/time -f "Memory: %M bytes" python script.py 1 </strong></span>
</pre></div></li><li class="listitem" style="list-style-type: disc">#for the join version:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ /usr/bin/time -f "Memory: %M bytes" python script.py 0 </strong></span>
</pre></div></li></ul></div><p>The output from the for-loop version command is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Time using for-loop: 0.155635 seconds</strong></span>
<span class="strong"><strong>Memory: 66212 bytes</strong></span>
</pre></div><p>The output from the join version command is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Time using join: 0.015284 seconds</strong></span>
<span class="strong"><strong>Memory: 66092 bytes</strong></span>
</pre></div><p>The join version clearly takes considerably less time, and the peak memory consumption (measured by the time command) is also less.</p><p>The other use case we want to consider when working with strings in Python is a different type of concatenation; it is used when you're only dealing with a few variables, such as the following one:</p><div class="informalexample"><pre class="programlisting">document = title + introduction + main_piece + conclusion</pre></div><p>You'll end up creating a set of substrings every time the system computes a new concatenation. So a better and more efficient way of doing this is using variable interpolation:</p><div class="informalexample"><pre class="programlisting">document = "%s%s%s%s" % (title, introduction, main_piece, conclusion)</pre></div><p>Alternatively, it is even <a id="id252" class="indexterm"/>better to create substrings using the <code class="literal">locals</code> function:</p><div class="informalexample"><pre class="programlisting">document = "%(title)s%(introduction)s%(main_piece)s%(conclusion)s" % locals()</pre></div></div>
<div class="section" title="Other tips and tricks"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec27"/>Other tips and tricks</h1></div></div></div><p>The tips mentioned <a id="id253" class="indexterm"/>earlier are some of the most common techniques to <a id="id254" class="indexterm"/>optimize a program. Some of them are Python specific (such as string concatenation or using ctypes) and others are more generic (such as memoization and lookup tables).</p><p>There are still a few more minor tips and tricks specific to Python, which we will cover here. They might not yield a significant boost of speed, but they will shed some more light into the inner workings of the language:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Membership testing</strong></span>: When trying to figure out if a value is inside a list (we use the word "list" generically here, not specifically referencing the type <code class="literal">list</code>), something such as "a in b", we would have better results using sets and dictionaries (with a lookup time of <span class="emphasis"><em>O(1)</em></span>) than lists or tuples.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Don't reinvent the wheel</strong></span>: Python comes with built-in core blocks that are written in optimized C. There is no need to use hand-built alternatives, since the latter will most likely be slower. Datatypes such as <code class="literal">lists</code>, <code class="literal">tuples</code>, <code class="literal">sets</code>, and <code class="literal">dictionaries</code>, and modules such as <code class="literal">array</code>, <code class="literal">itertools</code>, and <code class="literal">collections.deque</code> are recommended. Built-in functions also apply here. They'll always be faster to do something such as <code class="literal">map(operator.add, list1, list2)</code> will always be faster than <code class="literal">map(lambda x, y: x+y, list1, list2)</code>.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Don't forget about deque</strong></span>: When needing a fixed length array or a variable length stack, lists perform well. However, when dealing with the <code class="literal">pop(0)</code> or <code class="literal">insert(0, your_list)</code> operation, try to use <code class="literal">collections.deque</code>, since it offers fast (<span class="emphasis"><em>O(1)</em></span>) appends and pops up on either end of the list.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Sometimes is better not to def</strong></span>: Calling a function adds a lot of overhead (as we already saw earlier). So, sometimes, in time-critical loops especially, inlining the code of a <a id="id255" class="indexterm"/>function, instead of calling that function, will be <a id="id256" class="indexterm"/>more performant. There is a big trade-off with this tip, since it could also considerably hurt things such as readability and maintainability. So this should only be done if, in fact, the boost on performance is absolutely required. The following simple example shows how a simple lookup operation ends up adding a considerable amount of time:<div class="informalexample"><pre class="programlisting">import time
def fn(nmbr):
   return (nmbr ** nmbr) / (nmbr + 1)
nmbr = 0
init = time.clock()
for i in range(1000):
   fn(i)
print "Total time: %s" % (time.clock() - init)

init = time.clock()
nmbr = 0
for i in range(1000):
  nmbr = (nmbr ** nmbr) / (nmbr + 1)
print "Total time (inline): %s" % (time.clock() - init)</pre></div></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>When possible, sort by the key</strong></span>: When doing a custom sort on a list, try not to sort using a comparison function. Instead, when possible, sort by the key. This is because the key function will be called only once per item, whereas the comparison function will be called several times per item during the process. Let's see a quick example comparing both methods:<div class="informalexample"><pre class="programlisting">import random
import time


#Generate 2 random lists of random elements
list1 = [ [random.randrange(0, 100), chr(random.randrange(32, 122))] for x in range(100000)]
list2 = [ [random.randrange(0, 100), chr(random.randrange(32, 122))] for x in range(100000)]

#sort by string, using a comparison function
init = time.clock()
<span class="strong"><strong>list1.sort(cmp=lambda a,b: cmp(a[1], b[1]))</strong></span>
print "Sort by comp: %s" % (time.clock() - init) <span class="strong"><strong>#prints  0.213434</strong></span>

#sort by key, using the string element as key
init = time.clock()
<span class="strong"><strong>list2.sort(key=lambda a: a[1])</strong></span>
print "Sort by key: %s" % (time.clock() - init) <span class="strong"><strong>#prints 0.047623</strong></span>
</pre></div></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>1 is better than True</strong></span>: Python 2.3 <code class="literal">while 1</code> gets optimized into a single jump, while <code class="literal">while True</code> does not, thus taking several jumps to complete. This implies that <a id="id257" class="indexterm"/>writing <code class="literal">while 1</code> is more efficient than <code class="literal">while True</code>, although just like inlining the code, this tip comes with a big trade-off.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Multiple assignments are slow but...</strong></span>: Multiple assignments (<code class="literal">a,b = "hello there", 123</code>) are generally slower than single assignments. However, again, when doing variable swaps, it becomes faster than doing it the regular way (because we skip the usage and assignment of the temporal variable):<div class="informalexample"><pre class="programlisting">a = "hello world"
b = 123
#this is faster
<span class="strong"><strong>a,b = b, a</strong></span>
#than doing
tmp  = a
<span class="strong"><strong>a = b</strong></span>
<span class="strong"><strong>b = tmp</strong></span>
</pre></div></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Chained comparisons are good</strong></span>: When comparing three variables with each other, instead of <a id="id258" class="indexterm"/>doing <span class="emphasis"><em>x &lt; y</em></span> and <span class="emphasis"><em>y &lt; z</em></span>, you can use <span class="emphasis"><em>x &lt; y &lt; z</em></span>. This should prove easier to read (more natural) and faster to run.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Using namedtuples instead of regular objects</strong></span>: When creating simple objects to store data, using the regular class notation, the instances contain a dictionary for attribute storage. This storage can become wasteful for objects with few attributes. If you need to create a large number of those objects, then that waste of <a id="id259" class="indexterm"/>memory adds up. For such cases, you can use <code class="literal">namedtuples</code>. This is a new <code class="literal">tuple</code> subclass, which can be easily constructed <a id="id260" class="indexterm"/>and is optimized for the task. For details on <a id="id261" class="indexterm"/><code class="literal">namedtuples</code>, check the official documentation at <a class="ulink" href="https://docs.python.org/2/library/collections.html#collections.namedtuple">https://docs.python.org/2/library/collections.html#collections.namedtuple</a>. The following code creates 1 million objects, both using regular classes and <code class="literal">namedtuples</code>, and displays the time for each action:<div class="informalexample"><pre class="programlisting">import time
import collections

class Obj(object):
  def __init__(self, i):
    self.i = i
    self.l = []
all = {}

init = time.clock()
for i in range(1000000):
  all[i] = Obj(i)
print "Regular Objects: %s" % (time.clock() - init) <span class="strong"><strong>#prints Regular Objects: 2.384832</strong></span>


Obj = collections.namedtuple('Obj', 'i l')

all = {}
init = time.clock()
for i in range(1000000):
  all[i] = Obj(i, [])
print "NamedTuples Objects: %s" % (time.clock() - init) <span class="strong"><strong>#prints  NamedTuples Objects: 1.272023</strong></span>
</pre></div></li></ul></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec28"/>Summary</h1></div></div></div><p>In this chapter, we covered several optimization techniques. Some of them are meant to provide big boosts on speed, and/or save memory. Some of them are just meant to provide minor speed improvements. Most of this chapter covered Python-specific techniques, but some of them can be translated into other languages as well.</p><p>In the next chapter, we will go over optimization techniques. In particular, we'll cover multi-threading and multiprocessing, and you'll learn when to apply each one.</p></div></body></html>