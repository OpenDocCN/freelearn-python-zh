- en: Chapter 8. Displaying Information and Performing Actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will work with a variety of breakout boards and an actuator
    to display data and perform actions by writing a Python code. We shall:'
  prefs: []
  type: TYPE_NORMAL
- en: Understand LCD displays and their connection types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn the most important things we must consider when choosing LCD displays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Take advantage of the `upm` library with LCD displays and actuators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use an LCD display with an RGB backlight that works with the I²C bus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Display and update text in a 16x2 LCD screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use an OLED display that works with the I²C bus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Display and update text on a 96-by-96 dot matrix OLED display
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wire a standard servo motor to be controlled with PWM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Display a value with a servo motor and a shaft
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding LCD displays and their connection types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, our IoT device has to provide information to the user with any device
    connected to an Intel Galileo Gen 2 board. We can use different kinds of electronic
    components, shields, or breakout boards to achieve this goal.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we can use simple LEDs to provide information that we can represent
    with colors. For example, a red LED that turns on can indicate that our temperature
    sensor connected to the board has detected that the ambient temperature is higher
    than 80 degrees Fahrenheit (ºF) or 26.66 degrees Celsius (ºC). A blue LED that
    turns on can indicate that our temperature sensor had detected that the ambient
    temperature is lower than 40 degrees Fahrenheit (ºF) or 4.44 degrees Celsius (ºC).
    A red LED turned on can indicate that the temperature is between these two values.
    These three LEDs allow us to provide valuable information to the user.
  prefs: []
  type: TYPE_NORMAL
- en: We can also achieve the same goal using a single RGB LED and work with **pulse
    width modulation** (**PWM**) to change its color based on the measured ambient
    temperature value, as we learned in [Chapter 4](ch04.html "Chapter 4. Working
    with a RESTful API and Pulse Width Modulation"), *Working with a RESTful API and
    Pulse Width Modulation*.
  prefs: []
  type: TYPE_NORMAL
- en: However, sometimes colors aren't enough to provide a detailed and accurate information
    to the user. For example, sometimes we want to display the humidity level with
    a percentage value and a few LEDs aren't enough to represent numbers from 0 to
    100%. If we want to be able to display a 1% step, we would require 100 LEDs. We
    don't have 100 GPIO pins, and therefore, we would require a shield or breakout
    board with 100 LEDs and a digital interface such as an I²C bus to allow us to
    send commands indicating the number of LEDs that we want to be turned on.
  prefs: []
  type: TYPE_NORMAL
- en: In these cases, an LCD screen that allows us to print a specific number of characters
    might be an appropriate solution. For example, on an LCD screen that allows us
    to display 16 characters per line, with 2 lines of 16 characters, known as a 16x2
    LCD module, we can display the temperature in the first line and the humidity
    level in the second line. The following table shows an example of each line with
    the text and the values considering that we have 16 columns and 2 rows for the
    characters.
  prefs: []
  type: TYPE_NORMAL
- en: '| T | e | m | p | . |   |   |   |   | 4 | 0 | . | 2 | F |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| H | u | m | i | d | i | t | y |   |   |   | 8 | 0 | % |   |   |'
  prefs: []
  type: TYPE_TB
- en: 'The 16x2 LCD module provides a clear description for each value, a floating
    point value and a unit of measure. Thus, we will use a 16x2 LCD module for our
    example. The following picture shows an example of the location of each character
    in a 16x2 LCD screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding LCD displays and their connection types](img/B05042_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There are LCD modules with different features and we must consider a lot of
    the things we learned when we analyzed sensors in [Chapter 7](ch07.html "Chapter 7. Retrieving
    Data from the Real World with Sensors"), *Retrieving Data from the Real World
    with Sensors*. The following list enumerates the most important things that we
    must consider when we select an LCD module and their description. As we analyzed
    many of these things when we learned about sensors, we won't repeat the descriptions
    for the common items.
  prefs: []
  type: TYPE_NORMAL
- en: '**Compatibility with Intel Galileo Gen 2 board and the voltage supply that
    we are using (5V or 3.3V)**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Power consumption**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Connection type**: Some LCD displays consume too many pins, and therefore,
    it is very important to check all the pins that they require. The most common
    connection types for LCD displays are the I²C bus, the SPI bus, and the UART port.
    However, some LCD displays require a bus or port combined with additional GPIO
    pins.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Operating range and special environment requirements**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dimensions**: LCD displays come with different dimensions. Sometimes only
    specific dimensions are suitable for our project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Number of columns and rows**: Based on the text we have to display, we will
    select the LCD display with the appropriate number of columns and rows that can
    display the characters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Response time**: It is very important to determine how much we can wait for
    the LCD display to show the new content that replaces the text that is being displayed
    or to clear the display.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Protocol, support in the upm library and Python bindings**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Supported character set and built-in fonts**: Some LCD displays support user-defined
    characters, and therefore, they allow us to configure and display custom characters.
    It is also important to check whether the LCD display supports characters for
    the languages in which we have to display the text.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Backlight color, text color and contrast level**: Some LCD displays allow
    us to change the backlight color while others have a fixed backlight color. An
    RGB backlight makes it possible to combine red, green, and blue components to
    determine the desired backlight color. In addition, it is always important to
    take into account whether the contrast level is appropriate for the light conditions
    in which you will need to display information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cost**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wiring an LCD RGB backlight to the I²C bus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our last example in [Chapter 7](ch07.html "Chapter 7. Retrieving Data from
    the Real World with Sensors"), *Retrieving Data from the Real World with Sensors*,
    we worked with a multifunctional digital sensor that provided us with the temperature
    and relative humidity information. We worked with a breakout board that uses the
    I²C bus to allow the Intel Galileo Gen 2 board to communicate with the sensor.
    Now, we will add a breakout board with a 16x2 LCD RGB backlight to allow us to
    display the measured temperature and humidity values with text and numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The LCD RGB backlight breakout board will also be connected to the same I²C
    bus to which the temperature and humidity digital sensor is connected. We can
    connect many slaves to the I²C bus in the Intel Galileo Gen 2 board as long as
    their have different I²C addresses. In fact, the LCD RGB backlight breakout board
    has two I²C addresses: one for the LCD display and the other for the backlight.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need the following parts to work with this example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A SeeedStudio Grove temperature and humidity sensor (high-accuracy and mini)
    breakout. The following URL provides detailed information about this breakout
    board: [http://www.seeedstudio.com/depot/Grove-TemperatureHumidity-Sensor-HighAccuracy-Mini-p-1921.html](http://www.seeedstudio.com/depot/Grove-TemperatureHumidity-Sensor-HighAccuracy-Mini-p-1921.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A SeeedStudio Grove LCD RGB backlight breakout. The following URL provides
    detailed information about this breakout board: [http://www.seeedstudio.com/depot/Grove-LCD-RGB-Backlight-p-1643.html](http://www.seeedstudio.com/depot/Grove-LCD-RGB-Backlight-p-1643.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram shows the digital temperature and humidity breakout,
    the LCD RGB backlight breakout, the necessary wirings, and the wirings from the
    Intel Galileo Gen 2 board to the breadboard. The Fritzing file for the sample
    is `iot_fritzing_chapter_08_01.fzz` and the following image is the breadboard
    view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Wiring an LCD RGB backlight to the I2C bus](img/B05042_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following image shows the schematic with the electronic components represented
    as symbols:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Wiring an LCD RGB backlight to the I2C bus](img/B05042_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As seen in the previous schematic, we have the following connections:'
  prefs: []
  type: TYPE_NORMAL
- en: The **SDA** pin is connected to both the breakout board pins labeled **SDA**.
    This way, we connect both the digital temperature and humidity sensor and the
    LCD backlight to the serial data line for the I²C bus.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **SCL** pin is connected to both the breakout board pins labeled **SCL**.
    This way, we can connect both the digital temperature and humidity sensor and
    the LCD backlight to the serial clock line for the I²C bus.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The power pin labeled **3V3** is connected to the digital temperature and humidity
    sensor breakout board power pin labeled **VCC**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The power pin labeled **5V** is connected to the LCD backlight breakout board
    power pin labeled **VCC**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ground pin labeled **GND** is connected to both the breakout board pins
    labeled **GND**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, it is time make all the necessary wirings. Don't forget to shut down the
    Yocto Linux, wait for all the onboard LEDs to turn off and unplug the power supply
    from the Intel Galileo Gen 2 board before adding or removing any wire from the
    board's pins.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying text on an LCD display
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `upm` library includes support for the 16x2 LCD RGB backlight breakout board
    in the `pyupm_i2clcd` module. The `Jhd1313m1` class declared in this module represents
    a 16x2 LCD display and its RGB backlight, connected to our board. The class makes
    it easy to set the color components for the RGB backlight, clear the LCD display,
    specify the cursor location, and write text through the I²C bus. The class works
    with the `mraa.I2c` class under the hoods to talk with the RGB backlight and the
    LCD display. These two devices act as slave devices connected to the I²C bus,
    and therefore, each of them have a specific address in this bus.
  prefs: []
  type: TYPE_NORMAL
- en: We will take the code we wrote in the previous chapter when we read temperature
    and humidity values from the sensor and we will use this code as a baseline to
    add the new features. The code file for the sample was `iot_python_chapter_07_05.py`.
  prefs: []
  type: TYPE_NORMAL
- en: We will create an `Lcd` class to represent the 16x2 LCD RGB backlight and make
    it easier for us to set the background color and write the text in two lines without
    worrying about the specific methods when working with an instance of the `Jhd1313m1`
    class. We will use the `Jhd1313m1` class to interact with the LCD and its RGB
    backlight. The following lines show the code for the new `Lcd` class that works
    with the `upm` library, specifically with the `pyupm_i2clcd` module. The code
    file for the sample is `iot_python_chapter_08_01.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Lcd` class declares two class attributes: `lcd_i2c_address` and `rgb_i2c_address`.
    The first class attribute defines the I²C address for the LCD display, that is,
    the address that will process the commands that locate the cursor and write text
    once the cursor is located in a specific row and column. The address is `3E` in
    hexadecimal (`0x3E`). If we just see a `0x3E` within the code, we don''t understand
    that it is an I²C bus address for the LCD display. The second class attribute
    defines the I²C address for the RGB backlight, that is, the address that will
    process the commands that set the red, green, and blue components for the backlight
    color. The address is `62` in hexadecimal (`0x62`). If we just see a `0x62` within
    the code, we don''t understand that it is an I²C bus address for the RGB backlight.
    These class attributes make it easier to read the code.'
  prefs: []
  type: TYPE_NORMAL
- en: We have to specify the I²C bus number to which the both the 16x2 LCD and the
    RGB backlight are wired when we create an instance of the `Lcd` class in the `bus`
    required argument. In addition, it is necessary to specify the values for the
    red, green and blue color components to configure the background color for the
    RGB backlight. The constructor, that is, the `__init__` method, creates a new
    `upmLcd.Jhd1313m1` instance with the received `bus` argument followed by the `lcd_i2c_address`
    and `rgb_i2c_address` class attributes and saves the reference for the new instance
    in the `lcd` attribute. Then, the code calls the `clear` method for the new instance
    to clear the LCD screen. Finally, the code calls the `set_background_color` method
    with the red, green, and blue values received as arguments to configure the background
    color for the RGB backlight.
  prefs: []
  type: TYPE_NORMAL
- en: The class declares the `set_background_color` method that calls the `lcd.setColor`
    method with the `red`, `green` and `blue` values received as arguments. Under
    the hoods, the `upmLcd.Jhd1313m1` instance will write data to the slave device
    whose address is equal to the `rgb_i2c_address` class attribute through the I²C
    bus to specify the desired value for each color component. We just create a specific
    method to follow Python naming conventions and make our final code that uses our
    class easier to read.
  prefs: []
  type: TYPE_NORMAL
- en: 'The class defines the following two additional methods to make it easy to print
    text on the first and the second row of the LCD display:'
  prefs: []
  type: TYPE_NORMAL
- en: '`print_line_1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`print_line_2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `print_line_1` method calls the `setCursor` method for the `upmLcd.Jhd1313m1`
    instance (`self.lcd`), with `0` as the value for both the `row` and the `column`
    argument, to locate the cursor in the first row and the first column. Then, a
    call to the write method for the the `upmLcd.Jhd1313m1` instance (`self.lcd`)
    with the `message` reviewed as a parameter as an argument prints the received
    string in the LCD display. Under the hoods, the `upmLcd.Jhd1313m1` instance will
    write the data to the slave device whose address is equal to the `lcd_i2c_address`
    class attribute through the I²C bus to specify the desired location for the cursor
    and then to write the specified text starting in the position in which we have
    located the cursor. The first row is identified with 0, but we named the method
    `print_line_1` because it makes it easier for us to understand that we are writing
    a message in the first line of the LCD screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `print_line_2` method has the same two lines of code than the `print_line_1`
    method with just one difference: the call to the `setCursor` method specifies
    1 as the value for the row argument. This way, the method prints a message in
    the second line of the LCD screen.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will create a subclass of the previously coded `Lcd` class named `TemperatureAndHumidityLcd`.
    The subclass will specialize the `Lcd` class to allow us to easily print a temperature
    value expressed in degrees Fahrenheit in the first line of the LCD screen and
    print a humidity value expressed in percentage in the second line of the LCD screen.
    The following lines show the code for the new `TemperatureAndHumidityLcd` class.
    The code file for the sample is `iot_python_chapter_08_01.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The new class (`TemperatureAndHumidityLcd`) adds the following two methods
    to its superclass (`Lcd`):'
  prefs: []
  type: TYPE_NORMAL
- en: '`print_temperature`: Calls the `print_line_1` method with the formatted text
    that displays the temperature value expressed in degrees Fahrenheit (ºF) received
    in the `temperature_fahrenheit` argument.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`print_humidity`: Calls the `print_line_2` method with the formatted text that
    displays the humidity level expressed in percentage received in the `humidity`
    argument.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, we will write a loop that will display the ambient temperature expressed
    in degrees Fahrenheit (ºF) and the humidity value in the LCD screen, every 10
    seconds. The code file for the sample is `iot_python_chapter_08_01.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted lines show the changes made to the `__main__` method compared
    with the previous version. The first highlighted line creates an instance of the
    previously coded `TemperatureAndHumidityLcd` class with `0` as the value of the
    `bus` argument, `0` for `red` and `green`, and `128` for `blue` to set the background
    color to light blue. The code saves the reference to this instance in the `lcd`
    local variable. This way, the instance will establish a communication with the
    LCD screen and the RGB backlight through the I²C bus. The RGB backlight will display
    a light blue background.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the code runs a loop forever and the highlighted line calls the `lcd.print_temperature`
    method with `temperature_and_humidity_sensor.temperature_fahrenheit`, that is,
    the measured temperature expressed in degrees Fahrenheit (ºF), as an argument.
    This way, the code displays this temperature value in the first line of the LCD
    screen.
  prefs: []
  type: TYPE_NORMAL
- en: The next hightlighted line calls the `lcd.print_humidity` method with `temperature_and_humidity_sensor.humidity`,
    that is, the measured humidity expressed in percentage, as an argument. This way,
    the code displays this humidity value in the second line of the LCD screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following line will start the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: After you run the example, turn on an air conditioner or heating system, to
    generate a change in the ambient temperature and humidity. The LCD screen will
    display the temperature and humidity and refresh it every 10 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Wiring an OLED dot matrix to the I²C bus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: LCD displays are not the only option when we have to display content on an external
    screen through the I²C or SPI buses. There are also OLED dot matrixes that allow
    us to control a specific number of dots. In OLED dot matrices we have control
    over each dot, instead of controlling each character space. Some of them are grayscale
    and others RGB.
  prefs: []
  type: TYPE_NORMAL
- en: 'The key advantage of OLED dot matrixes is that we can display any kind of graphics
    and not just text. In fact, we can mix any kind of graphics and images with text.
    The Grove OLED Display 0.96" is an example of a 16 grayscale 96-by-96 dot matrix
    OLED display module that works with the I²C bus. The following URL provides detailed
    information about this breakout board: [http://www.seeedstudio.com/depot/Grove-OLED-Display-096-p-824.html](http://www.seeedstudio.com/depot/Grove-OLED-Display-096-p-824.html).
    The Xadow RGB OLED 96x24 is an example of an RGB color 96-by-64 dot matrix OLED
    display module that works with the SPI bus. The following URL provides detailed
    information about this breakout board: [http://www.seeedstudio.com/depot/Xadow-RGB-OLED-96x64-p-2125.html](http://www.seeedstudio.com/depot/Xadow-RGB-OLED-96x64-p-2125.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another option is to work with TFT LCD dot matrices or displays. Some of them
    include support for touch detection.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will replace the breakout board with a 16x2 LCD RGB backlight with a
    16 grayscale 96-by-96 dot matrix OLED display module that also works with the
    I²C bus, and we will use this new screen to display similar values with a different
    configuration. The wirings are compatible with the previous breakout board.
  prefs: []
  type: TYPE_NORMAL
- en: As it happened in our previous example, the dot matrix OLED will also be connected
    to the same I²C bus to which the temperature and humidity digital sensor is connected.
    As the dot matrix OLED has an I²C address that is different than the one used
    by the temperature and humidity digital sensor, we don't have problems to wire
    the two devices to the same I²C bus.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need the following additional part to work with this example: A SeeedStudio
    Grove OLED Display 0.96", 16 grayscale 96-by-96 dot matrix OLED display module.
    The 96-by-96 dot matrix OLED display provides us the chance to control 9,216 dots,
    known as pixels. However, in this case, we just want to use the OLED display to
    display a similar text than the one we displayed in our previous example, but
    with a different layout.'
  prefs: []
  type: TYPE_NORMAL
- en: If we use the default 8-by-8 character box, we have 12 columns (96/8) and 12
    rows (96/8) for characters. The following table shows an example of each line
    with the text and the values.
  prefs: []
  type: TYPE_NORMAL
- en: '| T | e | m | p | e | r | a | t | u | r | e |   |'
  prefs: []
  type: TYPE_TB
- en: '|   |   |   |   |   |   |   |   |   |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| F | a | h | r | e | n | h | e | i | t |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | 0 | . | 2 |   |   |   |   |   |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: '|   |   |   |   |   |   |   |   |   |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| C | e | l | s | i | u | s |   |   |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | . | 5 | 5 |   |   |   |   |   |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: '|   |   |   |   |   |   |   |   |   |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| H | u | m | i | d | i | t | y |   |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| L | e | v | e | l |   |   |   |   |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | 0 | % |   |   |   |   |   |   |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: '|   |   |   |   |   |   |   |   |   |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: The possibility to work with 12 columns and 12 rows of characters allows us
    to provide a very clear description for each value. In addition, we are able to
    display the temperature values expressed in both degrees Fahrenheit and degrees
    Celsius. The following picture shows an example of the location of each character
    in the 96-by-96 dot matrix OLED display module with an 8-by-8 character box.
  prefs: []
  type: TYPE_NORMAL
- en: '![Wiring an OLED dot matrix to the I2C bus](img/B05042_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'After we replace the LCD screen breakout board with the OLED module, we will
    have the following connections:'
  prefs: []
  type: TYPE_NORMAL
- en: The **SDA** pin is connected to both breakout board pins labeled **SDA**. This
    way, we connect both the digital temperature and humidity sensor and the OLED
    module to the serial data line for the I²C bus.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **SCL** pin is connected to both the breakout board pins labeled **SCL**.
    This way, we connect both the digital temperature and humidity sensor and the
    OLED module to the serial clock line for the I²C bus.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The power pin labeled **3V3** is connected to the digital temperature and humidity
    sensor breakout board power pin labeled **VCC**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The power pin labeled **5V** is connected to the OLED module power pin labeled
    **VCC**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ground pin labeled **GND** is connected to both the breakout board pins
    labeled **GND**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, it is time make all the necessary wirings. Don't forget to shutdown the
    Yocto Linux, wait for all the onboard LEDs to turn off, and unplug the power supply
    from the Intel Galileo Gen 2 board before adding or removing any wire from the
    board's pins.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying text on an OLED display
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `upm` library includes support for the SeeedStudio Grove OLED display 0.96",
    16 grayscale 96-by-96 dot matrix OLED display breakout board the in the `pyupm_i2clcd`
    module. As this OLED display uses SSD1327 driver integrated circuit, the `SSD1327`
    class declared in this module represents a 96-by-96 dot matrix OLED display, connected
    to our board. The class makes it easy to clear the OLED screen, draw bitmap images,
    specify the cursor location, and write text through the I²C bus. The class works
    with the `mraa.I2c` class under the hoods to talk with the OLED display.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create a new `Oled` class that will represent the 96-by-96 dot matrix
    OLED and will use its default 8-by-8 character box to display text. We will use
    the `SSD1327` class to interact with the OLED display. The following lines show
    the code for the new `Oled` class that works with the `upm` library, specifically
    with the `pyupm_i2clcd` module and its `SSD1327` class. The code file for the
    sample is `iot_python_chapter_08_02.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `Oled` class declares the `oled_i2c_address` class attribute that defines
    the I²C address for the OLED display, that is, the address that will process the
    commands that locate the cursor and write text once the cursor is located in a
    specific row and column. The address is `3C` in hexadecimal (`0x3C`).
  prefs: []
  type: TYPE_NORMAL
- en: We have to specify the I²C bus number to which the OLED display is wired when
    we create an instance of the `Oled` class in the `bus` required argument. The
    constructor, that is, the `__init__` method, creates a new `upmLcd. SSD1327` instance
    with the received `bus` argument followed by the `oled_i2c_address` class attribute,
    and saves the reference for the new instance in the `oled` attribute. Finally,
    the code calls the `clear` method for the new instance to clear the OLED screen.
  prefs: []
  type: TYPE_NORMAL
- en: The class declared the `print_line` method to make it easy to print text on
    a specific row. The code calls the `setCursor` method for the `upmLcd.SSD1327`
    instance (`self.oled`), with the received `row` value as the value for the `row`
    argument and `0` for the `column` argument, to locate the cursor in the specified
    row and the first column. Then, a call to the `setGrayLevel` and the `write` method
    for the the `upmLcd.SSD1327` instance (`self.oled`) with the `message` reveiced
    as a parameter as an argument prints the received string in the OLED display with
    the default 8-by-8 character box with the gray level set to 12\. Under the hoods,
    the `upmLcd.SSD1327` instance will write data to the slave device whose address
    is equal to the `oled_i2c_address` class attribute through the I²C bus to specify
    the desired location for the cursor and then to write the specified text starting
    in the position in which we have located the cursor.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will create a subclass of the previously coded `Oled` class named `TemperatureAndHumidityOled`.
    The subclass will specialize the `Oled` class to allow us to easily print a temperature
    value expressed in degrees Fahrenheit, the temperature value expressed in degrees
    Celsius and a humidity value expressed in percentage. We will use the previously
    explained layout for the text. The following lines show the code for the new `TemperatureAndHumidityOled`
    class. The code file for the sample is `iot_python_chapter_08_02.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The new class (`TemperatureAndHumidityOled`) adds the following two methods
    to its superclass (`Oled`):'
  prefs: []
  type: TYPE_NORMAL
- en: '`print_temperature`: Calls the `print_line` method many times to display the
    temperature in both degrees Fahrenheit (ºF) and Celsius (ºC) received as arguments'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`print_humidity`: Calls the `print_line` method many times to display the humidity
    value received as an argument'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this case, we refresh many lines to change just a few values. As we will
    run a loop every 10 seconds, it won't be a problem. However, in other cases in
    which we want to update values in a shorter amount of time, we can write optimized
    code that just clears a single line and updates the specific value in this line.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will write a loop that will display the ambient temperature expressed
    in Fahrenheit (ºF) and Celsius (ºC) and the humidity value in the OLED screen,
    every 10 seconds. The code file for the sample is `iot_python_chapter_08_02.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted lines show the changes made in the `__main__` method compared
    with the previous version. The first highlighted line creates an instance of the
    previously coded `TemperatureAndHumidityOled` class with `0` as the value of the
    `bus` argument. The code saves the reference to this instance in the `oled` local
    variable. This way, the instance will establish a communication with the OLED
    screen through the I²C bus.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the code runs a loop forever and the highlighted line calls the `oled.print_temperature`
    method with `temperature_and_humidity_sensor.temperature_fahrenheit` and `temperature_and_humidity_sensor.temperature_celsius`
    as arguments. This way, the code displays both temperature values in the first
    lines of the OLED screen.
  prefs: []
  type: TYPE_NORMAL
- en: The next hightlighted line calls the `oled.print_humidity` method with `temperature_and_humidity_sensor.humidity`.
    This way, the code uses many lines to display this humidity value at the bottom
    of the OLED screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following line will start the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: After you run the example, turn on an air conditioner or a heating system to
    generate a change in the ambient temperature and humidity. The OLED screen will
    display the temperature and humidity and refresh it every 10 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Wiring a servo motor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have been using sensors to retrieve data from the real world and
    we displayed information in LCD and OLED displays. However, IoT devices are not
    limited to sensing and displaying data, they can also move things. We can connect
    different components, shields, or breakout boards to our Intel Galileo Gen 2 board
    and write Python code to move things connected to the board.
  prefs: []
  type: TYPE_NORMAL
- en: Standard servo motors are extremely useful to precisely control a shaft and
    position it at various angles, usually between 0 and 180 degrees. In [Chapter
    4](ch04.html "Chapter 4. Working with a RESTful API and Pulse Width Modulation"),
    *Working with a RESTful API and Pulse Width Modulation*, we worked with pulse
    width modulation, known as PWM, to control the brightness of an LED and a RGB
    LED. We can also use PWM to control a standard analog servo motor and position
    its shaft at a specific angle.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Standard servo motors are DC motors that includes gears and feedback control
    loop circuitry that provides precision positioning. They are ideal for pinion
    steering, robot arms and legs, among other usages that require a precise positioning.
    Standard servo motors don't require motor drivers.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, not all servor motors have the same features and we must take into
    account many of them when we select a specific servo motor for our project. It
    depends on what we need to position, the accuracy, the required torque, the optimal
    servo rotational velocity, among other factors. In this case, we will focus on
    the usage of PWM to position a standard servo motor. However, you cannot use the
    same servo to rotate a lighter plastic piece than the one you will need to rotate
    a heavy robotic arm. It is necessary to research about the appropriate servo for
    each task.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will wire a standard high sensitive mini servo motor to our existing
    project and we will rotate the shaft to display the measured temperature expressed
    in degrees Fahrenheit with the shaft. The shaft will allow us to display the measured
    temperature in a half circle protractor that measures angles in degrees and will
    display the number for the angle from 0 to 180 degrees. The combination of the
    servo with the shaft and the protactor will allow us to display the temperature
    with moving parts. Then, we can create our own protactor with a scale that can
    add colors, specific thresholds and many other visual artifacts to make temperature
    measurement funnier. Specifically, we can create a gauge chart, speedometer or
    semicircle donut, that is, a combination of a doughnut chart and a pie chart in
    a single chart with the different temperature values. The following picture shows
    and example of a half circle protractor that we can use in combination with the
    servo with the shaft.
  prefs: []
  type: TYPE_NORMAL
- en: '![Wiring a servo motor](img/B05042_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We need the following additional part to work with this example: A SeeedStudio
    Grove Servo or a EMAX 9g ES08A High Sensitive Mini Servo. The following URLs provide
    detailed information about these servos: [http://www.seeedstudio.com/depot/Grove-Servo-p-1241.html](http://www.seeedstudio.com/depot/Grove-Servo-p-1241.html)
    and [http://www.seeedstudio.com/depot/EMAX-9g-ES08A-High-Sensitive-Mini-Servo-p-760.html](http://www.seeedstudio.com/depot/EMAX-9g-ES08A-High-Sensitive-Mini-Servo-p-760.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the digital temperature and humidity breakout,
    the LCD RGB backlight breakout, the mini servo, the necessary wirings and the
    wirings from the Intel Galileo Gen 2 board to the breadboard. The Fritzing file
    for the sample is `iot_fritzing_chapter_08_03.fzz` and the following picture is
    the breadboard view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Wiring a servo motor](img/B05042_08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following picture shows the schematic with the electronic components represented
    as symbols:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Wiring a servo motor](img/B05042_08_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As seen in the previous schematic, we added the following additional connections
    to our existing project:'
  prefs: []
  type: TYPE_NORMAL
- en: The power pin labeled **5V** in the board's symbol is connected to the servo's
    pin labeled **+**. Servos usually use a red wire for this connection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The PWM capable GPIO pin labeled **D3 PWM** in the board's symbol is connected
    to the servo's pin labeled **PULSE**. Servos usually use a yellow wire for this
    connection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ground pin labeled **GND** in the board's symbol is connected to the servo's
    pin labeled **-**. Servos usually use a black wire for this connection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, it is time make all the necessary wirings. Don't forget to shut down the
    Yocto Linux, wait for all the onboard LEDs to turn off, and unplug the power supply
    from the Intel Galileo Gen 2 board before adding or removing any wire from the
    board's pins.
  prefs: []
  type: TYPE_NORMAL
- en: Positioning a shaft to indicate a value with a servo motor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can use the `mraa.Pwm` class to control PWM on the PWM capable GPIO pin labeled
    **~3**, as we learned in [Chapter 4](ch04.html "Chapter 4. Working with a RESTful
    API and Pulse Width Modulation"), *Working with a RESTful API and Pulse Width
    Modulation*. However, this would require us to read the detailed specs for the
    servo. The `upm` library includes support for both the SeeedStudio Grove Servo
    or the EMAX 9g ES08A High Sensitive Mini Servo in the `pyupm_servo` module. The
    `ES08A` class declared in this module represents any of the two mentioned servors
    connected to our board.
  prefs: []
  type: TYPE_NORMAL
- en: The class makes it easy to set the desired angle for the servo shaft and work
    with angles instead of duty cycles and other PWM details. The class works with
    the `mraa.Pwm` class under the hoods to configure PWM and control the duty cycle
    based on the desired angle for the shaft.
  prefs: []
  type: TYPE_NORMAL
- en: We will take the code we wrote in the previous example and we will use this
    code as a baseline to add the new features. The code file for the sample was `iot_python_chapter_08_02.py`.
  prefs: []
  type: TYPE_NORMAL
- en: We will create a `TemperatureServo` class to represent the servo and make it
    easier for us to position the shaft in a valid angle (from 0 to 180 degrees) based
    on the temperature expressed in degrees Fahrenheit. We will use the `ES08A` class
    to interact with the servo. The following lines show the code for the new `TemperatureServo`
    class that works with the `upm` library, specifically with the `pyupm_servo` module.
    The code file for the sample is `iot_python_chapter_08_03.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We have to specify the pin number to which the servo is connected when we create
    an instance of the `TemperatureServo` class in the `pin` required argument. The
    constructor, that is, the `__init__` method, creates a new `upmServo.ES08A` instance
    with the received `pin` as its `pin` argument, saves its reference in the `servo`
    attribute and calls its `setAngle` with `0` as the value for the `angle` required
    argument. This way, the underlying code will configure the output duty cycle for
    the PWM enabled GPIO pin based on the received value in the `angle` argument to
    position the shaft at the desired angle. In this case, we want the shaft to be
    positioned at 0 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: 'The class defines a `print_temperature` method that receives a temperature
    value expressed in degrees Fahrenheit (ºF) in the `temperature_fahrenheit` argument.
    The code defines an `angle` local variable that makes sure that the desired angle
    for the shaft is in a valid range: from 0 to 180 (inclusive). If the value received
    in the `temperature_fahrenheit` argument is lower than `0`, the `angle` value
    will be `0`. If the value received in the `temperature_fahrenheit` argument is
    greater than `180`, the `angle` value will be `180`. Then, the code calls the
    `setAngle` method for the `upmServo.ES08A` instance (`self.servo`) with `angle`
    as an argument. Under the hoods, the `upmServo.ES08A` instance will configure
    the output duty cycle for the PWM enabled GPIO pin based on the received value
    in the `angle` argument to position the shaft at the desired angle. This way,
    the shaft will position at an angle that will be the same than the received temperature
    in degrees Fahrenheit (ºF), as long as the temperature value is between 0 and
    180 degrees Fahrenheit (ºF).'
  prefs: []
  type: TYPE_NORMAL
- en: In case it is too cold, (less than 0 degrees Fahrenheit) the shaft will stay
    at a 0 degrees angle. In case the temperature is higher than 180 degrees Fahrenheit,
    the shaft will stay at a 180 degrees angle.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will make changes to our main loop to display the ambient temperature
    expressed in Fahrenheit (ºF) with the shaft, every 10 seconds. The code file for
    the sample is `iot_python_chapter_08_03.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted lines show the changes made to the `__main__` method compared
    with the previous version. The first highlighted line creates an instance of the
    previously coded `TemperatureServo` class with `3` as the value of the `pin` argument.
    The code saves the reference to this instance in the `temperature_servo` local
    variable. This way, the instance will configure PWM for pin number 3 and position
    the shaft at `0` degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the code runs a loop forever and the highlighted line calls the `temperature_servo.print_temperature`
    method with `temperature_and_humidity_sensor.temperature_fahrenheit` as an argument.
    This way, the code makes the shaft point to the temperature value in the protractor.
  prefs: []
  type: TYPE_NORMAL
- en: The following line will start the example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: After you run the example, turn on an air conditioner or a heating system and
    generate a change in the ambient temperature. You will notice how the shaft starts
    moving to reflect the changes in the temperature every 10 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Intel Galileo Gen 2 board works as an I²C bus master and allows us to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect many slaves to the I²C bus as long as their have different I²C addresses.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect many slaves to the I²C bus as long as their have the same I²C addresses.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect a maximum of two slaves to the I²C bus as long as their have different
    I²C addresses.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A 16x2 LCD module allows us to display:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Two lines of text with 16 characters each.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Sixteen lines of text with 2 characters each.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Sixteen lines of text with 3 characters each.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A 16 grayscale 96-by-96 dot matrix OLED display module allows us to control:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 96 lines of text with 96 characters each.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A single line with 96 dots or 96 characters, based on how we configure the OLED
    display.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 9,216 dots (96*96).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A 16 grayscale 96-by-96 dot matrix OLED display with an 8-by-8 character box
    allows us to display:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '96 lines of text with 96 characters each: 96 columns and 96 rows.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '16 lines of text with 16 characters each: 16 columns and 16 rows.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '12 lines of text with 12 characters each: 12 columns and 12 rows.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Standard servos allow us to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Display text on an OLED display.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Position the shaft at various specific angles.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Move the shaft to a specific location by specifying the desired latitude and
    longitude.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about different displays the we could connect to
    our board through the I²C bus. We worked with an LCD display, an RGB backlight,
    and then replaced it with an OLED dot matrix.
  prefs: []
  type: TYPE_NORMAL
- en: We wrote the code that took advantage of the modules and classes included in
    the `upm` library that made it easier for us to work with LCD and OLED display
    and show text on them. In addition, we wrote the code that interacted with an
    analog servo. Instead of writing our own code to set the output duty cycle based
    on the desired position for the shaft, we took advantage of a specific module
    and a class in the `upm` library. We could control the shaft to allow us to create
    a gauge chart to display the temperature value retrieved with a sensor. Our Python
    code could make things move.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are able to show data next to the board and work with servos, we
    will connect our IoT device to the entire world and work with cloud services,
    which is the topic of the next chapter.
  prefs: []
  type: TYPE_NORMAL
