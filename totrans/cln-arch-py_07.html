<html><head></head><body><div id="book-content"><div id="sbo-rt-content"><div id="_idContainer033">
    <h1 class="chapterNumber"><a id="_idTextAnchor123"/>5</h1>
    <h1 id="_idParaDest-117" class="chapterTitle"><a id="_idTextAnchor124"/>The Application Layer: Orchestrating Use Cases</h1>
    <p class="normal">In <a href="Chapter_04.xhtml#_idTextAnchor091"><em class="italic">Chapter 4</em></a>, we developed the Domain layer of our task management system and implemented entities, value objects, and domain services that encapsulate our core business rules. While this gives us a solid foundation, business rules alone don’t make a usable application. We need a way to coordinate these domain objects to fulfill user needs such as creating tasks, managing projects, and handling notifications. This is where<a id="_idIndexMarker254"/> the <strong class="keyWord">Application layer</strong> comes in.</p>
    <p class="normal">The Application layer acts as the conductor in our Clean Architecture orchestra. It coordinates domain objects and external services to accomplish specific use cases while maintaining the strict boundary between our business rules and the outside world. By implementing this layer correctly, we create applications that are not only functional but also maintainable and adaptable to change.</p>
    <p class="normal">In this chapter, we’ll explore how to implement an effective Application layer using our task management system as an example. We’ll see how to create use cases that orchestrate domain objects while maintaining clean architectural boundaries. You’ll learn how to implement request and response models that clearly define use case boundaries, and how to manage dependencies on external services without compromising architectural integrity.</p>
    <p class="normal">In this chapter, we’re going to cover the following main topics:</p>
    <ul>
      <li class="bulletList">Understanding the role of the Application layer</li>
      <li class="bulletList">Implementing use case interactors</li>
      <li class="bulletList">Defining request and response models</li>
      <li class="bulletList">Maintaining separation from external concerns</li>
    </ul>
    <h1 id="_idParaDest-118" class="heading-1"><a id="_idTextAnchor125"/>Technical requirements</h1>
    <p class="normal">The code examples presented in this chapter and throughout the rest of the book are tested with Python 3.13. For brevity, in addition to the lack of logging statements, some code examples in the chapter are only partially implemented. Complete versions of all examples can be found in the book’s accompanying GitHub repository at <a href="https://github.com/PacktPublishing/Clean-Architecture-with-Python"><span class="url">https://github.com/PacktPublishing/Clean-Architecture-with-Python</span></a>.</p>
    <h1 id="_idParaDest-119" class="heading-1"><a id="_idTextAnchor126"/>Understanding the role of the Application layer</h1>
    <p class="normal">The Application layer <a id="_idIndexMarker255"/>serves as a thin layer that coordinates our domain objects and services to accomplish meaningful user tasks. While our domain model provides the building blocks, tasks, projects, deadlines, it’s the Application layer that assembles these pieces into useful features.</p>
    <p class="normal">The Application layer serves another critical function: information hiding. In <a href="Chapter_04.xhtml#_idTextAnchor091"><em class="italic">Chapter 4</em></a>, we saw how domain entities hide their internal state and implementation details. The Application layer extends this principle across architectural boundaries, hiding infrastructure details from the domain and domain complexities from external interfaces. This deliberate hiding of information is what makes the additional effort of creating ports, adapters, and request/response models worthwhile. By exposing only what’s necessary through carefully designed interfaces, we create a system where components can evolve independently yet work together seamlessly.</p>
    <figure class="mediaobject"><img src="../Images/B31577_05_1.png" alt="Figure 5.1: Application layer and task management" width="1041" height="854"/></figure>
    <p class="packt_figref">Figure 5.1: Application layer and task management</p>
    <p class="normal">In <em class="italic">Figure 5.1</em>, we illustrate <a id="_idIndexMarker256"/>how the Application layer fits within Clean Architecture’s concentric layers. It acts as a mediator between the Domain layer, where our core business entities such as Task and Project reside, and the outer layers of our system. By encapsulating use cases that orchestrate domain entities, the Application layer maintains the Dependency Rule: outer layers depend inward, and inner layers remain unaffected by changes in outer layers.</p>
    <p class="normal">The Application layer has<a id="_idIndexMarker257"/> several distinct responsibilities:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Use case orchestration</strong>:<ul>
          <li class="bulletList level-2">Coordinating domain objects to accomplish user tasks</li>
          <li class="bulletList level-2">Managing the sequence of operations</li>
          <li class="bulletList level-2">Ensuring business rules are properly applied</li>
        </ul>
      </li>
      <li class="bulletList"><strong class="keyWord">Error handling and validation</strong>:<ul>
          <li class="bulletList level-2">Validating input before it reaches domain objects</li>
          <li class="bulletList level-2">Catching and translating domain errors</li>
          <li class="bulletList level-2">Providing consistent error responses</li>
        </ul>
      </li>
      <li class="bulletList"><strong class="keyWord">Transaction management</strong>:<ul>
          <li class="bulletList level-2">Ensuring operations are atomic when needed</li>
          <li class="bulletList level-2">Maintaining data consistency</li>
          <li class="bulletList level-2">Managing rollbacks on failures</li>
        </ul>
      </li>
      <li class="bulletList"><strong class="keyWord">Boundary translation</strong>:<ul>
          <li class="bulletList level-2">Converting external data formats to domain formats</li>
          <li class="bulletList level-2">Transforming domain objects for external presentation</li>
          <li class="bulletList level-2">Managing cross-boundary communication</li>
        </ul>
      </li>
    </ul>
    <p class="normal">These responsibilities <a id="_idIndexMarker258"/>work together to create a robust orchestration layer that maintains clean boundaries while ensuring reliable application behavior.</p>
    <h2 id="_idParaDest-120" class="heading-2"><a id="_idTextAnchor127"/>Error handling with result types</h2>
    <p class="normal">Before diving into our <a id="_idIndexMarker259"/>implementation patterns, it’s essential to understand a fundamental concept in our Application layer: the use of the <strong class="keyWord">result type</strong>. This pattern forms the backbone of our error-handling strategy, providing explicit handling of success and failure rather than relying solely on exceptions. This approach provides several benefits:</p>
    <ul>
      <li class="bulletList">Makes success/failure paths explicit in function signatures</li>
      <li class="bulletList">Provides consistent error handling across the application</li>
      <li class="bulletList">Maintains clean architectural boundaries by translating domain errors</li>
      <li class="bulletList">Improves testability and error handling predictability</li>
    </ul>
    <p class="normal">First, we define a standardized <code class="inlineCode">Error</code> class to represent all application-level errors:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span> <span class="hljs-title">ErrorCode</span>(<span class="hljs-title">Enum</span>):
    NOT_FOUND = <span class="hljs-string">"NOT_FOUND"</span>
    VALIDATION_ERROR = <span class="hljs-string">"VALIDATION_ERROR"</span>
    <span class="hljs-comment"># Add other error codes as needed</span>
<span class="hljs-meta">@dataclass(</span><span class="hljs-params">frozen=</span><span class="hljs-literal">True</span><span class="hljs-meta">)</span>
<span class="hljs-keyword">class</span> <span class="hljs-title">Error</span>:
    <span class="hljs-string">"""Standardized error information"""</span>
    code: ErrorCode
    message: <span class="hljs-built_in">str</span>
    details: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-type">Any</span>]] = <span class="hljs-literal">None</span>
<span class="hljs-meta">    @classmethod</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title">not_found</span>(<span class="hljs-params">cls, entity: </span><span class="hljs-built_in">str</span><span class="hljs-params">, entity_id: </span><span class="hljs-built_in">str</span>) -&gt; Self:
        <span class="hljs-keyword">return</span> cls(
            code=ErrorCode.NOT_FOUND,
            message=<span class="hljs-string">f"</span><span class="hljs-subst">{entity}</span><span class="hljs-string"> with id </span><span class="hljs-subst">{entity_id}</span><span class="hljs-string"> not found"</span>
        )
   
<span class="hljs-meta">    @classmethod</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title">validation_error</span>(<span class="hljs-params">cls, message: </span><span class="hljs-built_in">str</span>) -&gt; Self:
        <span class="hljs-keyword">return</span> cls(
            code=ErrorCode.VALIDATION_ERROR,
            message=message
        )
</code></pre>
    <p class="normal">Next, we define a <code class="inlineCode">Result</code> class that encapsulates either a successful value or an error:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@dataclass(</span><span class="hljs-params">frozen=</span><span class="hljs-literal">True</span><span class="hljs-meta">)</span>
<span class="hljs-keyword">class</span> <span class="hljs-title">Result</span>:
    <span class="hljs-string">"""Represents success or failure of a use case execution"""</span>
    value: <span class="hljs-type">Any</span> = <span class="hljs-literal">None</span> 
    error: <span class="hljs-type">Optional</span>[Error] = <span class="hljs-literal">None</span>
   
<span class="hljs-meta">    @property</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title">is_success</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">bool</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-variable">self</span>.error <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>
<span class="hljs-meta">    @classmethod</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title">success</span>(<span class="hljs-params">cls, value: </span><span class="hljs-type">Any</span>) -&gt; Self:
        <span class="hljs-keyword">return</span> cls(value=value)
       
<span class="hljs-meta">    @classmethod</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title">failure</span>(<span class="hljs-params">cls, error: Error</span>) -&gt; Self:
        <span class="hljs-keyword">return</span> cls(error=error)
</code></pre>
    <p class="normal">The use of result <a id="_idIndexMarker260"/>types enables clean orchestration of domain operations, as demonstrated in this usage example:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">try</span>:
    project = find_project(project_id)
    task = create_task(task_details)
    project.add_task(task)
    notify_stakeholders(task)
    <span class="hljs-keyword">return</span> Result.success(TaskResponse.from_entity(task))
<span class="hljs-keyword">except</span> ProjectNotFoundError:
    <span class="hljs-keyword">return</span> Result.failure(Error.not_found(<span class="hljs-string">"Project"</span>, <span class="hljs-built_in">str</span>(project_id)))
<span class="hljs-keyword">except</span> ValidationError <span class="hljs-keyword">as</span> e:
    <span class="hljs-keyword">return</span> Result.failure(Error.validation_error(<span class="hljs-built_in">str</span>(e)))
</code></pre>
    <p class="normal">The usage example above demonstrates several key advantages of the result pattern:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Clean error paths</strong>: Notice how <a id="_idIndexMarker261"/>the error cases are handled uniformly through <code class="inlineCode">Result.failure()</code>, providing a consistent interface regardless of the underlying error type</li>
      <li class="bulletList"><strong class="keyWord">Explicit domain translation</strong>: The conversion from domain-specific errors (<code class="inlineCode">ProjectNotFoundError</code>) to application-level errors happens cleanly at the boundary</li>
      <li class="bulletList"><strong class="keyWord">Self-contained context</strong>: The <code class="inlineCode">Result</code> object packages both the outcome and any error context, making the function’s behavior completely clear from its return value</li>
      <li class="bulletList"><strong class="keyWord">Testing clarity</strong>: The example makes it easy to test both success and failure cases by checking the result’s state rather than trying to catch exceptions</li>
    </ul>
    <div class="note">
      <p class="normal"><strong class="keyWord">Error handling boundaries in Clean Architecture</strong></p>
      <p class="normal">When implementing<a id="_idIndexMarker262"/> error handling in the Application layer, we explicitly catch and transform only expected domain and business errors into results. Thus, we don’t have an <code class="inlineCode">except Exception:</code> clause paired with the expected errors. This separation maintains clean architectural boundaries. Concerns such as global error handling remain in the outer layers.</p>
    </div>
    <h2 id="_idParaDest-121" class="heading-2"><a id="_idTextAnchor128"/>Application layer patterns</h2>
    <p class="normal">To understand how <a id="_idIndexMarker263"/>the Application layer manages its responsibilities, let’s examine how data flows through our architecture:</p>
    <figure class="mediaobject"><img src="../Images/B31577_05_2.png" alt="Figure 5.2: Request/Response flow in Clean Architecture" width="1210" height="779"/></figure>
    <p class="packt_figref">Figure 5.2: Request/Response flow in Clean Architecture</p>
    <p class="normal">The flow shown in <em class="italic">Figure 5.2</em> demonstrates several key patterns working together. A request enters through the Interface Adapters layer and is handled by our Application layer’s <strong class="keyWord">data transfer objects</strong> (<strong class="keyWord">DTOs)</strong>, which<a id="_idIndexMarker264"/> validate and transform the input into formats our domain can process. Use cases then orchestrate domain operations, working with these validated inputs to interact with domain <a id="_idIndexMarker265"/>objects and coordinate with external services through ports. The use cases return results that encapsulate either success (with a response DTO) or failure (with an error), which the Interface Adapters layer can then map directly to appropriate HTTP responses. Don’t worry about understanding all the discrete components in <em class="italic">Figure 5.2</em> now; we’ll cover them in more detail throughout the chapter.</p>
    <p class="normal">This choreographed interaction relies on three foundational patterns that work together to maintain clean architectural boundaries:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Use case interactors</strong>: These serve as the primary orchestrators, implementing specific business operations while managing transactions and coordinating domain objects. They ensure each operation is focused and its execution is consistent.</li>
      <li class="bulletList"><strong class="keyWord">Interface boundaries</strong>: Establish clear contracts between our Application layer and the services it depends on.</li>
      <li class="bulletList"><strong class="keyWord">Dependency inversion</strong>: Enables flexible implementation and straightforward testing through these boundaries, ensuring our core business logic remains decoupled from external concerns.</li>
    </ul>
    <p class="normal">Initially, our use cases will work with simple parameters and return basic data structures. As our application grows, we’ll introduce more sophisticated patterns for handling data that cross our architectural boundaries. This evolution helps us maintain a clean separation between layers while keeping our code adaptable to change.</p>
    <p class="normal">These patterns align <a id="_idIndexMarker266"/>naturally with the SOLID principles we explored in <a href="Chapter_02.xhtml#_idTextAnchor040"><em class="italic">Chapter 2</em></a>. Use cases embody the Single Responsibility Principle by focusing each operation on a specific goal. Interface definitions support interface segregation by defining focused, client-specific contracts.</p>
    <h2 id="_idParaDest-122" class="heading-2"><a id="_idTextAnchor129"/>Planning for evolution</h2>
    <p class="normal">Applications rarely <a id="_idIndexMarker267"/>remain static—successful ones inevitably grow in scope and complexity. What starts as a simple task management system might need to evolve to support multiple teams, integrate with various external services, or handle complex workflow automation. The Application layer patterns we’ve explored enable this evolution with minimal friction.</p>
    <p class="normal">Let’s examine how our task management system can grow through real-world scenarios:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Use case extensibility</strong>:<ul>
          <li class="bulletList level-2">Expanding task notifications from email to include Slack or similar communication platforms</li>
          <li class="bulletList level-2">Composing individual use cases, such as <em class="italic">assign task</em> and <em class="italic">set deadline,</em> into higher-level operations such as <em class="italic">sprint planning</em></li>
        </ul>
      </li>
      <li class="bulletList"><strong class="keyWord">Clean dependencies</strong>:<ul>
          <li class="bulletList level-2">Starting with local file storage for attachments, then seamlessly adding S3 support through the same interface</li>
          <li class="bulletList level-2">Switching database engines from SQLite to PostgreSQL without modifying use case code</li>
        </ul>
      </li>
      <li class="bulletList"><strong class="keyWord">Consistent boundaries</strong>:<ul>
          <li class="bulletList level-2">Handling data transformation in Request objects across new API versions (v1 versus v2) while reusing the same underlying use case code</li>
          <li class="bulletList level-2">Implementing distinct Response transformers for different clients (mobile, web, CLI) while sharing identical core business logic</li>
        </ul>
      </li>
    </ul>
    <p class="normal">This architectural foundation lets us confidently evolve our system. When the marketing team requests Salesforce integration, or when compliance requires audit logging, these capabilities can be added without<a id="_idIndexMarker268"/> disrupting existing functionality or compromising architectural integrity.</p>
    <p class="normal">In the next section, we’ll explore how to implement these concepts in Python, creating robust use case interactors that uphold the principles of Clean Architecture.</p>
    <h1 id="_idParaDest-123" class="heading-1"><a id="_idTextAnchor130"/>Implementing use case interactors</h1>
    <p class="normal">Having explored <a id="_idIndexMarker269"/>the theoretical foundations of the Application layer, we now turn to practical implementation. Use case interactors are the concrete classes that implement application-specific business rules. The term <em class="italic">interactors</em> emphasizes their role in interacting with and coordinating various parts of the system. While the Domain layer defines what the business rules are, interactors define how and when these rules are applied in response to specific application needs. In Python, we can implement these <a id="_idIndexMarker270"/>interactors in a way that’s both clean and expressive.</p>
    <h2 id="_idParaDest-124" class="heading-2"><a id="_idTextAnchor131"/>Structuring a use case</h2>
    <p class="normal">A well-designed<a id="_idIndexMarker271"/> use case interactor orchestrates domain objects while maintaining clean architectural boundaries. Let’s examine how this is achieved:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@dataclass(</span><span class="hljs-params">frozen=</span><span class="hljs-literal">True</span><span class="hljs-meta">)</span>
<span class="hljs-keyword">class</span> <span class="hljs-title">CompleteTaskUseCase</span>:
    <span class="hljs-string">"""Use case for marking a task as complete and notifying </span>
    <span class="hljs-string">stakeholders"""</span>
    task_repository: TaskRepository
<span class="hljs-keyword">def</span> <span class="hljs-title">execute</span>(
<span class="hljs-params">        self,</span>
<span class="hljs-params">        task_id: UUID,</span>
<span class="hljs-params">        completion_notes: </span><span class="hljs-type">Optional</span><span class="hljs-params">[</span><span class="hljs-built_in">str</span><span class="hljs-params">] = </span><span class="hljs-literal">None</span>
<span class="hljs-params">    </span>) -&gt; Result:
...
</code></pre>
    <p class="normal">First, looking at the outer structure of a use case, we see some key components. Dependency interfaces are injected, and the class has a public <code class="inlineCode">execute</code> method that returns a <code class="inlineCode">Result</code> object.</p>
    <p class="normal">Next, let’s examine the <code class="inlineCode">execute</code> method:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span> <span class="hljs-title">execute</span>(
<span class="hljs-params">        self,</span>
<span class="hljs-params">        task_id: UUID,</span>
<span class="hljs-params">        completion_notes: </span><span class="hljs-type">Optional</span><span class="hljs-params">[</span><span class="hljs-built_in">str</span><span class="hljs-params">] = </span><span class="hljs-literal">None</span>
<span class="hljs-params">    </span>) -&gt; Result:
        <span class="hljs-keyword">try</span>:
            <span class="hljs-comment"># Input validation</span>
            task = <span class="hljs-variable">self</span>.task_repository.get(task_id)
            task.complete(
                notes=completion_notes
            )
            <span class="hljs-variable">self</span>.task_repository.save(task)
           
            <span class="hljs-comment"># Return simplified task data</span>
            <span class="hljs-keyword">return</span> Result.success({
                <span class="hljs-string">"id"</span>: <span class="hljs-built_in">str</span>(task.<span class="hljs-built_in">id</span>),
                <span class="hljs-string">"status"</span>: <span class="hljs-string">"completed"</span>,
                <span class="hljs-string">"completion_date"</span>: task.completed_at.isoformat()
            })
           
        <span class="hljs-keyword">except</span> TaskNotFoundError:
            <span class="hljs-keyword">return</span> Result.failure(Error.not_found(<span class="hljs-string">"Task"</span>, <span class="hljs-built_in">str</span>(task_id)))
        <span class="hljs-keyword">except</span> ValidationError <span class="hljs-keyword">as</span> e:
            <span class="hljs-keyword">return</span> Result.failure(Error.validation_error(<span class="hljs-built_in">str</span>(e)))
</code></pre>
    <p class="normal">Here, we can see the<a id="_idIndexMarker272"/> orchestration of business rules upon the <code class="inlineCode">Task</code> domain object to accomplish the discrete goal of the use case: completing the task.</p>
    <p class="normal">This implementation embodies several key architectural principles:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Encapsulation</strong>: The use<a id="_idIndexMarker273"/> case class provides a clear boundary around a specific business operation.</li>
      <li class="bulletList"><strong class="keyWord">Interface definition</strong>: The <code class="inlineCode">execute</code> method provides a clean, focused interface using the result type. The result pattern ensures both success and failure paths are explicit in our interface, making error handling a first-class concern.</li>
      <li class="bulletList"><strong class="keyWord">Error handling</strong>: Domain errors are caught and translated into application-level errors.</li>
      <li class="bulletList"><strong class="keyWord">Dependency injection</strong>: Dependencies are passed in through the constructor, adhering to the Dependency Inversion Principle introduced in <a href="Chapter_02.xhtml#_idTextAnchor040"><em class="italic">Chapter 2</em></a>.</li>
    </ul>
    <p class="normal">Of these principles, dependency injection deserves special attention as it enables much of our architectural flexibility.</p>
    <h2 id="_idParaDest-125" class="heading-2"><a id="_idTextAnchor132"/>Dependency injection</h2>
    <p class="normal">Earlier we saw<a id="_idIndexMarker274"/> how dependency injection helps maintain clean architectural boundaries in our use cases. Let’s expand on this by examining how to structure our interfaces to maximize the benefits of dependency injection while ensuring our use cases remain flexible and testable. In Python, we can implement this elegantly using abstract base classes:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span> <span class="hljs-title">TaskRepository</span>(<span class="hljs-title">ABC</span>):
    <span class="hljs-string">"""Repository interface defined by the Application Layer"""</span>
<span class="hljs-meta">    @abstractmethod</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title">get</span>(<span class="hljs-params">self, task_id: UUID</span>) -&gt; Task:
        <span class="hljs-string">"""Retrieve a task by its ID"""</span>
        <span class="hljs-keyword">pass</span>
       
<span class="hljs-meta">    @abstractmethod</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title">save</span>(<span class="hljs-params">self, task: Task</span>) -&gt; <span class="hljs-literal">None</span>:
        <span class="hljs-string">"""Save a task to the repository"""</span>
        <span class="hljs-keyword">pass</span>
       
<span class="hljs-meta">    @abstractmethod</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title">delete</span>(<span class="hljs-params">self, task_id: UUID</span>) -&gt; <span class="hljs-literal">None</span>:
        <span class="hljs-string">"""Delete a task from the repository"""</span>
        <span class="hljs-keyword">pass</span>
<span class="hljs-keyword">class</span> <span class="hljs-title">NotificationService</span>(<span class="hljs-title">ABC</span>):
    <span class="hljs-string">"""Service interface for sending notifications"""</span>
<span class="hljs-meta">    @abstractmethod</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title">notify_task_assigned</span>(<span class="hljs-params">self, task_id: UUID</span>) -&gt; <span class="hljs-literal">None</span>:
        <span class="hljs-string">"""Notify when a task is assigned"""</span>
        <span class="hljs-keyword">pass</span>
<span class="hljs-meta">    @abstractmethod</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title">notify_task_completed</span>(<span class="hljs-params">self, task: Task</span>) -&gt; <span class="hljs-literal">None</span>:
        <span class="hljs-string">"""Notify when a task is completed"""</span>
        Pass
</code></pre>
    <p class="normal">By defining these interfaces in the Application layer, we strengthen our architectural boundaries while providing clear contracts for outer layers to implement. This approach provides several advanced benefits beyond basic dependency injection:</p>
    <ul>
      <li class="bulletList">Interface definitions express exactly what the Application layer needs, no more and no less</li>
      <li class="bulletList">Abstract methods document the expected behavior through clear method signatures and docstrings</li>
      <li class="bulletList">The Application layer maintains control over its dependencies while remaining independent of their implementations</li>
      <li class="bulletList">Test implementations can focus on exactly what each use case requires</li>
    </ul>
    <p class="normal">A concrete <a id="_idIndexMarker275"/>implementation adhering to this contract might take a form such as this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span> <span class="hljs-title">MongoDbTaskRepository</span>(<span class="hljs-title">TaskRepository</span>):
    <span class="hljs-string">"""MongoDB implementation of the TaskRepository interface"""</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, client: MongoClient</span>):
        <span class="hljs-variable">self</span>.client = client
        <span class="hljs-variable">self</span>.db = client.task_management
        <span class="hljs-variable">self</span>.tasks = <span class="hljs-variable">self</span>.db.tasks
       
    <span class="hljs-keyword">def</span> <span class="hljs-title">get</span>(<span class="hljs-params">self, task_id: UUID</span>) -&gt; Task:
        <span class="hljs-string">"""Retrieve a task by its ID"""</span>
        document = <span class="hljs-variable">self</span>.tasks.find_one({<span class="hljs-string">"_id"</span>: <span class="hljs-built_in">str</span>(task_id)})
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> document:
            <span class="hljs-keyword">raise</span> TaskNotFoundError(task_id)
        <span class="hljs-comment"># ... remainder of method implementation</span>
       
    <span class="hljs-comment"># Other interface methods implemented ...</span>
</code></pre>
    <p class="normal">This example demonstrates how outer layers can implement the interfaces defined by our Application layer, handling<a id="_idIndexMarker276"/> the specifics of data persistence while adhering to the contract our business logic expects.</p>
    <h2 id="_idParaDest-126" class="heading-2"><a id="_idTextAnchor133"/>Handling complex operations</h2>
    <p class="normal">Real-world use cases <a id="_idIndexMarker277"/>often involve multiple steps and potential failure points. Let’s examine how to manage this complexity while maintaining Clean Architecture principles. Consider a project completion scenario that requires the coordination of multiple tasks.</p>
    <p class="normal">The <code class="inlineCode">CompleteProjectUseCase</code> follows our established pattern:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@dataclass(</span><span class="hljs-params">frozen=</span><span class="hljs-literal">True</span><span class="hljs-meta">)</span>
<span class="hljs-keyword">class</span> <span class="hljs-title">CompleteProjectUseCase</span>:
    project_repository: ProjectRepository
    task_repository: TaskRepository
    notification_service: NotificationService
    <span class="hljs-keyword">def</span> <span class="hljs-title">execute</span>(
<span class="hljs-params">        self,</span>
<span class="hljs-params">        project_id: UUID,</span>
<span class="hljs-params">        completion_notes: </span><span class="hljs-type">Optional</span><span class="hljs-params">[</span><span class="hljs-built_in">str</span><span class="hljs-params">] = </span><span class="hljs-literal">None</span>
<span class="hljs-params">    </span>) -&gt; Result:
        ...
</code></pre>
    <p class="normal">Now, let’s examine its <code class="inlineCode">execute</code> method:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span> <span class="hljs-title">execute</span>(
<span class="hljs-params">        self,</span>
<span class="hljs-params">        project_id: UUID,</span>
<span class="hljs-params">        completion_notes: </span><span class="hljs-type">Optional</span><span class="hljs-params">[</span><span class="hljs-built_in">str</span><span class="hljs-params">] = </span><span class="hljs-literal">None</span>
<span class="hljs-params">    </span>) -&gt; Result:
        <span class="hljs-keyword">try</span>:
            <span class="hljs-comment"># Validate project exists</span>
            project = <span class="hljs-variable">self</span>.project_repository.get(project_id)
           
            <span class="hljs-comment"># Complete all outstanding tasks</span>
            <span class="hljs-keyword">for</span> task <span class="hljs-keyword">in</span> project.incomplete_tasks:
                task.complete()
                <span class="hljs-variable">self</span>.task_repository.save(task)
                <span class="hljs-variable">self</span>.notification_service.notify_task_completed(task)
            <span class="hljs-comment"># Complete the project itself</span>
            project.mark_completed(
                notes=completion_notes
            )
            <span class="hljs-variable">self</span>.project_repository.save(project)
           
            <span class="hljs-keyword">return</span> Result.success({
                <span class="hljs-string">"id"</span>: <span class="hljs-built_in">str</span>(project.<span class="hljs-built_in">id</span>),
                <span class="hljs-string">"status"</span>: project.status,
                <span class="hljs-string">"completion_date"</span>: project.completed_at,
                <span class="hljs-string">"task_count"</span>: <span class="hljs-built_in">len</span>(project.tasks),
                <span class="hljs-string">"completion_notes"</span>: project.completion_notes,
            })
           
        <span class="hljs-keyword">except</span> ProjectNotFoundError:
            <span class="hljs-keyword">return</span> Result.failure(Error.not_found(
<span class="hljs-keyword">                </span><span class="hljs-string">"Project"</span>, <span class="hljs-built_in">str</span>(project_id)))
        <span class="hljs-keyword">except</span> ValidationError <span class="hljs-keyword">as</span> e:
            <span class="hljs-keyword">return</span> Result.failure(Error.validation_error(<span class="hljs-built_in">str</span>(e)))
</code></pre>
    <p class="normal">This implementation<a id="_idIndexMarker278"/> demonstrates several patterns for managing complexity:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Coordinated operations</strong>: The use case manages multiple related operations as a single logical unit:<ul>
          <li class="bulletList level-2">Completing all outstanding tasks</li>
          <li class="bulletList level-2">Updating the project status</li>
          <li class="bulletList level-2">Notifying stakeholders</li>
        </ul>
      </li>
      <li class="bulletList"><strong class="keyWord">Error management</strong>: The use case provides comprehensive error handling:<ul>
          <li class="bulletList level-2">Domain-specific errors are caught and translated.</li>
          <li class="bulletList level-2">Each operation’s potential failures are considered. In a more involved example, you might see a rollback of the <code class="inlineCode">Task</code> saves if the <code class="inlineCode">Project</code> update or save failed.</li>
          <li class="bulletList level-2">Error responses are consistent and informative.</li>
        </ul>
      </li>
      <li class="bulletList"><strong class="keyWord">Clear dependencies</strong>: Required services are explicitly defined:<ul>
          <li class="bulletList level-2">Defining repositories for data access</li>
          <li class="bulletList level-2">Providing notification services for external communication</li>
          <li class="bulletList level-2">Injecting dependencies for flexibility and testing</li>
        </ul>
      </li>
      <li class="bulletList"><strong class="keyWord">Input validation</strong>: Parameters are validated before processing:<ul>
          <li class="bulletList level-2">Required IDs are checked for existence</li>
          <li class="bulletList level-2">Optional parameters are handled appropriately</li>
          <li class="bulletList level-2">Domain rules are enforced</li>
        </ul>
      </li>
      <li class="bulletList"><strong class="keyWord">Transactional integrity</strong>: Changes to both tasks and projects are handled as a cohesive operation:<ul>
          <li class="bulletList level-2">The code example could be extended to support true transactionality by just capturing the starting state and then rolling back if one of our statements fails. See the code for <code class="inlineCode">CompleteProjectUseCase</code> in the book’s accompanying GitHub repository for an example of this.</li>
        </ul>
      </li>
    </ul>
    <p class="normal">By applying these patterns consistently across our Application layer, we create a robust system that handles complex<a id="_idIndexMarker279"/> operations gracefully while maintaining clean architectural boundaries and clear separation of concerns.</p>
    <h1 id="_idParaDest-127" class="heading-1"><a id="_idTextAnchor134"/>Defining request and response models</h1>
    <p class="normal">In the previous section, our use cases worked directly with primitive types and dictionaries. While this approach can work for simple cases, as our application grows, we need more structured ways to handle data crossing our architectural boundaries. Request and response models serve this purpose, providing specialized DTOs that handle data transformation between the outer layers and our application core. Building on the information hiding principles we introduced earlier, these models extend this concept to architectural boundaries, specifically protecting our domain logic from external format details while shielding external interfaces from domain implementation specifics. This reciprocal boundary protection is particularly important as different interfaces evolve at different rates.</p>
    <h2 id="_idParaDest-128" class="heading-2"><a id="_idTextAnchor135"/>Request models</h2>
    <p class="normal"><strong class="keyWord">Request models</strong> capture <a id="_idIndexMarker280"/>and validate incoming data before it reaches our <a id="_idIndexMarker281"/>Application layer’s use cases. They provide a clear structure for input data and perform preliminary validation:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@dataclass(</span><span class="hljs-params">frozen=</span><span class="hljs-literal">True</span><span class="hljs-meta">)</span>
<span class="hljs-keyword">class</span> <span class="hljs-title">CompleteProjectRequest</span>:
    <span class="hljs-string">"""Data structure for project completion requests"""</span>
    project_id: <span class="hljs-built_in">str</span>  <span class="hljs-comment"># From API (will be converted to UUID)</span>
    completion_notes: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">str</span>] = <span class="hljs-literal">None</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title">__post_init__</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-literal">None</span>:
        <span class="hljs-string">"""Validate request data"""</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-variable">self</span>.project_id.strip():
            <span class="hljs-keyword">raise</span> ValidationError(<span class="hljs-string">"Project ID is required"</span>)
        <span class="hljs-keyword">if</span> <span class="hljs-variable">self</span>.completion_notes <span class="hljs-keyword">and</span> <span class="hljs-built_in">len</span>(<span class="hljs-variable">self</span>.completion_notes) &gt; <span class="hljs-number">1000</span>:
            <span class="hljs-keyword">raise</span> ValidationError(
<span class="hljs-keyword">                </span><span class="hljs-string">"Completion notes cannot exceed 1000 characters"</span>)
    <span class="hljs-keyword">def</span> <span class="hljs-title">to_execution_params</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">dict</span>:
        <span class="hljs-string">"""Convert validated request data to use case parameters"""</span>
        <span class="hljs-keyword">return</span> {
            <span class="hljs-string">'project_id'</span>: UUID(<span class="hljs-variable">self</span>.project_id),
            <span class="hljs-string">'completion_notes'</span>: <span class="hljs-variable">self</span>.completion_notes
        }
</code></pre>
    <p class="normal">Request models serve multiple architectural purposes by establishing a clear boundary between outer and inner layers. Through input validation and the <code class="inlineCode">to_execution_params</code> method, they ensure that use cases remain focused purely on business logic. The validation step catches malformed data early, while <code class="inlineCode">to_execution_params</code> transforms API-friendly formats (such as string IDs) into proper domain types (such as UUIDs) that our business logic expects.</p>
    <p class="normal">This transformation capability is particularly powerful as it:</p>
    <ul>
      <li class="bulletList">Keeps use cases clean and focused, working only with domain types</li>
      <li class="bulletList">Centralizes data conversion logic in a single, predictable location</li>
      <li class="bulletList">Allows API formats to evolve without impacting core business logic</li>
      <li class="bulletList">Improves testability by providing clear format boundaries</li>
    </ul>
    <p class="normal">By the time data flows through a request model to reach our use cases, it has been both validated and transformed into<a id="_idIndexMarker282"/> the precise format our domain logic expects. This <a id="_idIndexMarker283"/>maintains Clean Architecture’s separation of concerns, ensuring that outer layer implementation details (such as how IDs are formatted in HTTP requests) never leak into our core business rules.</p>
    <h2 id="_idParaDest-129" class="heading-2"><a id="_idTextAnchor136"/>Response models</h2>
    <p class="normal"><strong class="keyWord">Response models</strong> handle<a id="_idIndexMarker284"/> the transformation of domain objects into<a id="_idIndexMarker285"/> structures suitable for external consumption. They maintain our clean architectural boundaries by explicitly controlling what domain data is exposed and how it’s formatted:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@dataclass(</span><span class="hljs-params">frozen=</span><span class="hljs-literal">True</span><span class="hljs-meta">)</span>
<span class="hljs-keyword">class</span> <span class="hljs-title">CompleteProjectResponse</span>:
    <span class="hljs-string">"""Data structure for project completion responses"""</span>
    <span class="hljs-built_in">id</span>: <span class="hljs-built_in">str</span>
    status: <span class="hljs-built_in">str</span>
    completion_date: <span class="hljs-built_in">str</span>
    task_count: <span class="hljs-built_in">int</span>
    completion_notes: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">str</span>]
<span class="hljs-meta">    @classmethod</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title">from_entity</span>(<span class="hljs-params">cls,</span>
<span class="hljs-keyword">                    </span><span class="hljs-params">project: Project,</span>
<span class="hljs-params">                    user_service: UserService</span>
<span class="hljs-params">    </span>) -&gt; <span class="hljs-string">'CompleteProjectResponse'</span>:
        <span class="hljs-string">"""Create response from domain entities"""</span>
        <span class="hljs-keyword">return</span> cls(
            <span class="hljs-built_in">id</span>=<span class="hljs-built_in">str</span>(project.<span class="hljs-built_in">id</span>),
            status=project.status,
            completion_date=project.completed_at,
            task_count=<span class="hljs-built_in">len</span>(project.tasks),
            completion_notes=project.completion_notes,
        )
</code></pre>
    <p class="normal">While <code class="inlineCode">to_execution_params</code> of the request model transforms inbound data to match domain expectations, <code class="inlineCode">from_entity</code> handles the outbound journey by converting domain objects into formats suitable to traverse the boundary to the Adapters layer. This symmetrical pattern means our use cases can work purely with domain objects while both input and output are automatically adapted to external needs.</p>
    <p class="normal">The <code class="inlineCode">from_entity</code> method serves several key purposes:</p>
    <ul>
      <li class="bulletList">Protects domain objects from exposure to external layers</li>
      <li class="bulletList">Controls exactly what data is exposed and in what format (e.g., converting UUIDs back to strings)</li>
      <li class="bulletList">Provides a consistent serialization point for all external interfaces</li>
      <li class="bulletList">Allows computed or derived fields (such as <code class="inlineCode">task_count</code>) without modifying domain objects</li>
      <li class="bulletList">Includes computed or aggregate data not present in the base entity</li>
      <li class="bulletList">Optimizes performance by omitting large amounts of irrelevant data</li>
      <li class="bulletList">Includes operation-specific metadata</li>
    </ul>
    <p class="normal">Let’s revisit an evolved <a id="_idIndexMarker286"/>version of the <code class="inlineCode">CompleteProjectUseCase</code> to show <a id="_idIndexMarker287"/>how request models, domain logic, and response models work together:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@dataclass(</span><span class="hljs-params">frozen=</span><span class="hljs-literal">True</span><span class="hljs-meta">)</span>
<span class="hljs-keyword">class</span> <span class="hljs-title">CompleteProjectUseCase</span>:
    project_repository: ProjectRepository
    task_repository: TaskRepository
    notification_service: NotificationService
    <span class="hljs-comment"># Using CompleteProjectRequest vs discreet parameters</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title">execute</span>(<span class="hljs-params">self, request: CompleteProjectRequest</span>) -&gt; Result:
        <span class="hljs-keyword">try</span>:
            params = request.to_execution_params()
            project = <span class="hljs-variable">self</span>.project_repository.get(params[<span class="hljs-string">"project_id"</span>])
            project.mark_completed(notes=params[<span class="hljs-string">"completion_notes"</span>])
            <span class="hljs-comment"># Complete all outstanding tasks</span>
            <span class="hljs-comment"># ... Truncated for brevity </span>
            <span class="hljs-variable">self</span>.project_repository.save(project)
            <span class="hljs-comment"># using CompleteProjectResponse vs handbuilt dict</span>
            response = CompleteProjectResponse.from_entity(project)
            <span class="hljs-keyword">return</span> Result.success(response)
        <span class="hljs-keyword">except</span> ProjectNotFoundError:
            <span class="hljs-keyword">return</span> Result.failure(
                Error.not_found(<span class="hljs-string">"Project"</span>, <span class="hljs-built_in">str</span>(params[<span class="hljs-string">"project_id"</span>]))
            )
        <span class="hljs-keyword">except</span> ValidationError <span class="hljs-keyword">as</span> e:
            <span class="hljs-keyword">return</span> Result.failure(Error.validation_error(<span class="hljs-built_in">str</span>(e)))
</code></pre>
    <p class="normal">This example demonstrates how our use case remains focused purely on orchestrating domain logic while request and response models handle the necessary transformations at our architectural boundaries. The use case receives an already-validated request, works with proper domain types throughout its execution, and returns a response model wrapped in a <code class="inlineCode">Result</code> object that can be consumed by any outer layer implementation.</p>
    <p class="normal">In the Interface Adapters layer, these response models can be consumed by a variety of components including controllers handling HTTP requests, command-line interface command processors, or message<a id="_idIndexMarker288"/> queue handlers. Each adapter can transform the <a id="_idIndexMarker289"/>response data appropriately for its specific transport mechanism, converting it to JSON over HTTP, console output, or message payloads as needed.</p>
    <h1 id="_idParaDest-130" class="heading-1"><a id="_idTextAnchor137"/>Maintaining separation from external services</h1>
    <p class="normal">While request and <a id="_idIndexMarker290"/>response models handle data transformation at our API surface, our application must also interact with external services like email systems, file storage, and third-party APIs. The Application layer maintains separation from these services <a id="_idIndexMarker291"/>through <strong class="keyWord">ports</strong>— interfaces that define exactly what capabilities our application requires without specifying implementation details. In our task management system, external services might include:</p>
    <ul>
      <li class="bulletList">Email services for sending notifications (such as SendGrid or AWS SES)</li>
      <li class="bulletList">File storage systems for attachments (such as AWS S3 or Google Cloud Storage)</li>
      <li class="bulletList">Authentication services (such as Auth0 or Okta)</li>
      <li class="bulletList">Calendar integration services (such as Google Calendar or Microsoft Outlook)</li>
      <li class="bulletList">External messaging systems (such as Slack or Microsoft Teams)</li>
    </ul>
    <p class="normal">While request/response models and ports both serve to maintain clean architectural boundaries, they address different aspects of the system’s interaction with the outside world. Request/response models handle data transformation at our API boundaries, following consistent interfaces across all use cases (for example, <code class="inlineCode">from_entity</code> and <code class="inlineCode">to_execution_params</code>) to ensure uniform data handling.</p>
    <p class="normal">Ports, in contrast, define interfaces for the services our Application layer depends on with each port being specifically crafted to represent a particular external service’s capabilities. This dual approach ensures our <a id="_idIndexMarker292"/>core business logic remains independent of both data format details and external implementation specifics.</p>
    <h2 id="_idParaDest-131" class="heading-2"><a id="_idTextAnchor138"/>Interface boundaries</h2>
    <p class="normal">Ports allow the <a id="_idIndexMarker293"/>Application layer to specify exactly what capabilities it needs from external services without being coupled to specific implementations. Let’s examine how these boundary mechanisms work together:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># Port: Defines capability needed by Application Layer</span>
<span class="hljs-keyword">class</span> <span class="hljs-title">NotificationPort</span>(<span class="hljs-title">ABC</span>):
       
<span class="hljs-meta">    @abstractmethod</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title">notify_task_completed</span>(<span class="hljs-params">self, task: Task</span>) -&gt; <span class="hljs-literal">None</span>:
        <span class="hljs-string">"""Notify when a task is completed"""</span>
        <span class="hljs-keyword">pass</span>
    <span class="hljs-comment"># other capabilities as needed</span>
</code></pre>
    <p class="normal">This interface exemplifies information hiding at architectural boundaries. It reveals only the operations our Application layer needs while concealing all implementation details—whether notifications are sent via email, SMS, or another mechanism remains completely hidden from our core business logic.</p>
    <p class="normal">Then, in each use case, we might leverage the defined port like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@dataclass</span>
<span class="hljs-keyword">class</span> <span class="hljs-title">SetTaskPriorityUseCase</span>:
    task_repository: TaskRepository
    notification_service: NotificationPort <span class="hljs-comment"># Depends on </span>
                                           <span class="hljs-comment"># capability interface</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title">execute</span>(<span class="hljs-params">self, request: SetTaskPriorityRequest</span>) -&gt; Result:
        <span class="hljs-keyword">try</span>:
            params = request.to_execution_params()
           
            task = <span class="hljs-variable">self</span>.task_repository.get(params[<span class="hljs-string">'task_id'</span>])
            task.priority = params[<span class="hljs-string">'priority'</span>]
           
            <span class="hljs-variable">self</span>.task_repository.save(task)
           
            <span class="hljs-keyword">if</span> task.priority == Priority.HIGH:
                <span class="hljs-variable">self</span>.notification_service.notify_task_high_priority(task)
           
            <span class="hljs-keyword">return</span> Result.success(TaskResponse.from_entity(task))
        <span class="hljs-keyword">except</span> ValidationError <span class="hljs-keyword">as</span> e:
            <span class="hljs-keyword">return</span> Result.failure(Error.validation_error(<span class="hljs-built_in">str</span>(e)))
</code></pre>
    <p class="normal">This approach demonstrates the distinct roles of our boundary mechanisms:</p>
    <ul>
      <li class="bulletList">Request/response models handle the transformation of data at API boundaries</li>
      <li class="bulletList">Ports define the service capabilities our use cases need</li>
      <li class="bulletList">The Application layer uses both to maintain clean separation while coordinating the overall flow</li>
    </ul>
    <p class="normal">You might recall in our previous example in the <em class="italic">Handling complex operations</em> section that we referenced a concrete <code class="inlineCode">NotificationService</code>; here, we’ve matured our design by defining an abstract interface or port (<code class="inlineCode">NotificationPort</code>). This shift from implementation to interface better aligns with the Dependency Rule and provides clearer architectural boundaries.</p>
    <p class="normal">By depending only on the abstract capability interface rather than concrete implementations, our use case maintains information hiding in both directions: the use case knows nothing about notification implementation details, while notification services know nothing about use case internals beyond the <a id="_idIndexMarker294"/>parameters provided through the interface.</p>
    <p class="normal">We can now explore how to effectively manage the external dependencies these boundaries help us control.</p>
    <h2 id="_idParaDest-132" class="heading-2"><a id="_idTextAnchor139"/>Supporting evolving service requirements</h2>
    <p class="normal">As systems evolve, we need patterns that allow us to add new capabilities and adapt to changing service implementations. Let’s examine two key patterns for managing this evolution.</p>
    <h3 id="_idParaDest-133" class="heading-3"><a id="_idTextAnchor140"/>Supporting optional integration</h3>
    <p class="normal">As applications grow, we <a id="_idIndexMarker295"/>often want to make certain service integrations optional or environment-specific. The optional services pattern helps manage this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@dataclass(</span><span class="hljs-params">frozen=</span><span class="hljs-literal">True</span><span class="hljs-meta">)</span>
<span class="hljs-keyword">class</span> <span class="hljs-title">TaskManagementUseCase</span>:
    task_repository: TaskRepository
    notification_service: NotificationPort
    _optional_services: <span class="hljs-built_in">dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-type">Any</span>] = field(default_factory=<span class="hljs-built_in">dict</span>)
    <span class="hljs-keyword">def</span> <span class="hljs-title">register_service</span>(<span class="hljs-params">self, name: </span><span class="hljs-built_in">str</span><span class="hljs-params">, service: </span><span class="hljs-type">Any</span>) -&gt; <span class="hljs-literal">None</span>:
        <span class="hljs-string">"""Register an optional service"""</span>
        <span class="hljs-variable">self</span>._optional_services[name] = service
       
    <span class="hljs-keyword">def</span> <span class="hljs-title">complete_task</span>(<span class="hljs-params">self, task_id: UUID</span>) -&gt; Result:
        <span class="hljs-keyword">try</span>:
            task = <span class="hljs-variable">self</span>.task_repository.get(task_id)
            task.complete()
            <span class="hljs-variable">self</span>.task_repository.save(task)
           
            <span class="hljs-comment"># Required notification</span>
            <span class="hljs-variable">self</span>.notification_service.notify_task_completed(task)
           
            <span class="hljs-comment"># Optional integrations</span>
            <span class="hljs-keyword">if</span> analytics := <span class="hljs-variable">self</span>._optional_services.get(<span class="hljs-string">'analytics'</span>):
                analytics.track_task_completion(task.<span class="hljs-built_in">id</span>)
            <span class="hljs-keyword">if</span> audit := <span class="hljs-variable">self</span>._optional_services.get(<span class="hljs-string">'audit'</span>):
                audit.log_task_completion(task.<span class="hljs-built_in">id</span>)
               
            <span class="hljs-keyword">return</span> Result.success(TaskResponse.from_entity(task))
        <span class="hljs-keyword">except</span> ValidationError <span class="hljs-keyword">as</span> e:
            <span class="hljs-keyword">return</span> Result.failure(Error.validation_error(<span class="hljs-built_in">str</span>(e)))
</code></pre>
    <p class="normal">This approach provides several advantages:</p>
    <ul>
      <li class="bulletList">Core business operations remain focused and stable through the primary <code class="inlineCode">task_repository</code> and <code class="inlineCode">notification_service</code> dependencies</li>
      <li class="bulletList">New capabilities can be added without modifying existing code using the flexible <code class="inlineCode">_optional_services</code> dictionary</li>
      <li class="bulletList">Optional services can be configured based on deployment needs via the <code class="inlineCode">register_service</code> method</li>
      <li class="bulletList">Testing remains straightforward as dependencies are explicit in the constructor, with optional services clearly separated from the core requirements</li>
    </ul>
    <p class="normal">The use of a dictionary to store optional services combined with conditional execution (e.g., <code class="inlineCode">if analytics := self._optional_services.get('analytics')</code>) provides a clean pattern for gracefully handling<a id="_idIndexMarker296"/> features that may or may not be present in any given deployment.</p>
    <h3 id="_idParaDest-134" class="heading-3"><a id="_idTextAnchor141"/>Adapting to service changes</h3>
    <p class="normal">When integrating with <a id="_idIndexMarker297"/>third-party services or managing system upgrades, we often need to switch between different interfaces. The adapter pattern helps us manage this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span> <span class="hljs-title">ModernNotificationService</span>:
    <span class="hljs-string">"""Third-party service with a different interface"""</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title">send_notification</span>(<span class="hljs-params">self, payload: </span><span class="hljs-built_in">dict</span>) -&gt; <span class="hljs-literal">None</span>:
        <span class="hljs-comment"># Modern service implementation</span>
        <span class="hljs-keyword">pass</span>
<span class="hljs-keyword">class</span> <span class="hljs-title">ModernNotificationAdapter</span>(<span class="hljs-title">NotificationPort</span>):
    <span class="hljs-string">"""Adapts modern notification service to work with our interface"""</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, modern_service: ModernNotificationService</span>):
        <span class="hljs-variable">self</span>._service = modern_service
    
    <span class="hljs-keyword">def</span> <span class="hljs-title">notify_task_completed</span>(<span class="hljs-params">self, task: Task</span>) -&gt; <span class="hljs-literal">None</span>:
        <span class="hljs-variable">self</span>._service.send_notification({
            <span class="hljs-string">"type"</span>: <span class="hljs-string">"TASK_COMPLETED"</span>,
            <span class="hljs-string">"taskId"</span>: <span class="hljs-built_in">str</span>(task.<span class="hljs-built_in">id</span>)
        })
</code></pre>
    <p class="normal">The adapter pattern is particularly valuable in several scenarios:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Integrating with third-party services</strong>: The <code class="inlineCode">ModernNotificationService</code> can be wrapped without <a id="_idIndexMarker298"/>modifying its interface</li>
      <li class="bulletList"><strong class="keyWord">Managing system upgrades</strong>: The adapter’s translation layer (<code class="inlineCode">send_notification</code> to specific notification methods) isolates changes in service implementations</li>
      <li class="bulletList"><strong class="keyWord">Supporting multiple implementations</strong>: Different services can be adapted to the same <code class="inlineCode">NotificationPort</code> interface</li>
      <li class="bulletList"><strong class="keyWord">Transitioning between service versions</strong>: The mapping of structured payloads in <code class="inlineCode">notify_task_completed</code> allows protocol evolution while maintaining backward compatibility</li>
    </ul>
    <p class="normal">By using these patterns <a id="_idIndexMarker299"/>together, we can create systems that gracefully handle both optional features and changing service implementations while maintaining clean architectural boundaries.</p>
    <h1 id="_idParaDest-135" class="heading-1"><a id="_idTextAnchor142"/>Summary</h1>
    <p class="normal">In this chapter, we explored the Application layer of Clean Architecture, focusing on how it orchestrates domain objects and coordinates with external services to fulfill user needs. We learned how to implement use cases that maintain clean architectural boundaries while providing meaningful functionality.</p>
    <p class="normal">Through our task management system example, we discovered how to create use case interactors that coordinate domain objects while respecting the Dependency Rule introduced in <a href="Chapter_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>. We built upon the SOLID principles from <a href="Chapter_02.xhtml#_idTextAnchor040"><em class="italic">Chapter 2</em></a> and the type-awareness patterns from <a href="Chapter_03.xhtml#_idTextAnchor060"><em class="italic">Chapter 3</em></a> to create robust, maintainable implementations. Our use cases effectively orchestrate the domain objects and services we developed in <a href="Chapter_04.xhtml#_idTextAnchor091"><em class="italic">Chapter 4</em></a>, showing how Clean Architecture layers work together harmoniously.</p>
    <p class="normal">We implemented several key patterns and concepts:</p>
    <ul>
      <li class="bulletList">Use case interactors that orchestrate domain operations</li>
      <li class="bulletList">Request and response models that create clear boundaries</li>
      <li class="bulletList">Error handling patterns that maintain architectural separation</li>
      <li class="bulletList">Interface definitions that keep external concerns isolated</li>
    </ul>
    <p class="normal">These implementations demonstrated how to maintain the integrity of our architecture while handling real-world requirements. We saw how proper boundaries allow our application to evolve and adapt to changing needs without compromising its core design.</p>
    <p class="normal">In <a href="Chapter_06.xhtml#_idTextAnchor144"><em class="italic">Chapter 6</em></a>, we’ll explore how our clean boundaries enable the creation of effective adapters that translate between our Application layer and the outside world. We’ll see how the patterns we’ve established with request/response models and ports naturally extend to implementing controllers, gateways, and presenters.</p>
    <h1 id="_idParaDest-136" class="heading-1"><a id="_idTextAnchor143"/>Further reading</h1>
    <ul>
      <li class="bulletList"><em class="italic">Building Microservices: Designing Fine-Grained Systems</em> by Sam Newman. Although focused on microservices, this book’s chapters on service boundaries, inter-service communication, and data handling provide valuable insights for creating well-defined boundaries in application layers and can be applied to monolithic applications as well.</li>
      <li class="bulletList"><em class="italic">Hexagonal Architecture</em> by Alistair Cockburn (<a href="https://alistair.cockburn.us/hexagonal-architecture/"><span class="url">https://alistair.cockburn.us/hexagonal-architecture/</span></a>). This article explains the ports and adapters (or hexagonal architecture) pattern, which is highly complementary to Clean Architecture principles. It provides a clear understanding of managing dependencies and boundary translation, which are central to implementing the Application layer.</li>
    </ul>
  </div>
</div></div></body></html>