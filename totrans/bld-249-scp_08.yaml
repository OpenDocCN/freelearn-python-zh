- en: Chapter 8. Rendering and Image Manipulation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 8 章。渲染和图像处理
- en: In the previous chapters, we looked mainly at the scripting aspects of the individual
    components that make up a Blender scene such as meshes, lamps, materials, and
    so on. In this chapter, we will turn to the rendering process as a whole. We will
    automate this rendering process, combine the resulting images in various ways,
    and even turn Blender into a specialized web server.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们主要关注构成 Blender 场景的各个组件的脚本方面，例如网格、灯光、材质等。在本章中，我们将转向整个渲染过程。我们将自动化这个渲染过程，以各种方式组合生成的图像，甚至将
    Blender 转换为一个专门的 Web 服务器。
- en: 'In this chapter, you will learn how to:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何：
- en: Automate the rendering process
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化渲染过程
- en: Create multiple views for product presentations
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为产品展示创建多个视图
- en: Create billboards from complex objects
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从复杂对象创建广告牌
- en: Manipulate images, including render results, by using the Python Imaging Library
    (PIL)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Python 图像处理库 (PIL) 处理图像，包括渲染结果
- en: Create a server that creates on-demand images that may be used as CAPTCHA challenges
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个按需生成图像的服务器，这些图像可以用作 CAPTCHA 挑战
- en: Create a contact sheet
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建联系表
- en: A different view—combining multiple camera angles
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同的视角——结合多个摄像机角度
- en: By now, you might expect that rendering can be automated as well, and you're
    quite right. The Blender Python API provides access to almost all parameters of
    the rendering process and lets you render individual frames as well as animations.
    This allows for automating many tasks that would be tedious to do by hand.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你可能期望渲染也可以自动化，你完全正确。Blender Python API 提供了对渲染过程几乎所有参数的访问，并允许你渲染单个帧以及动画。这允许自动化许多手工操作起来繁琐的任务。
- en: Say you have created an object and want to create a single image that shows
    it from different angles. You could render these out separately and combine them
    in an external application, but we will write a script that not only renders these
    views but also combines them in a single image by using Blender's image manipulation
    capabilities and an external module called PIL. The effect we try to achieve is
    shown in the illustration of Suzanne, showing her from all of her best sides.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经创建了一个对象，并想创建一张从不同角度展示它的单张图像。你可以分别渲染这些图像，并在外部应用程序中合并它们，但我们将编写一个脚本，不仅渲染这些视图，而且通过使用
    Blender 的图像处理能力和一个名为 PIL 的外部模块，将它们合并到一张单独的图像中。我们试图达到的效果在苏珊娜的插图中有展示，展示了她最好的所有角度。
- en: '![A different view—combining multiple camera angles](img/0400-08-01.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![不同的视角——结合多个摄像机角度](img/0400-08-01.jpg)'
- en: Blender is an excellent tool that provides you not only with modeling, animating,
    and rendering options but has compositing functionality as well. One area that
    it does not excel in is "image manipulation". It does have an UV-editor/Image
    window of course, but that is very specifically engineered to manipulate UV maps
    and to view images rather than to manipulate them. The Node editor is also capable
    of sophisticated image manipulation but it has no documented API so it can't be
    configured from a script.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Blender 是一个出色的工具，它不仅提供了建模、动画和渲染选项，还具有合成功能。它不擅长的一个领域是“图像处理”。当然，它有一个 UV 编辑器/图像窗口，但这个窗口非常具体地设计用于处理
    UV 映射和查看图像，而不是处理它们。节点编辑器也具有复杂的图像处理能力，但没有文档化的 API，因此不能通过脚本进行配置。
- en: Of course, Blender cannot do everything and surely it doesn't try to compete
    with packages such as **GIMP** ([www.gimp.org](http://www.gimp.org)), but some
    built-in image manipulation functions would have been welcomed. (Each image can
    be manipulated on the pixel level but this would be fairly slow on large images
    and we still would have to implement high-level functionality, such as alpha blending
    or rotating images.)
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，Blender 不能做所有的事情，而且它当然不试图与 **GIMP** ([www.gimp.org](http://www.gimp.org))
    等包竞争，但一些内置的图像处理功能会受到欢迎。（每个图像都可以在像素级别上进行处理，但在大图像上这会相当慢，我们仍然需要实现高级功能，如 alpha 混合或旋转图像。）
- en: Fortunately, we can access any image generated by Blender from Python, and in
    Python it is fairly simple to add additional packages that do provide the extra
    functionality and use them from our scripts. The only drawback is that any script
    that uses these additional libraries is not automatically portable so users would
    have to check that the relevant libraries are available to them.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们可以从Python访问Blender生成的任何图像，并且在Python中添加额外的包以提供额外功能并从我们的脚本中使用它们相当简单。唯一的缺点是，使用这些额外库的任何脚本都不是自动可移植的，因此用户必须检查相关的库是否可用。
- en: 'The **Python Imaging Library** (**PIL**) that we will be using is freely available
    and easy to install. Therefore, it should pose no problem for the average user.
    However, as it is possible to implement the simple pasting functionality (we will
    see below) using just Blender''s `Image` module, we do provide in the full code
    a minimalist module `pim` that implements just the bare minimum to be able to
    use our example without the need to install PIL. This independence comes at a
    price: our `paste()` function is almost 40 times slower than the one provided
    by PIL and the resulting image can be saved only in TARGA (`.tga`) format. But
    you probably won''t notice that as Blender can display TARGA files just fine.
    The full code is equipped with some trickery to use PIL (if it''s available) and
    our replacement module if it isn''t. (This is not shown in the book.)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要使用的**Python Imaging Library**（**PIL**）是免费提供的，并且易于安装。因此，对于普通用户来说，应该不会造成任何问题。然而，由于我们可以仅使用Blender的`Image`模块来实现简单的粘贴功能（我们将在下面看到），我们确实在完整代码中提供了一个极简模块`pim`，它仅实现了使用我们的示例而不需要安装PIL所需的最基本功能。这种独立性是有代价的：我们的`paste()`函数比PIL提供的函数慢了近40倍，并且生成的图像只能以TARGA（`.tga`）格式保存。但你可能不会注意到这一点，因为Blender可以很好地显示TARGA文件。完整代码配备了一些技巧，以便在PIL（如果可用）和我们的替代模块不可用的情况下使用。
    （这一点在书中没有展示。）
- en: Note
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**The Python Imaging Library (PIL)**'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python Imaging Library (PIL**)'
- en: PIL is an open source package available for free from [http://www.pythonware.com/products/pil/index.htm](http://www.pythonware.com/products/pil/index.htm).
    It consists of a number of Python modules and a core library that comes precompiled
    for Windows (and is easy enough to compile on Linux or might even be available
    in the distribution already). Just follow the instructions on the site to install
    it (just remember to use the correct python version to install PIL; if you have
    more than one version of Python installed, use the one Blender uses as well to
    install).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: PIL是一个开源软件包，可以从[http://www.pythonware.com/products/pil/index.htm](http://www.pythonware.com/products/pil/index.htm)免费获取。它由多个Python模块和一个预编译的核心库组成，该库适用于Windows（在Linux上编译也足够简单，甚至可能已经包含在发行版中）。只需遵循网站上的说明进行安装（只需记住使用正确的Python版本安装PIL；如果你安装了多个Python版本，请使用Blender使用的版本来安装PIL）。
- en: Code outline—combine.py
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码概要—combine.py
- en: 'What steps do we have to take to create our combined image? We will have to:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要采取哪些步骤来创建我们的合成图像？我们将必须：
- en: Create cameras if needed.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如有必要，创建相机。
- en: Frame the cameras on the subject.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将相机对准主题。
- en: Render views from all cameras.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从所有相机渲染视图。
- en: Combine the rendered images to a single image.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将渲染的图像合并为单个图像。
- en: 'The code starts off by importing all of the necessary modules. From the PIL
    package we need the `Image` module, but we import it under a different name (`pim`)
    to prevent name clashes with Blender''s `Image` module, which we will be using
    as well:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先导入所有必要的模块。从PIL包中，我们需要`Image`模块，但我们以不同的名称（`pim`）导入它，以防止与我们将要使用的Blender的`Image`模块发生名称冲突：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The first utility function that we encounter is `paste()`. This function will
    combine four images into one. The images are passed as filenames and the result
    is saved as `result.png` unless another output filename is specified. We assume
    all four images to have the same dimensions, which we determine by opening the
    first file as a PIL image and examining its `size` attribute (highlighted in the
    next code). The images will be separated and bordered by a small line with a solid
    color. The width and color are hardcoded as the `edge` and `edgecolor` variables,
    although you might consider passing them as arguments:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遇到的第一个实用函数是`paste()`。此函数将四个图像合并成一个。图像作为文件名传递，结果保存为`result.png`，除非指定了另一个输出文件名。我们假设所有四个图像具有相同的尺寸，我们通过打开第一个文件作为PIL图像并检查其`size`属性（在下一行代码中突出显示）来确定尺寸。图像将通过一条带有实色的小线分隔和边框。宽度和颜色被硬编码为`edge`和`edgecolor`变量，尽管你可能考虑将它们作为参数传递：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, we create an empty image big enough to hold the four images with the
    appropriate borders. We will not be drawing any borders specifically, but just
    defining the new image with a solid color onto which the four images will be pasted
    at a fitting offset:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个足够大的空图像，足以容纳四张图片以及适当的边框。我们不会专门绘制任何边框，但只是定义一个新的图像，用实色填充，然后在这张图像上粘贴四张图片，并适当地偏移：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We already opened the top image so all we have to do is paste it in the upper-left
    quadrant of our combined image offset in both the horizontal and vertical directions
    by the border width:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经打开了顶部的图片，所以我们只需将其粘贴到合并图片的左上象限中，同时在水平和垂直方向上偏移边框宽度：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Pasting the three other images follows the same line: open the image and paste
    it at the correct position. Finally, the combined image is saved (highlighted).
    The file type of the saved image is determined by its extension (for example,
    `png`) but might have been overridden had we passed a format argument to the `save()`
    method. Note that there was no reason to specify a format for the input files
    as the image type is determined from its contents by the `open()` function.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 将其他三张图片粘贴的过程遵循相同的步骤：打开图片并将其粘贴到正确的位置。最后，合并后的图片被保存（突出显示）。保存的图片文件类型由其扩展名（例如，`png`）确定，但如果我们在`save()`方法中传递了格式参数，则可能会被覆盖。请注意，没有必要指定输入文件的格式，因为`open()`函数会根据其内容确定图像类型。
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Our next function renders the view from a specific camera and saves the result
    to a file. The camera to render is passed as the name of the Blender Object (that
    is, not the name of the underlying `Camera` object). The first line retrieves
    the `Camera` object and the current scene and makes the camera current in the
    scene—the one that will be rendered (highlighted below). `setCurrentCamera()`
    takes a Blender Object, not a `Camera` object, and that's the reason we passed
    the name of the object.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一个函数从特定的相机渲染视图并将结果保存到文件。要渲染的相机作为Blender对象的名称传递（即不是底层`Camera`对象的名称）。第一行检索`Camera`对象和当前场景，并在场景中使相机成为当前状态——即将要渲染的（在下面突出显示）。`setCurrentCamera()`接受一个Blender对象，而不是`Camera`对象，这就是我们传递对象名称的原因。
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As we might use this function in a **background** **process** we will be using
    the `renderAnim()` method of the rendering context rather than the `render()`
    method. This is because the `render()` method cannot be used in a background process.
    Therefore, we set the current frame and both the start and end frames to the same
    value to ensure that `renderAnim()` will render just a single frame. We also set
    `displayMode` to `0` to prevent an extra render window popping up (highlighted
    in the next code snippet):'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们可能会在**后台****进程**中使用此函数，我们将使用渲染上下文的`renderAnim()`方法而不是`render()`方法。这是因为`render()`方法不能在后台进程中使用。因此，我们将当前帧以及起始帧和结束帧设置为相同的值，以确保`renderAnim()`只会渲染一个帧。我们还设置`displayMode`为`0`以防止弹出额外的渲染窗口（在下一代码片段中突出显示）：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `renderAnim()` method renders frames to files so our next task is to retrieve
    the filename of the frame that we just rendered. The exact format of the filename
    may be specified by the user in the **User** **Preferences** window, but by calling
    `getFrameFilename()` explicitly we ensure that we get the right one:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`renderAnim()`方法将帧渲染到文件中，因此我们的下一个任务是检索我们刚刚渲染的帧的文件名。确切的文件名格式可以由用户在**用户****首选项**窗口中指定，但通过显式调用`getFrameFilename()`，我们确保我们得到正确的一个：'
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As the frame number will be the same for each camera view that we render, we
    will have to rename this file otherwise it would be overwritten. Therefore, we
    create a suitable new name consisting of the path of the frame we just rendered
    and the name of the camera. We use portable path manipulation functions from Python's
    `os.path` module so everything will work just as well under Windows as on Linux,
    for example.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个渲染的相机视图的帧编号都将相同，我们必须重命名此文件，否则它将被覆盖。因此，我们创建一个合适的新名称，由我们刚刚渲染的帧的路径和相机的名称组成。我们使用来自Python的`os.path`模块的可移植路径操作函数，以确保在Windows上和在Linux上都能正常工作。
- en: 'As our script may have been used already, we try to remove any existing file
    with the same name because renaming a file to an existing filename will fail under
    Windows. Of course, there might not be a file yet—a situation we guard against
    in the `try` block. Finally, our function returns the name of the newly created
    file:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的脚本可能已经被使用，我们尝试删除任何具有相同名称的现有文件，因为在Windows下将文件重命名为现有文件名将失败。当然，可能还没有文件——这种情况我们在`try`块中进行了保护。最后，我们的函数返回新创建的文件名：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The next important task is to frame the cameras, that is, to choose a suitable
    **camera angle** for all of the cameras in such a way that the subject fits the
    available area in the picture in an optimal way. We want the camera angle to be
    the same for all cameras to provide the viewer with a consistent perspective from
    all viewing angles. Of course, this could be done manually, but this is tedious
    so we define a function to do the work for us.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个重要任务是设置相机框架，即选择一个合适的 **相机角度**，以便所有相机都能以最佳方式适应图片中的可用区域。我们希望所有相机的角度都相同，以便从所有观察角度为观众提供一致的角度。当然，这可以手动完成，但这很繁琐，所以我们定义了一个函数来为我们完成这项工作。
- en: The way we do this is to take the **bounding box** of our subject and determine
    the viewing angle of the camera by assuming that this bounding box must just fill
    our view. Because we can calculate the distance of the camera to the center of
    the bounding box, the viewing angle must be the same as the acute angle of the
    triangle formed by the bounding box and the camera distance.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这样做是通过取我们主题的 **边界框** 并通过假设这个边界框必须刚好填满我们的视图来确定相机的观察角度。因为我们可以计算相机到边界框中心的距离，所以观察角度必须与边界框和相机距离形成的三角形的锐角相同。
- en: '![Code outline—combine.py](img/0400-08-02.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![代码概要—combine.py](img/0400-08-02.jpg)'
- en: We calculate this angle for all of the cameras and then set the camera angle
    for each camera to the widest angle calculated to prevent unwanted clipping of
    our subject. Note that this algorithm may fail if the cameras are too close to
    the subject (or equivalently, if the subject is too large), in which case some
    clipping may occur.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为所有相机计算这个角度，然后为每个相机设置最宽的角度，以防止对主题的不希望出现的裁剪。请注意，如果相机离主题太近（或者等价地，如果主题太大），则此算法可能会失败，在这种情况下可能会发生一些裁剪。
- en: 'The code is pretty heavy on the math, so we start off by importing the necessary
    functions:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 代码在数学上相当复杂，所以我们首先导入必要的函数：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The function itself will take a list of names of Blender objects (the cameras)
    and a bounding box (a list of vectors, one for each corner of the bounding box).
    It starts off by determining the minimum and maximum extents of the bounding box
    for all three axes and the widths. We assume that our subject is centered on the
    origin. `maxw` will hold the largest width along any axis.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数本身将接受一个Blender对象（相机）名称列表和一个边界框（一个向量列表，每个边界框的一个角对应一个向量）。它首先确定所有三个轴和宽度的边界框的最小和最大范围。我们假设我们的主题位于原点中心。`maxw`
    将保存任何轴上的最大宽度。
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, we get the world space coordinates for each `Camera` object to calculate
    the distance `d` to the midpoint of the bounding box (highlighted in the next
    code). We store the quotient of maximum width and distance:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们获取每个 `Camera` 对象的世界空间坐标，以计算到边界框中点的距离 `d`（下一行代码中突出显示）。我们存储最大宽度和距离的商：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We take the largest quotient calculated (as this will amount to the widest angle)
    and determine the angle by calculating the arc sinus and finish by setting the
    `lens` attribute of the `Camera` object. The relation between camera's viewing
    angle and the value of the `lens` attribute in Blender is complex and scarcely
    documented (`lens` holds an approximation of the focal length of an ideal lens).
    The formula shown is the one taken from Blender's source code (highlighted).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们取计算出的最大商（这将相当于最宽的角度），通过计算反正弦来确定角度，并通过设置 `Camera` 对象的 `lens` 属性来完成。相机观察角度与Blender中
    `lens` 属性值之间的关系复杂且很少被记录（`lens` 包含理想镜头焦距的近似值）。显示的公式是从Blender源代码中取出的（突出显示）。
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Another convenience function is the one that defines four cameras and puts
    them into the scene suitably arranged around the origin. The function is straightforward
    in principle but is a little bit complicated because it tries to reuse existing
    cameras with the same name to prevent unwanted proliferation of cameras if the
    script is run more than once. The `cameras` dictionary is indexed by name and
    holds a list of positions, rotations, and lens values:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个便利函数是定义四个相机并将它们适当地围绕原点排列到场景中的函数。在原则上，这个函数很简单，但它稍微复杂一些，因为它试图重用具有相同名称的现有相机，以防止在脚本运行多次时出现不希望的相机数量激增。`cameras`
    字典按名称索引，并包含位置、旋转和镜头值列表：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'For each camera in the `cameras` dictionary we check if it already exists as
    a Blender object. If it does, we check whether the Blender object has a `Camera`
    object associated with it. If the latter is not true we create a perspective camera
    with the same name as the top-level object (highlighted) and associate it with
    the top-level object by way of the `link()` method:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`cameras`字典中的每个相机，我们检查它是否已经作为一个Blender对象存在。如果存在，我们检查Blender对象是否与其关联了一个`Camera`对象。如果后者不成立，我们创建一个与顶级对象同名的透视相机（高亮显示），并通过`link()`方法将其与顶级对象关联起来：
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If there wasn''t a top-level object present already we create one and associate
    a new perspective `Camera` object with it:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有现有的顶级对象，我们创建一个并与之关联一个新的透视`Camera`对象：
- en: '[PRE15]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We end by setting the `location`, `rotation`, and `lens` attributes. Note that
    the rotation angles are in radians so we convert them from the more intuitive
    degrees that we used in our table (highlighted). We end by calling `Redraw()`
    to make the changes show up in the user interface:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过设置`location`、`rotation`和`lens`属性来结束。请注意，旋转角度是以弧度表示的，因此我们将它们从表格中更直观的度数（高亮显示）转换过来。最后，我们调用`Redraw()`方法，以便在用户界面中显示这些更改：
- en: '[PRE16]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, we define a `run()` method that strings all components together. It
    determines the active object and then cycles through a list of camera names to
    render each view and add the resulting filename to a list (highlighted):'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们定义一个`run()`方法，将所有组件连接起来。它确定活动对象，然后遍历相机名称列表以渲染每个视图，并将生成的文件名添加到列表中（高亮显示）：
- en: '[PRE17]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We will put the combined pictures in the same directory as the individual views
    and call it `result.png`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将组合的图片放在与单个视图相同的目录中，并将其命名为`result.png`：
- en: '[PRE18]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We then call our `paste()` function, passing the list of component filenames
    expanded as individual arguments by the asterisk (`*`) operator and end with a
    finishing touch of loading the result file as a Blender image and showing it in
    the image editor window (highlighted below). The `reload` is necessary to ensure
    that a previous image of the same name is refreshed:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们调用我们的`paste()`函数，通过星号（`*`）运算符将组件文件名展开为单独的参数，并以加载结果文件作为Blender图像并在图像编辑器窗口中显示（以下高亮显示）作为结束。`reload`是必要的，以确保刷新具有相同名称的先前图像：
- en: '[PRE19]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `run()` function deliberately did not create any cameras because the user
    might want to do that himself. The final script itself does take care of creating
    the cameras, but this might be changed quite easily and is as usual quite simple.
    After the check to see if it runs standalone it just creates the cameras and calls
    the `run` method:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`run()`函数故意没有创建任何相机，因为用户可能希望自行完成。最终脚本本身确实负责创建相机，但这可能很容易更改，并且通常很简单。在检查是否可以独立运行之后，它只是创建相机并调用`run`方法：'
- en: '[PRE20]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The full code is available as `combine.py` in `combine.blend`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码作为`combine.py`文件位于`combine.blend`中。
- en: Workflow—how to showcase your model
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作流程——如何展示你的模型
- en: 'The script can be used in the following way:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本可以使用以下方式使用：
- en: Put your subject at the origin (position (0, 0, 0)).
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的主题放置在原点（位置（0，0，0））。
- en: Create suitable lighting conditions.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建合适的照明条件。
- en: Run `combine.py`.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`combine.py`。
- en: The script may be loaded into the text editor to run with *Alt + P* but you
    may also put the script in Blender's `scripts` directory to make it available
    from the **Scripts | Render** menu.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过*Alt + P*将脚本加载到文本编辑器中运行，但你也可以将脚本放入Blender的`scripts`目录中，以便从**脚本 | 渲染**菜单中访问。通过**脚本
    | 渲染**菜单访问。
- en: Now, strip—creating a film strip from an animation
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现在，创建电影带——从动画中创建电影带
- en: Fitting multiple camera views to a single image is just one example where multiple
    images might be effectively combined to a single image. Another example is when
    we would like to show frames from an animation where we don't have access to facilities
    to replay the animation. In such situations we would like to show something resembling
    a film strip where we combine a small rendition of, for example, every tenth frame
    to a single sheet of images. An example is shown in the following illustration.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 将多个相机视图拟合到单个图像只是多个图像可能有效组合成单个图像的一个例子。另一个例子是当我们想展示动画的帧，而我们没有访问播放动画的设施时。在这种情况下，我们希望展示类似电影带的东西，我们将每第十帧的小版本组合到一张图像上。以下插图显示了示例。
- en: Although there are more images to combine than in the multiple camera view,
    the code to create such a film strip is fairly similar.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然组合的图像比多相机视图中的图像多，但创建此类电影带的代码相当相似。
- en: '![Now, strip—creating a film strip from an animation](img/0400-08-03.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![现在，strip——从动画创建电影条](img/0400-08-03.jpg)'
- en: The first function that we develop is `strip()` that takes a list of filenames
    of images to combine and an optional `name` that will be given to the combined
    image. A third optional argument is `cols`, which is the number of columns in
    the combined image. The default is four, but for long sequences it might be more
    natural to print on landscape paper and use a higher value here. The function
    will return a Blender `Image` object containing the combined image.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先开发的函数是`strip()`，它接受要组合的图像文件名列表和一个可选的`name`，该`name`将被赋予组合图像。第三个可选参数是`cols`，它是组合图像中的列数。默认值为四，但对于较长的序列，可能更自然地使用横向纸张并在此处使用更高的值。该函数将返回一个包含组合图像的Blender
    `Image`对象。
- en: 'We again use the `pim` module, which is either an alias for the PIL module
    if it''s available or will refer to our bare bones implementation if PIL is not
    available. The important difference with our previous image combination code is
    highlighted. The first highlighted part shows how to calculate the dimensions
    of the combined image based on the number of rows and columns plus the amount
    of pixels needed for the colored edges around images. The second highlighted line
    shows where we paste an image in the destination image:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次使用`pim`模块，如果PIL模块可用，则`pim`是PIL模块的别名，如果PIL不可用，则将引用我们的简化实现。与之前图像组合代码的重要区别被突出显示。第一个突出部分显示了如何根据行数、列数以及围绕图像的彩色边缘所需的像素数来计算组合图像的尺寸。第二个突出行显示了在目标图像中粘贴图像的位置：
- en: '[PRE21]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `render()` function that we define here will take the number of frames
    to skip as an argument and will render any number of frames between the start
    and end frames. These start and end frames may be set by the user in the render
    buttons. The render buttons also contain a step value, but this value is not provided
    to the Python API. This means that our function is a little bit more verbose than
    we like as we have to create a loop that renders each frame ourselves (highlighted
    in the next code) instead of just calling `renderAnim()`. We therefore have to
    manipulate the `startFrame` and `endFrame` attributes of the render context (as
    before) but we take care to restore those attributes before returning a list of
    filenames of the rendered images. If we did not need any programmatic control
    of setting the `skip` value, we could have simply replaced a call to `render()`
    by a call to `renderAnim()`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里定义的`render()`函数将接受要跳过的帧数作为参数，并将渲染从起始帧到结束帧之间的任意数量的帧。这些起始帧和结束帧可以由用户在渲染按钮中设置。渲染按钮还包含一个步进值，但此值不提供给Python
    API。这意味着我们的函数比我们希望的更冗长，因为我们必须创建一个循环来自己渲染每一帧（在下一代码中突出显示）而不是仅仅调用`renderAnim()`。因此，我们必须操作渲染上下文的`startFrame`和`endFrame`属性（如之前所述），但我们注意在返回渲染图像的文件名列表之前恢复这些属性。如果我们不需要任何程序控制来设置`skip`值，我们可以简单地用一个对`renderAnim()`的调用替换对`render()`的调用：
- en: '[PRE22]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'With these functions defined the script itself now simply calls `render()`
    to create the images and `strip()` to combine them. The resulting Blender image
    is reloaded to force an update if an image with the same name was already present
    and all windows are prompted to redraw themselves (highlighted):'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了这些函数后，脚本本身现在只需调用`render()`来创建图像，并调用`strip()`来组合它们。结果Blender图像被重新加载以强制更新，如果已存在具有相同名称的图像，并且所有窗口都会提示重新绘制自己（突出显示）：
- en: '[PRE23]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The full code is available as `strip.py` in `combine.blend`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 完整代码作为`strip.py`在`combine.blend`中可用。
- en: Workflow—using strip.py
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作流程——使用strip.py
- en: 'Creating a strip of animated frames can now be done as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以按照以下步骤创建动画帧条：
- en: Create your animation.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建您的动画。
- en: Run `strip.py` from the text editor.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从文本编辑器运行`strip.py`。
- en: The combined image will show up in the UV-editor/image window.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 组合图像将在UV编辑器/图像窗口中显示。
- en: Save the image with a name of your choice.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您选择的名称保存图片。
- en: Rendering billboards
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染广告牌
- en: Realism in scenes is often accomplished by providing lots of detail, especially
    in natural objects. However, this kind of realism comes with a price as detailed
    models often contain many faces and these faces consume memory and take time to
    render. A realistic tree model may contain as much as half a million faces so
    a forest of these would be almost impossible to render, even more so, if this
    forest is part of the scenery in a fast-paced game.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 场景中的现实主义通常是通过提供大量细节来实现的，尤其是在自然物体中。然而，这种现实主义是有代价的，因为详细的模型通常包含许多面，这些面消耗内存并需要时间来渲染。一个逼真的树木模型可能包含多达五十万个面，因此这样的森林几乎不可能渲染，尤其是在快速节奏的游戏场景中。
- en: Blender comes with a number of tools to reduce the amount of memory needed when
    rendering many copies of an object; different `Mesh` objects may refer to the
    same mesh data as may **DupliVerts.** (Child objects that are replicated at the
    position of each vertex of a parent object. See [http://wiki.blender.org/index.php/Doc:Manual/Modeling/Objects/Duplication/DupliVerts](http://wiki.blender.org/index.php/Doc:Manual/Modeling/Objects/Duplication/DupliVerts)
    for more information.) Duplication of objects in particle systems also allows
    us to create many instances of the same object without actually duplicating all
    the data. These techniques may save huge amounts of memory but detailed objects
    still may take a lot of CPU power to render because the details are still there
    to be rendered.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Blender附带了一些工具，可以在渲染多个物体副本时减少所需的内存量；不同的`网格`对象可能引用相同的网格数据，正如**DupliVerts**（在父对象的每个顶点位置复制的子对象。有关更多信息，请参阅[http://wiki.blender.org/index.php/Doc:Manual/Modeling/Objects/Duplication/DupliVerts](http://wiki.blender.org/index.php/Doc:Manual/Modeling/Objects/Duplication/DupliVerts)）。在粒子系统中复制对象也允许我们创建许多相同对象的实例，而无需实际复制所有数据。这些技术可能节省大量内存，但详细物体在渲染时仍可能需要大量的CPU资源，因为细节仍然需要被渲染。
- en: '**Billboards** are a technique used to apply a picture of a complex object
    to a simple object, such as a single square face, and replicate this simple object
    as many times as needed. The picture must have suitable transparency otherwise
    each object may occlude the others in unrealistic ways. Apart from that, this
    technique is quite simple and may save a lot of rendering time and it will give
    fairly realistic results for objects placed in the middle distance or farther
    away. Blender''s particle systems may use billboards either as simple squares
    with images applied or by applying an image to a simple object ourselves and using
    that as a duplicating object. The latter also holds for dupliverted objects.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**广告牌**是一种技术，用于将复杂物体的图片应用到简单物体上，例如单个正方形面，并按需要复制此简单物体。图片必须有合适的透明度，否则每个物体可能会以不真实的方式遮挡其他物体。除此之外，这项技术相当简单，可以节省大量的渲染时间，并且对于放置在中等距离或更远处的物体，它将给出相当逼真的效果。Blender的粒子系统可以使用广告牌，要么是带有图像的简单正方形，要么是我们自己将图像应用到简单物体上，并使用该物体作为复制对象。后者也适用于dupliverted对象。'
- en: 'The trick is to generate an image with suitable lighting to be used as an image
    that can be applied to a square. Actually, we want to create two images: one shot
    from the front, one from the right, and construct an object consisting of two
    square faces perpendicular to each other with the two images applied. Such an
    object will give us a limited amount of freedom later in the placement of the
    camera in our scene as they do not have to be seen from just one direction. This
    works well only for objects with a roughly cylindrical symmetry, such as trees
    or high-rises, but then it is quite effective.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 诀窍是生成一个具有合适光照的图像，用作可以应用到正方形上的图像。实际上，我们希望创建两个图像：一个从正面拍摄，一个从右侧拍摄，并构建一个由两个相互垂直的正方形面组成的物体，这两个面应用了上述图像。这样的物体将给我们提供有限的自由度，在场景中放置相机时，它们不必从单一方向被看到。这对于具有大致圆柱对称的物体，如树木或摩天大楼，效果很好，但效果相当有效。
- en: 'The workflow for constructing such objects is complex enough to warrant automation:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 构建此类物体的工作流程足够复杂，足以需要自动化：
- en: Position two cameras front and right of the detailed object.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将两个相机放置在详细物体的前方和右侧。
- en: Frame both cameras to capture all of the object with the same angle.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将两个相机调整到相同的视角，以捕捉所有物体。
- en: Render the transparent images with alpha premultiplied and without sky.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用带有预乘alpha通道且无天空的透明图像进行渲染。
- en: Construct a simple object of two perpendicular squares.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建一个由两个垂直正方形组成的简单物体。
- en: Apply each rendered image to a square.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将每个渲染的图像应用到正方形上。
- en: Hide the detailed object from rendering.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 隐藏详细物体以避免渲染。
- en: Optionally, replicate the simple object in a particle system (the user may opt
    not to automate this part but place the simple objects manually).
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选地，在粒子系统中复制简单对象（用户可以选择不自动化这一部分，而是手动放置简单对象）。
- en: The "premultiplication" mentioned in the third step may need some clarification.
    Obviously, the rendered images of our complex object need not show any background
    sky as their replicated clones may be positioned anywhere and may show different
    parts of the sky through their transparent parts. As we will see, this is simple
    enough to accomplish but when we simply render a transparent image and overlay
    it later on some background the image may have unsightly glaring edges.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 第三步中提到的“预乘”可能需要一些解释。显然，我们复杂对象的渲染图像不需要显示任何背景天空，因为它们的复制克隆可能位于任何位置，并且可能通过它们的透明部分显示天空的不同部分。正如我们将看到的，这很简单就能完成，但当我们简单地渲染一个透明图像并在后面叠加时，图像可能会有不美观的刺眼光边。
- en: The way to avoid this is to adjust the rendered colors by multiplying them with
    the alpha value and the render context has the necessary attributes to indicate
    this. We should not forget to mark the images produced as "premultiplied" when
    using them as textures, otherwise they will look too dark. The difference is illustrated
    in the following screenshot where we composited and enlarged a correctly premultiplied
    half on the left and a sky rendered half on the right. The trunk of the tree shows
    a light edge on the right. (Refer to Roger Wickes' excellent book "Foundation
    Blender Compositing" for more details.)
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 避免这种情况的方法是通过乘以alpha值和渲染上下文来调整渲染颜色，渲染上下文具有必要的属性来指示这一点。我们不应该忘记在使用它们作为纹理时标记生成的图像为“预乘”，否则它们看起来会太暗。差异在下图中得到了说明，其中我们合成了并放大了左侧正确预乘的一半和右侧渲染的天空的一半。树的树干在右侧显示了一个亮边。（有关更多详细信息，请参阅Roger
    Wickes的出色书籍《Blender合成基础》）。
- en: '![Rendering billboards](img/0400-08-04.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![渲染广告牌](img/0400-08-04.jpg)'
- en: 'The beech tree (used in these and the following illustrations) is a highly-detailed
    model (over 30,000 faces) created by Yorik van Havre with the free plant-modeling
    package **ngPlant**. (See his website for more fine examples: [http://yorik.uncreated.net/greenhouse.html](http://yorik.uncreated.net/greenhouse.html))
    The following first set of images shows the beech tree from the front and the
    resulting front facing render of the two billboards on the left. (slightly darker
    because of the premultiplication).'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些和随后的插图中所使用的山毛榉树是一个高度详细的三维模型（超过30,000个面），由Yorik van Havre使用免费的植物建模软件包 **ngPlant**
    创建。（请访问他的网站以查看更多精美示例：[http://yorik.uncreated.net/greenhouse.html](http://yorik.uncreated.net/greenhouse.html)）以下第一组图像显示了从前面拍摄的山毛榉树以及左侧两个广告牌的前视渲染结果。（由于预乘，颜色略暗）。
- en: '![Rendering billboards](img/0400-08-05_NEW.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![渲染广告牌](img/0400-08-05_NEW.jpg)'
- en: The next set of screenshots shows the same beech tree rendered from the right
    together with a right-facing render of the billboard on the left. As can be seen,
    the rendition is certainly not perfect from this angle and this closeup, but a
    reasonable three-dimensional aspect is retained.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了从右侧渲染的同一棵山毛榉树，以及左侧广告牌的面向右侧的渲染。正如所见，从这个角度和这个特写来看，渲染效果当然并不完美，但保留了合理的三维效果。
- en: '![Rendering billboards](img/0400-08-07_NEW.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![渲染广告牌](img/0400-08-07_NEW.jpg)'
- en: To give an impression of the construction of the billboards the next screenshot
    shows the two faces with the rendered images applied. The transparency is deliberately
    lessened to show the individual faces.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给广告牌的结构留下印象，下一张截图显示了应用了渲染图像的两个面。透明度故意降低，以显示单个面。
- en: '![Rendering billboards](img/0400-08-09.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![渲染广告牌](img/0400-08-09.jpg)'
- en: Our first challenge is to reuse some of the functions that we wrote for the
    generation of our contact sheet. These functions are in a text buffer called `combine.py`
    and we did not save this to an external file. We will create our `cardboard.py`
    script as a new text buffer in the same `.blend` file as `combine.py` and would
    like to refer to the latter just like some external module. Blender will make
    this possible for us as it searches for a module in the current text buffers if
    it cannot find an external file.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的首要挑战是重用我们为生成联系表所编写的部分功能。这些功能在一个名为 `combine.py` 的文本缓冲区中，我们没有将其保存到外部文件中。我们将在与
    `combine.py` 相同的 `.blend` 文件中创建一个新的文本缓冲区 `cardboard.py`，并希望像引用外部模块一样引用后者。如果找不到外部文件，Blender
    会为我们提供这种可能性，因为它会在当前文本缓冲区中搜索模块。
- en: 'Because internal text buffers have no information on when they were last modified,
    we have to make sure that the latest version is loaded. That is what the `reload()`
    function will take care of. If we didn''t do this Blender would not detect if
    `combine.py` had changed, which could lead to us using an older compiled version
    of it:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 由于内部文本缓冲区没有关于它们上次修改时间的信息，我们必须确保加载最新版本。这正是`reload()`函数要处理的。如果我们不这样做，Blender将无法检测`combine.py`是否已更改，这可能导致我们使用它的较旧编译版本：
- en: '[PRE24]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We will not reuse the `render()` function from `combine.py` because we have
    different requirements for the rendered images that we will apply to the billboards.
    As explained, we have to make sure that we won''t get any bright edges at points
    where we have partial transparency so we have to premultiply the alpha channel
    in advance (highlighted). We reset the rendering context to ''rendering the sky''
    again just before we return from this function because it''s easy to forget to
    turn this on again manually and you may waste time wondering where your sky has
    gone:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会重用`combine.py`中的`render()`函数，因为我们将对应用于广告牌的渲染图像有不同的要求。如前所述，我们必须确保在部分透明的地方不会出现任何亮边，因此我们必须预先乘以alpha通道（高亮显示）。在从该函数返回之前，我们再次将渲染上下文重置为'渲染天空'，因为这很容易忘记手动再次打开它，你可能会浪费时间
    wondering你的天空去哪了：
- en: '[PRE25]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Each rendered image will have to be converted to a suitable material to apply
    to a UV-mapped square. The function `imagemat()` will do just that; it will take
    a Blender `Image` object as an argument and will return a `Material` object. This
    material will be made completely transparent (highlighted) but this transparency
    and the color will be modified by the texture we assign to the first texture channel
    (second highlighted line). The textures type is set to `Image` and because we
    rendered these images with a premultiplied alpha channel, we use the `setImageFlags()`
    method to indicate that we want to use this alpha channel and set the `premul`
    attribute of the image to `True`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 每个渲染的图像都需要转换成适合应用于UV映射正方形的材料。函数`imagemat()`正是为此而设计的；它将接受一个Blender `Image`对象作为参数，并返回一个`Material`对象。这个材料将被完全透明（高亮显示），但这种透明度和颜色将由我们分配给第一个纹理通道（第二行高亮显示）的纹理进行修改。纹理类型设置为`Image`，因为我们渲染这些图像时使用了预乘alpha通道，所以我们使用`setImageFlags()`方法来指示我们想要使用这个alpha通道，并将图像的`premul`属性设置为`True`：
- en: '[PRE26]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Each face that we will apply a material to will have to be UV-mapped. In this
    case, this will be the simplest mapping possible as the square face will be mapped
    to match a rectangular image exactly once. This is often called **reset mapping**
    and therefore the function we define is called `reset()`. It will take a Blender
    `MFace` object that we assume to be a quad and set its `uv` attribute to a list
    of 2D vectors, one for each vertex. These vectors map each vertex to a corner
    of the image:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将应用材料的每个面都必须进行UV映射。在这种情况下，这将是最简单的映射，因为正方形面将正好映射到一个矩形图像上。这通常被称为**重置映射**，因此我们定义的函数被称为`reset()`。它将接受一个Blender
    `MFace`对象，我们假设它是一个四边形，并将它的`uv`属性设置为二维向量的列表，每个顶点一个。这些向量将每个顶点映射到图像的一个角落：
- en: '[PRE27]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `cardboard()` function takes care of constructing an actual `Mesh` object
    from the two `Image` objects passed as arguments. It starts off by constructing
    two square faces that cross each other along the z-axis. The next step is to add
    an UV-layer (highlighted) and make it the active one:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`cardboard()`函数负责从作为参数传递的两个`Image`对象中构建实际的`Mesh`对象。它首先构建两个沿z轴交叉的正方形面。下一步是添加一个UV层（高亮显示）并将其设置为活动层：'
- en: '[PRE28]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, we construct suitable materials from both images and assign these materials
    to the `materials` attribute of the mesh. Then, we reset the UV coordinates of
    both faces and assign the materials to them (highlighted). We update the mesh
    to make the changes visible before we return it:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们从两个图像中构建合适的材料，并将这些材料分配给网格的`materials`属性。然后，我们重置两个面的UV坐标，并将材料分配给它们（高亮显示）。在返回之前，我们更新网格以使更改可见：
- en: '[PRE29]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To replace the mesh of the duplication object of a particle system we implement
    a utility function `setmesh()`. It takes the name of the object with an associated
    particle system and a `Mesh` object as arguments. It locates the Object by name
    and retrieves the first particle system (highlighted in the next code snippet).
    The duplication object is stored in the `duplicateObject` attribute. Note that
    this is a *read-only* attribute so currently there is no possibility of replacing
    the object from Python. But we can replace the *data* of the object and that is
    what we do by passing the `Mesh` object to the `link()` method. Both the emitter
    object and the particle system''s duplication object are changed so we ensure
    that the changes are visible by calling the `makeDisplayList()` method on both
    of them before initiating a redraw of all Blender''s windows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了替换粒子系统的副本对象的网格，我们实现了一个实用函数 `setmesh()`。它接受与粒子系统相关联的对象的名称和一个 `Mesh` 对象作为参数。它通过名称定位对象并检索第一个粒子系统（在下一段代码片段中突出显示）。副本对象存储在
    `duplicateObject` 属性中。请注意，这是一个 *只读* 属性，因此目前没有从 Python 中替换对象的可能性。但我们可以替换对象的 *数据*，这正是我们通过将
    `Mesh` 对象传递给 `link()` 方法来做的。发射对象和粒子系统的副本对象都发生了变化，因此我们在开始重绘所有 Blender 窗口之前，通过在它们上调用
    `makeDisplayList()` 方法来确保更改是可见的：
- en: '[PRE30]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `run()` function encapsulates all the work that needs to be done to convert
    the active object to a set of billboards and assign them to a particle system.
    First, we retrieve a reference to the active object and make sure that it will
    be visible when rendered:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`run()` 函数封装了将活动对象转换为一系列广告牌并将它们分配给粒子系统所需的所有工作。首先，我们检索活动对象的引用并确保它在渲染时是可见的：'
- en: '[PRE31]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The next step is to make the rest of the objects in the scene invisible before
    we render the billboards. Some object may have been made invisible by the user,
    therefore, we have to remember the states so that we can restore them later. Also,we
    do not alter the state of lamps or cameras as making these invisible would leave
    us with all black images (highlighted):'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是在渲染广告牌之前，使场景中的其余对象不可见。有些对象可能已经被用户设置为不可见，因此，我们必须记住这些状态，以便稍后可以恢复它们。此外，我们不改变灯具或相机的状态，因为使这些对象不可见将导致我们得到全黑的图像（突出显示）：
- en: '[PRE32]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Once everything is set up to render just the active object, we render front
    and right images with suitably framed cameras, just like we did in the `combine.py`
    script. In fact, here we reuse the `frame()` function (highlighted):'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 一切设置完毕，只渲染活动对象后，我们使用合适的相机渲染前后图像，就像我们在 `combine.py` 脚本中所做的那样。实际上，这里我们重用了 `frame()`
    函数（突出显示）：
- en: '[PRE33]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then we restore the previous visibility of all the objects in the scene before
    we construct a new mesh from the two images. We finish by making the active object
    invisible for rendering and replacing the mesh of the duplication object in a
    designated particle system by our new mesh:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们在从两张图片中构建新网格之前，恢复场景中所有对象的前一个可见性。我们通过在调用 `run()` 之前从 `combine` 模块调用 `createcams()`
    函数来创建渲染广告牌所需的相机（如果这些相机尚未存在）：
- en: '[PRE34]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The final lines of code create the cameras necessary to render the billboards
    (if those cameras are not already present) by calling the `createcams()` function
    from the `combine` module before calling `run()`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的最后几行通过在调用 `run()` 之前从 `combine` 模块调用 `createcams()` 函数来创建渲染广告牌所需的相机（如果这些相机尚未存在）：
- en: '[PRE35]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The full code is available as `cardboard.py` in `combine.blend`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码作为 `cardboard.py` 存放在 `combine.blend` 中。
- en: Workflow—using cardboard.py
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作流程—使用 cardboard.py
- en: 'Assuming that you have a high poly object that you would like to convert to
    a set of billboards, a possible work flow would look like this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个希望转换为一系列广告牌的高多边形对象，可能的工作流程如下：
- en: Create an object called `CardboardP`.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `CardboardP` 的对象。
- en: Assign a particle system to this object.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将粒子系统分配给此对象。
- en: Create a dummy cube.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个虚拟立方体。
- en: Assign the dummy cube as the duplicate object on the first particle system of
    the `CarboardP` object.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将虚拟立方体分配为 `CarboardP` 对象的第一个粒子系统上的副本对象。
- en: Select (make active) the object to be rendered as a set of billboards.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择（激活）要渲染为一系列广告牌的对象。
- en: Run `cardboard.py`.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `cardboard.py`。
- en: Select the original camera and render the scene.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择原始相机并渲染场景。
- en: 'Of course, the script might be changed to omit the automated replacement of
    the duplication objects mesh if that is more suitable. For example, if we would
    like to use dupliverted objects instead of particles we would simply generate
    the cardboard object and assign its mesh to the dupliverted object. If we do use
    a particle system we probably do not want all replicated objects to be oriented
    in exactly the same way. We might, therefore, randomize their rotation, an example
    setup to accomplish that is shown in the following screenshot:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，脚本可以被修改以省略自动替换重复对象网格，如果这样做更合适的话。例如，如果我们想使用 dupliverted 对象而不是粒子，我们只需生成 cardboard
    对象并将其网格分配给 dupliverted 对象。如果我们确实使用粒子系统，我们可能不希望所有复制的对象都精确地以相同的方式定位。因此，我们可能会随机化它们的旋转，以下截图展示了完成这一目标的示例设置：
- en: '![Workflow—using cardboard.py](img/0400-08-10.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![工作流程—使用 cardboard.py](img/0400-08-10.jpg)'
- en: 'The next screenshot illustrates the application of billboards created from
    a tree model and used in a particle system:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个截图展示了从树模型创建的 billboard 的应用，并在粒子系统中使用：
- en: '![Workflow—using cardboard.py](img/0400-08-11.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![工作流程—使用 cardboard.py](img/0400-08-11.jpg)'
- en: Generating CAPTCHA challenges
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成 CAPTCHA 验证码
- en: In many situations such as blogs, forums, and online polls (to name a few) website
    operators want to guard against automated postings by spambots without wanting
    to burden human visitors with registration and authentication. In such situations
    it has become common to provide the visitor with a so-called CAPTCHA challenge
    ([http://en.wikipedia.org/wiki/Captcha](http://en.wikipedia.org/wiki/Captcha)).
    A **CAPTCHA** **challenge** (or just **Captcha**) in its simplest form is a picture
    that should be hard to recognize for a computer, yet simple to decipher by a human
    as it is, typically a distorted or blurred word or number.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，例如博客、论坛和在线调查（仅举几个例子），网站运营商希望防止垃圾邮件机器人自动发布内容，同时又不想让人类访客承担注册和认证的负担。在这种情况下，向访客提供所谓的
    CAPTCHA 验证码（[http://en.wikipedia.org/wiki/Captcha](http://en.wikipedia.org/wiki/Captcha)）已成为一种常见做法。**CAPTCHA**
    **验证码**（或简称**验证码**）在 simplest form 是一张对计算机来说难以识别，但对人类来说却很容易辨认的图片，通常是扭曲或模糊的文字或数字。
- en: Of course, no method is foolproof and certainly Captchas are neither without
    their flaws nor immune to the ever-growing computing power available, but they
    still remain quite effective. Although the current consensus is that simple blurring
    and coloring schemes are not up to the task, computers still have a hard time
    separating individual characters in words when they slightly overlap where humans
    have hardly any problem doing that.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，没有方法是万无一失的，CAPTCHA 也并非没有缺陷，也不是对不断增长的计算能力免疫的，但它们仍然非常有效。尽管目前的共识是简单的模糊和着色方案不足以完成任务，但计算机在字符轻微重叠时仍然难以分离单词中的单个字符，而人类几乎不会遇到这个问题。
- en: Given these arguments, this might be an excellent application of 3D rendering
    of text as presumably three-dimensional renditions of words in suitable lighting
    conditions (that is, harsh shadows) are even harder to interpret than two-dimensional
    text. Our challenge then is to design a server that will respond to requests to
    render three-dimensional images of some text.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些论点，文本的 3D 渲染可能是一个极好的应用，因为假设在合适的照明条件下（即强烈的阴影）的词语的三维呈现比二维文本更难解读。我们的挑战是设计一个服务器，它将响应请求以渲染某些文本的三维图像。
- en: 'We will design our server as a web server that will respond to requests addressed
    to it as URLs of the form `http:<hostname>:<port>/captcha?text=<sometext>` and
    that will return a PNG image—a 3D rendition of that text. In this way it will
    be easy to integrate this server into an architecture where some software, such
    as a blog, can easily incorporate this functionality by simply accessing our server
    through `HTTP`. An example of a generated challenge is shown in the illustration:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将设计我们的服务器作为一个 web 服务器，它将响应指向其 URL 的请求，形式为 `http:<hostname>:<port>/captcha?text=<sometext>`，并将返回一个
    PNG 图像——该文本的 3D 渲染。这样，它将很容易集成到某些软件（如博客）的架构中，这些软件可以通过简单地通过 `HTTP` 访问我们的服务器来轻松地整合这一功能。以下是一个生成的验证码示例：
- en: '![Generating CAPTCHA challenges](img/0400-08-12.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![生成 CAPTCHA 验证码](img/0400-08-12.jpg)'
- en: Design of a CAPTCHA server
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CAPTCHA 服务器的设计
- en: 'By making use of the modules available in a full Python distribution the task
    of implementing an `HTTP` server is not as daunting as is may seem. Our Captcha
    server will be based on the classes provided in Python''s `BaseHTTPServer` module
    so we start by importing this module along with some additional utility modules:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用Python完整发行版中可用的模块，实现HTTP服务器的任务并不像看起来那么令人畏惧。我们的Captcha服务器将基于Python的`BaseHTTPServer`模块中提供的类，因此我们首先导入这个模块以及一些额外的实用模块：
- en: '[PRE36]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `BaseHTTPServer` module defines two classes that together comprise a complete
    `HTTP` server implementation. The `BaseHTTPServer` class implements the basic
    server that will listen to incoming `HTTP` requests on some network port and we
    will use this class as is.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`BaseHTTPServer`模块定义了两个类，这两个类共同构成了一个完整的`HTTP`服务器实现。`BaseHTTPServer`类实现了基本的服务器，该服务器将在某个网络端口上监听传入的`HTTP`请求，我们将直接使用这个类。'
- en: Upon receiving a valid `HTTP` request `BaseHTTPServer` will dispatch this request
    to a request handler. Our implementation of such a request handler based on the
    `BaseHTTPRequestHandler` is pretty lean as all it is expected to do is to field
    `GET` and `HEAD` requests for URIs of the form `captcha?text=abcd`. Therefore,
    all we have to do is override the `do_GET()` and `do_HEAD()` methods of the base
    class.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在收到一个有效的`HTTP`请求后，`BaseHTTPServer`将把这个请求分发给请求处理器。我们基于`BaseHTTPRequestHandler`实现的这种请求处理器相当简洁，因为它预期只处理形式为`captcha?text=abcd`的URI的`GET`和`HEAD`请求。因此，我们只需要覆盖基类的`do_GET()`和`do_HEAD()`方法。
- en: A `HEAD` request is expected to return only the headers of a requested object,
    not its content, to save time when the content isn't changed since the last request
    (something that can be determined by checking the `Last-Modified` header). We
    ignore such niceties; we will return just the headers when we receive a `HEAD`
    request but we will generate a completely new image nonetheless. This is something
    of a waste but does keep the code simple. If performance is important, another
    implementation may be devised.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 预期`HEAD`请求只返回请求对象的头信息，而不是其内容，以节省在内容自上次请求以来未更改时的时间（这可以通过检查`Last-Modified`头信息来确定）。我们忽略了这样的小细节；当我们收到`HEAD`请求时，我们将只返回头信息，但仍然会生成一个全新的图片。这有点浪费，但确实使代码简单。如果性能很重要，可以设计另一种实现方式。
- en: 'Our implementation starts off by defining a `do_GET()` method that just calls
    the `do_HEAD()` method that will generate a Captcha challenge and return the headers
    to the client. `do_GET()` subsequently copies the contents of the file object
    returned by `do_HEAD()` to the output file, such as object of the request handler
    (highlighted), which will in turn return this content to the client (the browser
    for example):'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的实现首先定义了一个`do_GET()`方法，它只是调用`do_HEAD()`方法，该方法将生成一个Captcha挑战并返回头信息给客户端。`do_GET()`随后将`do_HEAD()`返回的文件对象的全部内容复制到输出文件，例如请求处理器的对象（突出显示），该对象随后将此内容返回给客户端（例如浏览器）：
- en: '[PRE37]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `do_HEAD()` method first determines whether we received a valid request
    (that is, a URI of the form `captcha?text=abcd`) by calling the `gettext()` method
    (highlighted, defined later in the code). If the URI is not valid, `gettext()`
    will return `None` and `do_HEAD()` will return a **File not found** error to the
    client by calling the `send_error()` method of the base class:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`do_HEAD()`方法首先通过调用`gettext()`方法（将在代码中稍后定义，并突出显示）来确定我们是否收到了一个有效的请求（即形式为`captcha?text=abcd`的URI）。如果URI无效，`gettext()`将返回`None`，并且`do_HEAD()`将通过调用基类的`send_error()`方法向客户端返回一个**文件未找到**错误：'
- en: '[PRE38]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'If a valid URI was requested, the actual image is generated by the `captcha()`
    method that will return the filename of the generated image. If this method fails
    for any reason an **Internal server** error is returned to the client:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果请求了一个有效的URI，实际的图片将通过`captcha()`方法生成，该方法将返回生成的图片的文件名。如果由于任何原因该方法失败，将向客户端返回一个**内部服务器错误**：
- en: '[PRE39]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If everything went well we open the image file, send a **200** response to
    the client (indicating a successful operation), and return a `Content-type` header
    stating that we will return a `png` image. Next, we use the `fstat()` function
    with the number of the open file handle as argument to retrieve the length of
    the generate image and return this as a `Content-Length` header (highlighted)
    followed by the modification time and an empty line signifying the end of the
    headers before returning the open file object `f`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们打开图像文件，向客户端发送**200**响应（表示操作成功），并返回一个`Content-type`头，表明我们将返回一个`png`图像。接下来，我们使用`fstat()`函数和打开文件句柄的编号作为参数来检索生成图像的长度，并将其作为`Content-Length`头返回（突出显示），然后是修改时间和一个空行，表示头部的结束，在返回打开的文件对象`f`之前：
- en: '[PRE40]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `gettext()` method verifies that the request passed to our request handler
    in the path variable is a valid URI by matching it against a regular expression.
    The `match()` function from Python''s `re` module will return a `MatchObject`
    if the regular expression matches and `None` if it does not. If there actually
    is a match we return the contents of the first match group (the characters that
    match the expression between the parentheses in the regular expression, in our
    case the value of the `text` argument), otherwise we return `None`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`gettext()`方法通过将请求与正则表达式匹配来验证传递给我们的请求处理程序在路径变量中的请求是否为有效的URI。Python的`re`模块中的`match()`函数如果正则表达式匹配，将返回一个`MatchObject`，如果不匹配，则返回`None`。如果确实存在匹配项，我们返回第一个匹配组的内容（匹配正则表达式中括号内的字符，在我们的情况下是`text`参数的值），否则返回`None`：'
- en: '[PRE41]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Now we come to the Blender-specific task of actually generating the rendered
    3D text that will be returned as a `png` image. The `captcha()` method will take
    the text to render as an argument and will return the filename of the generated
    image. We will assume that the lights and camera in the `.blend` file we run `captcha.py`
    from are correctly set up to display our text in a readable way. Therefore, the
    `captcha()` method will just consider itself with configuring a suitable `Text3d`
    object and rendering it.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来到了Blender特有的任务，即实际生成将被返回为`png`图像的渲染3D文本。`captcha()`方法将接受要渲染的文本作为参数，并返回生成的图像的文件名。我们将假设我们从`.blend`文件中运行`captcha.py`时，灯光和相机已经正确设置，以便以可读的方式显示我们的文本。因此，`captcha()`方法只需配置一个合适的`Text3d`对象并将其渲染即可。
- en: 'Its first task is to determine the current scene and check whether there is
    an Object called `Text` that can be reused (highlighted). Note that it is perfectly
    valid to have other objects in the scene to obfuscate the display even more:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 它的第一个任务是确定当前场景并检查是否存在名为`Text`的对象可以重用（突出显示）。请注意，在场景中存在其他对象以进一步模糊显示是完全有效的：
- en: '[PRE42]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If there was no reusable `Text3d` object, a new one is created:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有可重用的`Text3d`对象，将创建一个新的：
- en: '[PRE43]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The next step is to set the text of the `Text3d` object to the argument passed
    to the `captcha()` method and make it 3D by setting its extrude depth. We also
    alter the width of the characters and shorten the spacing between them to deteriorate
    the separation. Adding a small bevel will soften the contours of the characters
    what may add to the difficulty for a robot to discern the characters if the lighting
    is subtle (highlighted). We could have chosen to use a different font for our
    text that is even harder to read for a bot and this would be the place to set
    this font (see the following information box).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将`Text3d`对象的文本设置为传递给`captcha()`方法的参数，并通过设置其挤出深度使其成为3D。我们还调整了字符的宽度和缩短它们之间的间距以降低分离度。添加一个小斜面将使字符的轮廓变得柔和，这可能会增加在光线微妙（突出显示）的情况下机器人识别字符的难度。我们本可以选择使用对机器人来说甚至更难阅读的字体，而这将是设置此字体的位置（参见以下信息框）。
- en: Note
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Something is missing**'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**缺少某些内容**'
- en: 'Blender''s API documentation has a small omission: there seems to be no way
    to configure a different font for a `Text3d` object. There is an undocumented
    `setFont()` method, however, that will take a `Font` object as argument. The code
    to accomplish the font change would look like this:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Blender的API文档有一个小的遗漏：似乎没有方法可以为`Text3d`对象配置不同的字体。然而，有一个未记录的`setFont()`方法，它将接受一个`Font`对象作为参数。实现字体更改的代码看起来像这样：
- en: '`fancyfont=Text3d.Load( ''/usr/share/fonts/ttf/myfont.ttf'')` `text_ob.setFont(fancyfont)`'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`fancyfont=Text3d.Load( ''/usr/share/fonts/ttf/myfont.ttf'')` `text_ob.setFont(fancyfont)`'
- en: We have chosen not to include this code, however, partly because it is undocumented
    but mostly because the available fonts differ greatly from system to system. If
    you do have a suitable font available, by all means use it. Script type fonts
    which resemble handwriting for example may raise the bar even further for a computer.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择不包含此代码，部分原因是因为它没有文档说明，但主要是因为可用的字体在不同系统之间差异很大。如果你有合适的字体，请务必使用它。例如，类似于手写的脚本字体可能会进一步提高计算机的标准。
- en: 'The final step is to update Blender''s display list for this object so that
    our changes will be rendered:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是更新Blender中该对象的显示列表，以便我们的更改将被渲染：
- en: '[PRE44]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Once our `Text3d` object is in place our next task is to actually render an
    image to a file. First, we retrieve the rendering context from the current scene
    and set the `displayMode` to `0` to prevent an additional render window popping
    up:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的`Text3d`对象就位后，我们的下一个任务是将图像渲染到文件中。首先，我们从当前场景中检索渲染上下文，并将`displayMode`设置为`0`以防止弹出额外的渲染窗口：
- en: '[PRE45]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Next, we set the image size and indicate that we want a `png` image. By enabling
    RGBA and setting the alpha mode to `2` we ensure that there won''t be any sky
    visible and that our image will have a nice transparent background:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们设置图像大小，并指出我们想要一个`png`格式的图像。通过启用RGBA并将alpha模式设置为`2`，我们确保不会显示任何天空，并且我们的图像将有一个漂亮的透明背景：
- en: '[PRE46]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Even though we will render just a still image, we will use the `renderAnim()`
    method of the rendering context because otherwise the results will not be rendered
    to a file but to a buffer. Therefore, we set the start and end frames of the animation
    to 1 (just like the current frame) to ensure that we generate just a single frame.
    We then use the `getFrameFilename()` method to return the filename (with the complete
    path) of the rendered frame (highlighted). We then both store this filename and
    return it as a result:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们只渲染静态图像，但我们仍将使用渲染上下文的`renderAnim()`方法，因为否则结果将不会渲染到文件中，而是渲染到缓冲区中。因此，我们将动画的开始帧和结束帧设置为1（就像当前帧一样），以确保我们只生成一个帧。然后我们使用`getFrameFilename()`方法返回渲染帧的文件名（包括完整路径）（高亮显示）。然后我们存储这个文件名并将其作为结果返回：
- en: '[PRE47]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The final part of the script defines a `run()` function to start the Captcha
    server and calls this function if the script is running standalone (that is, not
    included as a module). By defining a `run()` function this way we can encapsulate
    the often used server defaults, such as port number to listen on (highlighted),
    yet allow reuse of the module if a different setup is required:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的最后一部分定义了一个`run()`函数来启动Captcha服务器，并在脚本作为独立程序运行时调用此函数（即，不是作为模块包含）。通过这种方式定义`run()`函数，我们可以封装常用的服务器默认设置，例如要监听的端口号（高亮显示），同时允许在需要不同设置时重用模块：
- en: '[PRE48]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The full code is available as `captcha.py` in the file `captcha.blend` and
    the server may be started in a number of ways: from the text editor (with *Alt
    + P*) from the menu **Scripts | render | captcha** or by invoking Blender in *background*
    mode from the command line. To stop the server again it is necessary to terminate
    Blender. Typically, this can be done by pressing **Ctrl + C** in the console or
    DOSbox'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 完整代码作为`captcha.py`文件存储在`captcha.blend`文件中，服务器可以通过多种方式启动：从文本编辑器（使用*Alt + P*），从菜单**脚本
    | 渲染 | captcha**，或者通过从命令行以*后台*模式调用Blender。要再次停止服务器，需要终止Blender。通常，这可以通过在控制台或DOSbox中按**Ctrl
    + C**来完成
- en: Note
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Warning**'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**'
- en: Note that as this server responds to requests from anybody it is far from secure.
    As a minimum it should be run behind a firewall that restricts access to it to
    just the server that needs the Captcha challenges. Before running it in any location
    that might be accessible from the Internet you should think thoroughly about your
    network security!
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于这个服务器响应来自任何人的请求，它远非安全。至少，它应该在防火墙后面运行，只允许需要Captcha挑战的服务器访问它。在将其运行在任何可能从互联网访问的位置之前，你应该仔细考虑你的网络安全问题！
- en: Summary
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we automated the render process and learned how to perform
    a number of operations on images without the need for an external image editing
    program. We have learned:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们自动化了渲染过程，并学习了如何在不需要外部图像编辑程序的情况下对图像执行多项操作。我们学习了：
- en: How to automate the rendering process
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何自动化渲染过程
- en: How to create multiple views for product presentations
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何为产品展示创建多个视图
- en: How to create billboards from complex objects
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何从复杂对象创建广告牌
- en: How to manipulate images, including render results by using the Python Imaging
    Library (PIL)
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Python Imaging Library (PIL)操作图像，包括渲染结果
- en: How to create a server that creates on demand images that may be used as CAPTCHA
    challenges
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建一个按需生成图像的服务器，这些图像可能被用作CAPTCHA挑战
- en: In the final chapter, we will look at some housekeeping tasks.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一章，我们将探讨一些日常维护任务。
