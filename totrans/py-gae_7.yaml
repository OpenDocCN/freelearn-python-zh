- en: Chapter 7. Building an Application with Django
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章. 使用Django构建应用程序
- en: '**Django** is an open source web application framework written in Python, originally
    written in 2003 by Adrian Holovaty and Simon Willison to quickly address the need
    for a web-based, database-driven application serving contents to an online newspaper.
    Django was released to the public as an open source project in 2005, and rapidly
    gained a strong following. With tens of thousands of users and contributors from
    all around the world, Django is one of the most adopted web frameworks among the
    Python community today, supported by an independent, non-profit foundation that
    promotes the project and protects its intellectual property.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**Django**是一个用Python编写的开源Web应用程序框架，最初由Adrian Holovaty和Simon Willison于2003年编写，旨在快速解决为在线报纸提供基于Web、数据库驱动的应用程序内容的需求。Django于2005年作为开源项目向公众发布，并迅速获得了强大的支持。凭借来自世界各地成千上万的用户和贡献者，Django现在是Python社区中最受欢迎的Web框架之一，由一个独立的非营利性基金会支持，该基金会推广项目并保护其知识产权。'
- en: One of the components that have contributed the most to the success of Django
    is its **Object-Relational Mapping** (**ORM**), the data access layer that maps
    the underlying relational database with some object-oriented code written in Python.
    At first, what was considered a strong point of the framework turned out to be
    a weakness within the App Engine environment. In fact, Django provides support
    for relational databases only, thus excluding the Datastore option.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 对Django成功贡献最大的组件之一是其**对象关系映射**（**ORM**），这是一个数据访问层，它将底层的数据库与用Python编写的某些面向对象代码映射起来。起初，被认为是框架的强点的实际上在App
    Engine环境中变成了弱点。事实上，Django仅支持关系数据库，因此排除了Datastore选项。
- en: However, things have deeply changed after the release of the Google Cloud SQL
    service, and now we can use Django and its ORM with a relational database on the
    Google Cloud Platform. In this chapter, we will reimplement several features of
    the original Notes application, starting from zero and using Django instead of
    the webapp2 framework, showing how the App Engine platform can be a viable solution
    to deploy and run Django applications.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在Google Cloud SQL服务发布之后，事情发生了深刻的变化，现在我们可以在Google Cloud Platform上使用Django及其ORM与关系数据库。在本章中，我们将重新实现原始Notes应用程序的几个功能，从头开始使用Django而不是webapp2框架，展示App
    Engine平台如何成为部署和运行Django应用程序的可行解决方案。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Configuring the development environment
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置开发环境
- en: Using Cloud SQL with the ORM by using the built-in authentication system
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用内置的认证系统使用ORM与Cloud SQL
- en: Uploading files on the Google Cloud Storage
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Google Cloud Storage上上传文件
- en: Setting up the local environment
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置本地环境
- en: At the time of writing this book, App Engine provides Django version 1.4 and
    1.5 as a third-party library for the Python 2.7 runtime environment. Even though
    it is quite old (Django 1.4 was released on March 2012 and 1.5 was released in
    February 2013), the 1.4 version is currently the long-term support distribution
    framework, with security patches and data loss fixes guaranteed until March 2015,
    and the 1.5 version (thus marked as experimental on App Engine) contains a lot
    of new features and improvements compared to the 1.4 version. For these reasons,
    we can safely build our applications using one of the Django packages provided
    by App Engine without the risk of producing legacy code.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，App Engine为Python 2.7运行环境提供了一个第三方库，提供了Django版本1.4和1.5。尽管它相当古老（Django
    1.4于2012年3月发布，1.5于2013年2月发布），但1.4版本目前是长期支持发行框架，保证直到2015年3月提供安全补丁和数据丢失修复，而1.5版本（因此在App
    Engine上标记为实验性）与1.4版本相比，包含了许多新功能和改进。因此，我们可以安全地使用App Engine提供的Django包之一来构建我们的应用程序，而不用担心产生遗留代码的风险。
- en: However, if we can afford to drop the official support that Google provides
    to Django 1.4 and 1.5, we can use the latest version of Django currently available,
    1.7, the only difference being that we will have to take care of the deployment
    of the package on our own because we won't find it on the production server.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们能够放弃Google为Django 1.4和1.5提供的官方支持，我们可以使用目前可用的最新Django版本1.7，唯一的区别是我们将不得不自己处理包的部署，因为我们不会在生产服务器上找到它。
- en: Since the deployment of applications written with Django 1.4 and 1.5 is well
    covered on the official documentation, and since we're building a prototype for
    the only purpose of learning how to get the most out of Google App Engine, we're
    going to develop our Django Notes application on Django 1.7; let's see how.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 由于使用 Django 1.4 和 1.5 编写的应用程序的部署在官方文档中得到了很好的覆盖，并且我们正在构建一个原型，其唯一目的是学习如何充分利用 Google
    App Engine，因此我们将使用 Django 1.7 开发我们的 Django Notes 应用程序；让我们看看如何操作。
- en: Configuring a virtual environment
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置虚拟环境
- en: When we need to use a specific version of Python packages that most likely differ
    from the ones provided by the package manger of our operating system, it's better
    to isolate the installation of such software in a separated environment using
    a tool such as **virtualenv**, and avoid clashes.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要使用与操作系统提供的包管理器中提供的版本不同的特定 Python 包版本时，最好使用像 **virtualenv** 这样的工具在单独的环境中隔离此类软件的安装，以避免冲突。
- en: 'Provided we are using Python 2.7, we can install virtualenv using the `pip`
    package manager:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们使用的是 Python 2.7，我们可以使用 `pip` 软件包管理器来安装 virtualenv：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can now proceed to start a new App Engine application as we did in [Chapter
    1](ch01.html "Chapter 1. Getting Started"), *Getting Started*, by simply creating
    the application root folder:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以像在 [第 1 章](ch01.html "第 1 章。入门")，*入门* 中所做的那样，简单地创建应用程序根文件夹来启动一个新的 App
    Engine 应用程序：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now we can set up a virtual environment inside the application folder:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在应用程序文件夹内设置一个虚拟环境：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Every time we want to work in a virtual environment, we need to activate it
    before so that we can transparently use Python and pip executables to run code
    and install packages. For Linux and Mac OS X, we can activate a virtual environment
    in this way:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们想在虚拟环境中工作之前，都需要激活它，这样我们就可以透明地使用 Python 和 pip 可执行文件来运行代码和安装包。对于 Linux 和 Mac
    OS X，我们可以这样激活虚拟环境：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'For Windows, we can simply invoke the activation script in the `Scripts` folder:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Windows，我们可以在 `Scripts` 文件夹中简单地调用激活脚本：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To deactivate the virtual environment and stop referring to the isolated Python
    installation, we can issue the following command for every supported operating
    system:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要取消虚拟环境并停止引用隔离的 Python 安装，我们可以为每个支持的操作系统发出以下命令：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We now need to make the local App Engine Python runtime available to our virtual
    environment. If we followed the instructions in [Chapter 1](ch01.html "Chapter 1. Getting
    Started"), *Getting Started*, we should now have installed the App Engine in a
    path on the filesystem depending on which operating system we are running. Take
    note of that path; for example, on Mac OS X, the App Engine SDK is sym-linked
    to the `/usr/local/google_appengine` URL. We then create a file named `gae.pth`
    and put it into the `site-package` directory of the virtual environment at the
    `$VIRTUAL_ENV/lib/python2.7/site-packages/` path.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要让本地的 App Engine Python 运行时对虚拟环境可用。如果我们遵循了 [第 1 章](ch01.html "第 1 章。入门")，*入门*
    中的说明，那么现在我们应该已经将 App Engine 安装在文件系统上的某个路径上，具体取决于我们运行的操作系统。注意这个路径；例如，在 Mac OS X
    上，App Engine SDK 被符号链接到 `/usr/local/google_appengine` URL。然后我们创建一个名为 `gae.pth`
    的文件，并将其放入虚拟环境的 `site-package` 目录中，路径为 `$VIRTUAL_ENV/lib/python2.7/site-packages/`。
- en: 'The `$VIRTUAL_ENV` variable is an environment variable, available while the
    virtual environment is active, that points to the virtual environment installation
    on our local filesystem. The `.pth` file must contain the following lines:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`$VIRTUAL_ENV` 变量是一个环境变量，在虚拟环境激活期间可用，它指向我们本地文件系统上的虚拟环境安装。`.pth` 文件必须包含以下行：'
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To check that everything is working properly, we can activate the environment
    and try to import the App Engine package. For example, on Linux and Mac OS X,
    we can do this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查一切是否正常工作，我们可以激活环境并尝试导入 App Engine 包。例如，在 Linux 和 Mac OS X 上，我们可以这样做：
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Installing dependencies
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装依赖项
- en: 'Now that we have a virtual environment set up for our application, we can begin
    to install the dependencies needed to run the Django Notes application. Of course,
    the first package we need to install is Django:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为我们的应用程序设置了一个虚拟环境，我们可以开始安装运行 Django Notes 应用程序所需的依赖项。当然，我们需要安装的第一个包是 Django：
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As we have learned in [Chapter 3](ch03.html "Chapter 3. Storing and Processing
    Users' Data"), *Storing and Processing Users' Data*, we need to install the package
    with the `-t` option so that it will be uploaded to the production server during
    the deployment process.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第3章](ch03.html "第3章。存储和处理用户数据")“存储和处理用户数据”中所学，我们需要使用`-t`选项安装包，以便在部署过程中将其上传到生产服务器。
- en: 'Since Django is also provided by the App Engine Python SDK, we need to be sure
    that when we import the `import django` package, Python is actually referring
    to the 1.7 package in our application root folder. There are many ways to accomplish
    this, but we will add the following contents to the `gae.pth` file:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Django也由App Engine Python SDK提供，我们需要确保当我们导入`import django`包时，Python实际上是指向应用程序根文件夹中的1.7包。有许多方法可以实现这一点，但我们将以下内容添加到`gae.pth`文件中：
- en: '[PRE9]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Since the `fix_sys_path()` function prepends all the App Engine packages and
    modules to the Python path, we need to insert the path where Django 1.7 lives
    before anything else. That''s why we''re using the `sys.path.insert()` function
    here. To be sure that we are using the right version of Django, once the virtualenv
    tool is active, we can write this at the command line:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`fix_sys_path()`函数将所有App Engine包和模块添加到Python路径的前面，我们需要在添加其他任何内容之前插入Django
    1.7所在的位置。这就是为什么我们在这里使用`sys.path.insert()`函数。为了确保我们使用的是正确的Django版本，一旦虚拟环境工具激活，我们可以在命令行中写下以下内容：
- en: '[PRE10]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The output should be something like `1.7.1`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该是类似`1.7.1`的。
- en: We will keep adding packages as long as we need them, but we have to remember
    to activate the virtual environment every time we want to run the project locally
    or deploy the application, and most importantly, every time we install a new package.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 只要我们需要，我们就会继续添加包，但我们必须记住每次想要在本地运行项目或部署应用程序，以及每次安装新包时，都要激活虚拟环境，最重要的是每次安装新包时。
- en: Rewriting our application using Django 1.7
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Django 1.7重写我们的应用程序
- en: 'We already created the application root folder, the same folder we installed
    the virtual environment in. Django provides a script that builds a standard application
    layout called `project`, also providing some default content for the configuration
    file. To start a new project within the application root, we issue the following
    at the command line:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了应用程序根文件夹，也就是我们安装虚拟环境的同一个文件夹。Django提供了一个名为`project`的脚本，用于构建标准应用程序布局，同时也为配置文件提供了一些默认内容。要在应用程序根目录内启动一个新的项目，我们在命令行中输入以下内容：
- en: '[PRE11]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We should now have a folder called `notes` inside our application root containing
    a Python module called `wsgi.py` we need to be aware of, as we will use it inside
    the `app.yaml` file.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们应该在我们的应用程序根目录中有一个名为`notes`的文件夹，其中包含一个名为`wsgi.py`的Python模块，我们需要注意它，因为我们将在`app.yaml`文件中使用它。
- en: 'As we already know, to create a new App Engine application, we need to provide
    an `app.yaml` file. We can pick any of the `app.yaml` files from the previous
    chapters as a base, and then rewrite it as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，要创建一个新的App Engine应用程序，我们需要提供一个`app.yaml`文件。我们可以从之前的章节中选择任何一个`app.yaml`文件作为基础，然后按照以下方式重写它：
- en: '[PRE12]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We changed the version number so that we can easily manage which application
    should run on the production server at any time: the old one built with the webapp2
    framework, or the new one built with Django. We define only one handler, which
    will match requests for any URL and serve them using the application instance
    inside the `wsgi.py` module generated by the `django_admin.py` script inside our
    project folder.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更改了版本号，这样我们就可以轻松管理在任何时候应该运行在生产服务器上的应用程序：是使用webapp2框架构建的旧版本，还是使用Django构建的新版本。我们只定义了一个处理器，它将匹配任何URL的请求，并使用`wsgi.py`模块中的应用程序实例来提供服务，该模块是由项目文件夹内的`django_admin.py`脚本生成的。
- en: 'We can now run the development server and point the browser to the `http://localhost:8080`
    URL. If Django is working, we should see a message like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以运行开发服务器，并将浏览器指向`http://localhost:8080` URL。如果Django运行正常，我们应该看到如下信息：
- en: '![Rewriting our application using Django 1.7](img/8194OS_07_01.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![使用Django 1.7重写我们的应用程序](img/8194OS_07_01.jpg)'
- en: As stated by the web page itself, we have created our first application on App
    Engine using the Django web framework. Now we can proceed and let our application
    do something more useful.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 正如网页本身所述，我们已经使用Django网络框架在App Engine上创建了我们的第一个应用程序。现在我们可以继续前进，让我们的应用程序做些更有用的事情。
- en: Using Google Cloud SQL as a database backend
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Google Cloud SQL作为数据库后端
- en: We already mentioned that we will make use of Google Cloud SQL as a relational
    database backend so that we can run every component of the Django framework without
    resorting to additional packages or derived projects.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到，我们将使用 Google Cloud SQL 作为关系型数据库后端，这样我们就可以运行 Django 框架的每个组件，而无需求助于额外的包或衍生项目。
- en: Configuring the relational database layer to make the ORM work is one of the
    first steps we have to take when developing a Django application. In fact, several
    key components, such as the user authentication mechanism, rely on a working database.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 配置关系型数据库层以使 ORM 工作是我们开发 Django 应用程序时必须采取的第一步之一。实际上，几个关键组件，如用户认证机制，都依赖于一个正常工作的数据库。
- en: 'The Django ORM provides full support for MySQL databases out of the box, so
    all of the additional software we need in order to use Google Cloud SQL is the
    MySQLdb Python package, which we will install with the `pip` package manager,
    exactly as we did in [Chapter 5](ch05.html "Chapter 5. Storing Data in Google
    Cloud SQL"), *Storing Data in Cloud SQL*. The following command is used to install
    the package:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Django ORM 默认完全支持 MySQL 数据库，因此我们使用 Google Cloud SQL 所需的额外软件仅仅是 MySQLdb Python
    包，我们将使用 `pip` 软件包管理器来安装它，就像我们在[第 5 章](ch05.html "第 5 章。在 Google Cloud SQL 中存储数据")中做的那样，*在
    Cloud SQL 中存储数据*。以下命令用于安装该包：
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To use the package in the production server, we have to add the following to
    our `app.yaml` file:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要在生产服务器上使用该包，我们必须将以下内容添加到我们的 `app.yaml` 文件中：
- en: '[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We already know how to configure Google Cloud SQL, so we assume that at this
    point, we have an instance up and running. We can access both from the local development
    and the App Engine application, and we have already created a database for the
    project.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道如何配置 Google Cloud SQL，因此我们假设此时我们已经有一个正在运行的实例。我们可以从本地开发环境和 App Engine 应用程序中访问它，并且我们已经为该项目创建了一个数据库。
- en: 'If we open the `settings.py` module inside our Django project folder, we will
    see that it contains the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们打开 Django 项目文件夹内的 `settings.py` 模块，我们会看到它包含以下内容：
- en: '[PRE15]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Django can use and connect to multiple relational databases at the same time
    from a single application, and the `DATABASES` dictionary contains another Python
    dictionary holding the configuration for each of them. For small applications,
    such as our Notes, we can use only one database—the one labeled `default`. The
    parameters to configure Cloud SQL when connecting from our local development environment
    and the parameters we need when the application is running on App Engine production
    servers slightly differ, so if we want to keep just one version of the settings
    module, we need to add some logic.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Django 可以从单个应用程序同时使用和连接到多个关系型数据库，`DATABASES` 字典包含一个 Python 字典，其中包含每个数据库的配置。对于像我们的笔记这样的小型应用程序，我们可以只使用一个数据库——标记为
    `default` 的数据库。当从我们的本地开发环境连接到 Cloud SQL 时以及当应用程序在 App Engine 生产服务器上运行时所需的参数略有不同，因此如果我们只想保留一个设置模块的版本，我们需要添加一些逻辑。
- en: 'First, we need to create a `utils.py` module at the `<app_root>/notes/notes`
    path, containing the `on_appengine()` function from [Chapter 5](ch05.html "Chapter 5. Storing
    Data in Google Cloud SQL"), *Storing Data in Cloud SQL*, to determine whether
    our application is running on App Engine or not:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在 `<app_root>/notes/notes` 路径下创建一个 `utils.py` 模块，其中包含来自[第 5 章](ch05.html
    "第 5 章。在 Google Cloud SQL 中存储数据")的 `on_appengine()` 函数，以确定我们的应用程序是否在 App Engine
    上运行：
- en: '[PRE16]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then we edit the `settings.py` module and change the `DATABASES` dictionary
    with the following code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们编辑 `settings.py` 模块，并使用以下代码更改 `DATABASES` 字典：
- en: '[PRE17]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We use the same Python database driver when we connect both from the local development
    environment and the App Engine production server. The database name and user credentials
    are also the same, but we need to specify a different `HOST` parameter depending
    on where the application is running because on App Engine, the connection is performed
    with a Unix socket, while in local connection, we use a TCP socket. If we want
    to use a local MySQL installation instead, we can change the `NAME`, `USER`, `PASSWORD`,
    and `HOST` parameters accordingly.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从本地开发环境和 App Engine 生产服务器连接时，我们使用相同的 Python 数据库驱动程序。数据库名称和用户凭据也是相同的，但我们需要根据应用程序运行的位置指定不同的
    `HOST` 参数，因为在 App Engine 上，连接是通过 Unix 套接字执行的，而在本地连接中，我们使用 TCP 套接字。如果我们想使用本地的 MySQL
    安装，我们可以相应地更改 `NAME`、`USER`、`PASSWORD` 和 `HOST` 参数。
- en: Before moving to the final step to configure the relational database, we need
    to introduce the concept of **migrations**, a new feature of Django 1.7\. Since
    the ORM maps Python objects to the database schema, it will likely require altering
    the schema accordingly with the changes we make to the Python code. Django writes
    such changes to one or more migration files that reside in several `migration`
    folders inside our project source tree. We will see later in this chapter how
    to deal with migrations. For the moment, all we need to do is to invoke a command
    called `migrate` to create the first version of the database schema.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行配置关系型数据库的最终步骤之前，我们需要介绍**迁移**的概念，这是Django 1.7的新特性。由于ORM将Python对象映射到数据库模式，因此它可能需要根据我们对Python代码所做的更改相应地更改模式。Django将这些更改写入一个或多个位于项目源树中的`migration`文件夹中的迁移文件。我们将在本章后面看到如何处理迁移。目前，我们只需要调用一个名为`migrate`的命令来创建数据库模式的第一版。
- en: Note
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'To invoke Django commands, we use the `manage.py` script, which was generated
    by the `django_admin.py` script when we first created the project. Inside the
    project folder, we can launch commands in this way:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用Django命令，我们使用由`django_admin.py`脚本在首次创建项目时生成的`manage.py`脚本。在项目文件夹中，我们可以这样启动命令：
- en: '[PRE18]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To see the list of available commands, we can invoke the `manage.py` script
    without arguments:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看可用命令的列表，我们可以不带参数调用`manage.py`脚本：
- en: '[PRE19]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To launch the `migrate` command, we issue the following at the command line:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动`migrate`命令，我们在命令行中输入以下内容：
- en: '[PRE20]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If the Cloud SQL instance is well configured, we should see the following output:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Cloud SQL实例配置良好，我们应该看到以下输出：
- en: '[PRE21]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Since the user authentication system is available by default, we can add a
    `superuser` user to the system with this command:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 由于用户身份验证系统默认可用，我们可以使用以下命令向系统中添加一个`superuser`用户：
- en: '[PRE22]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The command will prompt for username, e-mail address, and password. We can provide
    the credentials of our choice.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 命令将提示用户名、电子邮件地址和密码。我们可以提供我们选择的凭据。
- en: Creating a reusable application in Django
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Django中创建可重用应用程序
- en: We already used the term `project` when referring to the filesystem layout generated
    by the `django_admin.py` script. It contains all of the code and the assets needed
    to run our web applications called Notes. The core of a Django project is its
    settings file, which defines the global environment and configurations, and we
    have already seen how to use it to set up the relational database layer.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们提到由`django_admin.py`脚本生成的文件系统布局时，我们已经使用了`project`这个术语。它包含运行我们的名为Notes的Web应用程序所需的所有代码和资源。Django项目的核心是其设置文件，它定义了全局环境和配置，我们已经在设置关系型数据库层时看到了如何使用它。
- en: It's now time to introduce the term "application." In the Django lingo, an `application`
    is a Python package that provides a well-defined set of functionalities and can
    be reused across different Django projects. We must not confuse the term "application"
    as defined in Django and the more general term "web application." Even though
    Notes is actually an application in the general sense, it is developed as a Django
    project and contains some functional blocks called Django applications.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候介绍“应用程序”这个术语了。在Django术语中，一个`application`是一个Python包，它提供了一组定义良好的功能，并且可以在不同的Django项目中重用。我们不应该混淆Django中定义的“应用程序”术语和更通用的“Web应用程序”术语。尽管Notes在广义上实际上是一个应用程序，但它被开发为一个Django项目，并包含一些称为Django应用程序的功能块。
- en: A Django application usually contains the ORM model classes, view functions
    and classes, HTML templates, and static assets. An `application` package can be
    installed via the `pip` package manager or provided together with the `project`
    package. We need to know that a Django project will use an application only if
    it is listed in the `INSTALLED_APPS` settings value in the `settings.py` module.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Django应用程序通常包含ORM模型类、视图函数和类、HTML模板以及静态资源。可以通过`pip`包管理器安装`application`包，或者与`project`包一起提供。我们需要知道，Django项目只有在`settings.py`模块中的`INSTALLED_APPS`设置值中列出时，才会使用应用程序。
- en: 'We will create one Django application to implement Notes core functionalities,
    an application called `core`, to be precise. To create an empty application inside
    our project, we can use the `startapp` command and pass the name of the application:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个名为`core`的Django应用程序来实现Notes的核心功能。为了在我们的项目中创建一个空的应用程序，我们可以使用`startapp`命令并传递应用程序的名称：
- en: '[PRE23]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We can see how the command created a Python package inside our project folder
    called `core` as we asked for. The package contains a set of standard modules
    we will likely want to implement, as we will see in a moment.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到命令如何在我们的项目文件夹中创建了一个名为`core`的Python包，正如我们请求的那样。该包包含了一组我们将要实现的标准模块，正如我们稍后将看到的。
- en: 'As mentioned before, we need to list our newly created app inside the `INSTALLED_APPS`
    settings to tell Django that it must use it:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们需要在我们的`INSTALLED_APPS`设置中列出我们新创建的应用程序，以便告诉Django必须使用它：
- en: '[PRE24]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Django 1.7 provides a registry called `apps` provided by the `django.apps`
    package, which stores an `AppConfig` object for each installed application. We
    can use `AppConfig` objects to introspect applications'' metadata or to change
    the configuration of a determined application. To see the `apps` registry in action,
    we can access the Django shell like this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Django 1.7提供了一个由`django.apps`包提供的名为`apps`的注册表，它为每个已安装的应用程序存储一个`AppConfig`对象。我们可以使用`AppConfig`对象来检查应用程序的元数据或更改特定应用程序的配置。要查看`apps`注册表的实际操作，我们可以像这样访问Django
    shell：
- en: '[PRE25]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then we can test the following Python code:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以测试以下Python代码：
- en: '[PRE26]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Views and templates
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图和模板
- en: 'Now that the data backend is functional, we can start implementing the first
    building block—providing the view showing the homepage for our Notes web application.
    A view in the Django world is nothing more than a Python function or class that
    takes an HTTP request and returns an HTTP response, implementing whatever logic
    is needed to build the final content delivered to the client. We will add the
    code implementing a view to build the homepage to the `views.py` module we created
    inside our `core` application:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在数据后端已经功能正常，我们可以开始实现第一个构建块——为我们的Notes网络应用程序提供显示主页的视图。在Django的世界里，视图不过是一个接收HTTP请求并返回HTTP响应的Python函数或类，它实现了构建最终发送给客户端的内容所需的任何逻辑。我们将把构建主页的视图实现代码添加到我们在`core`应用程序中创建的`views.py`模块中：
- en: '[PRE27]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The view parameter called `home` does something very similar to the `get()`
    method of the `MainHandler` class in the webapp2 version of Notes. We create a
    `context` dictionary that will be passed to the template during the rendering
    process. Then we call the `render()` method, which passes the same `request` object
    we received as a parameter—a string containing the path to the HTML template.
    It will be used for the page and the `context` dictionary.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 被称为`home`的视图参数在webapp2版本的Notes中与`MainHandler`类的`get()`方法执行非常相似的操作。我们创建一个`context`字典，该字典将在渲染过程中传递给模板。然后我们调用`render()`方法，该方法传递我们作为参数接收的相同的`request`对象——一个包含HTML模板路径的字符串。它将被用于页面和`context`字典。
- en: 'In the webapp2 version of Notes, we used Jinja2 to render our pages, but Django
    has its own template system already integrated in the framework. The language
    we use inside the HTML files is very similar to Jinja2, but some major differences
    still exist, so we have to rewrite our templates. We create a new HTML file at
    the `core/templates/core/main.html` path, relative to the `project` folder and
    containing the following code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在webapp2版本的Notes中，我们使用了Jinja2来渲染我们的页面，但Django已经在其框架中集成了自己的模板系统。我们在HTML文件中使用的语言与Jinja2非常相似，但仍然存在一些主要差异，因此我们必须重写我们的模板。我们在`project`文件夹相对路径的`core/templates/core/main.html`处创建了一个新的HTML文件，包含以下代码：
- en: '[PRE28]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Notice in the template how we are using the `{{ django_version }}` element,
    which outputs the variable we put in the context dictionary, and the `{{ user
    }}` element, which is provided by default by the Django authentication system.
    Since we did not perform a login, the current user is set to a special entity
    called **anonymous user**.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在模板中我们是如何使用`{{ django_version }}`元素，它输出我们在`context`字典中放置的变量，以及`{{ user }}`元素，这是Django认证系统默认提供的。由于我们没有执行登录，当前用户被设置为称为**匿名用户**的特殊实体。
- en: 'Now that we have a view function providing an HTTP response and a template
    to render an HTML page, we need to map a URL of our choice to the view, just as
    we did with webapp2\. Django has a URL configurator module (also known as the
    `URLconf` module) called `urls.py`, containing pure Python code and defining a
    mapping between URLs described with regular expressions and view functions or
    classes. The `django_admin.py` script generates an `urls.py` module we can use
    as a starting point, but the final version to map the homepage view should be
    the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个提供HTTP响应和用于渲染HTML页面的模板的视图函数，我们需要将我们选择的URL映射到该视图，就像我们在webapp2中做的那样。Django有一个名为`urls.py`的URL配置器模块（也称为`URLconf`模块），它包含纯Python代码，并定义了使用正则表达式描述的URL与视图函数或类之间的映射。`django_admin.py`脚本生成一个我们可以用作起点的`urls.py`模块，但映射首页视图的最终版本应该是以下内容：
- en: '[PRE29]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'A `URLconf` module must define a variable named `urlpatterns` and contain a
    list of `django.conf.urls.url` instances that will be iterated in order by Django
    until one of them matches a requested URL. When a match with a regular expression
    occurs, Django stops the iteration and can potentially do two things:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`URLconf`模块必须定义一个名为`urlpatterns`的变量，并包含一个`django.conf.urls.url`实例的列表，这些实例将被Django按顺序迭代，直到其中一个与请求的URL匹配。当发生正则表达式匹配时，Django停止迭代，并可能执行以下两个操作：
- en: Import and call the `view` passed as parameter.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入并调用作为参数传递的`view`。
- en: Process an `include` statement that loads a `urlpattern` object from another
    module.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理一个`include`语句，该语句从另一个模块加载一个`urlpattern`对象。
- en: In our case, we match the root URL for the domain and import the `home` function
    view we previously defined in the `views.py` module.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们匹配域的根URL，并导入我们在`views.py`模块中先前定义的`home`函数视图。
- en: 'Finally, we put the same CSS file we used for the webapp2 version of Notes
    at the `static/css/notes.css` path, relative to the App Engine application root
    folder, and we should get the result for the homepage, as shown in the following
    screenshot:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将与webapp2版本Notes相同的CSS文件放在相对于App Engine应用程序根文件夹的`static/css/notes.css`路径下，我们应该得到以下截图所示的首页结果：
- en: '![Views and templates](img/8194OS_07_02.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![视图和模板](img/8194OS_07_02.jpg)'
- en: Authenticating users with Django
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Django验证用户
- en: 'To authenticate our users, we won''t use the App Engine User service, and we
    will completely rely on Django instead. Django provides a built-in user authentication
    system that also provides authorization checking. We can verify that users are
    who they claim to be, and we can determine what they are allowed to do. The authentication
    system is implemented as a Django application, and we have to ensure that it is
    listed in the `INSTALLED_APPS` settings before trying to use it as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证我们的用户，我们不会使用App Engine用户服务，而是完全依赖Django。Django提供了一个内置的用户认证系统，它还提供了授权检查。我们可以验证用户是否是他们所声称的人，并确定他们被允许做什么。认证系统作为Django应用程序实现，我们必须确保在尝试使用它之前，它已列在`INSTALLED_APPS`设置中，如下所示：
- en: '[PRE30]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The authentication system is also responsible for adding to the template context
    the `user` variable so that we can write `{{ user }}` in our HTML templates.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 认证系统还负责将`user`变量添加到模板上下文中，这样我们就可以在我们的HTML模板中写入`{{ user }}`。
- en: 'Since we won''t use the App Engine User service, we must implement the login
    and logout pages by ourselves, and Django helps us by providing two out-of-the-box
    views that serve as a login and a logout page. First of all, we need to map the
    login and logout URLs to such views in the `URLconf` module, so we add the following
    to the `urls.py` module:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不会使用App Engine用户服务，我们必须自己实现登录和注销页面，而Django通过提供两个现成的视图来帮助我们，这些视图分别作为登录和注销页面。首先，我们需要在`URLconf`模块中将登录和注销URL映射到这些视图，因此我们在`urls.py`模块中添加以下内容：
- en: '[PRE31]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Even if the logic for logging in users comes for free, we need to provide an
    HTML template for the login page. We add a folder called `registration` inside
    the `template` folder of the `core` application and create a file in it called
    `login.html`, containing the following code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 即使登录用户的逻辑是免费的，我们也需要提供一个登录页面的HTML模板。我们在`core`应用的`template`文件夹内添加一个名为`registration`的文件夹，并在其中创建一个名为`login.html`的文件，包含以下代码：
- en: '[PRE32]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We use the same style sheet and the same page structure of the main page to
    show the login form. To populate the `action` attribute of the form, we use the
    `url` template tag, which retrieves the URL of a view whose name is given. In
    this case, the attribute will contain the URL mapped to the `django.contrib.auth.views.login`
    view. We then use the `{% csrf_token %}` template tag to create a field inside
    the form that Django needs in order to prevent **Cross-Site Request Forgery**
    (**CSRF**) attacks. We also add a hidden field containing the URL we want to redirect
    users to after a successful login. This URL is handled by Django, and the authentication
    system takes care of filling the `next` value in the template context.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用与主页相同的样式表和页面结构来显示登录表单。为了填充表单的 `action` 属性，我们使用 `url` 模板标签，它检索具有给定名称的视图的
    URL。在这种情况下，该属性将包含映射到 `django.contrib.auth.views.login` 视图的 URL。然后我们使用 `{% csrf_token
    %}` 模板标签在表单内创建一个 Django 需要的字段，以防止 **跨站请求伪造** (**CSRF**) 攻击。我们还添加了一个包含我们想要在成功登录后重定向用户的
    URL 的隐藏字段。此 URL 由 Django 处理，认证系统负责在模板上下文中填充 `next` 值。
- en: 'Our users will be automatically redirected to the login page whenever they
    attempt to access a URL that is login-protected. To see the authentication system
    in action, we tell Django to protect the `home` view by adding the following code
    to the `views.py` module inside the `core` application:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的用户尝试访问受登录保护的 URL 时，他们将被自动重定向到登录页面。为了看到认证系统的工作情况，我们告诉 Django 通过在 `core` 应用程序内的
    `views.py` 模块中添加以下代码来保护 `home` 视图：
- en: '[PRE33]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now that we have added the `login_required()` function decorator to the `home`
    view, only logged-in users will be able to see page contents, and others will
    be redirected to the login page. If we try to access the `http://localhost:8080`
    URL, this is what we should see:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将 `login_required()` 函数装饰器添加到了 `home` 视图中，只有登录用户才能看到页面内容，其他人将被重定向到登录页面。如果我们尝试访问
    `http://localhost:8080` URL，我们应该看到以下内容：
- en: '![Authenticating users with Django](img/8194OS_07_03.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Django 验证用户](img/8194OS_07_03.jpg)'
- en: We can log in with the `superuser` user, using the same credentials we provided
    during the `createsuperuser` command execution earlier in this chapter.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以登录使用 `superuser` 用户，使用我们在本章前面 `createsuperuser` 命令执行期间提供的相同凭据。
- en: 'Finally, we have to provide a link to the logout view, which users can access
    to terminate their authenticated session. In the `main.html` template file, we
    add the following code:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须提供一个指向注销视图的链接，用户可以通过它来终止他们的认证会话。在 `main.html` 模板文件中，我们添加以下代码：
- en: '[PRE34]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We simply retrieve the URL mapped to the logout view and Django will do the
    rest, performing all the operations needed to make the user log out.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需检索映射到注销视图的 URL，Django 就会完成剩下的工作，执行所有必要的操作以使用户注销。
- en: Using the ORM and migrations system
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 ORM 和迁移系统
- en: 'We are already familiar with the model classes provided by webapp2 because
    in [Chapter 2](ch02.html "Chapter 2. A More Complex Application"), *A More Complex
    Application*, we used them to map Python objects to Datastore entities. Django
    uses an almost identical approach; we define Python classes deriving from the
    `django.db.models.Model` package, and the ORM component takes care of mapping
    instances of those classes to rows and tables in the underlying relational database.
    To see the ORM in action, we add the following models to the `models.py` module
    inside the `core` application:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经熟悉 webapp2 提供的模型类，因为在 [第 2 章](ch02.html "第 2 章。更复杂的应用") *更复杂的应用* 中，我们使用它们将
    Python 对象映射到数据存储实体。Django 使用几乎相同的方法；我们定义从 `django.db.models.Model` 包派生的 Python
    类，ORM 组件负责将这些类的实例映射到底层关系数据库中的行和表中。为了看到 ORM 的工作情况，我们在 `core` 应用程序内的 `models.py`
    模块中添加以下模型：
- en: '[PRE35]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We define a `Note` model class with a `title` property containing small text
    (up to ten characters), a `content` property containing text of arbitrary length,
    a `date_created` property containing date and time, and an `owner` property, which
    is a foreign key referring to an instance of the `User` model from the Django
    authentication system. Since we pass the `blank=False` parameter to the `TextField`
    model field constructor, the `content` property is required.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个 `Note` 模型类，它包含一个 `title` 属性，包含少量文本（最多十个字符），一个 `content` 属性，包含任意长度的文本，一个
    `date_created` 属性，包含日期和时间，以及一个 `owner` 属性，它是一个外键，引用 Django 认证系统中的 `User` 模型的一个实例。由于我们向
    `TextField` 模型字段构造函数传递了 `blank=False` 参数，因此 `content` 属性是必需的。
- en: We then define a `CheckListItem` model class with a `title` property containing
    small text (up to hundred characters), a `checked` property containing a Boolean
    value that defaults to the `False` parameter when not specified, and a `note`
    property, which is a foreign key referring to the `Note` model. The `related_name='checklist_items'`
    parameter we pass to the `ForeignKey` model field constructor means that we will
    be able to access the set of checklist items tied to a `Note` instance accessing
    a property called `checklist_items` on the instance itself.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后定义了一个`CheckListItem`模型类，它包含一个`title`属性，该属性包含少量文本（最多一百个字符），一个`checked`属性，该属性包含一个默认为`False`参数的布尔值，如果不指定，以及一个`note`属性，它是一个外键，指向`Note`模型。我们传递给`ForeignKey`模型字段构造函数的`related_name='checklist_items'`参数意味着我们将能够通过在实例本身上访问一个名为`checklist_items`的属性来访问与`Note`实例相关联的清单项集合。
- en: 'To translate our models into the SQL code needed to map them to the relational
    database, we need to perform a migration, more precisely the initial migration
    since this is the first time we are doing this for the core application:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将我们的模型转换为映射到关系数据库所需的SQL代码，我们需要执行迁移，更确切地说，是初始迁移，因为这是我们第一次为核心应用程序执行此操作：
- en: '[PRE36]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The output of the migration should be the following:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移的输出应该是以下内容：
- en: '[PRE37]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `makemigrations` command creates a `migration` folder inside the `core`
    application path with a migration file called `0001_initial.py`. The migration
    file contains the list of the operations the ORM needs to perform in order to
    map the current Python code to the database schema, creating or altering tables
    accordingly.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`makemigrations`命令在`core`应用程序路径内创建一个名为`migration`的文件夹，并包含一个名为`0001_initial.py`的迁移文件。迁移文件包含ORM需要执行的操作列表，以便将当前的Python代码映射到数据库模式，相应地创建或更改表。'
- en: Note
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: Migration files are part of the codebase and should be kept under version control
    like any other Python module.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移文件是代码库的一部分，应该像任何其他Python模块一样置于版本控制之下。
- en: 'To apply the changes to the database, we need to perform a migration with this
    command:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要将更改应用到数据库，我们需要使用以下命令执行迁移：
- en: '[PRE38]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The output of applying the changes to the database should be the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 对数据库应用更改的输出应该是以下内容：
- en: '[PRE39]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'At this point, we have created the database schema for our core application.
    If we want to confirm exactly which SQL code was produced by the migration system,
    we can issue the following command:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们已经为我们的核心应用程序创建了数据库模式。如果我们想确认迁移系统产生的确切SQL代码，我们可以发出以下命令：
- en: '[PRE40]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This command will print on the command line the SQL code produced for our initial
    migration.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将在命令行上打印出为我们初始迁移产生的SQL代码。
- en: 'At this point, we might notice that our `Note` model has a `title` field that
    is really too small to contain descriptive titles for our notes, so we change
    it in `models.py`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可能会注意到我们的`Note`模型有一个`title`字段，它实际上太小，无法包含描述性标题，因此我们在`models.py`中更改它：
- en: '[PRE41]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Of course, this change will alter the database schema, so we need to perform
    a migration:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个更改将改变数据库模式，因此我们需要执行迁移：
- en: '[PRE42]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This time, the output will be as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，输出将是以下内容：
- en: '[PRE43]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'A file called `0002_auto_20141101_1128.py` is added to the migration folder,
    containing the SQL instructions needed to alter the database schema to reflect
    our new Python code. The last step we need to take is to apply the migration:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在迁移文件夹中添加了一个名为`0002_auto_20141101_1128.py`的文件，其中包含更改数据库模式以反映我们新的Python代码所需的SQL指令。我们需要采取的最后一步是应用迁移：
- en: '[PRE44]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Processing forms with the Forms API
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用表单API处理表单
- en: 'Now that our database is ready to store our data, we can implement the code
    needed to handle the form we show in the main page to create new notes, and Django''s
    Forms API will simplify and automate a great part of this work. In particular,
    we will let Django take care of the following:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好存储我们的数据，我们可以实现处理主页上显示的表单以创建新笔记所需的代码，Django的表单API将简化并自动化这一工作的很大一部分。特别是，我们将让Django负责以下工作：
- en: Creating the HTML form automatically from the contents of our `Note` model class
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动从我们的`Note`模型类的内容创建HTML表单
- en: Processing and validating submitted data
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理和验证提交的数据
- en: Providing a CSRF security check
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供CSRF安全检查
- en: 'First of all, we implement a class deriving from the `django.forms.ModelForm`
    class that will let us define and process our form. Inside the `core` application,
    we create a new Python module called `forms.py`, containing the following lines:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们实现一个从`django.forms.ModelForm`类派生的类，这将使我们能够定义和处理我们的表单。在`core`应用程序内部，我们创建了一个名为`forms.py`的新Python模块，包含以下行：
- en: '[PRE45]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We define a Python class implementing a so-called `model` form, a Django `form`
    class that defines and validates data from a Django model. We define another class
    called `Meta` inside the `NoteForm` class. It contains the form's metadata, mainly
    the name of the model it will work on and a list of fields of the model we don't
    want to show on the HTML form.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个 Python 类，实现了一个所谓的 `model` 表单，这是一个 Django `form` 类，它定义并验证来自 Django 模型的数据。我们在
    `NoteForm` 类内部定义了另一个名为 `Meta` 的类。它包含表单的元数据，主要是它将要工作的模型名称以及我们不想在 HTML 表单中显示的模型字段列表。
- en: 'We will use the `NoteForm` class in our `home` view, so we add the following
    to the `views.py` module:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 `home` 视图中使用 `NoteForm` 类，因此我们在 `views.py` 模块中添加以下内容：
- en: '[PRE46]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We initially assign a `user` variable containing the current logged-in user
    instance. Then we check whether the view is serving a HTTP `POST` request. If
    this is the case, we instantiate our model form class, passing the request itself
    to the constructor. The form will extract the data it needs from the request body.
    We then call the `is_valid()` method to check whether all the fields needed were
    filled with the right data, and we call the `save()` method passing the `commit=False`
    parameter that will create a new `Note` instance without saving it in the database.
    We assign the `owner` field to the current logged-in user and save the `Note`
    instance, this time making it persist in the database. Finally, we redirect the
    user to the homepage URL. We call the `reverse()` method and pass the view name
    as a parameter. If the request is of the `GET` type, we instantiate an empty model
    form. The `NoteForm` instance is added to the context so that the template can
    use it to render the HTML form. Here, we perform our first database query using
    the Django ORM. The `Note.objects.filter(owner=user).order_by('-id')` query returns
    a list of the notes' objects filtered by the current logged-in user as `owner`
    and ordered by the `id` parameter in reverse order (notice the `-` character before
    the field name). The list is added to the context so that the template can render
    it.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最初分配一个包含当前登录用户实例的 `user` 变量。然后我们检查视图是否正在服务一个 HTTP `POST` 请求。如果是这种情况，我们实例化我们的模型表单类，将请求本身传递给构造函数。表单将从请求体中提取所需的数据。然后我们调用
    `is_valid()` 方法来检查是否所有需要的字段都已填写了正确的数据，并调用 `save()` 方法传递 `commit=False` 参数，这将创建一个新的
    `Note` 实例而不将其保存到数据库中。我们将 `owner` 字段分配给当前登录用户并保存 `Note` 实例，这次使其持久化在数据库中。最后，我们将用户重定向到主页
    URL。我们调用 `reverse()` 方法并传递视图名称作为参数。如果请求是 `GET` 类型，我们实例化一个空模型表单。`NoteForm` 实例被添加到上下文中，以便模板可以使用它来渲染
    HTML 表单。在这里，我们使用 Django ORM 执行我们的第一次数据库查询。`Note.objects.filter(owner=user).order_by('-id')`
    查询返回一个按 `id` 参数逆序排序的笔记对象列表，该列表按当前登录用户作为 `owner` 过滤（注意字段名前的 `-` 字符）。列表被添加到上下文中，以便模板可以渲染它。
- en: 'The final step we need to take is modifying the `main.html` template so that
    it can properly render the new contents we have just added to the context. Let''s
    start with the form, which we can easily define using the model form instance,
    `form`, without writing too much HTML code:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要采取的最后一步是修改 `main.html` 模板，以便它可以正确渲染我们刚刚添加到上下文中的新内容。让我们从表单开始，我们可以很容易地使用模型表单实例
    `form` 来定义它，而不需要编写太多的 HTML 代码：
- en: '[PRE47]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We first iterate the visible fields of the form. Note that Django will take
    care of printing the correct tags and labels. After iterating through the visible
    fields, we print the hidden fields, then print the CSRF token (as we did for the
    login form), and finally provide the `submit` button. Right after the form definition,
    we can add the loop that produces the HTML code to show the notes to the current
    user:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先迭代表单的可见字段。请注意，Django 将负责打印正确的标签和标签。在迭代完可见字段后，我们打印隐藏字段，然后打印 CSRF 令牌（就像我们在登录表单中所做的那样），最后提供
    `submit` 按钮。在表单定义之后，我们可以添加循环，生成显示当前用户笔记的 HTML 代码：
- en: '[PRE48]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'As we can see, the `input` control to add the `checklist_items` parameter is
    missing. This is because we want to provide such items with the same list as we
    did in the webapp2 version of Notes—a comma-separated list. Since the Note model
    does not provide a field to hold this list, the model form won''t show anything
    to provide such data. Anyway, we can manually add arbitrary fields to a model
    form independently from the fields of the associated model. In our `forms.py`
    module, we add the following to the `NoteForm` class:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，添加`checklist_items`参数的`input`控件缺失。这是因为我们希望提供与在Notes的webapp2版本中相同的列表——一个以逗号分隔的列表。由于Note模型没有提供字段来存储这个列表，模型表单不会显示任何提供此类数据的内容。无论如何，我们可以独立于关联模型的字段手动向模型表单添加任意字段。在我们的`forms.py`模块中，我们在`NoteForm`类中添加以下内容：
- en: '[PRE49]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We add a new field called `ci_items`. It is not required and is rendered using
    a `forms.TextInput` widget. We don''t use the default widget here because we want
    to provide the `placeholder` attribute to the corresponding HTML tag. We can refresh
    the homepage to see the new field appearing, without the need to touch the HTML
    template file. Now we need to process this new field, and we do this in the `home`
    view:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个名为`ci_items`的新字段。它不是必需的，并使用`forms.TextInput`小部件渲染。我们在这里不使用默认小部件，因为我们想为相应的HTML标签提供`placeholder`属性。我们可以刷新主页以查看新字段的出现，而无需修改HTML模板文件。现在我们需要处理这个新字段，我们在`home`视图中这样做：
- en: '[PRE50]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: After saving the note instance, we access the `cl_items` value in the `cleaned_data`
    dictionary Django filled after the form was processed. We split the string using
    the comma as a separator, create a new `CheckListItem` instance for every item
    the user passed through the form field, and cause that instance to persist.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在保存笔记实例后，我们访问Django在表单处理完毕后填充的`cleaned_data`字典中的`cl_items`值。我们使用逗号作为分隔符拆分字符串，为用户通过表单字段传递的每个项目创建一个新的`CheckListItem`实例，并使该实例持久化。
- en: Uploading files to Google Cloud Storage
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上传文件到Google Cloud Storage
- en: By default, when users upload their files, Django stores content locally in
    the server. As we already know, App Engine applications run in a sandboxed environment
    without being able to access the server filesystem, so this approach simply cannot
    work. Anyway, Django provides an abstraction layer, the file storage system. We
    can use this layer to customize where and how uploaded files are stored. We are
    going to take advantage of this feature, implementing our own storage backend
    class that will store uploaded files on the Google Cloud Storage.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当用户上传文件时，Django将内容本地存储在服务器上。正如我们所知，App Engine应用程序在沙盒环境中运行，无法访问服务器文件系统，因此这种方法根本无法工作。无论如何，Django提供了一个抽象层，即文件存储系统。我们可以使用这个层来自定义上传文件存储的位置和方式。我们将利用这个功能，实现自己的存储后端类，该类将上传的文件存储在Google
    Cloud Storage上。
- en: 'Before starting, we need to install the GCS Client Library as we did in [Chapter
    3](ch03.html "Chapter 3. Storing and Processing Users'' Data"), *Storing and Processing
    Users'' Data*, in order to easily interact with the Cloud Storage from our storage
    backend. We then create a `storage.py` module in our `core` application, containing
    the definition of the storage backend class, as shown in the following code:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，我们需要安装GCS客户端库，就像我们在[第3章](ch03.html "第3章。存储和处理用户数据")“存储和处理用户数据”中做的那样，以便轻松与存储后端交互。然后我们在`core`应用程序中创建一个`storage.py`模块，其中包含存储后端类的定义，如下面的代码所示：
- en: '[PRE51]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The constructor must be invoked without arguments, so everything we need from
    within the storage backend must be retrieved from the Django settings. In this
    case, we expect that the bucket name was specified in the `BUCKET_NAME` settings
    value, and we ensure that it is a valid name using the `validate_bucket_name`
    parameter from the GCS Client Library. We then add to our class the methods we
    must provide to meet the custom storage backend requirements:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数必须不带参数调用，因此我们需要从存储后端获取的所有内容都必须从Django设置中检索。在这种情况下，我们期望`BUCKET_NAME`设置值中指定了存储桶名称，我们使用GCS客户端库的`validate_bucket_name`参数确保它是一个有效的名称。然后我们在类中添加我们必须提供的方法以满足自定义存储后端的要求：
- en: '[PRE52]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The code is pretty much the same as what we saw in [Chapter 3](ch03.html "Chapter 3. Storing
    and Processing Users'' Data"), *Storing and Processing Users'' Data*, and all
    the class methods match a counterpart in the GCS Client Library, so it is very
    compact. Notice how in the `url` parameter we are telling Django to use the Google
    CDN to serve the files from our storage. We then add the following optional methods
    to complete our storage backend:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 代码基本上与我们在[第3章](ch03.html "第3章。存储和处理用户数据")中看到的一样，*存储和处理用户数据*，所有类方法都与GCS客户端库中的对应方法匹配，因此非常紧凑。注意在`url`参数中，我们告诉Django使用Google
    CDN从我们的存储中提供文件。然后我们添加以下可选方法来完成我们的存储后端：
- en: '[PRE53]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The `path()` method returns the full path to the file, including the leading
    slash and the bucket name. Access to the `bucket` root is not allowed, and we
    raise an exception in that case.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`path()`方法返回文件的完整路径，包括前面的斜杠和存储桶名称。不允许访问`bucket`根目录，在这种情况下我们将引发异常。'
- en: 'Now that the custom storage backend is complete, we tell Django to use it,
    so we write the following code in the `settings.py` module:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在自定义存储后端已经完成，我们告诉Django使用它，因此我们在`settings.py`模块中写下以下代码：
- en: '[PRE54]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'To see the custom file storage in action, we are going to slightly change the
    requirements of our Notes application. For the sake of simplicity, we will support
    only one file attached to every note so that we can simply add a couple of fields
    to the Note model class in our `models.py` module:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看自定义文件存储的实际效果，我们将稍微改变我们笔记应用的某些要求。为了简化，我们将只支持每个笔记附加一个文件，这样我们就可以简单地在我们`models.py`模块中的`Note`模型类中添加几个字段：
- en: '[PRE55]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The `attach` field is of the `FileField` type. This means Django will take
    care of the upload and store procedure for us, using our file storage. The `thumbnail_url`
    field will contain a string with the URL to retrieve the cropped version of the
    attachment if it is an image, just as we saw in [Chapter 3](ch03.html "Chapter 3. Storing
    and Processing Users'' Data"), *Storing and Processing Users'' Data*. It''s important
    to remember that we have to perform a migration for our `core` application after
    this change. We don''t want to show the `thumbnail_url` field in our HTML form,
    so we change the `Meta` class in the `NoteForm` file accordingly:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`attach`字段是`FileField`类型。这意味着Django将为我们处理上传和存储过程，使用我们的文件存储。`thumbnail_url`字段将包含一个字符串，其中包含检索附件裁剪版本的URL，如果它是图像，就像我们在[第3章](ch03.html
    "第3章。存储和处理用户数据")中看到的那样，*存储和处理用户数据*。重要的是要记住，在此更改后，我们必须对我们的`core`应用执行迁移。我们不希望在HTML表单中显示`thumbnail_url`字段，因此我们相应地更改`NoteForm`文件中的`Meta`类：'
- en: '[PRE56]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'At this point, the HTML form will show the file input field, but we need to
    handle uploads in our `home` view:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，HTML表单将显示文件输入字段，但我们需要在我们的`home`视图中处理上传：
- en: '[PRE57]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'First of all, we pass the `request.FILES` dictionary containing uploaded data
    to the form constructor so that it can process and validate our `attach` field.
    Then, if the field is present, we generate the thumbnail URL when possible and
    update our `note` model instance accordingly. Here, we use our custom storage
    class to retrieve the path to the file in the Cloud Storage. A custom storage
    backend class is not usually supposed to be used directly by the developer, but
    in this case, we can turn a blind eye and avoid code duplication. The very last
    step of the procedure is to show the attachment in the Notes main page, so we
    change the `main.html` template in this way:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将包含上传数据的`request.FILES`字典传递给表单构造函数，以便它可以处理和验证我们的`attach`字段。然后，如果该字段存在，我们将在可能的情况下生成缩略图URL，并相应地更新我们的`note`模型实例。在这里，我们使用我们的自定义存储类从云存储中检索文件的路径。通常情况下，自定义存储后端类不应该被开发者直接使用，但在这个案例中，我们可以睁一只眼闭一只眼，避免代码重复。程序的最后一个步骤是在笔记主页面中显示附件，所以我们这样修改`main.html`模板：
- en: '[PRE58]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Even if this version of Notes supports only one attachment for each note, we
    keep the same HTML structure we used for the webapp2 version to avoid rewriting
    CSS rules. We will see a thumbnail if the attachment is an image and the filename
    otherwise.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 即使这个版本的笔记只支持每个笔记一个附件，我们仍然保持与webapp2版本相同的HTML结构，以避免重写CSS规则。如果附件是图像，我们将看到一个缩略图，否则显示文件名。
- en: Summary
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This was a long journey through the lands of Django, and even if we don't have
    all the features of the webapp2 version of Notes, at this point, we do have a
    solid starting point to add all the missing pieces. We already know how to deal
    with the Cloud Platform services, and we can complete the porting as an exercise
    to get better at Django programming and become even more confident with all the
    technologies behind App Engine.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一次穿越 Django 领地的漫长旅程，即使我们没有 Notes 的 webapp2 版本的所有功能，但在这个阶段，我们确实有一个稳固的起点来添加所有缺失的部分。我们已经知道如何处理云平台服务，并且我们可以将迁移作为练习来完成，以提升
    Django 编程技能，并对 App Engine 背后的所有技术更加自信。
- en: In this chapter, we learned how to start a Django project, the basic concepts
    behind the framework, and how to integrate it smoothly inside an App Engine application.
    Using Django version 1.7, we also had the opportunity of dealing with the brand
    new migration system and getting the most out of the Cloud SQL database service.
    At this point, we know how to deal with forms, a simple example showing how easy
    life can be with the help of a framework like Django that saves us a lot of repetitive
    work. Another important step we took towards the perfect blend between Django
    and App Engine was the integration of the Google Cloud Storage service, an excellent
    backend used to store the files users upload to our Notes application.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何启动 Django 项目，框架背后的基本概念，以及如何将其顺利集成到 App Engine 应用程序中。使用 Django 1.7
    版本，我们还有机会处理全新的迁移系统，并充分利用 Cloud SQL 数据库服务。到目前为止，我们知道如何处理表单，一个简单的例子展示了在 Django 这样的框架帮助下，生活可以多么轻松，它为我们节省了大量重复性工作。我们朝着
    Django 和 App Engine 完美融合迈出的另一个重要步骤是集成 Google Cloud Storage 服务，这是一个用于存储用户上传到我们
    Notes 应用程序的文件的优秀后端。
- en: In the next chapter, we will go back to working with the webapp2 version of
    Notes to implement a REST API through the Google Cloud Endpoints technology.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将回到使用 Notes 的 webapp2 版本，通过 Google Cloud Endpoints 技术实现 REST API。
