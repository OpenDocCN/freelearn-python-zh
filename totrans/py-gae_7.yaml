- en: Chapter 7. Building an Application with Django
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Django** is an open source web application framework written in Python, originally
    written in 2003 by Adrian Holovaty and Simon Willison to quickly address the need
    for a web-based, database-driven application serving contents to an online newspaper.
    Django was released to the public as an open source project in 2005, and rapidly
    gained a strong following. With tens of thousands of users and contributors from
    all around the world, Django is one of the most adopted web frameworks among the
    Python community today, supported by an independent, non-profit foundation that
    promotes the project and protects its intellectual property.'
  prefs: []
  type: TYPE_NORMAL
- en: One of the components that have contributed the most to the success of Django
    is its **Object-Relational Mapping** (**ORM**), the data access layer that maps
    the underlying relational database with some object-oriented code written in Python.
    At first, what was considered a strong point of the framework turned out to be
    a weakness within the App Engine environment. In fact, Django provides support
    for relational databases only, thus excluding the Datastore option.
  prefs: []
  type: TYPE_NORMAL
- en: However, things have deeply changed after the release of the Google Cloud SQL
    service, and now we can use Django and its ORM with a relational database on the
    Google Cloud Platform. In this chapter, we will reimplement several features of
    the original Notes application, starting from zero and using Django instead of
    the webapp2 framework, showing how the App Engine platform can be a viable solution
    to deploy and run Django applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the development environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Cloud SQL with the ORM by using the built-in authentication system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uploading files on the Google Cloud Storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the local environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the time of writing this book, App Engine provides Django version 1.4 and
    1.5 as a third-party library for the Python 2.7 runtime environment. Even though
    it is quite old (Django 1.4 was released on March 2012 and 1.5 was released in
    February 2013), the 1.4 version is currently the long-term support distribution
    framework, with security patches and data loss fixes guaranteed until March 2015,
    and the 1.5 version (thus marked as experimental on App Engine) contains a lot
    of new features and improvements compared to the 1.4 version. For these reasons,
    we can safely build our applications using one of the Django packages provided
    by App Engine without the risk of producing legacy code.
  prefs: []
  type: TYPE_NORMAL
- en: However, if we can afford to drop the official support that Google provides
    to Django 1.4 and 1.5, we can use the latest version of Django currently available,
    1.7, the only difference being that we will have to take care of the deployment
    of the package on our own because we won't find it on the production server.
  prefs: []
  type: TYPE_NORMAL
- en: Since the deployment of applications written with Django 1.4 and 1.5 is well
    covered on the official documentation, and since we're building a prototype for
    the only purpose of learning how to get the most out of Google App Engine, we're
    going to develop our Django Notes application on Django 1.7; let's see how.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a virtual environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we need to use a specific version of Python packages that most likely differ
    from the ones provided by the package manger of our operating system, it's better
    to isolate the installation of such software in a separated environment using
    a tool such as **virtualenv**, and avoid clashes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Provided we are using Python 2.7, we can install virtualenv using the `pip`
    package manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now proceed to start a new App Engine application as we did in [Chapter
    1](ch01.html "Chapter 1. Getting Started"), *Getting Started*, by simply creating
    the application root folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can set up a virtual environment inside the application folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Every time we want to work in a virtual environment, we need to activate it
    before so that we can transparently use Python and pip executables to run code
    and install packages. For Linux and Mac OS X, we can activate a virtual environment
    in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'For Windows, we can simply invoke the activation script in the `Scripts` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To deactivate the virtual environment and stop referring to the isolated Python
    installation, we can issue the following command for every supported operating
    system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We now need to make the local App Engine Python runtime available to our virtual
    environment. If we followed the instructions in [Chapter 1](ch01.html "Chapter 1. Getting
    Started"), *Getting Started*, we should now have installed the App Engine in a
    path on the filesystem depending on which operating system we are running. Take
    note of that path; for example, on Mac OS X, the App Engine SDK is sym-linked
    to the `/usr/local/google_appengine` URL. We then create a file named `gae.pth`
    and put it into the `site-package` directory of the virtual environment at the
    `$VIRTUAL_ENV/lib/python2.7/site-packages/` path.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `$VIRTUAL_ENV` variable is an environment variable, available while the
    virtual environment is active, that points to the virtual environment installation
    on our local filesystem. The `.pth` file must contain the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To check that everything is working properly, we can activate the environment
    and try to import the App Engine package. For example, on Linux and Mac OS X,
    we can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Installing dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have a virtual environment set up for our application, we can begin
    to install the dependencies needed to run the Django Notes application. Of course,
    the first package we need to install is Django:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As we have learned in [Chapter 3](ch03.html "Chapter 3. Storing and Processing
    Users' Data"), *Storing and Processing Users' Data*, we need to install the package
    with the `-t` option so that it will be uploaded to the production server during
    the deployment process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since Django is also provided by the App Engine Python SDK, we need to be sure
    that when we import the `import django` package, Python is actually referring
    to the 1.7 package in our application root folder. There are many ways to accomplish
    this, but we will add the following contents to the `gae.pth` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the `fix_sys_path()` function prepends all the App Engine packages and
    modules to the Python path, we need to insert the path where Django 1.7 lives
    before anything else. That''s why we''re using the `sys.path.insert()` function
    here. To be sure that we are using the right version of Django, once the virtualenv
    tool is active, we can write this at the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The output should be something like `1.7.1`.
  prefs: []
  type: TYPE_NORMAL
- en: We will keep adding packages as long as we need them, but we have to remember
    to activate the virtual environment every time we want to run the project locally
    or deploy the application, and most importantly, every time we install a new package.
  prefs: []
  type: TYPE_NORMAL
- en: Rewriting our application using Django 1.7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We already created the application root folder, the same folder we installed
    the virtual environment in. Django provides a script that builds a standard application
    layout called `project`, also providing some default content for the configuration
    file. To start a new project within the application root, we issue the following
    at the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We should now have a folder called `notes` inside our application root containing
    a Python module called `wsgi.py` we need to be aware of, as we will use it inside
    the `app.yaml` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we already know, to create a new App Engine application, we need to provide
    an `app.yaml` file. We can pick any of the `app.yaml` files from the previous
    chapters as a base, and then rewrite it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We changed the version number so that we can easily manage which application
    should run on the production server at any time: the old one built with the webapp2
    framework, or the new one built with Django. We define only one handler, which
    will match requests for any URL and serve them using the application instance
    inside the `wsgi.py` module generated by the `django_admin.py` script inside our
    project folder.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now run the development server and point the browser to the `http://localhost:8080`
    URL. If Django is working, we should see a message like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Rewriting our application using Django 1.7](img/8194OS_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As stated by the web page itself, we have created our first application on App
    Engine using the Django web framework. Now we can proceed and let our application
    do something more useful.
  prefs: []
  type: TYPE_NORMAL
- en: Using Google Cloud SQL as a database backend
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We already mentioned that we will make use of Google Cloud SQL as a relational
    database backend so that we can run every component of the Django framework without
    resorting to additional packages or derived projects.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the relational database layer to make the ORM work is one of the
    first steps we have to take when developing a Django application. In fact, several
    key components, such as the user authentication mechanism, rely on a working database.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Django ORM provides full support for MySQL databases out of the box, so
    all of the additional software we need in order to use Google Cloud SQL is the
    MySQLdb Python package, which we will install with the `pip` package manager,
    exactly as we did in [Chapter 5](ch05.html "Chapter 5. Storing Data in Google
    Cloud SQL"), *Storing Data in Cloud SQL*. The following command is used to install
    the package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'To use the package in the production server, we have to add the following to
    our `app.yaml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We already know how to configure Google Cloud SQL, so we assume that at this
    point, we have an instance up and running. We can access both from the local development
    and the App Engine application, and we have already created a database for the
    project.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we open the `settings.py` module inside our Django project folder, we will
    see that it contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Django can use and connect to multiple relational databases at the same time
    from a single application, and the `DATABASES` dictionary contains another Python
    dictionary holding the configuration for each of them. For small applications,
    such as our Notes, we can use only one database—the one labeled `default`. The
    parameters to configure Cloud SQL when connecting from our local development environment
    and the parameters we need when the application is running on App Engine production
    servers slightly differ, so if we want to keep just one version of the settings
    module, we need to add some logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to create a `utils.py` module at the `<app_root>/notes/notes`
    path, containing the `on_appengine()` function from [Chapter 5](ch05.html "Chapter 5. Storing
    Data in Google Cloud SQL"), *Storing Data in Cloud SQL*, to determine whether
    our application is running on App Engine or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we edit the `settings.py` module and change the `DATABASES` dictionary
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We use the same Python database driver when we connect both from the local development
    environment and the App Engine production server. The database name and user credentials
    are also the same, but we need to specify a different `HOST` parameter depending
    on where the application is running because on App Engine, the connection is performed
    with a Unix socket, while in local connection, we use a TCP socket. If we want
    to use a local MySQL installation instead, we can change the `NAME`, `USER`, `PASSWORD`,
    and `HOST` parameters accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Before moving to the final step to configure the relational database, we need
    to introduce the concept of **migrations**, a new feature of Django 1.7\. Since
    the ORM maps Python objects to the database schema, it will likely require altering
    the schema accordingly with the changes we make to the Python code. Django writes
    such changes to one or more migration files that reside in several `migration`
    folders inside our project source tree. We will see later in this chapter how
    to deal with migrations. For the moment, all we need to do is to invoke a command
    called `migrate` to create the first version of the database schema.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To invoke Django commands, we use the `manage.py` script, which was generated
    by the `django_admin.py` script when we first created the project. Inside the
    project folder, we can launch commands in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'To see the list of available commands, we can invoke the `manage.py` script
    without arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To launch the `migrate` command, we issue the following at the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If the Cloud SQL instance is well configured, we should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the user authentication system is available by default, we can add a
    `superuser` user to the system with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The command will prompt for username, e-mail address, and password. We can provide
    the credentials of our choice.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a reusable application in Django
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We already used the term `project` when referring to the filesystem layout generated
    by the `django_admin.py` script. It contains all of the code and the assets needed
    to run our web applications called Notes. The core of a Django project is its
    settings file, which defines the global environment and configurations, and we
    have already seen how to use it to set up the relational database layer.
  prefs: []
  type: TYPE_NORMAL
- en: It's now time to introduce the term "application." In the Django lingo, an `application`
    is a Python package that provides a well-defined set of functionalities and can
    be reused across different Django projects. We must not confuse the term "application"
    as defined in Django and the more general term "web application." Even though
    Notes is actually an application in the general sense, it is developed as a Django
    project and contains some functional blocks called Django applications.
  prefs: []
  type: TYPE_NORMAL
- en: A Django application usually contains the ORM model classes, view functions
    and classes, HTML templates, and static assets. An `application` package can be
    installed via the `pip` package manager or provided together with the `project`
    package. We need to know that a Django project will use an application only if
    it is listed in the `INSTALLED_APPS` settings value in the `settings.py` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create one Django application to implement Notes core functionalities,
    an application called `core`, to be precise. To create an empty application inside
    our project, we can use the `startapp` command and pass the name of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We can see how the command created a Python package inside our project folder
    called `core` as we asked for. The package contains a set of standard modules
    we will likely want to implement, as we will see in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned before, we need to list our newly created app inside the `INSTALLED_APPS`
    settings to tell Django that it must use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Django 1.7 provides a registry called `apps` provided by the `django.apps`
    package, which stores an `AppConfig` object for each installed application. We
    can use `AppConfig` objects to introspect applications'' metadata or to change
    the configuration of a determined application. To see the `apps` registry in action,
    we can access the Django shell like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can test the following Python code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Views and templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that the data backend is functional, we can start implementing the first
    building block—providing the view showing the homepage for our Notes web application.
    A view in the Django world is nothing more than a Python function or class that
    takes an HTTP request and returns an HTTP response, implementing whatever logic
    is needed to build the final content delivered to the client. We will add the
    code implementing a view to build the homepage to the `views.py` module we created
    inside our `core` application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The view parameter called `home` does something very similar to the `get()`
    method of the `MainHandler` class in the webapp2 version of Notes. We create a
    `context` dictionary that will be passed to the template during the rendering
    process. Then we call the `render()` method, which passes the same `request` object
    we received as a parameter—a string containing the path to the HTML template.
    It will be used for the page and the `context` dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the webapp2 version of Notes, we used Jinja2 to render our pages, but Django
    has its own template system already integrated in the framework. The language
    we use inside the HTML files is very similar to Jinja2, but some major differences
    still exist, so we have to rewrite our templates. We create a new HTML file at
    the `core/templates/core/main.html` path, relative to the `project` folder and
    containing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Notice in the template how we are using the `{{ django_version }}` element,
    which outputs the variable we put in the context dictionary, and the `{{ user
    }}` element, which is provided by default by the Django authentication system.
    Since we did not perform a login, the current user is set to a special entity
    called **anonymous user**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a view function providing an HTTP response and a template
    to render an HTML page, we need to map a URL of our choice to the view, just as
    we did with webapp2\. Django has a URL configurator module (also known as the
    `URLconf` module) called `urls.py`, containing pure Python code and defining a
    mapping between URLs described with regular expressions and view functions or
    classes. The `django_admin.py` script generates an `urls.py` module we can use
    as a starting point, but the final version to map the homepage view should be
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'A `URLconf` module must define a variable named `urlpatterns` and contain a
    list of `django.conf.urls.url` instances that will be iterated in order by Django
    until one of them matches a requested URL. When a match with a regular expression
    occurs, Django stops the iteration and can potentially do two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Import and call the `view` passed as parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Process an `include` statement that loads a `urlpattern` object from another
    module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In our case, we match the root URL for the domain and import the `home` function
    view we previously defined in the `views.py` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we put the same CSS file we used for the webapp2 version of Notes
    at the `static/css/notes.css` path, relative to the App Engine application root
    folder, and we should get the result for the homepage, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Views and templates](img/8194OS_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Authenticating users with Django
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To authenticate our users, we won''t use the App Engine User service, and we
    will completely rely on Django instead. Django provides a built-in user authentication
    system that also provides authorization checking. We can verify that users are
    who they claim to be, and we can determine what they are allowed to do. The authentication
    system is implemented as a Django application, and we have to ensure that it is
    listed in the `INSTALLED_APPS` settings before trying to use it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The authentication system is also responsible for adding to the template context
    the `user` variable so that we can write `{{ user }}` in our HTML templates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we won''t use the App Engine User service, we must implement the login
    and logout pages by ourselves, and Django helps us by providing two out-of-the-box
    views that serve as a login and a logout page. First of all, we need to map the
    login and logout URLs to such views in the `URLconf` module, so we add the following
    to the `urls.py` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Even if the logic for logging in users comes for free, we need to provide an
    HTML template for the login page. We add a folder called `registration` inside
    the `template` folder of the `core` application and create a file in it called
    `login.html`, containing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We use the same style sheet and the same page structure of the main page to
    show the login form. To populate the `action` attribute of the form, we use the
    `url` template tag, which retrieves the URL of a view whose name is given. In
    this case, the attribute will contain the URL mapped to the `django.contrib.auth.views.login`
    view. We then use the `{% csrf_token %}` template tag to create a field inside
    the form that Django needs in order to prevent **Cross-Site Request Forgery**
    (**CSRF**) attacks. We also add a hidden field containing the URL we want to redirect
    users to after a successful login. This URL is handled by Django, and the authentication
    system takes care of filling the `next` value in the template context.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our users will be automatically redirected to the login page whenever they
    attempt to access a URL that is login-protected. To see the authentication system
    in action, we tell Django to protect the `home` view by adding the following code
    to the `views.py` module inside the `core` application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have added the `login_required()` function decorator to the `home`
    view, only logged-in users will be able to see page contents, and others will
    be redirected to the login page. If we try to access the `http://localhost:8080`
    URL, this is what we should see:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Authenticating users with Django](img/8194OS_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can log in with the `superuser` user, using the same credentials we provided
    during the `createsuperuser` command execution earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we have to provide a link to the logout view, which users can access
    to terminate their authenticated session. In the `main.html` template file, we
    add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We simply retrieve the URL mapped to the logout view and Django will do the
    rest, performing all the operations needed to make the user log out.
  prefs: []
  type: TYPE_NORMAL
- en: Using the ORM and migrations system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are already familiar with the model classes provided by webapp2 because
    in [Chapter 2](ch02.html "Chapter 2. A More Complex Application"), *A More Complex
    Application*, we used them to map Python objects to Datastore entities. Django
    uses an almost identical approach; we define Python classes deriving from the
    `django.db.models.Model` package, and the ORM component takes care of mapping
    instances of those classes to rows and tables in the underlying relational database.
    To see the ORM in action, we add the following models to the `models.py` module
    inside the `core` application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We define a `Note` model class with a `title` property containing small text
    (up to ten characters), a `content` property containing text of arbitrary length,
    a `date_created` property containing date and time, and an `owner` property, which
    is a foreign key referring to an instance of the `User` model from the Django
    authentication system. Since we pass the `blank=False` parameter to the `TextField`
    model field constructor, the `content` property is required.
  prefs: []
  type: TYPE_NORMAL
- en: We then define a `CheckListItem` model class with a `title` property containing
    small text (up to hundred characters), a `checked` property containing a Boolean
    value that defaults to the `False` parameter when not specified, and a `note`
    property, which is a foreign key referring to the `Note` model. The `related_name='checklist_items'`
    parameter we pass to the `ForeignKey` model field constructor means that we will
    be able to access the set of checklist items tied to a `Note` instance accessing
    a property called `checklist_items` on the instance itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'To translate our models into the SQL code needed to map them to the relational
    database, we need to perform a migration, more precisely the initial migration
    since this is the first time we are doing this for the core application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the migration should be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The `makemigrations` command creates a `migration` folder inside the `core`
    application path with a migration file called `0001_initial.py`. The migration
    file contains the list of the operations the ORM needs to perform in order to
    map the current Python code to the database schema, creating or altering tables
    accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Migration files are part of the codebase and should be kept under version control
    like any other Python module.
  prefs: []
  type: TYPE_NORMAL
- en: 'To apply the changes to the database, we need to perform a migration with this
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of applying the changes to the database should be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we have created the database schema for our core application.
    If we want to confirm exactly which SQL code was produced by the migration system,
    we can issue the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This command will print on the command line the SQL code produced for our initial
    migration.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we might notice that our `Note` model has a `title` field that
    is really too small to contain descriptive titles for our notes, so we change
    it in `models.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, this change will alter the database schema, so we need to perform
    a migration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, the output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'A file called `0002_auto_20141101_1128.py` is added to the migration folder,
    containing the SQL instructions needed to alter the database schema to reflect
    our new Python code. The last step we need to take is to apply the migration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Processing forms with the Forms API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that our database is ready to store our data, we can implement the code
    needed to handle the form we show in the main page to create new notes, and Django''s
    Forms API will simplify and automate a great part of this work. In particular,
    we will let Django take care of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the HTML form automatically from the contents of our `Note` model class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processing and validating submitted data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing a CSRF security check
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'First of all, we implement a class deriving from the `django.forms.ModelForm`
    class that will let us define and process our form. Inside the `core` application,
    we create a new Python module called `forms.py`, containing the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: We define a Python class implementing a so-called `model` form, a Django `form`
    class that defines and validates data from a Django model. We define another class
    called `Meta` inside the `NoteForm` class. It contains the form's metadata, mainly
    the name of the model it will work on and a list of fields of the model we don't
    want to show on the HTML form.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the `NoteForm` class in our `home` view, so we add the following
    to the `views.py` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: We initially assign a `user` variable containing the current logged-in user
    instance. Then we check whether the view is serving a HTTP `POST` request. If
    this is the case, we instantiate our model form class, passing the request itself
    to the constructor. The form will extract the data it needs from the request body.
    We then call the `is_valid()` method to check whether all the fields needed were
    filled with the right data, and we call the `save()` method passing the `commit=False`
    parameter that will create a new `Note` instance without saving it in the database.
    We assign the `owner` field to the current logged-in user and save the `Note`
    instance, this time making it persist in the database. Finally, we redirect the
    user to the homepage URL. We call the `reverse()` method and pass the view name
    as a parameter. If the request is of the `GET` type, we instantiate an empty model
    form. The `NoteForm` instance is added to the context so that the template can
    use it to render the HTML form. Here, we perform our first database query using
    the Django ORM. The `Note.objects.filter(owner=user).order_by('-id')` query returns
    a list of the notes' objects filtered by the current logged-in user as `owner`
    and ordered by the `id` parameter in reverse order (notice the `-` character before
    the field name). The list is added to the context so that the template can render
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final step we need to take is modifying the `main.html` template so that
    it can properly render the new contents we have just added to the context. Let''s
    start with the form, which we can easily define using the model form instance,
    `form`, without writing too much HTML code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We first iterate the visible fields of the form. Note that Django will take
    care of printing the correct tags and labels. After iterating through the visible
    fields, we print the hidden fields, then print the CSRF token (as we did for the
    login form), and finally provide the `submit` button. Right after the form definition,
    we can add the loop that produces the HTML code to show the notes to the current
    user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, the `input` control to add the `checklist_items` parameter is
    missing. This is because we want to provide such items with the same list as we
    did in the webapp2 version of Notes—a comma-separated list. Since the Note model
    does not provide a field to hold this list, the model form won''t show anything
    to provide such data. Anyway, we can manually add arbitrary fields to a model
    form independently from the fields of the associated model. In our `forms.py`
    module, we add the following to the `NoteForm` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We add a new field called `ci_items`. It is not required and is rendered using
    a `forms.TextInput` widget. We don''t use the default widget here because we want
    to provide the `placeholder` attribute to the corresponding HTML tag. We can refresh
    the homepage to see the new field appearing, without the need to touch the HTML
    template file. Now we need to process this new field, and we do this in the `home`
    view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: After saving the note instance, we access the `cl_items` value in the `cleaned_data`
    dictionary Django filled after the form was processed. We split the string using
    the comma as a separator, create a new `CheckListItem` instance for every item
    the user passed through the form field, and cause that instance to persist.
  prefs: []
  type: TYPE_NORMAL
- en: Uploading files to Google Cloud Storage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, when users upload their files, Django stores content locally in
    the server. As we already know, App Engine applications run in a sandboxed environment
    without being able to access the server filesystem, so this approach simply cannot
    work. Anyway, Django provides an abstraction layer, the file storage system. We
    can use this layer to customize where and how uploaded files are stored. We are
    going to take advantage of this feature, implementing our own storage backend
    class that will store uploaded files on the Google Cloud Storage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before starting, we need to install the GCS Client Library as we did in [Chapter
    3](ch03.html "Chapter 3. Storing and Processing Users'' Data"), *Storing and Processing
    Users'' Data*, in order to easily interact with the Cloud Storage from our storage
    backend. We then create a `storage.py` module in our `core` application, containing
    the definition of the storage backend class, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor must be invoked without arguments, so everything we need from
    within the storage backend must be retrieved from the Django settings. In this
    case, we expect that the bucket name was specified in the `BUCKET_NAME` settings
    value, and we ensure that it is a valid name using the `validate_bucket_name`
    parameter from the GCS Client Library. We then add to our class the methods we
    must provide to meet the custom storage backend requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The code is pretty much the same as what we saw in [Chapter 3](ch03.html "Chapter 3. Storing
    and Processing Users'' Data"), *Storing and Processing Users'' Data*, and all
    the class methods match a counterpart in the GCS Client Library, so it is very
    compact. Notice how in the `url` parameter we are telling Django to use the Google
    CDN to serve the files from our storage. We then add the following optional methods
    to complete our storage backend:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The `path()` method returns the full path to the file, including the leading
    slash and the bucket name. Access to the `bucket` root is not allowed, and we
    raise an exception in that case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the custom storage backend is complete, we tell Django to use it,
    so we write the following code in the `settings.py` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'To see the custom file storage in action, we are going to slightly change the
    requirements of our Notes application. For the sake of simplicity, we will support
    only one file attached to every note so that we can simply add a couple of fields
    to the Note model class in our `models.py` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The `attach` field is of the `FileField` type. This means Django will take
    care of the upload and store procedure for us, using our file storage. The `thumbnail_url`
    field will contain a string with the URL to retrieve the cropped version of the
    attachment if it is an image, just as we saw in [Chapter 3](ch03.html "Chapter 3. Storing
    and Processing Users'' Data"), *Storing and Processing Users'' Data*. It''s important
    to remember that we have to perform a migration for our `core` application after
    this change. We don''t want to show the `thumbnail_url` field in our HTML form,
    so we change the `Meta` class in the `NoteForm` file accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, the HTML form will show the file input field, but we need to
    handle uploads in our `home` view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'First of all, we pass the `request.FILES` dictionary containing uploaded data
    to the form constructor so that it can process and validate our `attach` field.
    Then, if the field is present, we generate the thumbnail URL when possible and
    update our `note` model instance accordingly. Here, we use our custom storage
    class to retrieve the path to the file in the Cloud Storage. A custom storage
    backend class is not usually supposed to be used directly by the developer, but
    in this case, we can turn a blind eye and avoid code duplication. The very last
    step of the procedure is to show the attachment in the Notes main page, so we
    change the `main.html` template in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Even if this version of Notes supports only one attachment for each note, we
    keep the same HTML structure we used for the webapp2 version to avoid rewriting
    CSS rules. We will see a thumbnail if the attachment is an image and the filename
    otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This was a long journey through the lands of Django, and even if we don't have
    all the features of the webapp2 version of Notes, at this point, we do have a
    solid starting point to add all the missing pieces. We already know how to deal
    with the Cloud Platform services, and we can complete the porting as an exercise
    to get better at Django programming and become even more confident with all the
    technologies behind App Engine.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we learned how to start a Django project, the basic concepts
    behind the framework, and how to integrate it smoothly inside an App Engine application.
    Using Django version 1.7, we also had the opportunity of dealing with the brand
    new migration system and getting the most out of the Cloud SQL database service.
    At this point, we know how to deal with forms, a simple example showing how easy
    life can be with the help of a framework like Django that saves us a lot of repetitive
    work. Another important step we took towards the perfect blend between Django
    and App Engine was the integration of the Google Cloud Storage service, an excellent
    backend used to store the files users upload to our Notes application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will go back to working with the webapp2 version of
    Notes to implement a REST API through the Google Cloud Endpoints technology.
  prefs: []
  type: TYPE_NORMAL
