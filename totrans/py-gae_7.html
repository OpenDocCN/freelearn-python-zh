<html><head></head><body><div class="chapter" title="Chapter&#xA0;7.&#xA0;Building an Application with Django"><div class="titlepage"><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Building an Application with Django</h1></div></div></div><p><span class="strong"><strong>Django</strong></span> is <a id="id409" class="indexterm"/>an open source web application framework written in Python, originally written in 2003 by Adrian Holovaty and Simon Willison to quickly address the need for a web-based, database-driven application serving contents to an online newspaper. Django was released to the public as an open source project in 2005, and rapidly gained a strong following. With tens of thousands of users and contributors from all around the world, Django is one of the most adopted web frameworks among the Python community today, supported by an independent, non-profit foundation that promotes the project and protects its intellectual property.</p><p>One of the <a id="id410" class="indexterm"/>components that have contributed the most to the success of Django is its <span class="strong"><strong>Object-Relational Mapping </strong></span>(<span class="strong"><strong>ORM</strong></span>), the data access layer that maps the underlying relational database with some object-oriented code written in Python. At first, what was considered a strong point of the framework turned out to be a weakness within the App Engine environment. In fact, Django provides support for relational databases only, thus excluding the Datastore option.</p><p>However, things have deeply changed after the release of the Google Cloud SQL service, and now we can use Django and its ORM with a relational database on the Google Cloud Platform. In this chapter, we will reimplement several features of the original Notes application, starting from zero and using Django instead of the webapp2 framework, showing how the App Engine platform can be a viable solution to deploy and run Django applications.</p><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Configuring the development environment</li><li class="listitem" style="list-style-type: disc">Using Cloud SQL with the ORM by using the built-in authentication system</li><li class="listitem" style="list-style-type: disc">Uploading files on the Google Cloud Storage</li></ul></div><div class="section" title="Setting up the local environment"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec47"/>Setting up the local environment</h1></div></div></div><p>At the time of writing this book, App Engine provides Django version 1.4 and 1.5 as a third-party library for the Python 2.7 runtime environment. Even though it is quite old (Django 1.4 was released on March 2012 and 1.5 was released in February 2013), the 1.4 version is <a id="id411" class="indexterm"/>currently the long-term support distribution framework, with security patches and data loss fixes guaranteed until March 2015, and the 1.5 version (thus marked as experimental on App Engine) contains a lot of new features and improvements compared to the 1.4 version. For these reasons, we can safely build our applications using one of the Django packages provided by App Engine without the risk of producing legacy code.</p><p>However, if we can afford to drop the official support that Google provides to Django 1.4 and 1.5, we can use the latest version of Django currently available, 1.7, the only difference being that we will have to take care of the deployment of the package on our own because we won't find it on the production server.</p><p>Since the deployment of applications written with Django 1.4 and 1.5 is well covered on the official documentation, and since we're building a prototype for the only purpose of learning how to get the most out of Google App Engine, we're going to develop our Django Notes application on Django 1.7; let's see how.</p><div class="section" title="Configuring a virtual environment"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec35"/>Configuring a virtual environment</h2></div></div></div><p>When we need to use a specific version of Python packages that most likely differ from the ones <a id="id412" class="indexterm"/>provided by the package manger of our operating system, it's better to isolate the installation of such software in a separated environment using a tool such as <span class="strong"><strong>virtualenv</strong></span>, and avoid clashes.</p><p>Provided we are <a id="id413" class="indexterm"/>using Python 2.7, we can install virtualenv using<a id="id414" class="indexterm"/> the <code class="literal">pip</code> package manager:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>pip install virtualenv</strong></span>
</pre></div><p>We can now proceed to start a new App Engine application as we did in <a class="link" href="ch01.html" title="Chapter 1. Getting Started">Chapter 1</a>, <span class="emphasis"><em>Getting Started</em></span>, by simply creating the application root folder:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>mkdir django_notes &amp;&amp; cd django_notes</strong></span>
</pre></div><p>Now we can set up a virtual environment inside the application folder:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>virtualenv .</strong></span>
</pre></div><p>Every time we want to work in a virtual environment, we need to activate it before so that we can transparently use Python and pip executables to run code and install packages. For Linux and Mac OS X, we can activate a virtual environment in this way:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>source ./bin/activate</strong></span>
</pre></div><p>For Windows, we can simply invoke the activation script in the <code class="literal">Scripts</code> folder:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Scripts\activate</strong></span>
</pre></div><p>To deactivate the virtual environment and stop referring to the isolated Python installation, we can issue the following command for every supported operating system:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>deactivate</strong></span>
</pre></div><p>We now <a id="id415" class="indexterm"/>need to make the local App Engine Python runtime available to our virtual environment. If we followed the instructions in <a class="link" href="ch01.html" title="Chapter 1. Getting Started">Chapter 1</a>, <span class="emphasis"><em>Getting Started</em></span>, we should now have installed the App Engine in a path on the filesystem depending on which operating system we are running. Take note of that path; for example, on Mac OS X, the App Engine SDK is sym-linked to the <code class="literal">/usr/local/google_appengine</code> URL. We then create a file named <code class="literal">gae.pth</code> and put it into the <code class="literal">site-package</code> directory of the virtual environment at the <code class="literal">$VIRTUAL_ENV/lib/python2.7/site-packages/</code> path.</p><p>The <code class="literal">$VIRTUAL_ENV</code> variable is an environment variable, available while the virtual environment is active, that points to the virtual environment installation on our local filesystem. The <code class="literal">.pth</code> file must contain the following lines:</p><div class="informalexample"><pre class="programlisting">/path/to/appengine/sdk # /usr/local/google_appengine on Mac OS X
import dev_appserver; dev_appserver.fix_sys_path()</pre></div><p>To check that everything is working properly, we can activate the environment and try to import the App Engine package. For example, on Linux and Mac OS X, we can do this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>source bin/activate</strong></span>
<span class="strong"><strong>python -c"import google"</strong></span>
</pre></div></div><div class="section" title="Installing dependencies"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec36"/>Installing dependencies</h2></div></div></div><p>Now that<a id="id416" class="indexterm"/> we have a virtual environment set up for our <a id="id417" class="indexterm"/>application, we can begin to install the dependencies<a id="id418" class="indexterm"/> needed to run the Django Notes application. Of course, the first package we need to install is Django:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>pip install django -t &lt;app_root&gt;</strong></span>
</pre></div><p>As we have learned in <a class="link" href="ch03.html" title="Chapter 3. Storing and Processing Users' Data">Chapter 3</a>, <span class="emphasis"><em>Storing and Processing Users' Data</em></span>, we need to install the package with the <code class="literal">-t</code> option so that it will be uploaded to the production server during the deployment process.</p><p>Since Django is also provided by the App Engine Python SDK, we need to be sure that when we import the <code class="literal">import django</code> package, Python is actually referring to the 1.7 package in our application root folder. There are many ways to accomplish this, but we will add the following contents to the <code class="literal">gae.pth</code> file:</p><div class="informalexample"><pre class="programlisting">/path/to/appengine/sdk # /usr/local/google_appengine on Mac OS X
import dev_appserver; dev_appserver.fix_sys_path()
import sys; sys.path.insert(1, '/path/to/application/root')</pre></div><p>Since the <code class="literal">fix_sys_path()</code> function prepends all the App Engine packages and modules to the Python path, we need to insert the path where Django 1.7 lives before anything else. That's why we're using the <code class="literal">sys.path.insert()</code> function here. To be sure that we are using the right version of Django, once the virtualenv tool is active, we can write this at the <a id="id419" class="indexterm"/>command line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>python -c"import django; print django.get_version()"</strong></span>
</pre></div><p>The output<a id="id420" class="indexterm"/> should be something like <code class="literal">1.7.1</code>.</p><p>We will keep<a id="id421" class="indexterm"/> adding packages as long as we need them, but we have to remember to activate the virtual environment every time we want to run the project locally or deploy the application, and most importantly, every time we install a new package.</p></div></div></div>
<div class="section" title="Rewriting our application using Django 1.7"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec48"/>Rewriting our application using Django 1.7</h1></div></div></div><p>We already <a id="id422" class="indexterm"/>created the application root folder, the same folder we installed the virtual environment in. Django provides a script that<a id="id423" class="indexterm"/> builds a standard application layout called <code class="literal">project</code>, also providing some default content for the configuration file. To start a new project within the application root, we issue the following at the command line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>django/bin/django-admin.py startproject notes</strong></span>
</pre></div><p>We should now have a folder called <code class="literal">notes</code> inside our application root containing a Python module called <code class="literal">wsgi.py</code> we need to be aware of, as we will use it inside the <code class="literal">app.yaml</code> file.</p><p>As we already know, to create a new App Engine application, we need to provide an <code class="literal">app.yaml</code> file. We can pick any of the <code class="literal">app.yaml</code> files from the previous chapters as a base, and then rewrite it as follows:</p><div class="informalexample"><pre class="programlisting">application: the_registered_application_ID
version: 2
runtime: python27
api_version: 1
threadsafe: yes

handlers:
- url: /static
  static_dir: static

- url: /.*
  script: notes.wsgi.application</pre></div><p>We changed the version number so that we can easily manage which application should run on the <a id="id424" class="indexterm"/>production server at any time: the <a id="id425" class="indexterm"/>old one built with the webapp2 framework, or the new one built with Django. We define only one handler, which will match requests for any URL and serve them using the application instance inside the <code class="literal">wsgi.py</code> module generated by the <code class="literal">django_admin.py</code> script inside our project folder.</p><p>We can now run the development server and point the browser to the <code class="literal">http://localhost:8080</code> URL. If Django is working, we should see a message like this:</p><div class="mediaobject"><img src="graphics/8194OS_07_01.jpg" alt="Rewriting our application using Django 1.7"/></div><p>As stated by the web page itself, we have created our first application on App Engine using the Django web framework. Now we can proceed and let our application do something more useful.</p><div class="section" title="Using Google Cloud SQL as a database backend"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec37"/>Using Google Cloud SQL as a database backend</h2></div></div></div><p>We <a id="id426" class="indexterm"/>already mentioned that we will make use of Google Cloud SQL as a relational database backend so that we<a id="id427" class="indexterm"/> can run every component of the Django framework without resorting to additional packages or derived projects.</p><p>Configuring the relational database layer to make the ORM work is one of the first steps we have to take when developing a Django application. In fact, several key components, such as the user authentication mechanism, rely on a working database.</p><p>The Django ORM provides full support for MySQL databases out of the box, so all of the additional software we need in order to use Google Cloud SQL is the MySQLdb Python package, which we will install with the <code class="literal">pip</code> package manager, exactly as we did in <a class="link" href="ch05.html" title="Chapter 5. Storing Data in Google Cloud SQL">Chapter 5</a>, <span class="emphasis"><em>Storing Data in Cloud SQL</em></span>. The following command is used to install the package:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>pip install MySQL-python</strong></span>
</pre></div><p>To use the package in the production server, we have to add the following to our <code class="literal">app.yaml</code> file:</p><div class="informalexample"><pre class="programlisting">libraries:
- name: MySQLdb
  version: "latest"</pre></div><p>We already know how to configure Google Cloud SQL, so we assume that at this point, we have an instance up and running. We can access both from the local development and the App Engine application, and we have already created a database for the project.</p><p>If we open the <code class="literal">settings.py</code> module inside our Django project folder, we will see that it contains the following:</p><div class="informalexample"><pre class="programlisting">DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),
    }
}</pre></div><p>Django can use and connect to multiple relational databases at the same time from a single application, and the <code class="literal">DATABASES</code> dictionary contains another Python dictionary holding the configuration for each of them. For small applications, such as our Notes, we can use only one database—the one labeled <code class="literal">default</code>. The parameters to configure Cloud SQL when connecting from our local development environment and the parameters we need when the application is running on App Engine production servers slightly differ, so if we <a id="id428" class="indexterm"/>want to keep just<a id="id429" class="indexterm"/> one version of the settings module, we need to add some logic.</p><p>First, we need to create a <code class="literal">utils.py</code> module at the <code class="literal">&lt;app_root&gt;/notes/notes</code> path, containing the <code class="literal">on_appengine()</code> function from <a class="link" href="ch05.html" title="Chapter 5. Storing Data in Google Cloud SQL">Chapter 5</a>, <span class="emphasis"><em>Storing Data in Cloud SQL</em></span>, to determine whether our application is running on App Engine or not:</p><div class="informalexample"><pre class="programlisting">import os

def on_appengine():
    return os.getenv('SERVER_SOFTWARE', '').startswith('Google App Engine')</pre></div><p>Then we edit the <code class="literal">settings.py</code> module and change the <code class="literal">DATABASES</code> dictionary with the following code:</p><div class="informalexample"><pre class="programlisting"># Database
# https://docs.djangoproject.com/en/1.7/ref/settings/#databases

from .utils import on_appengine

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': 'notes',
        'USER': 'notes',
        'PASSWORD': 'notes_password',
    }
}
if on_appengine():
    DATABASES['default']['HOST'] = '/cloudsql/my-project-id:myfirst'
else:
    DATABASES['default']['HOST'] = '&lt;instance_ip&gt;'</pre></div><p>We use the same Python database driver when we connect both from the local development environment and the App Engine production server. The database name and user credentials are also the same, but we need to specify a different <code class="literal">HOST</code> parameter depending on where the application is running because on App Engine, the connection is performed with a Unix socket, while in local connection, we use a TCP socket. If we want to use a local MySQL installation instead, we can change the <code class="literal">NAME</code>, <code class="literal">USER</code>, <code class="literal">PASSWORD</code>, and <code class="literal">HOST</code> parameters accordingly.</p><p>Before <a id="id430" class="indexterm"/>moving to the <a id="id431" class="indexterm"/>final step to <a id="id432" class="indexterm"/>configure the relational database, we need to introduce the concept of <span class="strong"><strong>migrations</strong></span>, a new feature of Django 1.7. Since the ORM maps Python objects to the database schema, it will likely require altering the schema accordingly with the changes we make to the Python code. Django writes such changes to one or more migration files that reside in several <code class="literal">migration</code> folders inside our project source tree. We will see later in this chapter how to deal with migrations. For the moment, all we need to do is to invoke a command called <code class="literal">migrate</code> to create the first version of the database schema.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note18"/>Note</h3><p>To invoke Django commands, we use the <code class="literal">manage.py</code> script, which was generated by the <code class="literal">django_admin.py</code> script when we first created the project. Inside the project folder, we can launch commands in this way:</p><div class="informalexample"><pre class="programlisting">python manage.py &lt;command&gt;</pre></div><p>To see the list of available commands, we can invoke the <code class="literal">manage.py</code> script without arguments:</p><div class="informalexample"><pre class="programlisting">python manage.py</pre></div></div></div><p>To launch the <code class="literal">migrate</code> command, we issue the following at the command line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>python manage.py migrate</strong></span>
</pre></div><p>If the Cloud SQL instance is well configured, we should see the following output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Operations to perform:</strong></span>
<span class="strong"><strong>  Apply all migrations: admin, contenttypes, auth, sessions</strong></span>
<span class="strong"><strong>Running migrations:</strong></span>
<span class="strong"><strong>  Applying contenttypes.0001_initial... OK</strong></span>
<span class="strong"><strong>  Applying auth.0001_initial... OK</strong></span>
<span class="strong"><strong>  Applying admin.0001_initial... OK</strong></span>
<span class="strong"><strong>  Applying sessions.0001_initial... OK</strong></span>
</pre></div><p>Since the user authentication system is available by default, we can add a <code class="literal">superuser</code> user to the system with this command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>python manage.py createsuperuser</strong></span>
</pre></div><p>The command will prompt for username, e-mail address, and password. We can provide the credentials of our choice.</p></div><div class="section" title="Creating a reusable application in Django"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec38"/>Creating a reusable application in Django</h2></div></div></div><p>We already<a id="id433" class="indexterm"/> used the term <code class="literal">project</code> when referring to the filesystem layout generated by the <code class="literal">django_admin.py</code> script. It contains all of the code<a id="id434" class="indexterm"/> and the assets needed to run our web applications called Notes. The core of a Django project is its settings file, which defines the global environment and configurations, and we have already seen how to use it to set up the relational database layer.</p><p>It's now time to introduce the term "application." In the Django lingo, an <code class="literal">application</code> is a Python package that provides a well-defined set of functionalities and can be reused across different Django projects. We must not confuse the term "application" as defined in Django and the more general term "web application." Even though Notes is actually an application in the general sense, it is developed as a Django project and contains some functional blocks called Django applications.</p><p>A Django application usually contains the ORM model classes, view functions and classes, HTML templates, and static assets. An <code class="literal">application</code> package can be installed via the <code class="literal">pip</code> package manager or provided together with the <code class="literal">project</code> package. We need to know that a Django project will use an application only if it is listed in the <code class="literal">INSTALLED_APPS</code> settings value in the <code class="literal">settings.py</code> module.</p><p>We will create one Django application to implement Notes core functionalities, an application called <code class="literal">core</code>, to be precise. To create an empty application inside our project, we can use the <code class="literal">startapp</code> command and pass the name of the application:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>python manage.py startapp core</strong></span>
</pre></div><p>We can see how the command created a Python package inside our project folder called <code class="literal">core</code> as we asked for. The package contains a set of standard modules we will likely want to implement, as we will see in a moment.</p><p>As mentioned before, we need to list our newly created app inside the <code class="literal">INSTALLED_APPS</code> settings to tell Django that it must use it:</p><div class="informalexample"><pre class="programlisting">INSTALLED_APPS = (
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',

    'core',
)</pre></div><p>Django 1.7 provides a registry called <code class="literal">apps</code> provided by the <code class="literal">django.apps</code> package, which stores an <code class="literal">AppConfig</code> object for each installed application. We can use <code class="literal">AppConfig</code> objects to introspect applications' metadata or to change the configuration of a determined application. To<a id="id435" class="indexterm"/> see the <code class="literal">apps</code> registry in action, we<a id="id436" class="indexterm"/> can access the Django shell like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>python manage.py shell</strong></span>
</pre></div><p>Then we can test the following Python code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; from django.apps import apps</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; apps.get_app_config('core').verbose_name</strong></span>
<span class="strong"><strong>'Core'</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; apps.get_app_config('core').path</strong></span>
<span class="strong"><strong>u'/opt/projects/django_notes/notes/core'</strong></span>
</pre></div></div><div class="section" title="Views and templates"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec39"/>Views and templates</h2></div></div></div><p>Now that the data backend is functional, we can start implementing the first building block—providing the view showing the homepage for our Notes web application. A view in the Django<a id="id437" class="indexterm"/> world is nothing more than a Python<a id="id438" class="indexterm"/> function or class that takes an HTTP request <a id="id439" class="indexterm"/>and returns an HTTP response, implementing whatever logic is needed to build the final content delivered to the client. We<a id="id440" class="indexterm"/> will add the code implementing a view to build the homepage to the <code class="literal">views.py</code> module we created inside our <code class="literal">core</code> application:</p><div class="informalexample"><pre class="programlisting">from django.shortcuts import render
from django import get_version

def home(request):
    context = {'django_version': get_version()}
    return render(request, 'core/main.html', context)</pre></div><p>The view parameter called <code class="literal">home</code> does something very similar to the <code class="literal">get()</code> method of the <code class="literal">MainHandler</code> class in the webapp2 version of Notes. We create a <code class="literal">context</code> dictionary that will be passed to the template during the rendering process. Then we call the <code class="literal">render()</code> method, which passes the same <code class="literal">request</code> object we received as a parameter—a string containing the path to the HTML template. It will be used for the page and the <code class="literal">context</code> dictionary.</p><p>In the webapp2 version of Notes, we used Jinja2 to render our pages, but Django has its own template system already integrated in the framework. The language we use inside the HTML files is very similar to Jinja2, but some major differences still exist, so we have to rewrite our templates. We create a new HTML file at the <code class="literal">core/templates/core/main.html</code> path, relative to the <code class="literal">project</code> folder and containing the following code:</p><div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head lang="en"&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;title&gt;Notes&lt;/title&gt;

  &lt;link rel="stylesheet" type="text/css" href="/static/css/notes.css"&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div class="container"&gt;

    &lt;h1&gt;Welcome to Notes!&lt;/h1&gt;
    &lt;h5&gt;Built with Django {{ django_version }}.&lt;/h5&gt;

    &lt;ul class="menu"&gt;
      &lt;li&gt;Hello, &lt;b&gt;{{ user }}&lt;/b&gt;&lt;/li&gt;
    &lt;/ul&gt;

    &lt;form action="" method="post" enctype="multipart/form-data"&gt;
      &lt;legend&gt;Add a new note&lt;/legend&gt;
      &lt;div class="form-group"&gt;
        &lt;label&gt;Title: &lt;input type="text" id="title" name="title"/&gt;
        &lt;/label&gt;
      &lt;/div&gt;
      &lt;div class="form-group"&gt;
        &lt;label for="content"&gt;Content:&lt;/label&gt;
        &lt;textarea id="content" name="content"&gt;&lt;/textarea&gt;
      &lt;/div&gt;
      &lt;div class="form-group"&gt;
        &lt;label for="checklist_items"&gt;Checklist items:&lt;/label&gt;
        &lt;input type="text" id="checklist_items" name="checklist_items"
               placeholder="comma,separated,values"/&gt;
      &lt;/div&gt;
      &lt;div class="form-group"&gt;
        &lt;label for="uploaded_file"&gt;Attached file:&lt;/label&gt;
        &lt;input type="file" id="uploaded_file" name="uploaded_file"&gt;
      &lt;/div&gt;
      &lt;div class="form-group"&gt;
        &lt;button type="submit"&gt;Save note&lt;/button&gt;
      &lt;/div&gt;
    &lt;/form&gt;
  &lt;/div&gt;

&lt;/body&gt;
&lt;/html&gt;</pre></div><p>Notice in the template how we are using the <code class="literal">{{ django_version }}</code> element, which outputs the variable we put in the context dictionary, and the <code class="literal">{{ user }}</code> element, which is <a id="id441" class="indexterm"/>provided by default by the Django <a id="id442" class="indexterm"/>authentication system. Since we did not perform a login, the <a id="id443" class="indexterm"/>current user is set to a special entity called <span class="strong"><strong>anonymous user</strong></span>.</p><p>Now that <a id="id444" class="indexterm"/>we have a view function providing<a id="id445" class="indexterm"/> an HTTP response and a template to render an HTML page, we need to map a URL of our choice to the view, just as we did with webapp2. Django has a URL configurator module (also known as the <code class="literal">URLconf</code> module) called <code class="literal">urls.py</code>, containing pure Python code and defining a mapping between URLs described with regular expressions and view functions or classes. The <code class="literal">django_admin.py</code> script generates an <code class="literal">urls.py</code> module we can use as a starting point, but the final version to map the homepage view should be the following:</p><div class="informalexample"><pre class="programlisting">from django.conf.urls import patterns, include, url

urlpatterns = patterns('',
    url(r'^$', 'core.views.home', name='home'),
)</pre></div><p>A <code class="literal">URLconf</code> module must define a variable named <code class="literal">urlpatterns</code> and contain a list of <code class="literal">django.conf.urls.url</code> instances that will be iterated in order by Django until one of them matches a requested URL. When a match with a regular expression occurs, Django stops the iteration and can potentially do two things:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Import and call the <code class="literal">view</code> passed as parameter.</li><li class="listitem">Process an <code class="literal">include</code> statement that loads a <code class="literal">urlpattern</code> object from another module.</li></ol></div><p>In our case, we match the root URL for the domain and import the <code class="literal">home</code> function view we previously defined in the <code class="literal">views.py</code> module.</p><p>Finally, we put the same CSS file we used for the webapp2 version of Notes at the <code class="literal">static/css/notes.css</code> path, relative to the App Engine application root folder, and we should get the result for the homepage, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/8194OS_07_02.jpg" alt="Views and templates"/></div></div><div class="section" title="Authenticating users with Django"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec40"/>Authenticating users with Django</h2></div></div></div><p>To authenticate our users, we won't use the App Engine User service, and we will completely<a id="id446" class="indexterm"/> rely on Django instead. Django <a id="id447" class="indexterm"/>provides a built-in user <a id="id448" class="indexterm"/>authentication system that also provides authorization checking. We can verify that users are who they claim to be, and we can determine what they are allowed to do. The authentication system is implemented as a Django application, and we have to ensure that it is listed in the <code class="literal">INSTALLED_APPS</code> settings before trying to use it as follows:</p><div class="informalexample"><pre class="programlisting">INSTALLED_APPS = (
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',

    'core',
)</pre></div><p>The<a id="id449" class="indexterm"/> authentication system is also responsible <a id="id450" class="indexterm"/>for adding to the <a id="id451" class="indexterm"/>template context the <code class="literal">user</code> variable so that we can write <code class="literal">{{ user }}</code> in our HTML templates.</p><p>Since we won't use the App Engine User service, we must implement the login and logout pages by ourselves, and Django helps us by providing two out-of-the-box views that serve as a login and a logout page. First of all, we need to map the login and logout URLs to such views in the <code class="literal">URLconf</code> module, so we add the following to the <code class="literal">urls.py</code> module:</p><div class="informalexample"><pre class="programlisting">from django.contrib.auth import views as auth_views

urlpatterns = patterns('',
    url(r'^$', 'notes.views.home', name='home'),
    url(r'^accounts/login/$', auth_views.login),
    url(r'^accounts/logout/$', auth_views.logout),
)</pre></div><p>Even if the logic for logging in users comes for free, we need to provide an HTML template for the login page. We add a folder called <code class="literal">registration</code> inside the <code class="literal">template</code> folder of the <code class="literal">core</code> application and create a file in it called <code class="literal">login.html</code>, containing the following code:</p><div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head lang="en"&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;title&gt;Notes&lt;/title&gt;

  &lt;link rel="stylesheet" type="text/css" href="/static/css/notes.css"&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div class="container"&gt;
    &lt;form action="{% url 'django.contrib.auth.views.login' %}" method="post"&gt;
      {% csrf_token %}
      &lt;legend&gt;You must login to use Notes&lt;/legend&gt;
      &lt;div class="form-group"&gt;
        &lt;label for="username"&gt;Username:&lt;/label&gt;
        &lt;input type="text" id="username" name="username"/&gt;
      &lt;/div&gt;
      &lt;div class="form-group"&gt;
        &lt;label for="password"&gt;Password:&lt;/label&gt;
        &lt;input type="password" id="password" name="password"/&gt;
      &lt;/div&gt;
      &lt;div class="form-group"&gt;
        &lt;button type="submit"&gt;Login&lt;/button&gt;
      &lt;/div&gt;
      &lt;input type="hidden" name="next" value="{{ next }}" /&gt;
    &lt;/form&gt;
  &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></div><p>We<a id="id452" class="indexterm"/> use the same style sheet and the same <a id="id453" class="indexterm"/>page structure of the main <a id="id454" class="indexterm"/>page to show the login form. To populate the <code class="literal">action</code> attribute of the form, we use the <code class="literal">url</code> template tag, which retrieves the URL of a view whose name is given. In this case, the attribute will contain the URL mapped to the <code class="literal">django.contrib.auth.views.login</code> view. We then use the <code class="literal">{% csrf_token %}</code> template tag to create a field inside the form that Django needs in order to prevent <span class="strong"><strong>Cross-Site Request Forgery</strong></span> (<span class="strong"><strong>CSRF</strong></span>) attacks. We also add a hidden field containing the <a id="id455" class="indexterm"/>URL we want to redirect users to after a successful login. This URL is handled by Django, and the authentication system takes care of filling the <code class="literal">next</code> value in the template context.</p><p>Our users will be automatically redirected to the login page whenever they attempt to access a URL that is login-protected. To see the authentication system in action, we tell Django to protect the <code class="literal">home</code> view by adding the following code to the <code class="literal">views.py</code> module inside the <code class="literal">core</code> application:</p><div class="informalexample"><pre class="programlisting">from django.contrib.auth.decorators import login_required

@login_required()
def home(request):
    context = {'django_version': get_version()}
    return render(request, 'core/main.html', context)</pre></div><p>Now that we have added the <code class="literal">login_required()</code> function decorator to the <code class="literal">home</code> view, only logged-in users will be able to see page contents, and others will be redirected to the login page. If we try to access the <code class="literal">http://localhost:8080</code> URL, this is what we should see:</p><div class="mediaobject"><img src="graphics/8194OS_07_03.jpg" alt="Authenticating users with Django"/></div><p>We <a id="id456" class="indexterm"/>can log in with the <code class="literal">superuser</code> user, using the same credentials we provided during the <code class="literal">createsuperuser</code> command<a id="id457" class="indexterm"/> execution earlier in this<a id="id458" class="indexterm"/> chapter.</p><p>Finally, we have to provide a link to the logout view, which users can access to terminate their authenticated session. In the <code class="literal">main.html</code> template file, we add the following code:</p><div class="informalexample"><pre class="programlisting">&lt;ul class="menu"&gt;
  &lt;li&gt;Hello, &lt;b&gt;{{ user }}&lt;/b&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;a href="{% url 'django.contrib.auth.views.logout' %}"&gt;Logout&lt;/a&gt;
  &lt;/li&gt;
&lt;/ul&gt;</pre></div><p>We simply retrieve the URL mapped to the logout view and Django will do the rest, performing all the operations needed to make the user log out.</p></div><div class="section" title="Using the ORM and migrations system"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec41"/>Using the ORM and migrations system</h2></div></div></div><p>We are already familiar with the model classes provided by webapp2 because in <a class="link" href="ch02.html" title="Chapter 2. A More Complex Application">Chapter 2</a>, <span class="emphasis"><em>A More Complex Application</em></span>, we used them to map Python objects to Datastore entities. Django <a id="id459" class="indexterm"/>uses an almost identical approach; we<a id="id460" class="indexterm"/> define Python classes deriving from the <code class="literal">django.db.models.Model</code> package, and the ORM component takes care of <a id="id461" class="indexterm"/>mapping instances of those classes to rows and tables in the underlying <a id="id462" class="indexterm"/>relational database. To see the ORM in action, we add the following models to the <code class="literal">models.py</code> module inside the <code class="literal">core</code> application:</p><div class="informalexample"><pre class="programlisting">from django.db import models
from django.contrib.auth.models import User

class Note(models.Model):
    title = models.CharField(max_length=10)
    content = models.TextField(blank=False)
    date_created = models.DateTimeField(auto_now_add=True)
    owner = models.ForeignKey(User)

class CheckListItem(models.Model):
    title = models.CharField(max_length=100)
    checked = models.BooleanField(default=False)
    note = models.ForeignKey('Note', related_name='checklist_items')</pre></div><p>We define a <code class="literal">Note</code> model class with a <code class="literal">title</code> property containing small text (up to ten characters), a <code class="literal">content</code> property containing text of arbitrary length, a <code class="literal">date_created</code> property containing date and time, and an <code class="literal">owner</code> property, which is a foreign key referring to an instance of the <code class="literal">User</code> model from the Django authentication system. Since we pass the <code class="literal">blank=False</code> parameter to the <code class="literal">TextField</code> model field constructor, the <code class="literal">content</code> property is required.</p><p>We then define a <code class="literal">CheckListItem</code> model class with a <code class="literal">title</code> property containing small text (up to hundred characters), a <code class="literal">checked</code> property containing a Boolean value that defaults to the <code class="literal">False</code> parameter when not specified, and a <code class="literal">note</code> property, which is a foreign key referring to the <code class="literal">Note</code> model. The <code class="literal">related_name='checklist_items'</code> parameter we pass to the <code class="literal">ForeignKey</code> model field constructor means that we will be able to access the set of checklist items tied to a <code class="literal">Note</code> instance accessing a property called <code class="literal">checklist_items</code> on the instance itself.</p><p>To translate our models into the SQL code needed to map them to the relational database, we need to perform a migration, more precisely the initial migration since this is the first time we are doing this for the core application:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>python manage.py makemigrations core</strong></span>
</pre></div><p>The output of the migration should be the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Migrations for 'core':</strong></span>
<span class="strong"><strong>  0001_initial.py:</strong></span>
<span class="strong"><strong>    - Create model CheckListItem</strong></span>
<span class="strong"><strong>    - Create model Note</strong></span>
<span class="strong"><strong>    - Add field note to checklistitem</strong></span>
</pre></div><p>The <code class="literal">makemigrations</code> command creates a <code class="literal">migration</code> folder inside the <code class="literal">core</code> application path with <a id="id463" class="indexterm"/>a migration file called <code class="literal">0001_initial.py</code>. The migration file contains the list of the operations the ORM needs to perform in <a id="id464" class="indexterm"/>order to map the current Python code to <a id="id465" class="indexterm"/>the database schema, creating or altering tables accordingly.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note20"/>Note</h3><p>Migration files are part of the codebase and should be kept under version control like any other Python module.</p></div></div><p>To apply the <a id="id466" class="indexterm"/>changes to the database, we need to perform a migration with this command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>python manage.py migrate core</strong></span>
</pre></div><p>The output of applying the changes to the database should be the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Operations to perform:</strong></span>
<span class="strong"><strong>  Apply all migrations: core</strong></span>
<span class="strong"><strong>Running migrations:</strong></span>
<span class="strong"><strong>  Applying core.0001_initial... OK</strong></span>
</pre></div><p>At this point, we have created the database schema for our core application. If we want to confirm exactly which SQL code was produced by the migration system, we can issue the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>python manage.py sqlmigrate core 0001_initial</strong></span>
</pre></div><p>This command will print on the command line the SQL code produced for our initial migration.</p><p>At this point, we might notice that our <code class="literal">Note</code> model has a <code class="literal">title</code> field that is really too small to contain descriptive titles for our notes, so we change it in <code class="literal">models.py</code>:</p><div class="informalexample"><pre class="programlisting">class Note(models.Model):
    title = models.CharField(max_length=100)
    content = models.TextField(blank=False)
    date_created = models.DateTimeField(auto_now_add=True)</pre></div><p>Of course, this change will alter the database schema, so we need to perform a migration:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>python manage.py makemigrations core</strong></span>
</pre></div><p>This time, the output will be as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Migrations for 'core':</strong></span>
<span class="strong"><strong>  0002_auto_20141101_1128.py:</strong></span>
<span class="strong"><strong>    - Alter field title on note</strong></span>
</pre></div><p>A file<a id="id467" class="indexterm"/> called <code class="literal">0002_auto_20141101_1128.py</code> is added to the<a id="id468" class="indexterm"/> migration folder, containing the SQL instructions<a id="id469" class="indexterm"/> needed to alter the database schema to reflect our new <a id="id470" class="indexterm"/>Python code. The last step we need to take is to apply the migration:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>python manage.py migrate core</strong></span>
</pre></div></div><div class="section" title="Processing forms with the Forms API"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec42"/>Processing forms with the Forms API</h2></div></div></div><p>Now that<a id="id471" class="indexterm"/> our database is ready to store our data, we can implement the code needed to handle the form we show in the main <a id="id472" class="indexterm"/>page to create new notes, and Django's Forms API will simplify and automate a great part of this work. In particular, we will let Django take care of the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating the HTML form automatically from the contents of our <code class="literal">Note</code> model class</li><li class="listitem" style="list-style-type: disc">Processing and validating submitted data</li><li class="listitem" style="list-style-type: disc">Providing a CSRF security check</li></ul></div><p>First of all, we implement a class deriving from the <code class="literal">django.forms.ModelForm</code> class that will let us define and process our form. Inside the <code class="literal">core</code> application, we create a new Python module called <code class="literal">forms.py</code>, containing the following lines:</p><div class="informalexample"><pre class="programlisting">from django import forms
from .models import Note

class NoteForm(forms.ModelForm):
    class Meta:
        model = Note
        exclude = ['id', 'date_created', 'owner']</pre></div><p>We define a Python class implementing a so-called <code class="literal">model</code> form, a Django <code class="literal">form</code> class that defines and validates data from a Django model. We define another class called <code class="literal">Meta</code> inside the <code class="literal">NoteForm</code> class. It contains the form's metadata, mainly the name of the model it will work on and a list of fields of the model we don't want to show on the HTML form.</p><p>We will use the <code class="literal">NoteForm</code> class in our <code class="literal">home</code> view, so we add the following to the <code class="literal">views.py</code> module:</p><div class="informalexample"><pre class="programlisting">from django.http import HttpResponseRedirect
from django.core.urlresolvers import reverse
from .forms import NoteForm

@login_required()
def home(request):
    user = request.user
    if request.method == "POST":
        f = NoteForm(request.POST)
        if f.is_valid():
            note = f.save(commit=False)
            note.owner = user
            note.save()
            return HttpResponseRedirect(reverse('home'))

    else:
        f = NoteForm()

    context = {
        'django_version': get_version(),
        'form': f,
        'notes': Note.objects.filter(owner=user).order_by('-id'),
    }
    return render(request, 'core/main.html', context)</pre></div><p>We initially assign a <code class="literal">user</code> variable containing the current logged-in user instance. Then we check<a id="id473" class="indexterm"/> whether the view is serving a HTTP <code class="literal">POST</code> request. If this is the case, we instantiate our model form class, passing<a id="id474" class="indexterm"/> the request itself to the constructor. The form will extract the data it needs from the request body. We then call the <code class="literal">is_valid()</code> method to check whether all the fields needed were filled with the right data, and we call the <code class="literal">save()</code> method passing the <code class="literal">commit=False</code> parameter that will create a new <code class="literal">Note</code> instance without saving it in the database. We assign the <code class="literal">owner</code> field to the current logged-in user and save the <code class="literal">Note</code> instance, this time making it persist in the database. Finally, we redirect the user to the homepage URL. We call the <code class="literal">reverse()</code> method and pass the view name as a parameter. If the request is of the <code class="literal">GET</code> type, we instantiate an empty model form. The <code class="literal">NoteForm</code> instance is added to the context so that the template can use it to render the HTML form. Here, we perform our first database query using the Django ORM. The <code class="literal">Note.objects.filter(owner=user).order_by('-id')</code> query returns a list of the notes' objects filtered by the current logged-in user as <code class="literal">owner</code> and ordered by the <code class="literal">id</code> parameter in reverse order (notice the <code class="literal">-</code> character before the field name). The list is added to the context so that the template can render it.</p><p>The final step we need to take is modifying the <code class="literal">main.html</code> template so that it can properly render the new contents we have just added to the context. Let's start with the form, which we can easily define using the model form instance, <code class="literal">form</code>, without writing too much HTML code:</p><div class="informalexample"><pre class="programlisting">&lt;form method="post" action="" enctype="multipart/form-data"&gt;
  &lt;legend&gt;Add a new note&lt;/legend&gt;

  {# Show visible fields #}
  {% for field in form.visible_fields %}
  &lt;div class="form-group"&gt;
    {{ field.errors }}
    {{ field.label_tag }}
    {{ field }}
  &lt;/div&gt;
  {% endfor %}

  {# Include hidden fields #}
  {% for hidden in form.hidden_fields %}
  {{ hidden }}
  {% endfor %}

  {% csrf_token %}
  &lt;div class="form-group"&gt;
    &lt;button type="submit"&gt;Save note&lt;/button&gt;
  &lt;/div&gt;
&lt;/form&gt;</pre></div><p>We <a id="id475" class="indexterm"/>first iterate the visible fields<a id="id476" class="indexterm"/> of the form. Note that Django will take care of printing the correct tags and labels. After iterating through the visible fields, we print the hidden fields, then print the CSRF token (as we did for the login form), and finally provide the <code class="literal">submit</code> button. Right after the form definition, we can add the loop that produces the HTML code to show the notes to the current user:</p><div class="informalexample"><pre class="programlisting">{% for note in notes %}
&lt;div class="note"&gt;
  &lt;h4&gt;{{ note.title }}&lt;/h4&gt;
  &lt;p class="note-content"&gt;{{ note.content }}&lt;/p&gt;
  {% if note.checklist_items %}
  &lt;ul&gt;
    {% for item in note.checklist_items.all %}
    &lt;li class="{%if item.checked%}checked{%endif%}"&gt;
      &lt;a href="#"&gt;{{item.title}}&lt;/a&gt;
    &lt;/li&gt;
    {% endfor %}
  &lt;/ul&gt;
  {% endif %}
&lt;/div&gt;
{% endfor %}</pre></div><p>As we can see, the <code class="literal">input</code> control to add the <code class="literal">checklist_items</code> parameter is missing. This is because we want to provide such items with the same list as we did in the webapp2 version of Notes—a comma-separated list. Since the Note model does not provide a<a id="id477" class="indexterm"/> field to hold this list, the<a id="id478" class="indexterm"/> model form won't show anything to provide such data. Anyway, we can manually add arbitrary fields to a model form independently from the fields of the associated model. In our <code class="literal">forms.py</code> module, we add the following to the <code class="literal">NoteForm</code> class:</p><div class="informalexample"><pre class="programlisting">class NoteForm(forms.ModelForm):
    cl_items = forms.CharField(required=False,
        label="Checklist Items",
        widget=forms.TextInput(attrs={
            'placeholder': 'comma,separated,values'
        }))

    class Meta:
        model = Note
        exclude = ['id', 'date_created', 'owner']</pre></div><p>We add a new field called <code class="literal">ci_items</code>. It is not required and is rendered using a <code class="literal">forms.TextInput</code> widget. We don't use the default widget here because we want to provide the <code class="literal">placeholder</code> attribute to the corresponding HTML tag. We can refresh the homepage to see the new field appearing, without the need to touch the HTML template file. Now we need to process this new field, and we do this in the <code class="literal">home</code> view:</p><div class="informalexample"><pre class="programlisting">@login_required()
def home(request):
    user = request.user
    if request.method == "POST":
        f = NoteForm(request.POST)
        if f.is_valid():
            note = f.save(commit=False)
            note.owner = user
            note.save()
            for item in f.cleaned_data['cl_items'].split(','):
                CheckListItem.objects.create(title=item,
                                             note=note)
            return HttpResponseRedirect(reverse('home'))</pre></div><p>After saving the note instance, we access the <code class="literal">cl_items</code> value in the <code class="literal">cleaned_data</code> dictionary Django filled after the form was processed. We split the string using the comma<a id="id479" class="indexterm"/> as a separator, create <a id="id480" class="indexterm"/>a new <code class="literal">CheckListItem</code> instance for every item the user passed through the form field, and cause that instance to persist.</p></div><div class="section" title="Uploading files to Google Cloud Storage"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec43"/>Uploading files to Google Cloud Storage</h2></div></div></div><p>By default, when users upload their files, Django stores content locally in the server. As we already know, App Engine applications run in a sandboxed environment without being <a id="id481" class="indexterm"/>able to access the server<a id="id482" class="indexterm"/> filesystem, so this approach simply cannot work. Anyway, Django provides an abstraction layer, the<a id="id483" class="indexterm"/> file storage system. We can use this layer to customize where and how uploaded files are stored. We are going to take advantage of this feature, implementing our own storage backend class that will store uploaded files on the Google Cloud Storage.</p><p>Before starting, we need to install the GCS Client Library as we did in <a class="link" href="ch03.html" title="Chapter 3. Storing and Processing Users' Data">Chapter 3</a>, <span class="emphasis"><em>Storing and Processing Users' Data</em></span>, in order to easily interact with the Cloud Storage from our storage backend. We then create a <code class="literal">storage.py</code> module in our <code class="literal">core</code> application, containing the definition of the storage backend class, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">class GoogleCloudStorage(Storage):
    def __init__(self):
        try:
            cloudstorage.validate_bucket_name(
                settings.BUCKET_NAME)
        except ValueError:
            raise ImproperlyConfigured(
                "Please specify a valid value for BUCKET_NAME")
        self._bucket = '/' + settings.BUCKET_NAME</pre></div><p>The constructor must be invoked without arguments, so everything we need from within the storage backend must be retrieved from the Django settings. In this case, we expect that the bucket name was specified in the <code class="literal">BUCKET_NAME</code> settings value, and we ensure that it is a valid name using the <code class="literal">validate_bucket_name</code> parameter from the GCS Client Library. We then add to our class the methods we must provide to meet the custom storage backend requirements:</p><div class="informalexample"><pre class="programlisting">    def _open(self, name, mode='rb'):
        return cloudstorage.open(self.path(name), 'r')

    def _save(self, name, content):
        realname = self.path(name)
        content_t = mimetypes.guess_type(realname)[0]
        with cloudstorage.open(realname, 'w',
                               content_type=content_t,
                               options={
                                   'x-goog-acl': 'public-read'
                               }) as f:
            f.write(content.read())
        return os.path.join(self._bucket, realname)

    def delete(self, name):
        try:
            cloudstorage.delete(self.path(name))
        except cloudstorage.NotFoundError:
            pass

    def exists(self, name):
        try:
            cloudstorage.stat(self.path(name))
            return True
        except cloudstorage.NotFoundError:
            return False

    def listdir(self, name):
        return [], [obj.filename for obj in
                    cloudstorage.listbucket(self.path(name))]

    def size(self, name):
        filestat = cloudstorage.stat(self.path(name))
        return filestat.st_size

    def url(self, name):
        key = blobstore.create_gs_key('/gs' + name)
        return images.get_serving_url(key)</pre></div><p>The<a id="id484" class="indexterm"/> code is pretty much the<a id="id485" class="indexterm"/> same as what we <a id="id486" class="indexterm"/>saw in <a class="link" href="ch03.html" title="Chapter 3. Storing and Processing Users' Data">Chapter 3</a>, <span class="emphasis"><em>Storing and Processing Users' Data</em></span>, and all the class methods match a counterpart in the GCS Client Library, so it is very compact. Notice how in the <code class="literal">url</code> parameter we are telling Django to use the Google CDN to serve the files from our storage. We then add the following optional methods to complete our storage backend:</p><div class="informalexample"><pre class="programlisting">    def path(self, name):
        if not name:
            raise SuspiciousOperation(
                "Attempted access to '%s' denied." % name)
        return os.path.join(self._bucket, os.path.normpath(name))

    def created_time(self, name):
        filestat = cloudstorage.stat(self.path(name))
        creation_date = timezone.datetime.fromtimestamp(
            filestat.st_ctime)
        return timezone.make_aware(creation_date,
            timezone.get_current_timezone())</pre></div><p>The <code class="literal">path()</code> method returns the full path to the file, including the leading slash and the bucket name. Access to the <code class="literal">bucket</code> root is not allowed, and we raise an exception in that case.</p><p>Now<a id="id487" class="indexterm"/> that the custom storage <a id="id488" class="indexterm"/>backend is complete, we<a id="id489" class="indexterm"/> tell Django to use it, so we write the following code in the <code class="literal">settings.py</code> module:</p><div class="informalexample"><pre class="programlisting">DEFAULT_FILE_STORAGE = 'core.storage.GoogleCloudStorage'
BUCKET_NAME = '&lt;your_bucket_name&gt;'</pre></div><p>To see the custom file storage in action, we are going to slightly change the requirements of our Notes application. For the sake of simplicity, we will support only one file attached to every note so that we can simply add a couple of fields to the Note model class in our <code class="literal">models.py</code> module:</p><div class="informalexample"><pre class="programlisting">class Note(models.Model):
    title = models.CharField(max_length=100)
    content = models.TextField(blank=False)
    date_created = models.DateTimeField(auto_now_add=True)
    owner = models.ForeignKey(User)
    attach = models.FileField(blank=True, null=True)
    thumbnail_url = models.CharField(max_length=255, blank=True, null=True)</pre></div><p>The <code class="literal">attach</code> field is of the <code class="literal">FileField</code> type. This means Django will take care of the upload and store procedure for us, using our file storage. The <code class="literal">thumbnail_url</code> field will contain a string with the URL to retrieve the cropped version of the attachment if it is an image, just as we saw in <a class="link" href="ch03.html" title="Chapter 3. Storing and Processing Users' Data">Chapter 3</a>, <span class="emphasis"><em>Storing and Processing Users' Data</em></span>. It's important to remember that we have to perform a migration for our <code class="literal">core</code> application after this change. We don't want to show the <code class="literal">thumbnail_url</code> field in our HTML form, so we change the <code class="literal">Meta</code> class in the <code class="literal">NoteForm</code> file accordingly:</p><div class="informalexample"><pre class="programlisting">    class Meta:
        model = Note
        exclude = ['id', 'date_created', 'owner', 'thumbnail_url']</pre></div><p>At this point, the HTML form will show the file input field, but we need to handle uploads in our <code class="literal">home</code> view:</p><div class="informalexample"><pre class="programlisting">from .storage import GoogleCloudStorage
from google.appengine.api import images
from google.appengine.ext import blobstore

@login_required()
def home(request):
    user = request.user
    if request.method == "POST":
        f = NoteForm(request.POST, request.FILES)
        if f.is_valid():
            note = f.save(commit=False)
            note.owner = user
            if f.cleaned_data['attach']:
                try:
                    s = GoogleCloudStorage()
                    path = '/gs' + s.path(f.cleaned_data['attach'].name)
                    key = blobstore.create_gs_key(path)
                    note.thumbnail_url = images.get_serving_url(key, size=150, crop=True)
                except images.TransformationError, images.NotImageError:
                    pass
            note.save()
            for item in f.cleaned_data['cl_items'].split(','):
                CheckListItem.objects.create(title=item, note=note)
            return HttpResponseRedirect(reverse('home'))</pre></div><p>First <a id="id490" class="indexterm"/>of all, we pass the <code class="literal">request.FILES</code> dictionary containing uploaded data to the form constructor so that it can<a id="id491" class="indexterm"/> process and validate<a id="id492" class="indexterm"/> our <code class="literal">attach</code> field. Then, if the field is present, we generate the thumbnail URL when possible and update our <code class="literal">note</code> model instance accordingly. Here, we use our custom storage class to retrieve the path to the file in the Cloud Storage. A custom storage backend class is not usually supposed to be used directly by the developer, but in this case, we can turn a blind eye and avoid code duplication. The very last step of the procedure is to show the attachment in the Notes main page, so we change the <code class="literal">main.html</code> template in this way:</p><div class="informalexample"><pre class="programlisting">&lt;h4&gt;{{ note.title }}&lt;/h4&gt;
&lt;p class="note-content"&gt;{{ note.content }}&lt;/p&gt;
{% if note.attach %}
&lt;ul&gt;
  {% if note.thumbnail_url %}
  &lt;li class="file"&gt;
    &lt;a href="{{ note.attach.url }}"&gt;
      &lt;img src="{{ note.thumbnail_url }}"&gt;
    &lt;/a&gt;
  &lt;/li&gt;
  {% else %}
  &lt;li class="file"&gt;
    &lt;a href="{{ note.attach.url }}"&gt;{{ note.attach.name }}&lt;/a&gt;
  &lt;/li&gt;
  {% endif %}
&lt;/ul&gt;
{% endif %}</pre></div><p>Even<a id="id493" class="indexterm"/> if this version of Notes supports only one attachment for each note, we keep the same HTML structure we used<a id="id494" class="indexterm"/> for the webapp2 version<a id="id495" class="indexterm"/> to avoid rewriting CSS rules. We will see a thumbnail if the attachment is an image and the filename otherwise.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec49"/>Summary</h1></div></div></div><p>This was a long journey through the lands of Django, and even if we don't have all the features of the webapp2 version of Notes, at this point, we do have a solid starting point to add all the missing pieces. We already know how to deal with the Cloud Platform services, and we can complete the porting as an exercise to get better at Django programming and become even more confident with all the technologies behind App Engine.</p><p>In this chapter, we learned how to start a Django project, the basic concepts behind the framework, and how to integrate it smoothly inside an App Engine application. Using Django version 1.7, we also had the opportunity of dealing with the brand new migration system and getting the most out of the Cloud SQL database service. At this point, we know how to deal with forms, a simple example showing how easy life can be with the help of a framework like Django that saves us a lot of repetitive work. Another important step we took towards the perfect blend between Django and App Engine was the integration of the Google Cloud Storage service, an excellent backend used to store the files users upload to our Notes application.</p><p>In the next chapter, we will go back to working with the webapp2 version of Notes to implement a REST API through the Google Cloud Endpoints technology.</p></div></body></html>