- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Logging
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志记录
- en: One of the basic elements of monitoring and observability is logs. Logs allow
    us to detect actions that are happening in a running system. That information
    can be used to analyze the behavior of the system, especially any errors or bugs
    that may arise, giving us useful insight into what is actually going on.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 监控和可观察性的基本要素之一就是日志。日志使我们能够检测正在运行的系统中的动作。这些信息可以用来分析系统的行为，特别是可能出现的任何错误或缺陷，从而为我们提供对实际发生情况的宝贵见解。
- en: Using logs correctly is deceptively difficult, though. It's easy to collect
    too much or too little information, or to log the wrong information. In this chapter,
    we will see some of the key elements of what to collect, and the general strategy
    to follow to ensure that logs are used to their best effect.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 正确使用日志看似困难，实则不然。很容易收集过多或过少的信息，或者记录错误的信息。在本章中，我们将探讨一些关键元素，以及确保日志发挥最佳效果的通用策略。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Log basics
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志基础
- en: Producing logs in Python
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Python中生成日志
- en: Detecting problems through logs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过日志检测问题
- en: Log strategies
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志策略
- en: Adding logs while developing
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开发时添加日志
- en: Log limitations
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志限制
- en: Let's start with the basic principles of logging.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从日志的基本原则开始。
- en: Log basics
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志基础
- en: Logs are basically messages produced by the system as it runs. These messages
    are produced by specific pieces of code as they are executed, allowing us to track
    actions happening in the code.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 日志基本上是系统运行时产生的消息。这些消息是在代码执行时由特定的代码片段产生的，使我们能够跟踪代码中的动作。
- en: Logs can be completely generic, like "*Function X is called*" or can include
    some context of the specifics of the execution, like "*Function X is called with
    parameter Y.*"
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 日志可以是完全通用的，如“*函数X被调用*”，或者可以包含一些执行具体细节的上下文，如“*函数X使用参数Y被调用.*”
- en: Normally, logs are generated as plaintext messages. While there are other options,
    pure plaintext is very easy to deal with, can be read easily, is flexible in its
    format, and can be searched with pure text tools like `grep`. These tools are
    normally very fast and most developers and sysadmins know how to use them.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，日志以纯文本消息的形式生成。虽然还有其他选项，但纯文本处理起来非常简单，易于阅读，格式灵活，可以使用像`grep`这样的纯文本工具进行搜索。这些工具通常运行得非常快，大多数开发人员和系统管理员都知道如何使用它们。
- en: As well as the main message text, each log contains some metadata about what
    system produced the log, what time the log was created, and so on. If the log
    is in text format, this is normally attached to the start of the line.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 除了主要的消息文本外，每个日志还包含一些元数据，例如产生日志的系统、日志创建的时间等。如果日志是文本格式，这些信息通常附加到行的开头。
- en: A standard and consistent log format helps you with searching, filtering, and
    sorting the messages. Ensure that you use consistent formats across your different
    systems.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 标准和一致的日志格式有助于您进行消息的搜索、过滤和排序。请确保您在不同系统之间使用一致的格式。
- en: Another important metadata value is the severity of the log. This allows us
    to categorize the different logs by their relative importance. The standard severity
    levels, in order of less to more important, are `DEBUG`, `INFO`, `WARNING`, and
    `ERROR`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的元数据值是日志的严重性。这使我们能够根据相对重要性对不同的日志进行分类。标准严重性级别，按从低到高的顺序，是`DEBUG`、`INFO`、`WARNING`和`ERROR`。
- en: The `CRITICAL` level is less used, but it's useful to show catastrophic errors.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`CRITICAL`级别使用较少，但用于显示灾难性错误是有用的。'
- en: It's important to categorize the logs with their proper severity and filter
    out unimportant messages to focus on the more important ones. Each logging facility
    can be configured to only produce logs at one severity level or more.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要对日志进行适当的分类，并过滤掉不重要的消息，以便关注更重要的消息。每个日志设施都可以配置为仅生成一个或多个严重性级别的日志。
- en: It's possible to add custom log levels instead of the predefined ones. This
    is generally a bad idea and should be avoided in most cases, as the log levels
    are well understood by all tools and engineers. We will describe later in this
    chapter how to define a strategy per level to make the best of each level.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 可以添加自定义日志级别，而不是预定义的级别。这通常不是一个好主意，在大多数情况下应避免，因为所有工具和工程师都很好地理解了日志级别。我们将在本章后面描述如何为每个级别定义策略，以充分利用每个级别。
- en: 'In a system serving requests, either as request-response or asynchronously,
    most of the logs will be generated as part of dealing with a request, which will
    produce several logs indicating what the request is doing. Because more than one
    request will normally be undergoing processing at once, the logs will be generated
    intermixed. For example, consider the following logs:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个处理请求的系统（无论是请求-响应还是异步）中，大部分日志都会作为处理请求的一部分生成，这将产生几个日志，指示请求正在做什么。由于通常会有多个请求同时进行，日志将会混合生成。例如，考虑以下日志：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding logs show two different services, as indicated by the different
    IP addresses (`10.1.0.34` and `10.1.0.37`) and the two different service types
    (`web` and `api`). Though this can be enough to separate the requests, it''s a
    good idea to create a single request ID to be able to group the requests in the
    following way:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的日志显示了两个不同的服务，如不同的 IP 地址（`10.1.0.34` 和 `10.1.0.37`）和两种不同的服务类型（`web` 和 `api`）所示。虽然这足以区分请求，但创建一个单一的请求
    ID 来能够以以下方式分组请求是个好主意：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In microservices environments, requests will flow from one service to the other,
    so it's a good idea to create a request ID that's shared across services so the
    full cross-service flow can be understood. To do that, the request ID needs to
    be created by the first service and then transmitted to the next, typically as
    a header in an HTTP request.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务环境中，请求将从一项服务流向另一项服务，因此创建一个跨服务共享的请求 ID 是个好主意，以便可以理解完整的跨服务流程。为此，请求 ID 需要由第一个服务创建，然后传输到下一个服务，通常作为
    HTTP 请求的头部。
- en: As we saw in*Chapter 5*, *The Twelve-Factor App Methodology*, in the Twelve-Factor
    App methodology, logs should be treated as an event stream. This means that the
    application itself should not be concerned with the storage and treatment of logs.
    Instead, the logs should be directed to `stdout`. From there, while developing
    the application, the developer can extract the information while it's running.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在*第五章*，*十二要素应用方法*中看到的，在十二要素应用方法中，日志应该被视为一个事件流。这意味着应用程序本身不应该关心日志的存储和处理。相反，日志应该被导向
    `stdout`。从那里，在开发应用程序时，开发者可以在运行时提取信息。
- en: In production environments, `stdout` should be captured so that other tools
    can use it and then routed, annexing any different sources into a single stream,
    and then stored or indexed for later consulting. These tools should be configured
    in the production environment, and not in the app itself.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中，`stdout` 应该被捕获，以便其他工具可以使用它，然后进行路由，将不同的来源合并到一个单一的流中，然后存储或索引以供以后查阅。这些工具应该在生产环境中配置，而不是在应用程序本身中配置。
- en: Possible tools for this rerouting include alternatives like Fluentd ([https://github.com/fluent/fluentd](https://github.com/fluent/fluentd))
    or even the old favorite combination of a direct to `logger` Linux command to
    create system logs and then sending those logs to a configured `rsyslog` ([https://www.rsyslog.com/](https://www.rsyslog.com/))
    server that can forward and aggregate them.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 可能用于此重路由的工具包括类似 Fluentd ([https://github.com/fluent/fluentd](https://github.com/fluent/fluentd))
    或甚至旧爱的直接到 `logger` Linux 命令来创建系统日志，然后将这些日志发送到配置的 `rsyslog` ([https://www.rsyslog.com/](https://www.rsyslog.com/))
    服务器，该服务器可以转发和聚合它们。
- en: No matter how we collect logs, a typical system will produce a lot of them,
    and they need to be stored somewhere. While each individual log is small, aggregating
    thousands of them uses a significant amount of space. Any log system should be
    configured to have a policy on how much data it should accept to avoid growing
    indefinitely. In general, a retention policy based on time (such as keeping logs
    from the last 15 days) is the best approach, as it will be easy to understand.
    Finding the balance between how far back in the past you need to be able look
    and the amount of space the system uses is important.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们如何收集日志，一个典型的系统都会产生大量的日志，并且需要存储在某个地方。虽然每个单独的日志都很小，但聚合数千个日志会占用大量的空间。任何日志系统都应该配置为有一个政策，以确定它应该接受多少数据以避免无限增长。一般来说，基于时间（例如保留过去15天的日志）的保留策略是最好的方法，因为它将很容易理解。在需要回溯多远的历史和系统使用的空间量之间找到平衡是很重要的。
- en: Be sure to check the retention policy when enabling any new log service, be
    it local or cloud-based, to make sure it's compatible with your defined retention
    period. You won't be able to analyze anything that happened before the time window.
    Double-check that the rate of log creation is as expected and that space consumption
    is not making the effective time window in which you can collect logs smaller.
    You don't want to find out that you unexpectedly went over quota while you were
    tracking a bug.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在启用任何新的日志服务时，无论是本地还是基于云的，务必检查保留策略，以确保它与您定义的保留期兼容。您将无法分析时间窗口之前发生的事情。请再次确认日志创建速率是否符合预期，以及空间消耗是否没有使您可以收集日志的有效时间窗口变小。您不希望在你追踪一个错误时意外地超出配额。
- en: Generating log entries is easy, as we will see in the next section, *Producing
    logs in Python.*
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 生成日志条目很简单，正如我们将在下一节中看到的，*在 Python 中生成日志*。
- en: Producing logs in Python
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Python 中生成日志
- en: Python includes a standard module to produce logs. This module is easy to use,
    with a very flexible configuration, but it can be confusing if you don't understand
    the way it operates.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Python 包含一个用于生成日志的标准模块。这个模块易于使用，具有非常灵活的配置，但如果你不了解它的操作方式，可能会令人困惑。
- en: 'A basic program to create logs looks like this. This is available as `basic_logging.py`
    on GitHub at [https://github.com/PacktPublishing/Python-Architecture-Patterns/tree/main/chapter_12_logging](https://github.com/PacktPublishing/Python-Architecture-Patterns/tree/main/chapter_12_logging):'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一个创建日志的基本程序看起来像这样。这个程序可以在 GitHub 上的 [https://github.com/PacktPublishing/Python-Architecture-Patterns/tree/main/chapter_12_logging](https://github.com/PacktPublishing/Python-Architecture-Patterns/tree/main/chapter_12_logging)
    找到，文件名为 `basic_logging.py`。
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `.warning` and `.info` methods create logs with the corresponding severity
    message. The message is a text string.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`.warning` 和 `.info` 方法创建具有相应严重性消息的日志。消息是一个文本字符串。'
- en: 'When executed, it shows the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行时，它会显示以下内容：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The logs are, by default, routed to `stdout`, which is what we want, but it
    is configured not to display `INFO` logs. The format of the logs is also the default,
    which doesn't include a timestamp.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，日志会被路由到 `stdout`，这是我们想要的，但它被配置为不显示 `INFO` 级别的日志。日志的格式也是默认的，不包含时间戳。
- en: 'To add all this information, we need to understand the three basic elements
    used for logging in Python:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加所有这些信息，我们需要了解 Python 中用于日志记录的三个基本元素：
- en: A *formatter*, which describes how the full log is going to be presented, attaching
    metadata like the timestamp or the severity.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 *格式化器*，它描述了完整的日志将如何呈现，附加元数据如时间戳或严重性。
- en: A *handler*, which decides how the logs are propagated. It sets the format of
    the logs through the formatter, as defined above.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 *处理器*，它决定了日志如何传播。它通过格式化器设置日志的格式，如上面定义的那样。
- en: A *logger*, which produces the logs. It has one or more handlers that describe
    how the logs are propagated.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 *记录器*，它生成日志。它有一个或多个处理器，描述了日志如何传播。
- en: 'With this information, we can configure the logs to specify all the details
    we want:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些信息，我们可以配置日志以指定我们想要的全部细节：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We define the three elements in the same order that we saw before. First the
    `formatter`, then the `handler`, which sets the `formatter`, and finally the `logger`,
    which adds the `handler`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们按照之前看到的顺序定义这三个元素。首先是 `formatter`，然后是 `handler`，它设置 `formatter`，最后是 `logger`，它添加
    `handler`。
- en: 'The `formatter` has the following format:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`formatter` 的格式如下：'
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`FORMAT` is composed in Python `%` format, which is an old way to describe
    strings. Most elements are described as `%(name)s`, where the final `s` character
    means string format. Here''s a description of each element:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`FORMAT` 是由 Python `%` 格式组成的，这是一种描述字符串的旧方法。大多数元素都描述为 `%(name)s`，其中最后的 `s` 字符表示字符串格式。以下是每个元素的描述：'
- en: '`asctime` sets the timestamp in a human-readable format. We describe it in
    the `datefmt` argument to follow the ISO 8601 format. We also add the milliseconds
    next and a `Z` to get the timestamp in full ISO 8601 form. `%(msecs)d` with a
    `d` at the end means that we print the value as an integer. This is to limit the
    value to milliseconds and not show any extra resolution, which is available as
    a fractional value.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`asctime` 将时间戳设置为可读的格式。我们在 `datefmt` 参数中描述它，以遵循 ISO 8601 格式。我们还添加了毫秒数和一个 `Z`
    来获取完整的 ISO 8601 格式的时间戳。`%(msecs)d` 末尾的 `d` 表示我们将值打印为整数。这是为了将值限制在毫秒，而不显示任何额外的分辨率，这可以作为分数值提供。'
- en: '`name` is the name of the logger, as we will describe later. We add also `APP`
    to differentiate between different applications.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name` 是记录器的名称，正如我们稍后将要描述的那样。我们还添加了 `APP` 以区分不同的应用程序。'
- en: '`levelname` is the severity of the log, such as `INFO`, `WARNING`, or `ERROR`.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`levelname`是日志的严重性，例如`INFO`、`WARNING`或`ERROR`。'
- en: '`message`, finally, is the log message.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，`message`是日志消息。
- en: 'Once we have defined the `formatter`, we can move to the `handler`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了`formatter`，我们就可以转向`handler`：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The handler is a `StreamHandler`, and we set the destination of the stream to
    be `sys.stdout`, which is the Python-defined variable that points to `stdout`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器是一个`StreamHandler`，我们将流的目的地设置为`sys.stdout`，这是Python定义的指向`stdout`的变量。
- en: There are more handlers available, like `FileHandler` to send the logs to a
    file, `SysLogHandler` to send logs to a `syslog` destination, and even more advanced
    cases like `TimeRotatingFileHandler`, which rotates the logs based on time, meaning
    it stores the last defined time, and archives older versions. You can see more
    information of all available handlers in the documentation at [https://docs.python.org/3/howto/logging.html#useful-handlers](https://docs.python.org/3/howto/logging.html#useful-handlers).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 有更多可用的处理器，如`FileHandler`，可以将日志发送到文件，`SysLogHandler`可以将日志发送到`syslog`目的地，还有更高级的案例，如`TimeRotatingFileHandler`，它根据时间旋转日志，这意味着它存储最后定义的时间，并归档旧版本。您可以在文档[https://docs.python.org/3/howto/logging.html#useful-handlers](https://docs.python.org/3/howto/logging.html#useful-handlers)中查看所有可用处理器的更多信息。
- en: 'Once the `handler` is defined, we can create the `logger`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了`handler`，我们就可以创建`logger`：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The first thing to do is to create a name for the logger, which here we define
    as `mylogger`. This allows us to divide the logs of the application into subsections.
    We append the handler using `.addHandler`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 首件事是为logger创建一个名称，这里我们将其定义为`mylogger`。这允许我们将应用程序的日志划分为子部分。我们使用`.addHandler`附加处理器。
- en: Finally, we define the level to log as `INFO` using the `.setLevel` method.
    This will display all logs of the level `INFO` and higher, while those lower won't
    be.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`.setLevel`方法将日志级别定义为`INFO`。这将显示所有`INFO`级别及以上的日志，而低于此级别的日志则不会显示。
- en: 'If we run the file, we see the whole configuration coming together:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行文件，我们会看到整个配置组合在一起：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can see that:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到：
- en: The time is defined in ISO 8601 format as `2021-09-18T23:15:24.563Z`. This is
    a combination of the `asctime` and `msec` parameters.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间定义为ISO 8601格式，即`2021-09-18T23:15:24.563Z`。这是`asctime`和`msec`参数的组合。
- en: The `APP` and `mylogger` parameters allow us to filter by application and submodule.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`APP`和`mylogger`参数允许我们通过应用程序和子模块进行筛选。'
- en: The severity is displayed. Note that there's a `DEBUG` message that isn't displayed,
    as the minimum level configured is `INFO`.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示了严重性。请注意，有一个未显示的`DEBUG`消息，因为配置的最小级别是`INFO`。
- en: The `logging` module in Python is capable of high levels of configuration. Check
    the official documentation for more information at [https://docs.python.org/3/library/logging.html](https://docs.python.org/3/library/logging.html).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的`logging`模块能够进行高级别的配置。有关更多信息，请参阅官方文档[https://docs.python.org/3/library/logging.html](https://docs.python.org/3/library/logging.html)。
- en: Detecting problems through logs
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过日志检测问题
- en: 'For any problem in a running system, there are two kind of errors that can
    occur: expected and unexpected. In this section, we will see the differences between
    them in terms of logs and how we handle them.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对于运行中的系统中的任何问题，都可能发生两种错误：预期错误和意外错误。在本节中，我们将通过日志来了解它们之间的区别，以及我们如何处理它们。
- en: Detecting expected errors
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测预期错误
- en: 'Expected errors are errors that are detected explicitly by creating an `ERROR`
    log in the code. For example, the following code produces an `ERROR` log when
    the accessed URL returns a status code different from `200 OK`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 预期错误是通过在代码中创建`ERROR`日志来显式检测到的错误。例如，以下代码在访问的URL返回的状态码不是`200 OK`时产生`ERROR`日志：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This code, when executed, triggers an `ERROR` log:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行此代码时，会触发一个`ERROR`日志：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is a common pattern to access an external URL and validate that it has
    been accessed correctly. The block where the log is generated could perform some
    remediation or a retry, among other things.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种常见的模式，用于访问外部URL并验证其是否正确访问。生成日志的块可以执行一些补救措施或重试，以及其他操作。
- en: Here, we use the [https://httpbin.org](https://httpbin.org) service, a simple
    HTTP request and response service that can be used to test code. In particular,
    the `https://httpbin.org/status/<code>` endpoint returns the specified status
    code, making it easy to generate errors.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用[https://httpbin.org](https://httpbin.org)服务，这是一个简单的HTTP请求和响应服务，可用于测试代码。特别是，`https://httpbin.org/status/<code>`端点返回指定的状态码，这使得生成错误变得容易。
- en: This is an example of an expected error. We planned in advance for something
    that we didn't want to happen, but understood that there's a possibility of it
    happening. By planning in advance, the code is ready to process the error and
    capture it adequately.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个预期错误的例子。我们事先计划了某些我们不希望发生的事情，但理解了它可能发生的可能性。通过提前规划，代码可以准备好处理错误并充分捕获它。
- en: In this case, we can describe the situation clearly enough, and provide context
    to understand what is happening. The problem is obvious, even if the solution
    may not be.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以清楚地描述情况，并提供上下文来理解正在发生的事情。问题很明显，即使解决方案可能不是。
- en: These kinds of errors are relatively easy to deal with since they describe foreseen
    problems.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这类错误相对容易处理，因为它们描述的是预见的问题。
- en: For example, the site may be unavailable, there could be an authentication problem,
    or perhaps the base URL is misconfigured.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，网站可能不可用，可能存在认证问题，或者可能是基本URL配置错误。
- en: Keep in mind that in some cases, it's possible for the code to deal with a certain
    situation without failing, but for it still to be considered an error. For example,
    maybe you want to detect if an old authentication system is still in use by someone.
    This method of adding `ERROR` or `WARNING` logs when deprecated actions are detected
    can enable you to take actions to remedy the situation.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在某些情况下，代码可能能够处理某种情况而不失败，但它仍然被视为错误。例如，你可能想检测是否有某人仍在使用旧的认证系统。当检测到已弃用的操作时，添加`ERROR`或`WARNING`日志的方法可以让你采取行动来纠正情况。
- en: Other examples of this type of error include connections to databases and data
    being stored in a deprecated format.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型错误的其他例子包括数据库连接和以已弃用的格式存储的数据。
- en: Capturing unexpected errors
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 捕获意外错误
- en: But expected errors are not the only ones that can occur. Unfortunately, any
    running system will surprise you with all kinds of unexpected behavior that will
    break the code in creative ways. Unexpected errors in Python are normally produced
    by an exception being raised at some point in the code when that exception won't
    be captured.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 但预期错误并不是唯一可能发生的错误。不幸的是，任何正在运行的系统都会以各种意想不到的方式让你感到惊讶，从而以创新的方式破坏代码。Python中的意外错误通常是在代码的某个点抛出异常时产生的，而这个异常不会被捕获。
- en: 'For example, imagine that when making a small change to some code, we introduce
    a typo:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象当我们对某些代码进行小改动时，我们引入了一个拼写错误：
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Note that in line 8, we introduced a typo:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在第8行中，我们引入了一个拼写错误：
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The correct `.get` call has been replaced by `.ge`. When we run it, it produces
    the following error:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的`.get`调用已被`.ge`替换。当我们运行它时，会产生以下错误：
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: By default in Python, it will show the error and stack trace in the `stdout`.
    When the code is executed as part of a web server, this is sometimes enough to
    send these messages as `ERROR` logs, depending on how the configuration is set
    up.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中默认情况下，它会在`stdout`中显示错误和堆栈跟踪。当代码作为Web服务器的一部分执行时，这有时足以将这些消息作为`ERROR`日志发送，具体取决于配置如何设置。
- en: Any web server will capture and route these messages properly toward the logs
    and generate a proper 500 status code, indicating that there has been an unexpected
    error. The server will still be available for the next request.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 任何网络服务器都会捕获并正确地将这些消息路由到日志中，并生成适当的500状态码，指示发生了意外错误。服务器仍然可以处理下一个请求。
- en: If you need to create a script that needs to be running endlessly and is protected
    against any unexpected errors, be sure to use a `try..except` block as it's generic,
    so any possible exception will be captured and handled.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要创建一个需要无限期运行并保护不受任何意外错误影响的脚本，请确保使用`try..except`块，因为它是一般性的，所以任何可能的异常都将被捕获和处理。
- en: Any Python exception that's properly captured with a specific `except` block
    can be considered an expected error. Some of them may require `ERROR` messages
    to be generated, but others may be captured and handled without requiring such
    information.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 任何使用特定`except`块正确捕获的Python异常都可以被认为是预期错误。其中一些可能需要生成`ERROR`消息，但其他可能被捕获和处理，而不需要此类信息。
- en: 'For example, let''s adjust the code to make a request every few seconds. The
    code is available in GitHub at [https://github.com/PacktPublishing/Python-Architecture-Patterns/tree/main/chapter_12_logging](https://github.com/PacktPublishing/Python-Architecture-Patterns/tree/main/chapter_12_logging):'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '例如，让我们调整代码，使其每隔几秒发送一次请求。代码在GitHub上可用，链接为 [https://github.com/PacktPublishing/Python-Architecture-Patterns/tree/main/chapter_12_logging](https://github.com/PacktPublishing/Python-Architecture-Patterns/tree/main/chapter_12_logging):'
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The key element is the following endless loop:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 关键元素是以下无限循环：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `try..except` block is inside the loop, so even if there's an error, the
    loop will be uninterrupted. If there's any error, `except Exception` will capture
    it, no matter what the exception is.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`try..except`块在循环内部，所以即使有错误，循环也不会中断。如果有任何错误，`except Exception`将捕获它，无论异常是什么。'
- en: This is sometimes referred to as *Pokemon exception handling*, as in "Gotta
    catch 'em all." This should be restricted to a kind of "last-resort safety net."
    In general, not being precise with the exceptions to be captured is a bad idea,
    as you can hide errors by handling them incorrectly. Errors should never pass
    silently.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这有时被称为*宝可梦异常处理*，就像“抓到它们所有”。这应该限制为一种“最后的救命网”。一般来说，不精确地捕获异常是一个坏主意，因为你可以通过错误地处理它们来隐藏错误。错误永远不应该无声地通过。
- en: To be sure that not only is the error logged, but also the full stack trace,
    we log it using `.exception` instead of `.error`. This extends the information
    over a single text message while logging it with `ERROR` severity.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保不仅记录了错误，还记录了完整的堆栈跟踪，我们使用`.exception`而不是`.error`来记录它。这通过`ERROR`严重性记录扩展了信息，而不会超过单条文本消息。
- en: 'When we run the command, we get these logs. Be sure to stop it by pressing
    *Ctrl* + *C*:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行命令时，我们会得到这些日志。确保通过按*Ctrl* + *C*来停止它：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, the logs include `Traceback`, which allows us to detect a specific
    problem by adding information about where the exception was produced.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，日志中包含了`Traceback`，这使我们能够通过添加异常产生位置的信息来检测特定的问题。
- en: Any unexpected error should be logged as `ERROR`. Ideally, they should also
    be analyzed and the code changed to bugfix them or at least transform them into
    expected errors. Sometimes this is not feasible due to other pressing issues or
    a low occurrence of the problem, but some strategy should be implemented to make
    sure there's consistency in the handling of bugs.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 任何意外错误都应该记录为`ERROR`。理想情况下，它们还应该被分析，并更改代码以修复错误或至少将它们转换为预期的错误。有时这由于其他紧迫的问题或问题发生的频率低而不可行，但应该实施一些策略以确保处理错误的连贯性。
- en: A great tool to handle unexpected errors is Sentry ([https://sentry.io/](https://sentry.io/)).
    This tool creates a trigger for each error on a lot of common platforms, including
    Python Django, Ruby on Rails, Node, JavaScript, C#, iOS, and Android. It aggregates
    the errors detected and allows us to work with them more strategically, which
    is sometimes difficult when just having access to the logs.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 处理意外错误的一个优秀工具是Sentry ([https://sentry.io/](https://sentry.io/))。这个工具在许多常见的平台上为每个错误创建触发器，包括Python
    Django、Ruby on Rails、Node、JavaScript、C#、iOS和Android。它聚合检测到的错误，并允许我们更策略性地处理它们，这在仅仅能够访问日志时有时是困难的。
- en: Sometimes, unexpected errors will present themselves with enough information
    about what the problem is, which could be related to an external problem like
    a network issue or a database problem. The solution may be located outside the
    realm of the service itself.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，意外错误会提供足够的信息来描述问题，这可能涉及到外部问题，如网络问题或数据库问题。解决方案可能位于服务本身之外。
- en: Log strategies
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志策略
- en: A common problem when dealing with logs is deciding on the appropriate severity
    for each of the individual services. Is this message a `WARNING` or an `ERROR`?
    Should this statement be added as an `INFO` message or not?
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 处理日志时常见的一个问题是确定每个单独服务的适当严重性。这条消息是`WARNING`还是`ERROR`？这个声明应该添加为`INFO`消息吗？
- en: 'Most of the log severity descriptions have definitions, such as *the program
    shows a potentially harmful situation* or *the application highlights the progress
    of the request*. These are vague definitions and difficult to act on in a real-life
    situation. Instead of using these vague definitions, try to define each level
    in relationship with any follow-up action that should be taken if the issue is
    encoutered. This helps to clarify to the developers what to do when a given error
    log is found. For example: "*Do I want to be informed each and every time this
    situation happens?*"'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数日志严重性描述都有定义，例如*程序显示一个可能有害的情况*或*应用程序突出显示请求的进度*。这些是模糊的定义，在现实生活中的情况下很难采取行动。与其使用这些模糊的定义，不如尝试将每个级别与如果遇到问题应该采取的任何后续行动相关联来定义。这有助于向开发者阐明在发现给定的错误日志时应该做什么。例如：“*我是否希望每次这种情况发生时都得到通知？*”
- en: 'The following table shows some examples of the different severity levels and
    what action could be taken:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 下表显示了不同严重级别的示例以及可能采取的行动：
- en: '| Log level | Action to take | Comments |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| 日志级别 | 应采取的操作 | 备注 |'
- en: '| `DEBUG` | None. | Not tracked. Only useful while developing. |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `DEBUG` | 无。 | 不跟踪。仅在开发期间有用。|'
- en: '| `INFO` | None. | `INFO` logs show generic information about the flow of the
    actions in the app to help track systems. |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `INFO` | 无。 | `INFO` 日志显示有关应用程序中操作流程的通用信息，以帮助跟踪系统。|'
- en: '| `WARNING` | Track the number of logs. Alert on raising levels. | `WARNING`
    logs track errors that are automatically fixed, like retries to connect to an
    external service, or fixable format errors in a database. A sudden increase may
    require investigation. |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `WARNING` | 跟踪日志数量。当级别上升时发出警报。 | `WARNING` 日志跟踪可以自动修复的错误，如尝试连接外部服务或数据库中的可修复格式错误。突然增加可能需要调查。|'
- en: '| `ERROR` | Track the number of logs. Alert on raising levels. Review all errors.
    | `ERROR` logs track errors that can''t be recovered. A sudden increase may require
    immediate action. All of them should be periodically reviewed to fix common occurrences
    and mitigate them, perhaps moving them to `WARNING` level. |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `ERROR` | 跟踪日志数量。当级别上升时发出警报。审查所有错误。 | `ERROR` 日志跟踪无法恢复的错误。突然增加可能需要立即采取行动。所有这些错误都应定期审查，以修复常见问题并减轻它们，可能将它们提升到
    `WARNING` 级别。|'
- en: '| `CRITICAL` | Immediate response. | `CRITICAL` logs indicate a catastrophic
    failure in the application. A single one indicates the system is not working at
    all and can''t recover. |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `CRITICAL` | 立即响应。 | `CRITICAL` 日志表明应用程序发生了灾难性故障。单个 `CRITICAL` 日志表示系统完全无法工作且无法恢复。|'
- en: This sets clear expectations on how to respond. Note this is an example, and
    you may need to make tweaks and adjustments to adapt this to the needs of your
    specific organization.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这明确了如何响应的期望。请注意，这是一个示例，你可能需要根据你特定组织的需要对其进行调整和修改。
- en: The hierarchy of different severities is very clear, and in our example, there's
    an acceptance that there'll be a certain number of `ERROR` logs generated. For
    the development team's sanity, not everything needs to be fixed immediately, but
    a certain order and prioritization should be enforced.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 不同严重程度的层次结构非常清晰，在我们的示例中，我们接受将产生一定数量的 `ERROR` 日志。为了开发团队的理智，不是所有问题都需要立即修复，但应强制执行一定的顺序和优先级。
- en: In production situations, `ERROR` logs will typically be categorized from "we're
    doomed" to "meh." Development teams should actively either fix "meh" logs or stop
    the issue from being logged to remove noise from the monitoring tools. That may
    include lowering the level of logs if they aren't worth checking. You want as
    few `ERROR` logs as possible, so all of them can be meaningful.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中，`ERROR` 日志通常会被分类从“我们完了”到“嗯”。开发团队应积极修复“嗯”日志或停止记录问题，以从监控工具中去除噪音。这可能包括降低日志级别，如果它们不值得检查的话。你希望尽可能少的
    `ERROR` 日志，这样所有的日志都是有意义的。
- en: Remember that `ERROR` logs will include unexpected errors that typically require
    a fix to either resolve the issue completely, or explicitly capture it and reduce
    its severity if it is not important.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`ERROR` 日志将包括通常需要修复以完全解决或明确捕获并降低其严重性（如果它不重要）的意外错误。
- en: This follow-up is definitely a challenge as applications grow, as the number
    of `ERROR` logs will increase significantly. It requires time to be spent on proactive
    maintenance. If this is not taken seriously and it is too often dropped for other
    tasks, it will compromise the reliability of the application in the medium term.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 随着应用程序的增长，这种后续工作无疑是一个挑战，因为 `ERROR` 日志的数量将显著增加。这需要投入时间进行主动维护。如果不认真对待，并且过于频繁地因其他任务而放弃，则会在中期损害应用程序的可靠性。
- en: '`WARNING` logs are indications that something may not be working as smoothly
    as expected, but things are under control, unless there''s a sudden increase in
    the number of logs of this kind. `INFO` logs are just there to give context in
    the event of a problem, but can be ignored otherwise.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`WARNING` 日志表明某些事情可能没有像预期那样顺利运行，但情况仍在控制之中，除非此类日志的数量突然增加。`INFO` 日志仅在出现问题时提供上下文，否则可以忽略。'
- en: A common mistake is to generate `ERROR` logs in actions where there are incorrect
    input parameters, such as in web requests when a `400 BAD REQUEST` status code
    is returned. Some developers will argue that a customer sending a malformed request
    is an error. But there's nothing that the developer team should do if the request
    is properly detected and returned. It's business as usual, and the only action
    may be to return a meaningful message to the requester so they can fix their request.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的错误是在存在错误输入参数的操作中生成`ERROR`日志，例如在Web请求中返回`400 BAD REQUEST`状态码时。一些开发者可能会争辩说，客户发送的格式不正确的请求是一个错误。但如果请求被正确检测并返回，开发团队就没有什么需要做的。这是正常的业务，唯一可能采取的行动可能是向请求者返回一个有意义的消息，以便他们可以修复他们的请求。
- en: If this behavior persists in certain critical requests, like repeatedly sending
    a bad password, a `WARNING` log can be created. There's no point in creating an
    `ERROR` log when the application is behaving as expected.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这种行为在某些关键请求中持续存在，例如反复发送错误的密码，可以创建一个`WARNING`日志。当应用程序按预期运行时，创建`ERROR`日志是没有意义的。
- en: In web applications, as a rule of thumb, `ERROR` logs should only be created
    when the status code is one of the 50X variants (like 500, 502, and 503). Remember
    that the 40X errors mean that the sender has a problem, while 50X means that the
    application has the problem, and it's your team's responsibility to fix it.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web应用程序中，一般来说，只有在状态码是50X变体之一（如500、502和503）时才应创建`ERROR`日志。记住，40X错误意味着发送者有问题，而50X意味着应用程序有问题，这是你团队的责任去修复。
- en: With common and shared definitions of log levels across the team, all engineers
    will have a shared understanding of error severity that will help shape meaningful
    actions toward improving the code.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在团队中采用常见和共享的日志级别定义，所有工程师都将对错误严重性有一个共同的理解，这将有助于形成改进代码的有意义行动。
- en: Allow time for tweaking and adjusting any definition. It's also likely that
    you'll have to deal with logs created before the definition, which can require
    work. One of the biggest challenges in legacy systems is creating a proper logging
    system to categorize problems, as they'll likely be very noisy, making it difficult
    to distinguish the real problems from annoyances and even non-problems.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 允许时间对任何定义进行调整和微调。也可能需要处理在定义之前创建的日志，这可能需要工作。在遗留系统中，最大的挑战之一是创建一个适当的日志系统来分类问题，因为这些问题可能非常嘈杂，使得区分真正的问题、烦恼甚至非问题变得困难。
- en: Adding logs while developing
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在开发过程中添加日志
- en: Any test runner will capture logs and display it as part of the trace while
    running tests.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 任何测试运行器都会在运行测试时捕获日志，并将其作为跟踪的一部分显示出来。
- en: '`pytest`, which we introduced in *Chapter 10*, *Testing and TDD*, will display
    logs as part of the result of a failing test.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*第10章*，*测试和TDD*中介绍的`pytest`将显示失败的测试结果中的日志。
- en: This is a good opportunity to check that the expected logs are being generated
    while the feature is still in development phase, especially if it's done in a
    TDD process where the failing tests and errors are produced routinely as part
    of the process, as we saw in *Chapter 10*, *Testing and TDD*. Any test that checks
    an error should also add a corresponding log and, while developing the feature,
    check that they are being produced.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个检查在功能开发阶段是否生成预期日志的好机会，尤其是在它是作为TDD过程的一部分完成的情况下，在TDD过程中，失败的测试和错误作为过程的一部分常规产生，正如我们在*第10章*，*测试和TDD*中看到的。任何检查错误的测试都应该添加相应的日志，并且在开发功能时检查它们是否被生成。
- en: You can explicitly add to the test a check to validate that the log is being
    generated by using a tool like `pytest-catchlog` ([https://pypi.org/project/pytest-catchlog/](https://pypi.org/project/pytest-catchlog/)).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用像`pytest-catchlog`（[https://pypi.org/project/pytest-catchlog/](https://pypi.org/project/pytest-catchlog/)）这样的工具显式地向测试添加一个检查，以验证日志是否被生成。
- en: Typically, though, we just take a bit of care and incorporate the practice of
    checking while using TDD practices as part of the initial check that the test
    is failing. However, be sure that the developers understand why it's useful to
    have logs while developing to make the habit stick.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们只需稍加注意，并在使用TDD实践作为初始检查的一部分时，将检查日志的做法纳入其中。然而，确保开发者理解为什么在开发过程中拥有日志是有用的，以便养成习惯。
- en: While developing, `DEBUG` logs can be used to add extra information about the
    code flow that would be excessive for production. In development, this extra information
    can help fill in the gaps between `INFO` logs and help developers to solidify
    the habit of adding logs. A `DEBUG` log may be promoted to `INFO` if, during tests,
    it's found to be useful in tracking problems in production.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，可以使用`DEBUG`日志来添加关于代码流程的额外信息，这些信息对于生产来说可能过多。在开发中，这些额外信息可以帮助填补`INFO`日志之间的差距，并帮助开发者养成添加日志的习惯。如果测试期间发现`DEBUG`日志在生产中跟踪问题很有用，则可以将`DEBUG`日志提升为`INFO`。
- en: Additionally, for special occasions, `DEBUG` logs can be enabled in production
    in controlled cases to track certain problems that are difficult to understand.
    Note that this has big implications on the number of generated logs, which can
    lead to storage problems. Be very cautious here.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在特殊情况下，可以在受控的情况下在生产环境中启用`DEBUG`日志来跟踪难以理解的问题。请注意，这将对生成的日志数量产生重大影响，可能导致存储问题。因此，请非常谨慎。
- en: Be sensible about the messages displayed in `INFO` and higher severity logs.
    In terms of information that's displayed, avoid sensitive data such as passwords,
    secret keys, credit card numbers, and personal information.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 对于显示在`INFO`和更高严重性日志中的消息，要有理智。在显示的信息方面，应避免敏感数据，如密码、密钥、信用卡号码和个人信息。
- en: Keep an eye in production for any size limitations and how quickly logs are
    generated. Systems may experience a log explosion in situations when new features
    are generated, if the number of requests grows, or if the number of workers in
    the system is increased. These three situations can be produced when systems undergo
    growth.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产过程中，要注意任何大小的限制以及日志生成的速度。当新功能生成、请求数量增加或系统中工人的数量增加时，系统可能会经历日志爆炸。这三种情况可以在系统增长时出现。
- en: It's always a good idea to double-check that the logs are being properly captured
    and available in different environments. All the configuration to ensure that
    the logs are properly captured may take a bit of time, so it's better to do this
    beforehand. This involves capturing unexpected errors and other logs in production
    and checking that all the plumbing is done correctly. The alternative is to discover
    that it's not working correctly only after stumbling into a real problem.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 总是检查日志是否被正确捕获并在不同的环境中可用是一个好主意。确保日志被正确捕获的所有配置可能需要一些时间，因此最好事先完成。这包括在生产环境中捕获意外错误和其他日志，并检查所有管道是否正确完成。另一种选择是在遇到真正的问题后才发现它没有正确工作。
- en: Log limitations
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志限制
- en: 'Logs are very useful to understand what''s happening in a running system, but
    they have certain limitations that are important to understand:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 日志对于理解正在运行的系统中的情况非常有用，但它们有一些重要的局限性需要了解：
- en: '*Logs are only as good as their messages*. A good, descriptive message is critical
    in making logs useful. Reviewing the log messages with a critical eye, and correcting
    them when needed, is important to save precious time on production problems.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*日志的价值取决于其消息。一个好的、描述性的消息对于使日志有用至关重要。用批判性的眼光审查日志消息，并在需要时进行纠正，对于在生产问题上节省宝贵时间非常重要。'
- en: '*Have an appropriate number of logs*. Too many logs can confuse a flow, and
    too few may not include enough information to allow us to understand the problem.
    Large numbers of logs also create problems with storage.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*应保持适当的日志数量。过多的日志可能会使流程混乱，而过少的日志可能不会包含足够的信息，使我们能够理解问题。大量的日志也会引起存储问题。'
- en: '*Logs should work as an indication of the context of the problem, but likely
    won''t pinpoint it.* Trying to generate specific logs that fully explain a bug
    will be an impossible task. Instead, focus on showing the general flow and surrounding
    context of the action, so it can be replicated locally and debugged. For example,
    for a request, make sure to log both the request and its parameters so the situation
    can be replicated.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*日志应作为问题上下文的指示，但很可能不会精确指出问题所在。*试图生成能够完全解释错误的特定日志将是一项不可能的任务。相反，应专注于展示动作的一般流程和周围上下文，以便可以在本地复制并调试。例如，对于请求，确保记录请求及其参数，以便可以复制情况。'
- en: '*Logs allow us to follow the execution of a single instance.* When grouped
    together using a request ID or similar, logs can be grouped by execution, allowing
    us to follow the flow of a request or task. However, logs don''t directly display
    aggregated information. Logs answer the question, "*what happened in this task?*",
    but not "*what is going on in the system?*" For that kind of info, it''s better
    to use metrics.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*日志使我们能够跟踪单个实例的执行过程*。当使用请求ID或类似方式分组时，日志可以根据执行进行分组，使我们能够跟踪请求或任务的流程。然而，日志并不直接显示汇总信息。日志回答的问题是“*在这个任务中发生了什么？*”，而不是“*系统中正在发生什么？*”对于这类信息，最好使用指标。'
- en: There are tools available to create metrics based on logs. We will talk more
    about metrics in *Chapter 13*, *Metrics*.
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有可用的工具可以根据日志创建指标。我们将在第13章*指标*中更多地讨论指标。
- en: '*Logs only work retrospectively*. When a problem in a task is detected, logs
    can only show information that was prepared in advance. That''s why it''s important
    to analyze critically and refine the information, removing logs that are not useful
    and adding others with relevant contextual information to help replicate the problem.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*日志仅具有回顾性功能*。当检测到任务中的问题时，日志只能显示事先准备好的信息。这就是为什么批判性地分析和精炼信息很重要，移除无用的日志，并添加包含相关上下文信息的其他日志，以帮助重现问题。'
- en: Logs are a fantastic tool, but they need to be maintained to ensure that they
    can be used to detect bugs and problems and allow us to take action as efficiently
    as possible.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 日志是一个出色的工具，但它们需要维护以确保它们可以用来检测错误和问题，并允许我们尽可能高效地采取行动。
- en: Summary
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we started by presenting the basic elements of logs. We defined
    how logs contain messages plus some metadata like a timestamp, and considered
    the different severity levels. We also described the need to define request IDs
    to group logs related to the same task. We also discussed how, in the Twelve-Factor
    App methodology, logs should be sent to `stdout` to detach log generation from
    the process of handling and routing them to the proper destination to allow the
    collection of all logs in the system.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先介绍了日志的基本元素。我们定义了日志包含消息以及一些元数据，如时间戳，并考虑了不同的严重级别。我们还描述了定义请求ID以分组与同一任务相关的日志的需求。此外，我们还讨论了在十二要素应用方法中，日志应发送到`stdout`，以便将日志生成与处理和路由到适当目的地的过程分离，从而允许收集系统中的所有日志。
- en: 'We then showed how to produce logs in Python using the standard `logging` module,
    describing the three key elements of the `logger`, the `handler`, and the `formatter`.
    Next, we showed the two different errors that can be produced in a system: *expected*,
    understood as errors that were foreseen as possible and are handled; and *unexpected*,
    meaning those that were not foreseen and occurred out of our control. We then
    went through the different strategies and cases for these.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们展示了如何使用标准的`logging`模块在Python中生成日志，描述了`logger`、`handler`和`formatter`的三个关键元素。接下来，我们展示了系统中可能产生的两种不同错误：*预期的*，理解为可以预见并得到处理的错误；和*意外的*，意味着那些我们没有预见并且超出我们控制范围的错误。然后我们探讨了这些错误的不同策略和案例。
- en: We described the different severities and how to generate a strategy for what
    actions should be taken when a log of a certain severity is detected, instead
    of categorizing the logs in terms of "how critical they are", which ends up generating
    vague guidelines and not being very useful.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们描述了不同的严重性以及当检测到特定严重性的日志时，应采取哪些行动的策略，而不是根据“它们有多关键”来对日志进行分类，这最终会产生模糊的指南，并且不太有用。
- en: We discussed several habits to improve the usefulness logs by including them
    in development in a TDD workflow. This allows developers to consider the information
    presented in logs while writing tests and producing errors, which presents the
    perfect opportunity to ensure that the logs generated work correctly.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了几个习惯，通过在TDD工作流程中包含它们来提高日志的有用性。这允许开发者在编写测试和产生错误时考虑日志中呈现的信息，这为确保生成的日志正确工作提供了完美的机会。
- en: Finally, we discussed the limitations of logs and how we can deal with them.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们讨论了日志的限制以及我们如何处理它们。
- en: In the next chapter, we will look at how to work with aggregated information
    to find out the general state of the system through the usage of metrics.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何通过使用指标来处理汇总信息，以找出系统的总体状态。
