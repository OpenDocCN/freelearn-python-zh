- en: Chapter 4. Templates and JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Arranging the base.html template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Including JavaScript settings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using HTML5 data attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Opening object details in a modal dialog
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a continuous scroll
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the Like widget
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uploading images by Ajax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are living in the Web2.0 world, where social web applications and smart websites
    communicate between servers and clients using Ajax, refreshing whole pages only
    when the context changes. In this chapter, you will learn best practices to deal
    with JavaScript in your templates in order to create a rich user experience. For
    responsive layouts, we will use the Bootstrap 3 frontend framework. For productive
    scripting, we will use the jQuery JavaScript framework.
  prefs: []
  type: TYPE_NORMAL
- en: Arranging the base.html template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you start working on templates, one of the first actions is to create the
    `base.html` boilerplate, which will be extended by most of the page templates
    in your project. In this recipe, we will demonstrate how to create such template
    for multilingual HTML5 websites with responsiveness in mind.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Responsive websites are the ones that adapt to the viewport of the device whether
    the visitor uses desktop browsers, tablets, or phones.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create the `templates` directory in your project and set `TEMPLATE_DIRS` in
    the settings.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the root directory of your `templates`, create a `base.html` file with the
    following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the same directory, create another file named `base_simple.html` for specific
    cases, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The base template contains the `<head>` and `<body>` sections of the HTML document
    with all the details that are reused on each page of the website. Depending on
    the web design requirements, you can have additional base templates for different
    layouts. For example, we added the `base_simple.html` file, which has the same
    HTML `<head>` section and a very minimalistic `<body>` section; and it can be
    used for the login screen, password reset, or other simple pages. You can have
    separate base templates for single-column, two-column, and three-column layouts,
    where each of them extends `base.html` and overwrites the content of the `<body>`
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look into the details of the `base.html` template that we defined earlier.
  prefs: []
  type: TYPE_NORMAL
- en: In the `<head>` section, we define UTF-8 as the default encoding to support
    multilingual content. Then, we have the viewport definition that will scale the
    website in the browser in order to use the full width. This is necessary for small-screen
    devices that will get specific screen layouts created with the Bootstrap frontend
    framework. Of course, there is a customizable website title and the favicon will
    be shown in the browser's tab. We have extendable blocks for meta tags, style
    sheets, JavaScript, and whatever else that might be necessary for the `<head>`
    section. Note that we load the Bootstrap CSS and JavaScript in the template as
    we want to have responsive layouts and basic solid predefined styles for all elements.
    Then, we load the JavaScript jQuery library that efficiently and flexibly allows
    us to create rich user experiences. We also load JavaScript settings that are
    rendered from a Django view. You will learn about this in the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: In the `<body>` section, we have the header with an overwritable navigation
    and a language chooser. We also have the content block and footer. At the very
    bottom, there is an extendable block for additional markup or JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: The base template that we created is, by no means, a static unchangeable template.
    You can add to it the elements that you need, for example, Google Analytics code,
    common JavaScript files, the Apple touch icon for iPhone bookmarks, Open Graph
    meta tags, Twitter Card tags, schema.org attributes, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Including JavaScript settings* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Including JavaScript settings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each Django project has its configuration set in the `conf/base.py` or `settings.py`
    settings file. Some of these configuration values also need to be set in JavaScript.
    As we want a single location to define our project settings, and we don't want
    to repeat the process when setting the configuration for the JavaScript values,
    it is a good practice to include a dynamically generated configuration file in
    the base template. In this recipe, we will see how to do that.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Make sure that you have the media, static, and request context processors set
    in the `TEMPLATE_CONTEXT_PROCESSORS` setting, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Also, create the `utils` app if you haven't done so already and place it under
    `INSTALLED_APPS` in the settings.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to create and include the JavaScript settings:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a URL rule to call a view that renders JavaScript settings, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the views of your `utils` app, create the `render_js()` view that returns
    a response of the JavaScript content type, as shown in the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `settings.js` template that returns JavaScript with the global settings
    variable, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, if you haven''t done it yet, include the rendered JavaScript settings
    file in the base template, as shown in the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Django template system is very flexible; you are not limited to using templates
    just for HTML. In this example, we will dynamically create the JavaScript file.
    You can access it in your development web server at `http://127.0.0.1:8000/en/js-settings/`
    and its content will be something similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The view will be cacheable in both server and browser.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to pass more variables to the JavaScript settings, either create
    a custom view and pass all the values to the context or create a custom context
    processor and pass all the values there. In the latter case, the variables will
    also be accessed in all the templates of your project. For example, you might
    have indicators such as `{{ is_mobile }}`, `{{ is_tablet }}`, and `{{ is_desktop
    }}` in your templates, with the user agent string telling whether the visitor
    uses a mobile, tablet, or desktop browser.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Arranging the base.html template* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Using HTML5 data attributes* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using HTML5 data attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you have dynamic data related to the DOM elements, you need a more efficient
    way to pass the values from Django to JavaScript. In this recipe, we will see
    a way to attach data from Django to custom HTML5 data attributes and then describe
    how to read the data from JavaScript with two practical examples. The first example
    will be an image that changes its source, depending on the viewport, so that the
    smallest version is shown on mobile devices, the medium-sized version is shown
    on tablets, and the biggest high-quality image is shown for the desktop version
    of the website. The second example will be a Google Map with a marker at a specified
    geographical position.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To get started, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `locations` app with a `Location` model, which will at least have the
    title character field, the slug field for URLs, the `small_image`, `medium_image`,
    and `large_image` image fields, and the latitude and longitude floating-point
    fields.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The term *slug* comes from newspaper editing and it means a short string without
    any special characters; just letters, numbers, underscores, and hyphens. Slugs
    are generally used to create unique URLs.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create an administration for this model and enter a sample location.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lastly, create a detailed view for the location and set the URL rule for it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we already have the app created, we will now need the template for the location
    detail:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Besides the template, we need the JavaScript file that will read out the HTML5
    data attributes and use them accordingly, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we need to set some CSS, as shown in the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you open your location detail view in a browser, you will see something
    similar to the following in the large window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/B04912_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you resize the browser window to 468 pixels or less, the image will change
    to its smallest version, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/B04912_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let's take a look at the code. In the template, we have an image tag with an
    `img-full-width` CSS class and its source is set to the smallest image by default.
    This `image` tag also has `data-small-src`, `data-medium-src`, and `data-large-src`
    custom attributes. In the JavaScript, the `show_best_images()` function is called
    when the page is loaded or the window is resized. The function goes through all
    images with the `img-full-width` CSS class and sets appropriate image sources
    from the custom data attributes, depending on the current image width.
  prefs: []
  type: TYPE_NORMAL
- en: Then, there is a `<div>` element with the map ID and the `data-latitude` and
    `data-longitude` custom attributes in the template. In the JavaScript, a `show_map()`
    function is called when the page is loaded. This function will create a Google
    Map in the `<div>` element. At first, the custom attributes are read and converted
    from strings to floating-point values. Then, the `LatLng` object is created that,
    in the next steps, becomes the center of the map and the geographical position
    of the marker shown on this map.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Including JavaScript settings* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Opening object details in a modal dialog* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Inserting a map into a change form* recipe in [Chapter 6](ch06.html "Chapter 6. Model
    Administration"), *Model Administration*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Opening object details in a modal dialog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will create a list of links to the locations, which when
    clicked, opens a Bootstrap 3 modal dialog (we will call it pop up in this recipe)
    with some information about the location and the *more…* link leading to the location
    detail page. The content for the dialog will be loaded by Ajax. For visitors without
    JavaScript, the detail page will open immediately, without this intermediate step.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's start with the `locations` app that we created in the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `urls.py` file, we will have three URL rules; one for the location list,
    other for the location detail, and the third one for the dialog, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Consequently, there will be three simple views, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute these steps one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a template for the location''s list view with a hidden empty modal dialog
    at the end. Each listed location will have custom HTML5 data attributes dealing
    with the pop-up information, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need JavaScript to handle the opening of the dialog and loading the content
    dynamically:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we will create a template for the content that will be loaded in the
    modal dialog, as shown in the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we go to the location''s list view in a browser and click on one of the
    locations, we will see a modal dialog similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/B04912_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How does this work? In the template, there is a `<div>` element with the `item`
    CSS class and a link for each location. The links have the `data-popup-url` and
    `data-popup-title` custom attributes. In the JavaScript, when the page is loaded,
    we assign an `onclick` handler for the `<body>` tag. The handler checks if any
    link inside the tag with the `item` CSS class was clicked. For each such clicked
    link the custom attributes are read as `popup_url` and `popup_title`, the new
    title is set for the hidden dialog box, the content is loaded in the modal dialog
    using Ajax, and then it is shown to the visitor.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Using HTML5 data attributes* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Implementing a continuous scroll* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Implementing the Like widget* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a continuous scroll
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Social websites often have the feature of continuous scrolling, which is also
    known as infinite scrolling. There are long lists of items and as you scroll the
    page down, new items are loaded and attached to the bottom automatically. In this
    recipe, we will see how to achieve such an effect with Django and the jScroll
    jQuery plugin. We'll illustrate this using a sample view showing the top 250 movies
    of all time from Internet Movie Database ([http://www.imdb.com/](http://www.imdb.com/)).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, download the jScroll plugin from the following link: [https://github.com/pklauzinski/jscroll](https://github.com/pklauzinski/jscroll).'
  prefs: []
  type: TYPE_NORMAL
- en: Put the `jquery.jscroll.js` and `jquery.jscroll.min.js` files from the package
    in the `myproject/site_static/site/js/` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Next, for this example, you will create a `movies` app with a paginated list
    view for the movies. You can either create a `Movie` model or a list of dictionaries
    with the movie data. Every movie will have rank, title, release year, and rating
    fields.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to create an continuously scrolling page:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to create a template for the list view that will also show
    a link to the next page, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The second step is to add JavaScript, as shown in the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you open the movie list view in a browser; a predefined number of items,
    for example, 25, is shown on the page. As you scroll down, an additional 25 items
    and the next pagination link are loaded and appended to the item container. Then,
    the third page of the items is loaded and attached at the bottom, and this continues
    until there are no more pages left to display.
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon the page load, the `<div>` tag in JavaScript that has the `object_list`
    CSS class and contains the items and pagination links will become a jScroll object.
    The following parameters define its features:'
  prefs: []
  type: TYPE_NORMAL
- en: '`loadingHtml`: This sets an animated loading indicator shown at the end of
    the list when a new page is loading'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`padding`: This will define that the new page has to be loaded, when there
    are 100 pixels between the scrolling position and the end of the scrolling area'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pagingSelector`: This CSS selector finds the HTML elements that will be hidden
    in the browsers with JavaScript switched on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nextSelector`: This CSS selector finds the HTML elements that will be used
    to read the URL of the next page'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`contentSelector`: This CSS selector defines the HTML elements to be taken
    out of the loaded content and put in the container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Managing paginated lists* recipe in [Chapter 3](ch03.html "Chapter 3. Forms
    and Views"), *Forms and Views*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Composing class-based views* recipe in [Chapter 3](ch03.html "Chapter 3. Forms
    and Views"), *Forms and Views*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Including JavaScript settings* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the Like widget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Nowadays, social websites usually have integrated Facebook, Twitter, and Google+
    widgets to like and share pages. In this recipe, I will guide you through a similar
    internal liking Django app that saves all the likes in your database so that you
    can create specific views based on the things that are liked on your website.
    We will create a Like widget with a two-state button and badge showing the number
    of total likes. The following are the states:'
  prefs: []
  type: TYPE_NORMAL
- en: Inactive state, where you can click on a button to activate it:![Implementing
    the Like widget](img/B04912_04_04.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Active state, where you can click on a button to deactivate it:![Implementing
    the Like widget](img/B04912_04_05.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The state of the widget will be handled by Ajax calls.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, create a `likes` app with a `Like` model, which has a foreign-key relation
    to the user that is liking something and a generic relationship to any object
    in the database. We will use `ObjectRelationMixin`, which we defined in the *Creating
    a model mixin to handle generic relations* recipe in [Chapter 2](ch02.html "Chapter 2. Database
    Structure"), *Database Structure*. If you don''t want to use the mixin, you can
    also define a generic relation in the following model yourself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, make sure that the request context processor is set in the settings.
    We also need an authentication middleware in the settings for the currently logged-in
    user attached to the request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute these steps one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `likes` app, create a `templatetags` directory with an empty `__init__.py`
    file in order to make it a Python module. Then, add the `likes_tags.py` file,
    where we''ll define the `{% like_widget %}` template tag as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Also, we''ll add a filter in the same file to get the number of likes for a
    specified object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the URL rules, we need a rule for a view, which will handle the liking and
    unliking using Ajax:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we need to define the view, as shown in the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the template for the list or detail view of any object, we can add the template
    tag for the widget. Let''s add the widget to the location detail that we created
    in the previous recipes, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we need a template for the widget, as shown in the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we create JavaScript to handle the liking and unliking action in the
    browser, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For any object in your website, you can put the `{% like_widget for object %}`
    template tag that will check whether the object is already liked and will show
    an appropriate state. The `data-href`, `data-like-text`, and `data-unlike-text`
    custom HTML5 attributes are in the widget template. The first attribute holds
    a unique object-specific URL to change the current state of the widget. The other
    two attributes hold the translated texts for the widget. In the JavaScript, liking
    buttons are recognized by the like button CSS class. A click-event listener attached
    to the document watches for the `onClick` events from each such button and then
    posts an Ajax call to the URL that is specified by the `data-href` attribute.
    The specified view accepts two of the parameters, content type and object ID,
    of the liked object. The view checks whether `Like` for the specified object exists,
    and if it does, the view removes it; otherwise the `Like` object is added. As
    a result, the view returns a JSON response with the success status, liked object's
    text representation, the action whether the `Like` object was added or removed,
    and the total number of likes. Depending on the action that is returned, JavaScript
    will show an appropriate state for the button.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can debug the Ajax responses in the Chrome Developer Tools or Firefox Firebug
    plugin. If any server errors occur while developing, you will see the error trace
    back in the preview of the response, otherwise you will see the returned JSON
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/B04912_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Opening object details in a modal dialog* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Implementing a continuous scroll* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Uploading images by Ajax* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a model mixin to handle generic relations* recipe in [Chapter
    2](ch02.html "Chapter 2. Database Structure"), *Database Structure*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 5](ch05.html "Chapter 5. Custom Template Filters and Tags"), *Custom
    Template Filters and Tags*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uploading images by Ajax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: File uploads using Ajax has become the de facto standard on the web. People
    want to see what they have chosen right after selecting a file instead of seeing
    it after submitting a form. Also, if the form has validation errors, nobody wants
    to select the files again; the file should still be selected in the form with
    validation errors.
  prefs: []
  type: TYPE_NORMAL
- en: There is a third-party app, `django-ajax-uploader`, that can be used to upload
    images with Ajax. In this recipe, we will see how to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's start with the `quotes` app that we created for the *Uploading images*
    recipe in [Chapter 3](ch03.html "Chapter 3. Forms and Views"), *Forms and Views*.
    We will reuse the model and view; however, we'll create a different form and template
    and add JavaScript too.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install `django-crispy-forms` and `django-ajax-uploader` in your local environment
    using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Don''t forget to put these apps in `INSTALLED_APPS`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s redefine the form for inspirational quotes using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create a layout for the Bootstrap 3 markup. Note that, instead of
    the `picture` image field, we have the hidden `picture_path` and `delete_picture`
    fields and some markup for the file upload widget:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we will overwrite the save method in order to handle the saving of the
    inspirational quote, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In addition to the previously defined views in the quotes app, we add the `ajax_uploader`
    view that will handle uploads with Ajax, as shown in the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we set the URL rule for the view, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, create the `image_upload_widget.html` template that will be included
    in the crispy form:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, it is time to create the template for the form page itself. In the extrabody
    block, we will set a `translatable_file_uploader_options` variable that will deal
    with all translatable options for the file uploader, such as the widget template
    markup, error messages, and notifications:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we create the JavaScript file that will initialize the file upload
    widget and handle the image preview and deletion, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When an image is selected in the upload widget, the result in the browser will
    look similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/B04912_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The same form can be used to create an inspirational quote and change an existing
    inspirational quote. Let''s dig deeper into the process to see how it works. In
    the form, we have an uploading mechanism that consists of the following essential
    parts:'
  prefs: []
  type: TYPE_NORMAL
- en: The area for the preview of the image that is defined as a `<div>` tag with
    the preview CSS class. Initially, it might show an image if we are in an object
    change view and the `InspirationQuote` object is passed to the template as `{{
    instance }}`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The area for the Ajax uploader widget that is defined as a `<div>` tag with
    the `uploader` CSS class. It will be filled with the dynamically-created uploading
    and deleting buttons as well as the uploading progress indicators.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The help text for the upload.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The area for error messages that is defined as a `<div>` tag with the `messages`
    CSS class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The hidden `picture_path` character field to set the path of the uploaded file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The hidden `delete_picture` Boolean field to mark the deletion of the file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On page load, JavaScript will check whether `picture_path` is set; and if it
    is, it will show a picture preview. This will be the case only when the form is
    submitted with an image selected; however, there are validation errors.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, we are defining the options for the upload widget in JavaScript.
    These options are combined of the global `translatable_file_uploader_options`
    variable with translatable strings set in the template and other configuration
    options set in the JavaScript file. The Ajax upload widget is initialized with
    these options. Some important settings to note are the `onComplete` callback that
    shows an image preview and fills in the `picture_path` field when an image is
    uploaded and the `showMessage` callback that defines how to show the error messages
    in the wanted area.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, there is a handler for the delete button in JavaScript, which when clicked,
    sets the hidden `delete_picture` field to `1` and removes the preview image.
  prefs: []
  type: TYPE_NORMAL
- en: The Ajax uploader widget dynamically creates a form with the file upload field
    and a hidden `<iframe>` tag to post the form data. When a file is selected, it
    is immediately uploaded to the `uploads` directory under `MEDIA_URL` and the path
    to the file is set to the `hidden picture_path` field. This directory is a temporary
    location for the uploaded files. When a user submits the inspirational quote form
    and the input is valid, the `save()` method is called. If `delete_picture` is
    set to `1`, the picture of the model instance will be deleted. If the `picture_path`
    field is defined, the image from the temporary location will be copied to its
    final destination and the original will be removed.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Uploading images* recipe in [Chapter 3](ch03.html "Chapter 3. Forms and
    Views"), *Forms and Views*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Opening object details in a modal dialog* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Implementing a continuous scroll* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Implementing the Like widget* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
