<html><head></head><body>
        

            
                <h1 class="header-title">Trees</h1>
            

            
                
<p>A tree is a hierarchical form of data structure. When we dealt with lists, queues, and stacks, items followed each other. But in a tree, there is a <em>parent-child</em> relationship between items.</p>
<p>To visualize what trees look like, imagine a tree growing up from the ground. Now remove that image from your mind. Trees are normally drawn downward, so you would be better off imagining the root structure of the tree growing downward.</p>
<p>At the top of every tree is the so-called <em>root node</em>. This is the ancestor of all other nodes in the tree.</p>
<p>Trees are used for a number of things, such as parsing expressions, and searches. Certain document types, such as XML and HTML, can also be represented in a tree form. We shall look at some of the uses of trees in this chapter.</p>
<p>In this chapter, we will cover the following areas:</p>
<ul>
<li>Terms and definitions of trees</li>
<li>Binary trees and binary search trees</li>
<li>Tree traversal</li>
</ul>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Terminology</h1>
            

            
                
<p>Let's consider some terms associated with trees.</p>
<p>To understand trees, we need to first understand the basic ideas on which they rest. The following figure contains a typical tree consisting of character nodes lettered <strong>A</strong> through to <strong>M</strong>.</p>
<div><img class="image-border" height="230" src="img/CH_06_01.png" width="299"/></div>
<p class="CDPAlignCenter CDPAlign CDPAlignLeft">Here is a list of terms associated with a Tree:</p>
<ul>
<li><strong>Node</strong>: Each circled alphabet represents a node. A node is any structure that holds data.</li>
<li><strong>Root node</strong>: The root node is the only node from which all other nodes come. A tree with an undistinguishable root node cannot be considered as a tree. The root node in our tree is the node A.</li>
<li><strong>Sub-tree</strong>: A sub-tree of a tree is a tree with its nodes being a descendant of some other tree. Nodes F, K, and L form a sub-tree of the original tree consisting of all the nodes.</li>
<li><strong>Degree</strong>: The number of sub-trees of a given node. A tree consisting of only one node has a degree of 0. This one tree node is also considered as a tree by all standards. The degree of node A is 2.</li>
<li><strong>Leaf node</strong>: This is a node with a degree of 0. Nodes J, E, K, L, H, M, and I are all leaf nodes.</li>
<li><strong>Edge</strong>: The connection between two nodes. An edge can sometimes connect a node to itself, making the edge appear as a loop.</li>
<li><strong>Parent</strong>: A node in the tree with other connecting nodes is the parent of those nodes. Node B is the parent of nodes D, E, and F.</li>
<li><strong>Child</strong>: This is a node connected to its parent. Nodes B and C are children of node A, the parent and root node.</li>
<li><strong>Sibling</strong>: All nodes with the same parent are siblings. This makes the nodes B and C siblings.</li>
<li><strong>Level</strong>: The level of a node is the number of connections from the root node. The root node is at level 0. Nodes B and C are at level 1.</li>
<li><strong>Height of a tree</strong>: This is the number of levels in a tree. Our tree has a height of 4.</li>
<li><strong>Depth</strong>: The depth of a node is the number of edges from the root of the tree to that node. The depth of node H is 2.</li>
</ul>
<p>We shall begin our treatment of trees by considering the node in a tree and abstracting a class.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Tree nodes</h1>
            

            
                
<p>Just as was the case with other data structures that we encountered, such as lists and stacks, trees are built up of nodes. But the nodes that make up a tree need to contain data about the parent-child relationship that we mentioned earlier.</p>
<p>Let us now look at how to build a binary tree <kbd>node</kbd> class in Python:</p>
<pre>
    class Node: <br/>        def __init__(self, data): <br/>            self.data = data <br/>            self.right_child = None <br/>            self.left_child = None 
</pre>
<p>Just like in our previous implementations, a node is a container for data and holds references to other nodes. Being a binary tree node, these references are to the left and the right children.</p>
<p>To test this class out, we first create a few nodes:</p>
<pre>
    n1 = Node("root node")  <br/>    n2 = Node("left child node") <br/>    n3 = Node("right child node") <br/>    n4 = Node("left grandchild node") 
</pre>
<p>Next, we connect the nodes to each other. We let <kbd>n1</kbd> be the root node with <kbd>n2</kbd> and <kbd>n3</kbd> as its children. Finally, we hook <kbd>n4</kbd> as the left child to <kbd>n2</kbd>, so that we get a few iterations when we traverse the left sub-tree:</p>
<pre>
    n1.left_child = n2 <br/>    n1.right_child = n3 <br/>    n2.left_child = n4 
</pre>
<p>Once we have our tree structure set up, we are ready to traverse it. As mentioned previously, we shall traverse the left sub-tree. We print out the node and move down the tree to the next left node. We keep doing this until we have reached the end of the left sub-tree:</p>
<pre>
    current = n1 <br/>    while current: <br/>        print(current.data) <br/>        current = current.left_child 
</pre>
<p>As you will probably have noticed, this requires quite a bit of work in the client code, as you have to manually build up the tree structure.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Binary trees</h1>
            

            
                
<p>A binary tree is one in which each node has a maximum of two children. Binary trees are very common and we shall use them to build up a BST implementation in<br/>
Python.</p>
<p>The following figure is an example of a binary tree with 5 being the root node:</p>
<div><img class="image-border" height="107" src="img/image_06_001.jpg" width="107"/></div>
<p>Each child is identified as being the right or left child of its parent. Since the parent node is also a node by itself, each node will hold a reference to a right and left node even if the nodes do not exist.</p>
<p>A regular binary tree has no rules as to how elements are arranged in the tree. It only satisfies the condition that each node should have a maximum of two children.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Binary search trees</h1>
            

            
                
<p>A <strong>binary search tree</strong> (<strong>BST</strong>) is a special kind of a binary tree. That is, it is a tree that is structurally a binary tree. Functionally, it is a tree that stores its nodes in such a way to be able to search through the tree efficiently.</p>
<p>There is a structure to a BST. For a given node with a value, all the nodes in the left sub-tree are less than or equal to the value of that node. Also, all the nodes in the right sub-tree of this node are greater than that of the parent node. As an example, consider the following tree:</p>
<p class="CDPAlignCenter CDPAlign"><img class="image-border" height="159" src="img/CH_06_02.png" width="275"/></p>
<p>This is an example of a BST. Testing our tree for the properties of a BST, you realize that all the nodes in the left sub-tree of the root node have a value less than 5. Likewise, all the nodes in the right sub-tree have a value that is greater than 5. This property applies to all the nodes in a BST, with no exceptions:</p>
<p class="CDPAlignCenter CDPAlign"><img class="image-border" height="140" src="img/CH_06_03.png" width="242"/></p>
<p>Despite the fact that the preceding figure looks similar to the previous figure, it does not qualify as a BST. Node 7 is greater than the root node 5; however, it is located to the left of the root node. Node 4 is to the right sub-tree of its parent node 7, which is incorrect.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Binary search tree implementation</h1>
            

            
                
<p>Let us begin our implementation of a BST. We will want the tree to hold a reference to its own root node:</p>
<pre>
    class Tree: <br/>        def __init__(self): <br/>            self.root_node = None 
</pre>
<p>That's all that is needed to maintain the state of a tree. Let's examine the main operations on the tree in the next section.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Binary search tree operations</h1>
            

            
                
<p>There are essentially two operations that are needful for having a usable BST. These are the <kbd>insert</kbd> and <kbd>remove</kbd> operations. These operations must occur with the one rule that they must maintain the principle that gives the BST its structure.</p>
<p>Before we tackle the insertion and removal of nodes, let's discuss some equally important operations that will help us better understand the <kbd>insert</kbd> and <kbd>remove</kbd> operations.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Finding the minimum and maximum nodes</h1>
            

            
                
<p>The structure of the BST makes looking for the node with the maximum and minimum values very easy.</p>
<p>To find the node with smallest value, we start our traversal from the root of the tree and visit the left node each time we reach a sub-tree. We do the opposite to find the node with the biggest value in the tree:</p>
<p class="CDPAlignCenter CDPAlign"><img class="image-border" height="174" src="img/CH_06_09.png" width="374"/></p>
<p>We move down from node 6 to 3 to 1 to get to the node with smallest value. Likewise, we go down 6, 8 to node 10, which is the node with the largest value.</p>
<p>This same means of finding the minimum and maximum nodes applies to sub-trees too. The minimum node in the sub-tree with root node 8 is 7. The node within that sub-tree with the maximum value is 10.</p>
<p>The method that returns the minimum node is as follows:</p>
<pre>
    def find_min(self): <br/>        current = self.root_node <br/>        while current.left_child: <br/>            current = current.left_child <br/><br/>        return current 
</pre>
<p>The <kbd>while</kbd> loop continues to get the left node and visits it until the last left node points to <kbd>None</kbd>. It is a very simple method. The method to return the maximum node does the opposite, where <kbd>current.left_child</kbd> now becomes <kbd>current.right_child</kbd>.</p>
<p>It takes <strong>O</strong>(<em>h</em>) to find the minimum or maximum value in a BST, where <em>h</em> is the height of the tree.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Inserting nodes</h1>
            

            
                
<p>One of the operations on a BST is the need to insert data as nodes. Whereas in our first implementation, we had to insert the nodes ourselves, here we are going to let the tree be in charge of storing its data.</p>
<p>In order to make a search possible, the nodes must be stored in a specific way. For each given node, its left child node will hold data that is less than its own value, as already discussed. That node's right child node will hold data greater than that of its parent node.</p>
<p>We are going to create a new BST of integers by starting with the data 5. To do this, we will create a node with its data attribute set to 5.</p>
<p>Now, to add the second node with value 3, 3 is compared with 5, the root node:</p>
<div><img class="image-border" height="45" src="img/image_06_002.jpg" width="156"/></div>
<p>Since 5 is greater than 3, it will be put in the left sub-tree of node 5. Our BST will look as follows:</p>
<div><img class="image-border" height="105" src="img/image_06_003.jpg" width="125"/></div>
<p>The tree satisfies the BST rule, where all the nodes in the left sub-tree are less than its parent.</p>
<p>To add another node of value 7 to the tree, we start from the root node with value 5 and do a comparison:</p>
<div><img class="image-border" height="45" src="img/image_06_004.jpg" width="162"/></div>
<p>Since 7 is greater than 5, the node with value 7 is situated to the right of this root.</p>
<p>What happens when we want to add a node that is equal to an existing node? We will simply add it as a left node and maintain this rule throughout the structure.</p>
<p>If a node already has a child in the place where the new node goes, then we have to move down the tree and attach it.</p>
<p>Let's add another node with value 1. Starting from the root of the tree, we do a comparison between 1 and 5:</p>
<div><img class="image-border" height="79" src="img/image_06_005.jpg" width="183"/></div>
<p>The comparison reveals that 1 is less than 5, so we move our attention to the left node of 5, which is the node with value 3:</p>
<div><img class="image-border" height="117" src="img/CH_06_05.png" width="305"/></div>
<p>We compare 1 with 3 and since 1 is less than 3, we move a level below node 3 and to its left. But there is no node there. Therefore, we create a node with the value 1 and associate it with the left pointer of node 3 to obtain the following structure:</p>
<div><img class="image-border" height="111" src="img/image_06_006.jpg" width="114"/></div>
<p>So far, we have been dealing only with nodes that contain only integers or numbers. For numbers, the idea of greater than and lesser than are clearly defined. Strings would be compared alphabetically, so there are no major problems there either. But if you want to store your own custom data types inside a BST, you would have to make sure that your class supports ordering.</p>
<p>Let's now create a function that enables us to add data as nodes to the BST. We begin with a function declaration:</p>
<pre>
    def insert(self, data): 
</pre>
<p>By now, you will be used to the fact that we encapsulate the data in a node. This way, we hide away the <kbd>node</kbd> class from the client code, who only needs to deal with the tree:</p>
<pre>
        node = Node(data) 
</pre>
<p>A first check will be to find out whether we have a root node. If we don't, the new node becomes the root node (we cannot have a tree without a root node):</p>
<pre>
        if self.root_node is None: <br/>            self.root_node = node <br/>        else: 
</pre>
<p>As we walk down the tree, we need to keep track of the current node we are working on, as well as its parent. The variable <kbd>current</kbd> is always used for this purpose:</p>
<pre>
        current = self.root_node <br/>        parent = None <br/>        while True: <br/>            parent = current 
</pre>
<p>Here we must perform a comparison. If the data held in the new node is less than the data held in the current node, then we check whether the current node has a left child node. If it doesn't, this is where we insert the new node. Otherwise, we keep traversing:</p>
<pre>
        if node.data &lt; current.data: <br/>            current = current.left_child <br/>            if current is None: <br/>                parent.left_child = node <br/>                return 
</pre>
<p>Now we take care of the greater than or equal case. If the current node doesn't have a right child node, then the new node is inserted as the right child node. Otherwise, we move down and continue looking for an insertion point:</p>
<pre>
        else: <br/>            current = current.right_child <br/>            if current is None: <br/>                parent.right_child = node <br/>                return 
</pre>
<p>Insertion of a node in a BST takes <strong>O</strong>(<em>h</em>), where h is the height of the tree.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Deleting nodes</h1>
            

            
                
<p>Another important operation on a BST is the <kbd>deletion</kbd> or <kbd>removal</kbd> of nodes. There are three scenarios that we need to cater for during this process. The node that we want to remove might have the following:</p>
<ul>
<li>No children</li>
<li>One child</li>
<li>Two children</li>
</ul>
<p>The first scenario is the easiest to handle. If the node about to be removed has no children, we simply detach it from its parent:</p>
<div><img class="image-border" height="110" src="img/CH_06_06.png" width="324"/></div>
<p>Because node A has no children, we will simply dissociate it from its parent, node Z.</p>
<p>On the other hand, when the node we want to remove has one child, the parent of that node is made to point to the child of that particular node:</p>
<div><img class="image-border" height="253" src="img/CH_06_07.png" width="188"/></div>
<p>In order to remove node 6, which has as its only child, node 5, we point the left pointer of node 9 to node 5. The relationship between the parent node and child has to be preserved. That is why we need to take note of how the child node is connected to its parent (which is the node about to be deleted). The child node of the deleted node is stored. Then we connect the parent of the deleted node to that child node.</p>
<p>A more complex scenario arises when the node we want to delete has two children:</p>
<div><img class="image-border" height="179" src="img/CH_06_08.png" width="361"/></div>
<p>We cannot simply replace node 9 with either node 6 or 13. What we need to do is to find the next biggest descendant of node 9. This is node 12. To get to node 12, we move to the right node of node 9. And then move left to find the leftmost node. Node 12 is called the in-order successor of node 9. The second step resembles the move to find the maximum node in a sub-tree.</p>
<p>We replace the value of node 9 with the value 12 and remove node 12. In removing node 12, we end up with a simpler form of node removal that has been addressed previously. Node 12 has no children, so we apply the rule for removing nodes without children accordingly.</p>
<p>Our <kbd>node</kbd> class does not have reference to a parent. As such, we need to use a helper method to search for and return the node with its parent node. This method is similar to the <kbd>search</kbd> method:</p>
<pre>
    def get_node_with_parent(self, data): <br/>        parent = None <br/>        current = self.root_node <br/>        if current is None: <br/>            return (parent, None) <br/>        while True: <br/>            if current.data == data: <br/>                return (parent, current) <br/>            elif current.data &gt; data: <br/>                parent = current <br/>                current = current.left_child <br/>            else: <br/>                parent = current <br/>                current = current.right_child <br/><br/>        return (parent, current) 
</pre>
<p>The only difference is that before we update the current variable inside the loop, we store its parent with <kbd>parent = current</kbd>. The method to do the actual removal of a node begins with this search:</p>
<pre>
    def remove(self, data): <br/>        parent, node = self.get_node_with_parent(data) <br/><br/>        if parent is None and node is None: <br/>            return False <br/><br/>        # Get children count <br/>        children_count = 0 <br/><br/>        if node.left_child and node.right_child: <br/>            children_count = 2 <br/>        elif (node.left_child is None) and (node.right_child is None): <br/>            children_count = 0 <br/>        else: <br/>            children_count = 1 
</pre>
<p>We pass the parent and the found node to <kbd>parent</kbd> and <kbd>node</kbd> respectively with the line <kbd>parent, node = self.get_node_with_parent(data)</kbd>. It is helpful to know the number of children that the node we want to delete has. That is the purpose of the <kbd>if</kbd> statement.</p>
<p>After this, we need to begin handling the various conditions under which a node can be deleted. The first part of the <kbd>if</kbd> statement handles the case where the node has no children:</p>
<pre>
        if children_count == 0: <br/>            if parent: <br/>                if parent.right_child is node: <br/>                    parent.right_child = None <br/>                else: <br/>                    parent.left_child = None <br/>            else: <br/>                self.root_node = None 
</pre>
<p><kbd>if parent:</kbd> is used to handle cases where there is a BST that has only one node in the whole of the three.</p>
<p>In the case where the node about to be deleted has only one child, the <kbd>elif</kbd> part of the <kbd>if</kbd> statement does the following:</p>
<pre>
        elif children_count == 1: <br/>            next_node = None <br/>            if node.left_child: <br/>                next_node = node.left_child <br/>            else: <br/>                next_node = node.right_child <br/><br/>            if parent: <br/>                if parent.left_child is node: <br/>                    parent.left_child = next_node <br/>                else: <br/>                    parent.right_child = next_node <br/>            else: <br/>                self.root_node = next_node 
</pre>
<p><kbd>next_node</kbd> is used to keep track of where the single node pointed to by the node we want to delete is. We then connect <kbd>parent.left_child</kbd> or <kbd>parent.right_child</kbd> to <kbd>next_node</kbd>.</p>
<p>Lastly, we handle the condition where the node we want to delete has two children:</p>
<pre>
        ... <br/>        else: <br/>            parent_of_leftmost_node = node <br/>            leftmost_node = node.right_child <br/>            while leftmost_node.left_child: <br/>                parent_of_leftmost_node = leftmost_node <br/>                leftmost_node = leftmost_node.left_child <br/><br/>            node.data = leftmost_node.data 
</pre>
<p>In finding the in-order successor, we move to the right node with <kbd>leftmost_node = node.right_child</kbd>. As long as there exists a left node, <kbd>leftmost_node.left_child</kbd> will evaluate to <kbd>True</kbd> and the <kbd>while</kbd> loop will run. When we get to the leftmost node, it will either be a leaf node (meaning that it will have no child node) or have a right child.</p>
<p>We update the node about to be removed with the value of the in-order successor with <kbd>node.data = leftmost_node.data</kbd>:</p>
<pre>
    if parent_of_leftmost_node.left_child == leftmost_node: <br/>       parent_of_leftmost_node.left_child = leftmost_node.right_child <br/>    else: <br/>       parent_of_leftmost_node.right_child = leftmost_node.right_child 
</pre>
<p>The preceding statement allows us to properly attach the parent of the leftmost node with any child node. Observe how the right-hand side of the equals sign stays unchanged. That is because the in-order successor can only have a right child as its only child.</p>
<p>The <kbd>remove</kbd> operation takes <strong>O</strong>(<em>h</em>), where h is the height of the tree.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Searching the tree</h1>
            

            
                
<p>Since the <kbd>insert</kbd> method organizes data in a specific way, we will follow the same procedure to find the data. In this implementation, we will simply return the data if it was found or <kbd>None</kbd> if the data wasn't found:</p>
<pre>
    def search(self, data): 
</pre>
<p>We need to start searching at the very top, that is, at the root node:</p>
<pre>
        current = self.root_node <br/>        while True: 
</pre>
<p>We may have passed a leaf node, in which case the data doesn't exist in the tree and we return <kbd>None</kbd> to the client code:</p>
<pre>
            if current is None: <br/>                return None 
</pre>
<p>We might also have found the data, in which case we return it:</p>
<pre>
            elif current.data is data: <br/>                return data 
</pre>
<p>As per the rules for how data is stored in the BST, if the data we are searching for is less than that of the current node, we need to go down the tree to the left:</p>
<pre>
            elif current.data &gt; data: <br/>                current = current.left_child 
</pre>
<p>Now we only have one option left: the data we are looking for is greater than the data held in the current node, which means we go down the tree to the right:</p>
<pre>
            else: <br/>                current = current.right_child 
</pre>
<p>Finally, we can write some client code to test how the BST works. We create a tree and insert a few numbers between 1 and 10. Then we search for all the numbers in that range. The ones that exist in the tree get printed:</p>
<pre>
    tree = Tree() <br/>    tree.insert(5) <br/>    tree.insert(2) <br/>    tree.insert(7) <br/>    tree.insert(9) <br/>    tree.insert(1) <br/><br/>    for i in range(1, 10): <br/>        found = tree.search(i) <br/>        print("{}: {}".format(i, found)) 
</pre>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Tree traversal</h1>
            

            
                
<p>Visiting all the nodes in a tree can be done depth first or breadth first. These modes of traversal are not peculiar to only binary search trees but trees in general.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Depth-first traversal</h1>
            

            
                
<p>In this traversal mode, we follow a branch (or edge) to its limit before recoiling upwards to continue traversal. We will be using the recursive approach for the traversal. There are three forms of depth-first traversal, namely <kbd>in-order</kbd>, <kbd>pre-order</kbd>, and <kbd>post-order</kbd>.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">In-order traversal and infix notation</h1>
            

            
                
<p>Most of us are probably used to this way of representing an arithmetic expression, since this is the way we are normally taught in schools. The operator is inserted (infixed) between the operands, as in <kbd>3 + 4</kbd>. When necessary, parentheses can be used to build a more complex expression: <kbd>(4 + 5) * (5 - 3)</kbd>.</p>
<p>In this mode of traversal, you would visit the left sub-tree, the parent node, and finally the right sub-tree.</p>
<p>The recursive function to return an in-order listing of nodes in a tree is as follows:</p>
<pre>
    def inorder(self, root_node): <br/>        current = root_node <br/>        if current is None: <br/>            return <br/>        self.inorder(current.left_child) <br/>        print(current.data) <br/>        self.inorder(current.right_child) 
</pre>
<p>We visit the node by printing the node and making two recursive calls with <kbd>current.left_child</kbd> and <kbd>current.right_child</kbd>.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Pre-order traversal and prefix notation</h1>
            

            
                
<p>Prefix notation is commonly referred to as Polish notation. Here, the operator comes before its operands, as in <kbd>+ 3 4</kbd>. Since there is no ambiguity of precedence, parentheses are not required: <kbd>* + 4 5 - 5 3</kbd>.</p>
<p>To traverse a tree in pre-order mode, you would visit the node, the left sub-tree, and the right sub-tree node, in that order.</p>
<p>Prefix notation is well known to LISP programmers.</p>
<p>The recursive function for this traversal is as follows:</p>
<pre>
    def preorder(self, root_node): <br/>        current = root_node <br/>        if current is None: <br/>            return <br/>        print(current.data) <br/>        self.preorder(current.left_child) <br/>        self.preorder(current.right_child) 
</pre>
<p>Note the order in which the recursive call is made.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Post-order traversal and postfix notation.</h1>
            

            
                
<p>Postfix or <strong>reverse Polish notation</strong> (<strong>RPN</strong>) places the operator after its operands, as in <kbd>3 4 +</kbd>. As is the case with Polish notation, there is never any confusion over the precedence of operators, so parentheses are never needed: <kbd>4 5 + 5 3 - *</kbd>.</p>
<p>In this mode of traversal, you would visit the left sub-tree, the right sub-tree, and lastly the root node.</p>
<p>The <kbd>post-order</kbd> method is as follows:</p>
<pre>
    def postorder(self, root_node): <br/>        current = root_node <br/>        if current is None: <br/>            return <br/>        self.postorder(current.left_child) <br/>        self.postorder(current.right_child) <br/><br/>        print(current.data) 
</pre>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Breadth-first traversal</h1>
            

            
                
<p>This kind of traversal starts from the root of a tree and visits the node from one level of the tree to the other:</p>
<div><img class="image-border" height="191" src="img/CH_06_10.png" width="344"/></div>
<p>The node at level 1 is node 4. We visit this node by printing out its value. Next, we move to level 2 and visit the nodes on that level, which are nodes 2 and 8. On the last level, level 3, we visit nodes 1, 3, 5, and 10.</p>
<p>The complete output of such a traversal is 4, 2, 8, 1, 3, 5, and 10.</p>
<p>This mode of traversal is made possible by using a queue data structure. Starting with the root node, we push it into a queue. The node at the front of the queue is accessed (dequeued) and either printed and stored for later use. The left node is added to the queue followed by the right node. Since the queue is not empty, we repeat the process.</p>
<p>A dry run of the algorithm will enqueue the root node 4, dequeue, and access, or visit the node. Nodes 2 and 8 are enqueued as they are the left and right nodes respectively. Node 2 is dequeued in order to be visited. Its left and right nodes, 1 and 3, are enqueued. At this point, the node at the front of the queue is 8. We dequeue and visit node 8, after which we enqueue its left and right nodes. So the process continues until the queue is empty.</p>
<p>The algorithm is as follows:</p>
<pre>
    from collections import deque <br/>    class Tree: <br/>        def breadth_first_traversal(self): <br/>            list_of_nodes = [] <br/>            traversal_queue = deque([self.root_node]) 
</pre>
<p>We enqueue the root node and keep a list of the visited nodes in the <kbd>list_of_nodes</kbd> list. The <kbd>dequeue</kbd> class is used to maintain a queue:</p>
<pre>
        while len(traversal_queue) &gt; 0: <br/>            node = traversal_queue.popleft() <br/>            list_of_nodes.append(node.data) 


            if node.left_child: <br/>                traversal_queue.append(node.left_child) <br/><br/>            if node.right_child: <br/>                traversal_queue.append(node.right_child) <br/>        return list_of_nodes 
</pre>
<p>If the number of elements in the <kbd>traversal_queue</kbd> is greater than zero, the body of the loop is executed. The node at the front of the queue is popped off and appended to the <kbd>list_of_nodes</kbd> list. The first <kbd>if</kbd> statement will <kbd>enqueue</kbd> the left child node of the <kbd>node</kbd> provided a left node exists. The second <kbd>if</kbd> statement does the same for the right child node.</p>
<p>The <kbd>list_of_nodes</kbd> is returned in the last statement.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Benefits of a binary search tree</h1>
            

            
                
<p>We shall now briefly look at what makes a BST a better idea than using a list for data that needs to be searched. Let us assume that we have the following dataset: 5, 3, 7, 1, 4, 6, and 9. Using a list, the worst-case scenario would require you to search through the entire list of seven elements before finding the search term:</p>
<div><img class="image-border" height="54" src="img/image_06_007.jpg" width="364"/></div>
<p>Searching for 9 requires six jumps.</p>
<p>With a tree, the worst-case scenario is three comparisons:</p>
<div><img class="image-border" height="131" src="img/image_06_008.jpg" width="268"/></div>
<p>Searching for 9 requires two steps.</p>
<p>Notice, however, that if you insert the elements into the tree in the order 1, 2, 3, 5, 6, 7, 9, then the tree would not be more efficient than the list. We would have to balance the tree first:</p>
<div><img class="image-border" height="258" src="img/image_06_009.jpg" width="274"/></div>
<p>So not only is it important to use a BST but choosing a self-balancing tree helps to improve the <kbd>search</kbd> operation.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Expression trees</h1>
            

            
                
<p>The tree structure is also used to parse arithmetic and Boolean expressions. For example, the expression tree for <kbd>3 + 4</kbd> would look as follows:</p>
<div><img class="image-border" height="72" src="img/image_06_010.jpg" width="98"/></div>
<p>For a slightly more complex expression, <kbd>(4 + 5) * (5-3)</kbd>, we would get the following:</p>
<div><img class="image-border" height="153" src="img/image_06_011.jpg" width="255"/></div>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Parsing a reverse Polish expression</h1>
            

            
                
<p>Now we are going to build up a tree for an expression written in postfix notation. Then we will calculate the result. We will use a simple tree implementation. To keep it really simple, since we are going to grow the tree by merging smaller trees, we only need a tree node implementation:</p>
<pre>
    class TreeNode: <br/>        def __init__(self, data=None): <br/>            self.data = data <br/>            self.right = None <br/>            self.left = None 
</pre>
<p>In order to build the tree, we are going to enlist the help of a stack. You will see why soon. But for the time being, let us just create an arithmetic expression and set up our stack:</p>
<pre>
        expr = "4 5 + 5 3 - *".split() <br/>        stack = Stack() 
</pre>
<p>Since Python is a language that tries hard to have sensible defaults, its <kbd>split()</kbd> method splits on whitespace by default. (If you think about it, this is most likely what you would expect as well.) The result is going to be that expr is a list with the values 4, 5, +, 5, 3, - and *.</p>
<p>Each element of the expr list is going to be either an operator or an operand. If we get an operand then we embed it in a tree node and push it onto the stack. If we get an operator, on the other hand, then we embed the operator into a tree node and pop its two operands into the node's left and right children. Here we have to take care to ensure that the first pop goes into the right child, otherwise we will have problems with subtraction and division.</p>
<p>Here is the code to build the tree:</p>
<pre>
    for term in expr: <br/>        if term in "+-*/": <br/>            node = TreeNode(term) <br/>            node.right = stack.pop() <br/>            node.left = stack.pop() <br/>        else: <br/>            node = TreeNode(int(term)) <br/>        stack.push(node) 
</pre>
<p>Notice that we perform a conversion from string to int in the case of an operand. You could use <kbd>float()</kbd> instead, if you wanted to support floating point operands.</p>
<p>At the end of this operation, we should have one single element in the stack, and that holds the full tree.</p>
<p>We may now want to be able to evaluate the expression. We build the following little function to help us:</p>
<pre>
    def calc(node): <br/>        if node.data is "+": <br/>            return calc(node.left) + calc(node.right) <br/>        elif node.data is "-": <br/>            return calc(node.left) - calc(node.right) <br/>        elif node.data is "*": <br/>            return calc(node.left) * calc(node.right) <br/>        elif node.data is "/": <br/>            return calc(node.left) / calc(node.right) <br/>        else: <br/>            return node.data 
</pre>
<p>This function is very simple. We pass in a node. If the node contains an operand, then we simply return that value. If we get an operator, however, then we perform the operation that the operator represents, on the node's two children. However, since one or more of the children could also contain either operators or operands, we call the <kbd>calc()</kbd> function recursively on the two child nodes (bearing in mind that all the children of every node are also nodes).</p>
<p>Now we just need to pop the root node off the stack and pass it into the <kbd>calc()</kbd> function and we should have the result of the calculation:</p>
<pre>
    root = stack.pop() <br/>    result = calc(root) <br/>    print(result) 
</pre>
<p>Running this program should yield the result 18, which is the result of <kbd>(4 + 5) * (5 - 3)</kbd>.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Balancing trees</h1>
            

            
                
<p>Earlier, we mentioned that if nodes are inserted into the tree in a sequential order, then the tree behaves more or less like a list, that is, each node has exactly one child node. We normally would like to reduce the height of the tree as much as possible, by filling up each row in the tree. This process is called balancing the tree.</p>
<p>There are a number of types of self-balancing trees, such as red-black trees, AA trees, and scapegoat trees. These balance the tree during each operation that modifies the tree, such as insert or delete.</p>
<p>There are also external algorithms that balance a tree. The benefit of these is that you wouldn't need to balance the tree on every single operation, but could rather leave balancing to the point when you need it.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Heaps</h1>
            

            
                
<p>At this point, we shall briefly introduce the heap data structure. A heap is a specialization of a tree in which the nodes are ordered in a specific way. Heaps are divided into max and min heaps. In a max heap, each parent node must always be greater than or equal to its children. It follows that the root node must be the greatest value in the tree. A min heap is the opposite. Each parent node must be less than or equal to both its children. As a consequence, the root node holds the lowest value.</p>
<p>Heaps are used for a number of different things. For one, they are used to implement priority queues. There is also a very efficient sorting algorithm, called heap sort, that uses heaps. We are going to study these in depth in subsequent chapters.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Summary</h1>
            

            
                
<p>In this chapter, we have looked at tree structures and some example uses of them. We studied binary trees in particular, which is a subtype of trees where each node has at most two children.</p>
<p>We looked at how a binary tree can be used as a searchable data structure with a BST. We saw that, in most cases, finding data in a BST is faster than in a linked list, although this is not the case if the data is inserted sequentially, unless of course the tree is balanced.</p>
<p>The breadth- and depth-first search traversal modes were also implemented using queue recursion.</p>
<p>We also looked at how a binary tree can be used to represent an arithmetic or a Boolean expression. We built up an expression tree to represent an arithmetic expression. We showed how to use a stack to parse an expression written in RPN, build up the expression tree, and finally traverse it to get the result of the arithmetic expression.</p>
<p>Finally, we mentioned heaps, a specialization of a tree structure. We have tried to at least lay down the theoretical foundation for the heap in this chapter, so that we can go on to implement heaps for different purposes in upcoming chapters.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    </body></html>