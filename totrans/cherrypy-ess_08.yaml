- en: Chapter 8. Ajax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we built the photoblog web interface through the use
    of HTML, DOM, and JavaScript. We have shown how a web page could be modified dynamically
    from the browser itself. However, we have not detailed the nature of this dynamism,
    neither have we explained how to retrieve data from a web application server without
    refreshing the entire web page itself. The one who can do this for us is Ajax.
    So, the goal of this chapter is to introduce the concept of Ajax.
  prefs: []
  type: TYPE_NORMAL
- en: Rise of the Rich-Client Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until the year 2005, the most common pattern found in web applications was one
    HTTP request per page. In other words, navigation through a website was done through
    links that triggered the retrieval through an HTTP request of the linked resource.
    This pattern is still widely used but competes now with the pattern where we have
    several HTTP requests per page. The distinction might look anecdotal, but by allowing
    the browser to issue several HTTP requests to fetch more data from one web page
    at one given URI, it offers a different yet powerful path to the web developer
    desirous of creating a more interactive application.
  prefs: []
  type: TYPE_NORMAL
- en: For example, let's imagine a web application that shows a list of results by
    paging them instead of displaying them all at once. In traditional web applications,
    each time the end user went forward or backward, a new HTTP request would be sent
    to the server for the entire page to be reconstructed. In that case, the URL displayed
    in the browser address bar would also change, based on the current page viewed.
    On the other hand, imagine that instead of fetching the entire web page, only
    the new set of data to be displayed was fetched. We would still have one request
    made each time the customer moves from his or her current position, but it would
    be done without the replacement of the entire web page. The end user would have
    a lesser feeling of being governed by web pages, which could improve the overall
    experience of navigating through the set of data as well as reducing the bandwidth
    consumption.
  prefs: []
  type: TYPE_NORMAL
- en: This simplistic example is in fact a seed for all kind of enhancements for modern
    web applications that have led to the rise of rich-client applications.
  prefs: []
  type: TYPE_NORMAL
- en: Ajax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the year 2005, Jesse James Garrett ([http://www.adaptivepath.com/publications/essays/archives/000385.php](http://www.adaptivepath.com/publications/essays/archives/000385.php))
    coined the term Ajax to designate a set of technology that he was about to present
    to one of his clients. It has since then left its original author's hands and
    is today the referenced term for what we introduced in the previous section about
    making web applications look more dynamic and interactive.
  prefs: []
  type: TYPE_NORMAL
- en: '**Ajax** stands for **Asynchronous JavaScript and XML**, and covers a set of
    technologies applied to a web environment. Let''s review each part of the acronym:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Asynchronous:** In a client-server environment, there are two grand principles;
    either your operation is running synchronously to the rest of the program or not.
    If it is, then the program pauses until the operation terminates, and if it is
    not, then the operation returns immediately and lets the program continue. Once
    the operation is finished, it informs its main program through a callback function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the context of a web application, the whole purpose of Ajax is to bring more
    interactivity to the end user, which is why it broadly relies on asynchronous
    operations. Now, nothing prevents a developer from running specific operations
    synchronously to the rest of the application. This, however, can lead to the freezing
    of the entire browser, if the operation is not almost instantaneous.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**JavaScript:** In a traditional approach where each action from the end user
    leads to a new HTTP request, this request is generated by the browser itself,
    which also consumes the HTTP response. With Ajax, the HTTP request is handled
    by a JavaScript call to an underlying HTTP API that we will review later on. Therefore,
    the web developer is in charge of creating a valid request, being able to handle
    its response, and eventually updating the end-user view of the web page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**XML:** The main purpose of Ajax is to perform actions on the Document Object
    Model to either insert new content or remove parts of a web page from the end-user
    view. Ajax is based on the exchange of XML documents through HTTP. Those documents
    contain all the information and data necessary to perform the requested operation.
    Therefore, other formats of information can be used and XML is not compulsory.
    The most widespread format is JSON, which we will introduce later on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ajax—Advantages and Drawbacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At first sight, the concepts carried by Ajax seem really promising and they
    certainly are. Nonetheless, the technologies required can lead to unexpected issues.
    First of all, let''s review some of the advantages of Ajax:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Server and bandwidth usage reduction: In a traditional web application, where
    each page is requested in its entirety from the server, there is a resource waste
    from both the server and the network. This is because the server may have to recompute
    the page and more data is carried on the wire. In both cases, however, the sensible
    use of caching would decrease that effect.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When using Ajax principles, only the needed data is fetched from the server.
    In that case, the server and intermediates could cache it. In any case, Ajax can
    reduce the load occurring on servers, as part of the processing is moved to the
    client itself.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'General improvement of the end-user experience: Since the web page view is
    updated locally on the client side following the user''s actions, he or she may
    feel that the web application is more interactive and more responsive.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Separation of concerns enforced: Since the web developer is in charge of the
    construction of the HTTP request to be sent, he or she can decide to actually
    call different web services based on the current context of the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For instance, in a traditional web application an HTML form would be posted
    to the web server, which would return an HTML page. Ajax lets the developer decide
    which service will handle the user input. Therefore, the developer can call an
    Atom Publishing Protocol service that would return an Atom document that the developer
    would then handle manually. Ajax web applications can distribute their tasks among
    different specific services.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now let''s review the drawbacks associated with Ajax:'
  prefs: []
  type: TYPE_NORMAL
- en: One of the biggest issues for web applications, based on the principles of Ajax,
    is that they by-pass the browser machinery and, therefore, the standard behavior
    of the backward and forward buttons is not assured anymore. In a more general
    way, Ajax breaks an end-user habit that has become the standard way of navigating
    the Web. For instance, the page-to-page pattern is a clear sign that the end-user
    action has triggered an operation resulting in a modification of the current state
    of the web page, whereas a web application that will modify only a part of the
    viewed page can confuse some users.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ajax sometimes prevents users from bookmarking the pages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some have raised concerns about the possible security holes brought by Ajax
    and JavaScript. However, those claims are usually made against applications that
    had a weak point, not because of JavaScript but because of the way they have designed
    a functionality. In any case, you should always weigh the potential security risks
    for your own requirements when using Ajax. For instance, never trust client-side
    form validation only; make sure you validate any incoming data on the server side
    and keep client-side validation to minimize round-trip HTTP exchanges.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generally, the pitfall regarding the use of Ajax in a web application is its
    overuse. Although this is a fairly subjective topic, the abuse of Ajax is frowned
    upon when it does not improve the end-user experience as compared to a more traditional
    approach. Our photoblog application will use Ajax fairly heavily.
  prefs: []
  type: TYPE_NORMAL
- en: 'Behind the Scene: XMLHttpRequest'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we have seen, Ajax is based on the idea of sending HTTP requests using JavaScript;
    more specifically Ajax relies on the `XMLHttpRequest` object and its API to perform
    those operations. This object was first designed and implemented by Microsoft
    engineers as an ActiveX control available to Outlook Express and Internet Explorer,
    but it was not heavily used before the rise of Ajax and rich web applications.
    XMLHttpRequest is now part of every modern browser and is so widely used that
    the W3C has notably set up a working group to specify the boundaries of this object
    to provide the minimum interoperability requirements across implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s review the XMLHttpRequest interface specified by W3C, as it provides
    the most common attributes and functions implemented by browser vendors:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Attributes | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `readyState` | Read-only attribute carrying the current status of the object:`0:`
    Uninitialized`1:` Open`2:` Sent`3:` Receiving`4:` Loaded |'
  prefs: []
  type: TYPE_TB
- en: '| `onreadystatechange` | An EventListener is called when the `readyState` attribute
    changes. |'
  prefs: []
  type: TYPE_TB
- en: '| `responseText` | Contains the received bytes so far from the server as a
    string |'
  prefs: []
  type: TYPE_TB
- en: '| `responseXML` | If the `content-type` of the response was one associated
    with XML (`text/xml, application/xml`, or `+xml)`, this contains an instance of
    the received document. |'
  prefs: []
  type: TYPE_TB
- en: '| `status` | The HTTP response code |'
  prefs: []
  type: TYPE_TB
- en: '| `statusText` | The HTTP response text |'
  prefs: []
  type: TYPE_TB
- en: '| Methods | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `abort()` | Cancels the underlying network connection with the server. |'
  prefs: []
  type: TYPE_TB
- en: '| `getAllReponseHeaders()` | Returns a string of all HTTP response headers
    separated by a new line. |'
  prefs: []
  type: TYPE_TB
- en: '| `getResponseHeader(header)` | Returns the value of the header if present
    in the response. An empty string otherwise. |'
  prefs: []
  type: TYPE_TB
- en: '| `setRequestHeader(header, value)` | Sets an HTTP header for the underlying
    request. |'
  prefs: []
  type: TYPE_TB
- en: '| `open(method, uri, async, user, password)` | Initializes the object:`method:`
    the HTTP method to be used for the request`uri:` the URI on which the request
    is applied`async:` a Boolean indicating whether this request must be synchronous
    with the rest of the program or not`username` and `password:` provide the credentials
    to access the resource |'
  prefs: []
  type: TYPE_TB
- en: '| `send(data)` | Realizes the HTTP connection and sets the request body with
    data if provided. |'
  prefs: []
  type: TYPE_TB
- en: The API is fairly straightforward and simple. Let's go through various examples
    using the MochiKit Async module.
  prefs: []
  type: TYPE_NORMAL
- en: Performing a GET Request
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `GET` request is as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will see what we have actually done:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. As each browser has its own API for the developer who wishes to instantiate
    an XMLHttpRequest, Mochikit provides the `getXMLHttpRequest()` function that will
    return the correct object by checking which browser the end user is using.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 2\. We then initialize the object with required values. In this case, we want
    to perform a `GET` request against the "/" URI of the current host in an asynchronous
    fashion.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 3\. Then we inform the server that it must close the connection as soon as it
    finishes with our request and has sent us its response.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 4\. Then we use the Mochikit `sendXMLHttpRequest()` function that returns a
    deferred object. This object offers the developer a clean API to handle the different
    states that an `XMLHttpRequest` object can take during the processing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. We add a callback that will be applied if the response status code indicates
    a success (typically in the 2xx and 3xx ranges of HTTP).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: b. We also associate an error callback that will be applied when the response
    indicates an error (typically in the 4xx and 5xx ranges of HTTP).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 5\. The `data` parameter that each callback must take is the entity body included
    in the response, which can then be processed by the callback.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Performing a Content-Negotiated GET Request
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This `GET` request is as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this request, we inform the server that we are willing to accept content
    that is represented using the Atom format and which uses the French language.
    A server that is unable to handle this request could respond with `406 Not Acceptable`,
    and therefore the error callback would be applied.
  prefs: []
  type: TYPE_NORMAL
- en: Performing a POST Request
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `POST` request is as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will see what we have actually done:'
  prefs: []
  type: TYPE_NORMAL
- en: '1\. We post some data in the form of an encoded query string. The `queryString(data)`
    function takes an associative array of key values and returns an encoded string
    of the form: `key1=value1?key2=value2`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 2\. We initialize the `XMLHttpRequest` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '3\. We specify the content-type of our request entity body: `application/x-www-form-urlencoded`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 4\. Then we request a deferred object from `sendXMLHttpRequest`, but as you
    can see we also pass the data we wish to send.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's POST an XML Document
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This is how we will do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Performing PUT, HEAD, or DELETE Requests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unlike HTML forms, XMLHttpRequest is not limited in terms of supported HTTP
    methods that it recognizes. In fact, XMLHttpRequest does not pay attention to
    the method that you use and does not interpret it. The method you use is sent
    as it is to the server. This is extremely important in web services based on REST
    or the Atom Publishing Protocol, as we have seen in the previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Cookies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Cookies are sent along with the request, automatically by the user agent hosting
    XMLHttpRequest; therefore, there is no specific action for the developer to take.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication using Digest or Basic Schemes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `open()` method of XMLHttpRequest can take `username` and `password` parameters
    to be sent along with the request. The authentication schemes supported by XMLHttpRequest
    are defined in RFC 2617, namely *basic* and *digest*. These two schemes are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Basic scheme: The basic scheme is simply the transfer of the username and password
    encoded using the base64 algorithm. The issue with this is that, if a third-party
    fetches the encoded value, nothing can be done to prevent it from being decoded.
    This is why the basic is often referred as sending the password in clear text,
    because the applied encoding can be decoded very easily. It is therefore not a
    secure authentication scheme unless it is used on a secured protocol such as HTTPS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Digest scheme: The digest scheme, on the other hand, does not send the password
    as it is across the wire. Instead, both the parties apply the same algorithm using
    the password and other seeds to compute a digest value of those. The server also
    sends the seed value on the first request to *tag* that request. The client sends
    back the computation of the digest algorithm to the server, which compares it
    with its own computation. If the two match, the request is allowed. This scheme
    is safer than the basic one, as the password is actually never sent onto the wire
    in a form that can be decrypted in a reasonable amount of time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By default, when using those schemes, a browser would open a pop-up window
    asking for a username and a password. In the context of request issued by a JavaScript
    call to XMLHttpRequest, it is possible to avoid that pop up by providing the user
    credentials directly to the `open()` method. Obviously, it is out of question
    to hardcode them into the JavaScript code. Instead, it is fairly easy to integrate
    an HTML form into the web application and to dynamically pass the input values
    to the JavaScript call, as the following example demonstrates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The CherryPy script that would serve the previous page could look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'When you access [http://localhost:8080/](http://localhost:8080/), you should
    get the following page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Authentication using Digest or Basic Schemes](img/1848_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you enter the username `test` and password `test`, you will get the following
    view on your screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Authentication using Digest or Basic Schemes](img/1848_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'On the other hand, if you provide wrong values, you would get a screen like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Authentication using Digest or Basic Schemes](img/1848_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Unfortunately, the browser receives the message from the server about the authentication
    failure with `401 HTTP error code` and handles it itself. As of today, there is
    no cross-browser way to avoid that issue so that the pop up does not appear. If
    you hit the **Cancel** button of the pop up, the browser then goes back to your
    JavaScript code and the error callback is applied.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, since you cannot access the underlying session through the `XMLHttpRequest`
    object as it is handled by the browser, you cannot force a logout by suppressing
    the session credentials. The user has to close down the browser to disconnect
    from the application.
  prefs: []
  type: TYPE_NORMAL
- en: Consequently, although XMLHttpRequest allows you to provide a fancier way to
    enable basic and digest authentication in your web application, there are still
    some pitfalls that need to be acknowledged.
  prefs: []
  type: TYPE_NORMAL
- en: JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have already seen in this chapter, in spite of carrying XML in its name,
    Ajax does not prevent other formats being carried. For instance, one extremely
    common format that you will see is **JSON** (**JavaScript Object Notation**).
  prefs: []
  type: TYPE_NORMAL
- en: In a nutshell, JSON is a way to carry serialized JavaScript objects so that
    a JavaScript application can evaluate them and transform them into JavaScript
    objects that the application can manipulate.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, when the user requests the server for an `album` object formatted
    with the JSON format, the server would return the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We then use the `evalJSONRequest()` function from Mochikit, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the data is a JavaScript associative array and the description field can
    be accessed via:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: JSON is widely deployed because it is simple, easy to use, and efficient to
    construct or evaluate. It does support all the common basic types such as numbers,
    Booleans, arrays, strings, or the null object. More complex objects are translated
    into associative arrays, where object attribute names serve as keys to access
    their associated value.
  prefs: []
  type: TYPE_NORMAL
- en: The photoblog application will mainly use the JSON format in its operations.
  prefs: []
  type: TYPE_NORMAL
- en: When your CherryPy application relies heavily on JSON, it may be interesting
    to write a tool to automatically perform the JSON serialization and deserialization.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We create two tools using the simple JSON module to perform the conversion.
    The first one deserializes the request body from JSON only on POST and PUT requests
    that have the `application/json` content-type set. The tool loads the request
    body and transforms it into a dictionary, which is thereafter injected in the
    `params` attribute of the `cherrypy.request` object allowing CherryPy page handlers
    to expect keys of the JSON dictionary as regular parameters, as you can see in
    the process page handler. Note that we must encode those keys into Python strings
    from Unicode because CherryPy page handlers expect strings.
  prefs: []
  type: TYPE_NORMAL
- en: The second tool takes the dictionary returned by a page handler and serializes
    it into JSON.
  prefs: []
  type: TYPE_NORMAL
- en: Applying Ajax to our Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our photoblog application will use Ajax fairly extensively, and to explain this
    we will review how to handle the albums of the photoblog.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the Required Namespaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our first step will be to define the JavaScript namespaces that will allow us
    to reuse common function names in different contexts while avoiding name collision.
    Using the term namespace is slightly unexpected because JavaScript does not have
    that notion per se, but it is possible to emulate this feature in a number of
    ways. In the case of this application, we will be using JavaScript inheritance
    that is simple enough to implement our requirement.
  prefs: []
  type: TYPE_NORMAL
- en: 'The two namespaces that the photoblog application will use are: `ui` and `services`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `ui` namespace will cover the different interactions with the end user,
    while the `services` namespace will take care of exchanging data with the server.
    The `ui` namespace classes and functions will therefore call the `services` ones
    to perform operations requested by the end user.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement these two namespaces, we will simply define two empty JavaScript
    functions as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Implementing Namespaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We now have our functions and we can add attributes to them. Here we have the
    album class declaration that will handle all aspects of the album entity from
    a client-side point of view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here, we first create a regular JavaScript function that is used as the constructor
    of an `album` class. We also declare a few attributes attached to that object
    via the JavaScript keyword `this`.
  prefs: []
  type: TYPE_NORMAL
- en: Then we add an `albums` instance as an attribute of the `ui` function object
    prototype and we finally create the unique instance of the `ui` class that we
    will use throughout the life of the application within the session of the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'From now on we can use the `albums` instance to call its `edit` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We then define similarly the `album` class within the `services` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Adding Methods to the Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first method that we will add to our classes will be the one that toggles
    the visibility state of our albums container. This container will display information
    about existing albums and will fade in or fade out when the user clicks on the
    associated link. Let''s see how to add methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This method first toggles the visibility of the content panel that contains
    the current photograph. Then if the toggle means to open the `albums` panel, we
    set its visibility to `true` and we call the `forward` method. Otherwise, we set
    the visibility to `false` and we delete any elements attached to that container
    so that they don''t waste memory. Finally, we request Mochikit to change the visibility
    state of the `albums` panel. We then connect that method to the `onclick` signal
    of the associated link as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `forward` method is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The method first defines the range of albums we will need to fetch from the
    server. Then we call the `fetch_range()` method of the `services.albums` object,
    and we finally set the new starting position for the next call to that method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now review the `services.albums` object itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: You may notice that this method takes an extra parameter named `src`, which
    is the calling object so that our callbacks can apply methods on that object when
    receiving a response from the server.
  prefs: []
  type: TYPE_NORMAL
- en: The requested URI `albumsBaseUri.concat(start, "-", end). albumsBaseUri`, is
    a global string variable containing the base URI for performing requests against
    collections of albums.
  prefs: []
  type: TYPE_NORMAL
- en: We specify that we would prefer the server to send us back a JSON content, as
    this is what we will be using to populate the retrieved albums.
  prefs: []
  type: TYPE_NORMAL
- en: 'The request issued would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'And its response would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The returned content would be then evaluated by the MochiKit function `evalJSONRequest()`
    to return an instance of JavaScript objects; in this case an array of associative
    arrays. Once we have received and evaluated the content, we call the `populate()`
    method of the `ui.album` class to display the retrieved albums. This method is
    defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Method to Create a New Album
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we can display albums, we will review how to create a new album. To
    do so, we first need a form to gather the user input. Let's explain the `ui.albums.blank()`
    method that is in charge of displaying the form by dynamically inserting it into
    the DOM tree.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The creation of the form block requires further explanation. In order to provide
    a fancier panel carrying the form, we use the technique deployed in scripts such
    as *Lightbox* or *Thickbox*. Both rely on the overlay capabilities of CSS applied
    to the DOM to display elements on top of others. Overlays allow displaying elements
    not in a sequential fashion but as a pile. This feature associated with a sensible
    use of HTML blocks as `DIVs` and appropriate colors can provide an attractive
    way to display the content, as the following screenshot demonstrates:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Method to Create a New Album](img/1848_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you do not fill the required fields and submit the form, you will end up
    with a screen as displayed in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Method to Create a New Album](img/1848_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you fill the required fields and submit the form, you would get a screen
    as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Method to Create a New Album](img/1848_08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In order to avoid the situation where the user tries to re-submit the form,
    we remove the **Submit** link and the user can now safely close this screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The HTTP exchange will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note that the response gives us the URI to directly access the newly created
    album.
  prefs: []
  type: TYPE_NORMAL
- en: 'The method to handle the previous HTTP exchange is `services.album.create()`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `data` parameter is a JavaScript associative array of the form fields.
    The `src` parameter is the `ui.albums` instance, which is extended with the following
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Method to Update an Existing Album
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This follows the same principles as we have seen in the previous section, except
    that we provide an `album` object to fill the form automatically with its values.
  prefs: []
  type: TYPE_NORMAL
- en: Method to Delete an Existing Album
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally, we need a method to delete an album:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The HTTP exchange would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We have explained the basic methods to manipulate albums of the photoblog application.
    The same principles will be applied for the other entities of the application:
    film and photo.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has introduced you to Ajax and more generally to the basics of
    client-side programming using JavaScript. The possibilities are almost endless
    and the near future should see extremely interesting and powerful web applications
    that will slowly take the place of their rich-client counterparts.
  prefs: []
  type: TYPE_NORMAL
