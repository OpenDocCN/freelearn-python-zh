<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch06" class="calibre1"/>Chapter 6. Handling Return Data</h1></div></div></div><p class="calibre8">When the Salt Master issues a command to a Minion and the task completes successfully, there will always be return data. The <code class="email">salt</code> command normally listens for return data, and if it is sent back in time, it will be displayed using an outputter. But whether or not that happens, the Minion will always send return data back to the Master, and any other destinations configured as returners.</p><p class="calibre8">This chapter is all about handling that return data, using both returner and outputter modules. We'll talk about:</p><div><ul class="itemizedlist"><li class="listitem">How data is returned to the Master</li><li class="listitem">Writing returner modules</li><li class="listitem">Extending returners to be used as external job caches</li><li class="listitem">Troubleshooting returners</li><li class="listitem">Writing outputter modules</li><li class="listitem">Troubleshooting outputters</li></ul></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch06lvl1sec31" class="calibre1"/>Returning data to external destinations</h1></div></div></div><p class="calibre8">The most<a id="id170" class="calibre1"/> important type of module to handle return data is called a returner. When the Master publishes a task (called a job) to a target, it assigns a job ID (or JID) to it. When a Minion finishes that job, it sends the resulting data back to the Master, along with the JID that is associated with it.</p></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec32" class="calibre1"/>Returning data to the master</h1></div></div></div><p class="calibre8">Salt's <a id="id171" class="calibre1"/>architecture is based on the publish-subscribe pattern, known colloquially as pub/sub. In this design, one or more clients subscribe to a message queue. When a message is published to the queue, any current subscribers receive a copy, which they usually process in some way.</p><p class="calibre8">Salt in fact makes use of two message queues, both of which are managed by the Master. The first is used by the Master to publish commands to its Minions. Each Minion can see the messages published to this queue, but they will only react to them if the Minions are included in the target. A <a id="id172" class="calibre1"/>message targeted to <code class="email">'*'</code> will be processed by all Minions that are connected, whereas one targeted to <code class="email">192.168.0.0/16</code> using the <code class="email">-s</code> command-line option will only be processed by Minions whose IP address starts with <code class="email">192.168</code>.</p><p class="calibre8">The second message queue is also hosted by the Master, but messages are published to it from Minions, and the Master itself is the subscriber. These messages are normally stored in the Master's job cache. Returners can be configured to send these messages to other destinations, and some returners can also use those destinations as the job cache itself. If the <code class="email">salt</code> command is still listening when those messages are received, then it will also send the data to an outputter.</p></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec33" class="calibre1"/>Listening to event data</h1></div></div></div><p class="calibre8">Every time <a id="id173" class="calibre1"/>a message is published to the queue, an event is also fired along Salt's event bus. You can use the <code class="email">state.event</code> runner to listen to the event bus and display those messages in real time. </p><p class="calibre8">Make sure you have the <code class="email">salt-master</code> service running, and the <code class="email">salt-minion</code> service on at least one machine connected to it. On the Master, run the following command:</p><div><pre class="programlisting">
<strong class="calibre2"># salt-run state.event</strong>
</pre></div><p class="calibre8">In another terminal, issue a command to one or more Minions:</p><div><pre class="programlisting">
<strong class="calibre2"># salt '*' test.ping</strong>
</pre></div><p class="calibre8">In the terminal that is running the event listener, you will see the job go out to the Minions:</p><div><pre class="programlisting">Event fired at Sun Dec 20 12:04:15 2015
*************************
Tag: 20151220120415357444
Data:
{'_stamp': '2015-12-20T19:04:15.387417',
 'minions': ['trotter',
             'achatz']}</pre></div><p class="calibre8">The information contained in this event is no more than a timestamp indicating when the job was created, and a list of Minions that the specified target (in our example, all of them) are expected to execute the job and return data from it.</p><p class="calibre8">This is a very small task, so almost immediately you should start seeing return data show up from Minions. Because each Minion responds individually, you will see one entry per Minion:</p><div><pre class="programlisting">Event fired at Sun Dec 20 12:04:15 2015
*************************
Tag: salt/job/20151220120415357444/ret/dufresne
Data:
{'_stamp': '2015-12-20T19:04:15.618340',
 'cmd': '_return',
 'fun': 'test.ping',
 'fun_args': [],
 'id': 'dufresne',
 'jid': '20151220120415357444',
 'retcode': 0,
 'return': True,
 'success': True}</pre></div><p class="calibre8">Take note <a id="id174" class="calibre1"/>of the tags used for each event. The event that was created when the Master created the job has a tag that contains just the JID. Each return event contains a tag that is namespaced with <code class="email">salt/job/&lt;JID&gt;/ret/&lt;Minion ID&gt;</code>.</p><p class="calibre8">After a few seconds, the salt command will also return, and notify you which Minions did and did not finish the job that was assigned to them:</p><div><pre class="programlisting">
<strong class="calibre2"># salt '*' test.ping</strong>
<strong class="calibre2">achatz:</strong>
<strong class="calibre2">    True</strong>
<strong class="calibre2">trotter:</strong>
<strong class="calibre2">    Minion did not return. [Not connected]</strong>
</pre></div><p class="calibre8">In our case, <code class="email">achatz</code> was active, and able to return <code class="email">True</code> as requested. Unfortunately, <code class="email">trotter</code> isn't around anymore, and so wasn't able to do what we need.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch06lvl2sec54" class="calibre1"/>When returners listen to Minions</h2></div></div></div><p class="calibre8">Each time<a id="id175" class="calibre1"/> the Master receives a response from a Minion, it will call out to a returner. If a job targets, say, 400 Minions, then you should expect the returner to be executed 400 times, one for each Minion.</p><p class="calibre8">This is not normally a problem. If a returner connects to a database, then that database is likely to be able to handle 400 responses very quickly. However, if you create a returner that sends messages to humans, such as the SMTP returner that ships with Salt, then you can expect 400 individual e-mails to be sent; one per Minion.</p><p class="calibre8">There is one more thing to keep in mind: returners were originally designed to be executed on Minions. The idea behind this was to offload the work to Minions so that in a large environment, a Master wouldn't be required to handle all of the work necessary to, say, connect to a database once per Minion per job.</p><p class="calibre8">Returners can now be run either by a Master or by a Minion, and when writing your own returners, you should expect either to be a possibility. We will discuss the configuration for this later in the chapter, when we talk about job caches.</p><p class="calibre8">Let's go ahead and see an example of this in action. Connect to one of your Minions and stop the <code class="email">salt-minion</code> service. Then start it running in the foreground, using the <code class="email">info</code> log level:</p><div><pre class="programlisting">
<strong class="calibre2"># salt-minion --log-level info</strong>
</pre></div><p class="calibre8">Then connect to the Master and issue a job directly to it:</p><div><pre class="programlisting">
<strong class="calibre2"># salt dufresne test.ping</strong>
<strong class="calibre2">dufresne:</strong>
<strong class="calibre2">    True</strong>
</pre></div><p class="calibre8">Switch back to<a id="id176" class="calibre1"/> the Minion, and you will see some information about the job:</p><div><pre class="programlisting">[INFO    ] User sudo_techhat Executing command test.ping with jid 20151220124647074029
[INFO    ] Starting a new job with PID 25016
[INFO    ] Returning information for job: 20151220124647074029</pre></div><p class="calibre8">Now issue the command again, but with the <code class="email">--return</code> flag set to <code class="email">local</code>. This returner will display the return data directly to the local console:</p><div><pre class="programlisting">
<strong class="calibre2"># salt dufresne --return local test.ping</strong>
<strong class="calibre2">dufresne:</strong>
<strong class="calibre2">    True</strong>
</pre></div><p class="calibre8">Switch back to the Minion again to check out the return data:</p><div><pre class="programlisting">[INFO    ] User sudo_techhat Executing command test.ping with jid 20151220124658909637
[INFO    ] Starting a new job with PID 25066
[INFO    ] Returning information for job: 20151220124658909637
{'fun_args': [], 'jid': '20151220124658909637', 'return': True, 'retcode': 0, 'success': True, 'fun': 'test.ping', 'id': 'dufresne'}</pre></div></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec34" class="calibre1"/>Your first returner</h1></div></div></div><p class="calibre8">Go ahead <a id="id177" class="calibre1"/>and open up <code class="email">salt/returners/local.py</code>. There's not much in here, but what we're interested in is the <code class="email">returner()</code> function. It's very, very small:</p><div><pre class="programlisting">def returner(ret):
    '''
    Print the return data to the terminal to verify functionality
    '''
    print(ret)</pre></div><p class="calibre8">In fact, all it does is accept return data as <code class="email">ret</code>, and then print it to the console. It doesn't even attempt any sort of pretty printing; it just dumps it as is.</p><p class="calibre8">This is in fact <a id="id178" class="calibre1"/>the bare minimum that a returner needs: a <code class="email">returner()</code> function that accepts a dictionary, and then does something with it. Let's go ahead and create our own returner, which stores job information locally in JSON format.</p><div><pre class="programlisting">'''
Store return data locally in JSON format

This file should be saved as salt/returners/local_json.py
'''
import json
import salt.utils


def returner(ret):
    '''
    Open new file, and save return data to it in JSON format
    '''
    path = '/tmp/salt-{0}-{1}.json'.format(ret['jid'], ret['id'])
    with salt.utils.fopen(path, 'w') as fp_:
        json.dump(ret, fp_)</pre></div><p class="calibre8">Save this file, on a Minion, and then issue a job to it. It doesn't matter whether or not you restart the <code class="email">salt-minion</code> service; returner modules use <code class="email">LazyLoader</code>. But we'll go ahead and use <code class="email">salt-call</code> anyway:</p><div><pre class="programlisting">
<strong class="calibre2"># salt-call --local --return local_json test.ping</strong>
<strong class="calibre2">local:</strong>
<strong class="calibre2">    True</strong>
</pre></div><p class="calibre8">Go ahead and look inside the <code class="email">/tmp/</code> directory:</p><div><pre class="programlisting">
<strong class="calibre2"># ls -l /tmp/salt*</strong>
<strong class="calibre2">-rw-r--r-- 1 root  root  132 Dec 20 13:03 salt-20151220130309936721-dufresne.json</strong>
</pre></div><p class="calibre8">If you take a look inside that file, you will see return data that looks very similar to what we received from the local returner, except that it is in JSON format:</p><div><pre class="programlisting">
<strong class="calibre2"># cat /tmp/salt-20151220130309936721-dufresne.json</strong>
<strong class="calibre2">{"fun_args": [], "jid": "20151220130309936721", "return": true, "retcode": 0, "success": true, "fun": "test.ping", "id": "dufresne"}</strong>
</pre></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch06lvl2sec55" class="calibre1"/>Using job caches</h2></div></div></div><p class="calibre8">In a way, our<a id="id179" class="calibre1"/> JSON returner is a job cache, because it caches return data. Unfortunately, it doesn't contain any code to do anything with the data once it's saved. By updating the logic and adding a few functions, we can extend the functionality.</p><p class="calibre8">Right now, our returner behaves like little more than a set of log files. Let's change it to behave more like a flat-file database. We'll use the JID as the access key, and format the directory structure based on the dates in the JIDs:</p><div><pre class="programlisting">import json
import os.path
import salt.utils
import salt.syspaths


def _job_path(jid):
    '''
    Return the path for the requested JID
    '''
    return os.path.join(
        salt.syspaths.CACHE_DIR,
        'master',
        'json_cache',
        jid[:4],
        jid[4:6],
        jid[6:],
    )


def returner(ret):
    '''
    Open new file, and save return data to it in JSON format
    '''
    path = os.path.join(_job_path(ret['jid']), ret['id']) + '/'
    __salt__['file.makedirs'](path)
    ret_file = os.path.join(path, 'return.json')
    with salt.utils.fopen(ret_file, 'w') as fp_:
        json.dump(ret, fp_)</pre></div><p class="calibre8">We haven't changed anything except for the directory structure, and how it's handled. The private function <code class="email">_job_path()</code> will standardize the directory structure, and can be used by future functions. We've also made use of <code class="email">salt.syspaths</code> to detect where Salt is configured to keep cache files on this machine. When run against a Minion called <code class="email">dufresne</code>, the path used to store the return data will look like:</p><div><pre class="programlisting">/var/cache/salt/master/json_cache/2015/12/21134608721496/dufresne/return.json</pre></div><p class="calibre8">We'll also <a id="id180" class="calibre1"/>need to store information about the job itself. The <code class="email">return.json</code> file contains some information about the job, but not all of it.</p><p class="calibre8">Let's go ahead and add a function that saves the metadata about the job. This metadata is called the load, and contains a <code class="email">jid</code>, a dictionary called <code class="email">clear_load</code> that contains the bulk of the metadata, and a list called <code class="email">minions</code>, which will contain a list of all of the Minions that were included in the target:</p><div><pre class="programlisting">def save_load(jid, clear_load, minions=None):
    '''
    Save the load to the specified JID
    '''
    path = os.path.join(_job_path(jid)) + '/'
    __salt__['file.makedirs'](path)

    load_file = os.path.join(path, 'load.json')
    with salt.utils.fopen(load_file, 'w') as fp_:
        json.dump(clear_load, fp_)

    if 'tgt' in clear_load:
        if minions is None:
            ckminions = salt.utils.minions.CkMinions(__opts__)
            # Retrieve the minions list
            minions = ckminions.check_minions(
                    clear_load['tgt'],
                    clear_load.get('tgt_type', 'glob')
                    )
        minions_file = os.path.join(path, 'minions.json')
        with salt.utils.fopen(minions_file, 'w') as fp_:
            json.dump(minions, fp_)</pre></div><p class="calibre8">Once again, we generate the path that the data will be written to. The <code class="email">clear_load</code> dictionary will be written to <code class="email">load.json</code> inside that path. The list of Minions is a little trickier, since it may contain an empty list. If it does, we use a class inside <code class="email">salt.utils.minions</code> called <code class="email">CkMinions</code> to generate that list, based on the target that was used for the job. Once we have that list, we write it as <code class="email">minions.json</code>.</p><p class="calibre8">Testing this is also a little trickier, because it requires a job that was generated from the Master in order to generate all of the metadata that is needed. We also need to let the Master know that we're using an external job cache.</p><p class="calibre8">First, edit the master configuration file and add an <code class="email">ext_job_cache</code> line, which is set to <code class="email">local_json</code>:</p><div><pre class="programlisting">ext_job_cache: local_json</pre></div><div><h3 class="title2"><a id="note04" class="calibre1"/>Note</h3><p class="calibre8">
<strong class="calibre2">External job cache versus Master job cache</strong>
</p><p class="calibre8">When the <a id="id181" class="calibre1"/>Master is set to use an external job cache (with the <code class="email">ext_job_cache</code>) setting, the returner code will be executed on the Minion. This will relieve load on the Master since each Minion will be recording its own job data, instead of asking the Master to. However, any credentials necessary to connect to the job cache (for instance, if a database was used) will need to be accessible to the Minion.</p><p class="calibre8">When the Master is set to use a Master job cache (with the <code class="email">master_job_cache</code>) setting, the returner code will be executed on the Master. This will increase the workload on the Master, but will save you from having to make credentials available to Minions.</p></div><p class="calibre8">Once you've <a id="id182" class="calibre1"/>turned on the job cache, let's go ahead and restart both the Master and the Minion, and try things out:</p><div><pre class="programlisting">
<strong class="calibre2"># systemctl restart salt-master</strong>
<strong class="calibre2"># systemctl restart salt-minion</strong>
<strong class="calibre2"># salt dufresne test.ping</strong>
<strong class="calibre2">dufresne:</strong>
<strong class="calibre2">    True</strong>
<strong class="calibre2"># find /var/cache/salt/master/json_cache/</strong>
<strong class="calibre2">/var/cache/salt/master/json_cache/2015/12/</strong>
<strong class="calibre2">/var/cache/salt/master/json_cache/2015/12/21184312454127</strong>
<strong class="calibre2">/var/cache/salt/master/json_cache/2015/12/21184312454127/load.json</strong>
<strong class="calibre2">/var/cache/salt/master/json_cache/2015/12/21184312454127/dufresne</strong>
<strong class="calibre2">/var/cache/salt/master/json_cache/2015/12/21184312454127/dufresne/return.json</strong>
<strong class="calibre2">/var/cache/salt/master/json_cache/2015/12/21184312454127/minions.json</strong>
<strong class="calibre2"># cat /var/cache/salt/master/json_cache/2015/12/21184312454127/load.json</strong>
<strong class="calibre2">{"tgt_type": "glob", "jid": "20151221184312454127", "cmd": "publish", "tgt": "dufresne", "kwargs": {"delimiter": ":", "show_timeout": true, "show_jid": false}, "ret": "local_json", "user": "sudo_larry", "arg": [], "fun": "test.ping"}</strong>
<strong class="calibre2"># cat /var/cache/salt/master/json_cache/2015/12/21184312454127/minions.json</strong>
<strong class="calibre2">["dufresne"]</strong>
</pre></div><p class="calibre8">Now we have the information being saved, but we don't have any way to retrieve it, outside of manually looking inside the files. Let's go ahead and complete our returner with some functions that can read the data.</p><p class="calibre8">First, we need a function that just returns information about the job load:</p><div><pre class="programlisting">def get_load(jid):
    '''
    Return the load data for a specified JID
    '''
    path = os.path.join(_job_path(jid), 'load.json')
    with salt.utils.fopen(path, 'r') as fp_:
        return json.load(fp_)</pre></div><p class="calibre8">We also need a <a id="id183" class="calibre1"/>function that gets the return data from each job. These two functions will be used together by the <code class="email">jobs</code> runner:</p><div><pre class="programlisting">def get_jid(jid):
    '''
    Return the information returned when the specified JID was executed
    '''
    minions_path = os.path.join(_job_path(jid), 'minions.json')
    with salt.utils.fopen(minions_path, 'r') as fp_:
        minions = json.load(fp_)

    ret = {}
    for minion in minions:
        data_path = os.path.join(_job_path(jid), minion, 'return.json')
        with salt.utils.fopen(data_path, 'r') as fp_:
            ret[minion] = json.load(fp_)

    return ret</pre></div><p class="calibre8">We don't need to restart the Master to be able to test this, since the jobs runner doesn't require the Master to be running:</p><div><pre class="programlisting">
<strong class="calibre2"># salt-run jobs.print_job 20151221184312454127</strong>
<strong class="calibre2">20151221184312454127:</strong>
<strong class="calibre2">    ----------</strong>
<strong class="calibre2">    Arguments:</strong>
<strong class="calibre2">    Function:</strong>
<strong class="calibre2">        test.ping</strong>
<strong class="calibre2">    Result:</strong>
<strong class="calibre2">        ----------</strong>
<strong class="calibre2">        dufresne:</strong>
<strong class="calibre2">            ----------</strong>
<strong class="calibre2">            fun:</strong>
<strong class="calibre2">                test.ping</strong>
<strong class="calibre2">            fun_args:</strong>
<strong class="calibre2">            id:</strong>
<strong class="calibre2">                dufresne</strong>
<strong class="calibre2">            jid:</strong>
<strong class="calibre2">                20151221184312454127</strong>
<strong class="calibre2">            retcode:</strong>
<strong class="calibre2">                0</strong>
<strong class="calibre2">            return:</strong>
<strong class="calibre2">                True</strong>
<strong class="calibre2">            success:</strong>
<strong class="calibre2">                True</strong>
<strong class="calibre2">    StartTime:</strong>
<strong class="calibre2">        2015, Dec 21 18:43:12.454127</strong>
<strong class="calibre2">    Target:</strong>
<strong class="calibre2">        dufresne</strong>
<strong class="calibre2">    Target-type:</strong>
<strong class="calibre2">        glob</strong>
<strong class="calibre2">    User:</strong>
<strong class="calibre2">        sudo_techhat</strong>
</pre></div><p class="calibre8">We'll also need a <a id="id184" class="calibre1"/>function that returns a list of JIDs, along with some basic information about their associated jobs. This function will make use of another import, which we will use to quickly locate the <code class="email">load.json</code> files:</p><div><pre class="programlisting">import salt.utils.find


def get_jids():
    '''
    Return a dict mapping all JIDs to job information
    '''
    path = os.path.join(
        salt.syspaths.CACHE_DIR,
        'master',
        'json_cache'
    )

    ret = {}
    finder = salt.utils.find.Finder({'name': 'load.json'})
    for file_ in finder.find(path):
        with salt.utils.fopen(file_) as fp_:
            data = json.load(fp_)
        if 'jid' in data:
            ret[data['jid']] = {
                'Arguments': data['arg'],
                'Function': data['fun'],
                'StartTime': salt.utils.jid.jid_to_time(data['jid']),
                'Target': data['tgt'],
                'Target-type': data['tgt_type'],
                'User': data['user'],
            }

    return ret</pre></div><p class="calibre8">Once again, we <a id="id185" class="calibre1"/>test this with the <code class="email">jobs</code> runner:</p><div><pre class="programlisting">
<strong class="calibre2"># salt-run jobs.list_jobs</strong>
<strong class="calibre2">20151221184312454127:</strong>
<strong class="calibre2">    ----------</strong>
<strong class="calibre2">    Arguments:</strong>
<strong class="calibre2">    Function:</strong>
<strong class="calibre2">        test.ping</strong>
<strong class="calibre2">    StartTime:</strong>
<strong class="calibre2">        2015, Dec 21 18:43:12.454127</strong>
<strong class="calibre2">    Target:</strong>
<strong class="calibre2">        dufresne</strong>
<strong class="calibre2">    Target-type:</strong>
<strong class="calibre2">        glob</strong>
<strong class="calibre2">    User:</strong>
<strong class="calibre2">        sudo_techhat</strong>
</pre></div></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec35" class="calibre1"/>The final module</h1></div></div></div><p class="calibre8">Once we <a id="id186" class="calibre1"/>have compiled all of the code together, the final module will look like this:</p><div><pre class="programlisting">'''
Store return data locally in JSON format

This file should be saved as salt/returners/local_json.py
'''
import json
import os.path
import salt.utils
import salt.utils.find
import salt.utils.jid
import salt.syspaths


def _job_path(jid):
    '''
    Return the path for the requested JID
    '''
    return os.path.join(
        salt.syspaths.CACHE_DIR,
        'master',
        'json_cache',
        jid[:4],
        jid[4:6],
        jid[6:],
    )


def returner(ret):
    '''
    Open new file, and save return data to it in JSON format
    '''
    path = os.path.join(_job_path(ret['jid']), ret['id']) + '/'
    __salt__['file.makedirs'](path)
    ret_file = os.path.join(path, 'return.json')
    with salt.utils.fopen(ret_file, 'w') as fp_:
        json.dump(ret, fp_)


def save_load(jid, clear_load, minions=None):
    '''
    Save the load to the specified JID
    '''
    path = os.path.join(_job_path(jid)) + '/'
    __salt__['file.makedirs'](path)

    load_file = os.path.join(path, 'load.json')
    with salt.utils.fopen(load_file, 'w') as fp_:
        json.dump(clear_load, fp_)
            minions = ckminions.check_minions(
                    clear_load['tgt'],
                    clear_load.get('tgt_type', 'glob')
                    )
        minions_file = os.path.join(path, 'minions.json')
        with salt.utils.fopen(minions_file, 'w') as fp_:
            json.dump(minions, fp_)


def get_load(jid):
    '''
    Return the load data for a specified JID
    '''
    path = os.path.join(_job_path(jid), 'load.json')
    with salt.utils.fopen(path, 'r') as fp_:
        return json.load(fp_)


def get_jid(jid):
    '''
    Return the information returned when the specified JID was executed
    '''
    minions_path = os.path.join(_job_path(jid), 'minions.json')
    with salt.utils.fopen(minions_path, 'r') as fp_:
        minions = json.load(fp_)

    ret = {}
    for minion in minions:
        data_path = os.path.join(_job_path(jid), minion, 'return.json')
        with salt.utils.fopen(data_path, 'r') as fp_:
            ret[minion] = json.load(fp_)

    return ret


def get_jids():
    '''
    Return a dict mapping all JIDs to job information
    '''
    path = os.path.join(
        salt.syspaths.CACHE_DIR,
        'master',
        'json_cache'
    )

    ret = {}
    finder = salt.utils.find.Finder({'name': 'load.json'})
    for file_ in finder.find(path):
        with salt.utils.fopen(file_) as fp_:
            data = json.load(fp_)
        if 'jid' in data:
            ret[data['jid']] = {
                'Arguments': data['arg'],
                'Function': data['fun'],
                'StartTime': salt.utils.jid.jid_to_time(data['jid']),
                'Target': data['tgt'],
                'Target-type': data['tgt_type'],
                'User': data['user'],
            }

    return ret</pre></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec36" class="calibre1"/>Troubleshooting returners</h1></div></div></div><p class="calibre8">As you <a id="id187" class="calibre1"/>have seen, there are a number of different pieces of Salt that use different parts of the returner. Some of these require a Master to be<a id="id188" class="calibre1"/> running, which makes them a little trickier to troubleshoot. Here are some strategies that can help.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch06lvl2sec56" class="calibre1"/>Testing with salt-call</h2></div></div></div><p class="calibre8">The <code class="email">returner()</code> function <a id="id189" class="calibre1"/>can be tested with the <code class="email">salt-call</code> command. When doing this, simple <code class="email">print</code> statements can be used to display information to your console. If there are typos, Python will display error messages. If the problem pertains to technically valid, but still buggy code, then <code class="email">print</code> statements can be used to track down the problem.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch06lvl2sec57" class="calibre1"/>Testing with the Master running</h2></div></div></div><p class="calibre8">The <code class="email">save_load()</code> function requires a job to be generated on the Master, to one or more Minions. This <a id="id190" class="calibre1"/>of course requires both a Master and at least one Minion to be running. You can run them in the foreground in separate terminals, in order to see the output from <code class="email">print</code> statements:</p><div><pre class="programlisting">
<strong class="calibre2"># salt-master --log-level debug</strong>
<strong class="calibre2"># salt-minion --log-level debug</strong>
</pre></div><p class="calibre8">If you are using <code class="email">ext_job_cache</code>, then it is the Minion that you will want to be watching. If you are using the <code class="email">master_job_cache</code>, then watch the Master.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch06lvl2sec58" class="calibre1"/>Testing with runners</h2></div></div></div><p class="calibre8">The <code class="email">get_load()</code>, <code class="email">get_jid()</code>, and <code class="email">get_jids()</code> functions are all used by the <code class="email">jobs</code> runner. This <a id="id191" class="calibre1"/>runner doesn't require either Master or Minions to be running; it only requires that the data store that is being used by the returner is available. Again, <code class="email">print</code> statements inside these functions will display information when the <code class="email">jobs</code> runner is used.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec37" class="calibre1"/>Writing outputter modules</h1></div></div></div><p class="calibre8">When the <code class="email">salt</code> command <a id="id192" class="calibre1"/>is used, any return data that is received during the wait period will be displayed to the user. Outputter modules are used in this case to display that data to the console (or more accurately, to <code class="email">STDOUT</code>), usually in a format that is somewhat user-friendly.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch06lvl2sec59" class="calibre1"/>Pickling our output</h2></div></div></div><p class="calibre8">Because Salt <a id="id193" class="calibre1"/>already ships with a <code class="email">json</code> outputter, we'll take advantage of the fact that output data is technically going to <code class="email">STDOUT</code>, and put together an <code class="email">outputter</code> that uses a serializer (<code class="email">pickle</code>) that may dump binary data:</p><div><pre class="programlisting">'''
Pickle outputter

This file should be saved as salt/output/pickle.py
'''
from __future__ import absolute_import
import pickle


def output(data):
    '''
    Dump out data in pickle format
    '''
    return pickle.dumps(data)</pre></div><p class="calibre8">This <code class="email">outputter</code> is about as simple as it gets. The only required function is called <code class="email">output()</code>, and it accepts a dictionary. It doesn't matter what the dictionary is called, so long as the function has one defined.</p><p class="calibre8">The <code class="email">pickle</code> library is built into Python, and as you saw with the <code class="email">pickle</code> renderer, is very easy to use: we just tell it to dump out the data into a string, which is returned to Salt.</p><p class="calibre8">As usual, we can test this <code class="email">outputter</code> using <code class="email">salt-call</code>:</p><div><pre class="programlisting">
<strong class="calibre2"># salt-call --local test.ping --out pickle</strong>
<strong class="calibre2">(dp0</strong>
<strong class="calibre2">S'local'</strong>
<strong class="calibre2">p1</strong>
<strong class="calibre2">I01</strong>
<strong class="calibre2">s.</strong>
</pre></div><p class="calibre8">If you take a look at some of the other outputters that ship with Salt, you'll notice that some are just as simple. Even the <code class="email">json</code> outputter doesn't do any extra work, outside of formatting the output. Most execution modules will make use of the <code class="email">nested</code> outputter by default. <code class="email">nested</code> uses <a id="id194" class="calibre1"/>a format based on YAML, but with color-coded data. The <code class="email">state</code> functions, however, use the <code class="email">highstate</code> outputter, which builds upon nested to return an aggregated version of the data, with statistics about the success of the state run.</p></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec38" class="calibre1"/>Troubleshooting outputters</h1></div></div></div><p class="calibre8">Outputters <a id="id195" class="calibre1"/>can be one of the easiest types of module to troubleshoot. You should be able to test any of them using the <code class="email">salt-call</code> command.</p><p class="calibre8">When<a id="id196" class="calibre1"/> testing, start with a simple <code class="email">test.ping</code>, just to make sure that you are getting some output in the first place. Once you're satisfied that your <code class="email">output()</code> function is returning simple data that looks correct, take a look at <code class="email">grains.items</code>, which will make use of both lists and dictionaries.</p><p class="calibre8">You may find it useful to test your output against another outputter that is known to work well. I find that the <code class="email">pprint</code> outputter tends to be the most succinct at displaying data in a format that is easy to read, but takes the least amount of screen real-estate:</p><div><pre class="programlisting">
<strong class="calibre2"># salt-call --local grains.items --out pickle</strong>
<strong class="calibre2"># salt-call --local grains.items --out pprint</strong>
</pre></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec39" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">Return data command is always sent to the Master, even after the <code class="email">salt</code> command has finished listening for it. The event bus picks up those messages and can store them in an external job cache. If the <code class="email">salt</code> command is still listening, then it will be displayed using an <code class="email">outputter</code>. But specifying a returner will always send return data someplace to be processed, so long as the Master itself is still running.</p><p class="calibre8">Returners can be specified using the <code class="email">--return</code> flag, or can be set to run by default on the Minion using the <code class="email">ext_job_cache</code> <code class="email">master</code> configuration option, or on the Master using the <code class="email">master_job_cache</code> <code class="email">master</code> configuration option.</p><p class="calibre8">Now that we have ways of handling return data, it's time to create more intelligent processes to execute our commands. Next up: runners.</p></div></body></html>