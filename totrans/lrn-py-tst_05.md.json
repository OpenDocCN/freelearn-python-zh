["```py\nfrom unittest import TestCase, main\nfrom unittest.mock import Mock, patch\n\nimport pid\n\nclass test_pid_constructor(TestCase):\n    def test_constructor_with_when_parameter(self):\n        controller = pid.PID(P = 0.5, I = 0.5, D = 0.5,\n                             setpoint = 1, initial = 12,\n                             when = 43)\n\n        self.assertEqual(controller.gains, (0.5, 0.5, 0.5))\n        self.assertAlmostEqual(controller.setpoint[0], 1.0)\n        self.assertEqual(len(controller.setpoint), 1)\n        self.assertAlmostEqual(controller.previous_time, 43.0)\n        self.assertAlmostEqual(controller.previous_error, -11.0)\n        self.assertAlmostEqual(controller.integrated_error, 0)\n```", "```py\n    @patch('pid.time', Mock(side_effect = [1.0]))\n    def test_constructor_without_when_parameter(self):\n        controller = pid.PID(P = 0.5, I = 0.5, D = 0.5,\n                             setpoint = 0, initial = 12)\n\n        self.assertEqual(controller.gains, (0.5, 0.5, 0.5))\n        self.assertAlmostEqual(controller.setpoint[0], 0.0)\n        self.assertEqual(len(controller.setpoint), 1)\n        self.assertAlmostEqual(controller.previous_time, 1.0)\n        self.assertAlmostEqual(controller.previous_error, -12.0)\n        self.assertAlmostEqual(controller.integrated_error, 0)\n\nclass test_pid_calculate_response(TestCase):\n    def test_with_when_parameter(self):\n        mock = Mock()\n        mock.gains = (0.5, 0.5, 0.5)\n        mock.setpoint = [0.0]\n        mock.previous_time = 1.0\n        mock.previous_error = -12.0\n        mock.integrated_error = 0.0\n\n        self.assertEqual(pid.PID.calculate_response(mock, 6, 2), -3)\n        self.assertEqual(pid.PID.calculate_response(mock, 3, 3), -4.5)\n        self.assertEqual(pid.PID.calculate_response(mock, -1.5, 4), -0.75)\n        self.assertEqual(pid.PID.calculate_response(mock, -2.25, 5), -1.125)\n\n    @patch('pid.time', Mock(side_effect = [2.0, 3.0, 4.0, 5.0]))\n    def test_without_when_parameter(self):\n        mock = Mock()\n        mock.gains = (0.5, 0.5, 0.5)\n        mock.setpoint = [0.0]\n        mock.previous_time = 1.0\n        mock.previous_error = -12.0\n        mock.integrated_error = 0.0\n\n        self.assertEqual(pid.PID.calculate_response(mock, 6), -3)\n        self.assertEqual(pid.PID.calculate_response(mock, 3), -4.5)\n        self.assertEqual(pid.PID.calculate_response(mock, -1.5), -0.75)\n        self.assertEqual(pid.PID.calculate_response(mock, -2.25), -1.125)\n```", "```py\npython3 -m unittest discover\n```", "```py\nfrom unittest import TestCase\n\nclass two_failing_tests(TestCase):\n    def test_one_plus_one_equals_one_is_true(self):\n        self.assertTrue(1 == 1 + 1)\n\n    def test_one_plus_one_equals_one(self):\n        self.assertEqual(1, 1 + 1)\n```", "```py\nAssertionError: 1 != 2\n```", "```py\nAssertionError: False is not true\n```", "```py\nfrom unittest import TestCase\n\nclass floating_point_problems(TestCase):\n    def test_square_root_of_seven_squared_incorrectly(self):\n        self.assertEqual((7.0 ** 0.5) ** 2.0, 7.0)\n\n    def test_square_root_of_seven_squared(self):\n        self.assertAlmostEqual((7.0 ** 0.5) ** 2.0, 7.0)\n```", "```py\nfrom unittest import TestCase\n\nclass silly_int_test(TestCase):\n    def test_int_from_string(self):\n        self.assertRaises(ValueError, int, '8ca2', base = 16)\n```", "```py\nAssertionError: ValueError not raised by int\n```", "```py\nfrom unittest import TestCase\n\nclass test_with_fail(TestCase):\n    def test_less_than(self):\n        if not (2.3 < 5.6):\n            self.fail('2.3 is not less than 5.6, but it should be')\n```", "```py\n>>> try:\n...     int('123')\n... except ValueError:\n...     pass\n... else:\n...     print('Expected exception was not raised')\n```", "```py\nclass test_exceptions(TestCase):\n    def test_ValueError(self):\n        self.assertRaises(ValueError, int, '123')\n```", "```py\nclass Employees:\n    def __init__(self, connection):\n        self.connection = connection\n\n    def add_employee(self, first, last, date_of_employment):\n        cursor = self.connection.cursor()\n        cursor.execute('''insert into employees\n                            (first, last, date_of_employment)\n                          values\n                            (:first, :last, :date_of_employment)''',\n                       locals())\n        self.connection.commit()\n\n        return cursor.lastrowid\n\n    def find_employees_by_name(self, first, last):\n        cursor = self.connection.cursor()\n        cursor.execute('''select * from employees\n                          where\n                            first like :first\n                          and\n                            last like :last''',\n                       locals())\n\n        for row in cursor:\n            yield row\n\n    def find_employees_by_date(self, date):\n        cursor = self.connection.cursor()\n        cursor.execute('''select * from employees\n                          where date_of_employment = :date''',\n                       locals())\n\n        for row in cursor:\n            yield row\n```", "```py\nfrom unittest import TestCase\nfrom sqlite3 import connect, PARSE_DECLTYPES\nfrom datetime import date\nfrom employees import Employees\n\nclass test_employees(TestCase):\n```", "```py\n    def setUp(self):\n        connection = connect(':memory:',\n                             detect_types = PARSE_DECLTYPES)\n        cursor = connection.cursor()\n\n        cursor.execute('''create table employees\n                            (first text,\n                             last text,\n                             date_of_employment date)''')\n\n        cursor.execute('''insert into employees\n                            (first, last, date_of_employment)\n                          values\n                            (\"Test1\", \"Employee\", :date)''',\n                       {'date': date(year = 2003,\n                                     month = 7,\n                                     day = 12)})\n\n        cursor.execute('''insert into employees\n                            (first, last, date_of_employment)\n                          values\n                            (\"Test2\", \"Employee\", :date)''',\n                       {'date': date(year = 2001,\n                                     month = 3,\n                                     day = 18)})\n\n        self.connection = connection\n```", "```py\n    def tearDown(self):\n        self.connection.close()\n```", "```py\n    def test_add_employee(self):\n        to_test = Employees(self.connection)\n        to_test.add_employee('Test1', 'Employee', date.today())\n\n        cursor = self.connection.cursor()\n        cursor.execute('''select * from employees\n                          order by date_of_employment''')\n\n        self.assertEqual(tuple(cursor),\n                         (('Test2', 'Employee', date(year = 2001,\n                                                     month = 3,\n                                                     day = 18)),\n                          ('Test1', 'Employee', date(year = 2003,\n                                                     month = 7,\n                                                     day = 12)),\n                          ('Test1', 'Employee', date.today())))\n\n    def test_find_employees_by_name(self):\n        to_test = Employees(self.connection)\n\n        found = tuple(to_test.find_employees_by_name('Test1', 'Employee'))\n        expected = (('Test1', 'Employee', date(year = 2003,\n                                               month = 7,\n                                               day = 12)),)\n\n        self.assertEqual(found, expected)\n\n    def test_find_employee_by_date(self):\n        to_test = Employees(self.connection)\n\n        target = date(year = 2001, month = 3, day = 18)\n        found = tuple(to_test.find_employees_by_date(target))\n\n        expected = (('Test2', 'Employee', target),)\n\n        self.assertEqual(found, expected)\n```"]