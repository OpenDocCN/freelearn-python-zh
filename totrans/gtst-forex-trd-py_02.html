<html><head></head><body>
<div id="_idContainer011">
<h1 class="chapter-number" id="_idParaDest-29"><a id="_idTextAnchor028"/><span class="koboSpan" id="kobo.1.1">2</span></h1>
<h1 id="_idParaDest-30"><a id="_idTextAnchor029"/><span class="koboSpan" id="kobo.2.1">Using Python for Trading Strategies</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Python has gained a reputation as the language of choice for the development of a wide range of applications in the financial industry and has become a de facto industry standard for the research phase of trading strategy development. </span><span class="koboSpan" id="kobo.3.2">However, as with any other language or, better put, programming ecosystem, it has its advantages and disadvantages. </span><span class="koboSpan" id="kobo.3.3">So, as with any tool, it is essential to understand its strong and weak points to use the tool properly (not trying to hammer nails with a microscope, so </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">to say).</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">In this chapter, not only will we consider using Python for algorithmic trading strategy development but we will also learn about the essential steps in the research and development process, discuss the difference between market modeling and event-based trading, and point to the mistakes most typically made in the research and development process. </span><span class="koboSpan" id="kobo.5.2">Finally, we will see the limitations of using Python for algo trading so our expectations always </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">meet reality.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">We will quickly dive a bit deeper than just a surface overview to see how the strongest advantages of Python, such as native language structures and efficient </span><strong class="bold"><span class="koboSpan" id="kobo.8.1">object-oriented programming</span></strong><span class="koboSpan" id="kobo.9.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.10.1">OOP</span></strong><span class="koboSpan" id="kobo.11.1">), help make the code transparent and keep the architecture of a trading app modular, flexible, </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">and scalable.</span></span></p>
<p><span class="koboSpan" id="kobo.13.1">By the end of this chapter, you will be familiar with the key concepts of trading and algo trading, applications of Python, and various </span><strong class="bold"><span class="koboSpan" id="kobo.14.1">integrated development environments</span></strong><span class="koboSpan" id="kobo.15.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.16.1">IDEs</span></strong><span class="koboSpan" id="kobo.17.1">) for the research and development of trading strategies, and you will know the limits beyond which using Python is </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">not efficient.</span></span></p>
<p><span class="koboSpan" id="kobo.19.1">In this chapter, we will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.21.1">The advantages of using Python in trading </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">strategy development</span></span></li>
<li><span class="koboSpan" id="kobo.23.1">Modeling – forecasting the future doesn’t necessarily mean </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">practical benefits</span></span></li>
<li><span class="koboSpan" id="kobo.25.1">Paper trading and backtesting – an essential part of a systemic trader’s </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">risk management</span></span></li>
<li><span class="koboSpan" id="kobo.27.1">The disadvantages of using Python in trading </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">strategy development</span></span></li>
<li><span class="koboSpan" id="kobo.29.1">Live trading – where Python faces </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">its limits</span></span></li>
</ul>
<h1 id="_idParaDest-31"><a id="_idTextAnchor030"/><span class="koboSpan" id="kobo.31.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.32.1">You will need Python 3.10 or higher to run the code in </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">this chapter.</span></span></p>
<h1 id="_idParaDest-32"><a id="_idTextAnchor031"/><span class="koboSpan" id="kobo.34.1">The advantages of using Python in trading strategy development</span></h1>
<p><span class="koboSpan" id="kobo.35.1">Today when we say </span><em class="italic"><span class="koboSpan" id="kobo.36.1">Python</span></em><span class="koboSpan" id="kobo.37.1">, we most likely mean not only the most flexible object-oriented </span><a id="_idIndexMarker046"/><span class="koboSpan" id="kobo.38.1">programming language but also the most powerful and convenient interactive IDEs, such as Spyder or PyCharm, along with the vast collection of libraries that extend this language to fit virtually any domain of applied and fundamental research, from medicine to astronomy. </span><span class="koboSpan" id="kobo.38.2">There is no surprise that the Python ecosystem has become the de facto standard in the financial industry where numbers play a </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">decisive role.</span></span></p>
<p><span class="koboSpan" id="kobo.40.1">The advantages of using Python for the development of trading strategies are obvious and we will look into a few of these advantages in detail in the </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">following sections.</span></span></p>
<h2 id="_idParaDest-33"><a id="_idTextAnchor032"/><span class="koboSpan" id="kobo.42.1">Memory management</span></h2>
<p><span class="koboSpan" id="kobo.43.1">Python is one of the </span><a id="_idIndexMarker047"/><span class="koboSpan" id="kobo.44.1">few interpreters that has robust built-in memory management services such as garbage collection and reference counting. </span><span class="koboSpan" id="kobo.44.2">Essentially, this means that you don’t have to care about any complex object you work with and the amount of data processed by your code. </span><span class="koboSpan" id="kobo.44.3">Of course, this dramatically increases the development speed, especially if you work with large datasets – and trading applications work with </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">large datasets.</span></span></p>
<h2 id="_idParaDest-34"><a id="_idTextAnchor033"/><span class="koboSpan" id="kobo.46.1">Interactive computing</span></h2>
<p><span class="koboSpan" id="kobo.47.1">Python </span><a id="_idIndexMarker048"/><span class="koboSpan" id="kobo.48.1">is an interpreted language and this means two </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">important things.</span></span></p>
<p><span class="koboSpan" id="kobo.50.1">First, you can stop executing the code at any moment and check the environment at runtime, including all variables, functions, and objects – which is convenient </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">for debugging.</span></span></p>
<p><span class="koboSpan" id="kobo.52.1">Second, you can work with Python interactively. </span><span class="koboSpan" id="kobo.52.2">This means that in all Unix-like systems, we run Python in a console where we can send commands one by one and immediately get responses from the interpreter. </span><span class="koboSpan" id="kobo.52.3">If you develop trading applications, this allows you to quickly test some modules on small datasets before integrating them into the final code. </span><span class="koboSpan" id="kobo.52.4">It also allows you to quickly visualize any portion of a data set on the fly without rewriting and rerunning any code, which is invaluable for developing any applications that work with </span><span class="No-Break"><span class="koboSpan" id="kobo.53.1">time series.</span></span></p>
<p><span class="koboSpan" id="kobo.54.1">Working in a native console is not as convenient as in IPython – a command shell that supports </span><a id="_idIndexMarker049"/><span class="koboSpan" id="kobo.55.1">introspection, rich media, syntax highlighting, tab completion, and history. </span><span class="koboSpan" id="kobo.55.2">Released in 2001 as an open source </span><a id="_idIndexMarker050"/><span class="koboSpan" id="kobo.56.1">project, IPython quickly transformed Python into a direct competitor to Matlab, and thanks to the open source status and enormous community of contributors we can say that today, Python has won the competition. </span><span class="koboSpan" id="kobo.56.2">In 2014, a spin-off project based on IPython started with the idea of developing a universal interactive computing </span><a id="_idIndexMarker051"/><span class="koboSpan" id="kobo.57.1">environment suitable not only for Python but also for other languages. </span><span class="koboSpan" id="kobo.57.2">This project was called Jupyter and today this is probably the most popular notebook-style interactive computing environment. </span><span class="koboSpan" id="kobo.57.3">Sometimes Jupyter is even considered a replacement for IPython; however, this is not really correct. </span><span class="koboSpan" id="kobo.57.4">DataCamp published an excellent article that explains the </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">difference: </span></span><a href="https://www.datacamp.com/blog/ipython-or-jupyter&#13;"><span class="No-Break"><span class="koboSpan" id="kobo.59.1">https://www.datacamp.com/blog/ipython-or-jupyter</span></span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">.</span></span></a></p>
<h2 id="_idParaDest-35"><a id="_idTextAnchor034"/><span class="koboSpan" id="kobo.61.1">Ease of integration and routing</span></h2>
<p><span class="koboSpan" id="kobo.62.1">If the previous </span><a id="_idIndexMarker052"/><span class="koboSpan" id="kobo.63.1">two advantages are not specific to the development of trading applications, then what makes Python the preferred language for both trading research and development is the ease with which you can switch between </span><em class="italic"><span class="koboSpan" id="kobo.64.1">research mode</span></em><span class="koboSpan" id="kobo.65.1"> and </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.66.1">production mode</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.68.1">If you have carefully planned your data structures and codes (and this is what we will be learning to do throughout this book), then all essential modules of the trading app (which we drafted in the previous chapter) will be independent and replaceable. </span><span class="koboSpan" id="kobo.68.2">What advantage does this give you as a developer? </span><span class="koboSpan" id="kobo.68.3">The advantages are </span><span class="No-Break"><span class="koboSpan" id="kobo.69.1">as follows:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.70.1">It allows you to develop the trading logic using historical data and then replace the data source with a live stream from </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">the broker.</span></span></li>
<li><span class="koboSpan" id="kobo.72.1">It allows you to fine-tune and debug your application by simulating order execution and letting you switch to production using the same code you used for development. </span><span class="koboSpan" id="kobo.72.2">This reduces the risk </span><span class="No-Break"><span class="koboSpan" id="kobo.73.1">of errors.</span></span></li>
<li><span class="koboSpan" id="kobo.74.1">It allows you to scale your trading business by adding more execution venues, protocols, APIs, and trading accounts, keeping the rest of the code </span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">the same.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.76.1">Besides that, thanks to the interactivity of the Python environment, you can even intervene in </span><a id="_idIndexMarker053"/><span class="koboSpan" id="kobo.77.1">the trading process manually. </span><span class="koboSpan" id="kobo.77.2">For example, you can send a </span><strong class="source-inline"><span class="koboSpan" id="kobo.78.1">FIX</span></strong><span class="koboSpan" id="kobo.79.1"> message to close all open positions in case of an emergency. </span><span class="koboSpan" id="kobo.79.2">Of course, this is </span><em class="italic"><span class="koboSpan" id="kobo.80.1">not</span></em><span class="koboSpan" id="kobo.81.1"> the best practice, or even something that can be recommended, but knowing that even in the worst unexpected scenario you can take urgent action straight from the familiar development environment adds to peace </span><span class="No-Break"><span class="koboSpan" id="kobo.82.1">of mind.</span></span></p>
<h2 id="_idParaDest-36"><a id="_idTextAnchor035"/><span class="koboSpan" id="kobo.83.1">Native language structures – lists and dictionaries</span></h2>
<p><span class="koboSpan" id="kobo.84.1">One of the </span><a id="_idIndexMarker054"/><span class="koboSpan" id="kobo.85.1">key advantages of using Python for data processing is that it natively implements two powerful structures: lists </span><span class="No-Break"><span class="koboSpan" id="kobo.86.1">and dictionaries.</span></span></p>
<p><span class="koboSpan" id="kobo.87.1">Trading applications work with time series, and having convenient tools to read, access, compress, and process this data is crucial. </span><span class="koboSpan" id="kobo.87.2">Using lists and dictionaries along with objects becomes quite efficient. </span><span class="koboSpan" id="kobo.87.3">Let’s consider </span><span class="No-Break"><span class="koboSpan" id="kobo.88.1">an example.</span></span></p>
<p><span class="koboSpan" id="kobo.89.1">Imagine we have tick data and want to transform it into OHLC data points (see the previous chapter for an explanation of OHLC). </span><span class="koboSpan" id="kobo.89.2">We can define such a data point, which in trading is normally called a </span><em class="italic"><span class="koboSpan" id="kobo.90.1">bar</span></em><span class="koboSpan" id="kobo.91.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.92.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.93.1">
class OHLC:
        def __init__(self, O, H, L, C):
                self.open = O
                self.high = H
                self.low = L
                self.close = C</span></pre>
<p><span class="koboSpan" id="kobo.94.1">Then, we can create storage for </span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">our bars:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.96.1">
class time_series:
        def __init__(self):
                self.ts = []
                self.last = -1
        def add(self, bar):
                self.ts.append(bar)
        def read(self):
                self.last += 1
                return self.ts[self.last]</span></pre>
<p><span class="koboSpan" id="kobo.97.1">Here, we </span><a id="_idIndexMarker055"/><span class="koboSpan" id="kobo.98.1">can define a native Python list where we store OHLC bars and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.99.1">self.last</span></strong><span class="koboSpan" id="kobo.100.1"> pointer, which points to the last element that was read from the list. </span><span class="koboSpan" id="kobo.100.2">Then, we will add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.101.1">read</span></strong><span class="koboSpan" id="kobo.102.1"> method, which returns the element to which the </span><strong class="source-inline"><span class="koboSpan" id="kobo.103.1">self.last</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.104.1">pointer points.</span></span></p>
<p><span class="koboSpan" id="kobo.105.1">Then, instead of retrieving OHLC bars by index in the production code </span><span class="No-Break"><span class="koboSpan" id="kobo.106.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.107.1">
data = time_series()
i = some_index
price = data.ts[i].close</span></pre>
<p><span class="koboSpan" id="kobo.108.1">We will retrieve closing prices without direct reference to </span><span class="No-Break"><span class="koboSpan" id="kobo.109.1">the index:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.110.1">
data = time_series()
price = data.read().close</span></pre>
<p><span class="koboSpan" id="kobo.111.1">This streamlines working with time series (or any data series) dramatically as we no longer need to store indices in the main code and even more importantly – we reduce the risk of </span><em class="italic"><span class="koboSpan" id="kobo.112.1">peeking ahead</span></em><span class="koboSpan" id="kobo.113.1">. </span><span class="koboSpan" id="kobo.113.2">Peek ahead is a common error in trading strategy development. </span><span class="koboSpan" id="kobo.113.3">While doing backtests, the strategy code must use only past and current price data for each emulated trade. </span><span class="koboSpan" id="kobo.113.4">For example, if the strategy emulates the market on April 1</span><span class="superscript"><span class="koboSpan" id="kobo.114.1">st</span></span><span class="koboSpan" id="kobo.115.1">, it should not refer to price data from April 2</span><span class="superscript"><span class="koboSpan" id="kobo.116.1">nd</span></span><span class="koboSpan" id="kobo.117.1">. </span><span class="koboSpan" id="kobo.117.2">The same is applied to any time resolution, down to milliseconds. </span><span class="koboSpan" id="kobo.117.3">Strategies that use future data in the research phase, normally, are unable to work in real life (see</span><em class="italic"> </em><a href="B19145_05.xhtml#_idTextAnchor086"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.118.1">Chapter 5</span></em></span></a><em class="italic"><span class="koboSpan" id="kobo.119.1">, Retrieving and Handling Market Data with Python,</span></em><span class="koboSpan" id="kobo.120.1"> for a detailed discussion on proper data handling when performing backtests). </span><span class="koboSpan" id="kobo.120.2">It is impossible to overvalue the convenience with which Python allows you to avoid critical errors such as this, as these errors may cost real and </span><span class="No-Break"><span class="koboSpan" id="kobo.121.1">substantial money.</span></span></p>
<p><span class="koboSpan" id="kobo.122.1">Dictionaries offer another way to store and process series data in Python. </span><span class="koboSpan" id="kobo.122.2">As each data point, be it a </span><a id="_idIndexMarker056"/><span class="koboSpan" id="kobo.123.1">tick or a bar, has a timestamp, we can use timestamps as keys in </span><span class="No-Break"><span class="koboSpan" id="kobo.124.1">a dictionary:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.125.1">
class OHLC:
        def __init__(self, dt, O, H, L, C):
                self.datetime = dt
                self.open = O
                self.high = H
                self.low = L
                self.close = C
class time_series:
        def __init__(self):
                self.ts = {}
        def add(self, bar):
                self.ts[bar.datetime] = bar</span></pre>
<p><span class="koboSpan" id="kobo.126.1">Then, retrieving a particular </span><strong class="source-inline"><span class="koboSpan" id="kobo.127.1">close</span></strong><span class="koboSpan" id="kobo.128.1"> price by its </span><strong class="source-inline"><span class="koboSpan" id="kobo.129.1">timestamp</span></strong><span class="koboSpan" id="kobo.130.1"> value will be simple with the </span><span class="No-Break"><span class="koboSpan" id="kobo.131.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.132.1">
price = data.ts[timestamp].close</span></pre>
<p><span class="koboSpan" id="kobo.133.1">So, even native Python language structures offer a quick, simple, and extremely efficient way to handle data specific to trading. </span><span class="koboSpan" id="kobo.133.2">However, it is libraries that make Python the definite choice for </span><span class="No-Break"><span class="koboSpan" id="kobo.134.1">quantitative trading.</span></span></p>
<h2 id="_idParaDest-37"><a id="_idTextAnchor036"/><span class="koboSpan" id="kobo.135.1">Libraries</span></h2>
<p><span class="koboSpan" id="kobo.136.1">The ultimate success of Python as the environment for quantitative finance and trading is determined </span><a id="_idIndexMarker057"/><span class="koboSpan" id="kobo.137.1">by a number of libraries, which today are de facto industry standards and sometimes are so tightly associated with the language itself that many developers do not think about them separately. </span><span class="koboSpan" id="kobo.137.2">Let us look into some of </span><span class="No-Break"><span class="koboSpan" id="kobo.138.1">these libraries.</span></span></p>
<h3><span class="koboSpan" id="kobo.139.1">NumPy</span></h3>
<p><span class="koboSpan" id="kobo.140.1">Originally released in 1995 as Numeric Python, this library is used today in virtually any application that </span><a id="_idIndexMarker058"/><span class="koboSpan" id="kobo.141.1">uses mathematics. </span><span class="koboSpan" id="kobo.141.2">It was the very library that transformed Python </span><a id="_idIndexMarker059"/><span class="koboSpan" id="kobo.142.1">from just a programming language into a Matlab-like, powerful, </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">number-crunching suite.</span></span></p>
<p><span class="koboSpan" id="kobo.144.1">NumPy offers implementations for a number of core objects from linear algebra such as vectors, arrays, and operations with them. </span><span class="koboSpan" id="kobo.144.2">It offers comprehensive mathematical functions, random number generators, Fourier transforms, and more. </span><span class="koboSpan" id="kobo.144.3">Best of all – its core is written in C, so all native </span><strong class="source-inline"><span class="koboSpan" id="kobo.145.1">numpy</span></strong><span class="koboSpan" id="kobo.146.1"> methods work </span><span class="No-Break"><span class="koboSpan" id="kobo.147.1">blazingly fast.</span></span></p>
<h3><span class="koboSpan" id="kobo.148.1">Matplotlib</span></h3>
<p><span class="koboSpan" id="kobo.149.1">Matplotlib was released </span><a id="_idIndexMarker060"/><span class="koboSpan" id="kobo.150.1">in 2003 as the universal plotting library for Python and NumPy. </span><span class="koboSpan" id="kobo.150.2">It </span><a id="_idIndexMarker061"/><span class="koboSpan" id="kobo.151.1">recognizes native NumPy objects and produces print-quality images of almost any type of chart used </span><span class="No-Break"><span class="koboSpan" id="kobo.152.1">in mathematics.</span></span></p>
<p><span class="koboSpan" id="kobo.153.1">What makes Matplotlib especially attractive for trading app development are the </span><span class="No-Break"><span class="koboSpan" id="kobo.154.1">following features:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.155.1">It automatically scales data series to fit the chart, so it’s extremely easy to visualize any market or trading data with a </span><span class="No-Break"><span class="koboSpan" id="kobo.156.1">single command</span></span></li>
<li><span class="koboSpan" id="kobo.157.1">The charts are embeddable and can be output in consoles such as IPython </span><span class="No-Break"><span class="koboSpan" id="kobo.158.1">or Jupyter</span></span></li>
<li><span class="koboSpan" id="kobo.159.1">The charts are interactive, so you can zoom in, zoom out, and drag to explore details without needing to write your own </span><span class="No-Break"><span class="koboSpan" id="kobo.160.1">image-handling tools</span></span></li>
</ul>
<h3><span class="koboSpan" id="kobo.161.1">pandas</span></h3>
<p><span class="koboSpan" id="kobo.162.1">It is believed that the name </span><strong class="bold"><span class="koboSpan" id="kobo.163.1">pandas</span></strong><span class="koboSpan" id="kobo.164.1"> is derived from </span><strong class="bold"><span class="koboSpan" id="kobo.165.1">panel data</span></strong><span class="koboSpan" id="kobo.166.1">, a term used in econometrics. </span><span class="koboSpan" id="kobo.166.2">It </span><a id="_idIndexMarker062"/><span class="koboSpan" id="kobo.167.1">can also be understood as </span><strong class="bold"><span class="koboSpan" id="kobo.168.1">Python Analysis of Data</span></strong><span class="koboSpan" id="kobo.169.1">. </span><span class="koboSpan" id="kobo.169.2">This is a </span><a id="_idIndexMarker063"/><span class="koboSpan" id="kobo.170.1">library that introduces the concept of DataFrames. </span><span class="koboSpan" id="kobo.170.2">You can think about a </span><a id="_idIndexMarker064"/><span class="koboSpan" id="kobo.171.1">DataFrame as a hybrid of a Python dictionary, list, and </span><a id="_idIndexMarker065"/><span class="koboSpan" id="kobo.172.1">database. </span><span class="koboSpan" id="kobo.172.2">It uses keywords to access records but preserves the order of items so data can be retrieved by indexing. </span><span class="koboSpan" id="kobo.172.3">At the same time, it features routines typical for databases, such as making subsets </span><span class="No-Break"><span class="koboSpan" id="kobo.173.1">or slices.</span></span></p>
<p><span class="koboSpan" id="kobo.174.1">On top of DataFrames, pandas offers tools to read and write data between in-memory structures and different file formats, including CSV, JSON, SQL queries and tables, and MS Excel, which covers virtually all formats used today by data vendors, brokers, </span><span class="No-Break"><span class="koboSpan" id="kobo.175.1">and exchanges.</span></span></p>
<p><span class="koboSpan" id="kobo.176.1">If we also take into consideration the fact that pandas offers a variety of powerful functions that can rebuild missing data, generate datetime ranges, convert sampling frequencies, support sliding window statistics, and many more – you understand that you get the ultimate toolbox for developing any kind of </span><span class="No-Break"><span class="koboSpan" id="kobo.177.1">trading application.</span></span></p>
<p><span class="koboSpan" id="kobo.178.1">While covering pandas in all its powerful aspects is well beyond the scope of this book, we will consider a few useful applications of pandas in </span><a href="B19145_08.xhtml#_idTextAnchor130"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.179.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.180.1">, </span><em class="italic"><span class="koboSpan" id="kobo.181.1">Data Visualization in FX Trading </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.182.1">with Python</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.183.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.184.1">NumPy and matplotlib are parts of SciPy – a comprehensive library for any applied mathematics, from optimization and linear algebra to signal processing and multidimensional </span><span class="No-Break"><span class="koboSpan" id="kobo.185.1">image processing.</span></span></p>
<h1 id="_idParaDest-38"><a id="_idTextAnchor037"/><span class="koboSpan" id="kobo.186.1">Modeling – forecasting the future doesn’t necessarily mean practical benefits</span></h1>
<p><span class="koboSpan" id="kobo.187.1">In order to keep the discussion consistent, we need to draw a thin but solid line between trading and modeling. </span><span class="koboSpan" id="kobo.187.2">Sometimes, these two terms are seriously confused and may lead not only to misunderstanding but also to </span><span class="No-Break"><span class="koboSpan" id="kobo.188.1">losing money.</span></span></p>
<p><span class="koboSpan" id="kobo.189.1">Modeling is a research activity </span><a id="_idIndexMarker066"/><span class="koboSpan" id="kobo.190.1">that aims at building a model that explains the observed data. </span><span class="koboSpan" id="kobo.190.2">For example, Ptolemy developed a geocentric model of the Solar System, whereas Nicolaus Copernicus suggested a model of the Earth spinning around its own axis and traveling around the Sun on an elliptical orbit – now known as the heliocentric model. </span><span class="koboSpan" id="kobo.190.3">Both models explain the observed data: that the Sun visually moves around the Earth, that day follows night, and that seasons change in order. </span><span class="koboSpan" id="kobo.190.4">However, the heliocentric model proved to be far more precise and easy to use, so the other one </span><span class="No-Break"><span class="koboSpan" id="kobo.191.1">was abandoned.</span></span></p>
<p><span class="koboSpan" id="kobo.192.1">In the financial world, modeling a market means finding a set of quantitative rules that explain the observed </span><a id="_idIndexMarker067"/><span class="koboSpan" id="kobo.193.1">price behavior. </span><span class="koboSpan" id="kobo.193.2">At first glance, it looks like modeling any other physical process, for example, the same solar motion. </span><span class="koboSpan" id="kobo.193.3">The main problem with financial modeling, especially in trading, is that the modeled process </span><span class="No-Break"><span class="koboSpan" id="kobo.194.1">is non-stationary.</span></span></p>
<p><span class="koboSpan" id="kobo.195.1">In very simple terms, a </span><strong class="bold"><span class="koboSpan" id="kobo.196.1">non-stationary process</span></strong><span class="koboSpan" id="kobo.197.1"> doesn’t have a constant mean value or consistent </span><a id="_idIndexMarker068"/><span class="koboSpan" id="kobo.198.1">distribution of values across time. </span><span class="koboSpan" id="kobo.198.2">This is the very reason for the eventual failure of any attempt to use classical statistics, from averages to Gaussian distribution, to calculate fair prices or predict anything in the future. </span><span class="koboSpan" id="kobo.198.3">This is the very reason why many modern approaches that involve elements of machine learning, especially based on linear regression, also fail in </span><span class="No-Break"><span class="koboSpan" id="kobo.199.1">practical trading.</span></span></p>
<p><span class="koboSpan" id="kobo.200.1">If you are interested in learning more about non-stationary processes, including what they are and what makes successful statistics-based trading so problematic, then I’d recommend starting with a basic article from Investopedia: </span><a href="https://www.investopedia.com/articles/trading/07/stationary.asp"><span class="koboSpan" id="kobo.201.1">https://www.investopedia.com/articles/trading/07/stationary.asp</span></a><span class="koboSpan" id="kobo.202.1">. </span><span class="koboSpan" id="kobo.202.2">Or, if you are more advanced in mathematics, there is an excellent book by M. </span><span class="koboSpan" id="kobo.202.3">B. </span><span class="koboSpan" id="kobo.202.4">Priestley, </span><em class="italic"><span class="koboSpan" id="kobo.203.1">Non-linear and Non-stationary Time </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.204.1">Series Analysis</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.205.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.206.1">Back to the point – modeling non-stationary data is not only problematic but also often provides practically useless results. </span><span class="koboSpan" id="kobo.206.2">In the case of a stationary process, such as the Earth going around the Sun, we can use our model to predict the future – and will be correct in the absolute majority of cases. </span><span class="koboSpan" id="kobo.206.3">But with a non-stationary process, most models will perfectly explain past data, data that had already been observed, but will have problems forecasting future observations. </span><span class="koboSpan" id="kobo.206.4">So, in my opinion, the realm of market modeling is academic research, and using it for practical active trading is questionable. </span><span class="koboSpan" id="kobo.206.5">I know that there are opposite opinions, but nevertheless, in this book, we will focus only on </span><span class="No-Break"><span class="koboSpan" id="kobo.207.1">event-driven trading.</span></span></p>
<p><span class="koboSpan" id="kobo.208.1">The difference in approaches is that with market modeling, we try to predict future price movements and then follow the forecast to make trading decisions while in event-driven trading, we wait for a certain event to happen and then react immediately by placing an order. </span><span class="koboSpan" id="kobo.208.2">For example, if we run an arbitrage strategy, then we wait for the (rare) moment when the asset is mispriced. </span><span class="koboSpan" id="kobo.208.3">If we run a directional trading strategy, we wait for a moment when certain economic news is released or prices start to change rapidly, or vice versa – when </span><a id="_idIndexMarker069"/><span class="koboSpan" id="kobo.209.1">the market is slow, but anyway – the strategy reacts to what is going on in the market </span><em class="italic"><span class="koboSpan" id="kobo.210.1">right now</span></em><span class="koboSpan" id="kobo.211.1">, without </span><em class="italic"><span class="koboSpan" id="kobo.212.1">predicting</span></em><span class="koboSpan" id="kobo.213.1"> or </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.214.1">forecasting</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.215.1"> anything.</span></span></p>
<h3><span class="koboSpan" id="kobo.216.1">scikit-learn</span></h3>
<p><span class="koboSpan" id="kobo.217.1">Nevertheless, some of the inventory traditionally used in market modeling, especially machine learning, can be quite useful in event-driven trading strategies as part of data pre-processing. </span><span class="koboSpan" id="kobo.217.2">Therefore, we should mention at least one more Python library that is another de facto industry standard for </span><span class="No-Break"><span class="koboSpan" id="kobo.218.1">data science.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.219.1">scikit-learn</span></strong><span class="koboSpan" id="kobo.220.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.221.1">sklearn</span></strong><span class="koboSpan" id="kobo.222.1"> is a library with implementations of the most popular techniques used in data </span><a id="_idIndexMarker070"/><span class="koboSpan" id="kobo.223.1">science and machine learning. </span><span class="koboSpan" id="kobo.223.2">It includes easy-to-use implementations of classification, regression, clustering, and preprocessing along with model selection algorithms (cross-validation, grid search, and more). </span><span class="koboSpan" id="kobo.223.3">Having such a robust library also adds to the choice of Python as the preferred ecosystem for the development of </span><span class="No-Break"><span class="koboSpan" id="kobo.224.1">trading strategies.</span></span></p>
<p><span class="koboSpan" id="kobo.225.1">Now that we have familiarized ourselves with the diversity of powerful features offered by Python and numerous libraries, it’s time to dig a bit deeper into the process of research and development that is typical for any kind of algo </span><span class="No-Break"><span class="koboSpan" id="kobo.226.1">trading strategy.</span></span></p>
<h1 id="_idParaDest-39"><a id="_idTextAnchor038"/><span class="koboSpan" id="kobo.227.1">Paper trading and backtesting – an essential part of a systemic trader’s risk management</span></h1>
<p><span class="koboSpan" id="kobo.228.1">Imagine that we have used all the power of Python and developed a trading application. </span><span class="koboSpan" id="kobo.228.2">Now what? </span><span class="koboSpan" id="kobo.228.3">Is it time to immediately launch it and try earning some money? </span><span class="koboSpan" id="kobo.228.4">No! </span><span class="koboSpan" id="kobo.228.5">Before jumping in the pool, it’s essential to make sure there’s water in it, and in our case before putting the app into production, it’s essential that it can make money, at least </span><span class="No-Break"><span class="koboSpan" id="kobo.229.1">in theory.</span></span></p>
<p><span class="koboSpan" id="kobo.230.1">In this section, we’ll consider paper trading and backtesting – two cornerstones of systematic trading </span><a id="_idIndexMarker071"/><span class="koboSpan" id="kobo.231.1">that help us understand potential pitfalls with the newly developed </span><a id="_idIndexMarker072"/><span class="koboSpan" id="kobo.232.1">strategy. </span><span class="koboSpan" id="kobo.232.2">We will learn about historical data, trade simulation, and ordering, and we’ll also quickly consider some ready-made packages that simplify this part of </span><span class="No-Break"><span class="koboSpan" id="kobo.233.1">the development.</span></span></p>
<h2 id="_idParaDest-40"><a id="_idTextAnchor039"/><span class="koboSpan" id="kobo.234.1">What are paper trading and backtesting?</span></h2>
<p><span class="koboSpan" id="kobo.235.1">After we have developed a trading algorithm, connected to the data source, and are ready to send orders, it’s time to test our setup. </span><span class="koboSpan" id="kobo.235.2">Such a test validates the following </span><span class="No-Break"><span class="koboSpan" id="kobo.236.1">crucial points:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.237.1">The consistency of the </span><span class="No-Break"><span class="koboSpan" id="kobo.238.1">trading logic</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.239.1">Risk management</span></span></li>
<li><span class="koboSpan" id="kobo.240.1">Ordering interface and </span><span class="No-Break"><span class="koboSpan" id="kobo.241.1">handling errors</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.242.1">If a test is </span><a id="_idIndexMarker073"/><span class="koboSpan" id="kobo.243.1">performed using past market data (mostly referred to as </span><strong class="bold"><span class="koboSpan" id="kobo.244.1">historical data</span></strong><span class="koboSpan" id="kobo.245.1">) with orders sent to a simulation engine, then it is called </span><strong class="bold"><span class="koboSpan" id="kobo.246.1">backtesting</span></strong><span class="koboSpan" id="kobo.247.1">. </span><span class="koboSpan" id="kobo.247.2">If the test is </span><a id="_idIndexMarker074"/><span class="koboSpan" id="kobo.248.1">performed using live market data with orders sent to the UAT </span><a id="_idIndexMarker075"/><span class="koboSpan" id="kobo.249.1">environment (provided by the broker, trading venue, or again emulated locally), then it is called </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.250.1">paper trading</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.251.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.252.1">The purpose of backtesting is to see how our strategy would have reacted to various market situations </span><a id="_idIndexMarker076"/><span class="koboSpan" id="kobo.253.1">in the past. </span><span class="koboSpan" id="kobo.253.2">This is absolutely essential because all systematic trading is built around the idea that if a certain situation happened in the past, then most likely it will repeat in the future. </span><span class="koboSpan" id="kobo.253.3">For example, if the non-farm payroll is way lower than expectations, stock prices go down for some time. </span><span class="koboSpan" id="kobo.253.4">This is confirmed by many years of historical data. </span><span class="koboSpan" id="kobo.253.5">So, we may assume that next time it is too low, stock prices will go </span><span class="No-Break"><span class="koboSpan" id="kobo.254.1">down again.</span></span></p>
<p><span class="koboSpan" id="kobo.255.1">Paper trading is essential because this is the only test that may prove that the strategy is able to practically make money, </span><a id="_idIndexMarker077"/><span class="koboSpan" id="kobo.256.1">not only in theory. </span><span class="koboSpan" id="kobo.256.2">Remember our discussion regarding modeling and forecasting in the previous sections? </span><span class="koboSpan" id="kobo.256.3">It is possible (and not really difficult) to build a model that perfectly trades in the past but is helpless in production. </span><span class="koboSpan" id="kobo.256.4">So, any trading app requires a certain period of paper trading to check whether it can make money in </span><span class="No-Break"><span class="koboSpan" id="kobo.257.1">real life.</span></span></p>
<h2 id="_idParaDest-41"><a id="_idTextAnchor040"/><span class="koboSpan" id="kobo.258.1">Backtesting and paper trading in Python</span></h2>
<p><span class="koboSpan" id="kobo.259.1">Python itself is very </span><a id="_idIndexMarker078"/><span class="koboSpan" id="kobo.260.1">convenient for backtesting and paper trading because of its </span><a id="_idIndexMarker079"/><span class="koboSpan" id="kobo.261.1">capabilities for interactive computing and ready-made </span><a id="_idIndexMarker080"/><span class="koboSpan" id="kobo.262.1">libraries for data handling and visualization. </span><span class="koboSpan" id="kobo.262.2">We can </span><a id="_idIndexMarker081"/><span class="koboSpan" id="kobo.263.1">write an order execution simulator and collect cumulative data about returns from our trades in a dataset – this will take some time and effort, but is then so easy to analyze: from statistical methods to </span><a id="_idIndexMarker082"/><span class="koboSpan" id="kobo.264.1">visual representation, which is most widely known as </span><strong class="bold"><span class="koboSpan" id="kobo.265.1">equity curve</span></strong><span class="koboSpan" id="kobo.266.1">. </span><span class="koboSpan" id="kobo.266.2">All this can be done interactively by issuing a single command in </span><span class="No-Break"><span class="koboSpan" id="kobo.267.1">the console.</span></span></p>
<p><span class="koboSpan" id="kobo.268.1">In this book, we will focus on the architecture of trading applications and, therefore, mostly consider </span><a id="_idIndexMarker083"/><span class="koboSpan" id="kobo.269.1">solutions based on native Python structures as our </span><a id="_idIndexMarker084"/><span class="koboSpan" id="kobo.270.1">goal is to understand all stages of developing a trading </span><a id="_idIndexMarker085"/><span class="koboSpan" id="kobo.271.1">app going down to the core logical structures. </span><span class="koboSpan" id="kobo.271.2">However, as is </span><a id="_idIndexMarker086"/><span class="koboSpan" id="kobo.272.1">the case with data handling, there are open source and free libraries and frameworks that facilitate backtesting in Python, making it even more attractive for the development of trading strategies. </span><span class="koboSpan" id="kobo.272.2">A detailed review or tutorial on any of these products is beyond the scope of this book but you will be able to easily incorporate any of them into your workflow once you understand the research and </span><span class="No-Break"><span class="koboSpan" id="kobo.273.1">development process.</span></span></p>
<h3><span class="koboSpan" id="kobo.274.1">PyAlgoTrade</span></h3>
<p><span class="koboSpan" id="kobo.275.1">PyAlgoTrade is a framework with which you can develop full-featured trading strategies. </span><span class="koboSpan" id="kobo.275.2">It is quite a mature </span><a id="_idIndexMarker087"/><span class="koboSpan" id="kobo.276.1">product, as it was one of the first in this class, and it is still actively maintained and developed. </span><span class="koboSpan" id="kobo.276.2">It follows the modular ideology of designing a trading application. </span><span class="koboSpan" id="kobo.276.3">So, you can first develop a strategy, backtest it, then switch the data source to live data, paper-trade, and finally switch the output from emulated order execution to the broker of your choice and trade live. </span><span class="koboSpan" id="kobo.276.4">It supports free data sources such as Yahoo! </span><span class="koboSpan" id="kobo.276.5">Finance and Google Finance, but if you want to use PyAlgoTrade for forex trading, you will have to obtain data from a third party source, save it in CSV format, and only then use the data with </span><span class="No-Break"><span class="koboSpan" id="kobo.277.1">this framework.</span></span></p>
<p><span class="koboSpan" id="kobo.278.1">It’s important to note that PyAlgoTrade supports real-time Twitter event handling, which means that you can use rules based on non-price data for your strategies (such as </span><em class="italic"><span class="koboSpan" id="kobo.279.1">“when an ECB member says something, sell </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.280.1">the euro”</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.281.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.282.1">You will find the project page located </span><span class="No-Break"><span class="koboSpan" id="kobo.283.1">here: </span></span><a href="https://github.com/gbeced/pyalgotrade&#13;"><span class="No-Break"><span class="koboSpan" id="kobo.284.1">github.com/gbeced/pyalgotrade</span></span><span class="No-Break"><span class="koboSpan" id="kobo.285.1">.</span></span></a></p>
<h3><span class="koboSpan" id="kobo.286.1">bt – backtesting for Python</span></h3>
<p><span class="koboSpan" id="kobo.287.1">bt is another framework </span><a id="_idIndexMarker088"/><span class="koboSpan" id="kobo.288.1">for backtesting that is more focused on portfolio trading (running many different strategies and trading many different markets </span><span class="No-Break"><span class="koboSpan" id="kobo.289.1">in parallel).</span></span></p>
<p><span class="koboSpan" id="kobo.290.1">This approach brings bt close to various visual constructors of trading strategies that were popular some time ago. </span><span class="koboSpan" id="kobo.290.2">Of course, this speeds up the development process dramatically as you don’t need to code the algos on a low level; you only select the most appropriate from the inventory. </span><span class="koboSpan" id="kobo.290.3">However, this advantage is clearly a shortcoming as well because you are limited to using what the developers of the framework </span><span class="No-Break"><span class="koboSpan" id="kobo.291.1">considered suitable.</span></span></p>
<p><span class="koboSpan" id="kobo.292.1">However, the good news here is that, unlike visual constructors, you can modify anything in bt and write your own </span><em class="italic"><span class="koboSpan" id="kobo.293.1">building blocks</span></em><span class="koboSpan" id="kobo.294.1">, which gives you almost the same freedom as writing your own strategies </span><span class="No-Break"><span class="koboSpan" id="kobo.295.1">from scratch.</span></span></p>
<p><span class="koboSpan" id="kobo.296.1">bt also offers a comprehensive suite of statistical tools to analyze the strategy or portfolio performance and also to quickly try various combinations of trading algorithms to discover the one that works best in the </span><span class="No-Break"><span class="koboSpan" id="kobo.297.1">particular market.</span></span></p>
<p><span class="koboSpan" id="kobo.298.1">This framework is </span><a id="_idIndexMarker089"/><span class="koboSpan" id="kobo.299.1">predominantly focused on backtesting and paper trading, so you will need to develop your own order generation and submission module if you plan to trade live from the </span><span class="No-Break"><span class="koboSpan" id="kobo.300.1">same application.</span></span></p>
<p><span class="koboSpan" id="kobo.301.1">You will find the project page located </span><span class="No-Break"><span class="koboSpan" id="kobo.302.1">here: </span></span><a href="https://pmorissette.github.io/bt&#13;"><span class="No-Break"><span class="koboSpan" id="kobo.303.1">pmorissette.github.io/bt</span></span><span class="No-Break"><span class="koboSpan" id="kobo.304.1">.</span></span></a></p>
<h3><span class="koboSpan" id="kobo.305.1">Zipline</span></h3>
<p><span class="koboSpan" id="kobo.306.1">Zipline is probably the most well-known research and development tool for trading strategies. </span><span class="koboSpan" id="kobo.306.2">It was </span><a id="_idIndexMarker090"/><span class="koboSpan" id="kobo.307.1">developed by Quantopian, the famous project that offered any developer an opportunity to become a quantitative trader by providing them with an environment for developing trading strategies. </span><span class="koboSpan" id="kobo.307.2">It even allocated some capital to them in case the strategy performance was proven to </span><span class="No-Break"><span class="koboSpan" id="kobo.308.1">be acceptable.</span></span></p>
<p><span class="koboSpan" id="kobo.309.1">Zipline can be used as a framework and as a standalone application, an algorithmic trading constructor and simulator with paper and live trading capabilities. </span><span class="koboSpan" id="kobo.309.2">You can interact with it using the browser-based iPython </span><span class="No-Break"><span class="koboSpan" id="kobo.310.1">Notebook interface.</span></span></p>
<p><span class="koboSpan" id="kobo.311.1">Zipline comes with 10 years of 1-minute-resolution historical US stock data. </span><span class="koboSpan" id="kobo.311.2">This is not much, and definitely not relevant to forex trading, but it supports importing data in various formats so you can use third-party data, for example, from </span><span class="No-Break"><span class="koboSpan" id="kobo.312.1">your broker.</span></span></p>
<p><span class="koboSpan" id="kobo.313.1">As Zipline was designed as part of Quantopian’s ecosystem, its live trading capabilities </span><span class="No-Break"><span class="koboSpan" id="kobo.314.1">are limited.</span></span></p>
<p><span class="koboSpan" id="kobo.315.1">Despite the initial success of Quantopian and quite some hype in the media, in 2020, the company went </span><a id="_idIndexMarker091"/><span class="koboSpan" id="kobo.316.1">bankrupt and shut down all operations. </span><span class="koboSpan" id="kobo.316.2">Zipline was then sold to Robinhood. </span><span class="koboSpan" id="kobo.316.3">But the new owners were not interested in the development of the product as much as its creators, so the project now exists mainly in form of enthusiast-supported forks, the “official” version not being supported </span><span class="No-Break"><span class="koboSpan" id="kobo.317.1">any longer.</span></span></p>
<p><span class="koboSpan" id="kobo.318.1">You will find </span><a id="_idIndexMarker092"/><span class="koboSpan" id="kobo.319.1">the project page located </span><span class="No-Break"><span class="koboSpan" id="kobo.320.1">here: </span></span><a href="https://zipline.io&#13;"><span class="No-Break"><span class="koboSpan" id="kobo.321.1">zipline.io</span></span><span class="No-Break"><span class="koboSpan" id="kobo.322.1">.</span></span></a></p>
<p><span class="koboSpan" id="kobo.323.1">You will find the GitHub source </span><span class="No-Break"><span class="koboSpan" id="kobo.324.1">here: </span></span><a href="https://github.com/quantopian/zipline&#13;"><span class="No-Break"><span class="koboSpan" id="kobo.325.1">github.com/quantopian/zipline</span></span><span class="No-Break"><span class="koboSpan" id="kobo.326.1">.</span></span></a></p>
<h3><span class="koboSpan" id="kobo.327.1">QSTrader</span></h3>
<p><span class="koboSpan" id="kobo.328.1">QSTrader was developed </span><a id="_idIndexMarker093"/><span class="koboSpan" id="kobo.329.1">by QuantStart. </span><span class="koboSpan" id="kobo.329.2">It is, again, a framework for research and development with live </span><span class="No-Break"><span class="koboSpan" id="kobo.330.1">trading capabilities.</span></span></p>
<p><span class="koboSpan" id="kobo.331.1">This framework strictly follows the modular principle of building trading applications that we already saw in the previous chapter, which is the main focus throughout this book. </span><span class="koboSpan" id="kobo.331.2">This helps streamline the general development process – </span><strong class="bold"><span class="koboSpan" id="kobo.332.1">research</span></strong><span class="koboSpan" id="kobo.333.1"> | </span><strong class="bold"><span class="koboSpan" id="kobo.334.1">backtesting</span></strong><span class="koboSpan" id="kobo.335.1"> | </span><strong class="bold"><span class="koboSpan" id="kobo.336.1">paper trading</span></strong><span class="koboSpan" id="kobo.337.1"> | </span><strong class="bold"><span class="koboSpan" id="kobo.338.1">live trading</span></strong><span class="koboSpan" id="kobo.339.1"> – because the code responsible for the strategy logic remains </span><span class="No-Break"><span class="koboSpan" id="kobo.340.1">the same.</span></span></p>
<p><span class="koboSpan" id="kobo.341.1">Currently, QSTrader supports bar-based data but tick data can also </span><span class="No-Break"><span class="koboSpan" id="kobo.342.1">be used.</span></span></p>
<p><span class="koboSpan" id="kobo.343.1">You will find </span><a id="_idIndexMarker094"/><span class="koboSpan" id="kobo.344.1">the project page located </span><span class="No-Break"><span class="koboSpan" id="kobo.345.1">here: </span></span><a href="https://www.quantstart.com/qstrader/&#13;"><span class="No-Break"><span class="koboSpan" id="kobo.346.1">https://www.quantstart.com/qstrader/</span></span><span class="No-Break"><span class="koboSpan" id="kobo.347.1">.</span></span></a></p>
<p><span class="koboSpan" id="kobo.348.1">You will find the Github source </span><span class="No-Break"><span class="koboSpan" id="kobo.349.1">here: </span></span><a href="https://github.com/mhallsmoore/qstrader&#13;"><span class="No-Break"><span class="koboSpan" id="kobo.350.1">github.com/mhallsmoore/qstrader</span></span><span class="No-Break"><span class="koboSpan" id="kobo.351.1">.</span></span></a></p>
<h1 id="_idParaDest-42"><a id="_idTextAnchor041"/><span class="koboSpan" id="kobo.352.1">The disadvantages of using Python in trading strategy development</span></h1>
<p><span class="koboSpan" id="kobo.353.1">Having praised </span><a id="_idIndexMarker095"/><span class="koboSpan" id="kobo.354.1">the advantages of using Python in algo trading, it’s time to mention its important shortcomings. </span><span class="koboSpan" id="kobo.354.2">As with many robust and universal ecosystems, these shortcomings are the other side of </span><span class="No-Break"><span class="koboSpan" id="kobo.355.1">its advantages.</span></span></p>
<p><span class="koboSpan" id="kobo.356.1">By any means, the most annoying thing about Python is speed, or, rather, the lack of it. </span><span class="koboSpan" id="kobo.356.2">Partly this is pre-determined by the fact that Python is an interpreted language; however, a much greater contribution to the overall slowness is made by weak typing and the same advanced memory management that we love so much when we </span><span class="No-Break"><span class="koboSpan" id="kobo.357.1">develop code.</span></span></p>
<p><span class="koboSpan" id="kobo.358.1">For readers who are not familiar with memory management, I’d recommend starting with a simple article at </span><a href="https://www.geeksforgeeks.org/memory-management-in-python/"><span class="koboSpan" id="kobo.359.1">https://www.geeksforgeeks.org/memory-management-in-python/</span></a><span class="koboSpan" id="kobo.360.1">, which also has references for further reading. </span><span class="koboSpan" id="kobo.360.2">In brief, if the language relieves the coder of the burden of declaring variables, then every time the variable is referenced, a number of routines are executed to make sure the reference is done correctly. </span><span class="koboSpan" id="kobo.360.3">Of course, this slows down the execution of the </span><span class="No-Break"><span class="koboSpan" id="kobo.361.1">entire code.</span></span></p>
<p><span class="koboSpan" id="kobo.362.1">The main part of trading strategy development where insufficient speed of code execution </span><a id="_idIndexMarker096"/><span class="koboSpan" id="kobo.363.1">becomes apparent is backtesting. </span><span class="koboSpan" id="kobo.363.2">During a backtest, we should process all historical data at a resolution granular enough for the specific strategy, and sometimes, this may be as low as raw tick data. </span><span class="koboSpan" id="kobo.363.3">As you may remember, the amount of such data may reach thousands of ticks per second, so just imagine how many times we would repeat the entire strategy logic in a loop processing each tick received in the </span><span class="No-Break"><span class="koboSpan" id="kobo.364.1">last year!</span></span></p>
<p><span class="koboSpan" id="kobo.365.1">But during the research and development phase, this slowness may be just annoying: indeed, no one is happy to wait for minutes, sometimes hours, and, in the worst cases, days to see the theoretical performance of their strategy. </span><span class="koboSpan" id="kobo.365.2">However, waiting too long is one thing, and being unable to place trades in production is completely different, and live trading is exactly where Python faces </span><span class="No-Break"><span class="koboSpan" id="kobo.366.1">its limits.</span></span></p>
<h1 id="_idParaDest-43"><a id="_idTextAnchor042"/><span class="koboSpan" id="kobo.367.1">Live trading – where Python faces its limits</span></h1>
<p><span class="koboSpan" id="kobo.368.1">Thus said, trading applications written in pure Python are not suitable for any live trading </span><a id="_idIndexMarker097"/><span class="koboSpan" id="kobo.369.1">activity that assumes the minimization of time from the moment market data is received to the moment an order is sent. </span><span class="koboSpan" id="kobo.369.2">Therefore, traditional arbitrage and many high-frequency trading activities (which sometimes suggest sending thousands of orders </span><em class="italic"><span class="koboSpan" id="kobo.370.1">per second</span></em><span class="koboSpan" id="kobo.371.1">) are definitely not </span><span class="No-Break"><span class="koboSpan" id="kobo.372.1">for Python.</span></span></p>
<p><span class="koboSpan" id="kobo.373.1">Besides that, there is another risk even for </span><em class="italic"><span class="koboSpan" id="kobo.374.1">slow</span></em><span class="koboSpan" id="kobo.375.1"> trading strategies that derive from automated memory management. </span><span class="koboSpan" id="kobo.375.2">We already know that trading strategies rely on price time series and the amount of processed market data may be quite large. </span><span class="koboSpan" id="kobo.375.3">Although both native Python and third-party libraries such as pandas offer data structures that ensure data persistence, it may become problematic to update data on the fly, especially in trading environments with </span><span class="No-Break"><span class="koboSpan" id="kobo.376.1">high throughputs.</span></span></p>
<p><span class="koboSpan" id="kobo.377.1">There are different ways to speed </span><a id="_idIndexMarker098"/><span class="koboSpan" id="kobo.378.1">up Python to some extent. </span><span class="koboSpan" id="kobo.378.2">There are static compilers such as Cython (</span><a href="https://cython.org"><span class="koboSpan" id="kobo.379.1">https://cython.org</span></a><span class="koboSpan" id="kobo.380.1">), which help execute the Python code faster and write C extensions for Python as well. </span><span class="koboSpan" id="kobo.380.2">There are runtime translators such as Numba (</span><a href="https://numba.pydata.org"><span class="koboSpan" id="kobo.381.1">https://numba.pydata.org</span></a><span class="koboSpan" id="kobo.382.1">), which also help execute Python code at speeds comparable to C. </span><span class="koboSpan" id="kobo.382.2">It also helps to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.383.1">numpy</span></strong><span class="koboSpan" id="kobo.384.1"> structures instead of pandas because, at the cost of </span><a id="_idIndexMarker099"/><span class="koboSpan" id="kobo.385.1">reduced convenience in some aspects, we have a gain in speed. </span><span class="koboSpan" id="kobo.385.2">However, in this book, we won’t really focus on this problem because we start with less latency-critical, more simplistic strategies that help us to understand the development of trading apps </span><span class="No-Break"><span class="koboSpan" id="kobo.386.1">in general.</span></span></p>
<p><span class="koboSpan" id="kobo.387.1">To summarize, we can say that the Python ecosystem is an excellent tool for the research and </span><a id="_idIndexMarker100"/><span class="koboSpan" id="kobo.388.1">development of trading strategies of any kind. </span><span class="koboSpan" id="kobo.388.2">It can also be used for live automated trading if the trading strategy meets the following </span><span class="No-Break"><span class="koboSpan" id="kobo.389.1">two criteria:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.390.1">It doesn’t require large amounts of market data to be received in </span><span class="No-Break"><span class="koboSpan" id="kobo.391.1">real time</span></span></li>
<li><span class="koboSpan" id="kobo.392.1">It is not sensitive to internal latency (a delay between data reception and </span><span class="No-Break"><span class="koboSpan" id="kobo.393.1">order submission)</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.394.1">In this book, we will mostly focus on using Python for research, development, and </span><span class="No-Break"><span class="koboSpan" id="kobo.395.1">simulated trading.</span></span></p>
<h1 id="_idParaDest-44"><a id="_idTextAnchor043"/><span class="koboSpan" id="kobo.396.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.397.1">In this chapter, we considered the pros and cons of using Python for algorithmic trading strategy research and development. </span><span class="koboSpan" id="kobo.397.2">We considered various options for using native Python data structures to handle market data. </span><span class="koboSpan" id="kobo.397.3">We learned about the various ecosystems, third-party libraries, and environments that speed up the development process. </span><span class="koboSpan" id="kobo.397.4">We also learned about the most important phases of development and the essential procedures that aim to make sure that the strategy has the potential to make money in </span><span class="No-Break"><span class="koboSpan" id="kobo.398.1">live markets.</span></span></p>
<p><span class="koboSpan" id="kobo.399.1">However, as with any project in any domain, before we can proceed to actual coding, we should get acquainted with the subject. </span><span class="koboSpan" id="kobo.399.2">In our case, it is the market itself, its basic elements, structure, and the organization that we will consider in order to see how it operates and what we should take into account to build robust trading applications. </span><span class="koboSpan" id="kobo.399.3">This is what we are going to do in the very </span><span class="No-Break"><span class="koboSpan" id="kobo.400.1">next chapter.</span></span></p>
</div>
</body></html>