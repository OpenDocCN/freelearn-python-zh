<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-29"><a id="_idTextAnchor028"/>2</h1>
<h1 id="_idParaDest-30"><a id="_idTextAnchor029"/>Using Python for Trading Strategies</h1>
<p>Python has gained a reputation as the language of choice for the development of a wide range of applications in the financial industry and has become a de facto industry standard for the research phase of trading strategy development. However, as with any other language or, better put, programming ecosystem, it has its advantages and disadvantages. So, as with any tool, it is essential to understand its strong and weak points to use the tool properly (not trying to hammer nails with a microscope, so to say).</p>
<p>In this chapter, not only will we consider using Python for algorithmic trading strategy development but we will also learn about the essential steps in the research and development process, discuss the difference between market modeling and event-based trading, and point to the mistakes most typically made in the research and development process. Finally, we will see the limitations of using Python for algo trading so our expectations always meet reality.</p>
<p>We will quickly dive a bit deeper than just a surface overview to see how the strongest advantages of Python, such as native language structures and efficient <strong class="bold">object-oriented programming</strong> (<strong class="bold">OOP</strong>), help make the code transparent and keep the architecture of a trading app modular, flexible, and scalable.</p>
<p>By the end of this chapter, you will be familiar with the key concepts of trading and algo trading, applications of Python, and various <strong class="bold">integrated development environments</strong> (<strong class="bold">IDEs</strong>) for the research and development of trading strategies, and you will know the limits beyond which using Python is not efficient.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>The advantages of using Python in trading strategy development</li>
<li>Modeling – forecasting the future doesn’t necessarily mean practical benefits</li>
<li>Paper trading and backtesting – an essential part of a systemic trader’s risk management</li>
<li>The disadvantages of using Python in trading strategy development</li>
<li>Live trading – where Python faces its limits</li>
</ul>
<h1 id="_idParaDest-31"><a id="_idTextAnchor030"/>Technical requirements</h1>
<p>You will need Python 3.10 or higher to run the code in this chapter.</p>
<h1 id="_idParaDest-32"><a id="_idTextAnchor031"/>The advantages of using Python in trading strategy development</h1>
<p>Today when we say <em class="italic">Python</em>, we most likely mean not only the most flexible object-oriented <a id="_idIndexMarker046"/>programming language but also the most powerful and convenient interactive IDEs, such as Spyder or PyCharm, along with the vast collection of libraries that extend this language to fit virtually any domain of applied and fundamental research, from medicine to astronomy. There is no surprise that the Python ecosystem has become the de facto standard in the financial industry where numbers play a decisive role.</p>
<p>The advantages of using Python for the development of trading strategies are obvious and we will look into a few of these advantages in detail in the following sections.</p>
<h2 id="_idParaDest-33"><a id="_idTextAnchor032"/>Memory management</h2>
<p>Python is one of the <a id="_idIndexMarker047"/>few interpreters that has robust built-in memory management services such as garbage collection and reference counting. Essentially, this means that you don’t have to care about any complex object you work with and the amount of data processed by your code. Of course, this dramatically increases the development speed, especially if you work with large datasets – and trading applications work with large datasets.</p>
<h2 id="_idParaDest-34"><a id="_idTextAnchor033"/>Interactive computing</h2>
<p>Python <a id="_idIndexMarker048"/>is an interpreted language and this means two important things.</p>
<p>First, you can stop executing the code at any moment and check the environment at runtime, including all variables, functions, and objects – which is convenient for debugging.</p>
<p>Second, you can work with Python interactively. This means that in all Unix-like systems, we run Python in a console where we can send commands one by one and immediately get responses from the interpreter. If you develop trading applications, this allows you to quickly test some modules on small datasets before integrating them into the final code. It also allows you to quickly visualize any portion of a data set on the fly without rewriting and rerunning any code, which is invaluable for developing any applications that work with time series.</p>
<p>Working in a native console is not as convenient as in IPython – a command shell that supports <a id="_idIndexMarker049"/>introspection, rich media, syntax highlighting, tab completion, and history. Released in 2001 as an open source <a id="_idIndexMarker050"/>project, IPython quickly transformed Python into a direct competitor to Matlab, and thanks to the open source status and enormous community of contributors we can say that today, Python has won the competition. In 2014, a spin-off project based on IPython started with the idea of developing a universal interactive computing <a id="_idIndexMarker051"/>environment suitable not only for Python but also for other languages. This project was called Jupyter and today this is probably the most popular notebook-style interactive computing environment. Sometimes Jupyter is even considered a replacement for IPython; however, this is not really correct. DataCamp published an excellent article that explains the difference: <a href="https://www.datacamp.com/blog/ipython-or-jupyter&#13;">https://www.datacamp.com/blog/ipython-or-jupyter.</a></p>
<h2 id="_idParaDest-35"><a id="_idTextAnchor034"/>Ease of integration and routing</h2>
<p>If the previous <a id="_idIndexMarker052"/>two advantages are not specific to the development of trading applications, then what makes Python the preferred language for both trading research and development is the ease with which you can switch between <em class="italic">research mode</em> and <em class="italic">production mode</em>.</p>
<p>If you have carefully planned your data structures and codes (and this is what we will be learning to do throughout this book), then all essential modules of the trading app (which we drafted in the previous chapter) will be independent and replaceable. What advantage does this give you as a developer? The advantages are as follows:</p>
<ul>
<li>It allows you to develop the trading logic using historical data and then replace the data source with a live stream from the broker.</li>
<li>It allows you to fine-tune and debug your application by simulating order execution and letting you switch to production using the same code you used for development. This reduces the risk of errors.</li>
<li>It allows you to scale your trading business by adding more execution venues, protocols, APIs, and trading accounts, keeping the rest of the code the same.</li>
</ul>
<p>Besides that, thanks to the interactivity of the Python environment, you can even intervene in <a id="_idIndexMarker053"/>the trading process manually. For example, you can send a <code>FIX</code> message to close all open positions in case of an emergency. Of course, this is <em class="italic">not</em> the best practice, or even something that can be recommended, but knowing that even in the worst unexpected scenario you can take urgent action straight from the familiar development environment adds to peace of mind.</p>
<h2 id="_idParaDest-36"><a id="_idTextAnchor035"/>Native language structures – lists and dictionaries</h2>
<p>One of the <a id="_idIndexMarker054"/>key advantages of using Python for data processing is that it natively implements two powerful structures: lists and dictionaries.</p>
<p>Trading applications work with time series, and having convenient tools to read, access, compress, and process this data is crucial. Using lists and dictionaries along with objects becomes quite efficient. Let’s consider an example.</p>
<p>Imagine we have tick data and want to transform it into OHLC data points (see the previous chapter for an explanation of OHLC). We can define such a data point, which in trading is normally called a <em class="italic">bar</em>, as follows:</p>
<pre class="source-code">
class OHLC:
        def __init__(self, O, H, L, C):
                self.open = O
                self.high = H
                self.low = L
                self.close = C</pre>
<p>Then, we can create storage for our bars:</p>
<pre class="source-code">
class time_series:
        def __init__(self):
                self.ts = []
                self.last = -1
        def add(self, bar):
                self.ts.append(bar)
        def read(self):
                self.last += 1
                return self.ts[self.last]</pre>
<p>Here, we <a id="_idIndexMarker055"/>can define a native Python list where we store OHLC bars and the <code>self.last</code> pointer, which points to the last element that was read from the list. Then, we will add the <code>read</code> method, which returns the element to which the <code>self.last</code> pointer points.</p>
<p>Then, instead of retrieving OHLC bars by index in the production code as follows:</p>
<pre class="source-code">
data = time_series()
i = some_index
price = data.ts[i].close</pre>
<p>We will retrieve closing prices without direct reference to the index:</p>
<pre class="source-code">
data = time_series()
price = data.read().close</pre>
<p>This streamlines working with time series (or any data series) dramatically as we no longer need to store indices in the main code and even more importantly – we reduce the risk of <em class="italic">peeking ahead</em>. Peek ahead is a common error in trading strategy development. While doing backtests, the strategy code must use only past and current price data for each emulated trade. For example, if the strategy emulates the market on April 1st, it should not refer to price data from April 2nd. The same is applied to any time resolution, down to milliseconds. Strategies that use future data in the research phase, normally, are unable to work in real life (see<em class="italic"> </em><a href="B19145_05.xhtml#_idTextAnchor086"><em class="italic">Chapter 5</em></a><em class="italic">, Retrieving and Handling Market Data with Python,</em> for a detailed discussion on proper data handling when performing backtests). It is impossible to overvalue the convenience with which Python allows you to avoid critical errors such as this, as these errors may cost real and substantial money.</p>
<p>Dictionaries offer another way to store and process series data in Python. As each data point, be it a <a id="_idIndexMarker056"/>tick or a bar, has a timestamp, we can use timestamps as keys in a dictionary:</p>
<pre class="source-code">
class OHLC:
        def __init__(self, dt, O, H, L, C):
                self.datetime = dt
                self.open = O
                self.high = H
                self.low = L
                self.close = C
class time_series:
        def __init__(self):
                self.ts = {}
        def add(self, bar):
                self.ts[bar.datetime] = bar</pre>
<p>Then, retrieving a particular <code>close</code> price by its <code>timestamp</code> value will be simple with the following code:</p>
<pre class="source-code">
price = data.ts[timestamp].close</pre>
<p>So, even native Python language structures offer a quick, simple, and extremely efficient way to handle data specific to trading. However, it is libraries that make Python the definite choice for quantitative trading.</p>
<h2 id="_idParaDest-37"><a id="_idTextAnchor036"/>Libraries</h2>
<p>The ultimate success of Python as the environment for quantitative finance and trading is determined <a id="_idIndexMarker057"/>by a number of libraries, which today are de facto industry standards and sometimes are so tightly associated with the language itself that many developers do not think about them separately. Let us look into some of these libraries.</p>
<h3>NumPy</h3>
<p>Originally released in 1995 as Numeric Python, this library is used today in virtually any application that <a id="_idIndexMarker058"/>uses mathematics. It was the very library that transformed Python <a id="_idIndexMarker059"/>from just a programming language into a Matlab-like, powerful, number-crunching suite.</p>
<p>NumPy offers implementations for a number of core objects from linear algebra such as vectors, arrays, and operations with them. It offers comprehensive mathematical functions, random number generators, Fourier transforms, and more. Best of all – its core is written in C, so all native <code>numpy</code> methods work blazingly fast.</p>
<h3>Matplotlib</h3>
<p>Matplotlib was released <a id="_idIndexMarker060"/>in 2003 as the universal plotting library for Python and NumPy. It <a id="_idIndexMarker061"/>recognizes native NumPy objects and produces print-quality images of almost any type of chart used in mathematics.</p>
<p>What makes Matplotlib especially attractive for trading app development are the following features:</p>
<ul>
<li>It automatically scales data series to fit the chart, so it’s extremely easy to visualize any market or trading data with a single command</li>
<li>The charts are embeddable and can be output in consoles such as IPython or Jupyter</li>
<li>The charts are interactive, so you can zoom in, zoom out, and drag to explore details without needing to write your own image-handling tools</li>
</ul>
<h3>pandas</h3>
<p>It is believed that the name <strong class="bold">pandas</strong> is derived from <strong class="bold">panel data</strong>, a term used in econometrics. It <a id="_idIndexMarker062"/>can also be understood as <strong class="bold">Python Analysis of Data</strong>. This is a <a id="_idIndexMarker063"/>library that introduces the concept of DataFrames. You can think about a <a id="_idIndexMarker064"/>DataFrame as a hybrid of a Python dictionary, list, and <a id="_idIndexMarker065"/>database. It uses keywords to access records but preserves the order of items so data can be retrieved by indexing. At the same time, it features routines typical for databases, such as making subsets or slices.</p>
<p>On top of DataFrames, pandas offers tools to read and write data between in-memory structures and different file formats, including CSV, JSON, SQL queries and tables, and MS Excel, which covers virtually all formats used today by data vendors, brokers, and exchanges.</p>
<p>If we also take into consideration the fact that pandas offers a variety of powerful functions that can rebuild missing data, generate datetime ranges, convert sampling frequencies, support sliding window statistics, and many more – you understand that you get the ultimate toolbox for developing any kind of trading application.</p>
<p>While covering pandas in all its powerful aspects is well beyond the scope of this book, we will consider a few useful applications of pandas in <a href="B19145_08.xhtml#_idTextAnchor130"><em class="italic">Chapter 8</em></a>, <em class="italic">Data Visualization in FX Trading </em><em class="italic">with Python</em>.</p>
<p>NumPy and matplotlib are parts of SciPy – a comprehensive library for any applied mathematics, from optimization and linear algebra to signal processing and multidimensional image processing.</p>
<h1 id="_idParaDest-38"><a id="_idTextAnchor037"/>Modeling – forecasting the future doesn’t necessarily mean practical benefits</h1>
<p>In order to keep the discussion consistent, we need to draw a thin but solid line between trading and modeling. Sometimes, these two terms are seriously confused and may lead not only to misunderstanding but also to losing money.</p>
<p>Modeling is a research activity <a id="_idIndexMarker066"/>that aims at building a model that explains the observed data. For example, Ptolemy developed a geocentric model of the Solar System, whereas Nicolaus Copernicus suggested a model of the Earth spinning around its own axis and traveling around the Sun on an elliptical orbit – now known as the heliocentric model. Both models explain the observed data: that the Sun visually moves around the Earth, that day follows night, and that seasons change in order. However, the heliocentric model proved to be far more precise and easy to use, so the other one was abandoned.</p>
<p>In the financial world, modeling a market means finding a set of quantitative rules that explain the observed <a id="_idIndexMarker067"/>price behavior. At first glance, it looks like modeling any other physical process, for example, the same solar motion. The main problem with financial modeling, especially in trading, is that the modeled process is non-stationary.</p>
<p>In very simple terms, a <strong class="bold">non-stationary process</strong> doesn’t have a constant mean value or consistent <a id="_idIndexMarker068"/>distribution of values across time. This is the very reason for the eventual failure of any attempt to use classical statistics, from averages to Gaussian distribution, to calculate fair prices or predict anything in the future. This is the very reason why many modern approaches that involve elements of machine learning, especially based on linear regression, also fail in practical trading.</p>
<p>If you are interested in learning more about non-stationary processes, including what they are and what makes successful statistics-based trading so problematic, then I’d recommend starting with a basic article from Investopedia: <a href="https://www.investopedia.com/articles/trading/07/stationary.asp">https://www.investopedia.com/articles/trading/07/stationary.asp</a>. Or, if you are more advanced in mathematics, there is an excellent book by M. B. Priestley, <em class="italic">Non-linear and Non-stationary Time </em><em class="italic">Series Analysis</em>.</p>
<p>Back to the point – modeling non-stationary data is not only problematic but also often provides practically useless results. In the case of a stationary process, such as the Earth going around the Sun, we can use our model to predict the future – and will be correct in the absolute majority of cases. But with a non-stationary process, most models will perfectly explain past data, data that had already been observed, but will have problems forecasting future observations. So, in my opinion, the realm of market modeling is academic research, and using it for practical active trading is questionable. I know that there are opposite opinions, but nevertheless, in this book, we will focus only on event-driven trading.</p>
<p>The difference in approaches is that with market modeling, we try to predict future price movements and then follow the forecast to make trading decisions while in event-driven trading, we wait for a certain event to happen and then react immediately by placing an order. For example, if we run an arbitrage strategy, then we wait for the (rare) moment when the asset is mispriced. If we run a directional trading strategy, we wait for a moment when certain economic news is released or prices start to change rapidly, or vice versa – when <a id="_idIndexMarker069"/>the market is slow, but anyway – the strategy reacts to what is going on in the market <em class="italic">right now</em>, without <em class="italic">predicting</em> or <em class="italic">forecasting</em> anything.</p>
<h3>scikit-learn</h3>
<p>Nevertheless, some of the inventory traditionally used in market modeling, especially machine learning, can be quite useful in event-driven trading strategies as part of data pre-processing. Therefore, we should mention at least one more Python library that is another de facto industry standard for data science.</p>
<p><strong class="bold">scikit-learn</strong> or <strong class="bold">sklearn</strong> is a library with implementations of the most popular techniques used in data <a id="_idIndexMarker070"/>science and machine learning. It includes easy-to-use implementations of classification, regression, clustering, and preprocessing along with model selection algorithms (cross-validation, grid search, and more). Having such a robust library also adds to the choice of Python as the preferred ecosystem for the development of trading strategies.</p>
<p>Now that we have familiarized ourselves with the diversity of powerful features offered by Python and numerous libraries, it’s time to dig a bit deeper into the process of research and development that is typical for any kind of algo trading strategy.</p>
<h1 id="_idParaDest-39"><a id="_idTextAnchor038"/>Paper trading and backtesting – an essential part of a systemic trader’s risk management</h1>
<p>Imagine that we have used all the power of Python and developed a trading application. Now what? Is it time to immediately launch it and try earning some money? No! Before jumping in the pool, it’s essential to make sure there’s water in it, and in our case before putting the app into production, it’s essential that it can make money, at least in theory.</p>
<p>In this section, we’ll consider paper trading and backtesting – two cornerstones of systematic trading <a id="_idIndexMarker071"/>that help us understand potential pitfalls with the newly developed <a id="_idIndexMarker072"/>strategy. We will learn about historical data, trade simulation, and ordering, and we’ll also quickly consider some ready-made packages that simplify this part of the development.</p>
<h2 id="_idParaDest-40"><a id="_idTextAnchor039"/>What are paper trading and backtesting?</h2>
<p>After we have developed a trading algorithm, connected to the data source, and are ready to send orders, it’s time to test our setup. Such a test validates the following crucial points:</p>
<ul>
<li>The consistency of the trading logic</li>
<li>Risk management</li>
<li>Ordering interface and handling errors</li>
</ul>
<p>If a test is <a id="_idIndexMarker073"/>performed using past market data (mostly referred to as <strong class="bold">historical data</strong>) with orders sent to a simulation engine, then it is called <strong class="bold">backtesting</strong>. If the test is <a id="_idIndexMarker074"/>performed using live market data with orders sent to the UAT <a id="_idIndexMarker075"/>environment (provided by the broker, trading venue, or again emulated locally), then it is called <strong class="bold">paper trading</strong>.</p>
<p>The purpose of backtesting is to see how our strategy would have reacted to various market situations <a id="_idIndexMarker076"/>in the past. This is absolutely essential because all systematic trading is built around the idea that if a certain situation happened in the past, then most likely it will repeat in the future. For example, if the non-farm payroll is way lower than expectations, stock prices go down for some time. This is confirmed by many years of historical data. So, we may assume that next time it is too low, stock prices will go down again.</p>
<p>Paper trading is essential because this is the only test that may prove that the strategy is able to practically make money, <a id="_idIndexMarker077"/>not only in theory. Remember our discussion regarding modeling and forecasting in the previous sections? It is possible (and not really difficult) to build a model that perfectly trades in the past but is helpless in production. So, any trading app requires a certain period of paper trading to check whether it can make money in real life.</p>
<h2 id="_idParaDest-41"><a id="_idTextAnchor040"/>Backtesting and paper trading in Python</h2>
<p>Python itself is very <a id="_idIndexMarker078"/>convenient for backtesting and paper trading because of its <a id="_idIndexMarker079"/>capabilities for interactive computing and ready-made <a id="_idIndexMarker080"/>libraries for data handling and visualization. We can <a id="_idIndexMarker081"/>write an order execution simulator and collect cumulative data about returns from our trades in a dataset – this will take some time and effort, but is then so easy to analyze: from statistical methods to <a id="_idIndexMarker082"/>visual representation, which is most widely known as <strong class="bold">equity curve</strong>. All this can be done interactively by issuing a single command in the console.</p>
<p>In this book, we will focus on the architecture of trading applications and, therefore, mostly consider <a id="_idIndexMarker083"/>solutions based on native Python structures as our <a id="_idIndexMarker084"/>goal is to understand all stages of developing a trading <a id="_idIndexMarker085"/>app going down to the core logical structures. However, as is <a id="_idIndexMarker086"/>the case with data handling, there are open source and free libraries and frameworks that facilitate backtesting in Python, making it even more attractive for the development of trading strategies. A detailed review or tutorial on any of these products is beyond the scope of this book but you will be able to easily incorporate any of them into your workflow once you understand the research and development process.</p>
<h3>PyAlgoTrade</h3>
<p>PyAlgoTrade is a framework with which you can develop full-featured trading strategies. It is quite a mature <a id="_idIndexMarker087"/>product, as it was one of the first in this class, and it is still actively maintained and developed. It follows the modular ideology of designing a trading application. So, you can first develop a strategy, backtest it, then switch the data source to live data, paper-trade, and finally switch the output from emulated order execution to the broker of your choice and trade live. It supports free data sources such as Yahoo! Finance and Google Finance, but if you want to use PyAlgoTrade for forex trading, you will have to obtain data from a third party source, save it in CSV format, and only then use the data with this framework.</p>
<p>It’s important to note that PyAlgoTrade supports real-time Twitter event handling, which means that you can use rules based on non-price data for your strategies (such as <em class="italic">“when an ECB member says something, sell </em><em class="italic">the euro”</em>).</p>
<p>You will find the project page located here: <a href="https://github.com/gbeced/pyalgotrade&#13;">github.com/gbeced/pyalgotrade.</a></p>
<h3>bt – backtesting for Python</h3>
<p>bt is another framework <a id="_idIndexMarker088"/>for backtesting that is more focused on portfolio trading (running many different strategies and trading many different markets in parallel).</p>
<p>This approach brings bt close to various visual constructors of trading strategies that were popular some time ago. Of course, this speeds up the development process dramatically as you don’t need to code the algos on a low level; you only select the most appropriate from the inventory. However, this advantage is clearly a shortcoming as well because you are limited to using what the developers of the framework considered suitable.</p>
<p>However, the good news here is that, unlike visual constructors, you can modify anything in bt and write your own <em class="italic">building blocks</em>, which gives you almost the same freedom as writing your own strategies from scratch.</p>
<p>bt also offers a comprehensive suite of statistical tools to analyze the strategy or portfolio performance and also to quickly try various combinations of trading algorithms to discover the one that works best in the particular market.</p>
<p>This framework is <a id="_idIndexMarker089"/>predominantly focused on backtesting and paper trading, so you will need to develop your own order generation and submission module if you plan to trade live from the same application.</p>
<p>You will find the project page located here: <a href="https://pmorissette.github.io/bt&#13;">pmorissette.github.io/bt.</a></p>
<h3>Zipline</h3>
<p>Zipline is probably the most well-known research and development tool for trading strategies. It was <a id="_idIndexMarker090"/>developed by Quantopian, the famous project that offered any developer an opportunity to become a quantitative trader by providing them with an environment for developing trading strategies. It even allocated some capital to them in case the strategy performance was proven to be acceptable.</p>
<p>Zipline can be used as a framework and as a standalone application, an algorithmic trading constructor and simulator with paper and live trading capabilities. You can interact with it using the browser-based iPython Notebook interface.</p>
<p>Zipline comes with 10 years of 1-minute-resolution historical US stock data. This is not much, and definitely not relevant to forex trading, but it supports importing data in various formats so you can use third-party data, for example, from your broker.</p>
<p>As Zipline was designed as part of Quantopian’s ecosystem, its live trading capabilities are limited.</p>
<p>Despite the initial success of Quantopian and quite some hype in the media, in 2020, the company went <a id="_idIndexMarker091"/>bankrupt and shut down all operations. Zipline was then sold to Robinhood. But the new owners were not interested in the development of the product as much as its creators, so the project now exists mainly in form of enthusiast-supported forks, the “official” version not being supported any longer.</p>
<p>You will find <a id="_idIndexMarker092"/>the project page located here: <a href="https://zipline.io&#13;">zipline.io.</a></p>
<p>You will find the GitHub source here: <a href="https://github.com/quantopian/zipline&#13;">github.com/quantopian/zipline.</a></p>
<h3>QSTrader</h3>
<p>QSTrader was developed <a id="_idIndexMarker093"/>by QuantStart. It is, again, a framework for research and development with live trading capabilities.</p>
<p>This framework strictly follows the modular principle of building trading applications that we already saw in the previous chapter, which is the main focus throughout this book. This helps streamline the general development process – <strong class="bold">research</strong> | <strong class="bold">backtesting</strong> | <strong class="bold">paper trading</strong> | <strong class="bold">live trading</strong> – because the code responsible for the strategy logic remains the same.</p>
<p>Currently, QSTrader supports bar-based data but tick data can also be used.</p>
<p>You will find <a id="_idIndexMarker094"/>the project page located here: <a href="https://www.quantstart.com/qstrader/&#13;">https://www.quantstart.com/qstrader/.</a></p>
<p>You will find the Github source here: <a href="https://github.com/mhallsmoore/qstrader&#13;">github.com/mhallsmoore/qstrader.</a></p>
<h1 id="_idParaDest-42"><a id="_idTextAnchor041"/>The disadvantages of using Python in trading strategy development</h1>
<p>Having praised <a id="_idIndexMarker095"/>the advantages of using Python in algo trading, it’s time to mention its important shortcomings. As with many robust and universal ecosystems, these shortcomings are the other side of its advantages.</p>
<p>By any means, the most annoying thing about Python is speed, or, rather, the lack of it. Partly this is pre-determined by the fact that Python is an interpreted language; however, a much greater contribution to the overall slowness is made by weak typing and the same advanced memory management that we love so much when we develop code.</p>
<p>For readers who are not familiar with memory management, I’d recommend starting with a simple article at <a href="https://www.geeksforgeeks.org/memory-management-in-python/">https://www.geeksforgeeks.org/memory-management-in-python/</a>, which also has references for further reading. In brief, if the language relieves the coder of the burden of declaring variables, then every time the variable is referenced, a number of routines are executed to make sure the reference is done correctly. Of course, this slows down the execution of the entire code.</p>
<p>The main part of trading strategy development where insufficient speed of code execution <a id="_idIndexMarker096"/>becomes apparent is backtesting. During a backtest, we should process all historical data at a resolution granular enough for the specific strategy, and sometimes, this may be as low as raw tick data. As you may remember, the amount of such data may reach thousands of ticks per second, so just imagine how many times we would repeat the entire strategy logic in a loop processing each tick received in the last year!</p>
<p>But during the research and development phase, this slowness may be just annoying: indeed, no one is happy to wait for minutes, sometimes hours, and, in the worst cases, days to see the theoretical performance of their strategy. However, waiting too long is one thing, and being unable to place trades in production is completely different, and live trading is exactly where Python faces its limits.</p>
<h1 id="_idParaDest-43"><a id="_idTextAnchor042"/>Live trading – where Python faces its limits</h1>
<p>Thus said, trading applications written in pure Python are not suitable for any live trading <a id="_idIndexMarker097"/>activity that assumes the minimization of time from the moment market data is received to the moment an order is sent. Therefore, traditional arbitrage and many high-frequency trading activities (which sometimes suggest sending thousands of orders <em class="italic">per second</em>) are definitely not for Python.</p>
<p>Besides that, there is another risk even for <em class="italic">slow</em> trading strategies that derive from automated memory management. We already know that trading strategies rely on price time series and the amount of processed market data may be quite large. Although both native Python and third-party libraries such as pandas offer data structures that ensure data persistence, it may become problematic to update data on the fly, especially in trading environments with high throughputs.</p>
<p>There are different ways to speed <a id="_idIndexMarker098"/>up Python to some extent. There are static compilers such as Cython (<a href="https://cython.org">https://cython.org</a>), which help execute the Python code faster and write C extensions for Python as well. There are runtime translators such as Numba (<a href="https://numba.pydata.org">https://numba.pydata.org</a>), which also help execute Python code at speeds comparable to C. It also helps to use <code>numpy</code> structures instead of pandas because, at the cost of <a id="_idIndexMarker099"/>reduced convenience in some aspects, we have a gain in speed. However, in this book, we won’t really focus on this problem because we start with less latency-critical, more simplistic strategies that help us to understand the development of trading apps in general.</p>
<p>To summarize, we can say that the Python ecosystem is an excellent tool for the research and <a id="_idIndexMarker100"/>development of trading strategies of any kind. It can also be used for live automated trading if the trading strategy meets the following two criteria:</p>
<ul>
<li>It doesn’t require large amounts of market data to be received in real time</li>
<li>It is not sensitive to internal latency (a delay between data reception and order submission)</li>
</ul>
<p>In this book, we will mostly focus on using Python for research, development, and simulated trading.</p>
<h1 id="_idParaDest-44"><a id="_idTextAnchor043"/>Summary</h1>
<p>In this chapter, we considered the pros and cons of using Python for algorithmic trading strategy research and development. We considered various options for using native Python data structures to handle market data. We learned about the various ecosystems, third-party libraries, and environments that speed up the development process. We also learned about the most important phases of development and the essential procedures that aim to make sure that the strategy has the potential to make money in live markets.</p>
<p>However, as with any project in any domain, before we can proceed to actual coding, we should get acquainted with the subject. In our case, it is the market itself, its basic elements, structure, and the organization that we will consider in order to see how it operates and what we should take into account to build robust trading applications. This is what we are going to do in the very next chapter.</p>
</div>
</body></html>