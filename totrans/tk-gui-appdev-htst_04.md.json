["```py\nfrom Tkinter import *\nclass GUI():\n  rows = 8\n  columns = 8\n  color1 = \"#DDB88C\"\n  color2 = \"#A66D4F\"\n  dim_square = 64\n  def __init__(self, parent):\n       self.parent = parent\n       canvas_width = self.columns * self.dim_square\n       canvas_height = self.rows * self.dim_square\n       self.canvas = Canvas(parent, width=canvas_width, height=canvas_height, background=\"grey\")\n       self.canvas.pack(padx=8, pady=8)\n self.draw_board()\n\n```", "```py\ndef draw_board(self):\n     color = self.color2\n     for r in range(self.rows):\n       color = self.color1 if color == self.color2 \n\t   else self.color2 # alternating between two colors\n       for c in range(self.columns):\n             x1 = (c * self.dim_square)\n             y1 = ((7-r) * self.dim_square)\n             x2 = x1 + self.dim_square\n             y2 = y1 + self.dim_square\n             self.canvas.create_rectangle(x1, y1, x2, y2, fill=color, tags=\"area\")\n             color = self.color1 if color == self.color2 else self.color2\n```", "```py\ndef main():\n     root = Tk()\n     root.title(\"Chess\")\n     gui = GUI(root)\n     root.mainloop()\nif __name__ == \"__main__\":\n     main()\n```", "```py\n>>> import Tkinter\n>>> help(Tkinter.Canvas) \n\n```", "```py\nclass Piece():\n  def __init__(self, color):\n     if color == 'black':\n        self.shortname = self.shortname.lower()\n     elif color == 'white':\n        self.shortname = self.shortname.upper()\n     self.color = color\n\n  def ref(self, board):\n   ''' Get a reference of chessboard instance'''\n     self.board = board\n```", "```py\nclass King(Piece):    shortname = 'k'\nclass Queen(Piece):    shortname = 'q'\nclass Rook(Piece):    shortname = 'r'\nclass Knight(Piece):    shortname = 'n'\nclass Bishop(Piece):    shortname = 'b'\nclass Pawn(Piece):   shortname = 'p'\n```", "```py\nimport sys\nSHORT_NAME = {'R':'Rook', 'N':'Knight', 'B':'Bishop', 'Q':'Queen', 'K':'King', 'P':'Pawn'}\ndef create_piece(piece, color='white'):\n     if piece in (None, ''): return\n     if piece.isupper(): color = 'white'\n     else: color = 'black'\n     piece = SHORT_NAME[piece.upper()]\n     module = sys.modules[__name__]\n     return module.__dict__[piece](color)\n```", "```py\nimport pieces\nimport re\nSTART_PATTERN = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w 0 1'\nclass Board(dict):\n     y_axis = ('A', 'B', 'C', 'D', 'E', 'F', 'G', 'H')\n     x_axis = (1,2,3,4,5,6,7,8)\n     def __init__(self, patt = None):\n        self.process_notation(START_PATTERN)\n```", "```py\ndef process_notation(self, patt):\n   self.clear()\n   patt = patt.split('')\n      # expand_whitespaces blanks\n\ndef expand_whitespaces(match): return '' * int(match.group(0))\n   patt[0] = re.compile(r'\\d').sub(expand_whitespaces, patt[0])\n   for x, row in enumerate(patt[0].split('/')):\n     for y, alphabet in enumerate(row):\n        if alphabet == '': continue\n        xycoord = self.alpha_notation((7-x,y))\n        self[xycoord] = pieces.piece(alphabet)\n        self[xycoord].ref(self)\n     if patt[1] == 'w': self.player_turn = 'white'\n     else: self.player_turn = 'black'\n```", "```py\ndef is_on_board(self, coord):\n     ifcoord[1] < 0 or coord[1] > 7 or coord[0] < 0 or coord[0] >7:\n        return False\n     else: return True\n```", "```py\ndef alpha_notation(self,xycoord):\n     if not self.is_on_board(xycoord): return\n     return self.y_axis[xycoord[1]] + str(self.x_axis[xycoord[0]])\n```", "```py\ndef num_notation(self, xycoord):\n     return int(xycoord[1])-1, self.y_axis.index(xycoord[0])\n```", "```py\ndef occupied(self, color):\n     result = []\n     for coord in self:\n        if self[coord].color == color:\n           result.append(coord)\n           return result\n```", "```py\nclassChessError(Exception): pass\n```", "```py\nfrom PIL import ImageTk\n```", "```py\ndef draw_pieces(self): \n   self.canvas.delete(\"occupied\")\n   for xycoord, piece in self.chessboard.iteritems():\n     x,y = self.chessboard.num_notation(xycoord)\n     if piece is not None:\n        filename = \"../pieces_image/%s%s.png\" % (piece.shortname.lower(), piece.color)\n        piecename = \"%s%s%s\" % (piece.shortname, x, y)\n        if (filename not in self.images):\n           self.images[filename] = ImageTk.PhotoImage(file=filename)\n        self.canvas.create_image(0,0, image=self.images[filename], tags=(piecename, \"occupied\"), anchor=\"c\")\n        x0 = (y * self.dim_square) + int(self.dim_square/2)\n        y0 = ((7-x) * self.dim_square) + int(self.dim_square/2)\n        self.canvas.coords(piecename, x0, y0)\n```", "```py\n    def moves_available(self, pos, diagonal, orthogonal, distance):\n        board = self.board\n        allowed_moves = []\n        orth  = ((-1,0),(0,-1),(0,1),(1,0))\n        diag  = ((-1,-1),(-1,1),(1,-1),(1,1))\n        piece = self\n        beginningpos = board.num_notation(pos.upper())\n        if orthogonal and diagonal:\n            directions = diag+orth\n        elif diagonal:\n            directions = diag\n        elif orthogonal:\n            directions = orth\n\n        for x,y in directions:\n            collision = False\n            for step in range(1, distance+1):\n                if collision: break\n                dest = beginningpos[0]+step*x, beginningpos[1]+step*y\n                if self.board.alpha_notation(dest) not in board.occupied('white') + board.occupied('black'):\n                    allowed_moves.append(dest)\n                elif self.board.alpha_notation(dest) in board.occupied(piece.color):\n                    collision = True\n                else:\n                    allowed_moves.append(dest)\n                    collision = True\n        allowed_moves = filter(board.is_on_board, allowed_moves)\n        return map(board.alpha_notation, allowed_moves)\n```", "```py\nclass King(Piece):\n   shortname = 'k'\n   def moves_available(self,pos):\n     return super(King, self).moves_available(pos.upper(), True, True, 1)\nclass Queen(Piece):\n   shortname = 'q'\n   def moves_available(self,pos):\n     return super(Queen,self).moves_available(pos.upper(), True, True, 8)\nclass Rook(Piece):\n   shortname = 'r'\n   def moves_available(self,pos):\n     return super(Rook, self).moves_available(pos.upper(), False, True, 8)\nclass Bishop(Piece):\n   shortname = 'b'\n   def moves_available(self,pos):\n     return super(Bishop,self).moves_available(pos.upper(), True, False, 8)\n```", "```py\nclass Knight(Piece):\n   shortname = 'n'\n   def moves_available(self,pos):\n     board = self.board\n     allowed_moves = []\n     beginningpos = board.num_notation(pos.upper())\n     piece = board.get(pos.upper())\n     changes=((-2,-1),(-2,1),(-1,-2),(-1,2),(1,-2),(1,2),(2,-1),(2,1))\n     for x,y in changes:\n        dest = beginningpos[0]+x, beginningpos[1]+y\n        if(board.alpha_notation(dest) not in board.occupied(piece.color)):\n           allowed_moves.append(dest)\n        allowed_moves = filter(board.is_on_board, allowed_moves)\n     return map(board.alpha_notation, allowed_moves)\n```", "```py\nclass Pawn(Piece):\n    shortname = 'p'\n    def moves_available(self, pos):\n        board = self.board        \n        piece = self\n        if self.color == 'white':\n            startpos, direction, enemy = 1, 1, 'black'\n        else:\n            startpos, direction, enemy = 6, -1, 'white'\n        allowed_moves = []\n        prohibited = board.occupied('white') + board.occupied('black')\n        beginningpos   = board.num_notation(pos.upper())\n        forward = beginningpos[0] + direction, beginningpos[1]\n        # Can a piece move forward?\n        if board.alpha_notation(forward) not in prohibited:\n            allowed_moves.append(forward)\n            if beginningpos[0] == startpos:\n                # If pawn in starting pos allow a double move\n                double_forward = (forward[0] + direction, forward[1])\n                if board.alpha_notation(double_forward) not in prohibited:\n                    allowed_moves.append(double_forward)\n        # Check for Capturing Moves Available\n        for a in range(-1, 2, 2):\n            attack = beginningpos[0] + direction, beginningpos[1] + a\n            if board.letter_notation(attack) in board.occupied(enemy):\n                allowed_moves.append(attack)\n        allowed_moves = filter(board.is_on_board, allowed_moves)\n        return map(board.alpha_notation, allowed_moves)\n```", "```py\ndef all_moves_available(self, color):\n   result = []\n   for coord in self.keys():\n     if (self[coord] is not None) and self[coord].color == color:\n        moves = self[coord].moves_available(coord)\n        if moves: result += moves\n   return result\n```", "```py\ndef position_of_king(self, color):\n   for pos in self.keys():\n     if is instance(self[pos], pieces.King) and self[pos].color == color:\n        return pos\n```", "```py\ndef king_in_check(self, color):\n   kingpos =  self.position_of_king(color)\n   opponent = ('black' if color =='white' else 'white')\n   for pieces in self.iteritems():\n     if kingpos in self.all_moves_available(opponent):\n        return True\n     else:\n        return False\n```", "```py\ndef show(self, pat):\n        self.clear()\n        pat = pat.split(' ')\n        def expand(match): return ' ' * int(match.group(0))\n        pat[0] = re.compile(r'\\d').sub(expand, pat[0])\n        for x, row in enumerate(pat[0].split('/')):\n            for y, letter in enumerate(row):\n                if letter == ' ': continue\n                coord = self.alpha_notation((7-x,y))\n                self[coord] = pieces.create_piece(letter)\n                self[coord].place(self)\n        if pat[1] == 'w': self.player_turn = 'white'\n        else: self.player_turn = 'black'\n        self.halfmove_clock = int(pat[2])\n        self.fullmove_number = int(pat[3])\n```", "```py\nself.canvas.bind(\"<Button-1>\", self.square_clicked)\n```", "```py\nclass GUI:\n   pieces = {}\n   selected_piece = None\n   focused = None\n   #other attributes from previous iterations\n```", "```py\ndef square_clicked(self, event):\n   col_size = row_size = self.dim_square\n   selected_column = event.x / col_size\n   selected_row = 7 - (event.y / row_size)\n   pos = self.chessboard.alpha_notation((selected_row, selected_column))\n   try:\n     piece = self.chessboard[pos]\n   except:\n     pass\n   if self.selected_piece:\n      self.shift(self.selected_piece[1], pos)\n      self.selected_piece = None\n      self.focused = None\n      self.pieces = {}\n      self.draw_board()\n      self.draw_pieces()\n   self.focus(pos)\n   self.draw_board()\n```", "```py\ndef shift(self, p1, p2):\n   piece = self.chessboard[p1]\n   try:\n     dest_piece = self.chessboard[p2]\n   except:\n     dest_piece = None\n   if dest_piece is None or dest_piece.color != piece.color:\n     try:\n        self.chessboard.shift(p1, p2)\n     except:\n        pass\n```", "```py\ndef focus(self, pos):\n   try:\n     piece = self.chessboard[pos]\n   except:\n     piece=None\n   if piece is not None and (piece.color == self.chessboard.player_turn):\n     self.selected_piece = (self.chessboard[pos], pos)\n     self.focused = map(self.chessboard.num_notation, (self.chessboard[pos].moves_available(pos)))\n```", "```py\nhighlightcolor =\"khaki\"\ndef draw_board(self):\n    color = self.color2\n    for row in range(self.rows):\n     color = self.color1 if color == self.color2 else self.color2\n     for col in range(self.columns):\n        x1 = (col * self.dim_square)\n        y1 = ((7-row) * self.dim_square)\n        x2 = x1 + self.dim_square\n        y2 = y1 + self.dim_square\n if(self.focused is not None and (row, col) in self.focused):\n self.canvas.create_rectangle(x1, y1, x2, y2, fill=self.highlightcolor, tags=\"area\")\n        else:\n           self.canvas.create_rectangle(x1, y1, x2, y2, fill=color, tags=\"area\")\n           color = self.color1 if color == self.color2 else self.color2\n for name in self.pieces:\n self.pieces[name] = (self.pieces[name][0], self.pieces[name][1])\n x0 = (self.pieces[name][1] * self.dim_square) + int(self.dim_square/2)\n y0 = ((7-self.pieces[name][0]) * self.dim_square) + int(self.dim_square/2)\n self.canvas.coords(name, x0, y0)\n self.canvas.tag_raise(\"occupied\")\n self.canvas.tag_lower(\"area\")\n\n```", "```py\nClass Board(dict):\n   #other attributes from previous iteration\n   captured_pieces = { 'white': [], 'black': [] }\n   player_turn = None\n   halfmove_clock = 0\n   fullmove_number = 1\n   history = []\n```", "```py\n    def shift(self, p1, p2):\n        p1, p2 = p1.upper(), p2.upper()\n        piece = self[p1]\n        try:\n            dest  = self[p2]\n        except:\n            dest = None\n        if self.player_turn != piece.color:\n            raise NotYourTurn(\"Not \" + piece.color + \"'s turn!\")\n        enemy = ('white' if piece.color == 'black' else 'black' )\n        moves_available = piece.moves_available(p1)\n        if p2 not in moves_available:\n            raise InvalidMove\n        if self.all_moves_available(enemy):\n            if self.is_in_check_after_move(p1,p2):\n                raise Check\n        if not moves_available and self.king_in_check(piece.color):\n            raise CheckMate\n        elif not moves_available:\n            raise Draw\n        else:\n            self.move(p1, p2)\n            self.complete_move(piece, dest, p1,p2)\n```", "```py\n    def is_in_check_after_move(self, p1, p2):\n        temp = deepcopy(self)\n        temp.unvalidated_move(p1,p2)\n        returntemp.king_in_check(self[p1].color)\n    ```", "```py\ndef move(self, p1, p2):\n   piece = self[p1]\n   try:\n     dest = self[p2]\n   except:\n     pass\n\n   del self[p1]\n   self[p2] = piece\n```", "```py\n    def complete_move(self, piece, dest, p1, p2):\n        enemy = ('white' if piece.color == 'black' else 'black' )\n        if piece.color == 'black':\n            self.fullmove_number += 1\n        self.halfmove_clock +=1\n        self.player_turn = enemy\n        abbr = piece.shortname\n        if abbr == 'P':\n            abbr = ''\n            self.halfmove_clock = 0\n        if dest is None:\n            movetext = abbr +  p2.lower()\n        else:\n            movetext = abbr + 'x' + p2.lower()\n            self.halfmove_clock = 0\n        self.history.append(movetext)\n```", "```py\nclass Check(ChessError): pass\nclassInvalidMove(ChessError): pass\nclassCheckMate(ChessError): pass\nclass Draw(ChessError): pass\nclassNotYourTurn(ChessError): pass\n```", "```py\ndef __init__(self, parent, chessboard):\n   self.chessboard = chessboard\n   self.parent = parent\n self.menubar = Menu(parent)\n self.filemenu = Menu(self.menubar, tearoff=0)\n self.filemenu.add_command(label=\"New Game\", command=self.new_game)\n self.menubar.add_cascade(label=\"File\", menu=self.filemenu)\n self.parent.config(menu=self.menubar)\n\n```", "```py\nself.btmfrm = Frame(parent, height=64)\nself.info_label = Label(self.btmfrm, text=\"   White to Start the Game  \", fg=self.color2)\nself.info_label.pack(side=RIGHT, padx=8, pady=5)\nself.btmfrm.pack(fill=\"x\", side=BOTTOM)\n```", "```py\ndef new_game(self):\n    self.chessboard.show(chessboard.START_PATTERN)\n    self.draw_board()\n    self.draw_pieces()\n    self.info_label.config(text=\"White to Start the Game\", fg='red')\n```", "```py\ndef shift(self, p1, p2):\n   piece = self.chessboard[p1]\n   try:\n     dest_piece = self.chessboard[p2]\n   except:\n     dest_piece = None\n   if dest_piece is None or dest_piece.color != piece.color:\n     try:\n        self.chessboard.shift(p1,p2)\n exceptchessboard.ChessError as error:\n self.info_label[\"text\"] = error.__class__.__name__\n else:\n turn = ('white' if piece.color == 'black' else 'black')\n self.info_label[\"text\"] = '' + piece.color.capitalize() +\"  :  \"+ p1 + p2 + '' + turn.capitalize() + '\\'s turn'\n\n```"]