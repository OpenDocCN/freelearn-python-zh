- en: '*Chapter 20*: The Decorator Pattern'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw in the previous chapter, using an **adapter**, the first structural
    design pattern, you can adapt an object implementing a given interface to implement
    another interface. This is called **interface** **adaptation** and includes the
    kinds of patterns that encourage composition over inheritance, and it could bring
    benefits when you have to maintain a large codebase.
  prefs: []
  type: TYPE_NORMAL
- en: 'A second interesting structural pattern to learn about is the **decorator**
    pattern, which allows us to add responsibilities to an object dynamically and
    transparently (without affecting other objects); this will be the topic of this
    chapter. Throughout our discussions, we will learn more about a specific usage
    of this design pattern: **memoization**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the decorator pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Real-world examples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code files for this chapter can be accessed through this link: [https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter20](https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter20).'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the decorator pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As Python developers, we can write decorators in a `func_in`, as input and returns
    another function object, `func_out`. It is a commonly used technique for extending
    the behavior of a function, method, or class.
  prefs: []
  type: TYPE_NORMAL
- en: But this feature should not be completely new to you. We have already seen how
    to use the built-in `property` decorator, which makes a method appear as a variable
    in both [*Chapter 16*](B17499_16_Final_SS_ePub.xhtml#_idTextAnchor276), *The Factory
    Pattern*, and [*Chapter 17*](B17499_17_Final_SS_ePub.xhtml#_idTextAnchor289),
    *The Builder Pattern*. There are also several other useful built-in decorators
    in Python. In the *Implementation* section of this chapter, we will learn how
    to implement and use our own decorators.
  prefs: []
  type: TYPE_NORMAL
- en: Note that there is no one-to-one relationship between the decorator pattern
    and Python's decorator feature. Python decorators can actually do much more than
    the decorator pattern. One of the things they can be used for is to implement
    the decorator pattern ([j.mp/moinpydec](http://j.mp/moinpydec)).
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's discuss some examples where the decorator pattern applies.
  prefs: []
  type: TYPE_NORMAL
- en: Real-world examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The decorator pattern is generally used for extending the functionality of an
    object. In everyday life, examples of functionality extensions are adding a holder
    stand to a phone or using different camera lenses.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Django framework, which uses decorators a lot, we have the `View` decorators,
    which can be used for the following ([j.mp/djangodec](http://j.mp/djangodec)):'
  prefs: []
  type: TYPE_NORMAL
- en: Restricting access to views based on the HTTP request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling the caching behavior on specific views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling compression on a per-view basis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling caching based on specific HTTP request headers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Both the Pyramid framework and the Zope application server also use decorators
    to achieve various goals, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Registering a function as an event subscriber
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protecting a method with a specific permission
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the adapter pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To be more concrete, we will iterate the specific use cases of the design pattern
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Use cases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The decorator pattern shines when used for implementing cross-cutting concerns
    ([j.mp/wikicrosscut](http://j.mp/wikicrosscut)). Examples of cross-cutting concerns
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Data validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Caching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Business rules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encryption
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In general, all parts of an application that are generic and can be applied
    to many different parts of it are considered to be cross-cutting concerns.
  prefs: []
  type: TYPE_NORMAL
- en: Another popular example of using the decorator pattern is **graphical user interface**
    (**GUI**) toolkits. In a GUI toolkit, we want to be able to add features such
    as borders, shadows, colors, and scrolling to individual components/widgets.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's move on to the implementation part of the chapter, in which we will
    see how the decorator pattern helps with memoization.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python decorators are generic and very powerful. You can find many examples
    of how they can be used in the decorator library of `python.org` ([j.mp/pydeclib](http://j.mp/pydeclib)).
    In this section, we will see how we can implement a memoization decorator ([j.mp/memoi](http://j.mp/memoi)).
    All recursive functions can benefit from memoization, so let's try a function,
    `number_sum()`, that returns the sum of the first `n` numbers. Note that this
    function is already available in the `math` module as `fsum()`, but let's pretend
    it is not.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s look at the naive implementation (the `number_sum_naive.py` file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'A sample execution of this example shows how slow this implementation is. It
    takes roughly 3 seconds to calculate the sum of the first 30 numbers on a MacBook,
    which can be seen when executing the `python number_sum_naive.py` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Let's see whether using memoization can help us improve the performance number.
    In the following code, we use `dict` for caching the already computed sums. We
    also change the parameter passed to the `number_sum()` function. We want to calculate
    the sum of the first 300 numbers instead of only the first 30.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the new version of the code, using memoization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Executing the memoization-based code shows that performance improves dramatically
    and is acceptable even for computing large values.
  prefs: []
  type: TYPE_NORMAL
- en: 'A sample execution, using `python number_sum.py`, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: But there are already a few problems with this approach. While the performance
    is not an issue any longer, the code is not as clean as it is when not using memoization.
    And what happens if we decide to extend the code with more math functions and
    turn it into a module? We can think of several functions that would be useful
    for our module, for problems such as Pascal's triangle or the Fibonacci numbers
    suite algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if we wanted a function in the same module as `number_sum()`, for the Fibonacci
    numbers suite, using the same memoization technique, we would add code that looks
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Do you notice the problem already? We ended up with a new `dict` called `cache_fib`,
    which acts as our cache for the `fibonacci()` function, and a function that is
    more complex than it would be without using memoization. Our module is becoming
    unnecessarily complex. Is it possible to write these functions keeping them as
    simple as the naive versions, but achieving performance similar to the performance
    of the functions that use memoization?
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, it is, and the solution is to use the decorator pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create a `memoize()` decorator, as shown in the following example.
    Our decorator accepts the `fn` function, which needs to be memoized, as an input.
    It uses `dict` named `cache` as the cached data container. The `functools.wraps()`
    function is used for convenience when creating decorators. It is not mandatory
    but a good practice to use it since it makes sure that the documentation, and
    the signature of the function that is decorated, is preserved ([j.mp/funcwraps](http://j.mp/funcwraps)).
    The `*args` argument list is required in this case because the functions that
    we want to decorate accept input arguments (such as the `n` argument for our two
    functions):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can use our `memoize()` decorator with the naive version of our functions.
    This has the benefit of readable code without performance impact. We apply a decorator
    using what is known as decoration (or a decoration line). A decoration uses the
    `@name` syntax, where `name` is the name of the decorator that we want to use.
    It is nothing more than syntactic sugar for simplifying the usage of decorators.
    We can even bypass this syntax and execute our decorator manually, but that is
    left as an exercise for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the `memoize()` decorator can be used with our recursive functions as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the last part of the code, via the `main()` function, we show how to use
    the decorated functions and measure their performance. The `to_execute` variable
    is used to hold a list of tuples containing the reference to each function and
    the corresponding `timeit.Timer()` call (to execute it while measuring the time
    spent), thus avoiding code repetition. Note how the `__name__` and `__doc__` method
    attributes show the proper function names and documentation values, respectively.
    Try removing the `@functools.wraps(fn)` decoration from `memoize()`, and see whether
    this is still the case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the last part of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s recapitulate how we write the complete code of our math module (the
    `mymath.py` file):'
  prefs: []
  type: TYPE_NORMAL
- en: After the import of Python's `functools` module that we will be using, we define
    the `memoize()` decorator function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we define the `number_sum()` function, decorated using `memoize()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We also define the `fibonacci()` function, as decorated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we add the `main()` function, as shown earlier, and use the usual trick
    to call it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is a sample output when executing the `python mymath.py` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: (The execution times might differ in your case.)
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we end up with readable code and acceptable performance. Now,
    you might argue that this is not the decorator pattern, since we don't apply it
    at runtime. The truth is that a decorated function cannot be undecorated, but
    you can still decide at runtime whether the decorator will be executed or not.
    That's an interesting exercise left for you.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Use a decorator that acts as a wrapper, which decides whether or not the real
    decorator is executed based on some condition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another interesting property of decorators not covered in this chapter is that
    you can decorate a function with more than one decorator. So, here''s another
    exercise: create a decorator that helps you to debug recursive functions, apply
    it to `number_sum()` and `fibonacci()`, and finally, determine the order in which
    the multiple decorators are executed.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covered the decorator pattern and its relationship to the Python
    programming language. We used the decorator pattern conveniently to extend the
    behavior of an object without using inheritance. Python, with its built-in decorator
    feature, extends the decorator concept even more, by allowing us to extend the
    behavior of any callable (function, method, or class) without using inheritance
    or composition.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen a few examples of real-world objects that are decorated, such as
    cameras. From a software point of view, both Django and Pyramid use decorators
    to achieve different goals, such as controlling HTTP compression and caching.
  prefs: []
  type: TYPE_NORMAL
- en: 'The decorator pattern is a great solution for implementing cross-cutting concerns
    because they are generic and do not fit well into the OOP paradigm. We mentioned
    several categories of cross-cutting concerns in the *Use cases* section. In fact,
    in the *Implementation* section, a cross-cutting concern was demonstrated: memoization.
    We saw how decorators can help us to keep our functions clean, without sacrificing
    performance.'
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter covers the bridge pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the main motivation for the decorator pattern?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is the decorator pattern particularly relevant in Python?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does the decorator pattern help with memoization?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
