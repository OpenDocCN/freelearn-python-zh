<html><head></head><body>
<section id="chapter-6-recursions-and-reductions" class="level2 chapterHead" data-number="0.10">&#13;
<h2 class="chapterHead" data-number="0.10"><span class="titlemark">Â 6</span><br/>&#13;
<span id="x1-1260006"/>Recursions and Reductions</h2>&#13;
<p>Many functional programming language compilers will optimize a recursive function to transform a recursive call in the tail of the function to an iteration. This tail-call optimization will dramatically improve performance. Python doesnâ€™t do this automatic tail-call optimization. One consequence is pure recursion suffers from limitations. Lacking an automated optimization, we need to do the tail-call optimization manually. This means rewriting recursion to use an explicit iteration. There are two common ways to do this, and weâ€™ll consider them both in this chapter.</p>&#13;
<p>In previous chapters, weâ€™ve looked at several related kinds of processing design patterns; some of them are as follows:</p>&#13;
<ul>&#13;
<li><p>Mapping and filtering, which create collections from collections</p></li>&#13;
<li><p>Reductions that create a scalar value from a collection</p></li>&#13;
</ul>&#13;
<p>The distinction is exemplified by functions such as <span class="obeylines-h"><span class="verb"><code class="inlineCode">map()</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">filter()</code></span></span> that accomplish the first kind of collection processing. There are some more specialized reduction functions, which include <span class="obeylines-h"><span class="verb"><code class="inlineCode">min()</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">max()</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">len()</code></span></span>, and <span class="obeylines-h"><span class="verb"><code class="inlineCode">sum()</code></span></span>. Thereâ€™s a general-purpose reduction function as well, <span class="obeylines-h"><span class="verb"><code class="inlineCode">functools.reduce()</code></span></span>.</p>&#13;
<p>Weâ€™ll also consider creating a <span class="obeylines-h"><span class="verb"><code class="inlineCode">collections.Counter()</code></span></span> object as a kind of reduction operator. It doesnâ€™t produce a single scalar value <span class="cmti-10x-x-109">per se</span>, but it does create a new organization of the data that eliminates some of the original structure. At heart, itâ€™s a kind of count-group-by operation that has more in common with a counting reduction than with a mapping.</p>&#13;
<p>In this chapter, weâ€™ll look at reduction functions in more detail. From a purely functional perspective, a reduction can be defined recursively. The tail-call optimization techniques available in Python apply elegantly to reductions.</p>&#13;
<p>Weâ€™ll review a number of built-in reduction algorithms including <span class="obeylines-h"><span class="verb"><code class="inlineCode">sum()</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">count()</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">max()</code></span></span>, and <span class="obeylines-h"><span class="verb"><code class="inlineCode">min()</code></span></span>. Weâ€™ll look at the <span class="obeylines-h"><span class="verb"><code class="inlineCode">collections.Counter()</code></span></span> creation and related <span class="obeylines-h"><span class="verb"><code class="inlineCode">itertools.groupby()</code></span></span> reductions. Weâ€™ll also look at how parsing (and lexical scanning) are proper reductions since they transform sequences of tokens (or sequences of characters) into higher-order collections with more complex properties. <span id="x1-126001r128"/></p>&#13;
<section id="simple-numerical-recursions" class="level3 sectionHead" data-number="0.10.1">&#13;
<h3 class="sectionHead" data-number="0.10.1"><span class="titlemark">6.1 </span> <span id="x1-1270001"/>Simple numerical recursions</h3>&#13;
<p>We can consider all numeric<span id="dx1-127001"/> operations<span id="dx1-127002"/> to be defined by recursions. For more details, read about the <span class="keyWord">Peano axioms</span><span id="dx1-127003"/> that define the essential features of numbers at <a href="https://www.britannica.com/science/Peano-axioms" class="url">https://www.britannica.com/science/Peano-axioms</a>.</p>&#13;
<p>From these axioms, we can see that addition is defined recursively using more primitive notions of the next number, or the successor of a number <span class="italic">n</span>, <span class="italic">S</span>(<span class="italic">n</span>).</p>&#13;
<p>To simplify the presentation, weâ€™ll assume that we can define a predecessor function, <span class="italic">P</span>(<span class="italic">n</span>), such that <span class="italic">n </span>= <span class="italic">S</span>(<span class="italic">P</span>(<span class="italic">n</span>)) = <span class="italic">P</span>(<span class="italic">S</span>(<span class="italic">n</span>)), as long as <span class="italic">n</span><span class="italic">â‰ </span>0. This formalizes the idea that a number is the successor of the numberâ€™s predecessor.</p>&#13;
<p>Addition between two natural numbers could be defined recursively as follows:</p>&#13;
<div class="math-display" style="text-align:center">&#13;
<img src="../Images/file48.jpg" class="math-display" alt=" ( |{ add(a,b) = b if a = 0 |( add(P(a),S(b)) if a â„= 0 "/>&#13;
</div>&#13;
<p>If we use the more typical notations of <span class="italic">n </span>+ 1 and <span class="italic">n</span><span class="cmsy-10x-x-109">âˆ’ </span>1 instead of <span class="italic">S</span>(<span class="italic">n</span>) and <span class="italic">P</span>(<span class="italic">n</span>), we can more easily see how the rule add(<span class="italic">a,b</span>) = add(<span class="italic">a </span><span class="cmsy-10x-x-109">âˆ’ </span>1<span class="italic">,b </span>+ 1) when <span class="italic">a</span><span class="italic">â‰ </span>0 works.</p>&#13;
<p>This translates neatly into Python, as shown in the following function definition:</p>&#13;
<pre id="listing-112" class="lstlisting"><code>def add(a: int, b: int) -&gt; int:Â &#13;
Â Â Â Â if a == 0:Â &#13;
Â Â Â Â Â Â Â Â return bÂ &#13;
Â Â Â Â else:Â &#13;
Â Â Â Â Â Â Â Â return add(a - 1, b + 1)</code></pre>&#13;
<p>Weâ€™ve rearranged the abstract mathematical notation into concrete Python.</p>&#13;
<p>Thereâ€™s no good reason to provide our own functions<span id="dx1-127009"/> in Python to do simple addition. We rely on Pythonâ€™s underlying implementation to properly handle arithmetic of various kinds. Our point here is that fundamental scalar arithmetic can be defined recursively, and the definition translates to Python.</p>&#13;
<p>This suggests that more complicated operations, defined recursively, can also be translated to Python. The translation can be manually optimized to create working code that matches the abstract definitions, reducing questions about possible bugs in the implementation.</p>&#13;
<p>A recursive definition must include at least two cases: a non-recursive (or <span class="cmti-10x-x-109">base</span>) case where the value of the function is defined directly, and the recursive case where the value of the function is computed from a recursive evaluation of the function with different argument values.</p>&#13;
<p>In order to be sure the recursion will terminate, itâ€™s important to see how the recursive case computes values that approach the defined non-recursive base case. Pragmatically, there are often constraints on the argument values that weâ€™ve omitted from the functions here. For example, the <span class="obeylines-h"><span class="verb"><code class="inlineCode">add()</code></span></span> function in the preceding command snippet could be expanded to include <span class="obeylines-h"><span class="verb"><code class="inlineCode">assert</code><code class="inlineCode">Â a&gt;=0</code><code class="inlineCode">Â and</code><code class="inlineCode">Â b&gt;=0</code></span></span> to establish two necessary constraints on the input values.</p>&#13;
<p>Without these constraints, starting with <span class="obeylines-h"><span class="verb"><code class="inlineCode">a</code></span></span> equal to -1 wonâ€™t approach the non-recursive case of <span class="obeylines-h"><span class="verb"><code class="inlineCode">a</code><code class="inlineCode">Â ==</code><code class="inlineCode">Â 0</code></span></span> as we keep subtracting 1 from <span class="obeylines-h"><span class="verb"><code class="inlineCode">a</code></span></span>. <span id="x1-127010r131"/></p>&#13;
<section id="implementing-manual-tail-call-optimization" class="level4 subsectionHead" data-number="0.10.1.1">&#13;
<h4 class="subsectionHead" data-number="0.10.1.1"><span class="titlemark">6.1.1 </span> <span id="x1-1280001"/>Implementing manual tail-call optimization</h4>&#13;
<p>For some functions, the recursive<span id="dx1-128001"/> definition is the most succinct and expressive. A common example is the <span class="obeylines-h"><span class="verb"><code class="inlineCode">factorial()</code></span></span> function.</p>&#13;
<p>We can see how this is rewritten as a simple recursive<span id="dx1-128002"/> function in Python from the following formula:</p>&#13;
<div class="math-display" style="text-align:center">&#13;
<img src="../Images/file49.jpg" class="math-display" alt=" ( | { 1 if n = 0 n! = |( n Ã— (nâˆ’ 1)! if n â„= 0 "/>&#13;
</div>&#13;
<p>The preceding formula can be implemented in Python by using the following function definition:</p>&#13;
<pre id="listing-113" class="lstlisting"><code>def fact(n: int) -&gt; int:Â &#13;
Â Â Â Â if n == 0:Â &#13;
Â Â Â Â Â Â Â Â return 1Â &#13;
Â Â Â Â else:Â &#13;
Â Â Â Â Â Â Â Â return n*fact(n-1)</code></pre>&#13;
<p>This implementation has the advantage of simplicity. The recursion limits in Python artificially constrain us; we canâ€™t do anything larger than about <span class="obeylines-h"><span class="verb"><code class="inlineCode">fact(997)</code></span></span>. The value of 1000! has 2,568 digits and generally exceeds our floating-point capacity; on some systems the floating-point limit is near 10<sup><span class="cmr-8">300</span></sup>. Pragmatically, itâ€™s common to switch to a log gamma function instead of working with immense numbers.</p>&#13;
<div id="tcolobox-135" class="infobox note">&#13;
&#13;
&#13;
<p>See <a href="https://functions.wolfram.com/GammaBetaErf/LogGamma/introductions/Gammas/ShowAll.html" class="url">https://functions.wolfram.com/GammaBetaErf/LogGamma/introductions/Gammas/ShowAll.html</a> for more on log gamma functions.</p>&#13;
&#13;
</div>&#13;
<p>We can expand Pythonâ€™s call stack limit to stretch this to the limits of memory. Itâ€™s better, however, to manually optimize these kinds of functions to eliminate the recursion.</p>&#13;
<p>This function demonstrates a typical tail recursion. The last expression in the function is a call to the function with a new argument value. An optimizing compiler can replace the function call stack management with a loop that executes very quickly.</p>&#13;
<p>In this example, the function involves an incremental change from <span class="italic">n </span>to <span class="italic">n </span><span class="cmsy-10x-x-109">âˆ’ </span>1. This means that weâ€™re generating a sequence of numbers and then doing a reduction to compute their product.</p>&#13;
<p>Stepping outside purely functional<span id="dx1-128008"/> processing, we can define an imperative <span class="obeylines-h"><span class="verb"><code class="inlineCode">facti()</code></span></span> calculation as follows:</p>&#13;
<pre id="listing-114" class="lstlisting"><code>def facti(n: int) -&gt; int:Â &#13;
Â Â Â Â if n == 0:Â &#13;
Â Â Â Â Â Â Â Â return 1Â &#13;
Â Â Â Â f = 1Â &#13;
Â Â Â Â for i in range(2, n+1):Â &#13;
Â Â Â Â Â Â Â Â f = f * iÂ &#13;
Â Â Â Â return f</code></pre>&#13;
<p>This version of the factorial function<span id="dx1-128016"/> will compute values beyond 1000! (2000!, for example, has 5,736 digits). This example isnâ€™t purely functional. Weâ€™ve optimized the tail recursion into a stateful <span class="obeylines-h"><span class="verb"><code class="inlineCode">for</code></span></span> statement depending on the <span class="obeylines-h"><span class="verb"><code class="inlineCode">i</code></span></span> variable to maintain the state of the computation.</p>&#13;
<p>In general, weâ€™re obliged to do this in Python because Python canâ€™t automatically do the tail-call optimization. There are situations, however, where this kind of optimization isnâ€™t actually helpful. Weâ€™ll look at a few of them. <span id="x1-128017r135"/></p>&#13;
</section>&#13;
<section id="leaving-recursion-in-place" class="level4 subsectionHead" data-number="0.10.1.2">&#13;
<h4 class="subsectionHead" data-number="0.10.1.2"><span class="titlemark">6.1.2 </span> <span id="x1-1290002"/>Leaving recursion in place</h4>&#13;
<p>In some cases, the recursive<span id="dx1-129001"/> definition is actually optimal. Some recursions involve a <span class="cmti-10x-x-109">divide and conquer </span>strategy<span id="dx1-129002"/> that minimizes the work. One example of this is the algorithm for doing exponentiation by squaring. This works for computing values that have a positive integer exponent, like 2<sup><span class="cmr-8">64</span></sup>. We can state it formally as follows:</p>&#13;
<div class="math-display" style="text-align:center">&#13;
<img src="../Images/file50.jpg" class="math-display" alt=" (| ||| 1 if n = 0 n { (nâˆ’1) a = || a Ã— a if a is odd ||( n2 2 (a ) if a is even "/>&#13;
</div>&#13;
<p>Weâ€™ve broken the process into three cases, easily written in Python as a recursion. Look at the following function definition:</p>&#13;
<pre id="listing-115" class="lstlisting"><code>def fastexp(a: float, n: int) -&gt; float:Â &#13;
Â Â Â Â if n == 0:Â &#13;
Â Â Â Â Â Â Â Â return 1Â &#13;
Â Â Â Â elif n % 2 == 1:Â &#13;
Â Â Â Â Â Â Â Â return a * fastexp(a, n - 1)Â &#13;
Â Â Â Â else:Â &#13;
Â Â Â Â Â Â Â Â t = fastexp(a, n // 2)Â &#13;
Â Â Â Â Â Â Â Â return t * t</code></pre>&#13;
<p>For odd numbers, the <span class="obeylines-h"><span class="verb"><code class="inlineCode">fastexp()</code></span></span> method is defined recursively. The exponent <span class="obeylines-h"><span class="verb"><code class="inlineCode">n</code></span></span> is reduced by 1. A simple tail-recursion optimization<span id="dx1-129011"/> would work for this case. It would not work for the even case, however.</p>&#13;
<p>For even numbers, the <span class="obeylines-h"><span class="verb"><code class="inlineCode">fastexp()</code></span></span> recursion uses <span class="obeylines-h"><span class="verb"><code class="inlineCode">n</code><code class="inlineCode">Â //</code><code class="inlineCode">Â 2</code></span></span>, chopping the problem into half of its original size. Since the problem size is reduced by a factor of 2, this case results in a significant speed-up of the processing.</p>&#13;
<p>We canâ€™t trivially reframe this kind of function into a tail-call optimization loop. Since itâ€™s already optimal, we donâ€™t really need to optimize it further. The recursion limit in Python would impose the constraint of <span class="italic">n </span><span class="cmsy-10x-x-109">â‰¤ </span>2<sup><span class="cmr-8">1000</span></sup>, a generous upper bound. <span id="x1-129012r136"/></p>&#13;
</section>&#13;
<section id="handling-difficult-tail-call-optimization" class="level4 subsectionHead" data-number="0.10.1.3">&#13;
<h4 class="subsectionHead" data-number="0.10.1.3"><span class="titlemark">6.1.3 </span> <span id="x1-1300003"/>Handling difficult tail-call optimization</h4>&#13;
<p>We can look at the definition<span id="dx1-130001"/> of <span class="keyWord">Fibonacci </span>numbers<span id="dx1-130002"/> recursively. The following is one widely used definition<span id="dx1-130003"/> for the <span class="cmti-10x-x-109">n</span><sup><span class="cmr-10">th</span></sup> Fibonacci number, <span class="italic">F</span><sub><span class="cmmi-8">n</span></sub>:</p>&#13;
<div class="math-display" style="text-align:center">&#13;
<img src="../Images/file51.jpg" class="math-display" alt=" (| ||| 0 if n = 0 { Fn = | 1 if n = 1 |||( Fnâˆ’ 1 + Fnâˆ’ 2 if n â‰¥ 2 "/>&#13;
</div>&#13;
<p>A given Fibonacci number, <span class="italic">F</span><sub><span class="cmmi-8">n</span></sub>, is defined as the sum of the previous two numbers, <span class="italic">F</span><sub><span class="cmmi-8">n</span><span class="cmsy-8">âˆ’</span><span class="cmr-8">1</span></sub> + <span class="italic">F</span><sub><span class="cmmi-8">n</span><span class="cmsy-8">âˆ’</span><span class="cmr-8">2</span></sub>. This is an example of multiple<span id="dx1-130004"/> recursion: it canâ€™t be trivially optimized as a simple tail recursion. However, if we donâ€™t optimize it to a tail recursion, weâ€™ll find it to be too slow to be useful.</p>&#13;
<p>The following is a naÃ¯ve implementation:</p>&#13;
<pre id="listing-116" class="lstlisting"><code>def fib(n: int) -&gt; int:Â &#13;
Â Â Â Â if n == 0: return 0Â &#13;
Â Â Â Â if n == 1: return 1Â &#13;
Â Â Â Â return fib(n-1) + fib(n-2)</code></pre>&#13;
<p>This suffers from a terrible multiple<span id="dx1-130009"/> recursion problem. When computing the <span class="obeylines-h"><span class="verb"><code class="inlineCode">fib(n)</code></span></span> value, we must compute the <span class="obeylines-h"><span class="verb"><code class="inlineCode">fib(n-1)</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">fib(n-2)</code></span></span> values. The computation of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">fib(n-1)</code></span></span> value involves a duplicate calculation of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">fib(n-2)</code></span></span> value. The two recursive uses of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">fib()</code></span></span> function will more than duplicate the amount of computation being done.</p>&#13;
<p>Because of the left-to-right Python evaluation rules, we can evaluate values up to about <span class="obeylines-h"><span class="verb"><code class="inlineCode">fib(1000)</code></span></span>. However, we have to be patient. Very patient. (Trying to find the actual upper bound with the default stack size means waiting a long time before the <span class="obeylines-h"><span class="verb"><code class="inlineCode">RecursionError</code></span></span> is raised.)</p>&#13;
<p>The following is one alternative, which restates the entire algorithm to use stateful variables instead of a simple recursion:</p>&#13;
<pre id="listing-117" class="lstlisting"><code>def fibi(n: int) -&gt; int:Â &#13;
Â Â Â Â if n == 0: return 0Â &#13;
Â Â Â Â if n == 1: return 1Â &#13;
Â Â Â Â f_n2, f_n1 = 1, 1Â &#13;
Â Â Â Â for _ in range(2, n):Â &#13;
Â Â Â Â Â Â Â Â f_n2, f_n1 = f_n1, f_n2 + f_n1Â &#13;
Â Â Â Â return f_n1</code></pre>&#13;
<div id="tcolobox-136" class="packt_tip">&#13;
&#13;
&#13;
<p>Our stateful version of this function counts up from 0, unlike the recursion, which counts down from the initial value of <span class="obeylines-h"><span class="verb"><code class="inlineCode">n</code></span></span>. This version is considerably faster than the recursive version.</p>&#13;
&#13;
</div>&#13;
<p>Whatâ€™s important<span id="dx1-130017"/> here is that we couldnâ€™t trivially optimize the <span class="obeylines-h"><span class="verb"><code class="inlineCode">fib()</code></span></span> function recursion<span id="dx1-130018"/> with an obvious rewrite. In order to replace the recursion with an imperative version, we had to look closely at the algorithm to determine how many stateful intermediate variables were required.</p>&#13;
<p>As an exercise for the reader, try using the <span class="obeylines-h"><span class="verb"><code class="inlineCode">@cache</code></span></span> decorator from the <span class="obeylines-h"><span class="verb"><code class="inlineCode">functools</code></span></span> module. What impact does this have? <span id="x1-130019r137"/></p>&#13;
</section>&#13;
<section id="processing-collections-through-recursion" class="level4 subsectionHead" data-number="0.10.1.4">&#13;
<h4 class="subsectionHead" data-number="0.10.1.4"><span class="titlemark">6.1.4 </span> <span id="x1-1310004"/>Processing collections through recursion</h4>&#13;
<p>When working<span id="dx1-131001"/> with a collection, we can also define the processing<span id="dx1-131002"/> recursively. We can, for example, define the <span class="obeylines-h"><span class="verb"><code class="inlineCode">map()</code></span></span> function recursively. The formalism could be stated as follows:</p>&#13;
<div class="math-display" style="text-align:center">&#13;
<img src="../Images/file52.jpg" class="math-display" alt=" ( |{ [] if len(C ) = 0 map (f,C ) = | ( map(f,C [:âˆ’1]) + [f (C âˆ’1)] if len(C ) &gt; 0 "/>&#13;
</div>&#13;
<p>Weâ€™ve defined the mapping of a function, <span class="italic">f</span>, to an empty collection as an empty sequence, <span class="obeylines-h"><span class="verb"><code class="inlineCode">[]</code></span></span>. Weâ€™ve also specified that applying a function to a collection can be defined recursively with a three-step expression. First, recursively perform the mapping of the function to all of the collection except the last element, creating a sequence object. Then apply the function to the last element. Finally, append the last calculation to the previously built sequence.</p>&#13;
<p>Following is a purely recursive function version of this <span class="obeylines-h"><span class="verb"><code class="inlineCode">map()</code></span></span> function:</p>&#13;
<pre id="listing-118" class="lstlisting"><code>from collections.abc import Callable, SequenceÂ &#13;
from typing import Any, TypeVarÂ &#13;
Â &#13;
MapD = TypeVar("MapD")Â &#13;
MapR = TypeVar("MapR")Â &#13;
Â &#13;
def mapr(Â &#13;
Â Â Â Â Â Â Â Â f: Callable[[MapD], MapR],Â &#13;
Â Â Â Â Â Â Â Â collection: Sequence[MapD]Â &#13;
) -&gt; list[MapR]:Â &#13;
Â Â Â Â if len(collection) == 0: return []Â &#13;
Â Â Â Â return mapr(f, collection[:-1]) + [f(collection[-1])]</code></pre>&#13;
<p>The value of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">mapr(f,[])</code></span></span> method is defined to be an empty list object. The value of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">mapr()</code></span></span> function with a non-empty list will apply the function to the last element in the list and append this to the list built recursively<span id="dx1-131015"/> from the <span class="obeylines-h"><span class="verb"><code class="inlineCode">mapr()</code></span></span> function applied to the head of the list.</p>&#13;
<p>We have to emphasize<span id="dx1-131016"/> that this <span class="obeylines-h"><span class="verb"><code class="inlineCode">mapr()</code></span></span> function actually creates a list object. The built-in <span class="obeylines-h"><span class="verb"><code class="inlineCode">map()</code></span></span> function is an iterator; it doesnâ€™t create a list object. It yields the result values as they are computed. Also, the work is done in right-to-left order, which is not the way Python normally works. This is only observable when using a function that has side effects, something weâ€™d like to avoid doing.</p>&#13;
<p>While this is an elegant formalism, it still lacks the tail-call optimization required. An optimization will allow us to exceed the default recursion limit of 1,000 and also performs much more quickly than this naÃ¯ve recursion.</p>&#13;
<p>The use of <span class="obeylines-h"><span class="verb"><code class="inlineCode">Callable[[Any],</code><code class="inlineCode">Â Any]</code></span></span> is a weak type hint. To be more clear, it can help to define a domain type variable and a range type variable. Weâ€™ll include this detail in the optimized example. <span id="x1-131017r138"/></p>&#13;
</section>&#13;
<section id="tail-call-optimization-for-collections" class="level4 subsectionHead" data-number="0.10.1.5">&#13;
<h4 class="subsectionHead" data-number="0.10.1.5"><span class="titlemark">6.1.5 </span> <span id="x1-1320005"/>Tail-call optimization for collections</h4>&#13;
<p>We have two general<span id="dx1-132001"/> ways to handle<span id="dx1-132002"/> collections: we can use a higher-order function that returns a generator expression, or we can create a function that uses a <span class="obeylines-h"><span class="verb"><code class="inlineCode">for</code></span></span> statement to process each item in a collection. These two patterns are very similar.</p>&#13;
<p>Following is a higher-order function that behaves like the built-in <span class="obeylines-h"><span class="verb"><code class="inlineCode">map()</code></span></span> function:</p>&#13;
<pre id="listing-119" class="lstlisting"><code>from collections.abc import Callable, Iterable, IteratorÂ &#13;
from typing import Any, TypeVarÂ &#13;
Â &#13;
DomT = TypeVar("DomT")Â &#13;
RngT = TypeVar("RngT")Â &#13;
Â &#13;
def mapf(Â &#13;
Â Â Â Â Â Â Â Â f: Callable[[DomT], RngT],Â &#13;
Â Â Â Â Â Â Â Â C: Iterable[DomT]Â &#13;
) -&gt; Iterator[RngT]:Â &#13;
Â Â Â Â return (f(x) for x in C)</code></pre>&#13;
<p>Weâ€™ve returned a generator expression that produces the required mapping. This uses the explicit <span class="obeylines-h"><span class="verb"><code class="inlineCode">for</code></span></span> in the generator<span id="dx1-132014"/> expression as a kind of tail-call optimization.</p>&#13;
<p>The source of data, <span class="obeylines-h"><span class="verb"><code class="inlineCode">C</code></span></span>, has a type hint of <span class="obeylines-h"><span class="verb"><code class="inlineCode">Iterable[DomT]</code></span></span> to emphasize that some type, <span class="obeylines-h"><span class="verb"><code class="inlineCode">DomT</code></span></span>, will form the domain for the mapping. The transformation<span id="dx1-132015"/> function has a hint of <span class="obeylines-h"><span class="verb"><code class="inlineCode">Callable[[DomT],</code><code class="inlineCode">Â RngT]</code></span></span> to make it clear that it transforms from some domain type to a range type. The function <span class="obeylines-h"><span class="verb"><code class="inlineCode">float()</code></span></span>, for example, can transform values from the string domain to the float range. The result has the hint of <span class="obeylines-h"><span class="verb"><code class="inlineCode">Iterator[RngT]</code></span></span> to show that it iterates over the range type, <span class="obeylines-h"><span class="verb"><code class="inlineCode">RngT</code></span></span>; the result type of the callable function.</p>&#13;
<p>The following is a generator function with the same signature and result:</p>&#13;
<pre id="listing-120" class="lstlisting"><code>def mapg(Â &#13;
Â Â Â Â Â Â Â Â f: Callable[[DomT], RngT],Â &#13;
Â Â Â Â Â Â Â Â C: Iterable[DomT]Â &#13;
) -&gt; Iterator[RngT]:Â &#13;
Â Â Â Â for x in C:Â &#13;
Â Â Â Â Â Â Â Â yield f(x)</code></pre>&#13;
<p>This uses a complete <span class="obeylines-h"><span class="verb"><code class="inlineCode">for</code></span></span> statement for the tail-call optimization. The results are identical. This version is slightly slower because it involves multiple statements.</p>&#13;
<p>In both cases, the result is an iterator over the results. We must do something else to materialize a sequence object from an iterable source. For example, here is the <span class="obeylines-h"><span class="verb"><code class="inlineCode">list()</code></span></span> function being used to create a sequence from the iterator:</p>&#13;
<div id="tcolobox-137" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; list(mapg(lambda x: 2 ** x, [0, 1, 2, 3, 4]))Â &#13;
[1, 2, 4, 8, 16]</code></pre>&#13;
&#13;
</div>&#13;
<p>For performance and scalability, this kind of tail-call optimization<span id="dx1-132025"/> is required in Python programs. It makes the code less than purely functional. However, the benefit far outweighs the lack of purity. In order to reap the benefits<span id="dx1-132026"/> of succinct and expressive functional design, it is helpful to treat these less-than-pure functions as if they were proper recursions.</p>&#13;
<p>What this means, pragmatically, is that we must avoid cluttering up a collection processing function with additional stateful processing. The central tenets of functional programming are still valid even if some elements of our programs are less than purely functional. <span id="x1-132027r139"/></p>&#13;
</section>&#13;
<section id="using-the-assignment-sometimes-called-the-walrus-operator-in-recursions" class="level4 subsectionHead" data-number="0.10.1.6">&#13;
<h4 class="subsectionHead" data-number="0.10.1.6"><span class="titlemark">6.1.6 </span> <span id="x1-1330006"/>Using the assignment (sometimes called the â€walrusâ€) operator in recursions</h4>&#13;
<p>In some cases, recursions involve<span id="dx1-133001"/> conditional processing that can be optimized<span id="dx1-133002"/> using the â€walrusâ€ or assignment<span id="dx1-133003"/> operator, <span class="obeylines-h"><span class="verb"><code class="inlineCode">:=</code></span></span>. The use of assignment means that weâ€™re introducing stateful variables. If weâ€™re careful of the scope of those variables, the possibility of terribly complex algorithms is reduced.</p>&#13;
<p>We reviewed the <span class="obeylines-h"><span class="verb"><code class="inlineCode">fast_exp()</code></span></span> function shown below in the <a href="#x1-1290002"><span class="cmti-10x-x-109">Leaving recursion in</span> <span class="cmti-10x-x-109">place</span></a> section. This function used three separate cases to implement a <span class="cmti-10x-x-109">divide and</span> <span class="cmti-10x-x-109">conquer </span>strategy. In the case of raising a number, <span class="obeylines-h"><span class="verb"><code class="inlineCode">a</code></span></span>, to an even power, we can use <span class="italic">t </span>= <span class="italic">a</span><sup><img src="../Images/file53.jpg" class="frac" data-align="middle" alt="n 2"/></sup> to compute <span class="italic">t </span><span class="cmsy-10x-x-109">Ã— </span><span class="italic">t </span>= <span class="italic">a</span><sup><span class="cmmi-8">n</span></sup>:</p>&#13;
<pre id="listing-121" class="lstlisting"><code>def fastexp_w(a: float, n: int) -&gt; float:Â &#13;
Â Â Â Â if n == 0:Â &#13;
Â Â Â Â Â Â Â Â return 1Â &#13;
Â Â Â Â else:Â &#13;
Â Â Â Â Â Â Â Â q, r = divmod(n, 2)Â &#13;
Â Â Â Â Â Â Â Â if r == 1:Â &#13;
Â Â Â Â Â Â Â Â Â Â Â Â return a * fastexp_w(a, n - 1)Â &#13;
Â Â Â Â Â Â Â Â else:Â &#13;
Â Â Â Â Â Â Â Â Â Â Â Â return (t := fastexp_w(a, q)) * t</code></pre>&#13;
<p>This uses the <span class="obeylines-h"><span class="verb"><code class="inlineCode">:=</code></span></span> walrus operator<span id="dx1-133013"/> to compute a partial answer, <span class="obeylines-h"><span class="verb"><code class="inlineCode">fastexp_w(a,</code><code class="inlineCode">Â q)</code></span></span>, and save it into a temporary variable, <span class="obeylines-h"><span class="verb"><code class="inlineCode">t</code></span></span>. This is used later in the same statement to compute <span class="obeylines-h"><span class="verb"><code class="inlineCode">t</code><code class="inlineCode">Â *</code><code class="inlineCode">Â t</code></span></span>.</p>&#13;
<p>For the most part, when we perform<span id="dx1-133014"/> tail-call optimization on a recursion, the body of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">for</code></span></span> statement will have ordinary assignment statements. It isnâ€™t often necessary to exploit the walrus operator.</p>&#13;
<p>The assignment<span id="dx1-133015"/> operator is often used in situations like regular expression matching, where we want to save the match object as well as make a decision. Itâ€™s very common to see <span class="obeylines-h"><span class="verb"><code class="inlineCode">if</code><code class="inlineCode">Â (match</code><code class="inlineCode">Â :=</code><code class="inlineCode">Â pattern.match(text)):</code></span></span> as a way to both attempt a regular expression match, save the resulting match object, and confirm itâ€™s not a <span class="obeylines-h"><span class="verb"><code class="inlineCode">None</code></span></span> object. <span id="x1-133016r134"/></p>&#13;
</section>&#13;
</section>&#13;
<section id="reductions-and-folding-a-collection-from-many-items-to-one" class="level3 sectionHead" data-number="0.10.2">&#13;
<h3 class="sectionHead" data-number="0.10.2"><span class="titlemark">6.2 </span> <span id="x1-1340002"/>Reductions and folding a collection from many items to one</h3>&#13;
<p>We can consider the <span class="obeylines-h"><span class="verb"><code class="inlineCode">sum()</code></span></span> function<span id="dx1-134001"/> to have the following kind of definition. We could say that the sum of a collection<span id="dx1-134002"/> is 0 for an empty collection. For a non-empty collection, the sum is the first element plus the sum of the remaining elements:</p>&#13;
<div class="math-display" style="text-align:center">&#13;
<img src="../Images/file54.jpg" class="math-display" alt=" (| { 0 if n = 0 sum ([c0,c1,c2,...,cn]) = | ( c0 + sum ([c1,c2,...,cn]) if n &gt; 0 "/>&#13;
</div>&#13;
<p>We can use a slightly simplified notation called the Bird-Meertens<span id="dx1-134003"/> Formalism. This uses <span class="cmsy-10x-x-109">âŠ•</span><span class="italic">âˆ•</span>[<span class="italic">c</span><sub><span class="cmr-8">0</span></sub><span class="italic">,c</span><sub><span class="cmr-8">1</span></sub><span class="italic">,...c</span><sub><span class="cmmi-8">n</span></sub>] to show how some arbitrary binary operator, <span class="cmsy-10x-x-109">âŠ•</span>, can be applied to a sequence of values. Itâ€™s used as follows to summarize a recursive definition into something a little easier to work with:</p>&#13;
<div class="math-display" style="text-align:center">&#13;
<img src="../Images/file55.jpg" class="math-display" alt="sum ([c0,c1,c2,...,cn]) = + âˆ•[c0,c1,c2,...,cn] = 0+ c0 + c1 + ...+ cn "/>&#13;
</div>&#13;
<p>Weâ€™ve effectively folded the + operator between each item of the sequence. Implicitly, the processing will be done left to right. This could be called a â€fold leftâ€ way of reducing a collection to a single value. We could also imagine grouping<span id="dx1-134004"/> the operators from right to left, calling this a â€fold right.â€ While some compiled languages will perform this optimization, Python works strictly from left to right when given a sequence of similar precedence operators.</p>&#13;
<p>In Python, a product function can be defined recursively as follows:</p>&#13;
<pre id="listing-122" class="lstlisting"><code>from collections.abc import SequenceÂ &#13;
Â &#13;
def prodrc(collection: Sequence[float]) -&gt; float:Â &#13;
Â Â Â Â if len(collection) == 0: return 1Â &#13;
Â Â Â Â return collection[0] * prodrc(collection[1:])</code></pre>&#13;
<p>This is a tiny rewrite from a mathematical notation to Python. However, it is less than optimal because all of the slices will create a large number of intermediate list objects. Itâ€™s also limited to only working with explicit collections; it canâ€™t work easily with iterable objects.</p>&#13;
<p>We can revise this slightly to work with an iterable, which avoids creating any intermediate collection objects. The following is a properly recursive product function that works with any iterator as a source of data:</p>&#13;
<pre id="listing-123" class="lstlisting"><code>from collections.abc import IteratorÂ &#13;
Â &#13;
def prodri(items: Iterator[float]) -&gt; float:Â &#13;
Â Â Â Â try:Â &#13;
Â Â Â Â Â Â Â Â head = next(items)Â &#13;
Â Â Â Â except StopIteration:Â &#13;
Â Â Â Â Â Â Â Â return 1Â &#13;
Â Â Â Â return head * prodri(items)</code></pre>&#13;
<p>This doesnâ€™t work with iterable collections. We canâ€™t interrogate an iterator with the <span class="obeylines-h"><span class="verb"><code class="inlineCode">len()</code></span></span> function to see how many elements it has. All we can do is attempt to extract the head of the iterator. If there are no items in the iterator, then any attempt to get the head will raise the <span class="obeylines-h"><span class="verb"><code class="inlineCode">StopIteration</code></span></span> exception. If there is an item, then we can multiply this item by the product of the remaining items in the sequence.</p>&#13;
<p>Note that we must explicitly<span id="dx1-134018"/> create an iterator from a materialized sequence object, using the <span class="obeylines-h"><span class="verb"><code class="inlineCode">iter()</code></span></span> function. In other contexts, we might have an iterable result that we can use. Following is an example:</p>&#13;
<div id="tcolobox-138" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; prodri(iter([1,2,3,4,5,6,7]))Â &#13;
5040</code></pre>&#13;
&#13;
</div>&#13;
<p>This recursive definition does not rely on explicit state or other imperative features of Python. While itâ€™s more purely functional, it is still limited to working with collections of under 1,000 items. (While we can extend the stack size, itâ€™s far better to optimize this properly.) Pragmatically, we can use the following kind of imperative structure for reduction functions:</p>&#13;
<pre id="listing-124" class="lstlisting"><code>from collections.abc import IterableÂ &#13;
Â &#13;
def prodi(items: Iterable[float]) -&gt; float:Â &#13;
Â Â Â Â p: float = 1Â &#13;
Â Â Â Â for n in items:Â &#13;
Â Â Â Â Â Â Â Â p *= nÂ &#13;
Â Â Â Â return p</code></pre>&#13;
<p>This avoids any recursion limits. It includes the required tail-call optimization. Furthermore, this will work equally well with any iterable. This means a <span class="obeylines-h"><span class="verb"><code class="inlineCode">Sequence</code></span></span> object, or an iterator. <span id="x1-134029r140"/></p>&#13;
<section id="tail-call-optimization-using-deques" class="level4 subsectionHead" data-number="0.10.2.1">&#13;
<h4 class="subsectionHead" data-number="0.10.2.1"><span class="titlemark">6.2.1 </span> <span id="x1-1350001"/>Tail-call optimization using deques</h4>&#13;
<p>The heart of recursion<span id="dx1-135001"/> is a stack of function<span id="dx1-135002"/> calls. Evaluating <span class="obeylines-h"><span class="verb"><code class="inlineCode">fact(5)</code></span></span>, for example, is <span class="obeylines-h"><span class="verb"><code class="inlineCode">5*fact(4)</code></span></span>. The value of <span class="obeylines-h"><span class="verb"><code class="inlineCode">fact(4)</code></span></span> is <span class="obeylines-h"><span class="verb"><code class="inlineCode">5*fact(3)</code></span></span>. There is a stack<span id="dx1-135003"/> of pending computations until <span class="obeylines-h"><span class="verb"><code class="inlineCode">fact(0)</code></span></span> has a value of 1. Then the stack of computations is completed, revealing the final result.</p>&#13;
<p>Python manages the stack of calls for us. It imposes an arbitrary default limit of 1,000 calls on the stack, to prevent a program with a bug in the recursion from running forever.</p>&#13;
<p>We can manage<span id="dx1-135004"/> the stack<span id="dx1-135005"/> manually, also. This gives us another way to optimize recursions. We canâ€”explicitlyâ€”create a stack of pending work. We can then do a final summarization of the pending work, emptying the items from the stack.</p>&#13;
<p>For something as simple as computing<span id="dx1-135006"/> a factorial value, the stacking and unstacking can seem like needless overhead. For more complex applications, like examining the hierarchical file system, it seems more appropriate to mix processing files with putting directories onto a stack for later consideration.</p>&#13;
<p>We need a function to traverse a directory hierarchy without an explicit recursion. The core concept is that a directory is a collection of entries, and each entry is either a file, a sub-directory, or some other filesystem object we donâ€™t want to touch (e.g., a mount point, symbolic link, etc.).</p>&#13;
<p>We can say a node in the directory tree is a collection of entries: <span class="italic">N </span>= <span class="italic">e</span><sub><span class="cmr-8">0</span></sub><span class="italic">,e</span><sub><span class="cmr-8">1</span></sub><span class="italic">,e</span><sub><span class="cmr-8">2</span></sub><span class="italic">,...,e</span><sub><span class="cmmi-8">n</span></sub>. Each entry is either another directory, <span class="italic">e </span><span class="cmsy-10x-x-109">âˆˆ</span><span class="msbm-10x-x-109">ğ”»</span>, or a file, <span class="italic">e </span><span class="cmsy-10x-x-109">âˆˆ</span><span class="msbm-10x-x-109">ğ”½</span>.</p>&#13;
<p>We can perform mappings on each file in the tree to process each fileâ€™s content. We might perform a filter operation to create an iterator over files with a specific property. We can also perform a reduction to count the number of files with a property. In this example, weâ€™ll count the occurrences of a specific substring throughout the contents of files in a directory tree.</p>&#13;
<p>Formally, we want a function <span class="italic">p</span>(<span class="italic">f</span>) that will provide the count of <span class="obeylines-h"><span class="verb"><code class="inlineCode">"print"</code></span></span> in a node of the directory tree. It could be defined like this:</p>&#13;
<div class="math-display" style="text-align:center">&#13;
<img src="../Images/file56.jpg" class="math-display" alt=" ( |{|â€œprintâ€ âˆˆ N | if N âˆˆ ğ”½ p(N ) = âˆ‘ |( eâˆˆN p(e) if N âˆˆ ğ”» "/>&#13;
</div>&#13;
<p>This shows how to apply the <span class="italic">p</span>(<span class="italic">N</span>) function to each element of a directory tree. When the element is a file, <span class="italic">e </span><span class="cmsy-10x-x-109">âˆˆ</span><span class="msbm-10x-x-109">ğ”½</span>, we can count instances of â€printâ€. When the element is a directory, <span class="italic">e </span><span class="cmsy-10x-x-109">âˆˆ</span><span class="msbm-10x-x-109">ğ”»</span>, we need to apply the <span class="italic">p</span>(<span class="italic">N</span>) function recursively to each entry, <span class="italic">e</span><sub><span class="cmmi-8">x</span></sub>, in the directory. While directory trees canâ€™t be deep enough to break Pythonâ€™s stack size limit, this kind of algorithm reveals an alternative<span id="dx1-135007"/> tail-call optimization. It is an opportunity to use an explicit stack.</p>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">collections.deque</code></span></span> class is a marvelous<span id="dx1-135008"/> way to build stacks<span id="dx1-135009"/> and queues. The name comes from â€double-ended queue,â€ sometimes spelled dequeue. The data structure can be used as either a <span class="keyWord">last-in-first-out </span>(<span class="keyWord">LIFO</span>) stack<span id="dx1-135010"/> or a <span class="keyWord">first-in-first-out </span>(<span class="keyWord">FIFO</span>). In this example, we use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">append()</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">pop()</code></span></span> methods, which enforce<span id="dx1-135011"/> LIFO stack behavior. While this is much like a list, there are some optimizations in the <span class="obeylines-h"><span class="verb"><code class="inlineCode">deque</code></span></span> implementation that can make it slightly faster than the generic list.</p>&#13;
<p>Using a stack data structure lets us work with a hierarchy of indefinite size without running into Pythonâ€™s internal stack depth limitation and raising <span class="obeylines-h"><span class="verb"><code class="inlineCode">RecursionError</code></span></span> exceptions. The following function will traverse a file hierarchy looking at Python source files (with a suffix of <span class="obeylines-h"><span class="verb"><code class="inlineCode">.py</code></span></span>):</p>&#13;
<pre id="listing-125" class="lstlisting"><code>from collections import dequeÂ &#13;
from pathlib import PathÂ &#13;
Â &#13;
def all_print(start: Path) -&gt; int:Â &#13;
Â Â Â Â count = 0Â &#13;
Â Â Â Â pending: deque[Path] = deque([start])Â &#13;
Â Â Â Â while pending:Â &#13;
Â Â Â Â Â Â Â Â dir_path = pending.pop()Â &#13;
Â Â Â Â Â Â Â Â for path in dir_path.iterdir():Â &#13;
Â Â Â Â Â Â Â Â Â Â Â Â if path.is_file():Â &#13;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if path.suffix == â€™.pyâ€™:Â &#13;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â count += path.read_text().count("print")Â &#13;
Â Â Â Â Â Â Â Â Â Â Â Â elif path.is_dir():Â &#13;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if not path.stem.startswith(â€™.â€™):Â &#13;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â pending.append(path)Â &#13;
Â Â Â Â Â Â Â Â Â Â Â Â else: Â # Ignore other filesystem objectsÂ &#13;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â passÂ &#13;
Â Â Â Â return count</code></pre>&#13;
<p>We seeded the stack of pending<span id="dx1-135030"/> tasks with the initial directory. The essential algorithm is to unstack a directory and visit each entry in the directory. For entries that are files with the proper suffix, the processing<span id="dx1-135031"/> is performed: counting the occurrences of â€printâ€. For entries that are directories, the directory is put into the stack as a pending task. Note that directories with a leading dot in their name need to be ignored. For the code in this book, those directories include caches<span id="dx1-135032"/> used by tools<span id="dx1-135033"/> like <span class="keyWord">mypy</span>, <span class="keyWord">pytest</span>, and <span class="keyWord">tox</span>. We want<span id="dx1-135034"/> to skip over those cache<span id="dx1-135035"/> directories.</p>&#13;
<p>The processing performed on each file is part of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">all_print()</code></span></span> function. This can be refactored as a separate function thatâ€™s applied to each node as part of a reduction. Rewriting the <span class="obeylines-h"><span class="verb"><code class="inlineCode">all_print()</code></span></span> function to be a proper higher-order function is left as an exercise for the reader.</p>&#13;
<p>The idea here is we have two strategies for transforming a formal recursion into a usefully optimized function. We can reframe the recursion into an iteration, or we can introduce an explicit stack.</p>&#13;
<p>In the next section, we will apply the idea of a reduction (and the associated tail-call optimizations) to creating groups of items and computing a reduction for the groups. <span id="x1-135036r141"/></p>&#13;
</section>&#13;
</section>&#13;
<section id="group-by-reduction-from-many-items-to-fewer" class="level3 sectionHead" data-number="0.10.3">&#13;
<h3 class="sectionHead" data-number="0.10.3"><span class="titlemark">6.3 </span> <span id="x1-1360003"/>Group-by reduction from many items to fewer</h3>&#13;
<p>The idea of a reduction<span id="dx1-136001"/> can apply in many ways. Weâ€™ve looked at the essential recursive definition of a reduction<span id="dx1-136002"/> that produces a single value from a collection of values. This leads us to optimizing the recursion so we have the ability to compute summaries without the overheads of a naive Pythonic implementation.</p>&#13;
<p>Creating subgroups in Python isnâ€™t difficult, but it can help to understand the formalisms that support it. This understanding can help to avoid implementations that perform extremely poorly.</p>&#13;
<p>A very common operation is a reduction that groups values by some key or indicator. The raw data is grouped by some columnâ€™s value, and reductions (sometimes called <span class="cmti-10x-x-109">aggregate functions</span>) are applied to other columns.</p>&#13;
<p>In SQL, this is often called the <span class="obeylines-h"><span class="verb"><code class="inlineCode">GROUP</code><code class="inlineCode">Â BY</code></span></span> clause of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">SELECT</code></span></span> statement. The SQL aggregate functions include <span class="obeylines-h"><span class="verb"><code class="inlineCode">SUM</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">COUNT</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">MAX</code></span></span>, and <span class="obeylines-h"><span class="verb"><code class="inlineCode">MIN</code></span></span>, and often many more.</p>&#13;
<p>Python offers us several<span id="dx1-136003"/> ways to group<span id="dx1-136004"/> data before computing a reduction of the grouped values. Weâ€™ll start by looking at two ways to get simple counts of grouped data. Then weâ€™ll look at ways to compute different summaries of grouped data.</p>&#13;
<p>Weâ€™ll use the trip data that we computed in <a href="Chapter_04.xhtml#x1-740004"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109">Â 4</span></a>, <a href="Chapter_04.xhtml#x1-740004"><span class="cmti-10x-x-109">Working with</span> <span class="cmti-10x-x-109">Collections</span></a>. This data started as a sequence of latitude-longitude waypoints. We restructured it to create legs represented by three-tuples of start, end, and distance for each leg. The data looks as follows:</p>&#13;
<div id="tcolobox-139" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>(((37.5490162, -76.330295), (37.840832, -76.273834), 17.7246),Â &#13;
((37.840832, -76.273834), (38.331501, -76.459503), 30.7382),Â &#13;
((38.331501, -76.459503), (38.845501, -76.537331), 31.0756),Â &#13;
...Â &#13;
((38.330166, -76.458504), (38.976334, -76.473503), 38.8019))</code></pre>&#13;
&#13;
</div>&#13;
<p>Weâ€™d like to know the most common distance. Since the data is real-valued, and continuous, each distance is a unique value. We need to constrain these values from the continuous domain to a discrete set of distances. For example, quantizing each leg to the nearest multiple of five nautical miles. This creates bands of 0 to 5 miles, over 5 to 10 miles, etc. Once weâ€™ve created discrete integer values, we can count the number of legs in each of these bands.</p>&#13;
<p>These quantized distances can be produced with a generator expression:</p>&#13;
<pre id="listing-126" class="lstlisting"><code>quantized = (5 * (dist // 5) for start, stop, dist in trip)</code></pre>&#13;
<p>This will divide each distance by 5â€”discarding any fractionsâ€”then multiply the truncated result by 5 to compute a number that represents the distance rounded down to the nearest 5 nautical miles.</p>&#13;
<p>We donâ€™t use the values<span id="dx1-136012"/> assigned to the <span class="obeylines-h"><span class="verb"><code class="inlineCode">start</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">stop</code></span></span> variables. Itâ€™s common practice to assign these values to the <span class="obeylines-h"><span class="verb"><code class="inlineCode">_</code></span></span> variable. This can lead to some confusion<span id="dx1-136013"/> because this can obscure the structure of the triple. It would look like this:</p>&#13;
<pre id="listing-127" class="lstlisting"><code>quantized = (5 * (dist // 5) for _, _, dist in trip)</code></pre>&#13;
<p>This approach can be helpful for removing some visual clutter. <span id="x1-136015r142"/></p>&#13;
<section id="building-a-mapping-with-counter" class="level4 subsectionHead" data-number="0.10.3.1">&#13;
<h4 class="subsectionHead" data-number="0.10.3.1"><span class="titlemark">6.3.1 </span> <span id="x1-1370001"/>Building a mapping with Counter</h4>&#13;
<p>A mapping<span id="dx1-137001"/> like the <span class="obeylines-h"><span class="verb"><code class="inlineCode">collections.Counter</code></span></span> class is a great optimization for doing reductions that create counts (or totals) grouped by some value in the collection. The following expression creates a mapping from distance<span id="dx1-137002"/> to frequency:</p>&#13;
<div id="tcolobox-140" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code># See Chapter 4 for ways to parse "file:./Winter%202012-2013.kml"Â &#13;
# We want to build a trip variable with the sequence of tuplesÂ &#13;
Â &#13;
&gt;&gt;&gt; from collections import CounterÂ &#13;
Â &#13;
&gt;&gt;&gt; quantized = (5 * (dist // 5) for start, stop, dist in trip)Â &#13;
&gt;&gt;&gt; summary = Counter(quantized)</code></pre>&#13;
&#13;
</div>&#13;
<p>The resulting <span class="obeylines-h"><span class="verb"><code class="inlineCode">summary</code></span></span> object is stateful; it can be updated. The expression to create the groups, <span class="obeylines-h"><span class="verb"><code class="inlineCode">Counter()</code></span></span>, looks like a function, making it a good fit for a design based on functional programming ideas.</p>&#13;
<p>If we print the <span class="obeylines-h"><span class="verb"><code class="inlineCode">summary.most_common()</code></span></span> value, weâ€™ll see the following results:</p>&#13;
<pre>&gt;&gt;&gt; summary.most_common()&#13;
[(30.0, 15), (15.0, 9), ...]&#13;
</pre>&#13;
<p>The most common distance was about 30 nautical miles. We can also apply functions like <span class="obeylines-h"><span class="verb"><code class="inlineCode">min()</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">max()</code></span></span> to find the shortest recorded and longest legs as well.</p>&#13;
<p>Note that your output<span id="dx1-137014"/> may vary slightly from whatâ€™s shown. The results of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">most_common()</code></span></span> function are in order of frequency; equal-frequency bins may be in any order. These five lengths may not always<span id="dx1-137015"/> be in the order shown:</p>&#13;
<div id="tcolobox-141" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>(35.0, 5), (5.0, 5), (10.0, 5), (20.0, 5), (25.0, 5)</code></pre>&#13;
&#13;
</div>&#13;
<p>This slight variability makes testing with the <span class="keyWord">doctest </span>tool a little bit more complex. One helpful trick for testing with counters is to use a dictionary to validate the results in general; the comparison between actual and expected no longer relies on the vagaries of internal hash computations. <span id="x1-137018r144"/></p>&#13;
</section>&#13;
<section id="building-a-mapping-by-sorting" class="level4 subsectionHead" data-number="0.10.3.2">&#13;
<h4 class="subsectionHead" data-number="0.10.3.2"><span class="titlemark">6.3.2 </span> <span id="x1-1380002"/>Building a mapping by sorting</h4>&#13;
<p>An alternative to <span class="obeylines-h"><span class="verb"><code class="inlineCode">Counter</code></span></span> is to sort the original collection, and then use a recursive loop to identify when each group begins. This involves materializing the raw data, performing a sort that couldâ€”at worstâ€”do <span class="keyWord">O</span>(<span class="italic">n</span>log <span class="italic">n</span>) operations, and then doing a reduction to get the sums or counts for each key.</p>&#13;
<p>In order to work in a general way with Python objects that can be sorted, we need to define the protocol required for sorting. Weâ€™ll call the protocol <span class="obeylines-h"><span class="verb"><code class="inlineCode">SupportsRichComparisonT</code></span></span> because we can sort any kinds of objects that implement the rich comparison operators, <span class="obeylines-h"><span class="verb"><code class="inlineCode">&lt;</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">&gt;</code></span></span>. This isnâ€™t a particular class of objects; itâ€™s a protocol that any number of classes might implement. We formalize the idea of a protocol that classes must support using the <span class="obeylines-h"><span class="verb"><code class="inlineCode">typing.Protocol</code></span></span> type definition. It could be also be called an interface that a class must implement. Pythonâ€™s flexibility stems from having a fairly large number of protocols that many different classes support.</p>&#13;
<p>The following is a common algorithm for creating groups from sorted data:</p>&#13;
<pre id="listing-128" class="lstlisting"><code>from collections.abc import IterableÂ &#13;
from typing import Any, TypeVar, Protocol, TypeAliasÂ &#13;
Â &#13;
class Comparable(Protocol):Â &#13;
Â Â Â Â def __lt__(self, __other: Any) -&gt; bool: ...Â &#13;
Â Â Â Â def __gt__(self, __other: Any) -&gt; bool: ...Â &#13;
SupportsRichComparisonT = TypeVar("SupportsRichComparisonT", bound=Comparable)Â &#13;
Â &#13;
Leg: TypeAlias = tuple[Any, Any, float]Â &#13;
Â &#13;
def group_sort(trip: Iterable[Leg]) -&gt; dict[int, int]:Â &#13;
Â &#13;
Â Â Â Â def group(Â &#13;
Â Â Â Â Â Â Â Â Â Â Â Â data: Iterable[SupportsRichComparisonT]Â &#13;
Â Â Â Â ) -&gt; Iterable[tuple[SupportsRichComparisonT, int]]:Â &#13;
Â Â Â Â Â Â Â Â sorted_data = iter(sorted(data))Â &#13;
Â Â Â Â Â Â Â Â previous, count = next(sorted_data), 1Â &#13;
Â Â Â Â Â Â Â Â for d in sorted_data:Â &#13;
Â Â Â Â Â Â Â Â Â Â Â Â if d == previous:Â &#13;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â count += 1Â &#13;
Â Â Â Â Â Â Â Â Â Â Â Â else:Â &#13;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â yield previous, countÂ &#13;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â previous, count = d, 1Â &#13;
Â Â Â Â Â Â Â Â yield previous, countÂ &#13;
Â &#13;
Â Â Â Â quantized = (int(5 * (dist // 5)) for beg, end, dist in trip)Â &#13;
Â Â Â Â return dict(group(quantized))</code></pre>&#13;
<p>The internal <span class="obeylines-h"><span class="verb"><code class="inlineCode">group()</code></span></span> function steps through<span id="dx1-138028"/> the sorted sequence of legs. If a given item key has already been seenâ€”it matches<span id="dx1-138029"/> the value in <span class="obeylines-h"><span class="verb"><code class="inlineCode">previous</code></span></span>â€”then the <span class="obeylines-h"><span class="verb"><code class="inlineCode">counter</code></span></span> variable is incremented. If a given item does not match the previous value, then thereâ€™s been a change in value: emit the previous value and the count, and begin a new accumulation of counts for the new value.</p>&#13;
<p>The definition of <span class="obeylines-h"><span class="verb"><code class="inlineCode">group()</code></span></span> provides two important type hints. The source data is an iterable over some type, shown with the type variable <span class="obeylines-h"><span class="verb"><code class="inlineCode">SupportsRichComparisonT</code></span></span>. In this specific case, itâ€™s pretty clear that the values in use will be of type <span class="obeylines-h"><span class="verb"><code class="inlineCode">int</code></span></span>; however, the algorithm will work for any Python type. The resulting iterable from the <span class="obeylines-h"><span class="verb"><code class="inlineCode">group()</code></span></span> function will preserve the type of the source data, and this is made explicit by using the same type variable, <span class="obeylines-h"><span class="verb"><code class="inlineCode">SupportsRichComparisonT</code></span></span>.</p>&#13;
<p>The final line of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">group_sort()</code></span></span> function creates<span id="dx1-138030"/> a dictionary from the grouped items. This dictionary<span id="dx1-138031"/> will be similar to a <span class="obeylines-h"><span class="verb"><code class="inlineCode">Counter</code></span></span> dictionary. The primary difference is that a <span class="obeylines-h"><span class="verb"><code class="inlineCode">Counter()</code></span></span> function will have a <span class="obeylines-h"><span class="verb"><code class="inlineCode">most_common()</code></span></span> method function, which a default dictionary lacks.</p>&#13;
<p>We can also do this with <span class="obeylines-h"><span class="verb"><code class="inlineCode">itertools.groupby()</code></span></span>. Weâ€™ll look at this function closely in <a href="Chapter_08.xhtml#x1-1700008"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109">Â 8</span></a>, <a href="Chapter_08.xhtml#x1-1700008"><span class="cmti-10x-x-109">The Itertools Module</span></a>. <span id="x1-138032r145"/></p>&#13;
</section>&#13;
<section id="grouping-or-partitioning-data-by-key-values" class="level4 subsectionHead" data-number="0.10.3.3">&#13;
<h4 class="subsectionHead" data-number="0.10.3.3"><span class="titlemark">6.3.3 </span> <span id="x1-1390003"/>Grouping or partitioning data by key values</h4>&#13;
<p>There are no limits to the kinds of reductions<span id="dx1-139001"/> we might want to apply to grouped data. We might have data with a number of independent and dependent variables. We can consider partitioning the data by an independent variable and computing summaries such as the maximum, minimum, average, and standard deviation of the values in each partition.</p>&#13;
<p>The essential trick to doing more sophisticated reductions is to collect all of the data values into each group. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">Counter()</code></span></span> function merely collects counts of identical items. For deeper analysis, we want to create sequences of the original members of the group.</p>&#13;
<p>Looking back at our trip data, each five-mile bin could contain the entire collection of legs of that distance, not merely a count of the legs. We can consider the partitioning as a recursion or as a stateful application of <span class="obeylines-h"><span class="verb"><code class="inlineCode">defaultdict(list)</code></span></span> objects. Weâ€™ll look at the recursive definition of a <span class="obeylines-h"><span class="verb"><code class="inlineCode">groupby()</code></span></span> function, since itâ€™s easy to design.</p>&#13;
<p>Clearly, the <span class="obeylines-h"><span class="verb"><code class="inlineCode">groupby(C,</code><code class="inlineCode">Â key)</code></span></span> computation for an empty collection, <span class="obeylines-h"><span class="verb"><code class="inlineCode">[]</code></span></span>, is the empty dictionary, <span class="obeylines-h"><span class="verb"><code class="inlineCode">dict()</code></span></span>. Or, more usefully, the empty <span class="obeylines-h"><span class="verb"><code class="inlineCode">defaultdict(list)</code></span></span> object.</p>&#13;
<p>For a non-empty collection, we need to work with item <span class="obeylines-h"><span class="verb"><code class="inlineCode">C[0]</code></span></span>, the head, and recursively process sequence <span class="obeylines-h"><span class="verb"><code class="inlineCode">C[1:]</code></span></span>, the tail. We can use slice expressions, or we can use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">head,</code></span></span> <span class="obeylines-h"><span class="verb"><code class="inlineCode">*tail</code><code class="inlineCode">Â =</code><code class="inlineCode">Â C</code></span></span> statement to do this parsing of the collection, as follows:</p>&#13;
<div id="tcolobox-142" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; C = [1,2,3,4,5]Â &#13;
&gt;&gt;&gt; head, *tail = CÂ &#13;
&gt;&gt;&gt; headÂ &#13;
1Â &#13;
&gt;&gt;&gt; tailÂ &#13;
[2, 3, 4, 5]</code></pre>&#13;
&#13;
</div>&#13;
<p>If we have a <span class="obeylines-h"><span class="verb"><code class="inlineCode">defaultdict</code></span></span> object named <span class="obeylines-h"><span class="verb"><code class="inlineCode">groups</code></span></span>, we need to use the expression <span class="obeylines-h"><span class="verb"><code class="inlineCode">groups[key(head)].append(head)</code></span></span> to include the head element in the <span class="obeylines-h"><span class="verb"><code class="inlineCode">groups</code></span></span> dictionary. After this, we need to evaluate the <span class="obeylines-h"><span class="verb"><code class="inlineCode">groupby(tail,</code><code class="inlineCode">Â key)</code></span></span> expression to process the remaining elements.</p>&#13;
<p>We can create a function<span id="dx1-139009"/> as follows:</p>&#13;
<pre id="listing-129" class="lstlisting"><code>from collections import defaultdictÂ &#13;
from collections.abc import Callable, Sequence, HashableÂ &#13;
from typing import TypeVarÂ &#13;
Â &#13;
SeqItemT = TypeVar("SeqItemT")Â &#13;
ItemKeyT = TypeVar("ItemKeyT", bound=Hashable)Â &#13;
Â &#13;
def group_by(Â &#13;
Â Â Â Â Â Â Â Â key: Callable[[SeqItemT], ItemKeyT],Â &#13;
Â Â Â Â Â Â Â Â data: Sequence[SeqItemT]Â &#13;
) -&gt; dict[ItemKeyT, list[SeqItemT]]:Â &#13;
Â &#13;
Â Â Â Â def group_into(Â &#13;
Â Â Â Â Â Â Â Â Â Â Â Â key: Callable[[SeqItemT], ItemKeyT],Â &#13;
Â Â Â Â Â Â Â Â Â Â Â Â collection: Sequence[SeqItemT],Â &#13;
Â Â Â Â Â Â Â Â Â Â Â Â group_dict: dict[ItemKeyT, list[SeqItemT]]Â &#13;
Â Â Â Â ) -&gt; dict[ItemKeyT, list[SeqItemT]]:Â &#13;
Â Â Â Â Â Â Â Â if len(collection) == 0:Â &#13;
Â Â Â Â Â Â Â Â Â Â Â Â return group_dictÂ &#13;
Â Â Â Â Â Â Â Â head, *tail = collectionÂ &#13;
Â Â Â Â Â Â Â Â group_dict[key(head)].append(head)Â &#13;
Â Â Â Â Â Â Â Â return group_into(key, tail, group_dict)Â &#13;
Â &#13;
Â Â Â Â return group_into(key, data, defaultdict(list))</code></pre>&#13;
<p>The interior function <span class="obeylines-h"><span class="verb"><code class="inlineCode">group_into()</code></span></span> handles the essential recursive definition. An empty value for <span class="obeylines-h"><span class="verb"><code class="inlineCode">collection</code></span></span> returns the provided dictionary, <span class="obeylines-h"><span class="verb"><code class="inlineCode">group_dict</code></span></span>. A non-empty collection is partitioned into a head and tail. The head is used to update the <span class="obeylines-h"><span class="verb"><code class="inlineCode">group_dict</code></span></span> dictionary. The tail is then used, recursively, to update the dictionary with all remaining elements.</p>&#13;
<p>The type hints make an explicit distinction<span id="dx1-139034"/> between the type of the source objects <span class="obeylines-h"><span class="verb"><code class="inlineCode">SeqItemT</code></span></span> and the type of the key <span class="obeylines-h"><span class="verb"><code class="inlineCode">ItemKeyT</code></span></span>. The function provided as the <span class="obeylines-h"><span class="verb"><code class="inlineCode">key</code></span></span> parameter must be a callable that returns a value of the key type <span class="obeylines-h"><span class="verb"><code class="inlineCode">ItemKeyT</code></span></span>, given an object of the source type <span class="obeylines-h"><span class="verb"><code class="inlineCode">SeqItemT</code></span></span>. In many of the examples, a function to extract the distance from a <span class="obeylines-h"><span class="verb"><code class="inlineCode">Leg</code></span></span> object will be be shown. This is a <span class="obeylines-h"><span class="verb"><code class="inlineCode">Callable[[SeqItemT],</code><code class="inlineCode">Â ItemKeyT]</code></span></span> where the source type <span class="obeylines-h"><span class="verb"><code class="inlineCode">SeqItemT</code></span></span> is the <span class="obeylines-h"><span class="verb"><code class="inlineCode">Leg</code></span></span> object and the key type <span class="obeylines-h"><span class="verb"><code class="inlineCode">ItemKeyT</code></span></span> is the float value.</p>&#13;
<p><span class="obeylines-h"><span class="verb"><code class="inlineCode">bound=Hashable</code></span></span> is an additional constraint. This defines an â€upper boundâ€ on the possible types, alerting <span class="keyWord">mypy</span><span id="dx1-139035"/> that any type that could be assigned to this type variable must implement the protocol for <span class="obeylines-h"><span class="verb"><code class="inlineCode">Hashable</code></span></span>. The essential, immutable Python types of numbers, strings, and tuples all meet this bound. A mutable object like a dictionary, set, or list, will not meet the upper bound, leading to warnings from <span class="keyWord">mypy</span>.</p>&#13;
<p>We canâ€™t easily use Pythonâ€™s default values to collapse this into a single function. We explicitly cannot use the following incorrect command snippet:</p>&#13;
<pre id="listing-130" class="lstlisting"><code># Bad use of a mutable default valueÂ &#13;
Â &#13;
def group_by(key, data, dictionary=defaultdict(list)):</code></pre>&#13;
<p>If we try this, all uses of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">group_by()</code></span></span> function share one common <span class="obeylines-h"><span class="verb"><code class="inlineCode">defaultdict(list)</code></span></span> object. This does not work because Python builds the default value just once. Mutable objects as default values rarely do what we want. The common practice is to provide a <span class="obeylines-h"><span class="verb"><code class="inlineCode">None</code></span></span> value, and use an explicit <span class="obeylines-h"><span class="verb"><code class="inlineCode">if</code></span></span> statement to create each unique, empty instance of <span class="obeylines-h"><span class="verb"><code class="inlineCode">defaultdict(list)</code></span></span> as needed. Weâ€™ve shown how to use a wrapper function definition to avoid the <span class="obeylines-h"><span class="verb"><code class="inlineCode">if</code></span></span> statement.</p>&#13;
<p>We can group the data by distance as follows:</p>&#13;
<div id="tcolobox-143" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; binned_distance = lambda leg: 5 * (leg[2] // 5)Â &#13;
&gt;&gt;&gt; by_distance = group_by(binned_distance, trip)</code></pre>&#13;
&#13;
</div>&#13;
<p>Weâ€™ve defined a reusable<span id="dx1-139042"/> lambda that puts our distances into bins, each of which is 5 nautical miles in size. We then grouped the data using the provided lambda.</p>&#13;
<p>We can examine the binned data as follows:</p>&#13;
<div id="tcolobox-144" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; import pprintÂ &#13;
&gt;&gt;&gt; for distance in sorted(by_distance):Â &#13;
...     print(distance)Â &#13;
...     pprint.pprint(by_distance[distance])</code></pre>&#13;
&#13;
</div>&#13;
<p>The following is what the output looks like:</p>&#13;
<div id="tcolobox-145" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>0.0Â &#13;
[((35.505665, -76.653664), (35.508335, -76.654999), 0.1731),Â &#13;
 ((35.028175, -76.682495), (35.031334, -76.682663), 0.1898),Â &#13;
 ((25.4095, -77.910164), (25.425833, -77.832664), 4.3155),Â &#13;
 ((25.0765, -77.308167), (25.080334, -77.334), 1.4235)]Â &#13;
5.0Â &#13;
[((38.845501, -76.537331), (38.992832, -76.451332), 9.7151),Â &#13;
 ((34.972332, -76.585167), (35.028175, -76.682495), 5.8441),Â &#13;
 ((30.717167, -81.552498), (30.766333, -81.471832), 5.103),Â &#13;
 ((25.471333, -78.408165), (25.504833, -78.232834), 9.7128),Â &#13;
 ((23.9555, -76.31633), (24.099667, -76.401833), 9.844)]Â &#13;
...Â &#13;
125.0Â &#13;
[((27.154167, -80.195663), (29.195168, -81.002998), 129.7748)]</code></pre>&#13;
&#13;
</div>&#13;
<p>Having looked at a recursive definition, we can turn to looking at making a tail-call optimization to build a group-by algorithm using iteration. This will work with larger collections of data, because it can exceed the internal stack size limitation.</p>&#13;
<p>Weâ€™ll start with doing tail-call optimization on the <span class="obeylines-h"><span class="verb"><code class="inlineCode">group_into()</code></span></span> function. Weâ€™ll rename this to <span class="obeylines-h"><span class="verb"><code class="inlineCode">partition()</code></span></span> because partitioning<span id="dx1-139063"/> is another way of looking at grouping.</p>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">partition()</code></span></span> function can be written as an iteration as follows:</p>&#13;
<pre id="listing-131" class="lstlisting"><code>from collections import defaultdictÂ &#13;
from collections.abc import Callable, Hashable, IterableÂ &#13;
from typing import TypeVarÂ &#13;
Â &#13;
SeqT = TypeVar("SeqT")Â &#13;
KeyT = TypeVar("KeyT", bound=Hashable)Â &#13;
Â &#13;
def partition(Â &#13;
Â Â Â Â Â Â Â Â key: Callable[[SeqT], KeyT],Â &#13;
Â Â Â Â Â Â Â Â data: Iterable[SeqT]Â &#13;
) -&gt; dict[KeyT, list[SeqT]]:Â &#13;
Â Â Â Â group_dict = defaultdict(list)Â &#13;
Â Â Â Â for head in data:Â &#13;
Â Â Â Â Â Â Â Â group_dict[key(head)].append(head)Â &#13;
Â Â Â Â Â Â Â Â #---------------------------------Â &#13;
Â Â Â Â return group_dict</code></pre>&#13;
<p>When doing the tail-call optimization, the essential line of the code in the imperative version will match the recursive definition. Weâ€™ve put a comment under the changed line to emphasize the rewrite is intended to have the same outcome. The rest of the structure represents the tail-call optimization weâ€™ve adopted as a common way to work around the Python limitations.</p>&#13;
<p>The type hints emphasize the distinction between the source type <span class="obeylines-h"><span class="verb"><code class="inlineCode">SeqT</code></span></span> and the key type <span class="obeylines-h"><span class="verb"><code class="inlineCode">KeyT</code></span></span>. The source data can be anything, but the keys are limited to types that have proper hash values. <span id="x1-139080r146"/></p>&#13;
</section>&#13;
<section id="writing-more-general-group-by-reductions" class="level4 subsectionHead" data-number="0.10.3.4">&#13;
<h4 class="subsectionHead" data-number="0.10.3.4"><span class="titlemark">6.3.4 </span> <span id="x1-1400004"/>Writing more general group-by reductions</h4>&#13;
<p>Once we have partitioned<span id="dx1-140001"/> the raw data, we can compute various kinds of reductions on the data elements in each partition. We might, for example, want the northernmost point for the start of each leg in the distance bins.</p>&#13;
<p>Weâ€™ll introduce some helper functions to decompose the tuple as follows:</p>&#13;
<pre id="listing-132" class="lstlisting"><code># Legs are (start, end, distance) tuplesÂ &#13;
Â &#13;
start = lambda s, e, d: sÂ &#13;
Â &#13;
end = lambda s, e, d: eÂ &#13;
Â &#13;
dist = lambda s, e, d: dÂ &#13;
Â &#13;
# start and end of a Leg are (lat, lon) tuplesÂ &#13;
Â &#13;
latitude = lambda lat, lon: latÂ &#13;
Â &#13;
longitude = lambda lat, lon: lon</code></pre>&#13;
<p>Each of these helper functions expects a tuple object to be provided using the <span class="obeylines-h"><span class="verb"><code class="inlineCode">*</code></span></span> operator to map each element of the tuple to a separate parameter of the lambda. Once the tuple is expanded into the <span class="obeylines-h"><span class="verb"><code class="inlineCode">s</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">e</code></span></span>, and <span class="obeylines-h"><span class="verb"><code class="inlineCode">p</code></span></span> parameters, itâ€™s reasonably obvious to return the proper parameter by name. Itâ€™s much clearer than trying to interpret the <span class="obeylines-h"><span class="verb"><code class="inlineCode">tuple_arg[2]</code></span></span> value.</p>&#13;
<p>The following is how we use these helper functions:</p>&#13;
<div id="tcolobox-146" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; point = ((35.505665, -76.653664), (35.508335, -76.654999), 0.1731)Â &#13;
&gt;&gt;&gt; start(*point)Â &#13;
(35.505665, -76.653664)Â &#13;
Â &#13;
&gt;&gt;&gt; end(*point)Â &#13;
(35.508335, -76.654999)Â &#13;
Â &#13;
&gt;&gt;&gt; dist(*point)Â &#13;
0.1731Â &#13;
Â &#13;
&gt;&gt;&gt; latitude(*start(*point))Â &#13;
35.505665</code></pre>&#13;
&#13;
</div>&#13;
<p>Our initial <span class="obeylines-h"><span class="verb"><code class="inlineCode">point</code></span></span> object is a nested three tuple with (0)â€”a starting position, (1)â€”the ending position, and (2)â€”the distance. We extracted various fields using our helper functions.</p>&#13;
<p>Given these helpers, we can locate the northernmost<span id="dx1-140028"/> starting position for the legs in each bin:</p>&#13;
<div id="tcolobox-147" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; binned_distance = lambda leg: 5 * (leg[2] // 5)Â &#13;
&gt;&gt;&gt; by_distance = partition(binned_distance, trip)Â &#13;
&gt;&gt;&gt; for distance in sorted(by_distance):Â &#13;
...     print(Â &#13;
...         distance,Â &#13;
...         max(by_distance[distance],Â &#13;
...         key=lambda pt: latitude(*start(*pt)))Â &#13;
...     )</code></pre>&#13;
&#13;
</div>&#13;
<p>The data that we grouped by distance included each leg of the given distance. We supplied all of the legs in each bin to the <span class="obeylines-h"><span class="verb"><code class="inlineCode">max()</code></span></span> function. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">key</code></span></span> function we provided to the <span class="obeylines-h"><span class="verb"><code class="inlineCode">max()</code></span></span> function extracted just the latitude of the starting point of the leg.</p>&#13;
<p>This gives us a short list of the northernmost legs of each distance, as follows:</p>&#13;
<div id="tcolobox-148" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>0.0 ((35.505665, -76.653664), (35.508335, -76.654999), 0.1731)Â &#13;
5.0 ((38.845501, -76.537331), (38.992832, -76.451332), 9.7151)Â &#13;
10.0 ((36.444168, -76.3265), (36.297501, -76.217834), 10.2537)Â &#13;
...Â &#13;
125.0 ((27.154167, -80.195663), (29.195168, -81.002998), 129.7748)</code></pre>&#13;
&#13;
</div>&#13;
<p><span id="x1-140044r147"/></p>&#13;
</section>&#13;
<section id="writing-higher-order-reductions" class="level4 subsectionHead" data-number="0.10.3.5">&#13;
<h4 class="subsectionHead" data-number="0.10.3.5"><span class="titlemark">6.3.5 </span> <span id="x1-1410005"/>Writing higher-order reductions</h4>&#13;
<p>Weâ€™ll look at an example of a higher-order reduction<span id="dx1-141001"/> algorithm here. This will introduce a rather complex topic. The simplest kind of reduction develops a single value from a collection of values. Python has a number of built-in reductions, including <span class="obeylines-h"><span class="verb"><code class="inlineCode">any()</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">all()</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">max()</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">min()</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">sum()</code></span></span>, and <span class="obeylines-h"><span class="verb"><code class="inlineCode">len()</code></span></span>.</p>&#13;
<p>As we noted in <a href="Chapter_04.xhtml#x1-740004"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109">Â 4</span></a>, <a href="Chapter_04.xhtml#x1-740004"><span class="cmti-10x-x-109">Working with Collections</span></a>, we can do a great deal of statistical calculation if we start with a few reductions such as the following:</p>&#13;
<pre id="listing-133" class="lstlisting"><code>from collections.abc import SequenceÂ &#13;
Â &#13;
def sum_x0(data: Sequence[float]) -&gt; float:Â &#13;
Â Â Â Â return sum(1 for x in data) Â # or len(data)Â &#13;
Â &#13;
def sum_x1(data: Sequence[float]) -&gt; float:Â &#13;
Â Â Â Â return sum(x for x in data) Â # or sum(data)Â &#13;
Â &#13;
def sum_x2(data: Sequence[float]) -&gt; float:Â &#13;
Â Â Â Â return sum(x*x for x in data)</code></pre>&#13;
<p>This allows us to define mean, standard deviation, normalized values, correction, and even least-squares linear regression, building on these base reduction functions.</p>&#13;
<p>The last of our reductions, <span class="obeylines-h"><span class="verb"><code class="inlineCode">sum_x2()</code></span></span>, shows how we can apply existing reductions to create higher-order functions. We might change our approach to be more like the following:</p>&#13;
<pre id="listing-134" class="lstlisting"><code>from collections.abc import Callable, IterableÂ &#13;
from typing import AnyÂ &#13;
Â &#13;
def sum_f(Â &#13;
Â Â Â Â Â Â Â Â function: Callable[[Any], float],Â &#13;
Â Â Â Â Â Â Â Â data: Iterable[float]Â &#13;
) -&gt; float:Â &#13;
Â Â Â Â return sum(function(x) for x in data)</code></pre>&#13;
<p>Weâ€™ve added a function, <span class="obeylines-h"><span class="verb"><code class="inlineCode">function()</code></span></span>, as a parameter; the function can transform the data. This overall function, <span class="obeylines-h"><span class="verb"><code class="inlineCode">sum_f()</code></span></span>, computes the sum of the transformed values.</p>&#13;
<p>Now we can apply this function in three different ways to compute the three essential sums as follows:</p>&#13;
<div id="tcolobox-149" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; data = [7.46, 6.77, 12.74, 7.11, 7.81,Â &#13;
...     8.84, 6.08, 5.39, 8.15, 6.42, 5.73]Â &#13;
Â &#13;
&gt;&gt;&gt; N = sum_f(lambda x: 1, data)  # x**0Â &#13;
&gt;&gt;&gt; NÂ &#13;
11Â &#13;
&gt;&gt;&gt; S = sum_f(lambda x: x, data)  # x**1Â &#13;
&gt;&gt;&gt; round(S, 2)Â &#13;
82.5Â &#13;
&gt;&gt;&gt; S2 = sum_f(lambda x: x*x, data)  # x**2Â &#13;
&gt;&gt;&gt; round(S2, 4)Â &#13;
659.9762</code></pre>&#13;
&#13;
</div>&#13;
<p>Weâ€™ve plugged in a small lambda to compute <span class="cmex-10x-x-109">âˆ‘</span> <sub><span class="cmmi-8">x</span><span class="cmsy-8">âˆˆ</span><span class="cmmi-8">X</span></sub><span class="italic">x</span><sup><span class="cmr-8">0</span></sup> = <span class="cmex-10x-x-109">âˆ‘</span> <sub><span class="cmmi-8">x</span><span class="cmsy-8">âˆˆ</span><span class="cmmi-8">X</span></sub>1, which is the count, <span class="cmex-10x-x-109">âˆ‘</span> <sub><span class="cmmi-8">x</span><span class="cmsy-8">âˆˆ</span><span class="cmmi-8">X</span></sub><span class="italic">x</span><sup><span class="cmr-8">1</span></sup> = <span class="cmex-10x-x-109">âˆ‘</span> <sub><span class="cmmi-8">x</span><span class="cmsy-8">âˆˆ</span><span class="cmmi-8">X</span></sub><span class="italic">x</span>, the sum, and <span class="cmex-10x-x-109">âˆ‘</span> <sub><span class="cmmi-8">x</span><span class="cmsy-8">âˆˆ</span><span class="cmmi-8">X</span></sub><span class="italic">x</span><sup><span class="cmr-8">2</span></sup>, the sum of the squares, which we can use to compute standard deviation.</p>&#13;
<p>A common extension<span id="dx1-141033"/> to this includes a filter to reject raw data that is unknown or unsuitable in some way. We might use the following function to reject bad data:</p>&#13;
<pre id="listing-135" class="lstlisting"><code>from collections.abc import Callable, IterableÂ &#13;
Â &#13;
def sum_filter_f(Â &#13;
Â Â Â Â Â Â Â Â filter_f: Callable[[float], bool],Â &#13;
Â Â Â Â Â Â Â Â function: Callable[[float], float],Â &#13;
Â Â Â Â Â Â Â Â data: Iterable[float]Â &#13;
) -&gt; float:Â &#13;
Â Â Â Â return sum(function(x) for x in data if filter_f(x))</code></pre>&#13;
<p>The following function definition for computing a mean will reject <span class="obeylines-h"><span class="verb"><code class="inlineCode">None</code></span></span> values in a simple way:</p>&#13;
<pre id="listing-136" class="lstlisting"><code>valid = lambda x: x is not NoneÂ &#13;
Â &#13;
def mean_f(predicate: Callable[[Any], bool], data: Sequence[float]) -&gt; float:Â &#13;
Â Â Â Â count_ = lambda x: 1Â &#13;
Â Â Â Â sum_ = lambda x: xÂ &#13;
Â Â Â Â N = sum_filter_f(valid, count_, data)Â &#13;
Â Â Â Â S = sum_filter_f(valid, sum_, data)Â &#13;
Â Â Â Â return S / N</code></pre>&#13;
<p>This shows how we can provide<span id="dx1-141050"/> two distinct combinations of lambdas to our <span class="obeylines-h"><span class="verb"><code class="inlineCode">sum_filter_f()</code></span></span> function. The filter argument is a lambda that rejects <span class="obeylines-h"><span class="verb"><code class="inlineCode">None</code></span></span> values; weâ€™ve called it <span class="obeylines-h"><span class="verb"><code class="inlineCode">valid</code></span></span> to emphasize its meaning. The function argument is a lambda that implements a count or a sum operation. We can easily add a lambda to compute a sum of squares.</p>&#13;
<p>The reuse of a common <span class="obeylines-h"><span class="verb"><code class="inlineCode">valid</code></span></span> rule assures that the various computations are all identical in applying any filters to the source data. This can be combined with a user-selected filter criteria to provide a tidy plug-in to compute a number of statistics related to a userâ€™s requested subset of the data. <span id="x1-141051r148"/></p>&#13;
</section>&#13;
<section id="writing-file-parsers" class="level4 subsectionHead" data-number="0.10.3.6">&#13;
<h4 class="subsectionHead" data-number="0.10.3.6"><span class="titlemark">6.3.6 </span> <span id="x1-1420006"/>Writing file parsers</h4>&#13;
<p>We can often consider<span id="dx1-142001"/> a file parser<span id="dx1-142002"/> to be a kind of reduction. Many languages have two levels of definition: the lower-level tokens in the language and the higher-level structures built from those tokens. When looking at an XML file, the tags, tag names, and attribute names form this lower-level syntax; the structures which are described by XML form a higher-level syntax.</p>&#13;
<p>The lower-level lexical scanning is a kind of reduction that takes individual characters and groups them into tokens. This fits well with Pythonâ€™s generator function design pattern. We can often write functions that look as follows:</p>&#13;
<pre id="listing-137" class="lstlisting"><code>from collections.abc import IteratorÂ &#13;
from enum import EnumÂ &#13;
import reÂ &#13;
Â &#13;
class Token(Enum):Â &#13;
Â Â Â Â SPACE = 1Â &#13;
Â Â Â Â PARA = 2Â &#13;
Â Â Â Â EOF = 3Â &#13;
Â &#13;
def lexical_scan(some_source: str) -&gt; Iterator[tuple[Token, str]]:Â &#13;
Â Â Â Â previous_end = 0Â &#13;
Â Â Â Â separator_pat = re.compile(r"\n\s*\n", re.M|re.S)Â &#13;
Â Â Â Â for sep in separator_pat.finditer(some_source):Â &#13;
Â Â Â Â Â Â Â Â start, end = sep.span()Â &#13;
Â Â Â Â Â Â Â Â yield Token.PARA, some_source[previous_end: start]Â &#13;
Â Â Â Â Â Â Â Â yield Token.SPACE, some_source[start: end]Â &#13;
Â Â Â Â Â Â Â Â previous_end = endÂ &#13;
Â Â Â Â yield Token.PARA, some_source[previous_end:]Â &#13;
Â Â Â Â yield Token.EOF, ""</code></pre>&#13;
<p>For well-known file formats, weâ€™ll use existing file parsers. For data in CSV, JSON, XML, or TOML format, we donâ€™t need to write<span id="dx1-142022"/> file parsers. Most of these modules have a <span class="obeylines-h"><span class="verb"><code class="inlineCode">load()</code></span></span> method that produces<span id="dx1-142023"/> useful Python objects.</p>&#13;
<p>In some cases, weâ€™ll need to combine the results of this parsing into higher-level objects, useful for our specific application. While the CSV parser provides individual rows, these might need to be used to create <span class="obeylines-h"><span class="verb"><code class="inlineCode">NamedTuple</code></span></span> instances, or perhaps some other class of immutable Python objects. Our examples of trip data, starting in <a href="Chapter_04.xhtml#x1-740004"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109">Â 4</span></a>, <a href="Chapter_04.xhtml#x1-740004"><span class="cmti-10x-x-109">Working with Collections</span></a>, are combined into higher-level objects, legs of a journey, by an algorithm that combines waypoints into pairs. When we introduce more complex decision-making, we make a transition from restructuring into parsing.</p>&#13;
<p>In order to provide useful waypoints in the first place, we needed to parse a source file. In these examples, the input was a KML file; KML is an XML representation of geographic information. The essential features of the parser look similar to the following definition:</p>&#13;
<pre id="listing-138" class="lstlisting"><code>from collections.abc import IteratorÂ &#13;
from typing import TextIO, castÂ &#13;
Â &#13;
def comma_split(text: str) -&gt; list[str]:Â &#13;
Â Â Â Â return text.split(",")Â &#13;
Â &#13;
def row_iter_kml(file_obj: TextIO) -&gt; Iterator[list[str]]:Â &#13;
Â Â Â Â ns_map = {Â &#13;
Â Â Â Â Â Â Â Â "ns0": "http://www.opengis.net/kml/2.2",Â &#13;
Â Â Â Â Â Â Â Â "ns1": "http://www.google.com/kml/ext/2.2"}Â &#13;
Â Â Â Â xpath = (Â &#13;
Â Â Â Â Â Â Â Â "./ns0:Document/ns0:Folder/"Â &#13;
Â Â Â Â Â Â Â Â "ns0:Placemark/ns0:Point/ns0:coordinates")Â &#13;
Â Â Â Â doc = XML.parse(file_obj)Â &#13;
Â Â Â Â return (Â &#13;
Â Â Â Â Â Â Â Â comma_split(cast(str, coordinates.text))Â &#13;
Â Â Â Â Â Â Â Â for coordinates in doc.findall(xpath, ns_map)Â &#13;
Â Â Â Â )</code></pre>&#13;
<p>The bulk of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">row_iter_kml()</code></span></span> function is the XML parsing that allows us to use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">doc.findall()</code></span></span> function to iterate through the <span class="obeylines-h"><span class="verb"><code class="inlineCode">&lt;ns0:coordinates&gt;</code></span></span> tags in the document. Weâ€™ve used a function named <span class="obeylines-h"><span class="verb"><code class="inlineCode">comma_split()</code></span></span> to parse the text of this tag into a three-tuple of values.</p>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">cast()</code></span></span> function is only present<span id="dx1-142042"/> to provide evidence to <span class="keyWord">mypy </span>that the value of <span class="obeylines-h"><span class="verb"><code class="inlineCode">coordinates.text</code></span></span> is a <span class="obeylines-h"><span class="verb"><code class="inlineCode">str</code></span></span> object. The default definition<span id="dx1-142043"/> of the text attribute is <span class="obeylines-h"><span class="verb"><code class="inlineCode">Union[str,</code></span></span> <span class="obeylines-h"><span class="verb"><code class="inlineCode">bytes]</code></span></span>; in this application, the data will be <span class="obeylines-h"><span class="verb"><code class="inlineCode">str</code></span></span> exclusively. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">cast()</code></span></span> function doesnâ€™t do any runtime processing.</p>&#13;
<p>This function focused on working with the normalized XML structure. The document is close to the database designerâ€™s definitions<span id="dx1-142044"/> of <span class="keyWord">first normal form</span>: each attribute is atomic (a single value), and each row in the XML data has the same columns with data of a consistent type. The data values arenâ€™t fully atomic, however: we have to split the points on the , to separate longitude, latitude, and altitude into atomic string values. However, the text value for these XML tags is internally consistent, making it a close fit with first normal form.</p>&#13;
<p>A large volume of dataâ€”XML tags, attributes, and other punctuationâ€”is reduced to a somewhat smaller volume, including just floating-point latitude and longitude values. For this reason, we can think of parsers as a kind of reduction.</p>&#13;
<p>Weâ€™ll need a higher-level set of conversions<span id="dx1-142045"/> to map the tuples<span id="dx1-142046"/> of text into floating-point numbers. Also, weâ€™d like to discard altitude, and reorder longitude and latitude. This will produce the application-specific tuple we need. We can use functions as follows for this conversion:</p>&#13;
<pre id="listing-139" class="lstlisting"><code>from collections.abc import IteratorÂ &#13;
Â &#13;
def pick_lat_lon(Â &#13;
Â Â Â Â Â Â Â Â lon: str, lat: str, alt: strÂ &#13;
) -&gt; tuple[str, str]:Â &#13;
Â Â Â Â return lat, lonÂ &#13;
Â &#13;
def float_lat_lon(Â &#13;
Â Â Â Â Â Â Â Â row_iter: Iterator[list[str]]Â &#13;
) -&gt; Iterator[tuple[float, float]]:Â &#13;
Â Â Â Â lat_lon_iter = (Â &#13;
Â Â Â Â Â Â Â Â pick_lat_lon(*row)Â &#13;
Â Â Â Â Â Â Â Â for row in row_iterÂ &#13;
Â Â Â Â )Â &#13;
Â Â Â Â return (Â &#13;
Â Â Â Â Â Â Â Â (float(lat), float(lon))Â &#13;
Â Â Â Â Â Â Â Â for lat, lon in lat_lon_iterÂ &#13;
Â Â Â Â )</code></pre>&#13;
<p>The essential tool is the <span class="obeylines-h"><span class="verb"><code class="inlineCode">float_lat_lon()</code></span></span> function. This is a higher-order function that returns a generator expression. The generator uses the <span class="obeylines-h"><span class="verb"><code class="inlineCode">map()</code></span></span> function to apply the <span class="obeylines-h"><span class="verb"><code class="inlineCode">float()</code></span></span> function conversion to the results of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">pick_lat_lon()</code></span></span> function, and the <span class="obeylines-h"><span class="verb"><code class="inlineCode">*row</code></span></span> argument to assign each member of the row tuple to a different parameter of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">pick_lat_lon()</code></span></span> function. This only works when each row is a three-tuple. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">pick_lat_lon()</code></span></span> function then returns a two-tuple of the selected items in the required order.</p>&#13;
<p>The source includes XML that looks like this:</p>&#13;
<pre id="listing-140" class="lstlisting"><code>&lt;Placemark&gt;&lt;Point&gt;Â &#13;
&lt;coordinates&gt;-76.33029518659048, 37.54901619777347,0&lt;/coordinates&gt;Â &#13;
&lt;/Point&gt;&lt;/Placemark&gt;</code></pre>&#13;
<p>We can use this parser as follows:</p>&#13;
<div id="tcolobox-150" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; import urllib.requestÂ &#13;
&gt;&gt;&gt; source_url = "file:./Winter%202012-2013.kml"Â &#13;
&gt;&gt;&gt; with urllib.request.urlopen(source_url) as source:Â &#13;
...      flat = list(float_lat_lon(row_iter_kml(source)))</code></pre>&#13;
&#13;
</div>&#13;
<p>This will build a tuple-of-tuples representation<span id="dx1-142073"/> of each waypoint along the path in the original KML file. The result will be a flat sequence<span id="dx1-142074"/> of pairs that looks like this:</p>&#13;
<div id="tcolobox-151" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; from pprint import pprintÂ &#13;
&gt;&gt;&gt; pprint(flat)  # doctest: +ELLIPSISÂ &#13;
[(37.54901619777347, -76.33029518659048),Â &#13;
 ...Â &#13;
 (38.976334, -76.473503)]</code></pre>&#13;
&#13;
</div>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">float_lat_lon()</code></span></span> function uses a low-level XML parser to extract rows of text data from the original representation. It uses a higher-level parser to transform the text items into more useful tuples of floating-point values suitable for the target application.</p>&#13;
<section id="parsing-csv-files" class="level5 likesubsubsectionHead" data-number="0.10.3.6.1">&#13;
<h5 class="likesubsubsectionHead" data-number="0.10.3.6.1"><span id="x1-1430006"/>Parsing CSV files</h5>&#13;
<p>In <a href="Chapter_03.xhtml#x1-510003"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109">Â 3</span></a>, <a href="Chapter_03.xhtml#x1-510003"><span class="cmti-10x-x-109">Functions, Iterators, and Generators</span></a>, we saw another example<span id="dx1-143001"/> where we parsed a CSV file that was not in a normalized form: we had to discard header rows to make it useful. To do this, we used a function<span id="dx1-143002"/> that extracted the header and returned an iterator over the remaining rows.</p>&#13;
<p>The data looks as follows:</p>&#13;
<pre id="listing-141" class="lstlisting"><code>Anscombeâ€™s quartetÂ &#13;
I II III IVÂ &#13;
x y x y x y x yÂ &#13;
10.0 8.04 10.0 9.14 10.0 7.46 8.0 6.58Â &#13;
8.0 6.95 8.0 8.14 8.0 6.77 8.0 5.76Â &#13;
...Â &#13;
5.0 5.68 5.0 4.74 5.0 5.73 8.0 6.89</code></pre>&#13;
<p>The columns are separated<span id="dx1-143010"/> by tab characters. Plus, there are three rows of headers that we can discard.</p>&#13;
<p>Hereâ€™s another version<span id="dx1-143011"/> of that CSV-based parser. Weâ€™ve broken it into three functions. The first, <span class="obeylines-h"><span class="verb"><code class="inlineCode">row_iter_csv()</code></span></span> function, returns the iterator over the rows in a tab-delimited file. The function looks as follows:</p>&#13;
<pre id="listing-142" class="lstlisting"><code>from collections.abc import IteratorÂ &#13;
import csvÂ &#13;
from typing import TextIOÂ &#13;
Â &#13;
def row_iter_csv(source: TextIO) -&gt; Iterator[list[str]]:Â &#13;
Â Â Â Â rdr = csv.reader(source, delimiter="\t")Â &#13;
Â Â Â Â return rdr</code></pre>&#13;
<p>This is a small wrapper around the CSV parsing process. When we look back at the previous parsers for XML and plain text, this was the kind of thing that was missing from those parsers. Producing an iterable over row tuples can be a common feature of parsers for normalized data.</p>&#13;
<p>Once we have a row of tuples, we can pass rows that contain usable data and reject rows that contain other metadata, such as titles and column names. Weâ€™ll introduce a helper function that we can use to do some of the parsing, plus a <span class="obeylines-h"><span class="verb"><code class="inlineCode">filter()</code></span></span> function to validate a row of data.</p>&#13;
<p>Following is the conversion:</p>&#13;
<pre id="listing-143" class="lstlisting"><code>from typing import castÂ &#13;
Â &#13;
def float_none(data: str) -&gt; float | None:Â &#13;
Â Â Â Â try:Â &#13;
Â Â Â Â Â Â Â Â data_f = float(data)Â &#13;
Â Â Â Â Â Â Â Â return data_fÂ &#13;
Â Â Â Â except ValueError:Â &#13;
Â Â Â Â Â Â Â Â return None</code></pre>&#13;
<p>This function handles the conversion<span id="dx1-143027"/> of a single string<span id="dx1-143028"/> to float values, converting bad data to a <span class="obeylines-h"><span class="verb"><code class="inlineCode">None</code></span></span> value. The type hint of <span class="obeylines-h"><span class="verb"><code class="inlineCode">float</code><code class="inlineCode">Â |</code><code class="inlineCode">Â None</code></span></span> expresses the idea of having a value of the given type or having a value of the same type as <span class="obeylines-h"><span class="verb"><code class="inlineCode">None</code></span></span>. This can also be stated as <span class="obeylines-h"><span class="verb"><code class="inlineCode">Union[float,</code><code class="inlineCode">Â None]</code></span></span> to show how the result is a union of different alternative types.</p>&#13;
<p>We can embed the <span class="obeylines-h"><span class="verb"><code class="inlineCode">float_none()</code></span></span> function in a mapping so that we convert all columns of a row to a float or <span class="obeylines-h"><span class="verb"><code class="inlineCode">None</code></span></span> value. A lambda for this looks as follows:</p>&#13;
<pre id="listing-144" class="lstlisting"><code>from collections.abc import CallableÂ &#13;
from typing import TypeAliasÂ &#13;
Â &#13;
R_Float: TypeAlias = list[float | None]Â &#13;
Â &#13;
float_row: Callable[[list[str]], R_Float] = \Â &#13;
Â Â Â Â lambda row: list(map(float_none, row))</code></pre>&#13;
<p>Two type hints are used to make the definition of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">float_row()</code></span></span> function explicit. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">R_Float</code></span></span> hint defines the floating-point version of a row of data that may include <span class="obeylines-h"><span class="verb"><code class="inlineCode">None</code></span></span> values.</p>&#13;
<p>Following is a row-level validator based on the use of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">all()</code></span></span> function to ensure that all values are <span class="obeylines-h"><span class="verb"><code class="inlineCode">float</code></span></span> (or none of the values are <span class="obeylines-h"><span class="verb"><code class="inlineCode">None</code></span></span>):</p>&#13;
<pre id="listing-145" class="lstlisting"><code>all_numeric: Callable[[R_Float], bool] = \Â &#13;
Â Â Â Â lambda row: all(row) and len(row) == 8</code></pre>&#13;
<p>This lambda is a kind of reduction, transforming a row of floating-point values to a Boolean value if all values are not â€falsyâ€ (that is, neither <span class="obeylines-h"><span class="verb"><code class="inlineCode">None</code></span></span> nor zero) and there are exactly eight values.</p>&#13;
<p>The simplistic <span class="obeylines-h"><span class="verb"><code class="inlineCode">all_numeric()</code></span></span> function conflates zero and <span class="obeylines-h"><span class="verb"><code class="inlineCode">None</code></span></span>. A more sophisticated test would rely on something such as <span class="obeylines-h"><span class="verb"><code class="inlineCode">not</code><code class="inlineCode">Â any(item</code><code class="inlineCode">Â is</code><code class="inlineCode">Â None</code><code class="inlineCode">Â for</code><code class="inlineCode">Â item</code><code class="inlineCode">Â in</code><code class="inlineCode">Â row)</code></span></span>. The rewrite is left as an exercise for the reader.</p>&#13;
<p>The essential<span id="dx1-143038"/> design is to create row-based elements that can be combined to create more complete algorithms for parsing<span id="dx1-143039"/> an input file. The foundational functions iterate over tuples of text. These are combined to convert and validate the converted data. For the cases where files are either in first normal form (all rows are the same) or a simple validator can reject the extraneous rows, this design pattern works out nicely.</p>&#13;
<p>All parsing problems arenâ€™t quite this simple, however. Some files have important data in header or trailer rows that must be preserved, even though it doesnâ€™t match the format of the rest of the file. These non-normalized files will require a more sophisticated parser design.</p>&#13;
</section>&#13;
<section id="parsing-plain-text-files-with-headers" class="level5 likesubsubsectionHead" data-number="0.10.3.6.2">&#13;
<h5 class="likesubsubsectionHead" data-number="0.10.3.6.2"><span id="x1-1440006"/>Parsing plain text files with headers</h5>&#13;
<p>In <a href="Chapter_03.xhtml#x1-510003"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109">Â 3</span></a>, <a href="Chapter_03.xhtml#x1-510003"><span class="cmti-10x-x-109">Functions, Iterators, and Generators</span></a>, the <span class="obeylines-h"><span class="verb"><code class="inlineCode">Crayola.GPL</code></span></span> file was presented without showing the parser. This file looks<span id="dx1-144001"/> as follows:</p>&#13;
<pre id="listing-146" class="lstlisting"><code>GIMP PaletteÂ &#13;
Name: CrayolaÂ &#13;
Columns: 16Â &#13;
#Â &#13;
239 222 205 AlmondÂ &#13;
205 149 117 Antique Brass</code></pre>&#13;
<p>We can parse a text file using regular expressions. We need to use a filter to read (and parse) header rows. We also want to return an iterable sequence of data rows. This rather complex two-part parsing is based entirely on the two-partâ€”head and tailâ€”file structure.</p>&#13;
<p>Following is a low-level parser<span id="dx1-144008"/> that handles both the four lines of the header and the long tail:</p>&#13;
<pre id="listing-147" class="lstlisting"><code>from collections.abc import IteratorÂ &#13;
from typing import TextIO, TypeAliasÂ &#13;
Â &#13;
Head_Body: TypeAlias = tuple[tuple[str, str], Iterator[list[str]]]Â &#13;
Â &#13;
def row_iter_gpl(file_obj: TextIO) -&gt; Head_Body:Â &#13;
Â Â Â Â header_pat = re.compile(Â &#13;
Â Â Â Â Â Â Â Â r"GIMP Palette\nName:\s*(.*?)\nColumns:\s*(.*?)\n#\n",Â &#13;
Â Â Â Â Â Â Â Â re.M)Â &#13;
Â &#13;
Â Â Â Â def read_head(file_obj: TextIO) -&gt; tuple[tuple[str, str], TextIO]:Â &#13;
Â Â Â Â Â Â Â Â if match := header_pat.match(Â &#13;
Â Â Â Â Â Â Â Â Â Â Â Â "".join(file_obj.readline() for _ in range(4))Â &#13;
Â Â Â Â Â Â Â Â ):Â &#13;
Â Â Â Â Â Â Â Â Â Â Â Â return (match.group(1), match.group(2)), file_objÂ &#13;
Â Â Â Â Â Â Â Â else:Â &#13;
Â Â Â Â Â Â Â Â Â Â Â Â raise ValueError("invalid header")Â &#13;
Â &#13;
Â Â Â Â def read_tail(Â &#13;
Â Â Â Â Â Â Â Â Â Â Â Â headers: tuple[str, str],Â &#13;
Â Â Â Â Â Â Â Â Â Â Â Â file_obj: TextIO) -&gt; Head_Body:Â &#13;
Â Â Â Â Â Â Â Â return (Â &#13;
Â Â Â Â Â Â Â Â Â Â Â Â headers,Â &#13;
Â Â Â Â Â Â Â Â Â Â Â Â (next_line.split() for next_line in file_obj)Â &#13;
Â Â Â Â Â Â Â Â )Â &#13;
Â &#13;
Â Â Â Â return read_tail(*read_head(file_obj))</code></pre>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">Head_Body</code></span></span> type definition summarizes<span id="dx1-144036"/> the overall goal of the row iterator. The result is a two-tuple. The first item is a two-tuple with details from the file header. The second item is an iterator that provides the text items for a color definition. This <span class="obeylines-h"><span class="verb"><code class="inlineCode">Head_Body</code></span></span> type hint is used in two places in this function definition.</p>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">header_pat</code></span></span> regular expression parses all four lines of the header. There are instances of <span class="obeylines-h"><span class="verb"><code class="inlineCode">()</code></span></span> in the expression to extract the name and column information from the header.</p>&#13;
<p>There are two internal functions for parsing different parts of the file. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">read_head()</code></span></span> function parses the header lines and returns interesting text and a <span class="obeylines-h"><span class="verb"><code class="inlineCode">TextIO</code></span></span> object that can be used for the rest of the parsing. It does this by reading four lines and merging them into a single long string. This is then parsed with the <span class="obeylines-h"><span class="verb"><code class="inlineCode">header_pat</code></span></span> regular expression.</p>&#13;
<p>The idea of returning<span id="dx1-144037"/> the iterator from one function to be used in another function is a pattern for passing an explicitly stateful object from one function to another. It seems helpful to make sure all of the arguments for the <span class="obeylines-h"><span class="verb"><code class="inlineCode">read_tail()</code></span></span> function are the results from the <span class="obeylines-h"><span class="verb"><code class="inlineCode">read_head()</code></span></span> function.</p>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">read_tail()</code></span></span> function parses the iterator over the remaining lines. These lines are merely split on spaces, since that fits the description of the GPL file format.</p>&#13;
<div id="tcolobox-152" class="packt_tip">&#13;
&#13;
&#13;
<p>For more information, visit the following link: <a href="https://code.google.com/p/grafx2/issues/detail?id=518" class="url">https://code.google.com/p/grafx2/issues/detail?id=518</a>.</p>&#13;
&#13;
</div>&#13;
<p>Once weâ€™ve transformed each line of the file into a canonical tuple-of-strings format, we can apply the higher level of parsing to this data. This involves conversion and (if necessary) validation.</p>&#13;
<p>The following is a higher-level parser command<span id="dx1-144038"/> snippet:</p>&#13;
<pre id="listing-148" class="lstlisting"><code>from collections.abc import IteratorÂ &#13;
from typing import NamedTupleÂ &#13;
Â &#13;
class Color(NamedTuple):Â &#13;
Â Â Â Â red: intÂ &#13;
Â Â Â Â blue: intÂ &#13;
Â Â Â Â green: intÂ &#13;
Â Â Â Â name: strÂ &#13;
Â &#13;
def color_palette(Â &#13;
Â Â Â Â Â Â Â Â headers: tuple[str, str],Â &#13;
Â Â Â Â Â Â Â Â row_iter: Iterator[list[str]]Â &#13;
) -&gt; tuple[str, str, tuple[Color, ...]]:Â &#13;
Â Â Â Â name, columns = headersÂ &#13;
Â Â Â Â colors = tuple(Â &#13;
Â Â Â Â Â Â Â Â Color(int(r), int(g), int(b), " ".join(name))Â &#13;
Â Â Â Â Â Â Â Â for r, g, b, *name in row_iterÂ &#13;
Â Â Â Â )Â &#13;
Â Â Â Â return name, columns, colors</code></pre>&#13;
<p>This function will work with the output of the lower-level <span class="obeylines-h"><span class="verb"><code class="inlineCode">row_iter_gpl()</code></span></span> parser: it requires the headers and the iterator<span id="dx1-144058"/> over individual rows. This function will use the multiple assignment feature of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">for</code></span></span> clause in the generator to separate the color numbers and the remaining words into four variables, <span class="obeylines-h"><span class="verb"><code class="inlineCode">r</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">g</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">b</code></span></span>, and <span class="obeylines-h"><span class="verb"><code class="inlineCode">name</code></span></span>. The use of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">*name</code></span></span> parameter ensures that all remaining values will be assigned to the <span class="obeylines-h"><span class="verb"><code class="inlineCode">name</code></span></span> variable as a tuple. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">"</code><code class="inlineCode">Â ".join(name)</code></span></span> expression then concatenates the words into a single space-separated string.</p>&#13;
<p>The following is how we can use this<span id="dx1-144059"/> two-tier parser:</p>&#13;
<div id="tcolobox-153" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; from pathlib import PathÂ &#13;
&gt;&gt;&gt; source_path = Path("crayola.gpl")Â &#13;
&gt;&gt;&gt; with source_path.open() as source:Â &#13;
...     name, cols, colors = color_palette(Â &#13;
...         *row_iter_gpl(source)Â &#13;
...     )Â &#13;
&gt;&gt;&gt; nameÂ &#13;
â€™Crayolaâ€™Â &#13;
&gt;&gt;&gt; colsÂ &#13;
â€™16â€™Â &#13;
&gt;&gt;&gt; len(colors)Â &#13;
133</code></pre>&#13;
&#13;
</div>&#13;
<p>Weâ€™ve applied the higher-level parser to the results of the lower-level parser. This will return the headers and a tuple built from the sequence of <span class="obeylines-h"><span class="verb"><code class="inlineCode">Color</code></span></span> objects. <span id="x1-144073r143"/></p>&#13;
</section>&#13;
</section>&#13;
</section>&#13;
<section id="summary-5" class="level3 sectionHead" data-number="0.10.4">&#13;
<h3 class="sectionHead" data-number="0.10.4"><span class="titlemark">6.4 </span> <span id="x1-1450004"/>Summary</h3>&#13;
<p>In this chapter, weâ€™ve looked at two significant functional programming topics. Weâ€™ve looked at recursions in some detail. Many functional programming language compilers will optimize a recursive function to transform a call in the tail of the function to a loop. This is sometimes called tail recursion elimination. More commonly, itâ€™s known as tail-call optimization. In Python, we must do the tail-call optimization manually by using an explicit <span class="obeylines-h"><span class="verb"><code class="inlineCode">for</code></span></span> statement, replacing a purely functional recursion.</p>&#13;
<p>Weâ€™ve also looked at reduction algorithms, including <span class="obeylines-h"><span class="verb"><code class="inlineCode">sum()</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">count()</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">max()</code></span></span>, and <span class="obeylines-h"><span class="verb"><code class="inlineCode">min()</code></span></span> functions. We looked at the <span class="obeylines-h"><span class="verb"><code class="inlineCode">collections.Counter()</code></span></span> function and related <span class="obeylines-h"><span class="verb"><code class="inlineCode">groupby()</code></span></span> reductions.</p>&#13;
<p>Weâ€™ve also looked at how parsing (and lexical scanning) are similar to reductions since they transform sequences of tokens (or sequences of characters) into higher-order collections with more complex properties. Weâ€™ve examined a design pattern that decomposes parsing into a lower level and tries to produce tuples of raw strings, and a higher level that creates more useful application objects.</p>&#13;
<p>In the next chapter, weâ€™ll look at some techniques appropriate to working with named tuples and other immutable data structures. Weâ€™ll look at techniques that make stateful objects unnecessary. While stateful objects arenâ€™t purely functional, the idea of a class hierarchy can be used to package related method definitions. <span id="x1-145001r152"/></p>&#13;
</section>&#13;
<section id="exercises-5" class="level3 sectionHead" data-number="0.10.5">&#13;
<h3 class="sectionHead" data-number="0.10.5"><span class="titlemark">6.5 </span> <span id="x1-1460005"/>Exercises</h3>&#13;
<p>This chapterâ€™s exercises are based on code available from Packt Publishing on GitHub. See <a href="https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition" class="url">https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition</a>.</p>&#13;
<p>In some cases, the reader will notice that the code provided on GitHub includes partial solutions to some of the exercises. These serve as hints, allowing the reader to explore alternative solutions.</p>&#13;
<p>In many cases, exercises will need unit test cases to confirm they actually solve the problem. These are often identical to the unit test cases already provided in the GitHub repository. The reader should replace the bookâ€™s example function name with their own solution to confirm that it works. <span id="x1-146001r149"/></p>&#13;
<section id="multiple-recursion-and-caching" class="level4 subsectionHead" data-number="0.10.5.1">&#13;
<h4 class="subsectionHead" data-number="0.10.5.1"><span class="titlemark">6.5.1 </span> <span id="x1-1470001"/>Multiple recursion and caching</h4>&#13;
<p>In <a href="#x1-1300003"><span class="cmti-10x-x-109">Handling difficult tail-call optimization</span></a>, we looked at a naive definition of a function to compute Fibonacci numbers, the <span class="obeylines-h"><span class="verb"><code class="inlineCode">fib()</code></span></span> function. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">functools.cache</code></span></span> decorator can have a profound impact on the performance of this algorithm.</p>&#13;
<p>Implement both versions and describe the impact of caching on the time required to compute large Fibonacci numbers. <span id="x1-147001r154"/></p>&#13;
</section>&#13;
<section id="refactor-the-all_print-function" class="level4 subsectionHead" data-number="0.10.5.2">&#13;
<h4 class="subsectionHead" data-number="0.10.5.2"><span class="titlemark">6.5.2 </span> <span id="x1-1480002"/>Refactor the all_print() function</h4>&#13;
<p>In <a href="#x1-1350001"><span class="cmti-10x-x-109">Tail-call optimization using deques</span></a>, we showed a function that used a <span class="obeylines-h"><span class="verb"><code class="inlineCode">collections.deque</code></span></span> to visit all nodes in a directory tree, summing the value for each node that is a proper file. This can be done with a list as well as a <span class="obeylines-h"><span class="verb"><code class="inlineCode">deque</code></span></span>, with some minor code changes.</p>&#13;
<p>This function embedded a specific computation. This computation (finding all occurrences of â€printâ€) really should have been a separate function. The body of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">all_print()</code></span></span> function should be refactored into two functions:</p>&#13;
<ul>&#13;
<li><p>A generic directory traverse that applies a function to each text file with the expected suffix and sums the results.</p></li>&#13;
<li><p>A function that counts instances of â€printâ€ in a given Python file.</p></li>&#13;
</ul>&#13;
<p><span id="x1-148001r155"/></p>&#13;
</section>&#13;
<section id="parsing-csv-files-1" class="level4 subsectionHead" data-number="0.10.5.3">&#13;
<h4 class="subsectionHead" data-number="0.10.5.3"><span class="titlemark">6.5.3 </span> <span id="x1-1490003"/>Parsing CSV files</h4>&#13;
<p>See the <a href="#x1-1430006"><span class="cmti-10x-x-109">Parsing CSV files</span></a> section, earlier in this chapter. In that example, the simplistic <span class="obeylines-h"><span class="verb"><code class="inlineCode">all_numeric()</code></span></span> function conflates zero and <span class="obeylines-h"><span class="verb"><code class="inlineCode">None</code></span></span>.</p>&#13;
<p>Create a test case for this function that will show that it does not handle zero correctly, treating it as <span class="obeylines-h"><span class="verb"><code class="inlineCode">None</code></span></span>. Once the test case is defined, rewrite the <span class="obeylines-h"><span class="verb"><code class="inlineCode">all_numeric()</code></span></span> function to distinguish between zero and <span class="obeylines-h"><span class="verb"><code class="inlineCode">None</code></span></span>.</p>&#13;
<p>Note that itâ€™s common practice in Python to use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">is</code></span></span> operator when comparing with <span class="obeylines-h"><span class="verb"><code class="inlineCode">None</code></span></span>. This specifically avoids some subtle problems that can arise when a class has an implementation of <span class="obeylines-h"><span class="verb"><code class="inlineCode">__eq__()</code></span></span> that doesnâ€™t handle <span class="obeylines-h"><span class="verb"><code class="inlineCode">None</code></span></span> as a properly distinct object. <span id="x1-149001r156"/></p>&#13;
</section>&#13;
<section id="classification-of-state-part-iii" class="level4 subsectionHead" data-number="0.10.5.4">&#13;
<h4 class="subsectionHead" data-number="0.10.5.4"><span class="titlemark">6.5.4 </span> <span id="x1-1500004"/>Classification of state, Part III</h4>&#13;
<p>See <a href="Chapter_05.xhtml#x1-1000005"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109">Â 5</span></a>, <a href="Chapter_05.xhtml#x1-1000005"><span class="cmti-10x-x-109">Higher-Order Functions</span></a>, the <a href="Chapter_05.xhtml#x1-1220001"><span class="cmti-10x-x-109">Classification of state</span></a> exercise.</p>&#13;
<p>Thereâ€™s a third way to consume status details and summarize them.</p>&#13;
<p>Write a reduce computation. This starts with an initial state of <span class="keyWord">Running</span>. As each serviceâ€™s three-tuple is folded into the result, there is a comparison between the state and the three-tuple. If the three-tuple has a non-responsive service, the state advances to <span class="keyWord">Stopped</span>. If the three-tuple has a slow or not working service, the state advances to <span class="keyWord">Degraded</span>. If no problems are found, the initial value becomes the final health of the overall system.</p>&#13;
<p>The idea is to provide a <span class="obeylines-h"><span class="verb"><code class="inlineCode">status_add(previous,</code><code class="inlineCode">Â this_service)</code></span></span> function. This can be used in the context of <span class="obeylines-h"><span class="verb"><code class="inlineCode">status</code><code class="inlineCode">Â =</code><code class="inlineCode">Â reduce(status_add,</code><code class="inlineCode">Â service_status_sequence,</code><code class="inlineCode">Â "Running")</code></span></span> to compute the current status of the sequence of services. <span id="x1-150001r157"/></p>&#13;
</section>&#13;
<section id="diesel-engine-data" class="level4 subsectionHead" data-number="0.10.5.5">&#13;
<h4 class="subsectionHead" data-number="0.10.5.5"><span class="titlemark">6.5.5 </span> <span id="x1-1510005"/>Diesel engine data</h4>&#13;
<p>A diesel engine has had some repairs that raised doubts about the accuracy of the tachometer. After some heroic effort, the following table of data was collected showing the observed reading on the engineâ€™s tachometer, and the actual RPMs measured with an optical device on the engine.</p>&#13;
<div class="table">&#13;
<div class="tabular">&#13;
<table id="TBL-1" class="tabular">&#13;
<tbody>&#13;
<tr id="TBL-1-1-" class="odd" style="vertical-align:baseline;">&#13;
<td id="TBL-1-1-1" class="td11" style="text-align: right; white-space: nowrap;"><span class="keyWord">Sample </span></td>&#13;
<td id="TBL-1-1-2" class="td11" style="text-align: right; white-space: nowrap;"><span class="keyWord">Tach </span></td>&#13;
<td id="TBL-1-1-3" class="td11" style="text-align: right; white-space: nowrap;"><span class="keyWord">Engine </span></td>&#13;
</tr>&#13;
<tr id="TBL-1-2-" class="even" style="vertical-align:baseline;">&#13;
<td id="TBL-1-2-1" class="td11" style="text-align: right; white-space: nowrap;">1</td>&#13;
<td id="TBL-1-2-2" class="td11" style="text-align: right; white-space: nowrap;">1000</td>&#13;
<td id="TBL-1-2-3" class="td11" style="text-align: right; white-space: nowrap;">883</td>&#13;
</tr>&#13;
<tr id="TBL-1-3-" class="odd" style="vertical-align:baseline;">&#13;
<td id="TBL-1-3-1" class="td11" style="text-align: right; white-space: nowrap;">2</td>&#13;
<td id="TBL-1-3-2" class="td11" style="text-align: right; white-space: nowrap;">1500</td>&#13;
<td id="TBL-1-3-3" class="td11" style="text-align: right; white-space: nowrap;">1242</td>&#13;
</tr>&#13;
<tr id="TBL-1-4-" class="even" style="vertical-align:baseline;">&#13;
<td id="TBL-1-4-1" class="td11" style="text-align: right; white-space: nowrap;">3</td>&#13;
<td id="TBL-1-4-2" class="td11" style="text-align: right; white-space: nowrap;">1500</td>&#13;
<td id="TBL-1-4-3" class="td11" style="text-align: right; white-space: nowrap;">1217</td>&#13;
</tr>&#13;
<tr id="TBL-1-5-" class="odd" style="vertical-align:baseline;">&#13;
<td id="TBL-1-5-1" class="td11" style="text-align: right; white-space: nowrap;">4</td>&#13;
<td id="TBL-1-5-2" class="td11" style="text-align: right; white-space: nowrap;">1600</td>&#13;
<td id="TBL-1-5-3" class="td11" style="text-align: right; white-space: nowrap;">1306</td>&#13;
</tr>&#13;
<tr id="TBL-1-6-" class="even" style="vertical-align:baseline;">&#13;
<td id="TBL-1-6-1" class="td11" style="text-align: right; white-space: nowrap;">5</td>&#13;
<td id="TBL-1-6-2" class="td11" style="text-align: right; white-space: nowrap;">1750</td>&#13;
<td id="TBL-1-6-3" class="td11" style="text-align: right; white-space: nowrap;">1534</td>&#13;
</tr>&#13;
<tr id="TBL-1-7-" class="odd" style="vertical-align:baseline;">&#13;
<td id="TBL-1-7-1" class="td11" style="text-align: right; white-space: nowrap;">6</td>&#13;
<td id="TBL-1-7-2" class="td11" style="text-align: right; white-space: nowrap;">2000</td>&#13;
<td id="TBL-1-7-3" class="td11" style="text-align: right; white-space: nowrap;">1805</td>&#13;
</tr>&#13;
<tr id="TBL-1-8-" class="even" style="vertical-align:baseline;">&#13;
<td id="TBL-1-8-1" class="td11" style="text-align: right; white-space: nowrap;">7</td>&#13;
<td id="TBL-1-8-2" class="td11" style="text-align: right; white-space: nowrap;">2000</td>&#13;
<td id="TBL-1-8-3" class="td11" style="text-align: right; white-space: nowrap;">1720</td>&#13;
</tr>&#13;
<tr id="TBL-1-9-" class="odd" style="vertical-align:baseline;">&#13;
<td id="TBL-1-9-1" class="td11" style="text-align: right; white-space: nowrap;"/>&#13;
<td style="text-align: right;"/>&#13;
<td style="text-align: right;"/>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div>&#13;
</div>&#13;
<p>If needed, create a CSV file with the data. If you have access to the GitHub repository for this book, this is available in the <span class="obeylines-h"><span class="verb"><code class="inlineCode">engine.csv</code></span></span> file.</p>&#13;
<p>Create a <span class="obeylines-h"><span class="verb"><code class="inlineCode">NamedTuple</code></span></span> for each sample and write some functions to acquire this data in a useful form. Once the data is available, see the <a href="Chapter_04.xhtml#x1-850001"><span class="cmti-10x-x-109">Using sums and counts</span> <span class="cmti-10x-x-109">for statistics</span></a> section of <a href="Chapter_04.xhtml#x1-740004"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109">Â 4</span></a>, <a href="Chapter_04.xhtml#x1-740004"><span class="cmti-10x-x-109">Working with Collections</span></a>, for a definition of a correlation function.</p>&#13;
<p>The objective is to apply this correlation function to the engine and tach values to see if the values correlate. If they do, it suggests that the engineâ€™s instruments can be recalibrated. If they donâ€™t correlate, something else is wrong with the engine.</p>&#13;
<p>Note that the <a href="Chapter_04.xhtml#x1-740004"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109">Â 4</span></a>, <a href="Chapter_04.xhtml#x1-740004"><span class="cmti-10x-x-109">Working with Collections</span></a>, correlation example may have assumptions about data types that donâ€™t necessarily apply to the <span class="obeylines-h"><span class="verb"><code class="inlineCode">NamedTuple</code></span></span> defined earlier. If necessary, rewrite the type hints or your <span class="obeylines-h"><span class="verb"><code class="inlineCode">NamedTuple</code></span></span> definition. Note that it can be difficult to write perfectly generic type hints, and it often takes a bit of work to resolve the differences.</p>&#13;
</section>&#13;
</section>&#13;
<section id="join-our-community-discord-space-6" class="level3 likesectionHead" data-number="0.10.6">&#13;
<h3 class="likesectionHead" data-number="0.10.6"><span id="x1-1520005"/>Join our community Discord space</h3>&#13;
<p>Join our Python Discord workspace to discuss and know more about the book: <a href="https://packt.link/dHrHU">https://packt.link/dHrHU</a></p>&#13;
<p><img src="../Images/file1.png" alt="PIC" width="85" height="85"/> <span id="x1-152001r133"/></p>&#13;
</section>&#13;
</section>&#13;
</body></html>