- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with WebSocket
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Real-time communication has become increasingly important in modern web applications,
    enabling interactive features such as chat, notifications, and live updates. In
    this chapter, we’ll explore the exciting world of WebSockets and how to leverage
    them effectively in FastAPI applications. From setting up WebSocket connections
    to implementing advanced features such as chat functionality and error handling,
    this chapter provides a comprehensive guide to building responsive, real-time
    communication features. By the end of the chapter, you will have the skills to
    create WebSockets and facilitate real-time communication in FastAPI applications,
    enabling interactive functionalities and dynamic user experiences.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Websockets in FastAPI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending and receiving messages over WebSockets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling WebSocket connections and disconnections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling WebSocket errors and exceptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing chat functionality with WebSocket
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing WebSocket performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing WebSocket connections with OAuth2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow along with the WebSockets recipes, make sure you have the following
    essentials in your setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**: Install a Python version higher than 3.9 in your environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**FastAPI**: This should be installed with all the required dependencies. If
    you haven’t done it in the previous chapters, you can simply do it from your terminal:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The code used in the chapter is hosted on GitHub at [https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter09](https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter09).
  prefs: []
  type: TYPE_NORMAL
- en: It is recommended to set up a virtual environment for the project in the project
    root folder to efficiently manage dependencies and maintain project isolation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within your virtual environment, you can install all the dependencies at once
    by using the `requirements.txt` file provided in the GitHub repository in the
    project folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Since the interactive Swagger documentation is limited at the time of writing,
    basic mastering of **Postman** or any other testing API is beneficial to test
    our API.
  prefs: []
  type: TYPE_NORMAL
- en: Having basic knowledge of how **WebSockets** work can be beneficial, although
    it’s not necessary since the recipes will guide you through.
  prefs: []
  type: TYPE_NORMAL
- en: For the *Implementing chat functionality with WebSockets* recipe, we will write
    some basic **HTML**, including some **Javascript** code.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up WebSockets in FastAPI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WebSockets provide a powerful mechanism for establishing full-duplex communication
    channels between clients and servers, allowing real-time data exchange. In this
    recipe, you’ll learn how to establish a connection with WebSocket functionality
    in your FastAPI applications to enable interactive and responsive communication.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before diving into the recipe, ensure you have all the required packages in
    your environment. You can install them from the `requirements.txt` file provided
    in the GitHub repository or install it manually with `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Since the swagger documentation does not support WebSocket, we will use an external
    tool to test the WebSocket connection, such as Postman.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find instructions on how to install it on the website: [https://www.postman.com/downloads/](https://www.postman.com/downloads/).'
  prefs: []
  type: TYPE_NORMAL
- en: The free community version will be enough to test the recipes.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create the project root folder called `chat_platform`. we can create our `app`
    folder containing the `main.py` module. Let's build our simple application with
    a WebSocket endpoint as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can start by creating our server in the `main.py` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then we can create the WebSocket endpoint to connect the client to the chat
    room:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The endpoint establishes the connection with the client, sends a welcome message,
    and closes the connection. This is the most basic configuration of a WebSocket
    endpoint.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'That''s it. To test it, spin up the server from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Welcome to the chat room! 12:37:19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: import logging
  prefs: []
  type: TYPE_NORMAL
- en: logger = logging.getLogger("uvicorn")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '@app.websocket("/ws")'
  prefs: []
  type: TYPE_NORMAL
- en: 'async def ws_endpoint(websocket: WebSocket):'
  prefs: []
  type: TYPE_NORMAL
- en: await websocket.accept()
  prefs: []
  type: TYPE_NORMAL
- en: await websocket.send_text(
  prefs: []
  type: TYPE_NORMAL
- en: '"Welcome to the chat room!"'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: 'while True:'
  prefs: []
  type: TYPE_NORMAL
- en: data = await websocket.receive_text()
  prefs: []
  type: TYPE_NORMAL
- en: 'logger.info(f"Message received: {data}")'
  prefs: []
  type: TYPE_NORMAL
- en: websocket.close() call from the previous recipe and used an infinite while loop.
    This allows the server side to continuously receive the message from the client
    and print it to the console without closing the connection. In this case, the
    connection can be closed only by the client.
  prefs: []
  type: TYPE_NORMAL
- en: This is all you need to read messages from the client and send it to the terminal
    output.
  prefs: []
  type: TYPE_NORMAL
- en: The server initiates a connection request when the client call the endpoint.
    With the `websocket.receive_text()` function, the server opens the connection
    and it is ready to receive the message from the client. The message is stored
    into the `data` variable and it is printed to terminal output. Then the server
    sends a confirmation message to the client.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s test it. Spin up the server by running `uvicorn app.main:app` from the
    command line and open Postman. Then apply the following steps.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new WebSocket request, and connect to the `ws://localhost:8000/ws`
    address.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once the connection is established, you will see on the terminal output the
    message:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'INFO: Message received: Hello FastAPI application'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Message received! 14:46:20
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 2.  You can then close the connection from the client by clicking on the **Disconnect**
    button to the right of the WebSocket **URL** field.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: By enabling the server to receive messages from the client, you have just enabled
    bidirectional communication between the client and server through a WebSocket.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: The `Fastapi.WebSocket` instance is, in reality, a `starlette.WebSocket` class
    from the `send_json` or `receive_json` methods).
  prefs: []
  type: TYPE_NORMAL
- en: 'Check more on the official Starlette documentation page:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Starlette* *Websockets*: [https://www.starlette.io/websockets/](https://www.starlette.io/websockets/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling WebSocket connections and disconnections
  prefs: []
  type: TYPE_NORMAL
- en: When a client establishes a WebSocket connection with a **FastAPI** server,
    it’s crucial to handle the lifecycle of these connections appropriately. This
    includes accepting incoming connections, maintaining active connections, and handling
    disconnections gracefully to ensure smooth communication between the client and
    server. In this recipe, we’ll explore how to effectively manage WebSocket connections
    and gracefully handle disconnections.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs: []
  type: TYPE_NORMAL
- en: To follow the recipe, you will need to have **Postman** or any other tool to
    test WebSocket connections. Also, you need to already have a WebSocket endpoint
    implemented in your application. Check the previous two recipes if that is not
    the case.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs: []
  type: TYPE_NORMAL
- en: 'We will see how to manage the following two situations:'
  prefs: []
  type: TYPE_NORMAL
- en: Client-side disconnection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Server-side disconnection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s have a look at each of these situations in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Client-side disconnection
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed in the *Sending and receiving messages over WebSockets*
    recipe that if the connection is closed from the client (e.g., from Postman) on
    the server console, a `WebSocketDisconnect` exception propagates, uncaptured.
  prefs: []
  type: TYPE_NORMAL
- en: This is because the disconnection from the client side should be properly handled
    in a `try-except` block.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s adjust the endpoint to take this into account. In the `main.py` module,
    we modify the `/ws`endpoint as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '@app.websocket("/ws")'
  prefs: []
  type: TYPE_NORMAL
- en: 'async def ws_endpoint(websocket: WebSocket):'
  prefs: []
  type: TYPE_NORMAL
- en: await websocket.accept()
  prefs: []
  type: TYPE_NORMAL
- en: await websocket.send_text(
  prefs: []
  type: TYPE_NORMAL
- en: '"Welcome to the chat room!"'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: 'while True:'
  prefs: []
  type: TYPE_NORMAL
- en: data = await websocket.receive_text()
  prefs: []
  type: TYPE_NORMAL
- en: 'logger.info(f"Message received: {data}")'
  prefs: []
  type: TYPE_NORMAL
- en: 'if data == "disconnect":'
  prefs: []
  type: TYPE_NORMAL
- en: logger.warn("Disconnecting...")
  prefs: []
  type: TYPE_NORMAL
- en: await websocket.close()
  prefs: []
  type: TYPE_NORMAL
- en: data string content to then call the websocket.close method and exit the while
    loop.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the server, try to connect to the WebSocket `/ws` endpoint, and send
    the `"disconnect"` string as a message, the connection will be closed by the server.
  prefs: []
  type: TYPE_NORMAL
- en: You have seen how to manage disconnection and connection handshakes for a WebSocket
    endpoint, however, we still need to manage the right status code and messages
    for each. Let’s check this in the following recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Handling WebSocket errors and exceptions
  prefs: []
  type: TYPE_NORMAL
- en: WebSocket connections are susceptible to various errors and exceptions that
    can occur during the lifecycle of a connection. Common issues include connection
    failures, message parsing errors, and unexpected disconnections. Properly handling
    errors and correctly communicating with the client is essential to maintaining
    a responsive and resilient WebSocket-based application. In this recipe, we’ll
    explore how to handle WebSocket errors and exceptions effectively in FastAPI applications.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs: []
  type: TYPE_NORMAL
- en: The recipe will show how to manage WebSocket errors that can happen for a specific
    endpoint. We will showcase how to improve the `/ws` endpoint defined in the *Handling
    WebSocket connections and* *disconnections* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs: []
  type: TYPE_NORMAL
- en: The way the `/ws` endpoint is coded in the previous recipe returns the same
    response code and message when the server closes the connection. Just like for
    HTTP responses, FastAPI allows you to personalize the response to return a more
    meaningful message to the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how to do it. You can use a solution like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We have specified to the `websocket.close` method a status code and reason that
    will be transmitted to the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we now spin up the server and send the disconnect message from the client,
    you will see a disconnection log message in the response window, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This is all you need to gracefully disconnect your WebSocket connection.
  prefs: []
  type: TYPE_NORMAL
- en: Alternative solution
  prefs: []
  type: TYPE_NORMAL
- en: Similarly to how an `HTTPException` instance is rendered for HTTP requests (see
    the *Handling errors and exceptions* recipe in [*Chapter 1*](B21025_01.xhtml#_idTextAnchor020),
    *First Steps with FastAPI*), FastAPI also enables the use of `WebSocketException`
    for WebSocket connections, which is rendered automatically as a response.
  prefs: []
  type: TYPE_NORMAL
- en: 'To better understand, imagine we want to disconnect the client if they write
    something that isn’t allowed – for example, the `"bad message"` text string. Let’s
    modify the chatroom endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If you spin up the server and try to send whatever message contains the `"bad
    message"` string, the client will be disconnected. Furthermore, on the **Response**
    panel section of Postman of your WebSocket connection you will see the following
    log message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You have just seen how to communicate WebSocket errors to the client by raising
    the appropriate exception. You can use this strategy for a variety of errors that
    can arise while running the application and have to be correctly communicated
    to the API consumer.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: 'WebSocket is a relatively new protocol compared to HTTP, so it is still evolving
    with time. Although status codes are not extensively used, like for HTTP, you
    can find definitions of WebSockets codes at the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '*WebSocket Close Code Number* *Registry*: [https://www.iana.org/assignments/websocket/websocket.xml#close-code-number](https://www.iana.org/assignments/websocket/websocket.xml#close-code-number)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can also find a list of the compatibility of WebSocket events for browsers
    on the following page:'
  prefs: []
  type: TYPE_NORMAL
- en: '*WebSocket* *CloseEvent*: [https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent](https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Furthermore, the `WebSocketException` class in FastAPI is documented at the
    official documentation link:'
  prefs: []
  type: TYPE_NORMAL
- en: '*FastAPI WebSocketExcpetion API* *documentation*: [https://fastapi.tiangolo.com/reference/exceptions/#fastapi.WebSocketException](https://fastapi.tiangolo.com/reference/exceptions/#fastapi.WebSocketException)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing chat functionality with WebSockets
  prefs: []
  type: TYPE_NORMAL
- en: Real-time chat functionality is a common feature in many modern web applications,
    enabling users to communicate instantly with each other. In this recipe, we’ll
    explore how to implement chat functionality using WebSockets in FastAPI applications.
  prefs: []
  type: TYPE_NORMAL
- en: By leveraging WebSockets, we will create a bidirectional communication channel
    between the server and multiple clients, allowing messages to be sent and received
    in real time.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs: []
  type: TYPE_NORMAL
- en: To follow the recipe, you need to have a good understanding of WebSockets and
    know how to build a WebSocket endpoint using FastAPI.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, having some basic knowledge of HTML and JavaScript can help create
    simple web pages for the application. The recipe we’ll be using is the foundation
    of our chat application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, we will use the `jinja2` package to apply basic templating for the HTML
    page. Make sure to have it in your environment. If you didn’t install packages
    with `requirements.txt`, install `jinja2` with `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Once the installation is complete, we are ready to start with the recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs: []
  type: TYPE_NORMAL
- en: 'To build the application, we will need to build three core pieces – the WebSocket
    connections manager, the WebSocket endpoint, and the chat HTML page:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by building the connection manager. The role of the connection
    manager is to keep track of open WebSocket connections and broadcast messages
    to active ones. Let’s define the `ConnectionManager` class in a dedicated `ws_manager.py`
    module under the `app` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `async def connect` method will be responsible for the handshake and adding
    the WebSocket to the list of active ones. The `def disconnect` method will remove
    the WebSocket from the list of active connections. The `async def send_personal_message`
    method will send a message to a specific WebSocket. Finally, `async def broadcast`
    will send the message to all the active connections except one, if specified.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The connection manager will then be used in the chat WebSocket endpoint.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.  Let’s create the WebSocket endpoint in a separate module called `chat.py`.
    Let’s initialize the connection manager:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then we define the router:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And finally, we can define the WebSocket endpoint:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '3.  After a new client joins a chat, the connection manager sends a message
    to all chat participants to notify them of the new arrival. The endpoint uses
    the `username` path parameter to retrieve the client’s name. Don’t forget to add
    the router to the FastAPI object in the `main.py` file:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <!doctype html>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <html>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <head>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <title>Chat</title>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: </head>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <body>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <h1>WebSocket Chat</h1>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '<h2>Your ID: <span id="ws-id"></span></h2>'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <form action="" onsubmit="sendMessage(event)">
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <input
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: type="text"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: id="messageText"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: autocomplete="off"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: />
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <button>Send</button>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: </form>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <ul id="messages"></ul>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <script>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <!—content of js script -->
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <script/>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: </body>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: </html>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '4.  To conclude, we need to build the endpoint that returns the HTML page.
    We can build it in the same `chat.py` module:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The endpoint will take as a path parameter the username of the client that will
    show in the chat conversation.
  prefs: []
  type: TYPE_NORMAL
- en: You have set up a basic chat room within your FastAPI application with the WebSockets
    protocol. You only have to spin up the server with `uvicorn app.main:app` and
    connect to `http://localhost:8000/chatroom/your-username` from your browser. Then,
    from another page, connect to the same address with a different username and start
    exchanging messages between the two browsers.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs: []
  type: TYPE_NORMAL
- en: When connecting to the `GET /chatroom/{username}` endpoint address (`http://localhost:8000/chatroom/{username}`),
    the server will use the username to render the HTML page customized to the username.
  prefs: []
  type: TYPE_NORMAL
- en: The HTML will contain the code to make the connection to the `/chatroom` WebSocket
    endpoint and create a new WebSocket connection for each user.
  prefs: []
  type: TYPE_NORMAL
- en: The endpoint will then use the `ConnectionManager()` connection manager object
    to exchange messages between all clients through the HTML page.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: 'We have used a basic feature of the Jinja2 templating library. However, you
    can free your creativity and discover the potential of this package by looking
    at the documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Jinja2* *Documentation*: [https://jinja.palletsprojects.com/en/3.1.x/](https://jinja.palletsprojects.com/en/3.1.x/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing WebSocket performance
  prefs: []
  type: TYPE_NORMAL
- en: WebSocket connections provide a powerful mechanism for real-time communication
    between clients and servers. To ensure the optimal performance and scalability
    of WebSocket applications, it’s essential to implement effective optimization
    techniques and a way to measure them. In this recipe, we will see how to benchmark
    WebSocket endpoints to test the number of connections supported by the connection
    and suggest practical tips and techniques to optimize WebSocket performance in
    your FastAPI applications.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs: []
  type: TYPE_NORMAL
- en: Besides knowledge of how to set up a WebSocket endpoint, we will use the *Implementing
    chat functionality with WebSockets* recipe to benchmark the traffic supported.
    You can also follow the recipe by applying the strategy to your application.
  prefs: []
  type: TYPE_NORMAL
- en: Whether you apply it to your application or the chat functionality, it can be
    useful to include some message logs to be printed during the endpoint execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, for the WebSocket `/chatroom/{username}` endpoint, you can add
    a log after each message broadcast as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We are now ready to create a benchmark script to test our chat functionality.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create the script file under the root folder and call it `benchmark_websocket.py`.
    A typical benchmark script should do the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Define a function to run the FastAPI server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define another function to connect *n* number of clients of the WebSocket endpoint
    and exchange a certain number of messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wrap up the previous steps by running the server in a separate process and running
    the clients
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are the steps to create the script:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by defining a function to run our server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `run_server` function is an alternative to the command-line `uvicorn app.main:app`
    command we are used to running from the terminal.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.  Now let’s define a function that will create a certain number of clients
    that will connect to the WebSocket endpoint and exchange some messages:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To simulate concurrent connection patterns, we use an `async def` function.
    This will enable us to evaluate the server’s performance under the high load of
    simultaneous requests to the endpoint.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Furthermore, we added some asynchronous sleeping time (`asyncio.sleep`) between
    messages to simulate the human behavior of the chat’s client.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.  Then, we can execute all the previous functions in a single overall `async
    def main` function as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The function creates a process to spin up the server, start it, wait some time
    to finish the startup, and simultaneously run all the clients to call the server.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '4.  Finally, to make it run, we need to pass it to the event loop if it is
    run as a script. We can do it like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To run the script, simply run it as a Python script from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '@app.websocket("/secured-ws")'
  prefs: []
  type: TYPE_NORMAL
- en: async def secured_websocket(
  prefs: []
  type: TYPE_NORMAL
- en: 'websocket: WebSocket,'
  prefs: []
  type: TYPE_NORMAL
- en: 'username: str'
  prefs: []
  type: TYPE_NORMAL
- en: '):'
  prefs: []
  type: TYPE_NORMAL
- en: await websocket.accept()
  prefs: []
  type: TYPE_NORMAL
- en: await websocket.send_text(f"Welcome {username}!")
  prefs: []
  type: TYPE_NORMAL
- en: 'async for data in websocket.iter_text():'
  prefs: []
  type: TYPE_NORMAL
- en: await websocket.send_text(
  prefs: []
  type: TYPE_NORMAL
- en: 'f"You wrote: {data}"'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: from fastapi import (
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: WebSocket,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: WebSocketException,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: status,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: from fastapi.security import OAuth2PasswordBearer
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: class OAuth2WebSocketPasswordBearer(
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: OAuth2PasswordBearer
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: async def __call__(
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'self, websocket: WebSocket'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ') -> str:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'authorization: str = websocket.headers.get('
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"authorization"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if not authorization:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: raise WebSocketException(
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: code=status.HTTP_401_UNAUTHORIZED,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: reason="Not authenticated",
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: scheme, param = authorization.split()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if scheme.lower() != "bearer":'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: raise WebSocketException(
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: code=status.HTTP_403_FORBIDDEN,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: reason=(
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"Invalid authentication "'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"credentials"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ),
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return param
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: from app.ws_password_bearer import (
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: OAuth2WebSocketPasswordBearer,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: oauth2_scheme_for_ws = OAuth2WebSocketPasswordBearer(
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: tokenUrl="/token"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: def get_username_from_token(
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'token: str = Depends(oauth2_scheme_for_ws),'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ') -> str:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: user = fake_token_resolver(token)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if not user:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: raise WebSocketException(
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: code=status.HTTP_401_UNAUTHORIZED,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: reason=(
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"Invalid authentication credentials"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return user.username
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: from import Annotated
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: from fastapi import Depends
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: from app.security import get_username_from_token
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '@app.websocket("/secured-ws")'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: async def secured_websocket(
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'websocket: WebSocket,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'username: Annotated['
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: get_username_from_token, Depends()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ']'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '# rest of the endpoint'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ uvicorn app.main:app
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
