- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Working with WebSocket
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用WebSocket
- en: Real-time communication has become increasingly important in modern web applications,
    enabling interactive features such as chat, notifications, and live updates. In
    this chapter, we’ll explore the exciting world of WebSockets and how to leverage
    them effectively in FastAPI applications. From setting up WebSocket connections
    to implementing advanced features such as chat functionality and error handling,
    this chapter provides a comprehensive guide to building responsive, real-time
    communication features. By the end of the chapter, you will have the skills to
    create WebSockets and facilitate real-time communication in FastAPI applications,
    enabling interactive functionalities and dynamic user experiences.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代Web应用程序中，实时通信变得越来越重要，它使得聊天、通知和实时更新等交互式功能成为可能。在本章中，我们将探索令人兴奋的WebSocket世界，以及如何在FastAPI应用程序中有效地利用它们。从设置WebSocket连接到实现聊天功能和错误处理等高级功能，本章提供了构建响应式、实时通信功能的全面指南。到本章结束时，你将具备在FastAPI应用程序中创建WebSocket并促进实时通信的技能，从而实现交互式功能和动态用户体验。
- en: 'In this chapter, we’re going to cover the following recipes:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下食谱：
- en: Setting up Websockets in FastAPI
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在FastAPI中设置WebSockets
- en: Sending and receiving messages over WebSockets
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过WebSocket发送和接收消息
- en: Handling WebSocket connections and disconnections
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理WebSocket连接和断开
- en: Handling WebSocket errors and exceptions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理WebSocket错误和异常
- en: Implementing chat functionality with WebSocket
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用WebSocket实现聊天功能
- en: Optimizing WebSocket performance
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化WebSocket性能
- en: Securing WebSocket connections with OAuth2
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用OAuth2保护WebSocket连接
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow along with the WebSockets recipes, make sure you have the following
    essentials in your setup:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟随WebSocket食谱，确保你的设置中包含以下基本要素：
- en: '**Python**: Install a Python version higher than 3.9 in your environment.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Python**：在你的环境中安装一个高于3.9版本的Python。'
- en: '**FastAPI**: This should be installed with all the required dependencies. If
    you haven’t done it in the previous chapters, you can simply do it from your terminal:'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FastAPI**：应安装所有必需的依赖项。如果你在前几章中没有这样做，你可以简单地从你的终端执行：'
- en: '[PRE0]'
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The code used in the chapter is hosted on GitHub at [https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter09](https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter09).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的代码托管在GitHub上，网址为[https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter09](https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter09)。
- en: It is recommended to set up a virtual environment for the project in the project
    root folder to efficiently manage dependencies and maintain project isolation.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 建议在项目根目录中为项目设置一个虚拟环境，以有效地管理依赖项并保持项目隔离。
- en: 'Within your virtual environment, you can install all the dependencies at once
    by using the `requirements.txt` file provided in the GitHub repository in the
    project folder:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的虚拟环境中，你可以通过使用GitHub仓库中项目文件夹提供的`requirements.txt`文件一次性安装所有依赖项：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Since the interactive Swagger documentation is limited at the time of writing,
    basic mastering of **Postman** or any other testing API is beneficial to test
    our API.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 由于交互式Swagger文档在撰写时有限，因此基本掌握**Postman**或其他测试API对于测试我们的API是有益的。
- en: Having basic knowledge of how **WebSockets** work can be beneficial, although
    it’s not necessary since the recipes will guide you through.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 了解**WebSockets**的工作原理可能会有所帮助，尽管这不是必需的，因为食谱会引导你完成。
- en: For the *Implementing chat functionality with WebSockets* recipe, we will write
    some basic **HTML**, including some **Javascript** code.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于*使用WebSockets实现聊天功能*食谱，我们将编写一些基本的**HTML**，包括一些**JavaScript**代码。
- en: Setting up WebSockets in FastAPI
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在FastAPI中设置WebSocket
- en: WebSockets provide a powerful mechanism for establishing full-duplex communication
    channels between clients and servers, allowing real-time data exchange. In this
    recipe, you’ll learn how to establish a connection with WebSocket functionality
    in your FastAPI applications to enable interactive and responsive communication.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: WebSockets提供了一种强大的机制，可以在客户端和服务器之间建立全双工通信通道，允许实时数据交换。在本食谱中，你将学习如何在FastAPI应用程序中建立WebSocket功能连接，以实现交互式和响应式的通信。
- en: Getting ready
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before diving into the recipe, ensure you have all the required packages in
    your environment. You can install them from the `requirements.txt` file provided
    in the GitHub repository or install it manually with `pip`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Since the swagger documentation does not support WebSocket, we will use an external
    tool to test the WebSocket connection, such as Postman.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find instructions on how to install it on the website: [https://www.postman.com/downloads/](https://www.postman.com/downloads/).'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: The free community version will be enough to test the recipes.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create the project root folder called `chat_platform`. we can create our `app`
    folder containing the `main.py` module. Let's build our simple application with
    a WebSocket endpoint as follows.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'We can start by creating our server in the `main.py` module:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then we can create the WebSocket endpoint to connect the client to the chat
    room:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The endpoint establishes the connection with the client, sends a welcome message,
    and closes the connection. This is the most basic configuration of a WebSocket
    endpoint.
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'That''s it. To test it, spin up the server from the command line:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Welcome to the chat room! 12:37:19
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: import logging
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: logger = logging.getLogger("uvicorn")
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '@app.websocket("/ws")'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'async def ws_endpoint(websocket: WebSocket):'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: await websocket.accept()
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: await websocket.send_text(
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '"Welcome to the chat room!"'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: )
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'while True:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: data = await websocket.receive_text()
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'logger.info(f"Message received: {data}")'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: websocket.close() call from the previous recipe and used an infinite while loop.
    This allows the server side to continuously receive the message from the client
    and print it to the console without closing the connection. In this case, the
    connection can be closed only by the client.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: This is all you need to read messages from the client and send it to the terminal
    output.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: The server initiates a connection request when the client call the endpoint.
    With the `websocket.receive_text()` function, the server opens the connection
    and it is ready to receive the message from the client. The message is stored
    into the `data` variable and it is printed to terminal output. Then the server
    sends a confirmation message to the client.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Let’s test it. Spin up the server by running `uvicorn app.main:app` from the
    command line and open Postman. Then apply the following steps.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Create a new WebSocket request, and connect to the `ws://localhost:8000/ws`
    address.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once the connection is established, you will see on the terminal output the
    message:'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'INFO: Message received: Hello FastAPI application'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Message received! 14:46:20
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 2.  You can then close the connection from the client by clicking on the **Disconnect**
    button to the right of the WebSocket **URL** field.
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: By enabling the server to receive messages from the client, you have just enabled
    bidirectional communication between the client and server through a WebSocket.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: The `Fastapi.WebSocket` instance is, in reality, a `starlette.WebSocket` class
    from the `send_json` or `receive_json` methods).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`Fastapi.WebSocket`实例是来自`send_json`或`receive_json`方法的`starlette.WebSocket`类。
- en: 'Check more on the official Starlette documentation page:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息请查看官方 Starlette 文档页面：
- en: '*Starlette* *Websockets*: [https://www.starlette.io/websockets/](https://www.starlette.io/websockets/)'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Starlette* *WebSockets*: [https://www.starlette.io/websockets/](https://www.starlette.io/websockets/)'
- en: Handling WebSocket connections and disconnections
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 处理 WebSocket 连接和断开连接
- en: When a client establishes a WebSocket connection with a **FastAPI** server,
    it’s crucial to handle the lifecycle of these connections appropriately. This
    includes accepting incoming connections, maintaining active connections, and handling
    disconnections gracefully to ensure smooth communication between the client and
    server. In this recipe, we’ll explore how to effectively manage WebSocket connections
    and gracefully handle disconnections.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端与**FastAPI**服务器建立 WebSocket 连接时，适当地处理这些连接的生命周期至关重要。这包括接受传入的连接、维护活跃的连接以及优雅地处理断开连接，以确保客户端和服务器之间的通信顺畅。在这个配方中，我们将探讨如何有效地管理
    WebSocket 连接并优雅地处理断开连接。
- en: Getting ready
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 准备工作
- en: To follow the recipe, you will need to have **Postman** or any other tool to
    test WebSocket connections. Also, you need to already have a WebSocket endpoint
    implemented in your application. Check the previous two recipes if that is not
    the case.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要遵循这个配方，你需要有**Postman**或其他任何工具来测试 WebSocket 连接。此外，你需要在你的应用程序中已经实现了一个 WebSocket
    端点。如果还没有，请检查前面的两个配方。
- en: How to do it…
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We will see how to manage the following two situations:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到如何管理以下两种情况：
- en: Client-side disconnection
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端端断开连接
- en: Server-side disconnection
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器端断开连接
- en: Let’s have a look at each of these situations in detail.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细查看这些情况中的每一个。
- en: Client-side disconnection
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端端断开连接
- en: You might have noticed in the *Sending and receiving messages over WebSockets*
    recipe that if the connection is closed from the client (e.g., from Postman) on
    the server console, a `WebSocketDisconnect` exception propagates, uncaptured.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能在*通过 WebSockets 发送和接收消息*的配方中注意到，如果连接从客户端（例如，从 Postman）在服务器控制台关闭，则会抛出一个未被捕获的`WebSocketDisconnect`异常。
- en: This is because the disconnection from the client side should be properly handled
    in a `try-except` block.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为客户端的断开连接应该在`try-except`块中适当处理。
- en: 'Let’s adjust the endpoint to take this into account. In the `main.py` module,
    we modify the `/ws`endpoint as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调整端点以考虑这一点。在`main.py`模块中，我们按照以下方式修改`/ws`端点：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '@app.websocket("/ws")'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '@app.websocket("/ws")'
- en: 'async def ws_endpoint(websocket: WebSocket):'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 'async def ws_endpoint(websocket: WebSocket):'
- en: await websocket.accept()
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: await websocket.accept()
- en: await websocket.send_text(
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: await websocket.send_text(
- en: '"Welcome to the chat room!"'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '"欢迎来到聊天室！"'
- en: )
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: 'while True:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: data = await websocket.receive_text()
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: data = await websocket.receive_text()
- en: 'logger.info(f"Message received: {data}")'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 'logger.info(f"收到消息: {data}")'
- en: 'if data == "disconnect":'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 'if data == "disconnect":'
- en: logger.warn("Disconnecting...")
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: logger.warn("断开连接...")
- en: await websocket.close()
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: await websocket.close()
- en: data string content to then call the websocket.close method and exit the while
    loop.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据字符串内容传递给websocket.close方法并退出while循环。
- en: If you run the server, try to connect to the WebSocket `/ws` endpoint, and send
    the `"disconnect"` string as a message, the connection will be closed by the server.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行服务器，尝试连接到 WebSocket `/ws` 端点，并发送`"disconnect"`字符串作为消息，服务器将关闭连接。
- en: You have seen how to manage disconnection and connection handshakes for a WebSocket
    endpoint, however, we still need to manage the right status code and messages
    for each. Let’s check this in the following recipe.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了如何管理 WebSocket 端点的断开和连接握手，然而，我们仍然需要为每个端点管理正确的状态码和消息。让我们在下面的配方中查看这一点。
- en: Handling WebSocket errors and exceptions
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 处理 WebSocket 错误和异常
- en: WebSocket connections are susceptible to various errors and exceptions that
    can occur during the lifecycle of a connection. Common issues include connection
    failures, message parsing errors, and unexpected disconnections. Properly handling
    errors and correctly communicating with the client is essential to maintaining
    a responsive and resilient WebSocket-based application. In this recipe, we’ll
    explore how to handle WebSocket errors and exceptions effectively in FastAPI applications.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: The recipe will show how to manage WebSocket errors that can happen for a specific
    endpoint. We will showcase how to improve the `/ws` endpoint defined in the *Handling
    WebSocket connections and* *disconnections* recipe.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: The way the `/ws` endpoint is coded in the previous recipe returns the same
    response code and message when the server closes the connection. Just like for
    HTTP responses, FastAPI allows you to personalize the response to return a more
    meaningful message to the client.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how to do it. You can use a solution like the following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We have specified to the `websocket.close` method a status code and reason that
    will be transmitted to the client.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'If we now spin up the server and send the disconnect message from the client,
    you will see a disconnection log message in the response window, like this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is all you need to gracefully disconnect your WebSocket connection.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Alternative solution
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Similarly to how an `HTTPException` instance is rendered for HTTP requests (see
    the *Handling errors and exceptions* recipe in [*Chapter 1*](B21025_01.xhtml#_idTextAnchor020),
    *First Steps with FastAPI*), FastAPI also enables the use of `WebSocketException`
    for WebSocket connections, which is rendered automatically as a response.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'To better understand, imagine we want to disconnect the client if they write
    something that isn’t allowed – for example, the `"bad message"` text string. Let’s
    modify the chatroom endpoint:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If you spin up the server and try to send whatever message contains the `"bad
    message"` string, the client will be disconnected. Furthermore, on the **Response**
    panel section of Postman of your WebSocket connection you will see the following
    log message:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You have just seen how to communicate WebSocket errors to the client by raising
    the appropriate exception. You can use this strategy for a variety of errors that
    can arise while running the application and have to be correctly communicated
    to the API consumer.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'WebSocket is a relatively new protocol compared to HTTP, so it is still evolving
    with time. Although status codes are not extensively used, like for HTTP, you
    can find definitions of WebSockets codes at the following links:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '*WebSocket Close Code Number* *Registry*: [https://www.iana.org/assignments/websocket/websocket.xml#close-code-number](https://www.iana.org/assignments/websocket/websocket.xml#close-code-number)'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can also find a list of the compatibility of WebSocket events for browsers
    on the following page:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在以下页面找到浏览器 WebSocket 事件的兼容性列表：
- en: '*WebSocket* *CloseEvent*: [https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent](https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent)'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*WebSocket* 关闭事件：[https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent](https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent)'
- en: 'Furthermore, the `WebSocketException` class in FastAPI is documented at the
    official documentation link:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，FastAPI 中的 `WebSocketException` 类在官方文档链接中有文档说明：
- en: '*FastAPI WebSocketExcpetion API* *documentation*: [https://fastapi.tiangolo.com/reference/exceptions/#fastapi.WebSocketException](https://fastapi.tiangolo.com/reference/exceptions/#fastapi.WebSocketException)'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*FastAPI WebSocketException API* 文档：[https://fastapi.tiangolo.com/reference/exceptions/#fastapi.WebSocketException](https://fastapi.tiangolo.com/reference/exceptions/#fastapi.WebSocketException)'
- en: Implementing chat functionality with WebSockets
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 WebSockets 实现聊天功能
- en: Real-time chat functionality is a common feature in many modern web applications,
    enabling users to communicate instantly with each other. In this recipe, we’ll
    explore how to implement chat functionality using WebSockets in FastAPI applications.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 实时聊天功能是许多现代网络应用程序的常见功能，使用户能够即时相互沟通。在本配方中，我们将探讨如何在 FastAPI 应用程序中使用 WebSockets
    实现聊天功能。
- en: By leveraging WebSockets, we will create a bidirectional communication channel
    between the server and multiple clients, allowing messages to be sent and received
    in real time.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用 WebSockets，我们将在服务器和多个客户端之间创建双向通信通道，允许实时发送和接收消息。
- en: Getting ready
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 准备工作
- en: To follow the recipe, you need to have a good understanding of WebSockets and
    know how to build a WebSocket endpoint using FastAPI.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要遵循配方，您需要对 WebSockets 有良好的理解，并知道如何使用 FastAPI 构建 WebSocket 端点。
- en: Additionally, having some basic knowledge of HTML and JavaScript can help create
    simple web pages for the application. The recipe we’ll be using is the foundation
    of our chat application.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，具备一些基本的 HTML 和 JavaScript 知识可以帮助创建简单的网页，用于应用程序。我们将使用的配方是聊天应用程序的基础。
- en: 'Also, we will use the `jinja2` package to apply basic templating for the HTML
    page. Make sure to have it in your environment. If you didn’t install packages
    with `requirements.txt`, install `jinja2` with `pip`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 还将使用 `jinja2` 包为 HTML 页面应用基本模板。请确保它在您的环境中。如果您没有使用 `requirements.txt` 安装包，请使用
    `pip` 安装 `jinja2`：
- en: '[PRE16]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Once the installation is complete, we are ready to start with the recipe.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，我们就可以开始配方了。
- en: How to do it…
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'To build the application, we will need to build three core pieces – the WebSocket
    connections manager, the WebSocket endpoint, and the chat HTML page:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建应用程序，我们需要构建三个核心组件——WebSocket 连接管理器、WebSocket 端点和聊天 HTML 页面：
- en: 'Let’s start by building the connection manager. The role of the connection
    manager is to keep track of open WebSocket connections and broadcast messages
    to active ones. Let’s define the `ConnectionManager` class in a dedicated `ws_manager.py`
    module under the `app` folder:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从构建连接管理器开始。连接管理器的角色是跟踪打开的 WebSocket 连接并向活跃的连接广播消息。让我们在 `app` 文件夹下的一个专用 `ws_manager.py`
    模块中定义 `ConnectionManager` 类：
- en: '[PRE17]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `async def connect` method will be responsible for the handshake and adding
    the WebSocket to the list of active ones. The `def disconnect` method will remove
    the WebSocket from the list of active connections. The `async def send_personal_message`
    method will send a message to a specific WebSocket. Finally, `async def broadcast`
    will send the message to all the active connections except one, if specified.
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`async def connect` 方法将负责握手并将 WebSocket 添加到活跃列表中。`def disconnect` 方法将从活跃连接列表中删除
    WebSocket。`async def send_personal_message` 方法将向特定的 WebSocket 发送消息。最后，`async def
    broadcast` 将向所有活跃连接发送消息，除非指定了排除的连接。'
- en: The connection manager will then be used in the chat WebSocket endpoint.
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 连接管理器将在聊天 WebSocket 端点中使用。
- en: '2.  Let’s create the WebSocket endpoint in a separate module called `chat.py`.
    Let’s initialize the connection manager:'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 2. 在一个名为 `chat.py` 的单独模块中创建 WebSocket 端点。让我们初始化连接管理器：
- en: '[PRE18]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then we define the router:'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后我们定义路由器：
- en: '[PRE19]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'And finally, we can define the WebSocket endpoint:'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，我们可以定义 WebSocket 端点：
- en: '[PRE20]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '3.  After a new client joins a chat, the connection manager sends a message
    to all chat participants to notify them of the new arrival. The endpoint uses
    the `username` path parameter to retrieve the client’s name. Don’t forget to add
    the router to the FastAPI object in the `main.py` file:'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: <!doctype html>
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <html>
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <head>
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <title>Chat</title>
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: </head>
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <body>
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <h1>WebSocket Chat</h1>
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '<h2>Your ID: <span id="ws-id"></span></h2>'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <form action="" onsubmit="sendMessage(event)">
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <input
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: type="text"
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: id="messageText"
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: autocomplete="off"
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: />
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <button>Send</button>
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: </form>
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <ul id="messages"></ul>
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <script>
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <!—content of js script -->
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <script/>
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: </body>
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: </html>
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '4.  To conclude, we need to build the endpoint that returns the HTML page.
    We can build it in the same `chat.py` module:'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The endpoint will take as a path parameter the username of the client that will
    show in the chat conversation.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: You have set up a basic chat room within your FastAPI application with the WebSockets
    protocol. You only have to spin up the server with `uvicorn app.main:app` and
    connect to `http://localhost:8000/chatroom/your-username` from your browser. Then,
    from another page, connect to the same address with a different username and start
    exchanging messages between the two browsers.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: When connecting to the `GET /chatroom/{username}` endpoint address (`http://localhost:8000/chatroom/{username}`),
    the server will use the username to render the HTML page customized to the username.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: The HTML will contain the code to make the connection to the `/chatroom` WebSocket
    endpoint and create a new WebSocket connection for each user.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: The endpoint will then use the `ConnectionManager()` connection manager object
    to exchange messages between all clients through the HTML page.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'We have used a basic feature of the Jinja2 templating library. However, you
    can free your creativity and discover the potential of this package by looking
    at the documentation:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '*Jinja2* *Documentation*: [https://jinja.palletsprojects.com/en/3.1.x/](https://jinja.palletsprojects.com/en/3.1.x/)'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing WebSocket performance
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: WebSocket connections provide a powerful mechanism for real-time communication
    between clients and servers. To ensure the optimal performance and scalability
    of WebSocket applications, it’s essential to implement effective optimization
    techniques and a way to measure them. In this recipe, we will see how to benchmark
    WebSocket endpoints to test the number of connections supported by the connection
    and suggest practical tips and techniques to optimize WebSocket performance in
    your FastAPI applications.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Besides knowledge of how to set up a WebSocket endpoint, we will use the *Implementing
    chat functionality with WebSockets* recipe to benchmark the traffic supported.
    You can also follow the recipe by applying the strategy to your application.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Whether you apply it to your application or the chat functionality, it can be
    useful to include some message logs to be printed during the endpoint execution.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, for the WebSocket `/chatroom/{username}` endpoint, you can add
    a log after each message broadcast as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We are now ready to create a benchmark script to test our chat functionality.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create the script file under the root folder and call it `benchmark_websocket.py`.
    A typical benchmark script should do the following tasks:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Define a function to run the FastAPI server
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define another function to connect *n* number of clients of the WebSocket endpoint
    and exchange a certain number of messages
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wrap up the previous steps by running the server in a separate process and running
    the clients
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are the steps to create the script:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by defining a function to run our server:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `run_server` function is an alternative to the command-line `uvicorn app.main:app`
    command we are used to running from the terminal.
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.  Now let’s define a function that will create a certain number of clients
    that will connect to the WebSocket endpoint and exchange some messages:'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: To simulate concurrent connection patterns, we use an `async def` function.
    This will enable us to evaluate the server’s performance under the high load of
    simultaneous requests to the endpoint.
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Furthermore, we added some asynchronous sleeping time (`asyncio.sleep`) between
    messages to simulate the human behavior of the chat’s client.
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.  Then, we can execute all the previous functions in a single overall `async
    def main` function as follows:'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The function creates a process to spin up the server, start it, wait some time
    to finish the startup, and simultaneously run all the clients to call the server.
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '4.  Finally, to make it run, we need to pass it to the event loop if it is
    run as a script. We can do it like this:'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To run the script, simply run it as a Python script from the command line:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '@app.websocket("/secured-ws")'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: async def secured_websocket(
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'websocket: WebSocket,'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'username: str'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '):'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: await websocket.accept()
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: await websocket.send_text(f"Welcome {username}!")
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'async for data in websocket.iter_text():'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: await websocket.send_text(
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'f"You wrote: {data}"'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: )
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: from fastapi import (
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: WebSocket,
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: WebSocketException,
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: status,
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: from fastapi.security import OAuth2PasswordBearer
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: class OAuth2WebSocketPasswordBearer(
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: OAuth2PasswordBearer
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '):'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: async def __call__(
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'self, websocket: WebSocket'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ') -> str:'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'authorization: str = websocket.headers.get('
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"authorization"'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if not authorization:'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: raise WebSocketException(
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: code=status.HTTP_401_UNAUTHORIZED,
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: reason="Not authenticated",
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: scheme, param = authorization.split()
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if scheme.lower() != "bearer":'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: raise WebSocketException(
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: code=status.HTTP_403_FORBIDDEN,
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: reason=(
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"Invalid authentication "'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"credentials"'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ),
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return param
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: from app.ws_password_bearer import (
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: OAuth2WebSocketPasswordBearer,
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: oauth2_scheme_for_ws = OAuth2WebSocketPasswordBearer(
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: tokenUrl="/token"
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: def get_username_from_token(
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'token: str = Depends(oauth2_scheme_for_ws),'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'token: str = Depends(oauth2_scheme_for_ws),'
- en: ') -> str:'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ') -> str:'
- en: user = fake_token_resolver(token)
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: user = fake_token_resolver(token)
- en: 'if not user:'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'if not user:'
- en: raise WebSocketException(
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: raise WebSocketException(
- en: code=status.HTTP_401_UNAUTHORIZED,
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: code=status.HTTP_401_UNAUTHORIZED,
- en: reason=(
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: reason=(
- en: '"Invalid authentication credentials"'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"无效的认证凭证"'
- en: )
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: )
- en: )
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: )
- en: return user.username
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: return user.username
- en: '[PRE33]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: from import Annotated
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: from import Annotated
- en: from fastapi import Depends
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从 fastapi 导入 Depends
- en: from app.security import get_username_from_token
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: from app.security 导入 get_username_from_token
- en: '@app.websocket("/secured-ws")'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '@app.websocket("/secured-ws")'
- en: async def secured_websocket(
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: async def secured_websocket(
- en: 'websocket: WebSocket,'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'websocket: WebSocket,'
- en: 'username: Annotated['
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'username: Annotated['
- en: get_username_from_token, Depends()
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: get_username_from_token, Depends()
- en: ']'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ']'
- en: '):'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '):'
- en: '# rest of the endpoint'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '# 端点其余部分'
- en: '[PRE34]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: $ uvicorn app.main:app
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: $ uvicorn app.main:app
- en: '[PRE35]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
