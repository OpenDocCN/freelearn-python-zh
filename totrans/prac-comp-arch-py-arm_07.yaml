- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: TC1 Assembler and Simulator Design
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TC1汇编器和模拟器设计
- en: 'In this chapter, we will put together the lessons we have learned in previous
    chapters and construct a computer simulator. The key topics we will cover in this
    chapter are as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将结合之前章节学到的知识，构建一个计算机模拟器。本章我们将涵盖的关键主题如下：
- en: Analyzing instructions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析指令
- en: Dealing with assembler directives
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理汇编指令
- en: Building the binary instruction
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建二进制指令
- en: The pre-TC1 (a prequel to the actual simulator)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: pre-TC1（实际模拟器的前传）
- en: The TC1 simulator program
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TC1模拟器程序
- en: A TC1 assembly language program
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个TC1汇编语言程序
- en: TC1 postscript
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TC1后记
- en: By the end of this chapter, you should understand how a simulator is designed
    and be able to create one. The following two chapters concentrate on expanding
    the simulator and providing more facilities, such as error detection in the input.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您应该了解模拟器是如何设计的，并且能够创建一个模拟器。接下来的两个章节将专注于扩展模拟器并提供更多功能，例如输入错误检测。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the programs used in this chapter on GitHub at [https://github.com/PacktPublishing/Practical-Computer-Architecture-with-Python-and-ARM/tree/main/Chapter06](https://github.com/PacktPublishing/Practical-Computer-Architecture-with-Python-and-ARM/tree/main/Chapter06).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章使用的程序：[https://github.com/PacktPublishing/Practical-Computer-Architecture-with-Python-and-ARM/tree/main/Chapter06](https://github.com/PacktPublishing/Practical-Computer-Architecture-with-Python-and-ARM/tree/main/Chapter06)。
- en: In order to construct a Python-based simulator, you need the same tools used
    in earlier chapters; that is, you require an editor to create the Python program
    and a Python interpreter. These are included in the freely available Python package
    we introduced in [*Chapter 1*](B19624_01.xhtml#_idTextAnchor015).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建一个基于Python的模拟器，您需要之前章节中使用的相同工具；也就是说，您需要一个编辑器来创建Python程序，以及一个Python解释器。这些工具包含在我们之前在[*第1章*](B19624_01.xhtml#_idTextAnchor015)中介绍的免费Python软件包中。
- en: Analyzing instructions
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析指令
- en: In this section, we will look at the way in which we take a text string representing
    an assembly language instruction and process it to create binary code that can
    be executed by the simulator.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何将表示汇编语言指令的文本字符串转换为可以被模拟器执行的二进制代码。
- en: 'Interestingly, the assembler can be more complicated than the actual simulator.
    Indeed, we devote relatively little space to the simulator itself in this chapter.
    We don’t actually need an assembler, because it’s easy to hand-translate assembly-level
    operations into binary code; it’s just a matter of filling in the fields of the
    32-bit instruction format. For example, *load register R7 with the literal value
    42* can be written as `LDRL` `R7`,`42`. This has a 7-bit opcode, `01` `01010`,
    the destination register is `r7` (code `111`), the two source registers are not
    used, and their fields can both be set to `000`. The literal is `42`, or `0000000000101010`
    as a 16-bit binary value. The binary-encoded instruction is as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，汇编器可能比实际的模拟器更复杂。实际上，在本章中，我们对模拟器本身的篇幅相对较少。我们实际上不需要汇编器，因为将汇编级操作手动翻译成二进制代码很容易；这只是填写32位指令格式字段的问题。例如，*将常量值42加载到寄存器R7中*可以写成`LDRL`
    `R7`,`42`。这个指令有7位操作码，`01` `01010`，目标寄存器是`r7`（代码`111`），两个源寄存器未使用，它们的字段都可以设置为`000`。常量是`42`，或者作为16位二进制值`0000000000101010`。二进制编码的指令如下：
- en: 0001010111`000000`0000000000101010
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 0001010111`000000`0000000000101010
- en: 'It’s easy to translate code by hand, but it’s no fun. We are going to create
    an assembler that automates the process of translation and lets you use symbolic
    names rather than actual literals (constants). Consider the following example
    of assembly language code. This is written using *numeric values* (shaded), rather
    than symbolic names. This is not intended to be a specific assembly language;
    it is designed to illustrate the basic concepts:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 手动翻译代码很容易，但并不有趣。我们将创建一个汇编器来自动化翻译过程，并允许您使用符号名称而不是实际的常量（常数）。考虑以下汇编语言代码的示例。这是使用*数值*（阴影标注）而不是符号名称编写的。这并不是一个特定的汇编语言；它旨在说明基本概念：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the following example, literals have been replaced with symbolic names.
    These are shaded:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，常量值已被替换为符号名称。这些名称被阴影标注：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Python’s dictionary structure makes the handling of symbolic names very easy
    indeed. The preceding shows the processing of a text file containing the assembly
    language. This file is called `sFile` and is simply a `.txt` file containing the
    assembly language instructions.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Python的字典结构确实使得处理符号名称变得非常容易。前面的示例展示了处理包含汇编语言的文本文件的过程。这个文件被称为`sFile`，它只是一个包含汇编语言指令的`.txt`文件。
- en: Processing the input
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理输入
- en: We will now look at how the raw input – that is, the text file containing the
    assembly language source code – can be processed. In principle, it would be nice
    to have a source file where the assembly language instructions were all perfectly
    formatted and laid out.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将探讨如何处理原始输入——即包含汇编语言源代码的文本文件。原则上，有一个源文件，其中汇编语言指令都完美格式化和排列，那将是很好的。
- en: In reality, a program may not be formatted ideally; for example, there may be
    blank lines or program comments that need to be ignored.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实中，一个程序可能不是理想地格式化的；例如，可能有空白行或需要忽略的程序注释。
- en: We have designed this assembly language to allow considerable latitude in the
    writing of a TC1 program. In fact, it allows a free format that is not implemented
    by most real assemblers. We took this approach for several reasons. First, it
    demonstrates how to perform text processing, which is a fundamental part of the
    design of assemblers. Second, a free format means you don’t have to remember whether
    to use uppercase or lowercase names and labels.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设计这种汇编语言，以便在编写TC1程序时具有相当大的灵活性。实际上，它允许一种大多数真实汇编器都没有实现的自由格式。我们采取这种方法的几个原因包括。首先，它展示了如何执行文本处理，这是汇编器设计的基本部分。其次，自由格式意味着你不必记住是否使用大写或小写名称和标签。
- en: 'Some languages are case-sensitive and some are not. The assembly language we
    have designed is *case-insensitive*; that is, you can write either `ADD` r0`,r1,r2`
    or `ADD` R0`,R1,R2.` Consequently, we can write the load register immediate assembly
    instruction in all the following forms to execute a *load* *register-indexed*
    operation:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一些语言是大小写敏感的，而另一些则不是。我们设计的汇编语言是*不区分大小写*的；也就是说，你可以写 `ADD r0,r1,r2` 或者 `ADD R0,R1,R2`。因此，我们可以以下列所有形式编写加载寄存器立即指令来执行*加载*
    *寄存器索引*操作：
- en: '`LDRI` `R2,[R1],10` or'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`LDRI` `R2,[R1],10` 或者'
- en: '`LDRI` `R2,r1,10` or'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`LDRI` `R2,r1,10` 或者'
- en: '`LDRI` `R2,[R1,10]` or`,`'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`LDRI` `R2,[R1,10]` 或者 `,`'
- en: '`LDRI r2,r1,10`'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`LDRI r2,r1,10`'
- en: This level of freedom of notation is possible because the `[]` brackets are
    not actually necessary to identify the instruction; they are used in programs
    because programmers associate `[r0]` with indirect addressing. In other words,
    the brackets are there for the programmer, not the computer, and are redundant.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这种记法自由度之所以可能，是因为`[]`括号实际上并不必要来识别指令；它们在程序中使用，因为程序员将`[r0]`与间接寻址联系起来。换句话说，括号是为了程序员而不是计算机而存在的，是多余的。
- en: However, this level of freedom is not necessarily desirable because it could
    lead to errors and make it more difficult for one person to read another person’s
    program. All design decisions come with pros and cons.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种自由度并不一定是可取的，因为它可能导致错误，并使一个人阅读另一个人的程序变得更加困难。所有设计决策都伴随着利弊。
- en: The following Python example includes a short embedded assembly language program.
    The Python code has been designed so that you can use either an assembly language
    program that is part of the assembler (this is just for testing and debugging
    purposes because it avoids having to go into a text editor every time you want
    to test a feature) or a program in text form on disk. In this example, we located
    the test program at `E\:testCode.txt` on my computer. When the demonstration text-processing
    code runs, it asks you whether the code is to come from disk or is the embedded
    code. Typing `d` reads the disk, and entering any other input reads the embedded
    code.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下Python示例包含一个简短的嵌入式汇编语言程序。Python代码被设计成你可以使用汇编器的一部分汇编语言程序（这只是为了测试和调试目的，因为它避免了每次想要测试一个特性时都需要进入文本编辑器的情况）或者磁盘上的文本形式程序。在这个例子中，我们在我的电脑上找到了测试程序，位于`E:\testCode.txt`。当演示文本处理代码运行时，它会询问你是从磁盘读取代码还是读取嵌入式代码。输入`d`读取磁盘，输入任何其他输入读取嵌入式代码。
- en: The filename of the assembly language program is `testCode = 'E://testCode.txt'`.
    A double backslash is used instead of the conventional filenaming convention in
    Python programs.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编语言程序的文件名为 `testCode = 'E://testCode.txt'`。在Python程序中，我们使用双反斜杠代替传统的文件命名约定。
- en: The text-processing program removes blank lines, converts text into uppercase
    (allowing you to write `r0` or `R0`), and lets you use a comma or a space as a
    separator (you can write `ADD R0,R1,R2` or `ADD r0 r1 r2`). We also remove surplus
    spaces before and after the instruction. The final result is a tokenized list;
    that is, `ADD r0,r1,r2` is converted into the `['ADD','R0','R1','R2']` list. Now,
    the assembler can look up the instruction and then extract the information it
    requires (register numbers and literals).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 文本处理程序移除空白行，将文本转换为大写（允许您写`r0`或`R0`），并允许您使用逗号或空格作为分隔符（您可以写`ADD R0,R1,R2`或`ADD
    r0 r1 r2`）。我们还移除了指令前后多余的空格。最终结果是标记化列表；也就是说，`ADD r0,r1,r2`被转换为`['ADD','R0','R1','R2']`列表。现在，汇编器可以查找指令，然后提取它所需的信息（寄存器编号和字面量）。
- en: 'In the following program, we used a new variable every time we processed a
    line in order to help you keep track of variables. The following is an example:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下程序中，我们每次处理一行时都会使用一个新的变量，以便帮助您跟踪变量。以下是一个示例：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We’ve used different variable names for clarity. Normally, you would write:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为了清晰起见使用了不同的变量名。通常，你会这样写：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We use file comprehension to remove comments in the code:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用文件理解来移除代码中的注释：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is a rather clever trick and requires explanation. It copies each line
    of `sFile2` to `sFile3`. However, the value copied for each line is `i.split('@')[0]`,
    where `i` is the current line. The `split('@')` method divides the list into strings
    using `'@'` as a divider. If there is no `'@'` in the original string, the string
    is copied. If there is an `'@'`, it is copied as two strings; for example, `ADD
    R1,R2,R3 @ Sum the totals` is copied to `sFile3` as `'ADD R1,R2,R3','@ Sum the
    totals'`. However, only the first element of the list is copied because of the
    `[0]` index; that is, only `'ADD R1,R2,R3'` is copied and the comment is removed.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当巧妙的技巧，需要解释。它将`sFile2`中的每一行复制到`sFile3`。然而，对于每一行的复制值是`i.split('@')[0]`，其中`i`是当前行。`split('@')`方法使用`'@'`作为分隔符将列表分割成字符串。如果原始字符串中没有`'@'`，则字符串将被复制。如果有`'@'`，它将被复制为两个字符串；例如，`ADD
    R1,R2,R3 @ Sum the totals`将被复制到`sFile3`作为`'ADD R1,R2,R3','@ Sum the totals'`。然而，由于`[0]`索引，只复制列表的第一个元素；也就是说，只复制`'ADD
    R1,R2,R3'`，并移除了注释。
- en: 'The text input processing block is given here:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 文本输入处理块如下所示：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The following are two examples of using this code. In the first case, the user
    input is `d`, indicating a disk program, and in the second case, the input is
    `x`, indicating the use of the embedded source program. In each case, the course
    and output values are printed to demonstrate the string-processing operations.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是用此代码的两个示例。在第一种情况下，用户输入是`d`，表示磁盘程序，在第二种情况下，输入是`x`，表示使用嵌入式源程序。在每种情况下，都会打印课程和输出值以演示字符串处理操作。
- en: Case 1 – Disk input
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 情况1 – 磁盘输入
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Case 2 – Using the embedded test program
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 情况2 – 使用嵌入式测试程序
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding code does not represent an optimum text-processing system. It
    was designed to demonstrate the basic process involved in manipulating text before
    you process it. However, these concepts will appear again in TC1.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码并不代表一个最优的文本处理系统。它被设计用来演示在处理文本之前涉及的基本过程。然而，这些概念将在TC1中再次出现。
- en: Dealing with Mnemonics
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理助记符
- en: What’s in a name? How do we know that a `NOP` instruction stands alone, but
    an `ADD` instruction requires three registers? In this section, we begin a discussion
    of how assembly language instructions are processed in order to extract their
    meaning (i.e., convert them into binary form).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 名字里有什么？我们如何知道一个`NOP`指令是独立的，而一个`ADD`指令需要三个寄存器？在本节中，我们将开始讨论汇编语言指令是如何被处理的，以便提取它们的含义（即，将它们转换为二进制形式）。
- en: 'Consider the following fragment of TC1 assembly language:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下TC1汇编语言的片段：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When the assembler reads a line, it needs to know how to deal with the opcode
    and its operands. So, how does it know how to proceed? We can use Python’s dictionary
    facility to solve this problem in a very simple way, by just looking in a table
    to see what information an opcode requires.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当汇编器读取一行时，它需要知道如何处理操作码及其操作数。那么，它是如何知道如何进行操作的？我们可以使用Python的字典功能以非常简单的方式解决这个问题，只需查看表格以查看操作码需要哪些信息。
- en: Recall that a dictionary is a set or collection of items, where each item has
    two components; for example, an English-German dictionary has items that consist
    of an English word and its German equivalent. The word you look up is called a
    *key* and that provides a *value*. For example, in the English-German dictionary,
    the item `'town':'Stadt'` consists of the key `town` and the value `Stadt`. A
    dictionary is a fancy name for a *look-up table*.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，字典是一组或集合的项目，其中每个项目有两个组成部分；例如，一个英德词典包含由一个英语单词及其德语对应词组成的项目。你查找的单词称为 *键*，它提供
    *值*。例如，在英德词典中，项目 `'town':'Stadt'` 由键 `town` 和值 `Stadt` 组成。字典是 *查找表* 的一个高级名称。
- en: A dictionary in Python is defined by its punctuation (i.e., it doesn’t require
    any special reserved Python words); it’s a type of list enclosed by curly braces,
    `{}`. Each list item consists of a key and its value separated with a colon. Successive
    items are separated with commas, exactly as in a list.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中的字典由其标点符号定义（即，它不需要任何特殊的保留 Python 词汇）；它是一种由花括号 `{}` 包围的列表类型。每个列表项由一个键及其值组成，键和值之间用冒号分隔。连续的项用逗号分隔，就像列表一样。
- en: 'A *key* is used to access the appropriate value in a dictionary. In TC1, the
    key is the *mnemonic* used to look up the details of the instruction. Let’s create
    a dictionary called `codes` with three keys that are strings representing valid
    TC1 instructions: `STOP`, `ADD`, and `LDRL`. This dictionary can be written as
    follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*键* 用于访问字典中适当的价值。在 TC1 中，键是用于查找指令详细信息的 *助记符*。让我们创建一个名为 `codes` 的字典，其中包含三个键，这些键是表示有效
    TC1 指令的字符串：`STOP`、`ADD` 和 `LDRL`。这个字典可以写成以下形式：'
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Each key is a string terminated by a colon, followed by its value. The key
    doesn’t have to be a string. In this case, it’s a string because we are using
    it to look up mnemonics, which are text strings. The first `key:value` pair is
    `''STOP'':P` , where `''STOP''`is the key and `P` is its value. Suppose we want
    to know whether `ADD` is a legal instruction (i.e., in the dictionary). We can
    test whether this instruction (i.e., key) is in the dictionary with the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 每个键都是一个以冒号结尾的字符串，后面跟着它的值。键不一定是字符串。在这种情况下，它是一个字符串，因为我们正在使用它来查找助记符，这些助记符是文本字符串。第一个
    `key:value` 对是 `'STOP':P`，其中 `'STOP'` 是键，`P` 是它的值。假设我们想知道 `ADD` 是否是一个合法的指令（即，在字典中）。我们可以通过以下方式测试这个指令（即，键）是否在字典中：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This returns `True` if the key is in the dictionary, and `False` otherwise.
    You can use `not in` to test whether something is *not* in a dictionary.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果键在字典中，则返回 `True`，否则返回 `False`。你可以使用 `not in` 来测试某个元素是否不在字典中。
- en: 'Python allows a key to be associated with any valid object, for example, a
    list. We could write, for example, the following `key:value` pair:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Python 允许将任何有效的对象与键关联，例如，一个列表。例如，我们可以写出以下 `key:value` 对：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, the value associated with a key is a five-element list that associates
    the `ADD` mnemonic with the number of its operands, its binary encoding, its name,
    the date it was designed, and the number of times it was used in the current program
    (as well as being able to read a value from a dictionary, you can write to it
    and update it).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，与键关联的值是一个包含五个元素的列表，它将 `ADD` 助记符与操作数的数量、其二进制编码、其名称、设计日期以及它在当前程序中被使用的次数（以及能够从字典中读取值，你还可以写入并更新它）相关联。
- en: 'The following code sets up a dictionary that binds mnemonics to variables (preset
    to integers `1,2,3,4`):'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码设置了一个字典，将助记符与变量（预设为整数 `1,2,3,4`）绑定：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this example, we used the `get()` method to read the value associated with
    a key. If the key is `x`, its value is given by `validCd.get(x)`; that is, the
    syntax is `dictionaryName.get(key)`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了 `get()` 方法来读取与键关联的值。如果键是 `x`，其值由 `validCd.get(x)` 给出；即，语法是 `dictionaryName.get(key)`。
- en: Assembly language contains instructions that are executed. However, it also
    contains information called *assembler directives* that tells the program something
    about the environment; for example, where to put data in memory or how to bind
    symbolic names to values. We will now look at assembler directives.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编语言包含要执行的指令。然而，它还包含称为 *汇编指令* 的信息，这些信息告诉程序有关环境的一些信息；例如，数据在内存中的位置或如何将符号名称绑定到值。我们现在将探讨汇编指令。
- en: Dealing with assembler directives
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理汇编指令
- en: 'In this section, we will learn about the following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习以下内容：
- en: What assembler directives do
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 汇编指令的作用
- en: How to create a symbol table linking symbolic names to values
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建一个将符号名称与值链接的符号表
- en: How to access the symbol table
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何访问符号表
- en: How to update the symbol table
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何更新符号表
- en: Processing labels
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理标签
- en: We will demonstrate how the names the programmer chooses are manipulated and
    translated into their appropriate numerical values.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将演示程序员选择的名称是如何被操作和转换为适当的数值的。
- en: 'The first version of TC1 required you to provide actual values for all names
    and labels. If you wanted to jump to an instruction, you had to provide the number
    of lines to jump. It’s much better to allow the programmer to write the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: TC1 的第一个版本要求你为所有名称和标签提供实际值。如果你想跳转到一条指令，你必须提供要跳转的行数。允许程序员编写以下内容会更好：
- en: '`JMP next`'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`JMP next`'
- en: 'Here, `next` is the label of the target line. This is preferred over writing
    the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`next` 是目标行的标签。这比编写以下内容更受欢迎：
- en: '`JMP 21`'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`JMP 21`'
- en: 'Similarly, if the literal `60` represents minutes in an hour, write the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，如果文字 `60` 代表一小时中的分钟，请编写以下内容：
- en: '`MULL` `,R1,MINUTES`'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`MULL ,R1,MINUTES`'
- en: 'This is preferred over the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这比以下内容更受欢迎：
- en: '`MULL` `,R1,60`'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`MULL ,R1,60`'
- en: We need a means of *linking* `next` with `21` and `MINUTES` with `60`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种方法来 *链接* `next` 与 `21` 和 `MINUTES` 与 `60`。
- en: Python’s *dictionary* structure solves this problem. We simply create `key:value`
    pairs, where `key` is the label that we want to define and `value` is its value.
    In this example, a dictionary for the preceding example would be `{'NEXT':21,
    'MINUTES':60}`. Note this example uses *integers* as values. In this book, we
    will also use *strings* as values, because we input data in text form; for example,
    `'MINUTES':'60'`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的 *字典* 结构解决了这个问题。我们只需创建 `key:value` 对，其中 `key` 是我们想要定义的标签，`value` 是它的值。在这个例子中，前面例子中的字典将是
    `{'NEXT':21, 'MINUTES':60}`。注意这个例子使用 *整数* 作为值。在这本书中，我们也将使用 *字符串* 作为值，因为我们以文本形式输入数据；例如，`'MINUTES':'60'`。
- en: 'The `EQU` assembler directive equates a value with a symbolic name. For example,
    TC1 lets you write the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`EQU` 汇编指令将一个值与一个符号名称关联。例如，TC1 允许你编写以下内容：'
- en: '`MINUTES` `EQU 60`'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`MINUTES EQU 60`'
- en: Using the dictionary
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用字典
- en: 'The `MINUTES EQU 60` assembler directive has three tokens: a label, a function
    (equate), and a value. We extract the `''MINUTES'':60` dictionary pair from the
    source code and insert it into a dictionary called `symbolTab`. The following
    code demonstrates the procedure. The first line sets up a symbol table. We initialize
    it with a dummy entry, `''START'':0`. We’ve created this initial entry for testing
    purposes:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`MINUTES EQU 60` 汇编指令有三个令牌：一个标签、一个函数（等价）和一个值。我们从源代码中提取 `''MINUTES'':60` 字典对，并将其插入到名为
    `symbolTab` 的字典中。以下代码演示了该过程。第一行设置符号表。我们用虚拟条目 `''START'':0` 初始化它。我们创建了这个初始条目用于测试目的：'
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `for` loop (shaded) reads each line of the source code, `sFile`, and tests
    for lines where `'EQU'` is the second token in the line. The `len(sFile[i]) >
    2` comparison ensures that this line has at least three tokens to ensure it’s
    a valid equate directive. The text is in bold font.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 循环（阴影部分）读取源代码的每一行，`sFile`，并检查 `''EQU''` 是否是该行的第二个令牌。`len(sFile[i]) >
    2` 的比较确保该行至少有三个令牌，以确保它是一个有效的等价指令。文本以粗体字体显示。'
- en: We can perform two tests together by employing an `and` Boolean operator so
    that the test is true only if both conditions are true.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用 `and` 布尔运算符同时执行两个测试，这样测试只有在两个条件都为真时才为真。
- en: We check that the second token is `'EQU'` with `sFile[i][1] == 'EQU'`. The `sFile`[i][1]
    notation has two list indexes. The first, in bold, indicates line `i` of the source
    code, and the second index indicates token 1 of that line; that is, it is the
    second element.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查第二个令牌是否为 `'EQU'`，使用 `sFile[i][1] == 'EQU'`。`sFile[i][1]` 表示法有两个列表索引。第一个，以粗体显示，表示源代码的第
    `i` 行，第二个索引表示该行的令牌 1；也就是说，它是第二个元素。
- en: If `'EQU'` is found, we add (i.e., insert) the first token,`[`sFile[i][0]`]`,
    into the symbol table as the key, and the third token, sFile[i][2], as the value.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找到 `'EQU'`，我们将第一个令牌 `[`sFile[i][0]`]` 作为键添加到符号表中，第三个令牌 `sFile[i][2]` 作为值。
- en: Consider the `MINUTES EQU 60` source code line.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下 `MINUTES EQU 60` 源代码行。
- en: The key is `sFile[i][0]` and its value is `sFile[i][2]`, because `MINUTES` is
    the first token on line `i` and `60` is the third token on line `i`. The stored
    key is `'MINUTES'` and its value is `60`. But note that the value `60` is in *string*
    form and not *integer* form. Why? Because the assembler directive is a string
    and not an integer. If we want the numeric value, we have to use `int()`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 关键是 `sFile[i][0]` 和它的值是 `sFile[i][2]`，因为 `MINUTES` 是第 `i` 行的第一个标记，而 `60` 是第
    `i` 行的第三个标记。存储的键是 `'MINUTES'`，其值是 `60`。但请注意，值 `60` 是以 *字符串* 形式存在，而不是 *整数* 形式。为什么？因为汇编指令是一个字符串，而不是一个整数。如果我们想要数值，我们必须使用
    `int()`。
- en: 'The final line of this block of code is as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的最后一行如下：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This line uses a list comprehension to scan the source file and delete any
    line with `EQU`, because only instructions are loaded in program memory. A line
    containing `EQU` is a directive and not an instruction. This operation uses the
    count method, `i.count(''EQU'')`, to count the number of times `EQU` appears in
    a line, and then deletes that line if the count isn’t `0`. The condition we test
    for before moving (i.e., keeping) a line is as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行使用列表推导来扫描源文件，并删除任何包含 `EQU` 的行，因为只有指令被加载到程序内存中。包含 `EQU` 的行是一个指令，而不是指令。这个操作使用计数方法，`i.count('EQU')`
    来计算 `EQU` 在一行中出现的次数，然后如果计数不是 `0`，则删除该行。我们在移动（即保留）一行之前测试的条件如下：
- en: '`if i.count(''EQU'') ==` `0:`'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`if i.count(''EQU'') ==` `0:`'
- en: Here, `i` is the current line being processed. The `count` method is applied
    to the current line and counts the number of occurrences of the `'EQU'` string
    in the line. Only if the count is `0` (i.e., it isn’t a line with an `EQU` directive)
    does that line get copied into `sFile`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`i` 是当前正在处理的行。将 `count` 方法应用于当前行，并计算 `'EQU'` 字符串在该行中出现的次数。只有当计数是 `0`（即，它不是一个带有
    `EQU` 指令的行）时，该行才会被复制到 `sFile`。
- en: 'Because detecting an `EQU` directive, putting it in the symbol table, and removing
    it from the code are so important, we will demonstrate its operation with a little
    piece of test code. The following code fragment sets up a list of three instructions
    in `sFile` to test. Remember that `sFile` is a list of lists and each list is
    an instruction composed of tokens, each of which is a string:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 由于检测 `EQU` 指令、将其放入符号表和从代码中删除非常重要，我们将通过一小段测试代码来演示其操作。以下代码片段在 `sFile` 中设置了一个包含三个指令的列表以进行测试。请记住，`sFile`
    是一个列表的列表，每个列表是一个由标记组成的指令，每个标记都是一个字符串：
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The code in bold is the code we’ve discussed. The remaining code is made up
    of `print` statements used to observe the code’s behavior. The key line in this
    code is as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 粗体的代码是我们讨论过的代码。其余的代码是由 `print` 语句组成的，用于观察代码的行为。代码中的关键行如下：
- en: '`symbolTab[sFile[i][0]] =` `sFile[i][2]`'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`symbolTab[sFile[i][0]] =` `sFile[i][2]`'
- en: 'This updates the symbol table by adding a `key:value` pair in the following
    format:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这通过以下格式的 `key:value` 对更新符号表：
- en: '`symbolTab[key] =` `value`'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`symbolTab[key] =` `value`'
- en: 'When this code is run, it generates the following output:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行此代码时，它生成以下输出：
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The final two lines give the symbol table and the post-processed version of
    `sFile`. The two equates have been loaded into the dictionary (symbol table) and
    the processed output has had the two equates stripped.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两行给出了符号表和 `sFile` 的后处理版本。两个等式已经被加载到字典（符号表）中，并且处理后的输出已经去除了这两个等式。
- en: 'There are several ways to add new `key:value` pairs to a dictionary. We could
    have applied the `update` method to `symbolTab` and written the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 向字典中添加新的 `key:value` 对的方法有很多。我们本可以应用 `update` 方法到 `symbolTab` 并编写以下内容：
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In a later example of an assembler, we will adopt a different convention for
    assembler directives and use the format .`equ name value` because this convention
    is adopted by ARM processors, as we’ll see in later chapters. There is often more
    than one way of representing assembly directives, each with its own advantages
    and disadvantages (e.g., ease of coding or fitting in with particular standards
    and conventions).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在汇编器的后续示例中，我们将采用不同的汇编指令约定，并使用 `.`equ `name value` 的格式，因为这种约定被 ARM 处理器采用，正如我们将在后面的章节中看到的。表示汇编指令的方法通常不止一种，每种方法都有其自身的优缺点（例如，编码的简便性或与特定标准和约定相匹配）。
- en: Labels
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标签
- en: 'The next step in processing the source file is to deal with labels. Take the
    following example:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 处理源文件的下一步是处理标签。以下是一个示例：
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this example, the decrement operation subtracts `1` from the contents of
    register `r1`. If the result is `0`, the `Z flag` is set. The next instruction
    is *branch on zero to NEXT1*. If *Z = 1*, a jump is made to the line labeled `NEXT1`;
    otherwise, the `INC r2` instruction immediately following `BEQ` is executed.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，递减操作从寄存器 `r1` 的内容中减去 `1`。如果结果是 `0`，则设置 `Z flag`。下一条指令是 *零分支到 NEXT1*。如果
    *Z = 1*，则跳转到标签为 `NEXT1` 的行；否则，执行紧随 `BEQ` 后面的 `INC r2` 指令。
- en: The binary program (machine code) generated by TC1 does not store or use labels.
    It requires either the actual address of the next instruction or its relative
    address (i.e., how far it needs to jump from the current location). In other words,
    we need to translate the `NEXT1` label into its actual address in the program.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 由 TC1 生成的二进制程序（机器代码）不存储或使用标签。它需要下一个指令的实际地址或其相对地址（即，它需要从当前位置跳转多远）。换句话说，我们需要将
    `NEXT1` 标签转换为程序中的实际地址。
- en: 'This is a job for the dictionary. All we have to do is put a label in the dictionary
    as a key and then insert the corresponding address as the value associated with
    the key. The following three lines of Python demonstrate how we collect label
    addresses and put them in the symbol table:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这是字典的工作。我们只需将标签作为键放入字典，然后将相应的地址作为与键关联的值插入。以下三行 Python 代码演示了如何收集标签地址并将它们放入符号表中：
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The three lines, 1 to 3, define a `for` loop that steps through every line in
    the source code in `sFile`. Because we’ve processed the code to convert each instruction
    into a list of tokens, each line begins with either a valid mnemonic or a label.
    All we have to do is check whether the first token on a line is in the list (or
    dictionary) of mnemonics. If the first token is in the list, it’s an instruction.
    If it’s not in the list, then it’s a label (we are ignoring the case that it’s
    an error).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这三条线，1 到 3，定义了一个 `for` 循环，遍历 `sFile` 中的每一行源代码。因为我们已经处理了代码，将每条指令转换成令牌列表，所以每一行以有效的助记符或标签开始。我们只需检查一行上的第一个令牌是否在助记符列表（或字典）中。如果第一个令牌在列表中，则它是一条指令。如果不在列表中，则它是一个标签（我们忽略它是错误的情况）。
- en: 'We perform the check for a valid mnemonic with the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下方式来检查有效的助记符：
- en: '[PRE20]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here, `sFile[i][0]` represents the first item (i.e., token) of line `i` in
    the dictionary of mnemonics. The `not in` Python code returns `True` if the mnemonic
    is not in the dictionary called `codes`. If the test does return `True`, then
    we have a label and must put it in the symbol table with the following operation:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`sFile[i][0]` 代表字典中第 `i` 行的第一个项目（即令牌）。Python 中的 `not in` 代码返回 `True` 如果助记符不在名为
    `codes` 的字典中。如果测试返回 `True`，则我们有一个标签，必须使用以下操作将其放入符号表中：
- en: '[PRE21]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This expression says, “*Add the specified* `key:value` *pair to the dictionary
    called* `symbolTable`*.*” Why is the value associated with the label given as
    `i`? The value associated with the label is the address of that line (i.e., the
    value of the program counter, `pc`, when that line is executed). Since we are
    stepping through the source code line by line, the counter, `i`, is the corresponding
    value of the program counter.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表达式表示，“*将指定的* `key:value` *对添加到名为* `symbolTable`* 的字典中*。”为什么与标签关联的值给定为 `i`？与标签关联的值是该行的地址（即，程序计数器
    `pc` 在执行该行时的值）。由于我们是逐行遍历源代码，计数器 `i` 是程序计数器的对应值。
- en: The `update` method is applied to the symbol table with sFile[i][0] as the key
    and `str(i)` as the value. The key is sFile[i][0], which is the label (i.e., a
    string). However, the *value* of `i` is not a *string*. The value is an *integer*,
    `i`, which is the current line address. We convert the integer address into a
    string with str(i) because equates are stored in the table as strings (i.e., this
    is a design decision made by me).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`update` 方法应用于符号表，其中 sFile[i][0] 作为键，`str(i)` 作为值。键是 sFile[i][0]，即标签（即字符串）。然而，`i`
    的 *值* 不是一个 *字符串*。这个值是一个 *整数*，`i`，它是当前行地址。我们通过 str(i) 将整数地址转换为字符串，因为等式以字符串的形式存储在表中（即，这是由我做出的设计决策）。'
- en: 'The next two lines print the symbol table:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 下两行打印符号表：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The value of the symbol table is printed using a `for` loop. We extract a `key:value`
    pair by using the following:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `for` 循环打印符号表中的值。我们使用以下方式提取 `key:value` 对：
- en: '[PRE23]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The items() method steps through all the elements of the `symbolTab` dictionary
    and allows us to print each `key:pair` value (i.e., all names/labels and their
    values). The `print` statement displays eight characters, right justified, by
    using `{:<8}.format(x)` to format the value of `x`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`items()` 方法遍历 `symbolTab` 字典的所有元素，并允许我们打印每个 `key:pair` 值（即，所有名称/标签及其值）。`print`
    语句使用 `{:<8}.format(x)` 格式化 `x` 的值，以显示八个字符，右对齐。'
- en: Having decoded an instruction, we next have to convert it into the appropriate
    binary code.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 解码指令后，我们接下来必须将其转换为适当的二进制代码。
- en: Building the binary instruction
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建二进制指令
- en: The next step in the assembly process is to generate the appropriate binary
    pattern for each instruction. In this section, we show how the components of an
    instruction are put together to create a binary value that can later be executed
    by the computer.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编过程的下一步是为每个指令生成适当的二进制模式。在本节中，我们展示了如何将指令的各个组件组合起来，以创建可以由计算机稍后执行的二进制值。
- en: Note that the code in this section describes some of the instruction processing
    involved in analyzing instructions. The actual simulator differs in minor details,
    although the principles are the same.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，本节中的代码描述了分析指令时涉及的一些指令处理。实际的模拟器在细节上有所不同，尽管原理是相同的。
- en: 'We first have to extract the mnemonic, convert it into binary, then extract
    the register numbers (where appropriate), and finally, insert the 16-bit literal.
    Moreover, because the assembler is in text form, we have to be able to deal with
    literals that are symbolic (i.e., they are names rather than numbers), decimal,
    negative, binary, or hexadecimal; that is, we have to handle instructions of the
    following form:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先必须提取助记符，将其转换为二进制，然后提取寄存器编号（如果适用），最后插入16位字面量。此外，因为汇编器是文本形式，我们必须能够处理符号字面量（即，它们是名称而不是数字）、十进制、负数、二进制或十六进制；也就是说，我们必须处理以下形式的指令：
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The assembler looks at each line of the source code and extracts the mnemonic.
    An instruction is a list of tokens (e.g., `''NEXT''`, `''ADD''`, `''r1''`, `''r2''`,
    `''0x12FA''`, which is five tokens, or `''STOP''`, which is one token). The situation
    is made more complex because the mnemonic may be the *first* token, or the *second*
    token if the instruction has a label. In the following example, `sFile` contains
    the program as a list of instructions, and we are processing line `i`, `sFile[i]`.
    Our solution is as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编器查看源代码的每一行，并提取助记符。指令是一系列标记（例如，`'NEXT'`、`'ADD'`、`'r1'`、`'r2'`、`'0x12FA'`，这是五个标记，或者
    `'STOP'`，这是一个标记）。情况变得更加复杂，因为助记符可能是第一个标记，或者如果指令有标签，则是第二个标记。在以下示例中，`sFile` 包含程序作为指令列表，我们正在处理第
    `i` 行，`sFile[i]`。我们的解决方案如下：
- en: Read the first token, `sFile[i][0]`. If this token is in the list of codes,
    then it’s an instruction. If it is not in the list of codes, it’s a label, and
    the second token, `sFile[i][1]`, is the instruction.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取第一个标记，`sFile[i][0]`。如果此标记在代码列表中，则它是一个指令。如果不在此代码列表中，则它是一个标签，第二个标记 `sFile[i][1]`
    是指令。
- en: Get the instruction details. These are stored in a dictionary called `codes`.
    If the mnemonic is in the dictionary, the key returns a tuple with two components.
    The first component is the format of the instruction, which defines the required
    operands in the sequence `rD`, `rS1`, `rS2`, `literal`; for example, the code
    `1001` indicates an instruction with a destination register and a literal. The
    second component of the tuple is the value of the opcode. We use a decimal value
    for this (ideally, it should be binary for the sake of readability, but binary
    values were too long and made the text harder to read).
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取指令详细信息。这些信息存储在一个名为 `codes` 的字典中。如果助记符在字典中，则键返回一个包含两个组件的元组。第一个组件是指令的格式，它定义了所需的操作数序列
    `rD`, `rS1`, `rS2`, `literal`；例如，代码 `1001` 表示一个具有目标寄存器和字面量的指令。元组的第二个组件是操作码的值。我们使用十进制值（理想情况下，为了可读性，它应该是二进制，但二进制值太长，使得文本难以阅读）。
- en: Read the register numbers from the tokens in the instruction; for example, `ADD`
    `r3`,`r2`,`r7` would return `3`,`2`,`7`, whereas `NOP` would return `0`,`0`,`0`
    (if a register field is not used, it is set to `0`).
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从指令中的标记读取寄存器编号；例如，`ADD` `r3`,`r2`,`r7` 将返回 `3`,`2`,`7`，而 `NOP` 将返回 `0`,`0`,`0`（如果寄存器字段未使用，则将其设置为
    `0`）。
- en: Read any literal and convert it into a 16-bit integer. This is the most complex
    operation because the literal may have one of the seven different formats described
    previously.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取任何字面量并将其转换为16位整数。这是最复杂的操作，因为字面量可能有之前描述的七种不同格式之一。
- en: The discussion in this section refers to the TC1 program that is presented in
    full at the end of the chapter. Here, we present slices of that program and explain
    how they work and the steps in the assembly process.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本节中的讨论指的是在章节末尾完整呈现的TC1程序。在这里，我们展示该程序的部分内容，并解释它们是如何工作的以及汇编过程中的步骤。
- en: Extracting the instruction and its parameters
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提取指令及其参数
- en: 'The following fragment of code shows the beginning of the loop that scans the
    source code and creates the binary value. This code initializes variables, extracts
    the opcode as a mnemonic, extracts any labels, extracts the parameters required
    by the mnemonic, and looks up the opcode and its format:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了扫描源代码并创建二进制值的循环的开始。此代码初始化变量，提取操作码作为助记符，提取任何标签，提取助记符所需的参数，并查找操作码及其格式：
- en: '[PRE25]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Lines 2 and 3 in the loop declare and initialize the variables and provide default
    values.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 循环中的第2和3行声明并初始化变量，并提供了默认值。
- en: 'The first `if…else` statement on line 4 looks at the first token on line `i`
    of the source code, `sFile[i][0]`. If that token is in the `codes` dictionary,
    then `sFile[i][0]` is the opcode. If it isn’t in the dictionary, then that token
    must be a label and the second token is the opcode (lines 4 and 5):'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 第4行的第一个`if…else`语句检查源代码第`i`行的第一个令牌`sFile[i][0]`。如果该令牌在`codes`字典中，则`sFile[i][0]`是操作码。如果不在此字典中，则该令牌必须是标签，第二个令牌是操作码（第4和5行）：
- en: '[PRE26]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If we encounter a label, we can convert it into its actual address, which is
    in `symbolTab`, using the following:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们遇到标签，我们可以将其转换为其实际地址，该地址在`symbolTab`中，使用以下方法：
- en: '[PRE27]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Lines 6, 7, 8, and 9 extract the predicate from the assembly language. Remember,
    the predicate comprises the tokens following the mnemonic and consists of any
    registers and literal required by the instruction:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 第6、7、8和9行从汇编语言中提取谓词。记住，谓词由助记符之后的令牌组成，包括指令所需的任何寄存器和字面量：
- en: '[PRE28]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We have to deal with two cases: the first token is the mnemonic and the second
    token is the mnemonic. We also check that the line is long enough to have a predicate.
    If there is a predicate, it is extracted by lines `7` and `9`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须处理两种情况：第一个令牌是助记符，第二个令牌也是助记符。我们还检查该行是否足够长以包含谓词。如果有谓词，它将通过第7和第9行被提取：
- en: '[PRE29]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The notation `[2:]` indicates *everything from token 2 to the end of the line*.
    This is a very nice feature of Python because it doesn’t require you to explicitly
    state the length of the line. Once we’ve extracted the predicate containing the
    register and literal information, we can start to assemble the instruction.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 符号`[2:]`表示从令牌2到行尾的所有内容。这是Python的一个非常好的特性，因为它不需要你明确地声明行的长度。一旦我们提取了包含寄存器和字面量信息的谓词，我们就可以开始汇编指令。
- en: 'Next, we extract the current line’s code format to get the information required
    from the predicate. Line `10`, form `= codes.get(opCode)`, accesses the `codes`
    dictionary to look for the mnemonic, which is in the `opCode` variable. The `get`
    method is applied to `codes` and the `form` variable receives the key value, which
    is the (`format`,`code`) tuple, for example, (`8`,`10`). The `form[0]` variable
    is the instruction format, and `form[1]` is the opcode:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们提取当前行的代码格式以获取从谓词中所需的信息。第10行，形式`= codes.get(opCode)`，访问`codes`字典以查找`opCode`变量中的助记符。`get`方法应用于`codes`，`form`变量接收键值，即（格式，代码）元组，例如（8，10）。`form[0]`变量是指令格式，`form[1]`是操作码：
- en: '[PRE30]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The second element of the tuple, `form[1]`, gives the 7-bit opcode; that is,
    `0100010` for `LDRL`. Lines `10` to `13` demonstrate how the destination register
    is extracted. We first use `AND` `form[0]` with `0b1000` to test the most significant
    bit that indicates whether a destination register, `rD`, is required by this instruction.
    If it is required, we first test whether the register is expressed in the form
    `R0`, or whether it’s given as a name, for example, `TIME`. We have to do this
    because TC1 lets you rename registers by using the `EQU` directive.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 元组的第二个元素 `form[1]` 提供了 7 位指令码；即 `0100010` 对于 `LDRL`。行 `10` 到 `13` 展示了如何提取目标寄存器。我们首先使用
    `AND` `form[0]` 与 `0b1000` 来测试最高有效位，该位指示是否需要此指令的目标寄存器 `rD`。如果需要，我们首先测试寄存器是否以 `R0`
    的形式表示，或者是否以名称给出，例如 `TIME`。我们必须这样做，因为 TC1 允许你使用 `EQU` 指令重命名寄存器。
- en: 'You can check whether an item is in the dictionary by using `dictionary`. Take
    the following example:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `dictionary` 来检查一个项目是否在字典中。以下是一个例子：
- en: 'if `''INC''` in opCodes:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 'if `''INC''` in opCodes:'
- en: To obtain information about a particular mnemonic, we can use the `get` method
    to read the value associated with the key `–` for example, `format =` `opCodes.get('INC')`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取有关特定助记符的信息，我们可以使用 `get` 方法读取与键 `–` 关联的值，例如，`format =` `opCodes.get('INC')`。
- en: 'The preceding example returns `format = (8,82)`. `8` refers to the format code
    `0b1000` (specifying a destination register). `82` is the opcode for this instruction.
    We access the two fields of the value associated with `''INC''` with, for example,
    the following:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子返回 `format = (8,82)`。`8` 指的是格式代码 `0b1000`（指定目标寄存器）。`82` 是该指令的指令码。我们可以使用以下方式访问与
    `'INC'` 关联的值的两个字段：
- en: '[PRE31]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We first test whether a register has a symbolic name in line `12` with. `if
    predicate[0]` in `symbolTab:` and, if it is in the symbol table, we read its value
    in line `13` with.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在行 `12` 中测试寄存器是否有符号名称。`if predicate[0]` in `symbolTab:`，如果它在符号表中，我们在行 `13`
    中读取它的值。
- en: '`rD =` `int(symbolTab[predicate[0]][1:])`'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`rD =` `int(symbolTab[predicate[0]][1:])`'
- en: We interrogate the symbol table with a key, which is the first element of the
    predicate since the destination register always comes first in a TC1 assembly
    language instruction (e.g., in `ADD` r4,`r7`,`r2`, register `r4` is the first
    element). The register is given by `predicate[0]`. The `symbolTab`[predicate[0]]
    expression looks up the symbolic name and provides its value; for example, consider
    `TIME EQU R3`. The `INC TIME` assembly language instruction will look up `TIME`
    and return `R3`. We now have the destination operand, but it is a string, `'R3'`,
    and not a number. We just want `3` and have to use the `int` function to convert
    a number in string format into an integer value.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用键来查询符号表，这个键是谓词的第一个元素，因为在 TC1 汇编语言指令中（例如在 `ADD` r4,`r7`,`r2` 中），目标寄存器总是第一个。寄存器由
    `predicate[0]` 提供。`symbolTab[predicate[0]]` 表达式查找符号名称并提供其值；例如，考虑 `TIME EQU R3`。`INC
    TIME` 汇编语言指令将查找 `TIME` 并返回 `R3`。我们现在有了目标操作数，但它是一个字符串，`'R3'`，而不是一个数字。我们只需要 `3`，并必须使用
    `int` 函数将字符串格式的数字转换为整数值。
- en: 'Let’s simplify the Python expression to make the explanation easier. Suppose
    we write the following:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简化 Python 表达式，以便更容易解释。假设我们写下以下内容：
- en: '`destReg =` `symbolTab`[predicate[0]]'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`destReg =` `symbolTab`[predicate[0]]'
- en: The value of `destReg` is the string representing the destination register.
    Assume that this is `'R3'`. What we need to do is to isolate `'3'` from `'R3'`
    and then convert the character `'3'` into the integer `3`. We can write `destRegNum
    = destReg[1:]` to return all characters in the string except the initial `'R'`.
    The final step is to convert into an integer, which we can do with `rD =` `int(destRegNum)`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`destReg` 的值是表示目标寄存器的字符串。假设这是 `''R3''`。我们需要做的是从 `''R3''` 中隔离 `''3''`，然后将字符
    `''3''` 转换为整数 `3`。我们可以写 `destRegNum = destReg[1:]` 来返回字符串中除了初始 `''R''` 之外的所有字符。最后一步是将它转换为整数，我们可以用
    `rD =` `int(destRegNum)` 来完成。'
- en: Remember that `[1:]` means all the characters after the first character, `'R'`.
    Consequently, this returns `'3'` if the register was `'R3'`. We could have written
    `[1:2]` rather than `[1:]` since the number is in the range 1 to 7\. However,
    by using the `[1:]` notation, we can later increase the number of registers beyond
    9 without changing the program.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`[1:]` 表示第一个字符 `'R'` 之后的所有字符。因此，如果寄存器是 `'R3'`，则返回 `'3'`。我们本来可以写 `[1:2]` 而不是
    `[1:]`，因为数字在 1 到 7 的范围内。然而，通过使用 `[1:]` 符号，我们可以在不改变程序的情况下，以后增加超过 9 个寄存器的数量。
- en: Putting all three steps together, we get `rD =` `int(symbolTab[predicate[0]][1:])`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 将这三个步骤结合起来，我们得到`rD = int(symbolTab[predicate[0]][1:])`。
- en: 'The following Python code shows the entire decoding process:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 以下Python代码显示了整个解码过程：
- en: '[PRE32]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This block of code performs the same sequence of operations three times, processing
    `rD`, then `rS1` (the first source register), and then `rS2` (the second source
    register) in the same way. The last section of this block of code (shaded)) is
    more complicated because we allow several representations of the literal. We use
    an `if…elif` structure to test for a symbolic literal, a binary literal, a hexadecimal
    literal, an unsigned decimal numeric literal, and finally, a negative decimal
    numeric literal.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码块执行相同的操作序列三次，以相同的方式处理`rD`，然后是`rS1`（第一个源寄存器），然后是`rS2`（第二个源寄存器）。这个代码块的最后部分（阴影部分）更复杂，因为我们允许字面量的多种表示。我们使用`if…elif`结构来测试符号字面量、二进制字面量、十六进制字面量、无符号十进制数值字面量，最后是负十进制数值字面量。
- en: The literal is a numeric constant used by an instruction. However, in the assembly
    language, the literal is represented by a text string; that is, if the literal
    is `12`, it is the string `'12'` and not the numeric value `12`. It has to be
    converted into numeric form by the `int()` function.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 字面量是指令使用的数值常数。然而，在汇编语言中，字面量由一个文本字符串表示；也就是说，如果字面量是`12`，它就是字符串`'12'`而不是数值`12`。它必须通过`int()`函数转换成数值形式。
- en: 'We initially decided to allow decimal, binary, or hexadecimal integers. Later,
    we included symbolic names because they are so easy to deal with using Python’s
    dictionary. Suppose we have an instruction that has been tokenized into a mnemonic
    and a predicate that contains registers and a literal or symbolic name, for example,
    `[''R1'', ''R2'' , ''myData'']`. Consider the following code:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最初决定允许十进制、二进制或十六进制整数。后来，我们包括了符号名称，因为它们使用Python的字典处理起来非常容易。假设我们有一个指令，它已经被分解成一个助记符和一个包含寄存器和字面量或符号名称的谓词，例如，`['R1',
    'R2', 'myData']`。考虑以下代码：
- en: '[PRE33]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This takes the last element of the predicate (indicated by the `[-1]` index)
    and looks to see whether it’s in the symbol table. If it isn’t, the code tests
    for other types of literal. If it is in the symbol table, it is extracted and
    the `myData` symbolic name is replaced with its actual value.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这取谓词的最后一个元素（由`[-1]`索引指示）并查看它是否在符号表中。如果没有，代码将测试其他类型的字面量。如果在符号表中，它将被提取出来，并且`myData`符号名称将被其实际值替换。
- en: 'The literal in the table may be an integer or a string. The following converts
    it into a string if it is a literal:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 表中的字面量可能是一个整数或字符串。以下代码将其转换为字符串（如果它是字面量的话）：
- en: '[PRE34]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `if` construct uses the `type()` function, which returns the type of an
    object. In this case, it will be `'int'` if the object is an integer. The `str()`
    function converts an integer object into a string object.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`结构使用`type()`函数，该函数返回对象的类型。在这种情况下，如果对象是整数，它将是`''int''`。`str()`函数将整数对象转换为字符串对象。'
- en: This action may seem strange because we are converting an integer (which we
    want) into a string (which we don’t want). The reason for this anomaly is that
    we are later going to test for hex, binary, and signed values that will be strings,
    and keeping all literals as strings simplifies the coding.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作看起来可能很奇怪，因为我们正在将一个整数（我们想要的）转换成一个字符串（我们不想要的）。这种异常的原因是我们稍后将要测试十六进制、二进制和有符号值，这些值将是字符串，并且将所有字面量都作为字符串来处理可以简化编码。
- en: 'The following code demonstrates how three number formats are converted into
    integer form, ready for packing into the final 32-bit TC1 machine instruction:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了如何将三种数字格式转换为整数形式，以便将其打包到最终的32位TC1机器指令中：
- en: '[PRE35]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Binary numbers are prefixed with either `%` or `0b` in the TC1 assembly language,
    and hexadecimal values with `$` or `0x`. The constant is tested to see whether
    it’s decimal, binary, or hex, and then the appropriate conversion is performed.
    Converting a binary string, `x`, into an integer, `y`, is done with `y = int(x,2)`.
    The parameter in bold is the number base. In this case, it’s `2` in binary format.
    In hexadecimal format, it’s 16.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在TC1汇编语言中，二进制数以`%`或`0b`为前缀，十六进制值以`$`或`0x`为前缀。常数被测试以确定它是十进制、二进制还是十六进制，然后执行适当的转换。将二进制字符串`x`转换为整数`y`使用`y
    = int(x,2)`完成。粗体参数是数字基数。在这种情况下，它是二进制格式的`2`。在十六进制格式中，它是`16`。
- en: 'Let’s look at the hex conversion. We have to make two selections: the token
    and then the specific characters of the token. Consider `ADDL R1,R2,0XF2A4`. The
    predicate is `''R1 R2 0XF2A4''`, which is tokenized as `predicate = [''R1'', ''``R2'',
    ''0XF2A4'']`.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看十六进制转换。我们必须进行两个选择：首先是标记，然后是标记的具体字符。考虑`ADDL R1,R2,0XF2A4`。谓词是`'R1 R2 0XF2A4'`，它被标记为`predicate
    = ['R1', '``R2', '0XF2A4']`。
- en: 'The value of `predicate[-1]` is `''`0XF2A4`''`. To test for a hexadecimal value,
    we have to look at the first two characters to see whether they are `''0X''`.
    Note `0X` not `0x` because TC1 converts input into uppercase. We could write the
    following:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`predicate[-1]`的值是`''0XF2A4''`。为了测试十六进制值，我们必须查看前两个字符，看它们是否是`''0X''`。注意`0X`不是`0x`，因为TC1将输入转换为大写。我们可以编写以下代码：'
- en: '[PRE36]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We can save a line by combining the two list-index suffixes, `[-1]` and `[0:2`],
    into `predicate[-1][0:2]`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过合并两个列表索引后缀`[-1]`和`[0:2]`来节省一行，即`predicate[-1][0:2]`。
- en: 'The third line of the code, `elif predicate[-1].isnumeric(): literal=int(predicate[-1])`,
    detects decimal strings and converts them into numeric form. Since decimal values
    don’t have a prefix, we use the `isnumeric` method to test for a string that has
    a numeric value. This line is read as, "*If the last token in the predicate is
    numeric, then convert it into an* *integer value*."'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '代码的第三行`elif predicate[-1].isnumeric(): literal=int(predicate[-1])`检测十进制字符串并将它们转换为数值形式。由于十进制值没有前缀，我们使用`isnumeric`方法来测试具有数值的字符串。这一行读作，“*如果谓词中的最后一个标记是数值，则将其转换为*
    *整数值*。”'
- en: Finally, we have to deal with negative numbers (e.g., -5). If a literal is prefixed
    with -, the remaining string is read and converted into two’s complement binary
    form in 16 bits. This is necessary because the TC1 computer represents signed
    integers in 16-bit two’s complement form.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须处理负数（例如，-5）。如果一个字面量以-开头，则读取剩余的字符串并将其转换为16位二进制补码形式。这是必要的，因为TC1计算机以16位二进制补码形式表示有符号整数。
- en: 'The generation of the final 32-bit binary code of an instruction is easy. We
    have an opcode and zero to four fields to insert. The fields are initially set
    to all zeros (the default values). Then, each field is shifted left to its required
    place in the instruction and inserted into the instruction by using a bit-wise
    `OR` operation. The code for this is as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 生成指令的最终32位二进制代码很容易。我们有一个操作码和零到四个字段可以插入。字段最初设置为全零（默认值）。然后，每个字段向左移动到指令中所需的位置，并通过位运算`OR`将其插入到指令中。相应的代码如下：
- en: '[PRE37]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We could do all this in one line, as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以一行完成所有这些，如下所示：
- en: '[PRE38]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In the next chapter, we’ll return to the TC1 simulator and expand it. We’ll
    also demonstrate how the TC1 simulator can be extended by adding new operations
    to the instruction set and some ways of printing the results of a simulator.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将回到TC1模拟器并对其进行扩展。我们还将展示如何通过向指令集添加新操作和打印模拟器结果的一些方法来扩展TC1模拟器。
- en: Before presenting the full TC1, we are going to demonstrate a simplified version
    that can execute an assembly language program, essentially the same as the TC1\.
    However, this version has been designed to reduce the total complexity by leaving
    out features such as symbolic names or the ability to use different number bases
    when specifying a constant. In this case, all literals are simple decimal integers.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在展示完整的TC1之前，我们将演示一个简化的版本，它可以执行汇编语言程序，本质上与TC1相同。然而，这个版本已被设计为通过省略诸如符号名称或指定常量时使用不同数基的能力等特性来降低总复杂性。在这种情况下，所有字面量都是简单的十进制整数。
- en: 'Intermission: The Pre-TC1'
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 休息：TC1之前
- en: In order to provide a more complete overview of the operation of a CPU simulator,
    we are going to introduce a highly simplified, but complete, version to give you
    an idea of how things fit together, before we create a more complex system.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供一个更完整的CPU模拟器操作概述，我们将引入一个高度简化的但完整的版本，以便在我们创建更复杂的系统之前，给你一个了解事物如何组合的概念。
- en: In this section, you will learn how to design a simulator without some of the
    complications associated with a fully fledged design.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何设计一个模拟器，它不包含与完整设计相关的某些复杂性。
- en: This version of TC1, called TC1mini, can execute assembly language. However,
    we use a fixed format for assembly-level instructions (input is case-sensitive)
    and a fixed literal format (no hexadecimal or binary numbers), and we don’t support
    labels and symbolic names. This approach helps stop the details from getting in
    the way of the bigger picture.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本的TC1，称为TC1mini，可以执行汇编语言。然而，我们使用固定的汇编级指令格式（输入区分大小写）和固定的字面量格式（不支持十六进制或二进制数字），并且我们不支持标签和符号名称。这种方法有助于防止细节干扰大局。
- en: The Simulator
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟器
- en: 'The simulator supports register-to-register operations, such as `ADD r1,r2,r3`.
    Its only memory access is pointer-based, that is, `LDRI r1,[r2]` and `STRI r1,[r2]`.
    It provides increment and decrement instructions, `INC r1` and `INC r2`. There
    are two compare operations: `CMPI r1,5` and `CMP r1,r2` (the former compares a
    register with a literal and the latter compares two registers). To keep things
    simple, the only status flag is `z` (zero) and this is used only by compare and
    subtract operations.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟器支持寄存器到寄存器的操作，例如 `ADD r1,r2,r3`。它的唯一内存访问是基于指针的，即 `LDRI r1,[r2]` 和 `STRI r1,[r2]`。它提供递增和递减指令，`INC
    r1` 和 `INC r2`。有两种比较操作：`CMPI r1,5` 和 `CMP r1,r2`（前者比较寄存器与字面量，后者比较两个寄存器）。为了保持简单，唯一的状态标志是
    `z`（零），并且这个标志仅用于比较和减法操作。
- en: Three branch instructions are provided (unconditional branch, branch on zero,
    and branch on not zero). Since this simulator doesn’t support symbolic names,
    a branch requires a literal to indicate the destination. Branching is relative
    to the current location of the branch instruction; for example, `BRA 3` means
    jump to the instruction three locations forward, and `BRA -2` means jump two instructions
    backward.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 提供了三种分支指令（无条件分支、零分支和非零分支）。由于这个模拟器不支持符号名称，分支需要一个字面量来指示目标。分支相对于分支指令的当前位置；例如，`BRA
    3` 表示跳转到三个位置之后的指令，而 `BRA -2` 表示跳转回两个指令之前。
- en: I did not provide a file-based program input mechanism (i.e., reading a source
    program as a text file). The assembly language program to be executed is embedded
    as a Python list of strings called `sFile`. You can readily modify this or substitute
    the code to input a file.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我没有提供基于文件的程序输入机制（即，将源程序作为文本文件读取）。要执行的汇编语言程序作为名为 `sFile` 的Python字符串列表嵌入。你可以轻松修改它或替换代码以输入文件。
- en: 'The opcodes are set up in a dictionary of the following form:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 指令集被设置为以下形式的字典：
- en: '[PRE39]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `key:value` pair uses a mnemonic as the key and a list with one item, the
    class of the instruction, as the value. The classes range from `0` (a mnemonic
    with no operands) to `7` (a mnemonic with a register and register indirect operand).
    We’ve not implemented TC1’s 4-bit format code, which is used to determine the
    parameters required by an instruction, because that information is implicit in
    the class. Moreover, we do not assemble the instruction into a binary code. We
    read the mnemonic in text form and directly execute it.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`key:value` 对使用助记符作为键，并使用一个包含一个项目的列表作为值，该列表表示指令的类。类从 `0`（没有操作数的助记符）到 `7`（具有寄存器和寄存器间接操作数的助记符）。我们没有实现TC1的4位格式代码，该代码用于确定指令所需的参数，因为该信息在类中是隐含的。此外，我们不会将指令汇编成二进制代码。我们以文本形式读取助记符，并直接执行它。'
- en: When an instruction is read, it is first tokenized to create a list of one to
    four tokens, for example, `['CMPL', 'r3', '5']`. When an instruction is read from
    the source, the class is determined and used to extract the required information
    from the tokens.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当读取指令时，它首先被标记化以创建一个包含一到四个标记的列表，例如，`['CMPL', 'r3', '5']`。当从源读取指令时，确定类并用于从标记中提取所需信息。
- en: Once the mnemonic and register numbers/values and literal are known, a simple
    `if .. elif` structure is used to select the appropriate instruction and then
    execute it. Most instructions are interpreted in a single line of Python.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦知道了助记符、寄存器编号/值和字面量，就使用简单的 `if .. elif` 结构来选择适当的指令，然后执行它。大多数指令都在Python的单行中解释。
- en: At the end of the instruction reading and execution loop, you are invited to
    hit a key to execute the next instruction in sequence. The data displayed after
    each instruction is the program counter, z-bit, instruction, registers, and memory
    location. We use only four registers and eight memory locations.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在指令读取和执行循环结束时，你会被邀请按下一个键来按顺序执行下一个指令。每条指令之后显示的数据是程序计数器、z位、指令、寄存器和内存位置。我们只使用四个寄存器和八个内存位置。
- en: 'We have split this program into sections with brief descriptions between them.
    The first part provides the source code as a built-in list. It defines the instruction
    classes and provides a list of opcodes and their classes. We don’t use a dictionary
    for this. However, we do provide dictionaries for the registers and their indirect
    versions to simplify analyzing instructions. For example, we can look up both
    `r1` and `r2` in the `LDRI` `r1,[r2]` instruction:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个程序分成几个部分，每个部分之间都有简短的描述。第一部分提供源代码作为内置列表。它定义了指令类并提供了一组操作码及其类。我们为此不使用字典。然而，我们为寄存器及其间接版本提供了字典，以简化指令分析。例如，我们可以在`LDRI
    r1,[r2]`指令中查找`r1`和`r2`：
- en: '[PRE40]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In the following section, we analyze an instruction to extract the values of
    the operands required by the instruction. This is achieved by looking at the instruction’s
    op-class and then extracting the appropriate information (e.g., the register number):'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们分析一条指令以提取指令所需的操作数值。这是通过查看指令的op-class然后提取适当的信息（例如，寄存器号）来实现的：
- en: '[PRE42]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This is the instruction execution part of the program. We use a series of comparisons
    of the mnemonic with the opcodes and then directly execute the instruction. Unlike
    TC1, we do not convert the mnemonic into binary code and then execute it by converting
    the binary code into appropriate operations:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这是程序中的指令执行部分。我们使用一系列比较助记符与操作码，然后直接执行指令。与TC1不同，我们不将助记符转换为二进制代码，然后再通过将二进制代码转换为适当的操作来执行它：
- en: '[PRE43]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Note that the execution loop ends with an input request from the keyboard. In
    this way, the next cycle is not executed until the *Enter*/*Return* key is pressed.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，执行循环以从键盘请求输入结束。这样，在按下*Enter*/*Return*键之前，下一个循环不会执行。
- en: 'The following shows the output of the simulator as the embedded program is
    executed. Changed registers, memory locations, and flag values are in bold font:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 以下展示了模拟器在执行嵌入式程序时的输出。更改的寄存器、内存位置和标志值以粗体显示：
- en: '[PRE44]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We will now look at the program for the TC1 simulator. We will include a short
    introduction to some of its facilities before providing the code.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将查看TC1模拟器的程序。在提供代码之前，我们将简要介绍其一些功能。
- en: The TC1 simulator program
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TC1模拟器程序
- en: In this section, we provide the full code for the TC1 assembler and simulator.
    This will enable you to construct and modify a computer assembler and simulator
    that can execute the code supported by TC1 or your own instruction set (if you
    modify TC1).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们提供了TC1汇编器和模拟器的完整代码。这将使您能够构建和修改一个可以执行TC1支持的代码或您自己的指令集（如果您修改了TC1）的计算机汇编器和模拟器。
- en: The assembler is the more complicated part because it involves reading text,
    analyzing it, and formatting it into binary codes. The simulator itself simply
    reads each binary code and then performs the appropriate action.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编器是更复杂的一部分，因为它涉及到读取文本、分析它并将其格式化为二进制代码。模拟器本身只是读取每个二进制代码然后执行相应的操作。
- en: The simulator includes features that we haven’t covered yet in previous sections
    (e.g., debugging and trace facilities). In the first draft of this book, TC1 was
    rather more basic with a minimal subset of features. As the book was edited and
    the program modified, the set of features was enhanced to make it a more practical
    tool. We first provide brief notes on some of these features to aid understanding
    of the program.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟器包括我们在前面的章节中尚未介绍的功能（例如，调试和跟踪功能）。在本书的第一稿中，TC1的功能相对更基础，具有最小子集的功能。随着书籍的编辑和程序的修改，功能集得到了增强，使其成为一个更实用的工具。我们首先简要介绍一些这些功能，以帮助理解程序。
- en: Single-stepping
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单步执行
- en: A computer executes instructions sequentially unless a branch or subroutine
    call is encountered. When testing a simulator, you frequently want to execute
    a batch of instructions together (i.e., without printing register values), or
    you may wish to execute instructions one at a time by hitting *Enter*/*Return*
    after each instruction has been executed or to execute instructions until you
    hit a specific instruction.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机按顺序执行指令，除非遇到分支或子程序调用。在测试模拟器时，您经常希望一起执行一批指令（即，不打印寄存器值），或者您可能希望在每条指令执行后按*Enter*/*Return*键逐条执行指令，或者执行指令直到您按下特定的指令。
- en: In this version of TC1, you can execute and display an instruction, skip the
    display of the next n instructions, or not display instructions until a change-of-flow
    instruction is encountered. After the program is loaded, the input prompt is displayed.
    If you enter a return, the simulator executes the next instruction and waits.
    If you enter an integer (and return), the specified number of instructions is
    executed without displaying the results. If you enter b followed by a return,
    the simulator executes instructions without displaying them until the next branch
    instruction is encountered.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在TC1的这个版本中，你可以执行并显示一条指令，跳过显示接下来的n条指令，或者直到遇到改变流程的指令才显示指令。程序加载后，会显示输入提示。如果你输入回车，模拟器将执行下一条指令并等待。如果你输入一个整数（然后回车），模拟器将执行指定数量的指令而不显示结果。如果你输入b然后回车，模拟器将执行指令而不显示它们，直到遇到下一个分支指令。
- en: 'Consider the following example. The code is just a set of random instructions
    for demonstration. I’ve used no-operations (`nop`) as a filler. I’ve also tested
    literal address formats (hex and binary) and demonstrated case insensitivity:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例。代码只是一组用于演示的随机指令。我使用了无操作(`nop`)作为填充。我还测试了字面地址格式（十六进制和二进制），并展示了不区分大小写：
- en: '[PRE45]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'I’ve edited it to remove memory locations as they are not accessed. After the
    prompt, `>>>`, you select what is to happen: trace one instruction, execute `n`
    instructions without stopping or displaying registers, or execute code to the
    next branch instruction without displaying it. In each case, the following program
    counter value is highlighted in the following output. The text in bold is a comment
    I left on an action on the current line (trace indicates a *Return*/*Enter* was
    hit, which executes the next instruction):'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经编辑了它，移除了未访问的内存位置。在提示符`>>>`之后，你选择要执行的操作：跟踪一条指令，执行`n`条指令而不停止或显示寄存器，或者执行代码到下一个分支指令而不显示它。在每种情况下，以下输出中都会突出显示程序计数器的值。粗体的文本是我留在当前行操作上的注释（跟踪表示按下了*Return*/*Enter*键，这将执行下一条指令）：
- en: '[PRE46]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: File input
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件输入
- en: When we first started writing a simulator, we inputted test programs the easy
    way by typing the instructions in one by one. This worked for the simplest of
    tests but soon became tedious. Later, programs were input as a text file. That
    worked well when the filename was short, such as `t.txt`, but it got more tedious
    with long filenames (e.g., when I stored the source code in a specific directory).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们最初开始编写模拟器时，我们通过逐个输入指令的简单方式输入测试程序。这对于最简单的测试是有效的，但很快变得繁琐。后来，程序以文本文件的形式输入。当文件名较短时，例如`t.txt`，效果很好，但随着文件名的变长（例如，当我在特定目录中存储源代码时），它变得更加繁琐。
- en: We then included the filename in the actual TC1 program. That’s convenient when
    you’re going to be running the same program over and over again while you’re testing
    various features of the simulator. What we needed was a means of using my working
    program (baked into the simulator) most of the time, but to switch to an alternative
    when required.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将文件名包含在实际的TC1程序中。当你需要反复运行相同的程序来测试模拟器的各种功能时，这很方便。我们需要的是一种方法，在大多数时候使用我的工作程序（嵌入在模拟器中），但在需要时切换到替代程序。
- en: 'One sensible solution would be to generate an input banner prompting you to
    press *Enter* for the default file, or provide a filename for an alternative source
    program, say, *Enter return for the default file* or *Enter a filename for an
    alternative source program*. We decided to use Python’s exception mechanism to
    implement this. In computing, an *exception* (also called a *software interrupt*)
    is a mechanism designed to deal with unexpected events. In Python, the exception
    handler uses two reserved words: `try` and `exception`.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 一个合理的解决方案是生成一个输入提示，提示你按*Enter*键选择默认文件，或者为替代源程序提供文件名，例如，*按Enter键选择默认文件*或*输入文件名以选择替代源程序*。我们决定使用Python的异常机制来实现这一点。在计算机科学中，*异常*（也称为*软件中断*）是一种设计用来处理意外事件的机制。在Python中，异常处理器使用两个保留字：`try`和`exception`。
- en: As their names suggest, `try` requires Python to run the following block of
    code, and `exception` is a block of code that is executed if the `try` block failed.
    Essentially, it means, *“If you can’t do this, do that.”* The difference between
    `if` and `try` is that `if` returns `True` or `False` and performs the specified
    action if `True`, whereas `try` *attempts* to run a block and calls an exception
    if it fails, that is, if it crashes.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，`try` 会让 Python 执行其后的代码块，而 `exception` 是在 `try` 块失败时执行的代码块。本质上，它意味着“如果你不能这样做，就做那件事。”`if`
    和 `try` 的区别在于，`if` 返回 `True` 或 `False`，并在 `True` 时执行指定的操作，而 `try` 则尝试运行一个代码块，如果失败（即崩溃），则会调用异常。
- en: '`try` allows you to attempt to open a file and then gives you a way out if
    the file doesn’t exist (i.e., it avoids a fatal error). Consider the following:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`try` 允许你尝试打开一个文件，如果文件不存在（即避免致命错误），则提供一种退出方式。考虑以下情况：'
- en: '[PRE47]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This code looks for a file called `testException1.txt`. If it’s present (as
    it is in this case), the simulator runs it and we get the following output:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码寻找一个名为 `testException1.txt` 的文件。如果存在（如本例所示），模拟器会运行它，我们得到以下输出：
- en: '[PRE48]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In the next case, we’ve deleted `testException1.txt`. We now get the following
    output after the prompt:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个案例中，我们已删除 `testException1.txt`。现在在提示符后得到以下输出：
- en: '[PRE49]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The line in bold is the alternative filename.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 粗体显示的行是备选的文件名。
- en: 'In the TC1 program, I further simplify things by including the file directory
    in the exception (because I always use the same directory) and I include the file
    extension, `.txt`. This looks as follows:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TC1 程序中，我进一步简化了事情，通过在异常中包含文件目录（因为我总是使用相同的目录）并包含文件扩展名 `.txt`。它看起来如下：
- en: '[PRE50]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This expression automatically provides the path for the filename and address
    of the file type.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表达式自动提供文件名和文件类型的路径。
- en: Remember that Python lets you use the `+` operator to concatenate strings.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，Python 允许你使用 `+` 操作符来连接字符串。
- en: TC1 program
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TC1 程序
- en: The first part of the program provides a list of instructions and their encoding.
    This text is placed between two `'''` markers that indicate it is not part of
    the program. This avoids having to start each line with `#`. The triple quote
    marks is called a docstring comment.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的第一部分提供了指令列表及其编码。这段文本放置在两个 `'''` 标记之间，表示它不是程序的一部分。这样可以避免每行都从 `#` 开始。这种三引号称为文档字符串注释。
- en: 'The first part of TC1 is a listing of the instructions. These are provided
    to make the program easier to follow:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: TC1 的第一部分是指令列表。这些是为了使程序更容易理解而提供的：
- en: '[PRE51]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Because the `shift` operation is rather complex with left and right shifts,
    variable-length shifts, plus shifts, and rotates, we have provided a function
    to implement shifts. This takes the type of shift, direction, and number of places
    shifted as input parameters, together with the word to be shifted:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 由于左移和右移、变长移位、加移位和旋转操作相当复杂，我们提供了一个实现移位的函数。这个函数接受移位类型、方向和移动位数作为输入参数，以及要移动的单词：
- en: '[PRE52]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This is the function, `getLit`, that processes a literal. It can handle literals
    in a range of possible formats, including decimal, binary, hexadecimal, and symbolic
    form:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这是处理字面量的函数 `getLit`。它可以处理多种可能的格式中的字面量，包括十进制、二进制、十六进制和符号形式：
- en: '[PRE53]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '`Print` statements can be a little complicated. Consequently, we have created
    a `print` function that is used to display register and memory contents. We discuss
    print formatting elsewhere in this book. We generate the data as strings to be
    printed, `m`, `m1`, and `m2`, and then print them using the appropriate formatting:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`Print` 语句可能有点复杂。因此，我们创建了一个 `print` 函数，用于显示寄存器和内存内容。我们将在本书的其他地方讨论打印格式。我们生成要打印的字符串数据
    `m`、`m1` 和 `m2`，然后使用适当的格式打印它们：'
- en: '[PRE55]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The preceding block of code provides a debug functionality and is intended
    to demonstrate the concept of debugging and provide a facility to check the assembly
    process by displaying intermediate information during the assembly phase. A variable,
    `debugLevel`, is read from the keyboard at the start of the program. This determines
    the level of the debugging facility from 1 (none) to 5 (maximum). Debugging information
    can include the source code, decoded operations, and other parameters:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码块提供了调试功能，旨在演示调试的概念，并提供在汇编阶段显示中间信息以检查汇编过程的功能。在程序开始时，从键盘读取一个变量 `debugLevel`。这决定了调试功能级别，从
    1（无）到 5（最大）。调试信息可以包括源代码、解码操作和其他参数：
- en: '[PRE56]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The following section is responsible for reading the source file to be assembled
    and executed. This source code should be in the form of a `.txt` file. Note that
    this code uses Python’s `try` and `except` mechanism, which is able to perform
    an action (in this case, try and load a file from disk) and, if the action fails,
    perform a new action instead. Here, we use it to test for a default filename and
    then get one from the terminal if that file does not exist:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 以下一小节负责读取要汇编和执行的源文件。此源代码应采用`.txt`文件的形式。请注意，此代码使用Python的`try`和`except`机制，该机制能够执行一个动作（在这种情况下，尝试从磁盘加载文件）并在动作失败时执行另一个动作。在这里，我们用它来测试默认文件名，如果该文件不存在，则从终端获取一个文件名：
- en: '[PRE57]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This short section deals with the equate assembler directive and binds values
    to symbolic names using the `EQU` directive. These bindings are placed in the
    `symbol table` dictionary and the equates are removed from the source code:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这一小节处理等价汇编指令，并使用`EQU`指令将值绑定到符号名称。这些绑定放置在`符号表`字典中，等价项从源代码中移除：
- en: '[PRE59]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Here, we perform the instruction decoding; that is, we analyze the text of
    each instruction to extract the opcode and parameters:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们执行指令解码；也就是说，我们分析每条指令的文本以提取操作码和参数：
- en: '[PRE60]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'This section was added after the development of TC1\. We introduce the concept
    of a debug level. That is, at the beginning of a simulation run, you can set a
    parameter in the range of `1` to `3` that determines how much information is displayed
    during the assembly processing. This allows you to get more information about
    the instruction encoding when testing the program:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这一节是在TC1开发之后添加的。我们引入了调试级别的概念。也就是说，在模拟运行开始时，你可以设置一个范围在`1`到`3`之间的参数，以确定在汇编处理过程中显示多少信息。这允许你在测试程序时获取更多关于指令编码的信息：
- en: '[PRE61]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We are about to execute the instructions. Before we do that, it is necessary
    to initialize several variables concerning the current operation (e.g., tracing):'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将执行指令。在我们这样做之前，有必要初始化一些与当前操作相关的变量（例如，跟踪）：
- en: '[PRE62]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'This is the main loop where we decode instructions to extract the parameters
    (register numbers and the literal):'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这是主循环，我们在这里解码指令以提取参数（寄存器编号和字面量）：
- en: '[PRE64]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'In the next section, we depart from the original version of TC1\. The first
    version of TC1 decoded the opcode as a binary string and then looked it up. However,
    as we have the source file, it is easier to go directly from the text of the mnemonic
    and execute it. This makes the code so much easier to read:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将从TC1的原始版本开始。TC1的第一个版本将操作码解码为二进制字符串，然后进行查找。然而，由于我们有源文件，直接从助记符文本执行会更简单。这使得代码更容易阅读：
- en: '[PRE65]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'This section performs a function called tracing and allows us to list the contents
    of the register or turn off the listing as we execute the code:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这一小节执行一个名为跟踪的功能，允许我们在执行代码时列出寄存器的内容或关闭列表：
- en: '[PRE66]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Now that we’ve explained the TC1 simulator, we’ll demonstrate its use.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经解释了TC1模拟器，我们将演示其使用方法。
- en: Example of a TC1 assembly language program
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TC1汇编语言程序的示例
- en: 'Here, we demonstrate a TC1 program in assembly language. This offers a means
    of testing the simulator and showing how it works. We would like to test a range
    of facilities, so we should include looping, conditional testing, and pointer-based
    memory access. We will write a program to do the following:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们演示了一个TC1汇编语言程序。这提供了一种测试模拟器和展示其工作方式的方法。我们希望测试一系列功能，因此我们应该包括循环、条件测试和基于指针的内存访问。我们将编写一个程序来完成以下任务：
- en: Fill a region of memory from locations 0 to 4 with random numbers.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将内存从位置0到4的区域填充为随机数。
- en: Reverse the order of the numbers.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 反转数字的顺序。
- en: 'Since this problem uses memory and sequential addresses, it involves register
    indirect addressing, that is, `LDRI` and `STRI` instructions. Creating the random
    numbers and storing them sequentially in memory can be done by doing the following:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个问题使用内存和顺序地址，它涉及到寄存器间接寻址，即`LDRI`和`STRI`指令。通过以下方式创建随机数并将它们按顺序存储在内存中：
- en: '[PRE68]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'In TC1 code, we can translate this as follows:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在TC1代码中，我们可以将其翻译如下：
- en: '[PRE69]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'We’ve filled a region of memory with random values. We now need to reverse
    their order. There are many ways of reversing the order of numbers. One is to
    move the numbers from the source to a temporary location in memory and then write
    them back in reverse order. Of course, this takes up extra memory for the temporary
    copy. Consider another solution that does not require a buffer. We will write
    down the source addresses above the destination addresses:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经用随机值填充了一个内存区域。现在我们需要反转它们的顺序。有许多方法可以反转数字的顺序。一种是将数字从源位置移动到内存中的一个临时位置，然后以相反的顺序写回。当然，这需要额外的内存来存储临时副本。考虑另一种不需要缓冲区的解决方案。我们将在目标地址上方写下源地址：
- en: '`Original (source)        0   1   2   3   4`'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`原始（源）        0   1   2   3   4`'
- en: '`Swapped (destination)    4   3   2   1   0`'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`交换（目标）    4   3   2   1   0`'
- en: 'As you can see, location `0` is swapped with location `4`, then location `1`
    with location `3`; then, at location `2`, we have reached the middle point and
    the reversal is complete. To perform this action, we need two pointers, one for
    each end of the string. We select the two characters at the ends of the string
    and swap them. Then, we move the pointers inward and do a second swap. The task
    is complete when the pointers meet in the middle. Note that this assumes an odd
    number of items to reverse:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，位置`0`与位置`4`交换，然后位置`1`与位置`3`交换；接着，在位置`2`，我们达到了中间点，反转完成。为了执行这个动作，我们需要两个指针，每个字符串的一端一个。我们选择字符串两端的两个字符并交换它们。然后，我们将指针向内移动并执行第二次交换。当指针在中点相遇时，任务完成。请注意，这假设要反转的项目数量是奇数：
- en: '[PRE70]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'In TC1 assembly language, this looks as follows:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在TC1汇编语言中，这看起来如下：
- en: '[PRE71]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The following shows the output when this program is executed, instruction by
    instruction. In order to simplify the reading of this data, we’ve put changes
    in register and memory values in bold. The branch operations are shaded. Comparison
    instructions are in italics.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 以下显示了程序逐条指令执行时的输出。为了简化数据的阅读，我们将寄存器和内存值的变化用粗体表示。分支操作被阴影覆盖。比较指令用斜体表示。
- en: 'The first block is the source code printed by TC1 before the start of the instruction
    execution:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个块是在指令执行开始前TC1打印的源代码：
- en: '[PRE72]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The second code block shows the output of the assembler as instructions are
    decoded. You can see the various registers, the literal, and the format field:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个代码块显示了汇编器在指令解码时的输出。你可以看到各种寄存器、字面量和格式字段：
- en: '[PRE73]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The following provides the output of a run using this program. We’ve set the
    trace level to `4` to show the source code (after text processing), the symbol
    table, and the decoded instructions.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 以下提供了使用此程序运行时的输出。我们将跟踪级别设置为`4`以显示源代码（在文本处理之后）、符号表和解码指令。
- en: Then, we’ve executed the code line by line. In order to make the output more
    readable and to fit it on the page, we’ve removed registers and memory locations
    that don’t change, and we’ve highlighted values (memory, registers, and z-flag)
    that change as the result of an instruction. You can follow this through and see
    how memory/registers change with each instruction.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们逐行执行了代码。为了使输出更易于阅读并适应页面，我们移除了不改变的寄存器和内存位置，并突出显示了由于指令的结果而改变的值（内存、寄存器和z标志）。你可以跟随这些内容，看看内存/寄存器是如何随着每个指令而改变的。
- en: 'As you can see, we create five random numbers in memory locations `0` to `4`
    and then reverse their order. This does not match the output of the print status
    because it’s been modified for printing:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们在内存位置`0`到`4`中创建了五个随机数，然后反转它们的顺序。这并不匹配打印状态的输出，因为它已经被修改以适应打印：
- en: '[PRE74]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'In the next section, we demonstrate how you might go about testing the operation
    of TC1\. We cover the following:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将展示如何测试TC1的操作。我们将涵盖以下内容：
- en: Testing the assembler (e.g., the ability to use a free format of code)
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试汇编器（例如，使用代码自由格式的能力）
- en: Testing flow control instructions (branches)
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试流程控制指令（分支）
- en: Testing shift operations
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试移位操作
- en: Testing the assembler
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试汇编器
- en: 'Since the TC1 assembler can deal with several typographic features (e.g., uppercase
    or lowercase and multiple spaces), a simple way of testing the assembler is to
    give it a file to assemble that includes various conditions, such as multiple
    spaces, equates, and uppercase and lowercase conversion. My initial test source
    code was as follows:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 由于TC1汇编器可以处理多种排版特性（例如，大写或小写和多个空格），测试汇编器的一个简单方法是为它提供一个包含各种条件的文件来汇编，例如多个空格、等价和大小写转换。我的初始测试源代码如下：
- en: '[PRE75]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'This is not exactly stylish code; it’s just random test code. In the following
    code, we provide the output of the assembler when operated in `debug` mode. This
    includes the formatting of the code (removal of blank lines and lowercase to uppercase
    conversion). The first listing provides the instructions as an array of lists
    of tokens:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The second listing is the symbol table that ties symbol names and labels to
    integer values:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The next listing was used largely for debugging when an instruction didn’t
    behave as intended. It lets you determine whether an instruction has been correctly
    decoded:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Testing flow control operations
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here, we demonstrate how to test the computer’s most important class of operations,
    the flow-control instruction, that is, the conditional branch.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the most important classes of instructions to test are those that change
    the flow of control: the branch and subroutine call instructions. The following
    fragment of code is also meaningless (it serves only to test instruction execution)
    and is designed only to test loops. One loop is built using a branch on a not-zero
    operation, and the other uses an automatic loop mechanism that operates by decrementing
    a register and branching until the register decrements to zero. The `DBNE` `r0`,`loop`,
    where `r0` is the counter being decremented and `loop` is the branch target address.'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: 'We first provide the source listing and symbol table:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The following provides the output after a debugging session. As you can see,
    the sequence of branches is faithfully implemented. Note that we’ve highlighted
    the branch actions and consequences (i.e., the next instruction):'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: In the next chapter, we will look at some of the ways in which the TC1 program
    can be enhanced to add facilities such as error checking, the inclusion of new
    instructions, and special features such as variable-length operand fields.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: Testing shift operations
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'TC1 supports two shift types: *logical* and *rotate*. A logical shift moves
    the bits left or right. At one end, vacated bits are replaced by zeros and, at
    the other end, the bit shifted out is copied to the carry flag. In a rotation,
    the bit that is shifted out of one end is copied to the other end; that is, the
    string of bits is treated as a ring. No bit is lost, no matter how many shifts
    take place. At each bit shift, the bit that was shifted to the other end is also
    copied to the carry bit.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: 'Most real computers have two other shift variations: an arithmetic shift that
    preserves the sign of two’s complement numbers when shifted right (divide-by-2
    operation) and a rotate-through-carry shift where the bit shifted in at one end
    is the old carry bit and the bit shifted out becomes the new carry bit. Essentially,
    if the register has `m` bits, the carry bit is included to create an `m+1` bit
    word. This feature is used for multi-precision arithmetic. We haven’t included
    these modes in TC1.'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: 'As well as specifying the shift type, we have to specify the shift direction
    (left or right). Most computers let you specify the number of shifts. We provide
    both facilities and the number of shifts can be specified using either a register
    or a literal. In a multi-length shift, the state of the carry bit is the last
    bit shifted out into the carry. The shift operations (with examples) are as follows:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '| **Shift Type** | **Register/Literal** | **Example** |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
- en: '| Logical shift left | literal | `LSLL r0,r1,2` |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
- en: '| Logical shift left | register | `LSL r3,r1,r4` |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
- en: '| Logical shift right | literal | `LSRL r0,r1,2` |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
- en: '| Logical shift right | register | `LSR r3,r1,r2` |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
- en: '| Rotate left | literal | `ROLL r0,r1,2` |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
- en: '| Rotate left | register | `ROL` `r3,r1,r0` |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
- en: '| Rotate right | literal | `RORL r0,r3,2` |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
- en: '| Rotate right | register | `ROR` `r3,r1,r0` |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
- en: Table 6.1 – TC1 shifting modes
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: When we test these instructions, we have to ensure that the shift direction
    is correct, the right number of shifts take place, the end bits (those shifted
    out or in) behave correctly, and the flag bits are set appropriately.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following fragment of code using the 16-bit value `1000000110000001`
    in a series of shifts:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The following output from the simulator (edited to show only relevant information)
    gives the registers and condition codes as the preceding code is executed. The
    binary value of register `r0` is displayed on the right. This allows us to verify
    whether the operations have been executed correctly by manual inspection:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Note that a load operation does not affect the z-bit. Some computers update
    the z-bit after almost every operation. Some update the z-bit on demand (e.g.,
    ARM, which we will introduce later), and some update it only after certain operations.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: The penultimate section of this chapter covers adding a postscript to TC1 where
    we provide a simpler example that performs the same basic function but carries
    out some operations in a different way, such as instruction decoding. The purpose
    of this is to demonstrate that there are many ways of constructing a simulator.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: TC1 postscript
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The version of TC1 presented here grew during the development of this book.
    The current version has more features than the prototype; for example, initially,
    it didn’t include symbolic branch addresses and required users to enter actual
    line numbers.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: Here, we’re presenting a cut-down version of TC1, called TC1mini, where we do
    some things differently; for example, by not allowing a free format (mnemonics
    must be uppercase and registers lowercase, and you can’t use spaces and commas
    as interchangeable delimiters). In this version, a simple function checks that
    the mnemonic is valid and terminates the program if it isn’t. Similarly, we’ve
    added a feature that checks whether an address generated by a pointer lies within
    the bounds of your memory space. The following section provides some comments
    on this version.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: The classDecode function
  id: totrans-359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TC1 associates a 4-bit binary value with each instruction to indicate that parameters
    are required by the current instruction; for example, `1101` indicates registers
    `rD`, `rS1`, and a literal. The TC1mini version associates a *class number* in
    the range `0` to `7`, with each instruction that describes its type. The classes
    range from `0` (mnemonic with no parameters) to `7` (mnemonic with an indirect
    address, such as `LDRI r2,[r4])`. Unlike TC1, the `[ ]` brackets are not optional
    in TC1mini's assembly language.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: The difference between the two simulators, TC1 and TC1mini, is that the 4-bit
    binary code provides *pre-decoding*; that is, the simulator doesn’t have to calculate
    what parameters the instruction requires because the code directly tells you that.
    If you use a class number instead, you have to decode the class number to determine
    the actual parameters required. However, a class number can be very creative.
    TC1mini uses seven different instruction formats and requires a minimum of seven
    classes to be defined. If you had, say, 14 classes, each addressing mode class
    could be divided into two subclasses to give you greater control over the instruction
    execution process.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: The `classDecode` function takes in an instruction’s predicate and returns the
    four predicate values, the destination register, source register `1`, source register
    `2`, and the literal. Of course, instructions may have from zero to four of these
    values. Consequently, these parameters are initially set to dummy values, either
    a `null` string or zero.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: 'Before continuing, recall that Python’s `in` operator is useful for testing
    whether an element is a member of a set. For example, if an operation is in classes
    2, 4, 5, and 9, we can write the following:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The current instruction’s `opClass` is used to extract the parameters. Instead
    of using `if` constructs, we’ve used Python’s `if in [list]` construct; for example,
    `if opClass in [3,4,5,6,7]` returns `True` if the instruction is in classes `3`
    to `7`. If it is, the predicate (a string) is divided into a list using the `split()`
    function, and the first element is read to extract the destination register, `rD`.
    Note that we need to split the predicate only once, because all the following
    cases also fall within this group.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: The testLine function
  id: totrans-366
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another limitation of TC1 is the lack of testing and validation; for example,
    I sometimes type `MOVE` instead of `MOV` and the program crashes. Normally, this
    isn’t a problem; you just re-edit the source program. However, when debugging
    TC1, I often assumed an error was due to a mistake in my new code, only to discover
    that it was simply a misprint in the assembly language program. So, I added a
    small amount of testing. The following provides the testing function:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The only line of interest is the following:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'There are two cases to consider: instructions with a label and those without
    a label. In the former case, the mnemonic is the second token in the instruction,
    and in the latter case, the mnemonic is the first token. We can test whether a
    token is a mnemonic by using Python’s `if ... in` construct. Say we have the following
    construct:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '`if token[0]` `in codes`'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: This returns `True` if the first token is a valid mnemonic. We can combine the
    two tests with an `or` Boolean to get the preceding expression. In the program,
    we call `testLine` with the `tokens` parameter and it returns an error. We use
    the error to print a message and return it to the operating system with the `sys.exit()`
    function.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: The testIndex() function
  id: totrans-374
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This simulator provides an instruction in the form `LDRI r1,[r2]` to provide
    memory indirect addressing (i.e., pointer-based or indexed addressing).
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, register `r1` is loaded with the contents of memory pointed at
    by register `r2`. If the pointer register contains an invalid value that is outside
    the range of legal addresses, the program will crash. By testing the index, we
    can ensure that an out-of-range index is detected. Note that only the first source
    register, `rS1`, is ever used as a memory pointer:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: General comments
  id: totrans-378
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following line demonstrates how we extract the operation class from the
    mnemonic. The expression looks strange because of the `()` and `[]` parentheses.
    The `codes.get(key)` operation uses `key` to get the associated value from the
    `codes` dictionary:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: In this case, the key is the mnemonic, and the value returned is the operation
    class; for example, if the mnemonic is `'LDRL'`, the corresponding value is `[3]`.
    Note that the value returned is not `3`! It is a *list* with the single value
    `3`. Consequently, we have to extract the value from the list by specifying the
    first item, that is, `mnemonic[0]`.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: There are many ways to build an instruction. In TC1, we create a binary value,
    just like a real assembler. In TC1mini, we directly execute the instruction from
    the assembly language form. So, when we compile the instructions, we create a
    program in text form. To do that, we need to combine the label, mnemonic, registers,
    and literal into a list.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: 'The code to do that is as follows:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: In this example, we use the `list()` function to combine items into a list,
    and then we use `append()` to add this item to an existing list. Note the syntax
    of `list()`. You might expect it to be `list(a,b,c)`. No. It’s `list((a,b,c))`.
    The `list()` function uses parentheses as normal but the list itself must be in
    parentheses. That’s because the list items constitute a *single* parameter to
    list.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: The TC1tiny code listing
  id: totrans-386
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is the listing of the cut-down version of TC1\. Instructions fall into
    eight classes depending on the number and arrangements of operands. Each instruction
    is in a dictionary, `codes`, which provides the class number that is used to decode
    operands. The instruction itself is executed directly from its mnemonic. Unlike
    TC1, there is no intermediate binary code. Similarly, both register names and
    indirect register names are in dictionaries to simplify instruction decoding:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'This section deals with decoding instructions into the appropriate task in
    order to correctly execute them with the appropriate parameters:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Unlike TC1, we perform a little testing on the input, for example, whether
    the memory or register index is out of range. This is simply an illustrative example
    of data validation:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'The following is the actual instruction execution loop. As you can see, it
    is remarkably compact:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: The code execution loop, like most of the simulators we discuss, is remarkably
    straightforward. The current instruction is fetched and decoded into mnemonic,
    class, and register numbers. The program counter is advanced and the mnemonic
    is presented to a series of `then...elif` statements.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: 'Many of the instructions are executed in only one line of code; for example,
    `ADD` is implemented by adding two registers together: `r[rD] = r[rS1] + r[rS2]`.
    Some instructions, such as `compare`, require two registers to be subtracted and
    then the status bits to be set accordingly.'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: We included one relatively complex instruction, decrement and branch on not
    zero, which decrements a register and then branches to a target address if the
    register has not counted down to `0`.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: In the final section, we will look at yet another variation of TC1.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: TC1 postscript mark II
  id: totrans-399
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If one postscript is good, two are even better. We’ve added this second variation
    on a theme to demonstrate some different ways of doing things. Much of the program’s
    structure is the same as before. The features are as follows:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: Direct execution (revisited)
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to avoid different mnemonics (e.g., `ADD` and `ADDL`) for the same
    basic operation
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The principal enhancement is the way to handle instructions and decode them.
    In TC1, we use a 4-bit code to define the structure of each instruction in terms
    of its parameters. When a mnemonic is looked up in the dictionary, it returns
    a code giving the required parameters.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: One feature (problem?) with TC1 is that we have different mnemonics for variations
    on an instruction, for example, `ADD` and `ADDL`. The suffix `L` tells the assembler
    that a literal operand (rather than a register number) is required. In this example,
    we avoid different instruction formats and use a single mnemonic by putting instructions
    into classes. Each class defines an instruction format, ranging from class `0`
    (instruction with no parameters) to class `9` (instruction with *four* registers).
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: This example uses the direct execution of an instruction. That is, we don’t
    compile an instruction into binary and then execute the binary. We execute an
    instruction directly from its mnemonic.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: A consequence of this arrangement is that an instruction may fall into multiple
    classes; for example, `LDR` is in *three* classes, rather than having the `LDR`,
    `LDRL`, and `LDRI` variants. When an instruction is encountered, it is checked
    against each class. If the mnemonic is in a class, the attributes of the instruction
    are checked before deciding whether we’ve found the correct class.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: Consider `ADD`. We can write `ADD r1,r2,5` or `ADD r1,r2,r3`; that is, the second
    number added to a register may be a literal or a register. Consequently, `ADD`
    is in class `5` and class `6`. To resolve the ambiguity, we look at the final
    operand; if it’s a literal, then it’s class `5`, and if it’s a register, it’s
    class `6`.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: 'Testing for a register is easy because we’ve put registers in a dictionary,
    so it’s necessary only to check whether the final operand is in the dictionary
    or not. Consider class `3`:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Here, we do a triple test. First, we check whether the mnemonic is in class
    `3`. Then, we test the predicate length (it’s `2` for two operands, such as `CMP
    r1,5`). Finally, we test for a numeric second operand by ensuring that the operand
    is not in the list of registers.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: The Python program for this experiment is as follows.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'In this simulator, we deal with instructions by class rather than by mnemonic.
    This feature means that the same mnemonic can have different addressing modes,
    such as literal, register, or even memory. The first class, `0`, is reserved for
    mnemonics with no operands, such as `NOP`. Of course, this mechanism would make
    it possible to invent a new operation, such as, say, `NOP 4`, that acts in a different
    way:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: The purpose of the previous program is to demonstrate another way of categorizing
    instructions and using the number of operands to distinguish between instruction
    types, such as `ADD r1,r2` and `ADD r1,r2,r3`.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-416
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we presented the TC1 simulator, which can take a text file
    in TC1 assembly language, convert it into machine code, and then execute it. TC1’s
    instruction set architecture is close to the classic RISC architecture with a
    register-to-register architecture (i.e., data operations take place on the contents
    of registers). The only memory operations permitted are loading a register from
    memory (or a literal) and storing a register in memory.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: 'The simulator has two basic components: an assembler that translates a mnemonic
    such as `ADD r1,r2,r3` into a 32-bit binary instruction, and an interpreter that
    reads the instruction, extracts the necessary information, and then executes the
    instruction.'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: Some of the elements of TC1 are rather unusual. A free-format structure for
    the source code is provided; for example, you can write `ADD r1,r2,r3` or `adD
    R1 r2 r3` and both instructions will be happily accepted. Why? First, it was done
    to demonstrate the use of string processing in Python. Second, it makes it easier
    for the user to enter input in their chosen case. All input is automatically converted
    into uppercase to make the language case-free. Similarly, a comma or space is
    allowed as a separator between parameters. Finally, the need for `[]` brackets
    to indicate indirect addressing was removed. Users may enter `LDRI r0,[r1]` or
    `LDRI r0,r1`.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, numbers can be entered in different forms (decimal, binary, or hexadecimal);
    for example, number bases can be indicated in *Motorola format* or *Python format*.
    Most real assemblers don’t permit such luxury.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: The first versions of TC1 required all addresses to be numeric; if you wanted
    to branch to line `30`, you had to write `BRA 30`. It was the remarkable power
    and ease of use of Python’s dictionary structure that made it so easy to include
    labels. All you have to do is recognize a label, pop it in the dictionary together
    with its value, and then, whenever you encounter that label, just look up its
    value in the dictionary.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: We also provided an example assembly language program to test TC1 and a short
    discussion of how we go about testing various instructions.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: Having designed TC1, we created a rather simplified version and called it TC1mini.
    This simulator does not provide the same flexibility in writing instructions,
    and it does not have a large instruction set. It also does not encode the instruction
    into a binary form and then decode it again and execute it. It executes the assembly
    instruction directly (thanks one more to Python’s dictionary mechanism).
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: At the end of this chapter, we provided yet another simplified computer simulator
    to both emphasize the structure of a computer simulator and provide an example
    of the way in which you can modify the basic design.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: In this key chapter, we introduced the TC1 computer simulator and presented
    its design. We also looked at variations of TC1 to help create a more complete
    picture of the simulator and assembler. In the next chapter, we will take things
    a step further and look at some more aspects of the simulator. We will describe
    several simulators that have different architectures.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
