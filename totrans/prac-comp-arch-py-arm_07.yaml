- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TC1 Assembler and Simulator Design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will put together the lessons we have learned in previous
    chapters and construct a computer simulator. The key topics we will cover in this
    chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing instructions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dealing with assembler directives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the binary instruction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The pre-TC1 (a prequel to the actual simulator)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The TC1 simulator program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A TC1 assembly language program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TC1 postscript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you should understand how a simulator is designed
    and be able to create one. The following two chapters concentrate on expanding
    the simulator and providing more facilities, such as error detection in the input.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the programs used in this chapter on GitHub at [https://github.com/PacktPublishing/Practical-Computer-Architecture-with-Python-and-ARM/tree/main/Chapter06](https://github.com/PacktPublishing/Practical-Computer-Architecture-with-Python-and-ARM/tree/main/Chapter06).
  prefs: []
  type: TYPE_NORMAL
- en: In order to construct a Python-based simulator, you need the same tools used
    in earlier chapters; that is, you require an editor to create the Python program
    and a Python interpreter. These are included in the freely available Python package
    we introduced in [*Chapter 1*](B19624_01.xhtml#_idTextAnchor015).
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing instructions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at the way in which we take a text string representing
    an assembly language instruction and process it to create binary code that can
    be executed by the simulator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Interestingly, the assembler can be more complicated than the actual simulator.
    Indeed, we devote relatively little space to the simulator itself in this chapter.
    We don’t actually need an assembler, because it’s easy to hand-translate assembly-level
    operations into binary code; it’s just a matter of filling in the fields of the
    32-bit instruction format. For example, *load register R7 with the literal value
    42* can be written as `LDRL` `R7`,`42`. This has a 7-bit opcode, `01` `01010`,
    the destination register is `r7` (code `111`), the two source registers are not
    used, and their fields can both be set to `000`. The literal is `42`, or `0000000000101010`
    as a 16-bit binary value. The binary-encoded instruction is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 0001010111`000000`0000000000101010
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s easy to translate code by hand, but it’s no fun. We are going to create
    an assembler that automates the process of translation and lets you use symbolic
    names rather than actual literals (constants). Consider the following example
    of assembly language code. This is written using *numeric values* (shaded), rather
    than symbolic names. This is not intended to be a specific assembly language;
    it is designed to illustrate the basic concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following example, literals have been replaced with symbolic names.
    These are shaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Python’s dictionary structure makes the handling of symbolic names very easy
    indeed. The preceding shows the processing of a text file containing the assembly
    language. This file is called `sFile` and is simply a `.txt` file containing the
    assembly language instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Processing the input
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will now look at how the raw input – that is, the text file containing the
    assembly language source code – can be processed. In principle, it would be nice
    to have a source file where the assembly language instructions were all perfectly
    formatted and laid out.
  prefs: []
  type: TYPE_NORMAL
- en: In reality, a program may not be formatted ideally; for example, there may be
    blank lines or program comments that need to be ignored.
  prefs: []
  type: TYPE_NORMAL
- en: We have designed this assembly language to allow considerable latitude in the
    writing of a TC1 program. In fact, it allows a free format that is not implemented
    by most real assemblers. We took this approach for several reasons. First, it
    demonstrates how to perform text processing, which is a fundamental part of the
    design of assemblers. Second, a free format means you don’t have to remember whether
    to use uppercase or lowercase names and labels.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some languages are case-sensitive and some are not. The assembly language we
    have designed is *case-insensitive*; that is, you can write either `ADD` r0`,r1,r2`
    or `ADD` R0`,R1,R2.` Consequently, we can write the load register immediate assembly
    instruction in all the following forms to execute a *load* *register-indexed*
    operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`LDRI` `R2,[R1],10` or'
  prefs: []
  type: TYPE_NORMAL
- en: '`LDRI` `R2,r1,10` or'
  prefs: []
  type: TYPE_NORMAL
- en: '`LDRI` `R2,[R1,10]` or`,`'
  prefs: []
  type: TYPE_NORMAL
- en: '`LDRI r2,r1,10`'
  prefs: []
  type: TYPE_NORMAL
- en: This level of freedom of notation is possible because the `[]` brackets are
    not actually necessary to identify the instruction; they are used in programs
    because programmers associate `[r0]` with indirect addressing. In other words,
    the brackets are there for the programmer, not the computer, and are redundant.
  prefs: []
  type: TYPE_NORMAL
- en: However, this level of freedom is not necessarily desirable because it could
    lead to errors and make it more difficult for one person to read another person’s
    program. All design decisions come with pros and cons.
  prefs: []
  type: TYPE_NORMAL
- en: The following Python example includes a short embedded assembly language program.
    The Python code has been designed so that you can use either an assembly language
    program that is part of the assembler (this is just for testing and debugging
    purposes because it avoids having to go into a text editor every time you want
    to test a feature) or a program in text form on disk. In this example, we located
    the test program at `E\:testCode.txt` on my computer. When the demonstration text-processing
    code runs, it asks you whether the code is to come from disk or is the embedded
    code. Typing `d` reads the disk, and entering any other input reads the embedded
    code.
  prefs: []
  type: TYPE_NORMAL
- en: The filename of the assembly language program is `testCode = 'E://testCode.txt'`.
    A double backslash is used instead of the conventional filenaming convention in
    Python programs.
  prefs: []
  type: TYPE_NORMAL
- en: The text-processing program removes blank lines, converts text into uppercase
    (allowing you to write `r0` or `R0`), and lets you use a comma or a space as a
    separator (you can write `ADD R0,R1,R2` or `ADD r0 r1 r2`). We also remove surplus
    spaces before and after the instruction. The final result is a tokenized list;
    that is, `ADD r0,r1,r2` is converted into the `['ADD','R0','R1','R2']` list. Now,
    the assembler can look up the instruction and then extract the information it
    requires (register numbers and literals).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following program, we used a new variable every time we processed a
    line in order to help you keep track of variables. The following is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ve used different variable names for clarity. Normally, you would write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We use file comprehension to remove comments in the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This is a rather clever trick and requires explanation. It copies each line
    of `sFile2` to `sFile3`. However, the value copied for each line is `i.split('@')[0]`,
    where `i` is the current line. The `split('@')` method divides the list into strings
    using `'@'` as a divider. If there is no `'@'` in the original string, the string
    is copied. If there is an `'@'`, it is copied as two strings; for example, `ADD
    R1,R2,R3 @ Sum the totals` is copied to `sFile3` as `'ADD R1,R2,R3','@ Sum the
    totals'`. However, only the first element of the list is copied because of the
    `[0]` index; that is, only `'ADD R1,R2,R3'` is copied and the comment is removed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The text input processing block is given here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The following are two examples of using this code. In the first case, the user
    input is `d`, indicating a disk program, and in the second case, the input is
    `x`, indicating the use of the embedded source program. In each case, the course
    and output values are printed to demonstrate the string-processing operations.
  prefs: []
  type: TYPE_NORMAL
- en: Case 1 – Disk input
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Case 2 – Using the embedded test program
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code does not represent an optimum text-processing system. It
    was designed to demonstrate the basic process involved in manipulating text before
    you process it. However, these concepts will appear again in TC1.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with Mnemonics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s in a name? How do we know that a `NOP` instruction stands alone, but
    an `ADD` instruction requires three registers? In this section, we begin a discussion
    of how assembly language instructions are processed in order to extract their
    meaning (i.e., convert them into binary form).
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following fragment of TC1 assembly language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: When the assembler reads a line, it needs to know how to deal with the opcode
    and its operands. So, how does it know how to proceed? We can use Python’s dictionary
    facility to solve this problem in a very simple way, by just looking in a table
    to see what information an opcode requires.
  prefs: []
  type: TYPE_NORMAL
- en: Recall that a dictionary is a set or collection of items, where each item has
    two components; for example, an English-German dictionary has items that consist
    of an English word and its German equivalent. The word you look up is called a
    *key* and that provides a *value*. For example, in the English-German dictionary,
    the item `'town':'Stadt'` consists of the key `town` and the value `Stadt`. A
    dictionary is a fancy name for a *look-up table*.
  prefs: []
  type: TYPE_NORMAL
- en: A dictionary in Python is defined by its punctuation (i.e., it doesn’t require
    any special reserved Python words); it’s a type of list enclosed by curly braces,
    `{}`. Each list item consists of a key and its value separated with a colon. Successive
    items are separated with commas, exactly as in a list.
  prefs: []
  type: TYPE_NORMAL
- en: 'A *key* is used to access the appropriate value in a dictionary. In TC1, the
    key is the *mnemonic* used to look up the details of the instruction. Let’s create
    a dictionary called `codes` with three keys that are strings representing valid
    TC1 instructions: `STOP`, `ADD`, and `LDRL`. This dictionary can be written as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Each key is a string terminated by a colon, followed by its value. The key
    doesn’t have to be a string. In this case, it’s a string because we are using
    it to look up mnemonics, which are text strings. The first `key:value` pair is
    `''STOP'':P` , where `''STOP''`is the key and `P` is its value. Suppose we want
    to know whether `ADD` is a legal instruction (i.e., in the dictionary). We can
    test whether this instruction (i.e., key) is in the dictionary with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This returns `True` if the key is in the dictionary, and `False` otherwise.
    You can use `not in` to test whether something is *not* in a dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python allows a key to be associated with any valid object, for example, a
    list. We could write, for example, the following `key:value` pair:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here, the value associated with a key is a five-element list that associates
    the `ADD` mnemonic with the number of its operands, its binary encoding, its name,
    the date it was designed, and the number of times it was used in the current program
    (as well as being able to read a value from a dictionary, you can write to it
    and update it).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code sets up a dictionary that binds mnemonics to variables (preset
    to integers `1,2,3,4`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we used the `get()` method to read the value associated with
    a key. If the key is `x`, its value is given by `validCd.get(x)`; that is, the
    syntax is `dictionaryName.get(key)`.
  prefs: []
  type: TYPE_NORMAL
- en: Assembly language contains instructions that are executed. However, it also
    contains information called *assembler directives* that tells the program something
    about the environment; for example, where to put data in memory or how to bind
    symbolic names to values. We will now look at assembler directives.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with assembler directives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will learn about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: What assembler directives do
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create a symbol table linking symbolic names to values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to access the symbol table
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to update the symbol table
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processing labels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will demonstrate how the names the programmer chooses are manipulated and
    translated into their appropriate numerical values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first version of TC1 required you to provide actual values for all names
    and labels. If you wanted to jump to an instruction, you had to provide the number
    of lines to jump. It’s much better to allow the programmer to write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`JMP next`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, `next` is the label of the target line. This is preferred over writing
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`JMP 21`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, if the literal `60` represents minutes in an hour, write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MULL` `,R1,MINUTES`'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is preferred over the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MULL` `,R1,60`'
  prefs: []
  type: TYPE_NORMAL
- en: We need a means of *linking* `next` with `21` and `MINUTES` with `60`.
  prefs: []
  type: TYPE_NORMAL
- en: Python’s *dictionary* structure solves this problem. We simply create `key:value`
    pairs, where `key` is the label that we want to define and `value` is its value.
    In this example, a dictionary for the preceding example would be `{'NEXT':21,
    'MINUTES':60}`. Note this example uses *integers* as values. In this book, we
    will also use *strings* as values, because we input data in text form; for example,
    `'MINUTES':'60'`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `EQU` assembler directive equates a value with a symbolic name. For example,
    TC1 lets you write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MINUTES` `EQU 60`'
  prefs: []
  type: TYPE_NORMAL
- en: Using the dictionary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `MINUTES EQU 60` assembler directive has three tokens: a label, a function
    (equate), and a value. We extract the `''MINUTES'':60` dictionary pair from the
    source code and insert it into a dictionary called `symbolTab`. The following
    code demonstrates the procedure. The first line sets up a symbol table. We initialize
    it with a dummy entry, `''START'':0`. We’ve created this initial entry for testing
    purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `for` loop (shaded) reads each line of the source code, `sFile`, and tests
    for lines where `'EQU'` is the second token in the line. The `len(sFile[i]) >
    2` comparison ensures that this line has at least three tokens to ensure it’s
    a valid equate directive. The text is in bold font.
  prefs: []
  type: TYPE_NORMAL
- en: We can perform two tests together by employing an `and` Boolean operator so
    that the test is true only if both conditions are true.
  prefs: []
  type: TYPE_NORMAL
- en: We check that the second token is `'EQU'` with `sFile[i][1] == 'EQU'`. The `sFile`[i][1]
    notation has two list indexes. The first, in bold, indicates line `i` of the source
    code, and the second index indicates token 1 of that line; that is, it is the
    second element.
  prefs: []
  type: TYPE_NORMAL
- en: If `'EQU'` is found, we add (i.e., insert) the first token,`[`sFile[i][0]`]`,
    into the symbol table as the key, and the third token, sFile[i][2], as the value.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the `MINUTES EQU 60` source code line.
  prefs: []
  type: TYPE_NORMAL
- en: The key is `sFile[i][0]` and its value is `sFile[i][2]`, because `MINUTES` is
    the first token on line `i` and `60` is the third token on line `i`. The stored
    key is `'MINUTES'` and its value is `60`. But note that the value `60` is in *string*
    form and not *integer* form. Why? Because the assembler directive is a string
    and not an integer. If we want the numeric value, we have to use `int()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final line of this block of code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This line uses a list comprehension to scan the source file and delete any
    line with `EQU`, because only instructions are loaded in program memory. A line
    containing `EQU` is a directive and not an instruction. This operation uses the
    count method, `i.count(''EQU'')`, to count the number of times `EQU` appears in
    a line, and then deletes that line if the count isn’t `0`. The condition we test
    for before moving (i.e., keeping) a line is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`if i.count(''EQU'') ==` `0:`'
  prefs: []
  type: TYPE_NORMAL
- en: Here, `i` is the current line being processed. The `count` method is applied
    to the current line and counts the number of occurrences of the `'EQU'` string
    in the line. Only if the count is `0` (i.e., it isn’t a line with an `EQU` directive)
    does that line get copied into `sFile`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because detecting an `EQU` directive, putting it in the symbol table, and removing
    it from the code are so important, we will demonstrate its operation with a little
    piece of test code. The following code fragment sets up a list of three instructions
    in `sFile` to test. Remember that `sFile` is a list of lists and each list is
    an instruction composed of tokens, each of which is a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The code in bold is the code we’ve discussed. The remaining code is made up
    of `print` statements used to observe the code’s behavior. The key line in this
    code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`symbolTab[sFile[i][0]] =` `sFile[i][2]`'
  prefs: []
  type: TYPE_NORMAL
- en: 'This updates the symbol table by adding a `key:value` pair in the following
    format:'
  prefs: []
  type: TYPE_NORMAL
- en: '`symbolTab[key] =` `value`'
  prefs: []
  type: TYPE_NORMAL
- en: 'When this code is run, it generates the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The final two lines give the symbol table and the post-processed version of
    `sFile`. The two equates have been loaded into the dictionary (symbol table) and
    the processed output has had the two equates stripped.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several ways to add new `key:value` pairs to a dictionary. We could
    have applied the `update` method to `symbolTab` and written the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In a later example of an assembler, we will adopt a different convention for
    assembler directives and use the format .`equ name value` because this convention
    is adopted by ARM processors, as we’ll see in later chapters. There is often more
    than one way of representing assembly directives, each with its own advantages
    and disadvantages (e.g., ease of coding or fitting in with particular standards
    and conventions).
  prefs: []
  type: TYPE_NORMAL
- en: Labels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next step in processing the source file is to deal with labels. Take the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the decrement operation subtracts `1` from the contents of
    register `r1`. If the result is `0`, the `Z flag` is set. The next instruction
    is *branch on zero to NEXT1*. If *Z = 1*, a jump is made to the line labeled `NEXT1`;
    otherwise, the `INC r2` instruction immediately following `BEQ` is executed.
  prefs: []
  type: TYPE_NORMAL
- en: The binary program (machine code) generated by TC1 does not store or use labels.
    It requires either the actual address of the next instruction or its relative
    address (i.e., how far it needs to jump from the current location). In other words,
    we need to translate the `NEXT1` label into its actual address in the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a job for the dictionary. All we have to do is put a label in the dictionary
    as a key and then insert the corresponding address as the value associated with
    the key. The following three lines of Python demonstrate how we collect label
    addresses and put them in the symbol table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The three lines, 1 to 3, define a `for` loop that steps through every line in
    the source code in `sFile`. Because we’ve processed the code to convert each instruction
    into a list of tokens, each line begins with either a valid mnemonic or a label.
    All we have to do is check whether the first token on a line is in the list (or
    dictionary) of mnemonics. If the first token is in the list, it’s an instruction.
    If it’s not in the list, then it’s a label (we are ignoring the case that it’s
    an error).
  prefs: []
  type: TYPE_NORMAL
- en: 'We perform the check for a valid mnemonic with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `sFile[i][0]` represents the first item (i.e., token) of line `i` in
    the dictionary of mnemonics. The `not in` Python code returns `True` if the mnemonic
    is not in the dictionary called `codes`. If the test does return `True`, then
    we have a label and must put it in the symbol table with the following operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This expression says, “*Add the specified* `key:value` *pair to the dictionary
    called* `symbolTable`*.*” Why is the value associated with the label given as
    `i`? The value associated with the label is the address of that line (i.e., the
    value of the program counter, `pc`, when that line is executed). Since we are
    stepping through the source code line by line, the counter, `i`, is the corresponding
    value of the program counter.
  prefs: []
  type: TYPE_NORMAL
- en: The `update` method is applied to the symbol table with sFile[i][0] as the key
    and `str(i)` as the value. The key is sFile[i][0], which is the label (i.e., a
    string). However, the *value* of `i` is not a *string*. The value is an *integer*,
    `i`, which is the current line address. We convert the integer address into a
    string with str(i) because equates are stored in the table as strings (i.e., this
    is a design decision made by me).
  prefs: []
  type: TYPE_NORMAL
- en: 'The next two lines print the symbol table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The value of the symbol table is printed using a `for` loop. We extract a `key:value`
    pair by using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The items() method steps through all the elements of the `symbolTab` dictionary
    and allows us to print each `key:pair` value (i.e., all names/labels and their
    values). The `print` statement displays eight characters, right justified, by
    using `{:<8}.format(x)` to format the value of `x`.
  prefs: []
  type: TYPE_NORMAL
- en: Having decoded an instruction, we next have to convert it into the appropriate
    binary code.
  prefs: []
  type: TYPE_NORMAL
- en: Building the binary instruction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next step in the assembly process is to generate the appropriate binary
    pattern for each instruction. In this section, we show how the components of an
    instruction are put together to create a binary value that can later be executed
    by the computer.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the code in this section describes some of the instruction processing
    involved in analyzing instructions. The actual simulator differs in minor details,
    although the principles are the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'We first have to extract the mnemonic, convert it into binary, then extract
    the register numbers (where appropriate), and finally, insert the 16-bit literal.
    Moreover, because the assembler is in text form, we have to be able to deal with
    literals that are symbolic (i.e., they are names rather than numbers), decimal,
    negative, binary, or hexadecimal; that is, we have to handle instructions of the
    following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The assembler looks at each line of the source code and extracts the mnemonic.
    An instruction is a list of tokens (e.g., `''NEXT''`, `''ADD''`, `''r1''`, `''r2''`,
    `''0x12FA''`, which is five tokens, or `''STOP''`, which is one token). The situation
    is made more complex because the mnemonic may be the *first* token, or the *second*
    token if the instruction has a label. In the following example, `sFile` contains
    the program as a list of instructions, and we are processing line `i`, `sFile[i]`.
    Our solution is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Read the first token, `sFile[i][0]`. If this token is in the list of codes,
    then it’s an instruction. If it is not in the list of codes, it’s a label, and
    the second token, `sFile[i][1]`, is the instruction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the instruction details. These are stored in a dictionary called `codes`.
    If the mnemonic is in the dictionary, the key returns a tuple with two components.
    The first component is the format of the instruction, which defines the required
    operands in the sequence `rD`, `rS1`, `rS2`, `literal`; for example, the code
    `1001` indicates an instruction with a destination register and a literal. The
    second component of the tuple is the value of the opcode. We use a decimal value
    for this (ideally, it should be binary for the sake of readability, but binary
    values were too long and made the text harder to read).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Read the register numbers from the tokens in the instruction; for example, `ADD`
    `r3`,`r2`,`r7` would return `3`,`2`,`7`, whereas `NOP` would return `0`,`0`,`0`
    (if a register field is not used, it is set to `0`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Read any literal and convert it into a 16-bit integer. This is the most complex
    operation because the literal may have one of the seven different formats described
    previously.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The discussion in this section refers to the TC1 program that is presented in
    full at the end of the chapter. Here, we present slices of that program and explain
    how they work and the steps in the assembly process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extracting the instruction and its parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following fragment of code shows the beginning of the loop that scans the
    source code and creates the binary value. This code initializes variables, extracts
    the opcode as a mnemonic, extracts any labels, extracts the parameters required
    by the mnemonic, and looks up the opcode and its format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Lines 2 and 3 in the loop declare and initialize the variables and provide default
    values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first `if…else` statement on line 4 looks at the first token on line `i`
    of the source code, `sFile[i][0]`. If that token is in the `codes` dictionary,
    then `sFile[i][0]` is the opcode. If it isn’t in the dictionary, then that token
    must be a label and the second token is the opcode (lines 4 and 5):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If we encounter a label, we can convert it into its actual address, which is
    in `symbolTab`, using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Lines 6, 7, 8, and 9 extract the predicate from the assembly language. Remember,
    the predicate comprises the tokens following the mnemonic and consists of any
    registers and literal required by the instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We have to deal with two cases: the first token is the mnemonic and the second
    token is the mnemonic. We also check that the line is long enough to have a predicate.
    If there is a predicate, it is extracted by lines `7` and `9`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The notation `[2:]` indicates *everything from token 2 to the end of the line*.
    This is a very nice feature of Python because it doesn’t require you to explicitly
    state the length of the line. Once we’ve extracted the predicate containing the
    register and literal information, we can start to assemble the instruction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we extract the current line’s code format to get the information required
    from the predicate. Line `10`, form `= codes.get(opCode)`, accesses the `codes`
    dictionary to look for the mnemonic, which is in the `opCode` variable. The `get`
    method is applied to `codes` and the `form` variable receives the key value, which
    is the (`format`,`code`) tuple, for example, (`8`,`10`). The `form[0]` variable
    is the instruction format, and `form[1]` is the opcode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The second element of the tuple, `form[1]`, gives the 7-bit opcode; that is,
    `0100010` for `LDRL`. Lines `10` to `13` demonstrate how the destination register
    is extracted. We first use `AND` `form[0]` with `0b1000` to test the most significant
    bit that indicates whether a destination register, `rD`, is required by this instruction.
    If it is required, we first test whether the register is expressed in the form
    `R0`, or whether it’s given as a name, for example, `TIME`. We have to do this
    because TC1 lets you rename registers by using the `EQU` directive.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can check whether an item is in the dictionary by using `dictionary`. Take
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if `''INC''` in opCodes:'
  prefs: []
  type: TYPE_NORMAL
- en: To obtain information about a particular mnemonic, we can use the `get` method
    to read the value associated with the key `–` for example, `format =` `opCodes.get('INC')`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding example returns `format = (8,82)`. `8` refers to the format code
    `0b1000` (specifying a destination register). `82` is the opcode for this instruction.
    We access the two fields of the value associated with `''INC''` with, for example,
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We first test whether a register has a symbolic name in line `12` with. `if
    predicate[0]` in `symbolTab:` and, if it is in the symbol table, we read its value
    in line `13` with.
  prefs: []
  type: TYPE_NORMAL
- en: '`rD =` `int(symbolTab[predicate[0]][1:])`'
  prefs: []
  type: TYPE_NORMAL
- en: We interrogate the symbol table with a key, which is the first element of the
    predicate since the destination register always comes first in a TC1 assembly
    language instruction (e.g., in `ADD` r4,`r7`,`r2`, register `r4` is the first
    element). The register is given by `predicate[0]`. The `symbolTab`[predicate[0]]
    expression looks up the symbolic name and provides its value; for example, consider
    `TIME EQU R3`. The `INC TIME` assembly language instruction will look up `TIME`
    and return `R3`. We now have the destination operand, but it is a string, `'R3'`,
    and not a number. We just want `3` and have to use the `int` function to convert
    a number in string format into an integer value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s simplify the Python expression to make the explanation easier. Suppose
    we write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`destReg =` `symbolTab`[predicate[0]]'
  prefs: []
  type: TYPE_NORMAL
- en: The value of `destReg` is the string representing the destination register.
    Assume that this is `'R3'`. What we need to do is to isolate `'3'` from `'R3'`
    and then convert the character `'3'` into the integer `3`. We can write `destRegNum
    = destReg[1:]` to return all characters in the string except the initial `'R'`.
    The final step is to convert into an integer, which we can do with `rD =` `int(destRegNum)`.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that `[1:]` means all the characters after the first character, `'R'`.
    Consequently, this returns `'3'` if the register was `'R3'`. We could have written
    `[1:2]` rather than `[1:]` since the number is in the range 1 to 7\. However,
    by using the `[1:]` notation, we can later increase the number of registers beyond
    9 without changing the program.
  prefs: []
  type: TYPE_NORMAL
- en: Putting all three steps together, we get `rD =` `int(symbolTab[predicate[0]][1:])`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following Python code shows the entire decoding process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This block of code performs the same sequence of operations three times, processing
    `rD`, then `rS1` (the first source register), and then `rS2` (the second source
    register) in the same way. The last section of this block of code (shaded)) is
    more complicated because we allow several representations of the literal. We use
    an `if…elif` structure to test for a symbolic literal, a binary literal, a hexadecimal
    literal, an unsigned decimal numeric literal, and finally, a negative decimal
    numeric literal.
  prefs: []
  type: TYPE_NORMAL
- en: The literal is a numeric constant used by an instruction. However, in the assembly
    language, the literal is represented by a text string; that is, if the literal
    is `12`, it is the string `'12'` and not the numeric value `12`. It has to be
    converted into numeric form by the `int()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We initially decided to allow decimal, binary, or hexadecimal integers. Later,
    we included symbolic names because they are so easy to deal with using Python’s
    dictionary. Suppose we have an instruction that has been tokenized into a mnemonic
    and a predicate that contains registers and a literal or symbolic name, for example,
    `[''R1'', ''R2'' , ''myData'']`. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This takes the last element of the predicate (indicated by the `[-1]` index)
    and looks to see whether it’s in the symbol table. If it isn’t, the code tests
    for other types of literal. If it is in the symbol table, it is extracted and
    the `myData` symbolic name is replaced with its actual value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The literal in the table may be an integer or a string. The following converts
    it into a string if it is a literal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `if` construct uses the `type()` function, which returns the type of an
    object. In this case, it will be `'int'` if the object is an integer. The `str()`
    function converts an integer object into a string object.
  prefs: []
  type: TYPE_NORMAL
- en: This action may seem strange because we are converting an integer (which we
    want) into a string (which we don’t want). The reason for this anomaly is that
    we are later going to test for hex, binary, and signed values that will be strings,
    and keeping all literals as strings simplifies the coding.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code demonstrates how three number formats are converted into
    integer form, ready for packing into the final 32-bit TC1 machine instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Binary numbers are prefixed with either `%` or `0b` in the TC1 assembly language,
    and hexadecimal values with `$` or `0x`. The constant is tested to see whether
    it’s decimal, binary, or hex, and then the appropriate conversion is performed.
    Converting a binary string, `x`, into an integer, `y`, is done with `y = int(x,2)`.
    The parameter in bold is the number base. In this case, it’s `2` in binary format.
    In hexadecimal format, it’s 16.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the hex conversion. We have to make two selections: the token
    and then the specific characters of the token. Consider `ADDL R1,R2,0XF2A4`. The
    predicate is `''R1 R2 0XF2A4''`, which is tokenized as `predicate = [''R1'', ''``R2'',
    ''0XF2A4'']`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The value of `predicate[-1]` is `''`0XF2A4`''`. To test for a hexadecimal value,
    we have to look at the first two characters to see whether they are `''0X''`.
    Note `0X` not `0x` because TC1 converts input into uppercase. We could write the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We can save a line by combining the two list-index suffixes, `[-1]` and `[0:2`],
    into `predicate[-1][0:2]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third line of the code, `elif predicate[-1].isnumeric(): literal=int(predicate[-1])`,
    detects decimal strings and converts them into numeric form. Since decimal values
    don’t have a prefix, we use the `isnumeric` method to test for a string that has
    a numeric value. This line is read as, "*If the last token in the predicate is
    numeric, then convert it into an* *integer value*."'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have to deal with negative numbers (e.g., -5). If a literal is prefixed
    with -, the remaining string is read and converted into two’s complement binary
    form in 16 bits. This is necessary because the TC1 computer represents signed
    integers in 16-bit two’s complement form.
  prefs: []
  type: TYPE_NORMAL
- en: 'The generation of the final 32-bit binary code of an instruction is easy. We
    have an opcode and zero to four fields to insert. The fields are initially set
    to all zeros (the default values). Then, each field is shifted left to its required
    place in the instruction and inserted into the instruction by using a bit-wise
    `OR` operation. The code for this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We could do all this in one line, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In the next chapter, we’ll return to the TC1 simulator and expand it. We’ll
    also demonstrate how the TC1 simulator can be extended by adding new operations
    to the instruction set and some ways of printing the results of a simulator.
  prefs: []
  type: TYPE_NORMAL
- en: Before presenting the full TC1, we are going to demonstrate a simplified version
    that can execute an assembly language program, essentially the same as the TC1\.
    However, this version has been designed to reduce the total complexity by leaving
    out features such as symbolic names or the ability to use different number bases
    when specifying a constant. In this case, all literals are simple decimal integers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Intermission: The Pre-TC1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to provide a more complete overview of the operation of a CPU simulator,
    we are going to introduce a highly simplified, but complete, version to give you
    an idea of how things fit together, before we create a more complex system.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you will learn how to design a simulator without some of the
    complications associated with a fully fledged design.
  prefs: []
  type: TYPE_NORMAL
- en: This version of TC1, called TC1mini, can execute assembly language. However,
    we use a fixed format for assembly-level instructions (input is case-sensitive)
    and a fixed literal format (no hexadecimal or binary numbers), and we don’t support
    labels and symbolic names. This approach helps stop the details from getting in
    the way of the bigger picture.
  prefs: []
  type: TYPE_NORMAL
- en: The Simulator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The simulator supports register-to-register operations, such as `ADD r1,r2,r3`.
    Its only memory access is pointer-based, that is, `LDRI r1,[r2]` and `STRI r1,[r2]`.
    It provides increment and decrement instructions, `INC r1` and `INC r2`. There
    are two compare operations: `CMPI r1,5` and `CMP r1,r2` (the former compares a
    register with a literal and the latter compares two registers). To keep things
    simple, the only status flag is `z` (zero) and this is used only by compare and
    subtract operations.'
  prefs: []
  type: TYPE_NORMAL
- en: Three branch instructions are provided (unconditional branch, branch on zero,
    and branch on not zero). Since this simulator doesn’t support symbolic names,
    a branch requires a literal to indicate the destination. Branching is relative
    to the current location of the branch instruction; for example, `BRA 3` means
    jump to the instruction three locations forward, and `BRA -2` means jump two instructions
    backward.
  prefs: []
  type: TYPE_NORMAL
- en: I did not provide a file-based program input mechanism (i.e., reading a source
    program as a text file). The assembly language program to be executed is embedded
    as a Python list of strings called `sFile`. You can readily modify this or substitute
    the code to input a file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The opcodes are set up in a dictionary of the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The `key:value` pair uses a mnemonic as the key and a list with one item, the
    class of the instruction, as the value. The classes range from `0` (a mnemonic
    with no operands) to `7` (a mnemonic with a register and register indirect operand).
    We’ve not implemented TC1’s 4-bit format code, which is used to determine the
    parameters required by an instruction, because that information is implicit in
    the class. Moreover, we do not assemble the instruction into a binary code. We
    read the mnemonic in text form and directly execute it.
  prefs: []
  type: TYPE_NORMAL
- en: When an instruction is read, it is first tokenized to create a list of one to
    four tokens, for example, `['CMPL', 'r3', '5']`. When an instruction is read from
    the source, the class is determined and used to extract the required information
    from the tokens.
  prefs: []
  type: TYPE_NORMAL
- en: Once the mnemonic and register numbers/values and literal are known, a simple
    `if .. elif` structure is used to select the appropriate instruction and then
    execute it. Most instructions are interpreted in a single line of Python.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the instruction reading and execution loop, you are invited to
    hit a key to execute the next instruction in sequence. The data displayed after
    each instruction is the program counter, z-bit, instruction, registers, and memory
    location. We use only four registers and eight memory locations.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have split this program into sections with brief descriptions between them.
    The first part provides the source code as a built-in list. It defines the instruction
    classes and provides a list of opcodes and their classes. We don’t use a dictionary
    for this. However, we do provide dictionaries for the registers and their indirect
    versions to simplify analyzing instructions. For example, we can look up both
    `r1` and `r2` in the `LDRI` `r1,[r2]` instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following section, we analyze an instruction to extract the values of
    the operands required by the instruction. This is achieved by looking at the instruction’s
    op-class and then extracting the appropriate information (e.g., the register number):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the instruction execution part of the program. We use a series of comparisons
    of the mnemonic with the opcodes and then directly execute the instruction. Unlike
    TC1, we do not convert the mnemonic into binary code and then execute it by converting
    the binary code into appropriate operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Note that the execution loop ends with an input request from the keyboard. In
    this way, the next cycle is not executed until the *Enter*/*Return* key is pressed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following shows the output of the simulator as the embedded program is
    executed. Changed registers, memory locations, and flag values are in bold font:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We will now look at the program for the TC1 simulator. We will include a short
    introduction to some of its facilities before providing the code.
  prefs: []
  type: TYPE_NORMAL
- en: The TC1 simulator program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we provide the full code for the TC1 assembler and simulator.
    This will enable you to construct and modify a computer assembler and simulator
    that can execute the code supported by TC1 or your own instruction set (if you
    modify TC1).
  prefs: []
  type: TYPE_NORMAL
- en: The assembler is the more complicated part because it involves reading text,
    analyzing it, and formatting it into binary codes. The simulator itself simply
    reads each binary code and then performs the appropriate action.
  prefs: []
  type: TYPE_NORMAL
- en: The simulator includes features that we haven’t covered yet in previous sections
    (e.g., debugging and trace facilities). In the first draft of this book, TC1 was
    rather more basic with a minimal subset of features. As the book was edited and
    the program modified, the set of features was enhanced to make it a more practical
    tool. We first provide brief notes on some of these features to aid understanding
    of the program.
  prefs: []
  type: TYPE_NORMAL
- en: Single-stepping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A computer executes instructions sequentially unless a branch or subroutine
    call is encountered. When testing a simulator, you frequently want to execute
    a batch of instructions together (i.e., without printing register values), or
    you may wish to execute instructions one at a time by hitting *Enter*/*Return*
    after each instruction has been executed or to execute instructions until you
    hit a specific instruction.
  prefs: []
  type: TYPE_NORMAL
- en: In this version of TC1, you can execute and display an instruction, skip the
    display of the next n instructions, or not display instructions until a change-of-flow
    instruction is encountered. After the program is loaded, the input prompt is displayed.
    If you enter a return, the simulator executes the next instruction and waits.
    If you enter an integer (and return), the specified number of instructions is
    executed without displaying the results. If you enter b followed by a return,
    the simulator executes instructions without displaying them until the next branch
    instruction is encountered.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example. The code is just a set of random instructions
    for demonstration. I’ve used no-operations (`nop`) as a filler. I’ve also tested
    literal address formats (hex and binary) and demonstrated case insensitivity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'I’ve edited it to remove memory locations as they are not accessed. After the
    prompt, `>>>`, you select what is to happen: trace one instruction, execute `n`
    instructions without stopping or displaying registers, or execute code to the
    next branch instruction without displaying it. In each case, the following program
    counter value is highlighted in the following output. The text in bold is a comment
    I left on an action on the current line (trace indicates a *Return*/*Enter* was
    hit, which executes the next instruction):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: File input
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we first started writing a simulator, we inputted test programs the easy
    way by typing the instructions in one by one. This worked for the simplest of
    tests but soon became tedious. Later, programs were input as a text file. That
    worked well when the filename was short, such as `t.txt`, but it got more tedious
    with long filenames (e.g., when I stored the source code in a specific directory).
  prefs: []
  type: TYPE_NORMAL
- en: We then included the filename in the actual TC1 program. That’s convenient when
    you’re going to be running the same program over and over again while you’re testing
    various features of the simulator. What we needed was a means of using my working
    program (baked into the simulator) most of the time, but to switch to an alternative
    when required.
  prefs: []
  type: TYPE_NORMAL
- en: 'One sensible solution would be to generate an input banner prompting you to
    press *Enter* for the default file, or provide a filename for an alternative source
    program, say, *Enter return for the default file* or *Enter a filename for an
    alternative source program*. We decided to use Python’s exception mechanism to
    implement this. In computing, an *exception* (also called a *software interrupt*)
    is a mechanism designed to deal with unexpected events. In Python, the exception
    handler uses two reserved words: `try` and `exception`.'
  prefs: []
  type: TYPE_NORMAL
- en: As their names suggest, `try` requires Python to run the following block of
    code, and `exception` is a block of code that is executed if the `try` block failed.
    Essentially, it means, *“If you can’t do this, do that.”* The difference between
    `if` and `try` is that `if` returns `True` or `False` and performs the specified
    action if `True`, whereas `try` *attempts* to run a block and calls an exception
    if it fails, that is, if it crashes.
  prefs: []
  type: TYPE_NORMAL
- en: '`try` allows you to attempt to open a file and then gives you a way out if
    the file doesn’t exist (i.e., it avoids a fatal error). Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'This code looks for a file called `testException1.txt`. If it’s present (as
    it is in this case), the simulator runs it and we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next case, we’ve deleted `testException1.txt`. We now get the following
    output after the prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The line in bold is the alternative filename.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the TC1 program, I further simplify things by including the file directory
    in the exception (because I always use the same directory) and I include the file
    extension, `.txt`. This looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: This expression automatically provides the path for the filename and address
    of the file type.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that Python lets you use the `+` operator to concatenate strings.
  prefs: []
  type: TYPE_NORMAL
- en: TC1 program
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first part of the program provides a list of instructions and their encoding.
    This text is placed between two `'''` markers that indicate it is not part of
    the program. This avoids having to start each line with `#`. The triple quote
    marks is called a docstring comment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part of TC1 is a listing of the instructions. These are provided
    to make the program easier to follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the `shift` operation is rather complex with left and right shifts,
    variable-length shifts, plus shifts, and rotates, we have provided a function
    to implement shifts. This takes the type of shift, direction, and number of places
    shifted as input parameters, together with the word to be shifted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the function, `getLit`, that processes a literal. It can handle literals
    in a range of possible formats, including decimal, binary, hexadecimal, and symbolic
    form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '`Print` statements can be a little complicated. Consequently, we have created
    a `print` function that is used to display register and memory contents. We discuss
    print formatting elsewhere in this book. We generate the data as strings to be
    printed, `m`, `m1`, and `m2`, and then print them using the appropriate formatting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding block of code provides a debug functionality and is intended
    to demonstrate the concept of debugging and provide a facility to check the assembly
    process by displaying intermediate information during the assembly phase. A variable,
    `debugLevel`, is read from the keyboard at the start of the program. This determines
    the level of the debugging facility from 1 (none) to 5 (maximum). Debugging information
    can include the source code, decoded operations, and other parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The following section is responsible for reading the source file to be assembled
    and executed. This source code should be in the form of a `.txt` file. Note that
    this code uses Python’s `try` and `except` mechanism, which is able to perform
    an action (in this case, try and load a file from disk) and, if the action fails,
    perform a new action instead. Here, we use it to test for a default filename and
    then get one from the terminal if that file does not exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'This short section deals with the equate assembler directive and binds values
    to symbolic names using the `EQU` directive. These bindings are placed in the
    `symbol table` dictionary and the equates are removed from the source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we perform the instruction decoding; that is, we analyze the text of
    each instruction to extract the opcode and parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'This section was added after the development of TC1\. We introduce the concept
    of a debug level. That is, at the beginning of a simulation run, you can set a
    parameter in the range of `1` to `3` that determines how much information is displayed
    during the assembly processing. This allows you to get more information about
    the instruction encoding when testing the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'We are about to execute the instructions. Before we do that, it is necessary
    to initialize several variables concerning the current operation (e.g., tracing):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the main loop where we decode instructions to extract the parameters
    (register numbers and the literal):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next section, we depart from the original version of TC1\. The first
    version of TC1 decoded the opcode as a binary string and then looked it up. However,
    as we have the source file, it is easier to go directly from the text of the mnemonic
    and execute it. This makes the code so much easier to read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'This section performs a function called tracing and allows us to list the contents
    of the register or turn off the listing as we execute the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve explained the TC1 simulator, we’ll demonstrate its use.
  prefs: []
  type: TYPE_NORMAL
- en: Example of a TC1 assembly language program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here, we demonstrate a TC1 program in assembly language. This offers a means
    of testing the simulator and showing how it works. We would like to test a range
    of facilities, so we should include looping, conditional testing, and pointer-based
    memory access. We will write a program to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Fill a region of memory from locations 0 to 4 with random numbers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reverse the order of the numbers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Since this problem uses memory and sequential addresses, it involves register
    indirect addressing, that is, `LDRI` and `STRI` instructions. Creating the random
    numbers and storing them sequentially in memory can be done by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'In TC1 code, we can translate this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ve filled a region of memory with random values. We now need to reverse
    their order. There are many ways of reversing the order of numbers. One is to
    move the numbers from the source to a temporary location in memory and then write
    them back in reverse order. Of course, this takes up extra memory for the temporary
    copy. Consider another solution that does not require a buffer. We will write
    down the source addresses above the destination addresses:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Original (source)        0   1   2   3   4`'
  prefs: []
  type: TYPE_NORMAL
- en: '`Swapped (destination)    4   3   2   1   0`'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, location `0` is swapped with location `4`, then location `1`
    with location `3`; then, at location `2`, we have reached the middle point and
    the reversal is complete. To perform this action, we need two pointers, one for
    each end of the string. We select the two characters at the ends of the string
    and swap them. Then, we move the pointers inward and do a second swap. The task
    is complete when the pointers meet in the middle. Note that this assumes an odd
    number of items to reverse:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'In TC1 assembly language, this looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The following shows the output when this program is executed, instruction by
    instruction. In order to simplify the reading of this data, we’ve put changes
    in register and memory values in bold. The branch operations are shaded. Comparison
    instructions are in italics.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first block is the source code printed by TC1 before the start of the instruction
    execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The second code block shows the output of the assembler as instructions are
    decoded. You can see the various registers, the literal, and the format field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: The following provides the output of a run using this program. We’ve set the
    trace level to `4` to show the source code (after text processing), the symbol
    table, and the decoded instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we’ve executed the code line by line. In order to make the output more
    readable and to fit it on the page, we’ve removed registers and memory locations
    that don’t change, and we’ve highlighted values (memory, registers, and z-flag)
    that change as the result of an instruction. You can follow this through and see
    how memory/registers change with each instruction.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, we create five random numbers in memory locations `0` to `4`
    and then reverse their order. This does not match the output of the print status
    because it’s been modified for printing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next section, we demonstrate how you might go about testing the operation
    of TC1\. We cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Testing the assembler (e.g., the ability to use a free format of code)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing flow control instructions (branches)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing shift operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing the assembler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since the TC1 assembler can deal with several typographic features (e.g., uppercase
    or lowercase and multiple spaces), a simple way of testing the assembler is to
    give it a file to assemble that includes various conditions, such as multiple
    spaces, equates, and uppercase and lowercase conversion. My initial test source
    code was as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'This is not exactly stylish code; it’s just random test code. In the following
    code, we provide the output of the assembler when operated in `debug` mode. This
    includes the formatting of the code (removal of blank lines and lowercase to uppercase
    conversion). The first listing provides the instructions as an array of lists
    of tokens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The second listing is the symbol table that ties symbol names and labels to
    integer values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The next listing was used largely for debugging when an instruction didn’t
    behave as intended. It lets you determine whether an instruction has been correctly
    decoded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Testing flow control operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here, we demonstrate how to test the computer’s most important class of operations,
    the flow-control instruction, that is, the conditional branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the most important classes of instructions to test are those that change
    the flow of control: the branch and subroutine call instructions. The following
    fragment of code is also meaningless (it serves only to test instruction execution)
    and is designed only to test loops. One loop is built using a branch on a not-zero
    operation, and the other uses an automatic loop mechanism that operates by decrementing
    a register and branching until the register decrements to zero. The `DBNE` `r0`,`loop`,
    where `r0` is the counter being decremented and `loop` is the branch target address.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We first provide the source listing and symbol table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'The following provides the output after a debugging session. As you can see,
    the sequence of branches is faithfully implemented. Note that we’ve highlighted
    the branch actions and consequences (i.e., the next instruction):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: In the next chapter, we will look at some of the ways in which the TC1 program
    can be enhanced to add facilities such as error checking, the inclusion of new
    instructions, and special features such as variable-length operand fields.
  prefs: []
  type: TYPE_NORMAL
- en: Testing shift operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'TC1 supports two shift types: *logical* and *rotate*. A logical shift moves
    the bits left or right. At one end, vacated bits are replaced by zeros and, at
    the other end, the bit shifted out is copied to the carry flag. In a rotation,
    the bit that is shifted out of one end is copied to the other end; that is, the
    string of bits is treated as a ring. No bit is lost, no matter how many shifts
    take place. At each bit shift, the bit that was shifted to the other end is also
    copied to the carry bit.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Most real computers have two other shift variations: an arithmetic shift that
    preserves the sign of two’s complement numbers when shifted right (divide-by-2
    operation) and a rotate-through-carry shift where the bit shifted in at one end
    is the old carry bit and the bit shifted out becomes the new carry bit. Essentially,
    if the register has `m` bits, the carry bit is included to create an `m+1` bit
    word. This feature is used for multi-precision arithmetic. We haven’t included
    these modes in TC1.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As well as specifying the shift type, we have to specify the shift direction
    (left or right). Most computers let you specify the number of shifts. We provide
    both facilities and the number of shifts can be specified using either a register
    or a literal. In a multi-length shift, the state of the carry bit is the last
    bit shifted out into the carry. The shift operations (with examples) are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Shift Type** | **Register/Literal** | **Example** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Logical shift left | literal | `LSLL r0,r1,2` |'
  prefs: []
  type: TYPE_TB
- en: '| Logical shift left | register | `LSL r3,r1,r4` |'
  prefs: []
  type: TYPE_TB
- en: '| Logical shift right | literal | `LSRL r0,r1,2` |'
  prefs: []
  type: TYPE_TB
- en: '| Logical shift right | register | `LSR r3,r1,r2` |'
  prefs: []
  type: TYPE_TB
- en: '| Rotate left | literal | `ROLL r0,r1,2` |'
  prefs: []
  type: TYPE_TB
- en: '| Rotate left | register | `ROL` `r3,r1,r0` |'
  prefs: []
  type: TYPE_TB
- en: '| Rotate right | literal | `RORL r0,r3,2` |'
  prefs: []
  type: TYPE_TB
- en: '| Rotate right | register | `ROR` `r3,r1,r0` |'
  prefs: []
  type: TYPE_TB
- en: Table 6.1 – TC1 shifting modes
  prefs: []
  type: TYPE_NORMAL
- en: When we test these instructions, we have to ensure that the shift direction
    is correct, the right number of shifts take place, the end bits (those shifted
    out or in) behave correctly, and the flag bits are set appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following fragment of code using the 16-bit value `1000000110000001`
    in a series of shifts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'The following output from the simulator (edited to show only relevant information)
    gives the registers and condition codes as the preceding code is executed. The
    binary value of register `r0` is displayed on the right. This allows us to verify
    whether the operations have been executed correctly by manual inspection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Note that a load operation does not affect the z-bit. Some computers update
    the z-bit after almost every operation. Some update the z-bit on demand (e.g.,
    ARM, which we will introduce later), and some update it only after certain operations.
  prefs: []
  type: TYPE_NORMAL
- en: The penultimate section of this chapter covers adding a postscript to TC1 where
    we provide a simpler example that performs the same basic function but carries
    out some operations in a different way, such as instruction decoding. The purpose
    of this is to demonstrate that there are many ways of constructing a simulator.
  prefs: []
  type: TYPE_NORMAL
- en: TC1 postscript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The version of TC1 presented here grew during the development of this book.
    The current version has more features than the prototype; for example, initially,
    it didn’t include symbolic branch addresses and required users to enter actual
    line numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we’re presenting a cut-down version of TC1, called TC1mini, where we do
    some things differently; for example, by not allowing a free format (mnemonics
    must be uppercase and registers lowercase, and you can’t use spaces and commas
    as interchangeable delimiters). In this version, a simple function checks that
    the mnemonic is valid and terminates the program if it isn’t. Similarly, we’ve
    added a feature that checks whether an address generated by a pointer lies within
    the bounds of your memory space. The following section provides some comments
    on this version.
  prefs: []
  type: TYPE_NORMAL
- en: The classDecode function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TC1 associates a 4-bit binary value with each instruction to indicate that parameters
    are required by the current instruction; for example, `1101` indicates registers
    `rD`, `rS1`, and a literal. The TC1mini version associates a *class number* in
    the range `0` to `7`, with each instruction that describes its type. The classes
    range from `0` (mnemonic with no parameters) to `7` (mnemonic with an indirect
    address, such as `LDRI r2,[r4])`. Unlike TC1, the `[ ]` brackets are not optional
    in TC1mini's assembly language.
  prefs: []
  type: TYPE_NORMAL
- en: The difference between the two simulators, TC1 and TC1mini, is that the 4-bit
    binary code provides *pre-decoding*; that is, the simulator doesn’t have to calculate
    what parameters the instruction requires because the code directly tells you that.
    If you use a class number instead, you have to decode the class number to determine
    the actual parameters required. However, a class number can be very creative.
    TC1mini uses seven different instruction formats and requires a minimum of seven
    classes to be defined. If you had, say, 14 classes, each addressing mode class
    could be divided into two subclasses to give you greater control over the instruction
    execution process.
  prefs: []
  type: TYPE_NORMAL
- en: The `classDecode` function takes in an instruction’s predicate and returns the
    four predicate values, the destination register, source register `1`, source register
    `2`, and the literal. Of course, instructions may have from zero to four of these
    values. Consequently, these parameters are initially set to dummy values, either
    a `null` string or zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before continuing, recall that Python’s `in` operator is useful for testing
    whether an element is a member of a set. For example, if an operation is in classes
    2, 4, 5, and 9, we can write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: The current instruction’s `opClass` is used to extract the parameters. Instead
    of using `if` constructs, we’ve used Python’s `if in [list]` construct; for example,
    `if opClass in [3,4,5,6,7]` returns `True` if the instruction is in classes `3`
    to `7`. If it is, the predicate (a string) is divided into a list using the `split()`
    function, and the first element is read to extract the destination register, `rD`.
    Note that we need to split the predicate only once, because all the following
    cases also fall within this group.
  prefs: []
  type: TYPE_NORMAL
- en: The testLine function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another limitation of TC1 is the lack of testing and validation; for example,
    I sometimes type `MOVE` instead of `MOV` and the program crashes. Normally, this
    isn’t a problem; you just re-edit the source program. However, when debugging
    TC1, I often assumed an error was due to a mistake in my new code, only to discover
    that it was simply a misprint in the assembly language program. So, I added a
    small amount of testing. The following provides the testing function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'The only line of interest is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two cases to consider: instructions with a label and those without
    a label. In the former case, the mnemonic is the second token in the instruction,
    and in the latter case, the mnemonic is the first token. We can test whether a
    token is a mnemonic by using Python’s `if ... in` construct. Say we have the following
    construct:'
  prefs: []
  type: TYPE_NORMAL
- en: '`if token[0]` `in codes`'
  prefs: []
  type: TYPE_NORMAL
- en: This returns `True` if the first token is a valid mnemonic. We can combine the
    two tests with an `or` Boolean to get the preceding expression. In the program,
    we call `testLine` with the `tokens` parameter and it returns an error. We use
    the error to print a message and return it to the operating system with the `sys.exit()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: The testIndex() function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This simulator provides an instruction in the form `LDRI r1,[r2]` to provide
    memory indirect addressing (i.e., pointer-based or indexed addressing).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, register `r1` is loaded with the contents of memory pointed at
    by register `r2`. If the pointer register contains an invalid value that is outside
    the range of legal addresses, the program will crash. By testing the index, we
    can ensure that an out-of-range index is detected. Note that only the first source
    register, `rS1`, is ever used as a memory pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: General comments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following line demonstrates how we extract the operation class from the
    mnemonic. The expression looks strange because of the `()` and `[]` parentheses.
    The `codes.get(key)` operation uses `key` to get the associated value from the
    `codes` dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the key is the mnemonic, and the value returned is the operation
    class; for example, if the mnemonic is `'LDRL'`, the corresponding value is `[3]`.
    Note that the value returned is not `3`! It is a *list* with the single value
    `3`. Consequently, we have to extract the value from the list by specifying the
    first item, that is, `mnemonic[0]`.
  prefs: []
  type: TYPE_NORMAL
- en: There are many ways to build an instruction. In TC1, we create a binary value,
    just like a real assembler. In TC1mini, we directly execute the instruction from
    the assembly language form. So, when we compile the instructions, we create a
    program in text form. To do that, we need to combine the label, mnemonic, registers,
    and literal into a list.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code to do that is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we use the `list()` function to combine items into a list,
    and then we use `append()` to add this item to an existing list. Note the syntax
    of `list()`. You might expect it to be `list(a,b,c)`. No. It’s `list((a,b,c))`.
    The `list()` function uses parentheses as normal but the list itself must be in
    parentheses. That’s because the list items constitute a *single* parameter to
    list.
  prefs: []
  type: TYPE_NORMAL
- en: The TC1tiny code listing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is the listing of the cut-down version of TC1\. Instructions fall into
    eight classes depending on the number and arrangements of operands. Each instruction
    is in a dictionary, `codes`, which provides the class number that is used to decode
    operands. The instruction itself is executed directly from its mnemonic. Unlike
    TC1, there is no intermediate binary code. Similarly, both register names and
    indirect register names are in dictionaries to simplify instruction decoding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'This section deals with decoding instructions into the appropriate task in
    order to correctly execute them with the appropriate parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike TC1, we perform a little testing on the input, for example, whether
    the memory or register index is out of range. This is simply an illustrative example
    of data validation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the actual instruction execution loop. As you can see, it
    is remarkably compact:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: The code execution loop, like most of the simulators we discuss, is remarkably
    straightforward. The current instruction is fetched and decoded into mnemonic,
    class, and register numbers. The program counter is advanced and the mnemonic
    is presented to a series of `then...elif` statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many of the instructions are executed in only one line of code; for example,
    `ADD` is implemented by adding two registers together: `r[rD] = r[rS1] + r[rS2]`.
    Some instructions, such as `compare`, require two registers to be subtracted and
    then the status bits to be set accordingly.'
  prefs: []
  type: TYPE_NORMAL
- en: We included one relatively complex instruction, decrement and branch on not
    zero, which decrements a register and then branches to a target address if the
    register has not counted down to `0`.
  prefs: []
  type: TYPE_NORMAL
- en: In the final section, we will look at yet another variation of TC1.
  prefs: []
  type: TYPE_NORMAL
- en: TC1 postscript mark II
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If one postscript is good, two are even better. We’ve added this second variation
    on a theme to demonstrate some different ways of doing things. Much of the program’s
    structure is the same as before. The features are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Direct execution (revisited)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to avoid different mnemonics (e.g., `ADD` and `ADDL`) for the same
    basic operation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The principal enhancement is the way to handle instructions and decode them.
    In TC1, we use a 4-bit code to define the structure of each instruction in terms
    of its parameters. When a mnemonic is looked up in the dictionary, it returns
    a code giving the required parameters.
  prefs: []
  type: TYPE_NORMAL
- en: One feature (problem?) with TC1 is that we have different mnemonics for variations
    on an instruction, for example, `ADD` and `ADDL`. The suffix `L` tells the assembler
    that a literal operand (rather than a register number) is required. In this example,
    we avoid different instruction formats and use a single mnemonic by putting instructions
    into classes. Each class defines an instruction format, ranging from class `0`
    (instruction with no parameters) to class `9` (instruction with *four* registers).
  prefs: []
  type: TYPE_NORMAL
- en: This example uses the direct execution of an instruction. That is, we don’t
    compile an instruction into binary and then execute the binary. We execute an
    instruction directly from its mnemonic.
  prefs: []
  type: TYPE_NORMAL
- en: A consequence of this arrangement is that an instruction may fall into multiple
    classes; for example, `LDR` is in *three* classes, rather than having the `LDR`,
    `LDRL`, and `LDRI` variants. When an instruction is encountered, it is checked
    against each class. If the mnemonic is in a class, the attributes of the instruction
    are checked before deciding whether we’ve found the correct class.
  prefs: []
  type: TYPE_NORMAL
- en: Consider `ADD`. We can write `ADD r1,r2,5` or `ADD r1,r2,r3`; that is, the second
    number added to a register may be a literal or a register. Consequently, `ADD`
    is in class `5` and class `6`. To resolve the ambiguity, we look at the final
    operand; if it’s a literal, then it’s class `5`, and if it’s a register, it’s
    class `6`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Testing for a register is easy because we’ve put registers in a dictionary,
    so it’s necessary only to check whether the final operand is in the dictionary
    or not. Consider class `3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Here, we do a triple test. First, we check whether the mnemonic is in class
    `3`. Then, we test the predicate length (it’s `2` for two operands, such as `CMP
    r1,5`). Finally, we test for a numeric second operand by ensuring that the operand
    is not in the list of registers.
  prefs: []
  type: TYPE_NORMAL
- en: The Python program for this experiment is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'In this simulator, we deal with instructions by class rather than by mnemonic.
    This feature means that the same mnemonic can have different addressing modes,
    such as literal, register, or even memory. The first class, `0`, is reserved for
    mnemonics with no operands, such as `NOP`. Of course, this mechanism would make
    it possible to invent a new operation, such as, say, `NOP 4`, that acts in a different
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of the previous program is to demonstrate another way of categorizing
    instructions and using the number of operands to distinguish between instruction
    types, such as `ADD r1,r2` and `ADD r1,r2,r3`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we presented the TC1 simulator, which can take a text file
    in TC1 assembly language, convert it into machine code, and then execute it. TC1’s
    instruction set architecture is close to the classic RISC architecture with a
    register-to-register architecture (i.e., data operations take place on the contents
    of registers). The only memory operations permitted are loading a register from
    memory (or a literal) and storing a register in memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simulator has two basic components: an assembler that translates a mnemonic
    such as `ADD r1,r2,r3` into a 32-bit binary instruction, and an interpreter that
    reads the instruction, extracts the necessary information, and then executes the
    instruction.'
  prefs: []
  type: TYPE_NORMAL
- en: Some of the elements of TC1 are rather unusual. A free-format structure for
    the source code is provided; for example, you can write `ADD r1,r2,r3` or `adD
    R1 r2 r3` and both instructions will be happily accepted. Why? First, it was done
    to demonstrate the use of string processing in Python. Second, it makes it easier
    for the user to enter input in their chosen case. All input is automatically converted
    into uppercase to make the language case-free. Similarly, a comma or space is
    allowed as a separator between parameters. Finally, the need for `[]` brackets
    to indicate indirect addressing was removed. Users may enter `LDRI r0,[r1]` or
    `LDRI r0,r1`.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, numbers can be entered in different forms (decimal, binary, or hexadecimal);
    for example, number bases can be indicated in *Motorola format* or *Python format*.
    Most real assemblers don’t permit such luxury.
  prefs: []
  type: TYPE_NORMAL
- en: The first versions of TC1 required all addresses to be numeric; if you wanted
    to branch to line `30`, you had to write `BRA 30`. It was the remarkable power
    and ease of use of Python’s dictionary structure that made it so easy to include
    labels. All you have to do is recognize a label, pop it in the dictionary together
    with its value, and then, whenever you encounter that label, just look up its
    value in the dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: We also provided an example assembly language program to test TC1 and a short
    discussion of how we go about testing various instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Having designed TC1, we created a rather simplified version and called it TC1mini.
    This simulator does not provide the same flexibility in writing instructions,
    and it does not have a large instruction set. It also does not encode the instruction
    into a binary form and then decode it again and execute it. It executes the assembly
    instruction directly (thanks one more to Python’s dictionary mechanism).
  prefs: []
  type: TYPE_NORMAL
- en: At the end of this chapter, we provided yet another simplified computer simulator
    to both emphasize the structure of a computer simulator and provide an example
    of the way in which you can modify the basic design.
  prefs: []
  type: TYPE_NORMAL
- en: In this key chapter, we introduced the TC1 computer simulator and presented
    its design. We also looked at variations of TC1 to help create a more complete
    picture of the simulator and assembler. In the next chapter, we will take things
    a step further and look at some more aspects of the simulator. We will describe
    several simulators that have different architectures.
  prefs: []
  type: TYPE_NORMAL
