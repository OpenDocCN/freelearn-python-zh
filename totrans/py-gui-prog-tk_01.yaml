- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Introduction to Tkinter
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Tkinter 简介
- en: Welcome, Python coder! If you've learned the basics of Python and want to start
    designing powerful GUI applications, this book is for you.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到 Python 程序员！如果你已经学会了 Python 的基础知识，并想开始设计强大的 GUI 应用程序，这本书就是为你准备的。
- en: By now, you have no doubt experienced the power and simplicity of Python. Perhaps
    you've written web services, performed data analysis, or administered servers.
    Perhaps you've written a game, automated routine tasks, or simply played around
    with code. But now you're ready to tackle the GUI.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你无疑已经体验到了 Python 的强大和简单。也许你编写过网络服务、执行过数据分析或管理过服务器。也许你编写过一款游戏、自动化常规任务，或者只是简单地玩弄代码。但现在你准备好处理
    GUI 了。
- en: With so much emphasis on web, mobile, and server-side programming, the development
    of simple desktop GUI applications seems increasingly like a lost art; many otherwise
    experienced developers have never learned to create one. What a tragedy! Desktop
    computers still play a vital role in work and home computing, and the ability
    to build simple, functional applications for this ubiquitous platform should be
    a part of every software developer's toolbox. Fortunately, for Python coders,
    that ability is well within reach thanks to Tkinter.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在对网络、移动和服务器端编程如此重视的今天，简单桌面 GUI 应用程序的开发似乎越来越像一门失传的艺术；许多经验丰富的开发者从未学会如何创建这样的应用程序。多么遗憾啊！桌面计算机在工作和家庭计算中仍然扮演着至关重要的角色，为这个无处不在的平台构建简单、功能性的应用程序应该是每个软件开发人员工具箱的一部分。幸运的是，对于
    Python 程序员来说，这种能力通过 Tkinter 轻而易举地就能实现。
- en: 'In this chapter, you will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将涵盖以下主题：
- en: In *Introducing Tkinter and Tk*, you'll learn about Tkinter, a fast, fun, easy-to-learn
    GUI library built in to the Python Standard Library; and IDLE, an editor and development
    environment written in Tkinter.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *Introducing Tkinter and Tk* 中，你将了解 Tkinter，这是一个内置在 Python 标准库中的快速、有趣、易于学习的
    GUI 库；以及 IDLE，这是一个用 Tkinter 编写的编辑器和开发环境。
- en: In *An overview of basic Tkinter*, you'll learn the basics of Tkinter with a
    "Hello World" program and create a Survey application.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *An overview of basic Tkinter* 中，你将通过一个 "Hello World" 程序学习 Tkinter 的基础知识，并创建一个调查应用程序。
- en: Introducing Tkinter and Tk
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Tkinter 和 Tk 介绍
- en: The Tk widget library originates from the **Tool Command Language** (**Tcl**)
    programming language. Tcl and Tk were created by John Ousterhout while he was
    a professor at Berkeley in the late 1980s as an easier way to program the engineering
    tools being used at the university. Because of its speed and relative simplicity,
    Tcl/Tk rapidly grew in popularity among academic, engineering, and Unix programmers.
    Much like Python itself, Tcl/Tk originated on the Unix platform and only later
    migrated to macOS and Windows. Tk's practical intent and Unix roots still inform
    its design today, and its simplicity compared to other toolkits is still a major
    strength.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Tk 窗口部件库起源于 **工具命令语言**（**Tcl**）编程语言。Tcl 和 Tk 是由 John Ousterhout 在 1980 年代后期在伯克利大学担任教授时创建的，作为一种更简单的编程大学正在使用的工程工具的方法。由于其速度和相对简单性，Tcl/Tk
    在学术、工程和 Unix 程序员中迅速流行起来。与 Python 本身一样，Tcl/Tk 最初起源于 Unix 平台，后来才迁移到 macOS 和 Windows。Tk
    的实用意图和 Unix 根仍然影响着其设计，与其它工具包相比，其简单性仍然是一个主要优势。
- en: '**Tkinter** is a Python interface to the Tk GUI library and has been a part
    of the Python standard library since 1994 with the release of Python version 1.1,
    making it the *de-facto* GUI library for Python. Documentation for Tkinter, along
    with links for further study, can be found in the standard library documentation
    at [https://docs.python.org/3/library/tkinter.html](https://docs.python.org/3/library/tkinter.html).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**Tkinter** 是 Python 对 Tk GUI 库的接口，自 1994 年 Python 版本 1.1 发布以来一直是 Python 标准库的一部分，使其成为
    Python 的 *事实上的* GUI 库。Tkinter 的文档以及进一步学习的链接可以在标准库文档中找到：[https://docs.python.org/3/library/tkinter.html](https://docs.python.org/3/library/tkinter.html)。'
- en: Choosing Tkinter
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择 Tkinter
- en: 'Python coders who want to build a GUI have several toolkit options to choose
    from; unfortunately, Tkinter is often maligned or ignored as a legacy option.
    To be fair, it''s not a glamorous technology that you can describe in trendy buzzwords
    and glowing hype. However, Tkinter is not only adequate for a wide variety of
    applications but also has some advantages that can''t be ignored:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 想要构建图形用户界面的 Python 程序员有多个工具包选项可供选择；不幸的是，Tkinter 经常被贬低或忽视，被视为一个过时的选项。公平地说，它并不是一种可以用时髦的词汇和夸大的宣传来描述的技术。然而，Tkinter
    不仅适用于各种应用，而且还有一些不容忽视的优点：
- en: '**Tkinter is in the standard library**: With few exceptions, Tkinter is available
    wherever Python is available. There is no need to install pip, create virtual
    environments, compile binaries, or search the web for installation packages. For
    simple projects that need to be done quickly, this is a clear advantage.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Tkinter在标准库中**：除少数例外，Tkinter在Python可用的任何地方都可用。无需安装pip、创建虚拟环境、编译二进制文件或在网上搜索安装包。对于需要快速完成的项目，这是一个明显的优势。'
- en: '**Tkinter is stable**: While Tkinter development has not stopped, it is slow
    and evolutionary. The API has been stable for years, the changes mainly being
    additional functionality and bug fixes. Your Tkinter code will likely run unaltered
    for years or decades to come.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Tkinter是稳定的**：虽然Tkinter的开发没有停止，但它的发展缓慢且渐进。API已经稳定多年，变化主要在于新增功能和错误修复。您的Tkinter代码在未来几年或几十年内可能无需修改即可运行。'
- en: '**Tkinter is only a GUI toolkit**: Unlike some other GUI libraries, Tkinter
    doesn''t have its own threading library, network stack, or filesystem API. It
    relies on regular Python libraries for such things, so it''s perfect for applying
    a GUI to existing Python code.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Tkinter只是一个GUI工具包**：与其他一些GUI库不同，Tkinter没有自己的线程库、网络堆栈或文件系统API。它依赖于常规Python库来处理这些事情，因此它非常适合将GUI应用于现有的Python代码。'
- en: '**Tkinter is simple and no-nonsense**: Tkinter is very basic and to-the-point;
    it can be used effectively in both procedural and object-oriented GUI designs.
    To use Tkinter, you don''t have to learn hundreds of widget classes, a markup
    or templating language, a new programming paradigm, client-server technologies,
    or a different programming language.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Tkinter简单且直接了当**：Tkinter非常基础且直接；它可以在过程式和面向对象的GUI设计中有效使用。要使用Tkinter，您不需要学习数百个小部件类、标记或模板语言、新的编程范式、客户端-服务器技术或不同的编程语言。'
- en: 'Tkinter is not perfect, of course. It also has some disadvantages:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，Tkinter并不完美，它也有一些缺点：
- en: '**Tkinter''s default look and feel is dated**: Tkinter''s default appearance
    has long lagged behind current trends, and it still bears a few artifacts from
    the 1990s Unix world. While it lacks niceties like animated widgets, gradients,
    or scalable graphics, it has nevertheless improved a great deal in the last few
    years, thanks to updates in Tk itself and the addition of themed widget libraries.
    We''ll learn how to fix or avoid some of Tkinter''s more archaic defaults throughout
    the book.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Tkinter的默认外观和感觉过时了**：Tkinter的默认外观已经落后于当前趋势，它还保留了一些来自20世纪90年代Unix世界的遗迹。虽然它缺少动画小部件、渐变或可缩放图形等细节，但得益于Tk本身的更新和主题小部件库的添加，它在过去几年里已经取得了很大的进步。本书将教会我们如何修复或避免Tkinter的一些更古老的默认设置。'
- en: '**Tkinter lacks more complex widgets**: Tkinter is missing advanced widgets
    like rich text editors, 3D graphics embedding, HTML viewers, or specialized input
    widgets. As we''ll see later in this book, Tkinter gives us the ability to create
    complex widgets by customizing and combining its simple ones.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Tkinter缺少更复杂的小部件**：Tkinter缺少像富文本编辑器、3D图形嵌入、HTML查看器或专用输入小部件等高级小部件。正如我们将在本书后面看到的那样，Tkinter通过自定义和组合其简单的小部件，使我们能够创建复杂的小部件。'
- en: Tkinter might be the wrong choice for a game UI or slick commercial application;
    however, for data-driven applications, simple utilities, configuration dialogs,
    and other business logic applications, Tkinter offers all that is needed and more.
    In this book we're going to be working through the development of data entry application
    for a workplace environment, something that Tkinter can handle admirably.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter可能不适合游戏UI或光滑的商业应用程序；然而，对于数据驱动应用程序、简单实用程序、配置对话框和其他业务逻辑应用程序，Tkinter提供了所需的一切，甚至更多。在这本书中，我们将通过开发一个工作环境中的数据输入应用程序来开展工作，Tkinter可以出色地处理这项任务。
- en: Installing Tkinter
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Tkinter
- en: Tkinter is included in the Python standard library for the Windows and macOS
    distributions. So, if you have installed Python on these platforms using the official
    installers, you don't need to do anything to install Tkinter.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter包含在Windows和macOS的Python标准库中。因此，如果您使用官方安装程序在这些平台上安装了Python，您不需要做任何事情来安装Tkinter。
- en: However, we're going to be exclusively focused on Python 3.9 for this book;
    so, you need to make sure that you have this version or later installed.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们将在这本书中专门关注Python 3.9；因此，您需要确保您已安装此版本或更高版本。
- en: Installing Python 3.9 on Windows
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Windows上安装Python 3.9
- en: 'You can obtain Python 3 installers for Windows from the [python.org](http://python.org)
    website by performing the following steps:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过以下步骤从 [python.org](http://python.org) 网站获取 Windows 的 Python 3 安装程序：
- en: Go to [https://www.python.org/downloads/windows](https://www.python.org/downloads/windows/).
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 [https://www.python.org/downloads/windows](https://www.python.org/downloads/windows/)。
- en: Select the latest Python 3 release. At the time of writing, the latest version
    is 3.9.2.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择最新的 Python 3 版本。在撰写本文时，最新版本是 3.9.2。
- en: Under the **Files** section, select the Windows executable installer appropriate
    to your system's architecture (x86 for 32-bit Windows, x86-64 for 64-bit Windows;
    if you're unsure, x86 will work on either).
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **文件** 部分下，选择适合您系统架构的 Windows 可执行安装程序（x86 用于 32 位 Windows，x86-64 用于 64 位 Windows；如果您不确定，x86
    适用于任何一种）。
- en: Launch the downloaded installer.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动下载的安装程序。
- en: Click on **Customize installation**. Make sure the **tcl/tk and IDLE** option
    is checked (it should be by default).
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **自定义安装**。确保已选中 **tcl/tk 和 IDLE** 选项（默认情况下应该已选中）。
- en: Continue through the installer with all defaults.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用所有默认选项继续安装向导。
- en: Installing Python 3 on macOS
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 macOS 上安装 Python 3
- en: As of this writing, macOS ships with Python 2.7 built in. However, Python 2
    was officially deprecated in 2020, and the code in this book will not work with
    it, so macOS users will need to install Python 3 to follow this book.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 到本文撰写时，macOS 内置了 Python 2.7。然而，Python 2 于 2020 年正式弃用，本书中的代码将无法与它兼容，因此 macOS
    用户需要安装 Python 3 才能遵循本书。
- en: 'Follow this procedure to install Python3 on macOS:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤在 macOS 上安装 Python3：
- en: Go to [https://www.python.org/downloads/mac-osx/](https://www.python.org/downloads/mac-osx/).
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 [https://www.python.org/downloads/mac-osx/](https://www.python.org/downloads/mac-osx/)。
- en: Select the latest Python 3 release. At the time of writing, the latest version
    is 3.9.2.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择最新的 Python 3 版本。在撰写本文时，最新版本是 3.9.2。
- en: Under the **Files** section, select and download the macOS 64-bit/32-bit installer.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **文件** 部分下，选择并下载 macOS 64 位/32 位安装程序。
- en: Launch the `.pkg` file that you've downloaded and follow the steps of the install
    wizard, selecting defaults.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动您下载的 `.pkg` 文件，并按照安装向导的步骤操作，选择默认选项。
- en: Installing Python 3 and Tkinter on Linux
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Linux 上安装 Python 3 和 Tkinter
- en: 'Most Linux distributions include both Python 2 and Python 3; however, Tkinter
    is not always bundled with it or installed by default. To find out if Tkinter
    is installed, open a Terminal and try the following command:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 Linux 发行版都包含 Python 2 和 Python 3；然而，Tkinter 并非总是与它捆绑在一起或默认安装。要找出 Tkinter
    是否已安装，打开终端并尝试以下命令：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This should open a simple window showing some information about Tkinter. If
    you get `ModuleNotFoundError` instead, you will need to use your package manager
    to install your distribution's Tkinter package for Python 3\. In most major distributions,
    including Debian, Ubuntu, Fedora, and openSUSE, this package is called `python3-tk`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会打开一个简单的窗口，显示有关 Tkinter 的信息。如果您收到 `ModuleNotFoundError` 错误，您需要使用您的包管理器安装您发行版的
    Python 3 Tkinter 包。在大多数主要发行版中，包括 Debian、Ubuntu、Fedora 和 openSUSE，此包称为 `python3-tk`。
- en: Introducing IDLE
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍 IDLE
- en: '**IDLE** is an integrated development environment that is bundled with the
    official Python software distributions for Windows and macOS (it''s readily available
    in most Linux distributions as well, usually as `idle` or `idle3`).'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**IDLE** 是一个集成开发环境，它包含在官方 Python 软件发行版中，适用于 Windows 和 macOS（在大多数 Linux 发行版中也可以轻松获得，通常作为
    `idle` 或 `idle3`）。'
- en: IDLE is written in Python using Tkinter, and it provides us with not only an
    editing environment for Python but also a great example of Tkinter in action.
    So, while IDLE's rudimentary feature set may not be considered professional grade
    by experienced Python coders, and while you may already have a preferred environment
    for writing Python code, I encourage you to spend some time using IDLE as you
    go through this book.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: IDLE 使用 Python 和 Tkinter 编写，它不仅为我们提供了 Python 的编辑环境，而且还是 Tkinter 作用的一个很好的示例。因此，尽管
    IDLE 的基本功能可能不被经验丰富的 Python 程序员视为专业级别，并且尽管您可能已经有一个用于编写 Python 代码的首选环境，但我鼓励您在阅读本书的过程中花些时间使用
    IDLE。
- en: 'IDLE has two primary modes: shell mode and editor mode. We''ll take a look
    at those in this section.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: IDLE 有两种主要模式：shell 模式和编辑模式。我们将在本节中探讨这些模式。
- en: Using the shell mode of IDLE
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 IDLE 的 shell 模式
- en: When you launch IDLE, you begin in shell mode, which is simply a Python **Read-Evaluate-Print-Loop**
    (**REPL**) similar to what you get when you type `python` in a Terminal window.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当您启动 IDLE 时，您将进入 shell 模式，这是一个简单的 Python **读取-评估-打印循环**（**REPL**），类似于在终端窗口中键入
    `python` 时获得的结果。
- en: 'You can see IDLE''s shell mode in this screenshot:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此屏幕截图中看到 IDLE 的 shell 模式：
- en: '![](img/B17578_01_01.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17578_01_01.png)'
- en: 'Figure 1.1: IDLE''s shell mode'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1：IDLE 的 shell 模式
- en: IDLE's shell has some nice features that you don't get from the command-line
    REPL, like syntax highlighting and tab completion. The REPL is essential to the
    Python development process, as it gives you the ability to test code in real time
    and inspect classes and APIs without having to write complete scripts. We'll use
    the shell mode in later chapters to explore the features and behaviors of modules.
    If you don't have a shell window open, you can open one by clicking on **Run**
    | **Python Shell** in the IDLE menu.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: IDLE 的 shell 有一些很好的功能，您在命令行 REPL 中得不到，如语法高亮和自动补全。REPL 对于 Python 开发过程至关重要，因为它允许您实时测试代码并检查类和
    API，而无需编写完整的脚本。我们将在后面的章节中使用 shell 模式来探索模块的功能和行为。如果您没有打开 shell 窗口，可以通过在 IDLE 菜单中点击**运行**|**Python
    Shell**来打开一个。
- en: Using the editor mode of IDLE
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 IDLE 的编辑模式
- en: Editor mode is for creating Python script files, which you can later run. When
    the book tells you to create a new file, this is the mode you'll use. To open
    a new file in the editor mode, simply navigate to **File** | **New File** in the
    menu or hit Ctrl + N on the keyboard.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑模式用于创建 Python 脚本文件，您可以在以后运行它们。当本书告诉您创建一个新文件时，这是您将使用的模式。要打开编辑模式中的新文件，只需在菜单中导航到**文件**|**新建文件**，或在键盘上按
    Ctrl + N。
- en: 'This image shows IDLE''s file editor:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 此图像显示了 IDLE 的文件编辑器：
- en: '![](img/B17578_01_02.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17578_01_02.png)'
- en: 'Figure 1.2: IDLE''s file editor'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2：IDLE 的文件编辑器
- en: You can run your script without leaving IDLE by hitting the F5 key in the editor
    mode; IDLE will open a shell-mode window to execute the script and display the
    output.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在编辑模式下按 F5 键运行脚本而无需离开 IDLE；IDLE 将打开一个 shell 模式窗口来执行脚本并显示输出。
- en: IDLE as a Tkinter example
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IDLE 作为 Tkinter 的示例
- en: 'Before we start coding with Tkinter, let''s take a quick look at what you can
    do with it by inspecting some of IDLE''s UI. Navigate to **Options** | **Configure
    IDLE** from the main menu to open IDLE''s configuration settings. Here you can
    change IDLE''s fonts, colors and theme, keyboard shortcuts, and default behaviors,
    as shown in this screenshot:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始使用 Tkinter 编程之前，让我们快速查看您可以使用它做什么，通过检查一些 IDLE 的 UI。从主菜单导航到**选项**|**配置 IDLE**以打开
    IDLE 的配置设置。在这里，您可以更改 IDLE 的字体、颜色和主题、键盘快捷键和默认行为，如此截图所示：
- en: '![](img/B17578_01_03.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17578_01_03.png)'
- en: 'Figure 1.3: IDLE configuration settings'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3：IDLE 配置设置
- en: 'Consider some of the following components that make up this user interface:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下组成此用户界面的组件：
- en: There are drop-down menus that allow you to select between large sets of options.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有下拉菜单，允许您在大型选项集中进行选择。
- en: There are checkable buttons that allow you to select between small sets of options.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有可勾选的按钮，允许您在小型选项集中进行选择。
- en: There are many push buttons that you can click on to execute actions.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有许多可点击的按钮来执行操作。
- en: There is a text window that can display multi-colored text.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个文本窗口可以显示多色文本。
- en: There are labeled frames that contain groups of components.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有标签化的框架，其中包含组件组。
- en: There are tabs across the top of the screen to select different sections of
    the configuration.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 屏幕顶部有标签页，用于选择不同的配置部分。
- en: In Tkinter (as in most GUI libraries), each of these components is known as
    a **widget**; we're going to meet these widgets and more throughout this book
    and learn how to use them as they've been used here. We'll begin, however, with
    something much simpler.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Tkinter（如大多数 GUI 库一样），这些组件都被称为**小部件**；我们将在本书中遇到这些小部件以及更多内容，并学习如何像这里一样使用它们。然而，我们首先从一些更简单的东西开始。
- en: Creating a Tkinter Hello World
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 Tkinter 的 "Hello World"
- en: 'One of the grand traditions in any programming language or library is to create
    a "Hello World" program: that is, a program that displays `Hello World` and exits.
    Let''s walk through creating a "Hello World" application for Tkinter and talk
    about the pieces of it along the way.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何编程语言或库中，有一个伟大的传统是创建一个 "Hello World" 程序：即，显示 `Hello World` 并退出的程序。让我们逐步创建一个
    Tkinter 的 "Hello World" 应用程序，并在过程中讨论它的各个部分。
- en: 'First, create a new file called `hello_tkinter.py` in IDLE or your favorite
    editor, and enter the following code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在 IDLE 或您喜欢的编辑器中创建一个名为 `hello_tkinter.py` 的新文件，并输入以下代码：
- en: '[PRE1]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first line is called a **docstring**, and every Python script should start
    with one. At a minimum, it should give the name of the program but can also include
    details about how to use it, who wrote it, and what it requires.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行被称为**文档字符串**，每个Python脚本都应该以一个开始。至少，它应该给出程序的名字，但也可以包括有关如何使用它、谁编写了它以及它需要什么的详细信息。
- en: The second line imports the `tkinter` module into our program. Although Tkinter
    is in the standard library, we have to import it before we can use any of its
    classes or functions.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行将`tkinter`模块导入到我们的程序中。尽管Tkinter在标准库中，但我们必须导入它才能使用其任何类或函数。
- en: Sometimes, you may see this import written as `from tkinter import *`. That
    approach is called a **wildcard import**, and it results in all the objects being
    brought into the global **namespace**. While popular in tutorials for its simplicity,
    it's a bad idea in actual code as there is a possibility of a collision between
    our own variable names and all names in the `tkinter` module, which can cause
    subtle bugs.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能看到这种导入方式被写成 `from tkinter import *`。这种做法被称为**通配符导入**，它会导致所有对象都被引入到全局**命名空间**中。虽然它在教程中因其简单性而流行，但在实际代码中却是个坏主意，因为我们的变量名可能与`tkinter`模块中的所有名称发生冲突，这可能导致微妙的错误。
- en: To avoid this, we're going to keep `tkinter` in its own **namespace**; however,
    to keep the code concise, we'll alias `tkinter` to `tk`. This convention will
    be used throughout the book.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种情况，我们将`tkinter`放在它自己的**命名空间**中；然而，为了使代码简洁，我们将别名`tkinter`为`tk`。这个约定将在整本书中使用。
- en: 'Every Tkinter program must have exactly one **root window**, which represents
    both the top-level window of our application, and the application itself. Let''s
    create our `root` window, like so:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Tkinter程序必须恰好有一个**根窗口**，它代表我们应用程序的最高级窗口，也是应用程序本身。让我们创建我们的`root`窗口，如下所示：
- en: '[PRE2]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `root` window is an instance of the `Tk` class. We create it by calling
    `Tk()` as we've done here. This object must exist before we can create any other
    Tkinter objects, and when it is destroyed, the application quits.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`root`窗口是`Tk`类的一个实例。我们通过调用`Tk()`来创建它，就像我们在这里做的那样。在我们可以创建任何其他Tkinter对象之前，这个对象必须存在，当它被销毁时，应用程序会退出。'
- en: 'Now, let''s create a widget to put in our window:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个窗口小部件：
- en: '[PRE3]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is a `Label` widget, which is just a panel that can display some text.
    The first argument to any Tkinter widget is always the **parent widget** (sometimes
    called **master widget**); in this case, we've passed in a reference to our root
    window. The parent widget is the widget on which our `Label` will be placed, so
    this `Label` will be directly on the root window of the application. Widgets in
    a Tkinter GUI are arranged in a hierarchy, each widget being contained by another
    all the way up to the root window.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个`Label`小部件，它只是一个可以显示一些文本的面板。任何Tkinter小部件的第一个参数总是**父小部件**（有时称为**主小部件**）；在这种情况下，我们传递了根窗口的引用。父小部件是我们`Label`将被放置其上的一小部件，因此这个`Label`将直接位于应用程序的根窗口上。Tkinter
    GUI中的小部件按层次排列，每个小部件都包含在另一个小部件中，直到根窗口。
- en: We've also passed in a keyword argument, `text`. This argument, of course, defines
    the text that will be placed on the widget. For most Tkinter widgets, the majority
    of configuration is done using keyword arguments like this.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还传递了一个关键字参数，`text`。这个参数当然定义了将被放置在小部件上的文本。对于大多数Tkinter小部件，大多数配置都是使用这样的关键字参数完成的。
- en: 'Now that we''ve created a widget, we need to actually place it on the GUI:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个小部件，我们需要将其实际放置在GUI上：
- en: '[PRE4]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `pack()` method of the `Label` widget is called a **geometry manager method**.
    Its job is to determine how the widget will be attached to its parent widget,
    and to draw it there. Without this call, your widget would exist but you wouldn't
    see it anywhere on the window. `pack()` is one of three geometry managers, which
    we'll learn more about in the next section.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`Label`小部件的`pack()`方法被称为**几何管理器方法**。它的任务是确定小部件将如何附加到其父小部件，并在那里绘制它。如果没有这个调用，你的小部件将存在，但你不会在任何窗口上看到它。`pack()`是三种几何管理器之一，我们将在下一节中了解更多关于它的内容。'
- en: 'The last line of our program looks like this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们程序的最后一行看起来是这样的：
- en: '[PRE5]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This line starts our application's **event loop**. The event loop is an infinite
    loop that continually processes any **events** that happen during the execution
    of the program. Events can be things like keystrokes, mouse clicks, or other user-generated
    activity. This loop runs until the program exits, so any code after this line
    will not be run until the main window is closed. For this reason, this line is
    usually the last one in any Tkinter program.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码启动了应用程序的**事件循环**。事件循环是一个无限循环，它持续处理程序执行期间发生的任何**事件**。事件可以是按键、鼠标点击或其他用户生成活动。这个循环一直运行到程序退出，因此在这行代码之后的任何代码都不会运行，直到主窗口关闭。因此，这行代码通常是任何Tkinter程序中的最后一行。
- en: 'Run the program in IDLE by hitting F5, or in your Terminal by typing the following
    command:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 通过按F5在IDLE中运行程序，或者在终端中输入以下命令：
- en: '[PRE6]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You should see a very tiny window pop up with the text **Hello World** as shown
    here:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到一个非常小的窗口弹出，上面显示**Hello World**，如图所示：
- en: '![](img/B17578_01_04.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图1.4](img/B17578_01_04.png)'
- en: 'Figure 1.4: Our "Hello World" application'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4：我们的“Hello World”应用程序
- en: Feel free to play around with this script by adding more widgets before the
    `root.mainloop()` call. You can add more `Label` objects, or try some `Button`
    (which creates a clickable button) or `Entry` (which creates a text field) widgets.
    Just like `Label`, these widgets are initialized with a parent object (use `root`)
    and a `text` parameter. Don't forget to call `pack()` on each widget to place
    them on the root window.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在`root.mainloop()`调用之前，你可以随意修改这个脚本，添加更多的小部件。你可以添加更多的`Label`对象，或者尝试一些`Button`（创建可点击的按钮）或`Entry`（创建文本字段）小部件。就像`Label`一样，这些小部件使用父对象（使用`root`）和`text`参数初始化。别忘了在每个小部件上调用`pack()`来将它们放置在根窗口上。
- en: Example code for all chapters in this book can be downloaded from [https://github.com/PacktPublishing/Python-GUI-Programming-with-Tkinter-2E](https://github.com/PacktPublishing/Python-GUI-Programming-with-Tkinter-2E).
    You may want to download these now so you can follow along.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 本书所有章节的示例代码可以从[https://github.com/PacktPublishing/Python-GUI-Programming-with-Tkinter-2E](https://github.com/PacktPublishing/Python-GUI-Programming-with-Tkinter-2E)下载。你可能现在想下载这些代码，以便跟随学习。
- en: When you're ready, move on to the next section where we'll create a more interesting
    application.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当你准备好后，继续到下一节，我们将创建一个更有趣的应用程序。
- en: An overview of basic Tkinter
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Tkinter基本概述
- en: As exciting as it may be to see that first GUI window pop up on the screen,
    "Hello World" is not a terribly interesting application. Let's start again and
    dig a little deeper into Tkinter as we build a slightly larger program. Since
    the next chapter will see you landing a job at a fictitious agricultural laboratory
    studying fruit plants, let's create a little program to gauge your opinions about
    bananas.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然看到第一个GUI窗口在屏幕上弹出可能非常令人兴奋，但“Hello World”并不是一个特别有趣的应用程序。让我们重新开始，在构建一个稍微大一点的应用程序的同时，更深入地了解Tkinter。由于下一章将带你去一个虚构的农业实验室工作，研究水果植物，让我们创建一个小程序来评估你对香蕉的看法。
- en: Building a GUI with Tkinter widgets
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Tkinter小部件构建GUI
- en: 'Start a new file in your editor called `banana_survey.py`, and begin by importing
    `tkinter` like so:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的编辑器中创建一个名为`banana_survey.py`的新文件，并开始导入`tkinter`，如下所示：
- en: '[PRE7]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As with `hello_tkinter.py`, we need to create a `root` window before we can
    create any widgets or other Tkinter objects:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 与`hello_tkinter.py`一样，在创建任何小部件或其他Tkinter对象之前，我们需要创建一个`root`窗口：
- en: '[PRE8]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Once again, we''ve called this object `root`. The `root` window can be configured
    in various ways; for example, we can give it a window title or set its size like
    so:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们把这个对象命名为`root`。`root`窗口可以以各种方式配置；例如，我们可以给它一个窗口标题或设置其大小，如下所示：
- en: '[PRE9]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `title()` method sets our window title (that is, the name that shows up
    in the task manager and in the window decorations), while `geometry()` sets the
    window size. In this case, we're telling the root window to be 640 by 480 pixels.
    The `+300+300` sets the position of the window on the screen — in this case, 300
    pixels from the top and 300 pixels from the left (the position portion is optional,
    if you only care about the size). Notice that the argument to `geometry()` is
    a string. In Tcl/Tk, every argument is treated as a string. Since Tkinter is just
    a wrapper that passes arguments on to Tcl/Tk, we'll often find that strings are
    used to configure Tkinter objects – even when we might expect to use integers
    or floats.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`title()`方法设置我们的窗口标题（即显示在任务管理器和窗口装饰中的名称），而`geometry()`设置窗口大小。在这种情况下，我们告诉根窗口大小为640×480像素。`+300+300`设置窗口在屏幕上的位置——在这种情况下，顶部和左侧各300像素（位置部分是可选的，如果你只关心大小）。请注意，`geometry()`的参数是一个字符串。在Tcl/Tk中，每个参数都被视为字符串。由于Tkinter只是一个包装器，它将参数传递给Tcl/Tk，我们经常会发现字符串被用来配置Tkinter对象——即使我们可能期望使用整数或浮点数。'
- en: The `resizable()` method sets whether or not our window can be resized horizontally
    and vertically, respectively. `True` means the window can be resized in that direction,
    `False` means its dimension is fixed. In this case, we want to prevent the resizing
    of the window so that we don't have to worry about making the layout flexible
    to window size changes.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`resizable()`方法设置我们的窗口是否可以水平和垂直调整大小。`True`表示窗口可以调整大小，`False`表示其尺寸是固定的。在这种情况下，我们希望防止窗口调整大小，这样我们就不必担心使布局适应窗口大小的变化。'
- en: 'Now let''s start adding widgets to our survey. We''ve already met the `Label`
    widget, so let''s add one:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始向我们的调查添加小部件。我们已经遇到了`Label`小部件，所以让我们添加一个：
- en: '[PRE10]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As we saw in our "Hello World" example, the first argument passed to any Tkinter
    widget is the **parent** widget on which the new widget will be placed. In this
    case, we''ll be placing this `Label` widget on the `root` window. The remaining
    arguments to a widget are specified as keyword arguments. Here, we''ve specified
    the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在“Hello World”示例中看到的那样，传递给任何Tkinter小部件的第一个参数是**父**小部件，新小部件将放置在这个小部件上。在这种情况下，我们将把这个`Label`小部件放置在`root`窗口上。小部件的其他参数被指定为关键字参数。在这里，我们指定了以下内容：
- en: '`text`, which is the text the label will display.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`text`，这是标签将显示的文本。'
- en: '`font`, which specifies the family, size, and weight of the font used to display
    the text. Notice again that the font settings are specified as a simple string,
    just as our `geometry` settings were.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`font`，指定用于显示文本的字体家族、大小和粗细。请注意，字体设置被指定为一个简单的字符串，就像我们的`geometry`设置一样。'
- en: '`bg`, which sets the background color for the widget. We''ve used a color name
    here; Tkinter recognizes a great many color names, similar to those used by CSS
    or X11.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bg`，用于设置小部件的背景颜色。在这里，我们使用了一个颜色名称；Tkinter识别了大量的颜色名称，类似于CSS或X11中使用的颜色名称。'
- en: '`fg`, which sets the foreground (text) color for the widget. In this case,
    we''ve specified a short hexadecimal string, in which the three characters represent
    the red, green, and blue values respectively. We can also use a six-character
    hex string (for example, `#FFE812`) for finer-grained control over the color.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fg`，用于设置小部件的前景色（文本）颜色。在这种情况下，我们指定了一个简短的十六进制字符串，其中三个字符分别代表红色、绿色和蓝色值。我们也可以使用六位十六进制字符串（例如，`#FFE812`）来对颜色进行更精细的控制。'
- en: In *Chapter 9*, *Improving the Look with Styles and Themes*, we'll learn more
    sophisticated ways to set up fonts and colors, but this will work just fine for
    now.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在第9章“使用样式和主题改进外观”中，我们将学习更复杂的方法来设置字体和颜色，但这对现在来说已经足够好了。
- en: 'Tkinter has many interactive widgets for data entry, of course, the simplest
    being the `Entry` widget:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter有许多用于数据输入的交互式小部件，当然，最简单的是`Entry`小部件：
- en: '[PRE11]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `Entry` widget is just a simple text-input box designed for a single line
    of text. Most input widgets in Tkinter do not include a label of any kind, so
    we've added one to make it clear to our user what the entry box is for.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`Entry`小部件只是一个简单的文本输入框，设计用于单行文本。Tkinter中的大多数输入小部件都不包含任何类型的标签，所以我们添加了一个标签，以便让我们的用户清楚输入框的用途。'
- en: 'One exception to that is the `Checkbutton` widget, which we''ll create next:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 那个例外是`Checkbutton`小部件，我们将在下一节创建它：
- en: '[PRE12]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: A `Checkbutton` creates a check box input; it includes a label that sits next
    to the box, and we can set its text using the `text` argument.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`Checkbutton`创建一个复选框输入；它包括一个位于框旁边的标签，我们可以使用`text`参数设置其文本。'
- en: 'For entering numbers, Tkinter provides the `Spinbox` widget. Let''s add one:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 对于输入数字，Tkinter 提供了 `Spinbox` 小部件。让我们添加一个：
- en: '[PRE13]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'A `Spinbox` is like an `Entry`, but features arrow buttons that can increment
    and decrement the number in the box. We''ve used several arguments to configure
    it here:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`Spinbox` 与 `Entry` 类似，但具有可以递增和递减框内数字的箭头按钮。我们在这里使用了几个参数来配置它：'
- en: The `from_` and `to` arguments set the minimum and maximum values that the buttons
    will decrement or increment to, respectively. Notice that `from_` has an extra
    underscore at the end; this is not a typo! Since `from` is a Python keyword (used
    in importing modules), it can't be used as a variable name, so the Tkinter authors
    chose to use `from_` instead.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`from_` 和 `to` 参数分别设置按钮递减或递增的最小和最大值。请注意，`from_` 在末尾有一个额外的下划线；这并不是一个错误！由于 `from`
    是 Python 的一个关键字（用于导入模块），它不能用作变量名，因此 Tkinter 的作者选择使用 `from_` 代替。'
- en: The `increment` argument sets how much the arrow buttons will increase or decrease
    the number.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`increment` 参数设置箭头按钮增加或减少的数值。'
- en: 'Tkinter has several widgets that allow you to choose from preset selection
    values; one of the simplest is `Listbox`, which looks like this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter 有几个小部件允许您从预设的选择值中进行选择；其中最简单的一个是 `Listbox`，它看起来像这样：
- en: '[PRE14]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `Listbox` takes a `height` argument that specifies how many lines are visible;
    by default the box is big enough to show all the options. We've changed that to
    `1` so that only the currently selected option is visible. The others can be accessed
    using the arrow keys.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`Listbox` 接受一个 `height` 参数，指定可见的行数；默认情况下，框足够大，可以显示所有选项。我们将其更改为 `1`，以便只显示当前选定的选项。其他选项可以使用箭头键访问。'
- en: To add options to the box, we need to call its `insert()` method and add each
    option one at a time. We've done that here using a `for` loop to save repetitive
    coding. The first argument to `insert` specifies where we want to insert the option;
    note that we've used a special **constant** provided by `tkinter`, `tk.END`. This
    is one of many special constants defined in Tkinter for certain configuration
    values. In this case, `tk.END` means the end of the widget, so that each choice
    that we insert will be placed at the end.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要向框中添加选项，我们需要调用其 `insert()` 方法并逐个添加每个选项。我们在这里使用 `for` 循环来完成，以节省重复的编码。`insert`
    的第一个参数指定我们想要插入选项的位置；请注意，我们使用了 `tkinter` 提供的一个特殊 **常量**，`tk.END`。这是 Tkinter 中定义的许多特殊常量之一。在这种情况下，`tk.END`
    表示小部件的末尾，因此我们插入的每个选择都将放置在末尾。
- en: 'Another way to let a user select between a small number of options is the `Radiobutton`
    widget; these are like `Checkbutton` widgets, but, similar to the mechanical preset
    buttons in (very, very old) car radios, they only allow one to be checked at a
    time. Let''s create a few `Radiobutton` widgets:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种让用户在少量选项之间进行选择的方法是 `Radiobutton` 小部件；这些与 `Checkbutton` 小部件类似，但类似于（非常、非常古老的）汽车收音机中的机械预设按钮，它们一次只允许选择一个。让我们创建几个
    `Radiobutton` 小部件：
- en: '[PRE15]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Notice what we''ve done here with `plantain_frame`: we''ve created a `Frame`
    object and used it as the parent widget for each of the `Radiobutton` widgets.
    A `Frame` is simply a blank panel with nothing on it, and it''s useful for organizing
    our layout hierarchically. We''ll use `Frame` widgets quite often in this book
    for keeping groups of widgets together.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们在 `plantain_frame` 上做了什么：我们创建了一个 `Frame` 对象，并将其用作每个 `Radiobutton` 小部件的父小部件。`Frame`
    只是一个空白的面板，上面没有任何内容，它对于分层组织布局非常有用。在这本书中，我们将经常使用 `Frame` 小部件来将一组小部件组合在一起。
- en: '`Entry` widgets work fine for single-line strings, but how about multi-line
    strings? For those, Tkinter offers us the `Text` widget, which we create like
    this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`Entry` 小部件适用于单行字符串，但对于多行字符串呢？对于这些，Tkinter 提供了 `Text` 小部件，我们创建它的方式如下：'
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `Text` widget is capable of much more than just multi-line text, and we'll
    explore a few of its more advanced capabilities in *Chapter 9*, *Improving the
    Look with Styles and Themes*. For now, though, we'll just use it for text.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`Text` 小部件的功能远不止多行文本，我们将在 *第 9 章*，*通过样式和主题改进外观* 中探索其一些更高级的功能。不过，现在我们只使用它来显示文本。'
- en: 'Our GUI would not be complete without a submit button for our survey, which
    is provided by the `Button` class, like so:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 GUI 如果没有用于调查的提交按钮就不完整了，这个按钮由 `Button` 类提供，如下所示：
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We'll use this button to submit the survey and display some output. What widget
    could we use to display that output? It turns out that `Label` objects are useful
    for more than just static messages; we can use them to display messages at runtime
    as well.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这个按钮来提交调查并显示一些输出。我们可以使用哪个小部件来显示那个输出？结果证明，`Label`对象不仅对静态消息很有用；我们还可以在运行时使用它们来显示消息。
- en: 'Let''s add one for our program output:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的程序输出添加一个：
- en: '[PRE18]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here we''ve created the `Label` widget with no text (since we have no output
    yet). We''re also using a couple of additional arguments for `Label`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个没有文本的`Label`小部件（因为我们还没有输出）。我们还使用了一些额外的参数来设置`Label`：
- en: '`anchor` determines which side of the widget the text will be stuck to if the
    widget is wider than the text. Tkinter sometimes uses cardinal directions (North,
    South, East, and West) abbreviated to their first letter whenever it needs to
    specify a side of a widget; in this case, the string `''w''` indicates the West
    (or left) side of the widget.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`anchor`确定如果小部件比文本宽，文本将粘附在哪个小部件的侧面。Tkinter有时使用基本方向（北、南、东和西），缩写为它们的首字母，每当它需要指定小部件的侧面时；在这种情况下，字符串`''w''`表示小部件的西边（或左边）。'
- en: '`justify` determines which side the text will align to when there are multiple
    lines of code. Unlike `anchor`, it uses conventional `''left''`, `''right''`,
    and `''center''` options.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`justify`确定当有多行代码时，文本将对齐到哪一侧。与`anchor`不同，它使用传统的`''left''`、`''right''`和`''center''`选项。'
- en: '`anchor` and `justify` may seem redundant, but they have slightly different
    behavior. In a multiline text situation, the text could be aligned to the center
    of each line, but the whole collection of lines could be anchored to the west
    side of the widget, for example. In other words, `anchor` affects the whole block
    of text with respect to the containing widget, while `justify` affects the individual
    lines of text with respect to the other lines.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`anchor`和`justify`可能看起来是多余的，但它们的行为略有不同。在多行文本的情况下，文本可以与每行的中心对齐，但整个行集合可以锚定到小部件的西边，例如。换句话说，`anchor`影响相对于包含小部件的整个文本块，而`justify`影响相对于其他行的单个文本行。'
- en: Tkinter has many more widgets, and we'll meet many of them throughout the remainder
    of the book.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter有许多更多的小部件，我们将在本书的剩余部分遇到许多它们。
- en: Arranging our widgets with geometry managers
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用几何管理器排列我们的小部件
- en: If you were to add `root.mainloop()` to this script and execute it as-is, you
    would see… a blank window. Hmmm, what happened to all those widgets we just created?
    Well, you may remember from `hello_tkinter.py` that we need to use a geometry
    manager like `pack()` to actually place them somewhere on their parent widgets.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将`root.mainloop()`添加到这个脚本中并直接执行，你会看到一个空白窗口。嗯，我们刚才创建的所有小部件都去哪了？嗯，你可能还记得从`hello_tkinter.py`中，我们需要使用像`pack()`这样的几何管理器来实际上将它们放置在父小部件的某个位置。
- en: 'Tkinter has three geometry manager methods available:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter提供了三种几何管理器方法：
- en: '`pack()` is the oldest, and simply adds widgets to one of the four sides of
    a window sequentially.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pack()`是最古老的，它简单地按顺序将小部件添加到窗口的四个侧面之一。'
- en: '`grid()` is newer and preferred, and allows you to place widgets within a 2-dimensional
    grid table.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`grid()`是较新的，也是首选的，它允许你在二维网格表中放置小部件。'
- en: '`place()` is a third option, which allows you to put widgets at specific pixel
    coordinates. It is not recommended, as it responds poorly to changes in window
    sizes, font sizes, and screen resolution, so we won''t be using it in this book.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`place()`是第三个选项，它允许你将小部件放置在特定的像素坐标上。它不建议使用，因为它对窗口大小、字体大小和屏幕分辨率的更改反应不佳，所以我们不会在这本书中使用它。'
- en: While `pack()` is certainly fine for simple layouts involving a handful of widgets,
    it doesn't scale so well to more complex layouts without an inordinate amount
    of `Frame` widget nesting. For this reason, most Tkinter programmers rely on the
    more modern `grid()` geometry manager. As the name suggests, `grid()` allows you
    to lay out widgets on a 2-dimensional grid, much like a spreadsheet document or
    HTML table. In this book, we'll focus primarily on `grid()`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`pack()`对于涉及少量小部件的简单布局来说确实不错，但它并不适合更复杂的布局，除非有大量的`Frame`小部件嵌套。因此，大多数Tkinter程序员依赖于更现代的`grid()`几何管理器。正如其名所示，`grid()`允许你在二维网格上布局小部件，就像电子表格文档或HTML表格一样。在这本书中，我们将主要关注`grid()`。
- en: 'Let''s start laying out the widgets of our GUI using `grid()`, beginning with
    the `title` label:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从使用`grid()`开始布局我们的GUI小部件，首先是`title`标签：
- en: '[PRE19]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'By default, a call to `grid()` will place the widget in the *first column*
    (column 0) of the *next empty row*. Thus, if we were to simply call `grid()` on
    the next widget, it would end up directly under the first. However, we can also
    be explicit about this using the `row` and `column` arguments, like so:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，对`grid()`的调用将小部件放置在*第一列*（列0）的*下一个空行*中。因此，如果我们简单地对下一个小部件调用`grid()`，它将直接位于第一个小部件下方。然而，我们也可以通过使用`row`和`column`参数来明确这一点，如下所示：
- en: '[PRE20]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Rows and columns count from the top-left corner of the widget, starting with
    `0`. Thus, `row=1, column=0` places the widget in the second row at the first
    column. If we want an additional column, all we need to do is place a widget in
    it, like so:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 行和列从小部件的左上角开始计数，从`0`开始。因此，`row=1, column=0`将小部件放置在第二行第一列。如果我们想要额外的列，我们只需要在小部件中放置一个，如下所示：
- en: '[PRE21]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The grid automatically expands whenever we add a widget to a new row or column.
    If a widget is larger than the current width of the column, or height of the row,
    all the cells in that column or row are expanded to accommodate it. We can tell
    a widget to span multiple columns or multiple rows using the `columnspan` and
    `rowspan` arguments, respectively. For example, it might be nice to have our title
    span the width of the form, so let''s amend it accordingly:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们向新行或新列添加小部件时，网格会自动扩展。如果一个小部件比当前列的宽度或行的长度大，那么该列或行的所有单元格都会扩展以容纳它。我们可以使用`columnspan`和`rowspan`参数分别告诉小部件跨越多个列或多个行。例如，让我们的标题跨越表单的宽度可能是个不错的选择，所以让我们相应地修改它：
- en: '[PRE22]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As columns and rows expand, the widgets do not expand with them by default.
    If we want them to expand, we need to use the `sticky` argument, like this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当列和行扩展时，小部件默认不会随着它们一起扩展。如果我们想让它们扩展，我们需要使用`sticky`参数，如下所示：
- en: '[PRE23]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`sticky` tells Tkinter to stick the sides of the widget to the sides of its
    containing cell so that the widget will stretch as the cell expands. Like the
    `anchor` argument we learned about above, `sticky` takes cardinal directions:
    `n`, `s`, `e`, and `w`. In this case we''ve specified West and East, which will
    cause the widget to stretch horizontally if the column expands further.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`sticky`告诉Tkinter将小部件的边缘粘附到其包含单元格的边缘，这样当单元格扩展时，小部件也会拉伸。就像我们上面学到的`anchor`参数一样，`sticky`也接受四个基本方向：`n`（北）、`s`（南）、`e`（东）和`w`（西）。在这种情况下，我们指定了西和东，这将导致当列进一步扩展时，小部件在水平方向上拉伸。'
- en: 'As an alternative to the strings, we can also use Tkinter''s constants as arguments
    to `sticky`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 作为字符串的替代，我们还可以使用Tkinter的常量作为`sticky`参数的参数：
- en: '[PRE24]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: There is no real difference between using constants and string literals as far
    as Tkinter is concerned; however, the advantage of using constants is that your
    editing software can more easily identify if you've used a constant that doesn't
    exist than an invalid string.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在Tkinter看来，使用常量和字符串字面量之间没有真正的区别；然而，使用常量的优点是，你的编辑软件可以更容易地识别你是否使用了不存在的常量，而不是无效的字符串。
- en: 'The `grid()` method allows us to add padding to our widgets as well, like so:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`grid()`方法允许我们为小部件添加填充，如下所示：'
- en: '[PRE25]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`padx` and `pady` indicate *external* padding – that is, they will expand the
    containing cell, but not the widget. `ipadx` and `ipady`, on the other hand, indicate
    *internal* padding. Specifying these arguments will expand the widget itself (and
    consequently the containing cell).'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`padx`和`pady`表示*外部*填充——也就是说，它们将扩展包含单元格，但不会扩展小部件。另一方面，`ipadx`和`ipady`表示*内部*填充。指定这些参数将扩展小部件本身（从而扩展包含单元格）。'
- en: '![](img/B17578_01_05.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17578_01_05.png)'
- en: 'Figure 1.5: Internal padding (ipadx, ipady) versus external padding (padx,
    pady)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.5：内部填充（ipadx, ipady）与外部填充（padx, pady）的比较
- en: Tkinter does not allow us to mix geometry managers on the same parent widget;
    once we've called `grid()` on any child widget, a call to the `pack()` or `place()`
    method on a sibling widget will generate an error, and vice versa.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter不允许我们在同一个父小部件上混合几何管理器；一旦我们在任何子小部件上调用`grid()`，对兄弟小部件的`pack()`或`place()`方法的调用将生成错误，反之亦然。
- en: 'We can, however, use a different geometry manager on the sibling widget''s
    children. For example, we can use `pack()` to place the child widgets on the `plantain_frame`
    widgets, as shown here:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以在兄弟小部件的子项上使用不同的几何管理器。例如，我们可以使用`pack()`将子小部件放置在`plantain_frame`小部件上，如下所示：
- en: '[PRE26]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `plantain_label` and `plantain_frame` widgets, as children of `root`, must
    be placed with `grid()`; `plantain_yes` and `plantain_no` are children of `plantain_frame`,
    though, so we can choose to use `pack()` (or `place()`) on them if we wish. The
    following diagram illustrates this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`plantain_label`和`plantain_frame`小部件作为`root`的子项，必须使用`grid()`进行放置；然而，`plantain_yes`和`plantain_no`是`plantain_frame`的子项，因此如果我们愿意，可以选择在它们上使用`pack()`（或`place()`）。以下图表说明了这一点：'
- en: '![](img/B17578_01_06.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17578_01_06.png)'
- en: 'Figure 1.6: Each widget''s children must use the same geometry manager method'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.6：每个小部件的子项必须使用相同的几何管理器方法
- en: This ability to choose the geometry manager for each container widget gives
    us enormous flexibility in how we lay out a GUI. While the `grid()` method is
    certainly capable of specifying most layouts, there are times when the semantics
    of `pack()` or `place()` make more sense for a piece of our interface.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这种为每个容器小部件选择几何管理器的能力，使我们能够在布局GUI时具有极大的灵活性。虽然`grid()`方法当然可以指定大多数布局，但在某些时候，`pack()`或`place()`的语义对于我们界面的一部分来说更有意义。
- en: Although the `pack()` geometry manager shares some arguments with `grid()`,
    like `padx` and `pady`, most of the arguments are different. For example, the
    `side` argument used in the example determines which side widgets will be packed
    from, and the `fill` argument determines on which axis the widget will expand.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`pack()`几何管理器与`grid()`共享一些参数，如`padx`和`pady`，但大多数参数是不同的。例如，示例中使用的`side`参数决定了小部件将从哪一侧填充，而`fill`参数决定了小部件将在哪个轴上扩展。
- en: 'Let''s add the last few widgets to our window:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们向窗口添加最后几个小部件：
- en: '[PRE27]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note that we've stuck the `Text` widget (`banana_haiku_inp`) to all four sides
    of its container. This will cause it to expand both vertically and horizontally
    as the grid is stretched. Also notice that we've skipped to rows 99 and 100 for
    the last two widgets. Remember that unused rows are collapsed into nothing, so
    by skipping rows or columns we can leave space for future expansion of our GUI.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们已经将`Text`小部件（`banana_haiku_inp`）固定在其容器的四面。这将导致它在网格拉伸时同时垂直和水平扩展。同时请注意，我们跳过了最后两个小部件的99行和100行。记住，未使用的行会被折叠成无，因此通过跳过行或列，我们可以为GUI未来的扩展留出空间。
- en: By default, Tkinter will make our window just large enough to contain all the
    widgets we place on it; but what happens if our window (or containing frame) becomes
    larger than the space required by our widgets? By default, the widgets will remain
    as they are, stuck to the upper-left side of the application. If we want the GUI
    to expand and fill the space available, we have to tell the parent widget which
    columns and rows of the grid will expand. We do this by using the parent widget's
    `columnconfigure()` and `rowconfigure()` methods.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Tkinter会使我们的窗口大小刚好足够容纳我们放置在上面的所有小部件；但如果我们的窗口（或包含框架）变得比小部件所需的空间大呢？默认情况下，小部件将保持原样，固定在应用程序的左上角。如果我们想让GUI扩展并填充可用空间，我们必须告诉父小部件哪些列和行将扩展。我们通过使用父小部件的`columnconfigure()`和`rowconfigure()`方法来完成此操作。
- en: 'For example, if we want our second column (the one containing most of the input
    widgets) to expand into unused space, we can do this:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想让我们的第二列（包含大部分输入小部件的列）扩展到未使用空间，我们可以这样做：
- en: '[PRE28]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The first argument specifies which column (counting from 0) we want to affect.
    The keyword argument `weight` takes an integer which will determine how much of
    the extra space the column will get. With only one column specified, any value
    greater than 0 will cause that column to expand into the leftover space.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数指定了我们想要影响的列（从0开始计数）。关键字参数`weight`接受一个整数，该整数将决定列将获得多少额外空间。当只指定一个列时，任何大于0的值都会导致该列扩展到剩余空间中。
- en: 'The `rowconfigure()` method works the same way:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`rowconfigure()`方法的工作方式相同：'
- en: '[PRE29]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This time, we've given two rows a `weight` value, but note that row `99` is
    given a weight of `2` while `100` is given a weight of `1`. In this configuration,
    any extra vertical space will be divided between rows `99` and `100`, but row
    `99` will get twice as much of it as row `100`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们给两行分配了一个`weight`值，但请注意，行`99`被分配了`2`的权重，而`100`被分配了`1`的权重。在这种配置下，任何额外的垂直空间将在行`99`和`100`之间分配，但行`99`将获得其中两倍的空间。
- en: As you can see, using a combination of `grid()`, `pack()` sub-frames, and some
    careful planning, we can achieve complex GUI layouts fairly easily in Tkinter.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，通过结合使用`grid()`、`pack()`子框架和一些精心规划，我们可以在Tkinter中相对容易地实现复杂的GUI布局。
- en: Making the form actually do something
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使表单真正发挥作用
- en: We've got a nice form all laid out now, complete with a submit button; so how
    do we make it actually do something? If you have only written procedural code
    in the past, you may be confused about how the flow of code works in a GUI application.
    Unlike a procedural script, the GUI cannot simply execute all the code from top
    to bottom. Instead, it has to respond to user actions, such as a button click
    or a keystroke, whenever and in whatever order they happen. Such actions are known
    as **events**. To make the program respond to an event, we need to **bind** the
    event to a function, which we call a **callback**.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个很好的表单布局，包括一个提交按钮；那么我们如何让它真正做些什么呢？如果你过去只编写过程式代码，你可能会对GUI应用程序中代码的流程感到困惑。与过程式脚本不同，GUI不能简单地从上到下执行所有代码。相反，它必须响应用户操作，如按钮点击或按键，无论何时何地发生。这些操作被称为**事件**。为了使程序响应用户事件，我们需要将事件**绑定**到函数上，我们称之为**回调**。
- en: 'There are a few ways to bind events to callback functions in Tkinter; for a
    button, the simplest is to configure its `command` attribute, like so:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在Tkinter中绑定事件到回调函数有几种方法；对于按钮，最简单的是配置其`command`属性，如下所示：
- en: '[PRE30]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `command` argument can be specified when creating a widget (for example,
    `submit_btn = Button(root, command=on_submit)`), or after creation of the widget
    using its `configure()` method. `configure()` allows you to change a widget's
    configuration after it's created, by passing in arguments just as you would when
    creating the widget.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建小部件时（例如，`submit_btn = Button(root, command=on_submit)`），或者在创建小部件后使用其`configure()`方法，可以指定`command`参数。`configure()`方法允许你在创建小部件后通过传递参数来更改小部件的配置，就像创建小部件时一样。
- en: In either case, `command` specifies a *reference* to a callback function to
    be called when the button is clicked. Note that we do not put parentheses after
    the function name here; doing so would cause the function to be called and its
    return value would be assigned to `command`. We only want a reference to the function
    here.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，`command`指定了一个当按钮被点击时要调用的回调函数的*引用*。请注意，我们在这里函数名后不加括号；这样做会导致函数被调用，并且其返回值将被分配给`command`。我们在这里只想得到函数的引用。
- en: 'The callback function needs to exist before we can pass it to `command`. So,
    before the call to `submit_btn.configure()`, let''s create the `on_submit()` function:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在将回调函数传递给`command`之前，回调函数必须存在。因此，在调用`submit_btn.configure()`之前，让我们创建`on_submit()`函数：
- en: '[PRE31]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: It is conventional to name callback functions in the format `on_<event_name>`
    when they are specifically created to respond to a particular event. However,
    it's not required, nor always appropriate (for example, if a function is a callback
    for many events).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 当回调函数专门创建来响应特定事件时，通常以`on_<event_name>`的格式命名回调函数。然而，这不是必需的，也不总是合适的（例如，如果函数是多个事件的回调）。
- en: A more powerful method of binding events is to use the widget's `bind()` method,
    which we will discuss in more detail in *Chapter 6*, *Planning for the Expansion
    of Our Application*.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定事件的一个更强大的方法是使用小部件的`bind()`方法，我们将在*第6章*，*规划应用扩展*中更详细地讨论。
- en: 'Our `on_submit()` callback is rather boring at the moment, so let''s make it
    better. Remove the `pass` statement and add in this code:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当前的`on_submit()`回调相当无聊，让我们让它变得更好。删除`pass`语句并添加以下代码：
- en: '[PRE32]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The first thing we'll do in this function is retrieve values from some of the
    inputs. For many inputs, the `get()` method is used to retrieve the current value
    of the widget. Note that this value will be returned as a string, even in the
    case of our `Spinbox`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们首先要做的是从一些输入中检索值。对于许多输入，我们使用`get()`方法来检索小部件的当前值。请注意，即使在我们的`Spinbox`中，这个值也将以字符串的形式返回。
- en: For our list widget, `color`, things are more complicated. Its `get()` method
    requires an index number for a choice, and returns the text for that index number.
    We can use the widget's `curselection()` method to get the selected index. If
    there are no selections made, the selected index will be an empty tuple. In that
    case, we'll just set `color` to an empty string. If there is a selection, we can
    pass the value to `get()`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的列表小部件`color`，事情要复杂一些。它的`get()`方法需要一个索引号来选择一个选项，并返回该索引号的文本。我们可以使用小部件的`curselection()`方法来获取选中的索引。如果没有进行选择，选中的索引将是一个空元组。在这种情况下，我们将只设置`color`为空字符串。如果有选择，我们可以将值传递给`get()`。
- en: Getting data from the `Text` widget is again slightly different. Its `get()`
    method requires two values, one for a starting location and another for an ending
    location. These follow a special syntax (which we'll discuss in *Chapter 3*, *Creating
    Basic Forms with Tkinter and Ttk Widgets*), but basically `1.0` means the first
    character of the first line, and `tk.END` is a constant that represents the end
    of the `Text` widget.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 从`Text`小部件获取数据又略有不同。它的`get()`方法需要两个值，一个用于起始位置，另一个用于结束位置。这些遵循特殊的语法（我们将在*第3章*，*使用Tkinter和Ttk小部件创建基本表单*中讨论），但基本上`1.0`表示第一行的第一个字符，而`tk.END`是一个表示`Text`小部件末尾的常量。
- en: Retrieving data from our `Checkbutton` and `Radiobutton` is not possible without
    using Tkinter control variables, which we'll talk about in the section below,
    *Handling data with Tkinter control variables*.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的`Checkbutton`和`Radiobutton`中检索数据，没有使用Tkinter控制变量是不可能的，我们将在下面的章节中讨论，即*使用Tkinter控制变量处理数据*。
- en: Having gathered the data, our callback ends by updating the `text` property
    of the output `Label` widget with a string containing some of the entered data,
    then printing the user's haiku to the console.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 收集完数据后，我们的回调函数通过更新输出`Label`小部件的`text`属性，以包含一些输入数据的字符串结束，然后将用户的俳句打印到控制台。
- en: 'To make this script runnable, finish with this line:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 要使这个脚本可运行，以这一行结束：
- en: '[PRE33]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This executes the event loop of the script so that Tkinter can begin responding
    to events. Save your script and execute it, and you should see something like
    this:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这将执行脚本的事件循环，以便Tkinter可以开始响应用件。保存你的脚本并执行它，你应该会看到类似这样的：
- en: '![](img/B17578_01_07.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17578_01_07.png)'
- en: 'Figure 1.7: Our banana survey application'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.7：我们的香蕉调查应用程序
- en: Congratulations, your banana survey works! Well, kind of. Let's see if we can
    get it fully working.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜，你的香蕉调查应用程序工作正常！好吧，有点。让我们看看我们是否可以使它完全工作。
- en: Handling data with Tkinter control variables
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Tkinter控制变量处理数据
- en: We've got the GUI layout well in hand, but our GUI has some problems. Retrieving
    data from our widgets is a bit of a mess, and we have no idea how to even get
    the values of the `Checkbutton` or `Radiobutton` widgets yet. In fact, if you
    try to operate the `Radiobutton` widgets, you'll see they are broken altogether.
    It seems we're missing a big piece of the puzzle.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经很好地掌握了GUI布局，但我们的GUI存在一些问题。从我们的小部件中检索数据有些混乱，我们甚至不知道如何获取`Checkbutton`或`Radiobutton`小部件的值。实际上，如果你尝试操作`Radiobutton`小部件，你会发现它们完全损坏了。看来我们遗漏了拼图中的一个大块。
- en: 'What we''re missing are Tkinter **control variables**. Control variables are
    special Tkinter objects that allow us to store data; there are four types of control
    variables:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们缺少的是Tkinter **控制变量**。控制变量是特殊的Tkinter对象，允许我们存储数据；有四种类型的控制变量：
- en: '**StringVar**: Used to store strings of any length'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**StringVar**：用于存储任意长度的字符串'
- en: '**IntVar**: Used to store integers'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IntVar**：用于存储整数'
- en: '**DoubleVar**: Used to store floating-point values'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DoubleVar**：用于存储浮点值'
- en: '**BooleanVar**: Used to store Boolean (True/False) values'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BooleanVar**：用于存储布尔（True/False）值'
- en: 'But wait! Python already has variables that can store those types of data and
    much more. Why do we need these classes? Simply put, these variable classes have
    some special abilities that regular Python variables lack, for example:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等！Python已经有一些可以存储这些类型数据以及更多数据的变量。我们为什么还需要这些类？简单地说，这些变量类具有一些常规Python变量所缺乏的特殊能力，例如：
- en: We can create a **two-way binding** between a control variable and a widget,
    so that if either the widget contents are changed or the variable contents are
    changed, both will be kept in sync.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在控制变量和小部件之间创建**双向绑定**，这样如果小部件内容或变量内容发生变化，两者都将保持同步。
- en: We can set up a **trace** on the variable. A trace binds a variable event (such
    as reading or updating the variable) to a callback function. (Traces will be discussed
    in *Chapter 4*, *Organizing Our Code with Classes*.)
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在变量上设置**跟踪**。跟踪将变量事件（如读取或更新变量）绑定到回调函数。（跟踪将在*第4章*，*使用类组织我们的代码*中讨论。）
- en: We can establish relationships between widgets. For example, we can tell our
    two `Radiobutton` widgets that they're connected.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在小部件之间建立关系。例如，我们可以告诉我们的两个`Radiobutton`小部件它们是连接的。
- en: 'Let''s look at how control variables can help our survey application. Go back
    up to the top where the name input is defined and let''s add a variable:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看控制变量如何帮助我们的调查应用程序。回到顶部，查看定义名称输入的地方，然后添加一个变量：
- en: '[PRE34]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We can create a `StringVar` object by calling `StringVar()`; note that we've
    passed in the `root` window as the first argument. Control variables require a
    reference to a `root` window; however, in almost every case, they can work this
    out for themselves automatically, so it's rarely necessary to actually specify
    the `root` window here. It's important to understand, though, that *no control
    variable objects* *can be created until a Tk object exists*.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调用`StringVar()`来创建一个`StringVar`对象；注意，我们已将`root`窗口作为第一个参数传递。控制变量需要一个对`root`窗口的引用；然而，在几乎所有情况下，它们可以自动解决这个问题，因此在这里实际上指定`root`窗口很少是必要的。重要的是要理解，*在没有Tk对象存在的情况下，不能创建任何控制变量对象*。
- en: 'Once we have a `StringVar` object, we can bind it to our `Entry` widget by
    passing it to the `textvariable` argument. By doing this, the contents of the
    `name_inp` widget and the `name_var` variable are kept in sync. A call to the
    variable''s `get()` method will return the current contents of the box, like so:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有一个`StringVar`对象，我们可以通过将其传递给`textvariable`参数来将其绑定到我们的`Entry`小部件。通过这样做，`name_inp`小部件的内容和`name_var`变量保持同步。调用变量的`get()`方法将返回框的当前内容，如下所示：
- en: '[PRE35]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'For a checkbox, a `BooleanVar` is used:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 对于复选框，使用`BooleanVar`：
- en: '[PRE36]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This time, we've passed the variable to the `Checkbutton` using the `variable`
    argument. Button widgets will use the keyword `variable` to bind a control variable,
    while widgets that you type into or that return string values typically use the
    keyword `textvariable`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们通过`variable`参数将变量传递给了`Checkbutton`。按钮小部件将使用关键字`variable`来绑定控制变量，而通常将文本值返回的小部件或用户输入的小部件则使用关键字`textvariable`。
- en: Button widgets do take a `textvariable` argument as well, but it does not bind
    the value of the button; rather it binds to the text of the button's label. This
    feature allows you to dynamically update a button's text.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮小部件也接受`textvariable`参数，但它并不绑定按钮的值；相反，它绑定到按钮标签的文本。这个特性允许你动态更新按钮的文本。
- en: 'Variables can be initialized with a default value using the `value` argument,
    like this:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`value`参数初始化变量，如下所示：
- en: '[PRE37]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Here, we've created an integer variable using `IntVar()` and set its value to
    `3`; when we launch the form, the `num_inp` widget will be set to `3`. Notice
    that, even though we think of the `Spinbox` as a number entry, it uses the `textvariable`
    argument to bind its control variable. A `Spinbox` widget can actually be used
    for more than just numbers, and as such its data is internally stored as text.
    However, by binding an `IntVar` or `DoubleVar` to it, the value retrieved will
    automatically be converted into an integer or float.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们使用`IntVar()`创建了一个整数变量并将其值设置为`3`；当我们启动表单时，`num_inp`小部件将被设置为`3`。请注意，尽管我们认为`Spinbox`是一个数字输入，但它使用`textvariable`参数来绑定其控制变量。`Spinbox`小部件实际上可以用于不仅仅是数字，因此其数据在内部以文本形式存储。然而，通过将其绑定到`IntVar`或`DoubleVar`，检索到的值将自动转换为整数或浮点数。
- en: The automatic conversion to integer or float done by `IntVar` and `DoubleVar`
    can be a problem if users are able to type letters, symbols, or other invalid
    characters into an entry. Calling `get()` on an integer or double variable bound
    to a widget containing an invalid number string (for example, `'1.1.2'` or `'I
    like plantains'`) will raise an exception, causing our application to crash. In
    *Chapter 5*, *Reducing User Error with Validation and Automation*, we'll learn
    how to address this problem.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户能够输入字母、符号或其他无效字符，`IntVar`和`DoubleVar`自动转换为整数或浮点数可能会成为一个问题。当在一个包含无效数字字符串（例如，`'1.1.2'`或`'I
    like plantains'`）的小部件上调用`get()`方法时，将引发异常，导致我们的应用程序崩溃。在*第5章*，*通过验证和自动化减少用户错误*，我们将学习如何解决这个问题。
- en: Previously, we'd used `Listbox` to display a list of options to the user. Unfortunately,
    `Listbox` doesn't work well with control variables, but there is another widget,
    `OptionMenu`, that does.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们使用`Listbox`向用户显示选项列表。不幸的是，`Listbox`与控制变量配合得不太好，但还有一个名为`OptionMenu`的小部件可以做到这一点。
- en: 'Let''s replace our `color_inp` with an `OptionMenu` widget:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将`color_inp`替换为`OptionMenu`小部件：
- en: '[PRE38]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `OptionMenu` holds a list of options as strings, so we need to create a
    `StringVar` to bind to it. Note that, unlike the `ListBox` widget, the `OptionMenu`
    allows us to specify the options as we create it. The `OptionMenu` constructor
    is also a bit different from other Tkinter widget constructors in that it takes
    the control variable and options as positional arguments, like this:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`OptionMenu`小部件以字符串的形式保存选项列表，因此我们需要创建一个`StringVar`来绑定它。注意，与`ListBox`小部件不同，`OptionMenu`允许我们在创建时指定选项。`OptionMenu`构造函数与其他Tkinter小部件构造函数也有所不同，因为它接受控制变量和选项作为位置参数，如下所示：'
- en: '[PRE39]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In our survey code, we've added the options by using the unpack operator (`*`)
    to expand our `color_choices` list into positional arguments. We could also have
    just listed them explicitly, but doing it this way keeps our code a little neater.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的调查代码中，我们通过使用解包操作符（`*`）将`color_choices`列表展开为位置参数来添加选项。我们也可以直接列出它们，但这样做可以使我们的代码更整洁。
- en: We're going to learn about a better option for a drop-down list box when we
    discuss the Ttk widget set in *Chapter 3*, *Creating Basic Forms with Tkinter
    and Ttk Widgets*.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第3章*使用Tkinter和Ttk小部件创建基本表单*中讨论一个更好的下拉列表框选项。
- en: 'The `Radiobutton` widget handles variables slightly differently from other
    widgets as well. To use `Radiobutton` widgets effectively, we bind all the buttons
    that are grouped together to the same control variable, like this:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`Radiobutton`小部件与其他小部件在处理变量方面略有不同。为了有效地使用`Radiobutton`小部件，我们将所有分组在一起的按钮绑定到同一个控制变量上，如下所示：'
- en: '[PRE40]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We can bind any kind of control variable to a `Radiobutton` widget, but we have
    to make sure to give each widget a `value` that matches the variable type. In
    this case, we're using the buttons for a `True`/`False` question, so `BooleanVar`
    is appropriate; we use the `value` argument to set one button to `True` and the
    other to `False`. When we call the variable's `get()` method, it will return the
    `value` argument of the selected button.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将任何类型的控制变量绑定到`Radiobutton`小部件上，但我们必须确保为每个小部件提供一个与变量类型匹配的`value`。在这种情况下，我们使用按钮来回答`True`/`False`问题，因此`BooleanVar`是合适的；我们使用`value`参数将一个按钮设置为`True`，另一个设置为`False`。当我们调用变量的`get()`方法时，它将返回所选按钮的`value`参数。
- en: Unfortunately, not all Tkinter widgets work with control variables. Notably,
    our `Text` widget used for the `banana_haiku_inp` input cannot be bound to a variable,
    and (unlike `Listbox`) there is no alternative available. For the time being,
    we'll have to handle the `Text` entry widget as we have already done.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，并非所有Tkinter小部件都支持控制变量。值得注意的是，我们用于`banana_haiku_inp`输入的`Text`小部件不能绑定到变量上，而且（与`Listbox`不同）没有可用的替代方案。目前，我们不得不像之前那样处理`Text`输入小部件。
- en: The Tkinter `Text` box does not support variables because it is much more than
    just multi-line text; it can contain images, rich text, and other objects that
    can't be represented in a simple string. However, in *Chapter 4*, *Organizing
    Our Code with Classes*, we'll implement a workaround for this that will allow
    us to bind a variable to a multi-line string widget.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter的`Text`框不支持变量，因为它不仅仅是多行文本；它可以包含图像、富文本和其他无法用简单字符串表示的对象。然而，在*第4章*，*使用类组织我们的代码*中，我们将实现一个解决方案，允许我们将变量绑定到多行字符串小部件。
- en: 'Control variables are not just for binding to input widgets; we can also use
    them to update strings in non-interactive widgets like `Label`. For example:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 控制变量不仅用于绑定到输入小部件；我们还可以使用它们来更新非交互式小部件（如`Label`）中的字符串。例如：
- en: '[PRE41]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: With the `output_var` control variable bound to the `textvariable` argument
    of this `Label` widget, we can alter the text displayed by the label at runtime
    by updating `output_var`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`output_var`控制变量绑定到这个`Label`小部件的`textvariable`参数，我们可以在运行时通过更新`output_var`来改变标签显示的文本。
- en: Using control variables in a callback function
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在回调函数中使用控制变量
- en: Now that we've created all these variables and bound them to our widgets, what
    can we do with them? Skip down to the callback function, `on_submit()`, and delete
    the code that is in it. We will re-write it using our control variables.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了所有这些变量并将它们绑定到小部件上，我们可以用它们做什么呢？跳转到回调函数`on_submit()`，并删除其中的代码。我们将使用控制变量重新编写它。
- en: 'Start with the `name` value:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 从`name`值开始：
- en: '[PRE42]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'As mentioned earlier, the `get()` method is used to retrieve a variable''s
    value. The data type returned by `get()` depends on the type of variable, as follows:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`get()`方法用于检索变量的值。`get()`返回的数据类型取决于变量的类型，如下所示：
- en: '`StringVar` returns a `str`'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StringVar`返回一个`str`'
- en: '`IntVar` returns an `int`'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IntVar` 返回一个 `int`'
- en: '`DoubleVar` returns a `float`'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DoubleVar` 返回一个 `float`'
- en: '`BooleanVar` returns a `bool`'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BooleanVar` 返回一个 `bool`'
- en: Note that type conversion is performed whenever `get()` is called, so any incompatibility
    between what the widget contains and what the variable expects will raise an exception
    at this time. For example, if an `IntVar` is bound to an empty `Spinbox`, `get()`
    will raise an exception because an empty string cannot be cast to `int`.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，每当调用 `get()` 时都会执行类型转换，因此如果小部件包含的内容与变量期望的内容不兼容，将会在此时刻引发异常。例如，如果 `IntVar`
    绑定到一个空的 `Spinbox`，`get()` 将会引发异常，因为空字符串无法转换为 `int`。
- en: 'For that reason, it is sometimes wise to put `get()` in a `try/except` block,
    like so:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，有时将 `get()` 放在 `try/except` 块中是明智的，如下所示：
- en: '[PRE43]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Contrary to what an experienced Python programmer might expect, the exception
    raised for an invalid value is *not* `ValueError`. The conversion is actually
    done in Tcl/Tk, not in Python, so the exception raised is a `tkinter.TclError`.
    Here, we've caught the `TclError` and handled it by setting the number of bananas
    to `10,000`.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 与经验丰富的 Python 程序员可能预期的相反，对于无效值引发的异常不是 `ValueError`。转换实际上是在 Tcl/Tk 中完成的，而不是在
    Python 中，因此引发的异常是 `tkinter.TclError`。在这里，我们已经捕获了 `TclError` 并通过将香蕉数量设置为 `10,000`
    来处理它。
- en: '`TclError` exceptions are raised *any time* Tcl/Tk has difficulty executing
    our translated Python calls, so to properly handle them you may need to extract
    the actual error string from the exception. This is a bit ugly and un-Pythonic,
    but Tkinter doesn''t leave us much choice.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Tcl/Tk 执行我们的翻译 Python 调用遇到困难时，会引发 `TclError` 异常，因此为了正确处理它们，您可能需要从异常中提取实际的错误字符串。这有点丑陋，不符合
    Python 风格，但 Tkinter 给我们的选择不多。
- en: 'Extracting the value of our `OptionMenu`, `Checkbutton`, and `Radiobutton`
    widgets is much cleaner now, as you can see here:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在提取我们的 `OptionMenu`、`Checkbutton` 和 `Radiobutton` 小部件的值要干净得多，正如您在这里可以看到的：
- en: '[PRE44]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: For the `OptionMenu`, `get()` returns the selected string. For `Checkbutton`,
    it returns `True` if the button is checked, or `False` if it is not. For the `Radiobutton`
    widgets, `get()` returns the `value` of the selected widget. The nice thing about
    control variables is that we don't have to know or care what kind of widget they
    were bound to; simply calling `get()` is sufficient to retrieve the user's input.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `OptionMenu`，`get()` 返回选中的字符串。对于 `Checkbutton`，如果按钮被选中，则返回 `True`，如果没有选中，则返回
    `False`。对于 `Radiobutton` 小部件，`get()` 返回选中小部件的 `value`。控制变量的好处是，我们不必知道或关心它们绑定到了哪种小部件；只需调用
    `get()` 就足以检索用户的输入。
- en: 'The `Text` widget, as mentioned before, doesn''t support control variables,
    so we have to get its content the old-fashioned way:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`Text` 小部件不支持控制变量，因此我们必须以传统的方式获取其内容：
- en: '[PRE45]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now that we have all that data, let''s build a message string for the survey
    taker:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了所有这些数据，让我们为调查者构建一个消息字符串：
- en: '[PRE46]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'To display our message for the user, we need to update the `output_var` variable.
    This is done using its `set()` method, like so:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 为了向用户显示我们的消息，我们需要更新 `output_var` 变量。这是通过使用它的 `set()` 方法来完成的，如下所示：
- en: '[PRE47]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The `set()` method will update the control variable, which in turn will update
    the `Label` widget to which it is bound. This way, we can dynamically update displayed
    messages, widget labels, and other text in our application.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`set()` 方法将更新控制变量，这反过来又会更新它所绑定到的 `Label` 小部件。这样，我们可以动态地更新显示的消息、小部件标签以及我们应用程序中的其他文本。'
- en: Remember to use `set()` to change a control variable's value! Using the assignment
    operator (`=`) will just overwrite the control variable object with a different
    object and you won't be able to work with it anymore. For example, `output_var
    = message` would just reassign the name `output_var` to the string object `message`,
    and the control variable object currently bound to `output_line` would become
    nameless.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 记得使用 `set()` 来更改控制变量的值！使用赋值运算符（`=`）只会用不同的对象覆盖控制变量对象，您将无法再使用它。例如，`output_var
    = message` 只会将名称 `output_var` 重新分配给字符串对象 `message`，而当前绑定到 `output_line` 的控制变量对象将变得无名称。
- en: The importance of control variables
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制变量的重要性
- en: 'Hopefully, you see that control variables are a powerful and essential part
    of a Tkinter GUI. We will use them extensively in our applications to store and
    communicate data between Tkinter objects. In fact, once we''ve bound a variable
    to a widget, it''s often unnecessary to keep a reference to our widget. For example,
    our survey code would work just fine if we defined the output section like this:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你能看到控制变量是Tkinter GUI的一个强大且必要的一部分。我们将在我们的应用程序中广泛使用它们来存储和传递Tkinter对象之间的数据。实际上，一旦我们将一个变量绑定到小部件上，通常就不再需要保留对小部件的引用。例如，如果我们这样定义输出部分，我们的调查代码将运行得很好：
- en: '[PRE48]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Since we don't need to interact directly with the output `Label`, we can just
    create it and place it all in one line, without bothering to save a reference.
    Since the widget's parent retains a reference to the object, Python won't destroy
    the object, and we can retrieve its contents at any time using the control variable.
    Of course, if we later want to manipulate the widget in some way (changing its
    `font` value, for example), we'll need to keep a reference to it.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不需要直接与输出`Label`交互，我们只需创建它并将所有内容放在一行中，无需保存引用。由于小部件的父级保留了对象的引用，Python不会销毁该对象，我们可以随时使用控制变量检索其内容。当然，如果我们后来想以某种方式操作小部件（例如更改其`font`值），我们需要保留对其的引用。
- en: Summary
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to install Tkinter and IDLE, and you've gotten
    a taste of how easy it is to start building a GUI with Tkinter. You learned how
    to create widgets, how to arrange them in the main window with the `grid()` geometry
    manager, and how to bind their contents to control variables like `StringVar`
    and `BooleanVar`. You also learned how to bind events like button clicks to callback
    functions, and how to retrieve and process widget data.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何安装Tkinter和IDLE，并且体验到了使用Tkinter开始构建GUI是多么简单。你学习了如何创建小部件，如何使用`grid()`布局管理器将它们排列在主窗口中，以及如何将它们的内联内容绑定到控制变量，如`StringVar`和`BooleanVar`。你还学习了如何将事件，如按钮点击，绑定到回调函数，以及如何检索和处理小部件数据。
- en: In the next chapter, you'll start your new job at ABQ AgriLabs and be presented
    with a problem that will require your GUI programming skills. You will learn how
    to dissect this problem, develop a program specification, and design a user-friendly
    application that will be part of the solution.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将在ABQ AgriLabs开始你的新工作，并面临一个需要你的GUI编程技能的问题。你将学习如何分析这个问题，制定程序规范，并设计一个用户友好的应用程序，这将成为解决方案的一部分。
