- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduction to Tkinter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome, Python coder! If you've learned the basics of Python and want to start
    designing powerful GUI applications, this book is for you.
  prefs: []
  type: TYPE_NORMAL
- en: By now, you have no doubt experienced the power and simplicity of Python. Perhaps
    you've written web services, performed data analysis, or administered servers.
    Perhaps you've written a game, automated routine tasks, or simply played around
    with code. But now you're ready to tackle the GUI.
  prefs: []
  type: TYPE_NORMAL
- en: With so much emphasis on web, mobile, and server-side programming, the development
    of simple desktop GUI applications seems increasingly like a lost art; many otherwise
    experienced developers have never learned to create one. What a tragedy! Desktop
    computers still play a vital role in work and home computing, and the ability
    to build simple, functional applications for this ubiquitous platform should be
    a part of every software developer's toolbox. Fortunately, for Python coders,
    that ability is well within reach thanks to Tkinter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: In *Introducing Tkinter and Tk*, you'll learn about Tkinter, a fast, fun, easy-to-learn
    GUI library built in to the Python Standard Library; and IDLE, an editor and development
    environment written in Tkinter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In *An overview of basic Tkinter*, you'll learn the basics of Tkinter with a
    "Hello World" program and create a Survey application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Tkinter and Tk
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Tk widget library originates from the **Tool Command Language** (**Tcl**)
    programming language. Tcl and Tk were created by John Ousterhout while he was
    a professor at Berkeley in the late 1980s as an easier way to program the engineering
    tools being used at the university. Because of its speed and relative simplicity,
    Tcl/Tk rapidly grew in popularity among academic, engineering, and Unix programmers.
    Much like Python itself, Tcl/Tk originated on the Unix platform and only later
    migrated to macOS and Windows. Tk's practical intent and Unix roots still inform
    its design today, and its simplicity compared to other toolkits is still a major
    strength.
  prefs: []
  type: TYPE_NORMAL
- en: '**Tkinter** is a Python interface to the Tk GUI library and has been a part
    of the Python standard library since 1994 with the release of Python version 1.1,
    making it the *de-facto* GUI library for Python. Documentation for Tkinter, along
    with links for further study, can be found in the standard library documentation
    at [https://docs.python.org/3/library/tkinter.html](https://docs.python.org/3/library/tkinter.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Choosing Tkinter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python coders who want to build a GUI have several toolkit options to choose
    from; unfortunately, Tkinter is often maligned or ignored as a legacy option.
    To be fair, it''s not a glamorous technology that you can describe in trendy buzzwords
    and glowing hype. However, Tkinter is not only adequate for a wide variety of
    applications but also has some advantages that can''t be ignored:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tkinter is in the standard library**: With few exceptions, Tkinter is available
    wherever Python is available. There is no need to install pip, create virtual
    environments, compile binaries, or search the web for installation packages. For
    simple projects that need to be done quickly, this is a clear advantage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tkinter is stable**: While Tkinter development has not stopped, it is slow
    and evolutionary. The API has been stable for years, the changes mainly being
    additional functionality and bug fixes. Your Tkinter code will likely run unaltered
    for years or decades to come.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tkinter is only a GUI toolkit**: Unlike some other GUI libraries, Tkinter
    doesn''t have its own threading library, network stack, or filesystem API. It
    relies on regular Python libraries for such things, so it''s perfect for applying
    a GUI to existing Python code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tkinter is simple and no-nonsense**: Tkinter is very basic and to-the-point;
    it can be used effectively in both procedural and object-oriented GUI designs.
    To use Tkinter, you don''t have to learn hundreds of widget classes, a markup
    or templating language, a new programming paradigm, client-server technologies,
    or a different programming language.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Tkinter is not perfect, of course. It also has some disadvantages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tkinter''s default look and feel is dated**: Tkinter''s default appearance
    has long lagged behind current trends, and it still bears a few artifacts from
    the 1990s Unix world. While it lacks niceties like animated widgets, gradients,
    or scalable graphics, it has nevertheless improved a great deal in the last few
    years, thanks to updates in Tk itself and the addition of themed widget libraries.
    We''ll learn how to fix or avoid some of Tkinter''s more archaic defaults throughout
    the book.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tkinter lacks more complex widgets**: Tkinter is missing advanced widgets
    like rich text editors, 3D graphics embedding, HTML viewers, or specialized input
    widgets. As we''ll see later in this book, Tkinter gives us the ability to create
    complex widgets by customizing and combining its simple ones.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tkinter might be the wrong choice for a game UI or slick commercial application;
    however, for data-driven applications, simple utilities, configuration dialogs,
    and other business logic applications, Tkinter offers all that is needed and more.
    In this book we're going to be working through the development of data entry application
    for a workplace environment, something that Tkinter can handle admirably.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Tkinter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tkinter is included in the Python standard library for the Windows and macOS
    distributions. So, if you have installed Python on these platforms using the official
    installers, you don't need to do anything to install Tkinter.
  prefs: []
  type: TYPE_NORMAL
- en: However, we're going to be exclusively focused on Python 3.9 for this book;
    so, you need to make sure that you have this version or later installed.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Python 3.9 on Windows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can obtain Python 3 installers for Windows from the [python.org](http://python.org)
    website by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to [https://www.python.org/downloads/windows](https://www.python.org/downloads/windows/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the latest Python 3 release. At the time of writing, the latest version
    is 3.9.2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under the **Files** section, select the Windows executable installer appropriate
    to your system's architecture (x86 for 32-bit Windows, x86-64 for 64-bit Windows;
    if you're unsure, x86 will work on either).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Launch the downloaded installer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Customize installation**. Make sure the **tcl/tk and IDLE** option
    is checked (it should be by default).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Continue through the installer with all defaults.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Installing Python 3 on macOS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As of this writing, macOS ships with Python 2.7 built in. However, Python 2
    was officially deprecated in 2020, and the code in this book will not work with
    it, so macOS users will need to install Python 3 to follow this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow this procedure to install Python3 on macOS:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to [https://www.python.org/downloads/mac-osx/](https://www.python.org/downloads/mac-osx/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the latest Python 3 release. At the time of writing, the latest version
    is 3.9.2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under the **Files** section, select and download the macOS 64-bit/32-bit installer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Launch the `.pkg` file that you've downloaded and follow the steps of the install
    wizard, selecting defaults.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Installing Python 3 and Tkinter on Linux
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Most Linux distributions include both Python 2 and Python 3; however, Tkinter
    is not always bundled with it or installed by default. To find out if Tkinter
    is installed, open a Terminal and try the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This should open a simple window showing some information about Tkinter. If
    you get `ModuleNotFoundError` instead, you will need to use your package manager
    to install your distribution's Tkinter package for Python 3\. In most major distributions,
    including Debian, Ubuntu, Fedora, and openSUSE, this package is called `python3-tk`.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing IDLE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**IDLE** is an integrated development environment that is bundled with the
    official Python software distributions for Windows and macOS (it''s readily available
    in most Linux distributions as well, usually as `idle` or `idle3`).'
  prefs: []
  type: TYPE_NORMAL
- en: IDLE is written in Python using Tkinter, and it provides us with not only an
    editing environment for Python but also a great example of Tkinter in action.
    So, while IDLE's rudimentary feature set may not be considered professional grade
    by experienced Python coders, and while you may already have a preferred environment
    for writing Python code, I encourage you to spend some time using IDLE as you
    go through this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'IDLE has two primary modes: shell mode and editor mode. We''ll take a look
    at those in this section.'
  prefs: []
  type: TYPE_NORMAL
- en: Using the shell mode of IDLE
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you launch IDLE, you begin in shell mode, which is simply a Python **Read-Evaluate-Print-Loop**
    (**REPL**) similar to what you get when you type `python` in a Terminal window.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see IDLE''s shell mode in this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17578_01_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.1: IDLE''s shell mode'
  prefs: []
  type: TYPE_NORMAL
- en: IDLE's shell has some nice features that you don't get from the command-line
    REPL, like syntax highlighting and tab completion. The REPL is essential to the
    Python development process, as it gives you the ability to test code in real time
    and inspect classes and APIs without having to write complete scripts. We'll use
    the shell mode in later chapters to explore the features and behaviors of modules.
    If you don't have a shell window open, you can open one by clicking on **Run**
    | **Python Shell** in the IDLE menu.
  prefs: []
  type: TYPE_NORMAL
- en: Using the editor mode of IDLE
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Editor mode is for creating Python script files, which you can later run. When
    the book tells you to create a new file, this is the mode you'll use. To open
    a new file in the editor mode, simply navigate to **File** | **New File** in the
    menu or hit Ctrl + N on the keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'This image shows IDLE''s file editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17578_01_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.2: IDLE''s file editor'
  prefs: []
  type: TYPE_NORMAL
- en: You can run your script without leaving IDLE by hitting the F5 key in the editor
    mode; IDLE will open a shell-mode window to execute the script and display the
    output.
  prefs: []
  type: TYPE_NORMAL
- en: IDLE as a Tkinter example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before we start coding with Tkinter, let''s take a quick look at what you can
    do with it by inspecting some of IDLE''s UI. Navigate to **Options** | **Configure
    IDLE** from the main menu to open IDLE''s configuration settings. Here you can
    change IDLE''s fonts, colors and theme, keyboard shortcuts, and default behaviors,
    as shown in this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17578_01_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.3: IDLE configuration settings'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider some of the following components that make up this user interface:'
  prefs: []
  type: TYPE_NORMAL
- en: There are drop-down menus that allow you to select between large sets of options.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are checkable buttons that allow you to select between small sets of options.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many push buttons that you can click on to execute actions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a text window that can display multi-colored text.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are labeled frames that contain groups of components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are tabs across the top of the screen to select different sections of
    the configuration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Tkinter (as in most GUI libraries), each of these components is known as
    a **widget**; we're going to meet these widgets and more throughout this book
    and learn how to use them as they've been used here. We'll begin, however, with
    something much simpler.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Tkinter Hello World
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the grand traditions in any programming language or library is to create
    a "Hello World" program: that is, a program that displays `Hello World` and exits.
    Let''s walk through creating a "Hello World" application for Tkinter and talk
    about the pieces of it along the way.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a new file called `hello_tkinter.py` in IDLE or your favorite
    editor, and enter the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The first line is called a **docstring**, and every Python script should start
    with one. At a minimum, it should give the name of the program but can also include
    details about how to use it, who wrote it, and what it requires.
  prefs: []
  type: TYPE_NORMAL
- en: The second line imports the `tkinter` module into our program. Although Tkinter
    is in the standard library, we have to import it before we can use any of its
    classes or functions.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, you may see this import written as `from tkinter import *`. That
    approach is called a **wildcard import**, and it results in all the objects being
    brought into the global **namespace**. While popular in tutorials for its simplicity,
    it's a bad idea in actual code as there is a possibility of a collision between
    our own variable names and all names in the `tkinter` module, which can cause
    subtle bugs.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid this, we're going to keep `tkinter` in its own **namespace**; however,
    to keep the code concise, we'll alias `tkinter` to `tk`. This convention will
    be used throughout the book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every Tkinter program must have exactly one **root window**, which represents
    both the top-level window of our application, and the application itself. Let''s
    create our `root` window, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `root` window is an instance of the `Tk` class. We create it by calling
    `Tk()` as we've done here. This object must exist before we can create any other
    Tkinter objects, and when it is destroyed, the application quits.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create a widget to put in our window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This is a `Label` widget, which is just a panel that can display some text.
    The first argument to any Tkinter widget is always the **parent widget** (sometimes
    called **master widget**); in this case, we've passed in a reference to our root
    window. The parent widget is the widget on which our `Label` will be placed, so
    this `Label` will be directly on the root window of the application. Widgets in
    a Tkinter GUI are arranged in a hierarchy, each widget being contained by another
    all the way up to the root window.
  prefs: []
  type: TYPE_NORMAL
- en: We've also passed in a keyword argument, `text`. This argument, of course, defines
    the text that will be placed on the widget. For most Tkinter widgets, the majority
    of configuration is done using keyword arguments like this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve created a widget, we need to actually place it on the GUI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `pack()` method of the `Label` widget is called a **geometry manager method**.
    Its job is to determine how the widget will be attached to its parent widget,
    and to draw it there. Without this call, your widget would exist but you wouldn't
    see it anywhere on the window. `pack()` is one of three geometry managers, which
    we'll learn more about in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last line of our program looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This line starts our application's **event loop**. The event loop is an infinite
    loop that continually processes any **events** that happen during the execution
    of the program. Events can be things like keystrokes, mouse clicks, or other user-generated
    activity. This loop runs until the program exits, so any code after this line
    will not be run until the main window is closed. For this reason, this line is
    usually the last one in any Tkinter program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the program in IDLE by hitting F5, or in your Terminal by typing the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see a very tiny window pop up with the text **Hello World** as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17578_01_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.4: Our "Hello World" application'
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to play around with this script by adding more widgets before the
    `root.mainloop()` call. You can add more `Label` objects, or try some `Button`
    (which creates a clickable button) or `Entry` (which creates a text field) widgets.
    Just like `Label`, these widgets are initialized with a parent object (use `root`)
    and a `text` parameter. Don't forget to call `pack()` on each widget to place
    them on the root window.
  prefs: []
  type: TYPE_NORMAL
- en: Example code for all chapters in this book can be downloaded from [https://github.com/PacktPublishing/Python-GUI-Programming-with-Tkinter-2E](https://github.com/PacktPublishing/Python-GUI-Programming-with-Tkinter-2E).
    You may want to download these now so you can follow along.
  prefs: []
  type: TYPE_NORMAL
- en: When you're ready, move on to the next section where we'll create a more interesting
    application.
  prefs: []
  type: TYPE_NORMAL
- en: An overview of basic Tkinter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As exciting as it may be to see that first GUI window pop up on the screen,
    "Hello World" is not a terribly interesting application. Let's start again and
    dig a little deeper into Tkinter as we build a slightly larger program. Since
    the next chapter will see you landing a job at a fictitious agricultural laboratory
    studying fruit plants, let's create a little program to gauge your opinions about
    bananas.
  prefs: []
  type: TYPE_NORMAL
- en: Building a GUI with Tkinter widgets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Start a new file in your editor called `banana_survey.py`, and begin by importing
    `tkinter` like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As with `hello_tkinter.py`, we need to create a `root` window before we can
    create any widgets or other Tkinter objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Once again, we''ve called this object `root`. The `root` window can be configured
    in various ways; for example, we can give it a window title or set its size like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `title()` method sets our window title (that is, the name that shows up
    in the task manager and in the window decorations), while `geometry()` sets the
    window size. In this case, we're telling the root window to be 640 by 480 pixels.
    The `+300+300` sets the position of the window on the screen — in this case, 300
    pixels from the top and 300 pixels from the left (the position portion is optional,
    if you only care about the size). Notice that the argument to `geometry()` is
    a string. In Tcl/Tk, every argument is treated as a string. Since Tkinter is just
    a wrapper that passes arguments on to Tcl/Tk, we'll often find that strings are
    used to configure Tkinter objects – even when we might expect to use integers
    or floats.
  prefs: []
  type: TYPE_NORMAL
- en: The `resizable()` method sets whether or not our window can be resized horizontally
    and vertically, respectively. `True` means the window can be resized in that direction,
    `False` means its dimension is fixed. In this case, we want to prevent the resizing
    of the window so that we don't have to worry about making the layout flexible
    to window size changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s start adding widgets to our survey. We''ve already met the `Label`
    widget, so let''s add one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As we saw in our "Hello World" example, the first argument passed to any Tkinter
    widget is the **parent** widget on which the new widget will be placed. In this
    case, we''ll be placing this `Label` widget on the `root` window. The remaining
    arguments to a widget are specified as keyword arguments. Here, we''ve specified
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`text`, which is the text the label will display.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`font`, which specifies the family, size, and weight of the font used to display
    the text. Notice again that the font settings are specified as a simple string,
    just as our `geometry` settings were.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bg`, which sets the background color for the widget. We''ve used a color name
    here; Tkinter recognizes a great many color names, similar to those used by CSS
    or X11.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fg`, which sets the foreground (text) color for the widget. In this case,
    we''ve specified a short hexadecimal string, in which the three characters represent
    the red, green, and blue values respectively. We can also use a six-character
    hex string (for example, `#FFE812`) for finer-grained control over the color.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In *Chapter 9*, *Improving the Look with Styles and Themes*, we'll learn more
    sophisticated ways to set up fonts and colors, but this will work just fine for
    now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tkinter has many interactive widgets for data entry, of course, the simplest
    being the `Entry` widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `Entry` widget is just a simple text-input box designed for a single line
    of text. Most input widgets in Tkinter do not include a label of any kind, so
    we've added one to make it clear to our user what the entry box is for.
  prefs: []
  type: TYPE_NORMAL
- en: 'One exception to that is the `Checkbutton` widget, which we''ll create next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: A `Checkbutton` creates a check box input; it includes a label that sits next
    to the box, and we can set its text using the `text` argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'For entering numbers, Tkinter provides the `Spinbox` widget. Let''s add one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'A `Spinbox` is like an `Entry`, but features arrow buttons that can increment
    and decrement the number in the box. We''ve used several arguments to configure
    it here:'
  prefs: []
  type: TYPE_NORMAL
- en: The `from_` and `to` arguments set the minimum and maximum values that the buttons
    will decrement or increment to, respectively. Notice that `from_` has an extra
    underscore at the end; this is not a typo! Since `from` is a Python keyword (used
    in importing modules), it can't be used as a variable name, so the Tkinter authors
    chose to use `from_` instead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `increment` argument sets how much the arrow buttons will increase or decrease
    the number.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Tkinter has several widgets that allow you to choose from preset selection
    values; one of the simplest is `Listbox`, which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `Listbox` takes a `height` argument that specifies how many lines are visible;
    by default the box is big enough to show all the options. We've changed that to
    `1` so that only the currently selected option is visible. The others can be accessed
    using the arrow keys.
  prefs: []
  type: TYPE_NORMAL
- en: To add options to the box, we need to call its `insert()` method and add each
    option one at a time. We've done that here using a `for` loop to save repetitive
    coding. The first argument to `insert` specifies where we want to insert the option;
    note that we've used a special **constant** provided by `tkinter`, `tk.END`. This
    is one of many special constants defined in Tkinter for certain configuration
    values. In this case, `tk.END` means the end of the widget, so that each choice
    that we insert will be placed at the end.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to let a user select between a small number of options is the `Radiobutton`
    widget; these are like `Checkbutton` widgets, but, similar to the mechanical preset
    buttons in (very, very old) car radios, they only allow one to be checked at a
    time. Let''s create a few `Radiobutton` widgets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice what we''ve done here with `plantain_frame`: we''ve created a `Frame`
    object and used it as the parent widget for each of the `Radiobutton` widgets.
    A `Frame` is simply a blank panel with nothing on it, and it''s useful for organizing
    our layout hierarchically. We''ll use `Frame` widgets quite often in this book
    for keeping groups of widgets together.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Entry` widgets work fine for single-line strings, but how about multi-line
    strings? For those, Tkinter offers us the `Text` widget, which we create like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `Text` widget is capable of much more than just multi-line text, and we'll
    explore a few of its more advanced capabilities in *Chapter 9*, *Improving the
    Look with Styles and Themes*. For now, though, we'll just use it for text.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our GUI would not be complete without a submit button for our survey, which
    is provided by the `Button` class, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We'll use this button to submit the survey and display some output. What widget
    could we use to display that output? It turns out that `Label` objects are useful
    for more than just static messages; we can use them to display messages at runtime
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add one for our program output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we''ve created the `Label` widget with no text (since we have no output
    yet). We''re also using a couple of additional arguments for `Label`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`anchor` determines which side of the widget the text will be stuck to if the
    widget is wider than the text. Tkinter sometimes uses cardinal directions (North,
    South, East, and West) abbreviated to their first letter whenever it needs to
    specify a side of a widget; in this case, the string `''w''` indicates the West
    (or left) side of the widget.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`justify` determines which side the text will align to when there are multiple
    lines of code. Unlike `anchor`, it uses conventional `''left''`, `''right''`,
    and `''center''` options.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`anchor` and `justify` may seem redundant, but they have slightly different
    behavior. In a multiline text situation, the text could be aligned to the center
    of each line, but the whole collection of lines could be anchored to the west
    side of the widget, for example. In other words, `anchor` affects the whole block
    of text with respect to the containing widget, while `justify` affects the individual
    lines of text with respect to the other lines.'
  prefs: []
  type: TYPE_NORMAL
- en: Tkinter has many more widgets, and we'll meet many of them throughout the remainder
    of the book.
  prefs: []
  type: TYPE_NORMAL
- en: Arranging our widgets with geometry managers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you were to add `root.mainloop()` to this script and execute it as-is, you
    would see… a blank window. Hmmm, what happened to all those widgets we just created?
    Well, you may remember from `hello_tkinter.py` that we need to use a geometry
    manager like `pack()` to actually place them somewhere on their parent widgets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tkinter has three geometry manager methods available:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pack()` is the oldest, and simply adds widgets to one of the four sides of
    a window sequentially.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`grid()` is newer and preferred, and allows you to place widgets within a 2-dimensional
    grid table.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`place()` is a third option, which allows you to put widgets at specific pixel
    coordinates. It is not recommended, as it responds poorly to changes in window
    sizes, font sizes, and screen resolution, so we won''t be using it in this book.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While `pack()` is certainly fine for simple layouts involving a handful of widgets,
    it doesn't scale so well to more complex layouts without an inordinate amount
    of `Frame` widget nesting. For this reason, most Tkinter programmers rely on the
    more modern `grid()` geometry manager. As the name suggests, `grid()` allows you
    to lay out widgets on a 2-dimensional grid, much like a spreadsheet document or
    HTML table. In this book, we'll focus primarily on `grid()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start laying out the widgets of our GUI using `grid()`, beginning with
    the `title` label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, a call to `grid()` will place the widget in the *first column*
    (column 0) of the *next empty row*. Thus, if we were to simply call `grid()` on
    the next widget, it would end up directly under the first. However, we can also
    be explicit about this using the `row` and `column` arguments, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Rows and columns count from the top-left corner of the widget, starting with
    `0`. Thus, `row=1, column=0` places the widget in the second row at the first
    column. If we want an additional column, all we need to do is place a widget in
    it, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The grid automatically expands whenever we add a widget to a new row or column.
    If a widget is larger than the current width of the column, or height of the row,
    all the cells in that column or row are expanded to accommodate it. We can tell
    a widget to span multiple columns or multiple rows using the `columnspan` and
    `rowspan` arguments, respectively. For example, it might be nice to have our title
    span the width of the form, so let''s amend it accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'As columns and rows expand, the widgets do not expand with them by default.
    If we want them to expand, we need to use the `sticky` argument, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '`sticky` tells Tkinter to stick the sides of the widget to the sides of its
    containing cell so that the widget will stretch as the cell expands. Like the
    `anchor` argument we learned about above, `sticky` takes cardinal directions:
    `n`, `s`, `e`, and `w`. In this case we''ve specified West and East, which will
    cause the widget to stretch horizontally if the column expands further.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As an alternative to the strings, we can also use Tkinter''s constants as arguments
    to `sticky`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: There is no real difference between using constants and string literals as far
    as Tkinter is concerned; however, the advantage of using constants is that your
    editing software can more easily identify if you've used a constant that doesn't
    exist than an invalid string.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `grid()` method allows us to add padding to our widgets as well, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '`padx` and `pady` indicate *external* padding – that is, they will expand the
    containing cell, but not the widget. `ipadx` and `ipady`, on the other hand, indicate
    *internal* padding. Specifying these arguments will expand the widget itself (and
    consequently the containing cell).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17578_01_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.5: Internal padding (ipadx, ipady) versus external padding (padx,
    pady)'
  prefs: []
  type: TYPE_NORMAL
- en: Tkinter does not allow us to mix geometry managers on the same parent widget;
    once we've called `grid()` on any child widget, a call to the `pack()` or `place()`
    method on a sibling widget will generate an error, and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can, however, use a different geometry manager on the sibling widget''s
    children. For example, we can use `pack()` to place the child widgets on the `plantain_frame`
    widgets, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `plantain_label` and `plantain_frame` widgets, as children of `root`, must
    be placed with `grid()`; `plantain_yes` and `plantain_no` are children of `plantain_frame`,
    though, so we can choose to use `pack()` (or `place()`) on them if we wish. The
    following diagram illustrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17578_01_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.6: Each widget''s children must use the same geometry manager method'
  prefs: []
  type: TYPE_NORMAL
- en: This ability to choose the geometry manager for each container widget gives
    us enormous flexibility in how we lay out a GUI. While the `grid()` method is
    certainly capable of specifying most layouts, there are times when the semantics
    of `pack()` or `place()` make more sense for a piece of our interface.
  prefs: []
  type: TYPE_NORMAL
- en: Although the `pack()` geometry manager shares some arguments with `grid()`,
    like `padx` and `pady`, most of the arguments are different. For example, the
    `side` argument used in the example determines which side widgets will be packed
    from, and the `fill` argument determines on which axis the widget will expand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the last few widgets to our window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note that we've stuck the `Text` widget (`banana_haiku_inp`) to all four sides
    of its container. This will cause it to expand both vertically and horizontally
    as the grid is stretched. Also notice that we've skipped to rows 99 and 100 for
    the last two widgets. Remember that unused rows are collapsed into nothing, so
    by skipping rows or columns we can leave space for future expansion of our GUI.
  prefs: []
  type: TYPE_NORMAL
- en: By default, Tkinter will make our window just large enough to contain all the
    widgets we place on it; but what happens if our window (or containing frame) becomes
    larger than the space required by our widgets? By default, the widgets will remain
    as they are, stuck to the upper-left side of the application. If we want the GUI
    to expand and fill the space available, we have to tell the parent widget which
    columns and rows of the grid will expand. We do this by using the parent widget's
    `columnconfigure()` and `rowconfigure()` methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we want our second column (the one containing most of the input
    widgets) to expand into unused space, we can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The first argument specifies which column (counting from 0) we want to affect.
    The keyword argument `weight` takes an integer which will determine how much of
    the extra space the column will get. With only one column specified, any value
    greater than 0 will cause that column to expand into the leftover space.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `rowconfigure()` method works the same way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This time, we've given two rows a `weight` value, but note that row `99` is
    given a weight of `2` while `100` is given a weight of `1`. In this configuration,
    any extra vertical space will be divided between rows `99` and `100`, but row
    `99` will get twice as much of it as row `100`.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, using a combination of `grid()`, `pack()` sub-frames, and some
    careful planning, we can achieve complex GUI layouts fairly easily in Tkinter.
  prefs: []
  type: TYPE_NORMAL
- en: Making the form actually do something
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've got a nice form all laid out now, complete with a submit button; so how
    do we make it actually do something? If you have only written procedural code
    in the past, you may be confused about how the flow of code works in a GUI application.
    Unlike a procedural script, the GUI cannot simply execute all the code from top
    to bottom. Instead, it has to respond to user actions, such as a button click
    or a keystroke, whenever and in whatever order they happen. Such actions are known
    as **events**. To make the program respond to an event, we need to **bind** the
    event to a function, which we call a **callback**.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few ways to bind events to callback functions in Tkinter; for a
    button, the simplest is to configure its `command` attribute, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `command` argument can be specified when creating a widget (for example,
    `submit_btn = Button(root, command=on_submit)`), or after creation of the widget
    using its `configure()` method. `configure()` allows you to change a widget's
    configuration after it's created, by passing in arguments just as you would when
    creating the widget.
  prefs: []
  type: TYPE_NORMAL
- en: In either case, `command` specifies a *reference* to a callback function to
    be called when the button is clicked. Note that we do not put parentheses after
    the function name here; doing so would cause the function to be called and its
    return value would be assigned to `command`. We only want a reference to the function
    here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The callback function needs to exist before we can pass it to `command`. So,
    before the call to `submit_btn.configure()`, let''s create the `on_submit()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: It is conventional to name callback functions in the format `on_<event_name>`
    when they are specifically created to respond to a particular event. However,
    it's not required, nor always appropriate (for example, if a function is a callback
    for many events).
  prefs: []
  type: TYPE_NORMAL
- en: A more powerful method of binding events is to use the widget's `bind()` method,
    which we will discuss in more detail in *Chapter 6*, *Planning for the Expansion
    of Our Application*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `on_submit()` callback is rather boring at the moment, so let''s make it
    better. Remove the `pass` statement and add in this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we'll do in this function is retrieve values from some of the
    inputs. For many inputs, the `get()` method is used to retrieve the current value
    of the widget. Note that this value will be returned as a string, even in the
    case of our `Spinbox`.
  prefs: []
  type: TYPE_NORMAL
- en: For our list widget, `color`, things are more complicated. Its `get()` method
    requires an index number for a choice, and returns the text for that index number.
    We can use the widget's `curselection()` method to get the selected index. If
    there are no selections made, the selected index will be an empty tuple. In that
    case, we'll just set `color` to an empty string. If there is a selection, we can
    pass the value to `get()`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting data from the `Text` widget is again slightly different. Its `get()`
    method requires two values, one for a starting location and another for an ending
    location. These follow a special syntax (which we'll discuss in *Chapter 3*, *Creating
    Basic Forms with Tkinter and Ttk Widgets*), but basically `1.0` means the first
    character of the first line, and `tk.END` is a constant that represents the end
    of the `Text` widget.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving data from our `Checkbutton` and `Radiobutton` is not possible without
    using Tkinter control variables, which we'll talk about in the section below,
    *Handling data with Tkinter control variables*.
  prefs: []
  type: TYPE_NORMAL
- en: Having gathered the data, our callback ends by updating the `text` property
    of the output `Label` widget with a string containing some of the entered data,
    then printing the user's haiku to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make this script runnable, finish with this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This executes the event loop of the script so that Tkinter can begin responding
    to events. Save your script and execute it, and you should see something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17578_01_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.7: Our banana survey application'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations, your banana survey works! Well, kind of. Let's see if we can
    get it fully working.
  prefs: []
  type: TYPE_NORMAL
- en: Handling data with Tkinter control variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've got the GUI layout well in hand, but our GUI has some problems. Retrieving
    data from our widgets is a bit of a mess, and we have no idea how to even get
    the values of the `Checkbutton` or `Radiobutton` widgets yet. In fact, if you
    try to operate the `Radiobutton` widgets, you'll see they are broken altogether.
    It seems we're missing a big piece of the puzzle.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we''re missing are Tkinter **control variables**. Control variables are
    special Tkinter objects that allow us to store data; there are four types of control
    variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '**StringVar**: Used to store strings of any length'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IntVar**: Used to store integers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DoubleVar**: Used to store floating-point values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**BooleanVar**: Used to store Boolean (True/False) values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'But wait! Python already has variables that can store those types of data and
    much more. Why do we need these classes? Simply put, these variable classes have
    some special abilities that regular Python variables lack, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: We can create a **two-way binding** between a control variable and a widget,
    so that if either the widget contents are changed or the variable contents are
    changed, both will be kept in sync.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can set up a **trace** on the variable. A trace binds a variable event (such
    as reading or updating the variable) to a callback function. (Traces will be discussed
    in *Chapter 4*, *Organizing Our Code with Classes*.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can establish relationships between widgets. For example, we can tell our
    two `Radiobutton` widgets that they're connected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at how control variables can help our survey application. Go back
    up to the top where the name input is defined and let''s add a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We can create a `StringVar` object by calling `StringVar()`; note that we've
    passed in the `root` window as the first argument. Control variables require a
    reference to a `root` window; however, in almost every case, they can work this
    out for themselves automatically, so it's rarely necessary to actually specify
    the `root` window here. It's important to understand, though, that *no control
    variable objects* *can be created until a Tk object exists*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have a `StringVar` object, we can bind it to our `Entry` widget by
    passing it to the `textvariable` argument. By doing this, the contents of the
    `name_inp` widget and the `name_var` variable are kept in sync. A call to the
    variable''s `get()` method will return the current contents of the box, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'For a checkbox, a `BooleanVar` is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This time, we've passed the variable to the `Checkbutton` using the `variable`
    argument. Button widgets will use the keyword `variable` to bind a control variable,
    while widgets that you type into or that return string values typically use the
    keyword `textvariable`.
  prefs: []
  type: TYPE_NORMAL
- en: Button widgets do take a `textvariable` argument as well, but it does not bind
    the value of the button; rather it binds to the text of the button's label. This
    feature allows you to dynamically update a button's text.
  prefs: []
  type: TYPE_NORMAL
- en: 'Variables can be initialized with a default value using the `value` argument,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've created an integer variable using `IntVar()` and set its value to
    `3`; when we launch the form, the `num_inp` widget will be set to `3`. Notice
    that, even though we think of the `Spinbox` as a number entry, it uses the `textvariable`
    argument to bind its control variable. A `Spinbox` widget can actually be used
    for more than just numbers, and as such its data is internally stored as text.
    However, by binding an `IntVar` or `DoubleVar` to it, the value retrieved will
    automatically be converted into an integer or float.
  prefs: []
  type: TYPE_NORMAL
- en: The automatic conversion to integer or float done by `IntVar` and `DoubleVar`
    can be a problem if users are able to type letters, symbols, or other invalid
    characters into an entry. Calling `get()` on an integer or double variable bound
    to a widget containing an invalid number string (for example, `'1.1.2'` or `'I
    like plantains'`) will raise an exception, causing our application to crash. In
    *Chapter 5*, *Reducing User Error with Validation and Automation*, we'll learn
    how to address this problem.
  prefs: []
  type: TYPE_NORMAL
- en: Previously, we'd used `Listbox` to display a list of options to the user. Unfortunately,
    `Listbox` doesn't work well with control variables, but there is another widget,
    `OptionMenu`, that does.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s replace our `color_inp` with an `OptionMenu` widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The `OptionMenu` holds a list of options as strings, so we need to create a
    `StringVar` to bind to it. Note that, unlike the `ListBox` widget, the `OptionMenu`
    allows us to specify the options as we create it. The `OptionMenu` constructor
    is also a bit different from other Tkinter widget constructors in that it takes
    the control variable and options as positional arguments, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In our survey code, we've added the options by using the unpack operator (`*`)
    to expand our `color_choices` list into positional arguments. We could also have
    just listed them explicitly, but doing it this way keeps our code a little neater.
  prefs: []
  type: TYPE_NORMAL
- en: We're going to learn about a better option for a drop-down list box when we
    discuss the Ttk widget set in *Chapter 3*, *Creating Basic Forms with Tkinter
    and Ttk Widgets*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Radiobutton` widget handles variables slightly differently from other
    widgets as well. To use `Radiobutton` widgets effectively, we bind all the buttons
    that are grouped together to the same control variable, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We can bind any kind of control variable to a `Radiobutton` widget, but we have
    to make sure to give each widget a `value` that matches the variable type. In
    this case, we're using the buttons for a `True`/`False` question, so `BooleanVar`
    is appropriate; we use the `value` argument to set one button to `True` and the
    other to `False`. When we call the variable's `get()` method, it will return the
    `value` argument of the selected button.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, not all Tkinter widgets work with control variables. Notably,
    our `Text` widget used for the `banana_haiku_inp` input cannot be bound to a variable,
    and (unlike `Listbox`) there is no alternative available. For the time being,
    we'll have to handle the `Text` entry widget as we have already done.
  prefs: []
  type: TYPE_NORMAL
- en: The Tkinter `Text` box does not support variables because it is much more than
    just multi-line text; it can contain images, rich text, and other objects that
    can't be represented in a simple string. However, in *Chapter 4*, *Organizing
    Our Code with Classes*, we'll implement a workaround for this that will allow
    us to bind a variable to a multi-line string widget.
  prefs: []
  type: TYPE_NORMAL
- en: 'Control variables are not just for binding to input widgets; we can also use
    them to update strings in non-interactive widgets like `Label`. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: With the `output_var` control variable bound to the `textvariable` argument
    of this `Label` widget, we can alter the text displayed by the label at runtime
    by updating `output_var`.
  prefs: []
  type: TYPE_NORMAL
- en: Using control variables in a callback function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we've created all these variables and bound them to our widgets, what
    can we do with them? Skip down to the callback function, `on_submit()`, and delete
    the code that is in it. We will re-write it using our control variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start with the `name` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'As mentioned earlier, the `get()` method is used to retrieve a variable''s
    value. The data type returned by `get()` depends on the type of variable, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`StringVar` returns a `str`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IntVar` returns an `int`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DoubleVar` returns a `float`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BooleanVar` returns a `bool`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that type conversion is performed whenever `get()` is called, so any incompatibility
    between what the widget contains and what the variable expects will raise an exception
    at this time. For example, if an `IntVar` is bound to an empty `Spinbox`, `get()`
    will raise an exception because an empty string cannot be cast to `int`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For that reason, it is sometimes wise to put `get()` in a `try/except` block,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Contrary to what an experienced Python programmer might expect, the exception
    raised for an invalid value is *not* `ValueError`. The conversion is actually
    done in Tcl/Tk, not in Python, so the exception raised is a `tkinter.TclError`.
    Here, we've caught the `TclError` and handled it by setting the number of bananas
    to `10,000`.
  prefs: []
  type: TYPE_NORMAL
- en: '`TclError` exceptions are raised *any time* Tcl/Tk has difficulty executing
    our translated Python calls, so to properly handle them you may need to extract
    the actual error string from the exception. This is a bit ugly and un-Pythonic,
    but Tkinter doesn''t leave us much choice.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Extracting the value of our `OptionMenu`, `Checkbutton`, and `Radiobutton`
    widgets is much cleaner now, as you can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: For the `OptionMenu`, `get()` returns the selected string. For `Checkbutton`,
    it returns `True` if the button is checked, or `False` if it is not. For the `Radiobutton`
    widgets, `get()` returns the `value` of the selected widget. The nice thing about
    control variables is that we don't have to know or care what kind of widget they
    were bound to; simply calling `get()` is sufficient to retrieve the user's input.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Text` widget, as mentioned before, doesn''t support control variables,
    so we have to get its content the old-fashioned way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have all that data, let''s build a message string for the survey
    taker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'To display our message for the user, we need to update the `output_var` variable.
    This is done using its `set()` method, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The `set()` method will update the control variable, which in turn will update
    the `Label` widget to which it is bound. This way, we can dynamically update displayed
    messages, widget labels, and other text in our application.
  prefs: []
  type: TYPE_NORMAL
- en: Remember to use `set()` to change a control variable's value! Using the assignment
    operator (`=`) will just overwrite the control variable object with a different
    object and you won't be able to work with it anymore. For example, `output_var
    = message` would just reassign the name `output_var` to the string object `message`,
    and the control variable object currently bound to `output_line` would become
    nameless.
  prefs: []
  type: TYPE_NORMAL
- en: The importance of control variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Hopefully, you see that control variables are a powerful and essential part
    of a Tkinter GUI. We will use them extensively in our applications to store and
    communicate data between Tkinter objects. In fact, once we''ve bound a variable
    to a widget, it''s often unnecessary to keep a reference to our widget. For example,
    our survey code would work just fine if we defined the output section like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Since we don't need to interact directly with the output `Label`, we can just
    create it and place it all in one line, without bothering to save a reference.
    Since the widget's parent retains a reference to the object, Python won't destroy
    the object, and we can retrieve its contents at any time using the control variable.
    Of course, if we later want to manipulate the widget in some way (changing its
    `font` value, for example), we'll need to keep a reference to it.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to install Tkinter and IDLE, and you've gotten
    a taste of how easy it is to start building a GUI with Tkinter. You learned how
    to create widgets, how to arrange them in the main window with the `grid()` geometry
    manager, and how to bind their contents to control variables like `StringVar`
    and `BooleanVar`. You also learned how to bind events like button clicks to callback
    functions, and how to retrieve and process widget data.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you'll start your new job at ABQ AgriLabs and be presented
    with a problem that will require your GUI programming skills. You will learn how
    to dissect this problem, develop a program specification, and design a user-friendly
    application that will be part of the solution.
  prefs: []
  type: TYPE_NORMAL
