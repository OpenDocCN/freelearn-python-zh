- en: Chapter 9. Other Tools and Techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've covered the core elements of testing in Python, but there are a number
    of peripheral methods and tools that will make your life easier. In this chapter,
    we're going to go through several of them in brief.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to:'
  prefs: []
  type: TYPE_NORMAL
- en: Discuss code coverage and how to get a code coverage report from Nose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discuss continuous integration and Buildbot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to integrate automated testing with Git, Mercurial, Bazaar, and Subversion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code coverage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tests tell you when the code you're testing doesn't work the way you thought
    it would, but they don't tell you a thing about the code you're not testing. They
    don't even tell you that the code you're not testing isn't being tested.
  prefs: []
  type: TYPE_NORMAL
- en: Code coverage is a technique to address that shortcoming. A code coverage tool
    watches while your tests are running, and keeps track of which lines of code are
    (and aren't) executed. After the tests have run, the tool will give you a report
    describing how well your tests cover the whole body of code.
  prefs: []
  type: TYPE_NORMAL
- en: It's desirable to have the coverage approach 100 percent, as you probably figured
    out already. Be careful not to focus on the coverage number too intensely, though,
    because it can be a bit misleading. Even if your tests execute every line of code
    in the program, they can easily not test everything that needs to be tested. This
    means that you can't take 100 percent coverage as certain proof that your tests
    are complete. On the other hand, there are times when some code really, truly
    doesn't need to be covered by the tests—some debugging support code, for example,
    or code generated by a user interface builder—and so less than 100 percent coverage
    is often completely acceptable.
  prefs: []
  type: TYPE_NORMAL
- en: Code coverage is a tool to give you an insight into what your tests are doing,
    and what they might be overlooking. It's not the definition of a good test suite.
  prefs: []
  type: TYPE_NORMAL
- en: Installing coverage.py
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We're going to be working with a module called `coverage.py`, which is—unsurprisingly—a
    code coverage tool for Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since `coverage.py` isn''t built in to Python, we''re going to need to download
    and install it. You can download the latest version from the Python Package Index
    at [http://pypi.python.org/pypi/coverage](http://pypi.python.org/pypi/coverage),
    but it will probably be easier simply to type the following from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We're going to walk through the steps of using `coverage.py` here, but if you
    want more information you can find it on the `coverage.py` home page at [http://nedbatchelder.com/code/coverage/](http://nedbatchelder.com/code/coverage/).
  prefs: []
  type: TYPE_NORMAL
- en: Using coverage.py with Nose
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We're going to create a little toy code module with tests, and then apply `coverage.py`
    to find out how much of the code the tests actually use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Put the following test code into `test_toy.py`. There are several problems
    with these tests, which we''ll discuss later, but they ought to run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: What we have here is a couple of `TestCase` classes with some very basic tests
    in them. These tests wouldn't be of much use in a real-world situation, but all
    we need them for is to illustrate how the code coverage tool works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Put the following code into `toy.py`. Notice the `if __name__ == ''__main__''`
    clause at the bottom; we haven''t dealt with one of these in a while, so I''ll
    remind you that the code inside that block runs `doctest` if we were to run the
    module with Python `toy.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have the code that satisfies the tests we just wrote. Like the tests
    themselves, this code wouldn't be of much use, but it serves as an illustration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go ahead and run Nose. It should find the tests, run them, and report that
    all is well. The problem is that some of the code isn''t ever tested. Let''s run
    the tests again, only this time we''ll tell Nose to use `coverage.py` to measure
    coverage while it''s running the tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This should give us an error report that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The dots at the top indicate passing tests, and the `OK` at the bottom says
    that the testing procedure worked as expected, but the part in between is new.
    That''s our coverage report. Apparently, our tests only cover three quarters of
    our code: out of the 12 statement lines in `toy.py`, three didn''t get executed.
    These lines were `16` and `19` through `20`.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The range `19-20` isn't any more useful than writing `19`, `20` would have been,
    but larger contiguous groups of lines are reported in the same way. That's a lot
    easier to parse, visually, than a soup of separate line numbers would be, especially
    when it's a range like `361-947`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we passed `--with-coverage` and `--cover-erase` as command-line parameters
    to Nose, what did they do? Well, `--with-coverage` is pretty straightforward:
    it told Nose to look for `coverage.py` and to use it while the tests get executed.
    That''s just what we wanted. The second parameter, `--cover-erase`, tells Nose
    to forget about any coverage information that was acquired during previous runs.
    By default, coverage information is aggregated across all of the uses of `coverage.py`.
    This allows you to run a set of tests using different testing frameworks or mechanisms,
    and then check the cumulative coverage. You still want to erase the data from
    previous test runs at the beginning of this process, though, and the `--cover-erase`
    command line is how you tell Nose to tell `coverage.py` that you''re starting
    a new.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Nose, being an integrated testing system, often renders the need to aggregate
    coverage information that is negligible. You'll almost always want `--cover-erase`
    when you invoke Nose with coverage enabled, so you should consider adding `cover-erase=1`
    to your Nose configuration file, as discussed in previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Another useful Nose command-line option is `--cover-package=PACKAGE`, which
    limits the coverage report to the specific package you're interested in. It didn't
    show up in our toy because we didn't import anything, but normally the coverage
    report includes every module or package that has code executed while your tests
    are running. The percentage of the standard library that is covered by your tests
    is usually not useful information. It can be convenient to limit the report to
    the things you actually want to know.
  prefs: []
  type: TYPE_NORMAL
- en: So, back to our coverage report. The missing lines were line `16` and lines
    `19` through `20`. Looking back at our code, we see that line `16` is the `__repr__`
    method. We really should have tested that, so the coverage check has revealed
    a hole in our tests that we should fix. Lines `19` and `20` are just code to run
    `doctest`, though. They're not something that we ought to be using under production
    conditions, so we can just ignore that coverage hole.
  prefs: []
  type: TYPE_NORMAL
- en: Code coverage can't detect problems with the tests themselves, in most cases.
    In the previous test code, the test for the `timestwo` method violates the isolation
    of units and invokes two different methods of `example_class`. Since one of the
    methods is the constructor, this might be acceptable, but the coverage checker
    isn't in a position to even see that there might be a problem. All it saw was
    more lines of code being covered. That's not a problem—it's how a coverage checker
    ought to work—but it's something to keep in mind. Coverage is useful, but high
    coverage doesn't equal good tests.
  prefs: []
  type: TYPE_NORMAL
- en: Version control integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most version control systems have the ability to run a program you've written
    in response to various events, as a way of customizing the version control system's
    behavior. These programs are commonly called **hooks**.
  prefs: []
  type: TYPE_NORMAL
- en: You can do all kinds of things by installing the right hook programs, but we're
    only going to focus on one use. We can make the version control program automatically
    run our tests, when we commit a new version of the code to the version control
    repository.
  prefs: []
  type: TYPE_NORMAL
- en: This is a fairly nifty trick, because this makes it difficult for test-breaking
    bugs to get into the repository unnoticed. Somewhat like code coverage, though,
    there's potential for trouble if it becomes a matter of policy rather than simply
    being a tool to make your life easier.
  prefs: []
  type: TYPE_NORMAL
- en: In most systems, you can write the hooks so that it's impossible to commit code
    that breaks tests. This might sound like a good idea at first, but it's really
    not. One reason for this is that one of the major purposes of a version control
    system is communication between developers, and interfering with that tends to
    be unproductive in the long run. Another reason is that it prevents anybody from
    committing partial solutions to problems, which means that things tend to get
    dumped into the repository in big chunks. Big commits are a problem because they
    make it hard to keep track of what changed, which adds to the confusion. There
    are better ways to make sure that you always have a working code base socked away
    somewhere, such as version control branches.
  prefs: []
  type: TYPE_NORMAL
- en: Git
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Git has become the most widely used distributed version control system, so we'll
    start there. By virtue of its being distributed, and thus decentralized, each
    Git user can control their own hooks. Cloning a repository will not clone the
    hooks for that repository.
  prefs: []
  type: TYPE_NORMAL
- en: If you don't have Git installed and don't plan to use it, you can skip this
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Git hooks are stored in the `.git/hooks/` subdirectory of the repository, each
    in its own file. The ones that we're interested in are the `pre-commit` hook and
    the `prepare-commit-msg` hook, either of which would potentially be suitable to
    our purposes.
  prefs: []
  type: TYPE_NORMAL
- en: All Git hooks are programs that Git executes automatically at a specific time.
    If a program named `pre-commit` exists in the `hooks` directory, it is run before
    a commit happens to check whether the commit is valid. If a program named `prepare-commit-msg`
    exists in the `hooks` directory, it is run to modify the default commit message
    that is presented to the user.
  prefs: []
  type: TYPE_NORMAL
- en: So, the `pre-commit` hook is the one we want if we want the failed tests to
    abort the commit (which is acceptable with Git, though I still don't recommend
    it because there's a command-line option, `--no-verify`, that allows the user
    to commit even if the tests fail). We can also run the tests from `pre-commit`
    and print the error report to the screen, while allowing the commit, regardless
    of the result, by simply producing a zero result code after we invoke Nose, instead
    of passing on the Nose result code.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to get fancier and add the test report to the commit message, or
    include it in the commit message file that will be shown to the user without actually
    adding it to the commit message, we need the `prepare‑commit‑msg` hook instead.
    This is what we're going to do in our example.
  prefs: []
  type: TYPE_NORMAL
- en: Example test-runner hook
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As I mentioned, Git hooks are programs, which means that we can write them in
    Python. If you place the following code in a file named `.git/hooks/prepare-commit-msg`
    (and make it executable) within one of your Git repositories, your Nose test suite
    will be run before each commit, and the test report will be presented to you when
    you are prompted for a commit message, but commented out so as to not actually
    end up in the Git log. If the tests convince you that you don't want to commit
    yet, all you have to do is leave the message blank to abort the commit.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In Windows, a file named `prepare-commit-msg` won''t be executable. You''ll
    need to name the actual hook program `prepare-commit-msg.py` and create a batch
    file named `prepare-commit-msg.bat` containing the following (assuming you have
    Python''s program directory in the `PATH` environment variable):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the first time I''ve mentioned the `pythonw` command. It''s a Windows-specific
    version of the Python interpreter with only one difference from the normal Python
    program: it does not open a terminal window for text-mode interactions. When a
    program is run via `pythonw` on Windows, nothing is visible to the user unless
    the program intentionally creates a user interface.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, without further ado, here is the Python program for a Git `prepare-commit-msg`
    hook that integrates Nose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, whenever you run a Git `commi`t command, you''ll get a Nose report:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Subversion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Subversion is the most popular freely available centralized version control
    system. There is a single server tasked with keeping track of everybody's changes,
    and this server also handles running hooks. This means that there is a single
    set of hooks that applies to everybody, probably under the control of a system
    administrator.
  prefs: []
  type: TYPE_NORMAL
- en: If you don't have Subversion installed and don't plan on using it, you can skip
    this section.
  prefs: []
  type: TYPE_NORMAL
- en: Subversion hooks are stored in files in the `hooks` subdirectory of the server's
    repository. Because Subversion operates on a centralized, client-server architecture,
    we're going to need both a client and a server setup for this example. They can
    both be on the same computer, but they'll be in different directories.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can work with concrete examples, we need a Subversion server. You
    can create one by making a new directory called `svnrepo`, and executing the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to configure the server to accept commits from us. To do this,
    we open the file called `conf/passwd`, and add the following line at the bottom:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we need to edit `conf/svnserve.conf`, and change the line reading:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The Subversion server needs to be running before we can interact with it. This
    is done by making sure that we''re in the `svnrepo` directory and then run the
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to import some test code into the Subversion repository. Make
    a directory and place the following (simple and silly) code into it in a file
    called `test_simple.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You can perform the import by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Subversion needs to know which text editor you want to use. If the preceding
    command fails, you probably need to tell it explicitly. You can do this by setting
    the `SVN_EDITOR` environment variable to the program path of the editor you prefer.
  prefs: []
  type: TYPE_NORMAL
- en: That command is likely to print out a gigantic, scary message about remembering
    passwords. In spite of the warnings, just say yes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve got the code imported, we need to check out a copy of it to
    work on. We can do this with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: From here on, in this example, we're going to be assuming that the Subversion
    server is running in a Unix-like environment (the clients might be running on
    Windows, but that doesn't matter for our purposes). The reason for this is that
    the details of the `post-commit` hook are significantly different on systems that
    don't have a Unix style shell scripting language, although the concepts remain
    the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code goes into a file called `hooks/post-commit` inside the Subversion
    server''s repository. The `svn update` and `svn checkout` lines have been wrapped
    around to fit on the page. In actual use, this wrapping should not be present:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Use the `chmod +x post-commit` command to make the hook executable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change to the `svn` checkout directory and edit `test_simple.py` to make one
    of the tests fail. We do this because, if all the tests pass, Subversion won''t
    show us anything to indicate that they were run at all. We only get feedback if
    they fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now commit the changes using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the commit triggered the execution of Nose, and that, if any of
    the tests fail, Subversion shows us the errors.
  prefs: []
  type: TYPE_NORMAL
- en: Because Subversion has one central set of hooks, they can be applied automatically
    to anybody who uses the repository.
  prefs: []
  type: TYPE_NORMAL
- en: Mercurial
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like Git, Mercurial is a distributed version control system with hooks that
    are managed by each user individually. Mercurial's hooks themselves, though, take
    a rather different form.
  prefs: []
  type: TYPE_NORMAL
- en: If you don't have Mercurial installed and don't plan to use it, you can skip
    this section.
  prefs: []
  type: TYPE_NORMAL
- en: Mercurial hooks can go in several different places. The two most useful are
    in your personal configuration file and in your repository configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: Your personal configuration file is `~/.hgrc` on Unix-like systems, and `%USERPROFILE%\Mercurial.ini`
    (which usually means `C:\Documents and Settings\<username>\Mercurial.ini`) on
    Windows-based systems.
  prefs: []
  type: TYPE_NORMAL
- en: Your repository configuration file is stored in a subdirectory of the repository,
    specifically, `.hg/hgrc`, on all systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re going to use the repository configuration file to store the hook, which
    means that the first thing we have to do is have a repository to work with. Make
    a new directory somewhere convenient, and execute the following command in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'One side-effect of this command is that a `.hg` subdirectory gets created.
    Change to this directory, and then create a text file called `hgrc` containing
    the following text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In the repository directory (that is, the parent of the `.hg` directory), we
    need some tests for Nose to run. Create a file called `test_simple.py` containing
    the following, admittedly silly, tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following commands to add the test file and commit it to the repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the commit triggered a run-through of the tests. Since we put the
    hook in the repository configuration file, it will only take effect on commits
    to this repository. If we'd instead put it into your personal configuration file,
    it would be called when you committed to any repository.
  prefs: []
  type: TYPE_NORMAL
- en: Bazaar
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like Git and Mercurial, Bazaar is a distributed version control system, and
    the individual users can control the hooks that apply to their own repositories.
    If you don't have Bazaar installed and don't plan to use it, you can skip this
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Bazaar hooks go in your plugins directory. On Unix-like systems, that's `~/.bazaar/plugins/`,
    while on Windows, it's `C:\Documents and Settings\<username>\Application Data\Bazaar\<version>\plugins\`.
    In either case, you might have to create the plugins subdirectory, if it doesn't
    already exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'Bazaar hooks are always written in Python, which is nice but, as I write this,
    they''re always written in Python 2, not Python 3\. This means that the hook code
    presented in this section is Python 2 code. Place the following code into a file
    called `run_nose.py` in the plugins directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Bazaar hooks are written in Python, so we've written our hook as a function
    called `run_nose`. Our `run_nose` function checks in order to make sure that the
    repository we're working on is local, and then it changes directories into the
    repository and runs Nose. We registered `run_nose` as a hook by calling `branch.Branch.hooks.install_named_hook`.
  prefs: []
  type: TYPE_NORMAL
- en: From now on, any time you commit to a Bazaar repository, Nose will search for
    and run whatever tests it can find within that repository. Note that this applies
    to any and all local repositories, as long as you're logged in to the same account
    on your computer.
  prefs: []
  type: TYPE_NORMAL
- en: Automated continuous integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Automated continuous integration tools are a step beyond using a version control
    hook to run your tests when you commit code to the repository. Instead of running
    your test suite once, an automated continuous integration system compiles your
    code (if need be) and runs your tests many times, in many different environments.
  prefs: []
  type: TYPE_NORMAL
- en: An automated continuous integration system might, for example, run your tests
    under Python versions 3.2, 3.3, and 3.4 on each of Windows, Linux, and Mac OS
    X. This not only lets you know about errors in your code, but also about the unexpected
    problems caused by the external environment. It's nice to know when that last
    patch broke the program on Windows, even though it worked like a charm on your
    Linux box.
  prefs: []
  type: TYPE_NORMAL
- en: Buildbot
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Buildbot is a popular automated continuous integration tool. Using Buildbot,
    you can create a network of "build slaves" that will check your code each time
    you commit it to your repository. This network can be quite large, and it can
    be distributed around the Internet, so Buildbot works even for projects with lots
    of developers spread around the world.
  prefs: []
  type: TYPE_NORMAL
- en: Buildbot's home page is at [http://buildbot.net/](http://buildbot.net/). By
    following links from this site, you can find the manual and download the latest
    version of the tool. At the time of writing, installing Buildbot with Python 3.x
    was slightly more complicated than just `pip install buildbot buildbot-slave`;
    thanks to some of the install files being targeted at Python 2.x. It's actually
    completely fine to install it with Python 2.x, and probably easier to deal with.
    Even if it's installed in Python 2.x, Buildbot can run your Python 3.x code inside
    the Python 3.x interpreter.
  prefs: []
  type: TYPE_NORMAL
- en: Buildbot operates in one of two modes, `buildmaster` and `buildslave`. A `buildmaster`
    mode manages a network of buildslaves, while the `buildslave` mode run the tests
    in their assorted environments.
  prefs: []
  type: TYPE_NORMAL
- en: Setup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To set up a `buildmaster` mode, create a directory for it to operate in and
    then run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding command, `<directory>` is the directory you just created for
    `buildbot` to work in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, to set up a `buildslave` mode, create a directory for it to operate
    in and then run the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding command, `<directory>` is the directory you just created for
    the `buildbot` to work in, `<host:port>` is the Internet host and port where the
    `buildmaster` can be found, and `<name>` and `<password>` are the login information
    that identifies this `buildslave` to the `buildmaster`. All of this information
    (except the directory) is determined by the operator of the `buildmaster`.
  prefs: []
  type: TYPE_NORMAL
- en: You should edit `<directory>/info/admin` and `<directory>/info/host` to contain
    the e-mail address you want associated with this `buildslave` and a description
    of the `buildslave` operating environment, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'On both the `buildmaster` and the `buildslave`, you''ll need to start up the
    `buildbot` background process. To do this, use the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding command, the directory is the directory you set up as the `buildmaster`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Configuring a `buildmaster` is a significant topic in itself, and one that
    we''re not going to address in detail. It''s fully described in Buildbot''s own
    documentation. We will provide a simple configuration file, though, for reference
    and quick setup. This particular configuration file assumes that you''re using
    Git, but it is not significantly different for other version control systems.
    The following code goes in the master''s `<directory>/master.cfg` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We just set up Buildbot to run our tests whenever it notices that our source
    code has been unchanged for two hours.
  prefs: []
  type: TYPE_NORMAL
- en: 'We told it to run the tests by adding a build step that runs `nose`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We told it to wait for the source code to be unchanged for two hours by adding
    a build scheduler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: To make effective use of this Buildbot configuration, you also need to install
    a version control hook that notifies Buildbot of changes. Generically, this can
    be done by calling the `buildbot sendchange` shell command from the hook.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have `buildmaster` and `buildslave` configured, have hooked `buildbot`
    into your version control system, and have started `buildmaster` and `buildslave`,
    you're in business.
  prefs: []
  type: TYPE_NORMAL
- en: Using Buildbot
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You''ll be able to see a report of the Buildbot status in your web browser,
    by navigating to the `buildbotURL` that you configured in the `master.cfg` file.
    One of the most useful reports is the so-called waterfall view. If the most recent
    commit passes the tests, you should see something similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Buildbot](img/3211OS_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'On the other hand, when the commit fails to pass the tests, you''ll see the
    screenshot as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Buildbot](img/3211OS_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Either way, you'll also see a history of earlier versions, whether or not they
    passed the tests as well as who made the changes and when, and what the output
    of the test command looked like.
  prefs: []
  type: TYPE_NORMAL
- en: You'll see similar information for each of the buildslaves, which means that,
    when the tests pass on some systems and fail on others, you'll know which system
    configurations are having the problem.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We learned a lot in this chapter about code coverage and plugging our tests
    into the other automation systems we use while writing software.
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, we covered what code coverage is and what it can tell us about
    our tests. We learned how to run Nose automatically when our version control software
    detects changes in the source code, and how to set up the Buildbot automated continuous
    integration system.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've learned about code coverage, version control hooks, and automated
    continuous integration, you're ready to tackle more or less anything. Congratulations!
  prefs: []
  type: TYPE_NORMAL
