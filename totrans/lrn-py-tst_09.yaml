- en: Chapter 9. Other Tools and Techniques
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 9 章。其他工具和技术
- en: We've covered the core elements of testing in Python, but there are a number
    of peripheral methods and tools that will make your life easier. In this chapter,
    we're going to go through several of them in brief.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了 Python 测试的核心元素，但还有一些外围方法和工具可以使你的生活更轻松。在本章中，我们将简要介绍其中的一些。
- en: 'In this chapter, we''re going to:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Discuss code coverage and how to get a code coverage report from Nose
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论代码覆盖率以及如何从 Nose 获取代码覆盖率报告
- en: Discuss continuous integration and Buildbot
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论持续集成和 Buildbot
- en: Learn how to integrate automated testing with Git, Mercurial, Bazaar, and Subversion
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何将自动化测试与 Git、Mercurial、Bazaar 和 Subversion 集成
- en: Code coverage
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码覆盖率
- en: Tests tell you when the code you're testing doesn't work the way you thought
    it would, but they don't tell you a thing about the code you're not testing. They
    don't even tell you that the code you're not testing isn't being tested.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 测试告诉你当你测试的代码没有按你想象的方式工作时，但它们不会告诉你关于你未测试的代码的任何信息。它们甚至不会告诉你你未测试的代码没有被测试。
- en: Code coverage is a technique to address that shortcoming. A code coverage tool
    watches while your tests are running, and keeps track of which lines of code are
    (and aren't) executed. After the tests have run, the tool will give you a report
    describing how well your tests cover the whole body of code.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 代码覆盖率是一种解决这一不足的技术。代码覆盖率工具在测试运行时进行监控，并跟踪哪些代码行被（和没有被）执行。测试运行完毕后，该工具将给出一份报告，描述你的测试覆盖整个代码库的情况。
- en: It's desirable to have the coverage approach 100 percent, as you probably figured
    out already. Be careful not to focus on the coverage number too intensely, though,
    because it can be a bit misleading. Even if your tests execute every line of code
    in the program, they can easily not test everything that needs to be tested. This
    means that you can't take 100 percent coverage as certain proof that your tests
    are complete. On the other hand, there are times when some code really, truly
    doesn't need to be covered by the tests—some debugging support code, for example,
    or code generated by a user interface builder—and so less than 100 percent coverage
    is often completely acceptable.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如你可能已经想到的，希望覆盖率接近 100%。但请注意，不要过于专注于覆盖率数字，因为它可能有些误导。即使你的测试执行了程序中的每一行代码，它们也可能很容易地没有测试到需要测试的所有内容。这意味着你不能将
    100% 的覆盖率作为测试完整的确定性证据。另一方面，有时某些代码确实不需要被测试——例如，一些调试支持代码或由用户界面构建器生成的代码——因此低于 100%
    的覆盖率通常是完全可以接受的。
- en: Code coverage is a tool to give you an insight into what your tests are doing,
    and what they might be overlooking. It's not the definition of a good test suite.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 代码覆盖率是一个工具，可以帮助你了解你的测试在做什么，以及它们可能忽略什么。它不是良好测试套件的定义。
- en: Installing coverage.py
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 coverage.py
- en: We're going to be working with a module called `coverage.py`, which is—unsurprisingly—a
    code coverage tool for Python.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个名为 `coverage.py` 的模块，这并不令人惊讶，它是一个用于 Python 的代码覆盖率工具。
- en: 'Since `coverage.py` isn''t built in to Python, we''re going to need to download
    and install it. You can download the latest version from the Python Package Index
    at [http://pypi.python.org/pypi/coverage](http://pypi.python.org/pypi/coverage),
    but it will probably be easier simply to type the following from the command line:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `coverage.py` 不是 Python 的内置工具，我们需要下载并安装它。你可以从 Python 包索引 [http://pypi.python.org/pypi/coverage](http://pypi.python.org/pypi/coverage)
    下载最新版本，但可能更简单的方法是从命令行输入以下内容：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We're going to walk through the steps of using `coverage.py` here, but if you
    want more information you can find it on the `coverage.py` home page at [http://nedbatchelder.com/code/coverage/](http://nedbatchelder.com/code/coverage/).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里介绍使用 `coverage.py` 的步骤，但如果你需要更多信息，可以在 `coverage.py` 的主页 [http://nedbatchelder.com/code/coverage/](http://nedbatchelder.com/code/coverage/)
    上找到。
- en: Using coverage.py with Nose
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 coverage.py 与 Nose
- en: We're going to create a little toy code module with tests, and then apply `coverage.py`
    to find out how much of the code the tests actually use.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个带有测试的小玩具代码模块，然后应用 `coverage.py` 来找出测试实际上使用了多少代码。
- en: 'Put the following test code into `test_toy.py`. There are several problems
    with these tests, which we''ll discuss later, but they ought to run:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下测试代码放入 `test_toy.py`。这些测试存在一些问题，我们将在后面讨论，但它们应该能运行：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: What we have here is a couple of `TestCase` classes with some very basic tests
    in them. These tests wouldn't be of much use in a real-world situation, but all
    we need them for is to illustrate how the code coverage tool works.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一对包含一些非常基本测试的`TestCase`类。这些测试在现实世界中的用途不大，但我们只需要它们来展示代码覆盖率工具的工作原理。
- en: 'Put the following code into `toy.py`. Notice the `if __name__ == ''__main__''`
    clause at the bottom; we haven''t dealt with one of these in a while, so I''ll
    remind you that the code inside that block runs `doctest` if we were to run the
    module with Python `toy.py`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码放入`toy.py`文件中。注意底部的`if __name__ == '__main__'`语句；我们有一段时间没有处理这类语句了，所以我会提醒你，如果我们用Python运行`toy.py`模块，该块内的代码将执行`doctest`：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we have the code that satisfies the tests we just wrote. Like the tests
    themselves, this code wouldn't be of much use, but it serves as an illustration.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们满足刚刚编写的测试的代码。像测试本身一样，这段代码也没有多大用处，但它起到了说明的作用。
- en: 'Go ahead and run Nose. It should find the tests, run them, and report that
    all is well. The problem is that some of the code isn''t ever tested. Let''s run
    the tests again, only this time we''ll tell Nose to use `coverage.py` to measure
    coverage while it''s running the tests:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行Nose。它应该会找到测试用例，运行它们，并报告一切正常。问题是有些代码从未被测试过。让我们再次运行测试，但这次我们将告诉Nose在运行测试时使用`coverage.py`来测量覆盖率：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This should give us an error report that looks like this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会给我们一个看起来像这样的错误报告：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The dots at the top indicate passing tests, and the `OK` at the bottom says
    that the testing procedure worked as expected, but the part in between is new.
    That''s our coverage report. Apparently, our tests only cover three quarters of
    our code: out of the 12 statement lines in `toy.py`, three didn''t get executed.
    These lines were `16` and `19` through `20`.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 顶部的点表示通过测试，底部的`OK`表示测试过程按预期工作，但中间的部分是新的。那是我们的覆盖率报告。显然，我们的测试只覆盖了我们代码的三分之三：在`toy.py`中的12条语句行中，有三条没有被执行。这些行是`16`到`20`行。
- en: Tip
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The range `19-20` isn't any more useful than writing `19`, `20` would have been,
    but larger contiguous groups of lines are reported in the same way. That's a lot
    easier to parse, visually, than a soup of separate line numbers would be, especially
    when it's a range like `361-947`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 范围`19-20`并不比直接写`19`、`20`更有用，但较大连续的行组将以相同的方式报告。这比单独行号的列表更容易解析，尤其是当它是像`361-947`这样的范围时。
- en: 'When we passed `--with-coverage` and `--cover-erase` as command-line parameters
    to Nose, what did they do? Well, `--with-coverage` is pretty straightforward:
    it told Nose to look for `coverage.py` and to use it while the tests get executed.
    That''s just what we wanted. The second parameter, `--cover-erase`, tells Nose
    to forget about any coverage information that was acquired during previous runs.
    By default, coverage information is aggregated across all of the uses of `coverage.py`.
    This allows you to run a set of tests using different testing frameworks or mechanisms,
    and then check the cumulative coverage. You still want to erase the data from
    previous test runs at the beginning of this process, though, and the `--cover-erase`
    command line is how you tell Nose to tell `coverage.py` that you''re starting
    a new.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将`--with-coverage`和`--cover-erase`作为命令行参数传递给Nose时，它们做了什么？嗯，`--with-coverage`相当直接：它告诉Nose寻找`coverage.py`并在测试执行时使用它。这正是我们想要的。第二个参数`--cover-erase`告诉Nose忘记在之前的运行中获取的任何覆盖率信息。默认情况下，覆盖率信息是跨所有`coverage.py`的使用聚合的。这允许你使用不同的测试框架或机制运行一系列测试，然后检查累积覆盖率。尽管如此，你仍然需要在开始此过程时清除之前测试运行的数据，而`--cover-erase`命令行就是告诉Nose告诉`coverage.py`你正在开始一个新的过程。
- en: Tip
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Nose, being an integrated testing system, often renders the need to aggregate
    coverage information that is negligible. You'll almost always want `--cover-erase`
    when you invoke Nose with coverage enabled, so you should consider adding `cover-erase=1`
    to your Nose configuration file, as discussed in previous chapters.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 作为集成测试系统，Nose通常不需要聚合可忽略的覆盖率信息。当你使用带有覆盖率功能的Nose时，几乎总是需要`--cover-erase`，所以你应该考虑将`cover-erase=1`添加到你的Nose配置文件中，正如前几章所讨论的那样。
- en: Another useful Nose command-line option is `--cover-package=PACKAGE`, which
    limits the coverage report to the specific package you're interested in. It didn't
    show up in our toy because we didn't import anything, but normally the coverage
    report includes every module or package that has code executed while your tests
    are running. The percentage of the standard library that is covered by your tests
    is usually not useful information. It can be convenient to limit the report to
    the things you actually want to know.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的Nose命令行选项是`--cover-package=PACKAGE`，它将覆盖率报告限制到你感兴趣的具体包。在我们的玩具示例中没有显示出来，因为我们没有导入任何东西，但通常覆盖率报告包括在测试运行期间执行过代码的每个模块或包。你的测试覆盖标准库的百分比通常不是有用的信息。限制报告只包括你真正想要知道的内容可能很方便。
- en: So, back to our coverage report. The missing lines were line `16` and lines
    `19` through `20`. Looking back at our code, we see that line `16` is the `__repr__`
    method. We really should have tested that, so the coverage check has revealed
    a hole in our tests that we should fix. Lines `19` and `20` are just code to run
    `doctest`, though. They're not something that we ought to be using under production
    conditions, so we can just ignore that coverage hole.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，回到我们的覆盖率报告。缺失的行是第`16`行以及第`19`行到第`20`行。回顾我们的代码，我们看到第`16`行是`__repr__`方法。我们真的应该测试那个，所以覆盖率检查揭示了我们应该修复的测试中的漏洞。第`19`行和第`20`行只是运行`doctest`的代码。它们不是我们在生产条件下应该使用的东西，所以我们可以忽略那个覆盖率漏洞。
- en: Code coverage can't detect problems with the tests themselves, in most cases.
    In the previous test code, the test for the `timestwo` method violates the isolation
    of units and invokes two different methods of `example_class`. Since one of the
    methods is the constructor, this might be acceptable, but the coverage checker
    isn't in a position to even see that there might be a problem. All it saw was
    more lines of code being covered. That's not a problem—it's how a coverage checker
    ought to work—but it's something to keep in mind. Coverage is useful, but high
    coverage doesn't equal good tests.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，代码覆盖率无法检测测试本身的问题。在前面的测试代码中，对`timestwo`方法的测试违反了单元隔离，调用了`example_class`的两个不同方法。由于其中一个方法是构造函数，这可能是可以接受的，但覆盖率检查器甚至无法看到可能存在问题的迹象。它只看到了更多被覆盖的代码行。这不是问题——这正是覆盖率检查器应该工作的方式——但这是需要记住的。覆盖率是有用的，但高覆盖率并不等于好的测试。
- en: Version control integration
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 版本控制集成
- en: Most version control systems have the ability to run a program you've written
    in response to various events, as a way of customizing the version control system's
    behavior. These programs are commonly called **hooks**.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数版本控制系统都有在响应各种事件时运行你编写的程序的能力，作为定制版本控制系统行为的一种方式。这些程序通常被称为**钩子**。
- en: You can do all kinds of things by installing the right hook programs, but we're
    only going to focus on one use. We can make the version control program automatically
    run our tests, when we commit a new version of the code to the version control
    repository.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 通过安装正确的钩子程序，你可以做各种事情，但我们只关注一个用途。我们可以让版本控制系统在将代码的新版本提交到版本控制仓库时自动运行我们的测试。
- en: This is a fairly nifty trick, because this makes it difficult for test-breaking
    bugs to get into the repository unnoticed. Somewhat like code coverage, though,
    there's potential for trouble if it becomes a matter of policy rather than simply
    being a tool to make your life easier.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当巧妙的技巧，因为它使得测试破坏性错误难以在仓库中不被注意地进入。然而，与代码覆盖率类似，如果它变成政策问题而不是仅仅作为一个使你的生活更轻松的工具，那么就可能存在潜在的问题。
- en: In most systems, you can write the hooks so that it's impossible to commit code
    that breaks tests. This might sound like a good idea at first, but it's really
    not. One reason for this is that one of the major purposes of a version control
    system is communication between developers, and interfering with that tends to
    be unproductive in the long run. Another reason is that it prevents anybody from
    committing partial solutions to problems, which means that things tend to get
    dumped into the repository in big chunks. Big commits are a problem because they
    make it hard to keep track of what changed, which adds to the confusion. There
    are better ways to make sure that you always have a working code base socked away
    somewhere, such as version control branches.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数系统中，你可以编写钩子，使得无法提交破坏测试的代码。一开始这可能听起来是个好主意，但实际上并不是。其中一个原因是版本控制系统的主要目的之一是开发者之间的沟通，而干扰这一点在长期来看往往是不生产的。另一个原因是它阻止任何人提交问题的部分解决方案，这意味着事情往往会以大块的形式被丢弃到仓库中。大提交是一个问题，因为它们使得跟踪发生了什么变得困难，这增加了混乱。有更好的方法来确保你始终有一个工作代码库保存在某个地方，比如版本控制分支。
- en: Git
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Git
- en: Git has become the most widely used distributed version control system, so we'll
    start there. By virtue of its being distributed, and thus decentralized, each
    Git user can control their own hooks. Cloning a repository will not clone the
    hooks for that repository.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Git 已经成为最广泛使用的分布式版本控制系统，因此我们将从这里开始。由于它是分布式的，因此是去中心化的，每个 Git 用户都可以控制自己的钩子。克隆一个仓库不会克隆该仓库的钩子。
- en: If you don't have Git installed and don't plan to use it, you can skip this
    section.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有安装 Git 并且不打算使用它，你可以跳过这一节。
- en: Git hooks are stored in the `.git/hooks/` subdirectory of the repository, each
    in its own file. The ones that we're interested in are the `pre-commit` hook and
    the `prepare-commit-msg` hook, either of which would potentially be suitable to
    our purposes.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Git 钩子存储在仓库的 `.git/hooks/` 子目录中，每个钩子都在自己的文件中。我们感兴趣的钩子是 `pre-commit` 钩子和 `prepare-commit-msg`
    钩子，任何一个都可能适合我们的目的。
- en: All Git hooks are programs that Git executes automatically at a specific time.
    If a program named `pre-commit` exists in the `hooks` directory, it is run before
    a commit happens to check whether the commit is valid. If a program named `prepare-commit-msg`
    exists in the `hooks` directory, it is run to modify the default commit message
    that is presented to the user.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 Git 钩子都是 Git 在特定时间自动执行的程序。如果 `hooks` 目录中存在名为 `pre-commit` 的程序，它将在提交发生之前运行，以检查提交是否有效。如果
    `hooks` 目录中存在名为 `prepare-commit-msg` 的程序，它将运行以修改显示给用户的默认提交信息。
- en: So, the `pre-commit` hook is the one we want if we want the failed tests to
    abort the commit (which is acceptable with Git, though I still don't recommend
    it because there's a command-line option, `--no-verify`, that allows the user
    to commit even if the tests fail). We can also run the tests from `pre-commit`
    and print the error report to the screen, while allowing the commit, regardless
    of the result, by simply producing a zero result code after we invoke Nose, instead
    of passing on the Nose result code.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们想要在测试失败时终止提交（虽然使用 Git 是可以接受的，尽管我仍然不推荐这样做，因为有一个命令行选项 `--no-verify` 允许用户即使测试失败也能提交），我们想要的钩子就是
    `pre-commit`。我们还可以从 `pre-commit` 运行测试并将错误报告打印到屏幕上，无论结果如何，通过在调用 Nose 后简单地产生一个零结果代码，而不是传递
    Nose 的结果代码，来允许提交。
- en: If we want to get fancier and add the test report to the commit message, or
    include it in the commit message file that will be shown to the user without actually
    adding it to the commit message, we need the `prepare‑commit‑msg` hook instead.
    This is what we're going to do in our example.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要更复杂一些，并将测试报告添加到提交信息中，或者将其包含在将显示给用户的提交信息文件中，而不实际将其添加到提交信息中，我们需要 `prepare‑commit‑msg`
    钩子。这正是我们将在示例中做的。
- en: Example test-runner hook
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例测试运行器钩子
- en: As I mentioned, Git hooks are programs, which means that we can write them in
    Python. If you place the following code in a file named `.git/hooks/prepare-commit-msg`
    (and make it executable) within one of your Git repositories, your Nose test suite
    will be run before each commit, and the test report will be presented to you when
    you are prompted for a commit message, but commented out so as to not actually
    end up in the Git log. If the tests convince you that you don't want to commit
    yet, all you have to do is leave the message blank to abort the commit.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我提到的，Git钩子是程序，这意味着我们可以用Python编写它们。如果你将以下代码放入一个名为`.git/hooks/prepare-commit-msg`的文件中（并使其可执行），在你的Git仓库中，你的Nose测试套件将在每次提交之前运行，当被提示输入提交信息时，测试报告将显示给你，但以注释形式，以便不会实际出现在Git日志中。如果你通过测试认为还不打算提交，你只需留下空白消息即可取消提交。
- en: Tip
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'In Windows, a file named `prepare-commit-msg` won''t be executable. You''ll
    need to name the actual hook program `prepare-commit-msg.py` and create a batch
    file named `prepare-commit-msg.bat` containing the following (assuming you have
    Python''s program directory in the `PATH` environment variable):'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows中，名为`prepare-commit-msg`的文件不会是可执行的。你需要将实际的钩子程序命名为`prepare-commit-msg.py`，并创建一个包含以下内容的批处理文件`prepare-commit-msg.bat`（假设Python程序目录在`PATH`环境变量中）：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This is the first time I''ve mentioned the `pythonw` command. It''s a Windows-specific
    version of the Python interpreter with only one difference from the normal Python
    program: it does not open a terminal window for text-mode interactions. When a
    program is run via `pythonw` on Windows, nothing is visible to the user unless
    the program intentionally creates a user interface.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我第一次提到`pythonw`命令。它是Python解释器的一个特定于Windows的版本，与正常Python程序只有一个区别：它不会为文本模式交互打开一个终端窗口。当程序通过Windows上的`pythonw`运行时，除非程序有意创建用户界面，否则用户看不到任何东西。
- en: 'So, without further ado, here is the Python program for a Git `prepare-commit-msg`
    hook that integrates Nose:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，无需多言，下面是用于Git `prepare-commit-msg`钩子的Python程序，该程序集成了Nose：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, whenever you run a Git `commi`t command, you''ll get a Nose report:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每次你运行Git `commi`t命令时，你都会得到一个Nose报告：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Subversion
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Subversion
- en: Subversion is the most popular freely available centralized version control
    system. There is a single server tasked with keeping track of everybody's changes,
    and this server also handles running hooks. This means that there is a single
    set of hooks that applies to everybody, probably under the control of a system
    administrator.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Subversion是最受欢迎的免费集中式版本控制系统。有一个服务器负责跟踪每个人的更改，并且这个服务器还处理运行钩子。这意味着有一个适用于所有人的单一钩子集，可能由系统管理员控制。
- en: If you don't have Subversion installed and don't plan on using it, you can skip
    this section.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有安装Subversion并且不打算使用它，你可以跳过这一部分。
- en: Subversion hooks are stored in files in the `hooks` subdirectory of the server's
    repository. Because Subversion operates on a centralized, client-server architecture,
    we're going to need both a client and a server setup for this example. They can
    both be on the same computer, but they'll be in different directories.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Subversion钩子存储在服务器仓库的`hooks`子目录中的文件中。由于Subversion在集中式、客户端-服务器架构上运行，我们需要为这个示例设置客户端和服务器。它们可以位于同一台计算机上，但它们将在不同的目录中。
- en: 'Before we can work with concrete examples, we need a Subversion server. You
    can create one by making a new directory called `svnrepo`, and executing the following
    command:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以使用具体示例之前，我们需要一个Subversion服务器。你可以通过创建一个名为`svnrepo`的新目录并执行以下命令来创建一个：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, we need to configure the server to accept commits from us. To do this,
    we open the file called `conf/passwd`, and add the following line at the bottom:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要配置服务器以接受我们的提交。为此，我们打开名为`conf/passwd`的文件，并在底部添加以下行：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then we need to edit `conf/svnserve.conf`, and change the line reading:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要编辑`conf/svnserve.conf`文件，并更改读取的行：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'into the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 转换为以下内容：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The Subversion server needs to be running before we can interact with it. This
    is done by making sure that we''re in the `svnrepo` directory and then run the
    command:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够与之交互之前，Subversion服务器需要运行。这是通过确保我们位于`svnrepo`目录中，然后运行以下命令来完成的：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, we need to import some test code into the Subversion repository. Make
    a directory and place the following (simple and silly) code into it in a file
    called `test_simple.py`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将一些测试代码导入到Subversion仓库中。创建一个目录，并将以下（简单而愚蠢的）代码放入一个名为`test_simple.py`的文件中：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You can perform the import by executing the following command:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过执行以下命令来执行导入：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Subversion needs to know which text editor you want to use. If the preceding
    command fails, you probably need to tell it explicitly. You can do this by setting
    the `SVN_EDITOR` environment variable to the program path of the editor you prefer.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Subversion 需要知道您想使用哪个文本编辑器。如果前面的命令失败，您可能需要明确地告诉它。您可以通过将 `SVN_EDITOR` 环境变量设置为所偏好的编辑器的程序路径来实现这一点。
- en: That command is likely to print out a gigantic, scary message about remembering
    passwords. In spite of the warnings, just say yes.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令可能会打印出一个巨大、令人恐惧的消息，关于记住密码。尽管有警告，但只需说“是”。
- en: 'Now that we''ve got the code imported, we need to check out a copy of it to
    work on. We can do this with the following command:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经导入了代码，我们需要检出它的一个副本来工作。我们可以使用以下命令来完成：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Tip
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: From here on, in this example, we're going to be assuming that the Subversion
    server is running in a Unix-like environment (the clients might be running on
    Windows, but that doesn't matter for our purposes). The reason for this is that
    the details of the `post-commit` hook are significantly different on systems that
    don't have a Unix style shell scripting language, although the concepts remain
    the same.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，在这个例子中，我们将假设 Subversion 服务器正在类 Unix 环境中运行（客户端可能运行在 Windows 上，但这对我们来说并不重要）。这样做的原因是，在非
    Unix 风格的 shell 脚本语言系统上，`post-commit` 钩子的细节有显著不同，尽管概念保持不变。
- en: 'The following code goes into a file called `hooks/post-commit` inside the Subversion
    server''s repository. The `svn update` and `svn checkout` lines have been wrapped
    around to fit on the page. In actual use, this wrapping should not be present:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将放入 Subversion 服务器仓库内名为 `hooks/post-commit` 的文件中。`svn update` 和 `svn checkout`
    行已被调整以适应页面。在实际使用中，这种调整不应存在：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Use the `chmod +x post-commit` command to make the hook executable.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `chmod +x post-commit` 命令使钩子可执行。
- en: 'Change to the `svn` checkout directory and edit `test_simple.py` to make one
    of the tests fail. We do this because, if all the tests pass, Subversion won''t
    show us anything to indicate that they were run at all. We only get feedback if
    they fail:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到 `svn` 检出目录并编辑 `test_simple.py` 以使其中一个测试失败。我们这样做是因为，如果所有测试都通过，Subversion
    不会显示任何信息来表明它们已被运行。只有在它们失败时我们才会得到反馈：
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now commit the changes using the following command:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以使用以下命令提交更改：
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Notice that the commit triggered the execution of Nose, and that, if any of
    the tests fail, Subversion shows us the errors.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到提交触发了 Nose 的执行，并且如果任何测试失败，Subversion 会显示错误。
- en: Because Subversion has one central set of hooks, they can be applied automatically
    to anybody who uses the repository.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Subversion 有一个中央集成的钩子集，它们可以自动应用于使用该仓库的任何人。
- en: Mercurial
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Mercurial
- en: Like Git, Mercurial is a distributed version control system with hooks that
    are managed by each user individually. Mercurial's hooks themselves, though, take
    a rather different form.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Git 一样，Mercurial 是一个分布式版本控制系统，其钩子由每个用户单独管理。然而，Mercurial 的钩子本身采取了相当不同的形式。
- en: If you don't have Mercurial installed and don't plan to use it, you can skip
    this section.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有安装 Mercurial 并且不打算使用它，您可以跳过这一部分。
- en: Mercurial hooks can go in several different places. The two most useful are
    in your personal configuration file and in your repository configuration file.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Mercurial 钩子可以放在几个不同的位置。最有用的是在您的个人配置文件和您的仓库配置文件中。
- en: Your personal configuration file is `~/.hgrc` on Unix-like systems, and `%USERPROFILE%\Mercurial.ini`
    (which usually means `C:\Documents and Settings\<username>\Mercurial.ini`) on
    Windows-based systems.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在类 Unix 系统上，您的个人配置文件是 `~/.hgrc`，而在基于 Windows 的系统上通常是 `%USERPROFILE%\Mercurial.ini`（通常意味着
    `C:\Documents and Settings\<username>\Mercurial.ini`)。
- en: Your repository configuration file is stored in a subdirectory of the repository,
    specifically, `.hg/hgrc`, on all systems.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您的仓库配置文件存储在仓库的子目录中，具体来说，在所有系统上的 `.hg/hgrc`。
- en: 'We''re going to use the repository configuration file to store the hook, which
    means that the first thing we have to do is have a repository to work with. Make
    a new directory somewhere convenient, and execute the following command in it:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用仓库配置文件来存储钩子，这意味着我们首先要做的是拥有一个可以工作的仓库。在某个方便的地方创建一个新的目录，并在其中执行以下命令：
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'One side-effect of this command is that a `.hg` subdirectory gets created.
    Change to this directory, and then create a text file called `hgrc` containing
    the following text:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令的一个副作用是创建了一个 `.hg` 子目录。切换到这个目录，然后创建一个名为 `hgrc` 的文本文件，包含以下文本：
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the repository directory (that is, the parent of the `.hg` directory), we
    need some tests for Nose to run. Create a file called `test_simple.py` containing
    the following, admittedly silly, tests:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在仓库目录中（即 `.hg` 目录的父目录），我们需要一些 Nose 可以运行的测试。创建一个名为 `test_simple.py` 的文件，包含以下显然有些愚蠢的测试：
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Run the following commands to add the test file and commit it to the repository:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以添加测试文件并将其提交到仓库：
- en: '[PRE22]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Notice that the commit triggered a run-through of the tests. Since we put the
    hook in the repository configuration file, it will only take effect on commits
    to this repository. If we'd instead put it into your personal configuration file,
    it would be called when you committed to any repository.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到提交触发了测试的运行。因为我们把钩子放在了仓库配置文件中，所以它只对这个仓库的提交生效。如果我们把它放在你的个人配置文件中，它会在你提交到任何仓库时被调用。
- en: Bazaar
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Bazaar
- en: Like Git and Mercurial, Bazaar is a distributed version control system, and
    the individual users can control the hooks that apply to their own repositories.
    If you don't have Bazaar installed and don't plan to use it, you can skip this
    section.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 Git 和 Mercurial，Bazaar 是一个分布式版本控制系统，个人用户可以控制应用于他们自己仓库的钩子。如果你没有安装 Bazaar
    并且不打算使用它，你可以跳过这一节。
- en: Bazaar hooks go in your plugins directory. On Unix-like systems, that's `~/.bazaar/plugins/`,
    while on Windows, it's `C:\Documents and Settings\<username>\Application Data\Bazaar\<version>\plugins\`.
    In either case, you might have to create the plugins subdirectory, if it doesn't
    already exist.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Bazaar 钩子放在你的插件目录中。在类 Unix 系统上，这是 `~/.bazaar/plugins/`，而在 Windows 上，它是 `C:\Documents
    and Settings\<username>\Application Data\Bazaar\<version>\plugins\`。在任何情况下，如果你还没有创建插件子目录，你可能需要创建它。
- en: 'Bazaar hooks are always written in Python, which is nice but, as I write this,
    they''re always written in Python 2, not Python 3\. This means that the hook code
    presented in this section is Python 2 code. Place the following code into a file
    called `run_nose.py` in the plugins directory:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Bazaar 钩子总是用 Python 编写的，这很好，但在我写这篇文章的时候，它们总是用 Python 2 编写的，而不是 Python 3。这意味着本节中展示的钩子代码是
    Python 2 代码。将以下代码放入插件目录中的 `run_nose.py` 文件中：
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Bazaar hooks are written in Python, so we've written our hook as a function
    called `run_nose`. Our `run_nose` function checks in order to make sure that the
    repository we're working on is local, and then it changes directories into the
    repository and runs Nose. We registered `run_nose` as a hook by calling `branch.Branch.hooks.install_named_hook`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Bazaar 钩子是用 Python 编写的，所以我们把钩子写成了一个名为 `run_nose` 的函数。我们的 `run_nose` 函数会检查以确保我们正在工作的仓库是本地的，然后它会切换到仓库目录并运行
    Nose。我们通过调用 `branch.Branch.hooks.install_named_hook` 注册了 `run_nose` 作为钩子。
- en: From now on, any time you commit to a Bazaar repository, Nose will search for
    and run whatever tests it can find within that repository. Note that this applies
    to any and all local repositories, as long as you're logged in to the same account
    on your computer.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，每次你向 Bazaar 仓库提交时，Nose 都会搜索并运行该仓库内能找到的任何测试。请注意，这适用于任何本地仓库，只要你在电脑上登录的是同一个账户。
- en: Automated continuous integration
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化持续集成
- en: Automated continuous integration tools are a step beyond using a version control
    hook to run your tests when you commit code to the repository. Instead of running
    your test suite once, an automated continuous integration system compiles your
    code (if need be) and runs your tests many times, in many different environments.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化的持续集成工具在将代码提交到仓库时运行测试的版本控制钩子之上。自动化的持续集成系统不是只运行一次测试套件，而是编译你的代码（如果需要的话）并在许多不同的环境中多次运行你的测试。
- en: An automated continuous integration system might, for example, run your tests
    under Python versions 3.2, 3.3, and 3.4 on each of Windows, Linux, and Mac OS
    X. This not only lets you know about errors in your code, but also about the unexpected
    problems caused by the external environment. It's nice to know when that last
    patch broke the program on Windows, even though it worked like a charm on your
    Linux box.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个自动化的持续集成系统可能会在 Windows、Linux 和 Mac OS X 的每个系统上运行 Python 3.2、3.3 和 3.4 版本的测试。这不仅让你知道代码中的错误，还能让你了解由外部环境引起的意外问题。知道最后一个补丁在
    Windows 上破坏了程序，尽管在你的 Linux 系统上运行得很好，这会让人感到很高兴。
- en: Buildbot
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Buildbot
- en: Buildbot is a popular automated continuous integration tool. Using Buildbot,
    you can create a network of "build slaves" that will check your code each time
    you commit it to your repository. This network can be quite large, and it can
    be distributed around the Internet, so Buildbot works even for projects with lots
    of developers spread around the world.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Buildbot是一个流行的自动化持续集成工具。使用Buildbot，您可以创建一个“构建奴隶”网络，每次您将代码提交到您的仓库时，它都会检查您的代码。这个网络可以相当大，并且可以分布在全球互联网上，因此Buildbot甚至适用于有大量开发者分布在世界各地的项目。
- en: Buildbot's home page is at [http://buildbot.net/](http://buildbot.net/). By
    following links from this site, you can find the manual and download the latest
    version of the tool. At the time of writing, installing Buildbot with Python 3.x
    was slightly more complicated than just `pip install buildbot buildbot-slave`;
    thanks to some of the install files being targeted at Python 2.x. It's actually
    completely fine to install it with Python 2.x, and probably easier to deal with.
    Even if it's installed in Python 2.x, Buildbot can run your Python 3.x code inside
    the Python 3.x interpreter.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Buildbot的主页是[http://buildbot.net/](http://buildbot.net/)。通过从该网站上的链接，您可以找到手册并下载工具的最新版本。在撰写本文时，使用Python
    3.x安装Buildbot比简单地`pip install buildbot buildbot-slave`要复杂一些；多亏了一些安装文件针对Python
    2.x。实际上，使用Python 2.x安装它可能更容易处理。即使安装在Python 2.x中，Buildbot也可以在Python 3.x解释器中运行您的Python
    3.x代码。
- en: Buildbot operates in one of two modes, `buildmaster` and `buildslave`. A `buildmaster`
    mode manages a network of buildslaves, while the `buildslave` mode run the tests
    in their assorted environments.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Buildbot在两种模式之一中运行，即`buildmaster`和`buildslave`。`buildmaster`模式管理构建奴隶网络，而`buildslave`模式在其各自的环境中运行测试。
- en: Setup
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置
- en: 'To set up a `buildmaster` mode, create a directory for it to operate in and
    then run the following command:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置`buildmaster`模式，创建一个用于其操作的目录，然后运行以下命令：
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the preceding command, `<directory>` is the directory you just created for
    `buildbot` to work in.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的命令中，`<directory>`是您为`buildbot`设置的目录。
- en: 'Similarly, to set up a `buildslave` mode, create a directory for it to operate
    in and then run the command:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，要设置`buildslave`模式，创建一个用于其操作的目录，然后运行以下命令：
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding command, `<directory>` is the directory you just created for
    the `buildbot` to work in, `<host:port>` is the Internet host and port where the
    `buildmaster` can be found, and `<name>` and `<password>` are the login information
    that identifies this `buildslave` to the `buildmaster`. All of this information
    (except the directory) is determined by the operator of the `buildmaster`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的命令中，`<directory>`是您为`buildbot`设置的目录，`<host:port>`是`buildmaster`可以找到的互联网主机和端口，而`<name>`和`<password>`是用于识别此`buildslave`给`buildmaster`的登录信息。所有这些信息（除了目录外）都由`buildmaster`的操作者确定。
- en: You should edit `<directory>/info/admin` and `<directory>/info/host` to contain
    the e-mail address you want associated with this `buildslave` and a description
    of the `buildslave` operating environment, respectively.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该编辑`<directory>/info/admin`和`<directory>/info/host`，以便包含您希望与该`buildslave`关联的电子邮件地址以及`buildslave`操作环境的描述。
- en: 'On both the `buildmaster` and the `buildslave`, you''ll need to start up the
    `buildbot` background process. To do this, use the command:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在`buildmaster`和`buildslave`上，您都需要启动`buildbot`后台进程。为此，请使用以下命令：
- en: '[PRE26]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the preceding command, the directory is the directory you set up as the `buildmaster`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的命令中，目录是您为`buildmaster`设置的目录。
- en: 'Configuring a `buildmaster` is a significant topic in itself, and one that
    we''re not going to address in detail. It''s fully described in Buildbot''s own
    documentation. We will provide a simple configuration file, though, for reference
    and quick setup. This particular configuration file assumes that you''re using
    Git, but it is not significantly different for other version control systems.
    The following code goes in the master''s `<directory>/master.cfg` file:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 配置`buildmaster`是一个重要的话题，但我们不会详细讨论。它已经在Buildbot的官方文档中完全描述。不过，我们将提供一个简单的配置文件，供参考和快速设置。这个特定的配置文件假设您正在使用Git，但对于其他版本控制系统来说并没有显著差异。以下代码应放在主机的`<directory>/master.cfg`文件中：
- en: '[PRE27]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We just set up Buildbot to run our tests whenever it notices that our source
    code has been unchanged for two hours.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是设置了Buildbot，以便在它注意到我们的源代码两小时未更改时运行我们的测试。
- en: 'We told it to run the tests by adding a build step that runs `nose`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过添加一个运行`nose`的构建步骤来告诉它运行测试：
- en: '[PRE28]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We told it to wait for the source code to be unchanged for two hours by adding
    a build scheduler:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过添加构建调度器来告诉它等待源代码两小时不变：
- en: '[PRE29]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: To make effective use of this Buildbot configuration, you also need to install
    a version control hook that notifies Buildbot of changes. Generically, this can
    be done by calling the `buildbot sendchange` shell command from the hook.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效地使用这个 Buildbot 配置，你还需要安装一个版本控制钩子，该钩子会通知 Buildbot 有更改。通常，这可以通过从钩子中调用 `buildbot
    sendchange` 命令来完成。
- en: Once you have `buildmaster` and `buildslave` configured, have hooked `buildbot`
    into your version control system, and have started `buildmaster` and `buildslave`,
    you're in business.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你配置了 `buildmaster` 和 `buildslave`，将 `buildbot` 集成到你的版本控制系统，并启动了 `buildmaster`
    和 `buildslave`，你就可以开始工作了。
- en: Using Buildbot
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Buildbot
- en: 'You''ll be able to see a report of the Buildbot status in your web browser,
    by navigating to the `buildbotURL` that you configured in the `master.cfg` file.
    One of the most useful reports is the so-called waterfall view. If the most recent
    commit passes the tests, you should see something similar to the following screenshot:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在网页浏览器中导航到你在 `master.cfg` 文件中配置的 `buildbotURL` 来查看 Buildbot 状态的报告。其中最有用的报告之一是所谓的瀑布视图。如果最近的提交通过了测试，你应该会看到以下截图类似的内容：
- en: '![Using Buildbot](img/3211OS_09_01.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Buildbot](img/3211OS_09_01.jpg)'
- en: 'On the other hand, when the commit fails to pass the tests, you''ll see the
    screenshot as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当提交未能通过测试时，你会看到以下截图：
- en: '![Using Buildbot](img/3211OS_09_02.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Buildbot](img/3211OS_09_02.jpg)'
- en: Either way, you'll also see a history of earlier versions, whether or not they
    passed the tests as well as who made the changes and when, and what the output
    of the test command looked like.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 不论哪种情况，你也会看到早期版本的历史记录，无论它们是否通过了测试，以及谁在何时进行了更改，以及测试命令的输出看起来像什么。
- en: You'll see similar information for each of the buildslaves, which means that,
    when the tests pass on some systems and fail on others, you'll know which system
    configurations are having the problem.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个构建奴隶，你都会看到类似的信息，这意味着，当某些系统上的测试通过而其他系统上的测试失败时，你会知道哪些系统配置存在问题。
- en: Summary
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We learned a lot in this chapter about code coverage and plugging our tests
    into the other automation systems we use while writing software.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们关于代码覆盖率和将我们的测试集成到我们编写软件时使用的其他自动化系统中学到了很多。
- en: Specifically, we covered what code coverage is and what it can tell us about
    our tests. We learned how to run Nose automatically when our version control software
    detects changes in the source code, and how to set up the Buildbot automated continuous
    integration system.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们涵盖了代码覆盖率是什么以及它能告诉我们关于测试的什么信息。我们学习了当我们的版本控制软件检测到源代码中的更改时如何自动运行 Nose，以及如何设置
    Buildbot 自动化持续集成系统。
- en: Now that we've learned about code coverage, version control hooks, and automated
    continuous integration, you're ready to tackle more or less anything. Congratulations!
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了代码覆盖率、版本控制钩子和自动化持续集成，你就可以应对更多或更少的事情了。恭喜你！
