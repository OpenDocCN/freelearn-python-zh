- en: '*Chapter 25*: The Command Pattern'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第25章*：命令模式'
- en: In this chapter, we will cover the **command pattern**. Using this design pattern,
    we can encapsulate an operation, such as *copy and paste*, as an object. The command
    pattern is also great for grouping multiple commands. It's useful for implementing
    macros, multilevel undoing, and transactions. Throughout our discussions, we will
    learn about the idea of treating an operation as an object and use this command
    mindset to handle application transactions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍**命令模式**。使用这种设计模式，我们可以将操作（如“复制粘贴”）封装为一个对象。命令模式也非常适合组合多个命令。它对于实现宏、多级撤销和事务非常有用。在我们的讨论过程中，我们将了解将操作视为对象的想法，并使用这种命令思维来处理应用程序事务。
- en: 'We will discuss the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论以下内容：
- en: Understanding the command pattern
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解命令模式
- en: Real-world examples
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现实世界示例
- en: Use cases
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用例
- en: Implementation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现方式
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code files for this chapter can be accessed through this link: [https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter25](https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter25).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以通过以下链接访问：[https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter25](https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter25)。
- en: Understanding the command pattern
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解命令模式
- en: Most applications nowadays have an **undo** operation. It is hard to imagine,
    but undo did not exist in any software for many years. Undo was introduced in
    1974 ([j.mp/wiundo](http://j.mp/wiundo)), but Fortran and Lisp, two programming
    languages that are still widely used, were created in 1957 and 1958, respectively
    ([j.mp/proghist](http://j.mp/proghist))! The user had no easy way to fix a mistake.
    I wouldn't like to have been an application user during those years.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现今的大多数应用程序都有**撤销**操作。这很难想象，但在许多年前，任何软件中都没有撤销功能。撤销功能是在1974年引入的([j.mp/wiundo](http://j.mp/wiundo))，但Fortran和Lisp这两种至今仍被广泛使用的编程语言分别在1957年和1958年创建([j.mp/proghist](http://j.mp/proghist))！用户没有简单的方法来修复错误。我不希望在那几年里成为一个应用程序用户。
- en: 'Enough with the history! We want to know how we can implement the undo functionality
    in our applications, and since you have read the title of this chapter, you already
    know which design pattern is recommended to implement undo: the command pattern.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 历史就到这里吧！我们想知道如何在我们的应用程序中实现撤销功能，既然你已经阅读了本章的标题，你就已经知道推荐使用哪种设计模式来实现撤销：命令模式。
- en: 'The command design pattern helps us encapsulate an operation (undo, redo, copy,
    paste, and so forth) as an object. What this simply means is that we create a
    class that contains all the logic and the methods required to implement the operation.
    The advantages of doing this are as follows ([j.mp/cmdpattern](http://j.mp/cmdpattern)):'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 命令设计模式帮助我们封装操作（撤销、重做、复制、粘贴等）为一个对象。这简单意味着我们创建一个包含所有逻辑和实现操作所需方法的类。这样做的好处如下([j.mp/cmdpattern](http://j.mp/cmdpattern))：
- en: We don't have to execute a command directly. It can be executed at will.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不必直接执行命令。它可以在任何时候执行。
- en: The object that invokes the command is decoupled from the object that knows
    how to perform it. The invoker does not need to know any implementation details
    about the command.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用命令的对象与知道如何执行它的对象解耦。调用者不需要了解命令的任何实现细节。
- en: If it makes sense, multiple commands can be grouped to allow the invoker to
    execute them in order. This is useful, for instance, when implementing a multilevel
    undo command.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有道理，可以将多个命令组合起来，以便调用者可以按顺序执行它们。这在实现多级撤销命令时非常有用。
- en: As you can imagine, this pattern has a wide range of use cases in the real world,
    which we will see in the next section.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所想，这个模式在现实世界中有着广泛的应用场景，我们将在下一节中看到。
- en: Real-world examples
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现实世界示例
- en: When we go to a restaurant for dinner, we give the order to the waiter. The
    order pad (usually paper) that they use to write the order is an example of a
    command. After writing the order, the waiter places it in the queue that is executed
    by the cook. Each check is independent and can be used to execute many different
    commands, for example, one command for each item that will be cooked.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们去餐馆吃晚餐时，我们会向服务员下单。他们用来写下订单的订单本（通常是纸张）是一个命令的例子。写下订单后，服务员将其放入厨师执行的队列中。每个检查都是独立的，可以用来执行许多不同的命令，例如，为每个将要烹饪的项目执行一个命令。
- en: 'As you would expect, we also have several examples in software. Here are two
    I can think of:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所预期，我们也有几个软件中的示例。以下是我能想到的两个：
- en: PyQt is the Python binding of the QT toolkit. PyQt contains a `QAction` class
    that models an action as a command. Extra optional information is supported for
    every action, such as description, tooltip, or shortcut ([j.mp/qaction](http://j.mp/qaction)).
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PyQt是QT工具包的Python绑定。PyQt包含一个`QAction`类，它将操作建模为命令。每个动作都支持额外的可选信息，例如描述、工具提示或快捷键([j.mp/qaction](http://j.mp/qaction))。
- en: Git Cola ([j.mp/git-cola](http://j.mp/git-cola)), a Git GUI written in Python,
    uses the Command pattern to modify the model, amend a commit, apply a different
    election, check out, and so forth ([j.mp/git-cola-code](http://j.mp/git-cola-code)).
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git Cola ([j.mp/git-cola](http://j.mp/git-cola))，一个用Python编写的Git图形用户界面，使用命令模式来修改模型、修改提交、应用不同的选举、检出等([j.mp/git-cola-code](http://j.mp/git-cola-code))。
- en: Let's now be more general and discuss when the command pattern will prove useful
    in the next section.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将更一般地讨论在下一节中命令模式何时会证明是有用的。
- en: Use cases
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用例
- en: 'Many developers use the undo example as the only use case of the command pattern.
    The truth is that undo is the killer feature of the command pattern. However,
    the command pattern can actually do much more ([j.mp/commddp](http://j.mp/commddp)):'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发者将撤销示例视为命令模式的唯一用例。实际上，撤销是命令模式的杀手级功能。然而，命令模式实际上可以做更多([j.mp/commddp](http://j.mp/commddp))：
- en: '**GUI buttons and menu items**: The PyQt example that was already mentioned
    uses the command pattern to implement actions on buttons and menu items.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GUI按钮和菜单项**：前面提到的PyQt示例使用命令模式来实现按钮和菜单项上的操作。'
- en: '**Other operations**: Apart from undo, commands can be used to implement any
    operation. A few examples are cut, copy, paste, redo, and capitalize text.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**其他操作**：除了撤销之外，命令还可以用于实现任何操作。一些例子是剪切、复制、粘贴、重做和首字母大写文本。'
- en: '**Transactional behavior and logging**: Transactional behavior and logging
    are important to keep a persistent log of changes. They are used by operating
    systems to recover from system crashes, relational databases to implement transactions,
    filesystems to implement snapshots, and installers (wizards) to revert canceled
    installations.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事务行为和日志记录**：事务行为和日志记录对于保持更改的持久日志非常重要。操作系统用于从系统崩溃中恢复，关系数据库用于实现事务，文件系统用于实现快照，安装程序（向导）用于撤销已取消的安装。'
- en: '**Macros**: By macros, in this case, we mean a sequence of actions that can
    be recorded and executed on demand at any point in time. Popular editors such
    as Emacs and Vim support macros.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**宏**：在这里，我们指的是可以记录并在任何时间点按需执行的行动序列。流行的编辑器如Emacs和Vim支持宏。'
- en: To demonstrate what we have discussed so far, we will implement a file utility
    management application next.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示我们迄今为止讨论的内容，我们将实现一个文件实用程序管理应用程序。
- en: Implementation
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现
- en: 'In this section, we will use the command pattern to implement the most basic
    file utilities:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用命令模式来实现最基本的文件实用程序：
- en: Creating a file and optionally writing text (a string) to it
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个文件，并可选择向其中写入文本（一个字符串）
- en: Reading the contents of a file
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取文件内容
- en: Renaming a file
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重命名文件
- en: Deleting a file
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除文件
- en: We will not implement these utilities from scratch, since Python already offers
    good implementations of them in the `os` module. What we want is to add an extra
    abstraction level on top of them so that they can be treated as commands. By doing
    this, we get all the advantages offered by commands.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会从头实现这些实用程序，因为Python已经在`os`模块中提供了良好的实现。我们想要在它们之上添加一个额外的抽象层，以便将它们视为命令。通过这样做，我们可以获得命令提供的所有优势。
- en: From the operations shown, renaming a file and creating a file support undo.
    Deleting a file and reading the contents of a file do not support undo. Undo can
    actually be implemented on delete file operations. One technique is to use a special
    trash/wastebasket directory that stores all the deleted files so that they can
    be restored when the user requests them. This is the default behavior used on
    all modern desktop environments and is left as an exercise to you.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 从显示的操作中可以看出，重命名文件和创建文件支持撤销。删除文件和读取文件内容不支持撤销。实际上，可以在删除文件操作上实现撤销。一种技术是使用一个特殊的垃圾箱目录来存储所有已删除的文件，以便在用户请求时恢复它们。这是所有现代桌面环境默认使用的功能，留作练习。
- en: 'Each command has two parts:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 每个命令有两个部分：
- en: '`__init__()` method and contains all the information required by the command
    to be able to do something useful (the path of a file, the contents that will
    be written to the file, and so forth).'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__init__()` 方法，并包含命令执行有用操作所需的所有信息（文件的路径、将要写入文件的内容等等）。'
- en: '`execute()` method. We call the `execute()` method when we want to actually
    run a command. This is not necessarily right after initializing it.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`execute()` 方法。当我们想要实际运行命令时，我们会调用 `execute()` 方法。这不一定是在初始化后立即进行的。'
- en: 'Let''s start with the rename utility, which is implemented using the `RenameFile`
    class. The `__init__()` method accepts the source (`src`) and destination (`dest`)
    file paths as parameters (strings). If no path separators are used, the current
    directory is used to create the file. An example of using a path separator is
    passing the `/tmp/file1` string as `src` and the `/home/user/file2` string as
    `dest`. Another example, where we would not use a path, is passing `file1` as
    `src` and `file2` as `dest`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从重命名实用工具开始，它是通过 `RenameFile` 类实现的。`__init__()` 方法接受源 (`src`) 和目标 (`dest`)
    文件路径作为参数（字符串）。如果没有使用路径分隔符，则使用当前目录来创建文件。使用路径分隔符的一个例子是将 `/tmp/file1` 字符串作为 `src`，将
    `/home/user/file2` 字符串作为 `dest`。另一个例子，我们不会使用路径，是将 `file1` 作为 `src`，将 `file2` 作为
    `dest`：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We add the `execute()` method to the class. This method does the actual renaming
    using `os.rename()`. The `verbose` variable corresponds to a global `print()`
    is good enough for an example, normally something more mature and powerful can
    be used, for example, the logging module ([j.mp/py3log](http://j.mp/py3log)):'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向类中添加了 `execute()` 方法。此方法使用 `os.rename()` 实际执行重命名。`verbose` 变量对应于全局 `print()`，对于示例来说足够好，通常可以使用更成熟和强大的工具，例如，logging
    模块 ([j.mp/py3log](http://j.mp/py3log))：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Our rename utility (`RenameFile`) supports the undo operation through its `undo()`
    method. In this case, we use `os.rename()` again to revert the name of the file
    to its original value:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的重命名实用工具 (`RenameFile`) 通过其 `undo()` 方法支持撤销操作。在这种情况下，我们再次使用 `os.rename()`
    来恢复文件的原始名称：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In this example, deleting a file is implemented in a function, instead of a
    class. That is to show it is not mandatory to create a new class for every command
    that you want to add (more on that will be covered later). The `delete_file()`
    function accepts a file path as a string and uses `os.remove()` to delete it:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，删除文件是在一个函数中实现的，而不是在类中。这是为了表明，对于您想要添加的每个命令，不一定必须创建一个新的类（更多内容将在后面介绍）。`delete_file()`
    函数接受一个文件路径作为字符串，并使用 `os.remove()` 来删除它：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Back to using classes again. The `CreateFile` class is used to create a file.
    The `__init__()` method for that class accepts the familiar `path` parameter and
    a `txt` parameter for the content (a string) that will be written to the file.
    If nothing is passed as `txt`, the default `hello world` text is written to the
    file. Normally, the same default behavior is to create an empty file, but for
    the needs of this example, I decided to write a default string in it.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 回到使用类。`CreateFile` 类用于创建文件。该类的 `__init__()` 方法接受熟悉的 `path` 参数和一个 `txt` 参数，用于写入文件的内容（一个字符串）。如果没有传递
    `txt`，则将默认的 `hello world` 文本写入文件。通常，相同的默认行为是创建一个空文件，但为了这个示例的需要，我决定在其中写入一个默认字符串。
- en: 'The definition of the `CreateFile` class starts as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateFile` 类的定义如下开始：'
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then we add an `execute()` method, in which we use the `with` statement and
    Python''s `open()` built-in function to open the file (`mode=''w''` means write
    mode), and the `write()` function to write the `txt` string to it, as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们添加一个 `execute()` 方法，在其中我们使用 `with` 语句和 Python 的内置 `open()` 函数来打开文件（`mode='w'`
    表示写入模式），并使用 `write()` 函数将 `txt` 字符串写入其中，如下所示：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The undo action for the operation of creating a file is to delete that file.
    So, the `undo()` method, which we add to the class, simply uses the `delete_file()`
    function to achieve that, as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 创建文件操作的撤销动作是删除该文件。因此，我们添加到类中的 `undo()` 方法简单地使用 `delete_file()` 函数来实现，如下所示：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The last utility gives us the ability to read the contents of a file. The `execute()`
    method of the `ReadFile` class uses `open()` again, this time in read mode, and
    just prints the content of the file using `print()`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个实用工具使我们能够读取文件的内容。`ReadFile` 类的 `execute()` 方法再次使用 `open()`，这次是以读取模式，然后使用
    `print()` 打印文件的内容。
- en: 'The `ReadFile` class is defined as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReadFile` 类被定义为如下：'
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `main()` function makes use of the utilities we have defined. The `orig_name`
    and `new_name` parameters are the original and new names of the file that is created
    and renamed. A commands list is used to add (and configure) all the commands that
    we want to execute at a later point. Note that the commands are not executed unless
    we explicitly call `execute()` for each command:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()`函数使用了我们所定义的实用工具。`orig_name`和`new_name`参数是创建并重命名文件的原始名称和新名称。使用命令列表来添加（并配置）我们希望在以后某个时间点执行的命令。请注意，除非我们明确为每个命令调用`execute()`，否则命令不会执行：'
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The next step is to ask the users whether they want to undo the executed commands
    or not. The user selects whether the commands will be undone or not. If they choose
    to undo them, `undo()` is executed for all commands in the commands list. However,
    since not all commands support undo, exception handling is used to catch (and
    ignore) the `AttributeError` exception generated when the `undo()` method is missing.
    The code would look like the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是询问用户他们是否想要撤销已执行的命令。用户可以选择是否撤销命令。如果他们选择撤销，将对命令列表中的所有命令执行`undo()`操作。然而，由于并非所有命令都支持撤销，因此使用异常处理来捕获（并忽略）当`undo()`方法缺失时产生的`AttributeError`异常。代码看起来如下所示：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Using exception handling for such cases is an acceptable practice, but if you
    don't like it, you can check explicitly whether a command supports the undo operation
    by adding a `supports_undo()` or `can_be_undone()`. Again, that is not mandatory.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种情况使用异常处理是一种可接受的做法，但如果你不喜欢，你可以通过添加`supports_undo()`或`can_be_undone()`来显式检查命令是否支持撤销操作。再次强调，这并不是强制性的。
- en: Let's see two sample executions using the `python command.py` command line.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用`python command.py`命令行执行的两个示例执行。
- en: 'In the first one, there is no undo of commands:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，没有命令的撤销：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the second one, we have the undo of commands:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二种情况下，我们有命令的撤销：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'But wait! Let''s see what can be improved in our command implementation example.
    Among the things to consider are the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等！让我们看看我们的命令实现示例中可以改进的地方。需要考虑的事项包括以下内容：
- en: What happens if we try to rename a file that doesn't exist?
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们尝试重命名一个不存在的文件会发生什么？
- en: What about files that exist but cannot be renamed because we don't have the
    proper filesystem permissions?
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于存在但因为我们没有适当的文件系统权限而无法重命名的文件怎么办？
- en: We can try improving the utilities by doing some kind of error handling. Checking
    the return status of the functions in the `os` module can be useful. We could
    check whether the file exists before trying the delete action, using the `os.path.exists()`
    function.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过进行某种错误处理来尝试改进实用工具。检查`os`模块中函数的返回状态可能很有用。我们可以在尝试删除操作之前使用`os.path.exists()`函数检查文件是否存在。
- en: 'Also, the file creation utility creates a file using the default file permissions
    as decided by the filesystem. For example, in POSIX systems, the permissions are
    `-rw-rw-r--`. You might want to give the ability to the user to provide their
    own permissions by passing the appropriate parameter to `CreateFile`. How can
    you do that? Hint: one way is by using `os.fdopen()`.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，文件创建实用工具使用文件系统决定的默认文件权限创建文件。例如，在POSIX系统中，权限是`-rw-rw-r--`。你可能希望允许用户通过将适当的参数传递给`CreateFile`来提供他们自己的权限。你该如何做到这一点？提示：一种方法是通过使用`os.fdopen()`。
- en: 'And now, here''s something for you to think about. I mentioned earlier that
    a command does not necessarily need to be a class. That''s how the delete utility
    was implemented; there is just a `delete_file()` function. What are the advantages
    and disadvantages of this approach? Here''s a hint: is it possible to put a delete
    command in the commands list as was done for the rest of the commands? We know
    that functions are first-class citizens in Python, so we can do something such
    as the following (see the `first-class.py` file):'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这里有一些事情要你思考。我之前提到过，命令不一定是类。这就是删除实用工具的实现方式；只有一个`delete_file()`函数。这种方法的优缺点是什么？提示：是否可以将删除命令放入命令列表中，就像对其他命令所做的那样？我们知道在Python中函数是一等公民，所以我们可以做如下操作（参见`first-class.py`文件）：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Running `first-class.py` gives us the following output:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`first-class.py`会给出以下输出：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We see that this variant of the implementation example works as intended, as
    the second delete throws an error saying that the action was not successful.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，这个实现示例的变体按预期工作，因为第二次删除操作抛出一个错误，表示操作未成功。
- en: With that said, there are some potential improvements to this program that you
    could think about. First, the code we have is not uniform; we rely too much on
    exception handling, which is not the normal flow of a program. While all the other
    commands we implemented have an `execute()` method, in this case, there is no
    `execute()`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，这个程序还有一些潜在的改进可以考虑。首先，我们现有的代码并不统一；我们过度依赖异常处理，这不是程序的正常流程。虽然我们实现的所有其他命令都有一个`execute()`方法，但在这个情况下，却没有`execute()`。
- en: Furthermore, the delete file utility currently has no undo support. What happens
    if we eventually decide to add undo support for it? Normally, we add an `undo()`
    method to the class that represents the command. However, in this case, there
    is no class. We could create another function to handle undo, but creating a class
    is a better approach.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当前删除文件工具没有撤销支持。如果我们最终决定为它添加撤销支持，会发生什么？通常，我们会为表示命令的类添加一个`undo()`方法。然而，在这种情况下，没有类。我们可以创建另一个函数来处理撤销，但创建一个类是更好的方法。
- en: Summary
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered the command pattern. Using this design pattern,
    we can encapsulate an operation, such as copy and paste, as an object. Using this
    pattern, we can execute a command whenever we want, and not necessarily at creation
    time, while the client code that executes a command does not need to know any
    details about how it is implemented. Moreover, we can group commands and execute
    them in a specific order.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了命令模式。使用这个设计模式，我们可以将操作，如复制和粘贴，封装为一个对象。使用这个模式，我们可以在任何时候执行命令，而无需在创建时执行，而执行命令的客户端代码不需要了解其实现的任何细节。此外，我们可以分组命令并按特定顺序执行它们。
- en: To demonstrate command, we implemented some basic file utilities on top of Python's
    `os` module. Our utilities supported undo and had a uniform interface, which makes
    grouping commands easy.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示命令，我们在Python的`os`模块之上实现了一些基本的文件工具。我们的工具支持撤销，并且有一个统一的接口，这使得分组命令变得容易。
- en: The next chapter covers the Observer pattern.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍观察者模式。
- en: Questions
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'The answers to these questions can be found in the *Assessments* section at
    the end of the book:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题的答案可以在本书末尾的*评估*部分找到：
- en: What are the high-level benefits of the command pattern?
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命令模式的优点是什么？
- en: From the perspective of the client of an application, how is the command pattern
    specifically useful?
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从应用程序客户端的角度来看，命令模式具体有什么好处？
- en: How is the command pattern implemented in the Python example of file management?
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命令模式是如何在文件管理的Python示例中实现的？
