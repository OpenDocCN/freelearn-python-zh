- en: '*Chapter 25*: The Command Pattern'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will cover the **command pattern**. Using this design pattern,
    we can encapsulate an operation, such as *copy and paste*, as an object. The command
    pattern is also great for grouping multiple commands. It's useful for implementing
    macros, multilevel undoing, and transactions. Throughout our discussions, we will
    learn about the idea of treating an operation as an object and use this command
    mindset to handle application transactions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will discuss the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the command pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Real-world examples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code files for this chapter can be accessed through this link: [https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter25](https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter25).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the command pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most applications nowadays have an **undo** operation. It is hard to imagine,
    but undo did not exist in any software for many years. Undo was introduced in
    1974 ([j.mp/wiundo](http://j.mp/wiundo)), but Fortran and Lisp, two programming
    languages that are still widely used, were created in 1957 and 1958, respectively
    ([j.mp/proghist](http://j.mp/proghist))! The user had no easy way to fix a mistake.
    I wouldn't like to have been an application user during those years.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enough with the history! We want to know how we can implement the undo functionality
    in our applications, and since you have read the title of this chapter, you already
    know which design pattern is recommended to implement undo: the command pattern.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The command design pattern helps us encapsulate an operation (undo, redo, copy,
    paste, and so forth) as an object. What this simply means is that we create a
    class that contains all the logic and the methods required to implement the operation.
    The advantages of doing this are as follows ([j.mp/cmdpattern](http://j.mp/cmdpattern)):'
  prefs: []
  type: TYPE_NORMAL
- en: We don't have to execute a command directly. It can be executed at will.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The object that invokes the command is decoupled from the object that knows
    how to perform it. The invoker does not need to know any implementation details
    about the command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If it makes sense, multiple commands can be grouped to allow the invoker to
    execute them in order. This is useful, for instance, when implementing a multilevel
    undo command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can imagine, this pattern has a wide range of use cases in the real world,
    which we will see in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Real-world examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we go to a restaurant for dinner, we give the order to the waiter. The
    order pad (usually paper) that they use to write the order is an example of a
    command. After writing the order, the waiter places it in the queue that is executed
    by the cook. Each check is independent and can be used to execute many different
    commands, for example, one command for each item that will be cooked.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you would expect, we also have several examples in software. Here are two
    I can think of:'
  prefs: []
  type: TYPE_NORMAL
- en: PyQt is the Python binding of the QT toolkit. PyQt contains a `QAction` class
    that models an action as a command. Extra optional information is supported for
    every action, such as description, tooltip, or shortcut ([j.mp/qaction](http://j.mp/qaction)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Git Cola ([j.mp/git-cola](http://j.mp/git-cola)), a Git GUI written in Python,
    uses the Command pattern to modify the model, amend a commit, apply a different
    election, check out, and so forth ([j.mp/git-cola-code](http://j.mp/git-cola-code)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's now be more general and discuss when the command pattern will prove useful
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Use cases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Many developers use the undo example as the only use case of the command pattern.
    The truth is that undo is the killer feature of the command pattern. However,
    the command pattern can actually do much more ([j.mp/commddp](http://j.mp/commddp)):'
  prefs: []
  type: TYPE_NORMAL
- en: '**GUI buttons and menu items**: The PyQt example that was already mentioned
    uses the command pattern to implement actions on buttons and menu items.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Other operations**: Apart from undo, commands can be used to implement any
    operation. A few examples are cut, copy, paste, redo, and capitalize text.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transactional behavior and logging**: Transactional behavior and logging
    are important to keep a persistent log of changes. They are used by operating
    systems to recover from system crashes, relational databases to implement transactions,
    filesystems to implement snapshots, and installers (wizards) to revert canceled
    installations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Macros**: By macros, in this case, we mean a sequence of actions that can
    be recorded and executed on demand at any point in time. Popular editors such
    as Emacs and Vim support macros.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To demonstrate what we have discussed so far, we will implement a file utility
    management application next.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will use the command pattern to implement the most basic
    file utilities:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a file and optionally writing text (a string) to it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading the contents of a file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Renaming a file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting a file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will not implement these utilities from scratch, since Python already offers
    good implementations of them in the `os` module. What we want is to add an extra
    abstraction level on top of them so that they can be treated as commands. By doing
    this, we get all the advantages offered by commands.
  prefs: []
  type: TYPE_NORMAL
- en: From the operations shown, renaming a file and creating a file support undo.
    Deleting a file and reading the contents of a file do not support undo. Undo can
    actually be implemented on delete file operations. One technique is to use a special
    trash/wastebasket directory that stores all the deleted files so that they can
    be restored when the user requests them. This is the default behavior used on
    all modern desktop environments and is left as an exercise to you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each command has two parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`__init__()` method and contains all the information required by the command
    to be able to do something useful (the path of a file, the contents that will
    be written to the file, and so forth).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`execute()` method. We call the `execute()` method when we want to actually
    run a command. This is not necessarily right after initializing it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s start with the rename utility, which is implemented using the `RenameFile`
    class. The `__init__()` method accepts the source (`src`) and destination (`dest`)
    file paths as parameters (strings). If no path separators are used, the current
    directory is used to create the file. An example of using a path separator is
    passing the `/tmp/file1` string as `src` and the `/home/user/file2` string as
    `dest`. Another example, where we would not use a path, is passing `file1` as
    `src` and `file2` as `dest`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We add the `execute()` method to the class. This method does the actual renaming
    using `os.rename()`. The `verbose` variable corresponds to a global `print()`
    is good enough for an example, normally something more mature and powerful can
    be used, for example, the logging module ([j.mp/py3log](http://j.mp/py3log)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Our rename utility (`RenameFile`) supports the undo operation through its `undo()`
    method. In this case, we use `os.rename()` again to revert the name of the file
    to its original value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, deleting a file is implemented in a function, instead of a
    class. That is to show it is not mandatory to create a new class for every command
    that you want to add (more on that will be covered later). The `delete_file()`
    function accepts a file path as a string and uses `os.remove()` to delete it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Back to using classes again. The `CreateFile` class is used to create a file.
    The `__init__()` method for that class accepts the familiar `path` parameter and
    a `txt` parameter for the content (a string) that will be written to the file.
    If nothing is passed as `txt`, the default `hello world` text is written to the
    file. Normally, the same default behavior is to create an empty file, but for
    the needs of this example, I decided to write a default string in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The definition of the `CreateFile` class starts as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we add an `execute()` method, in which we use the `with` statement and
    Python''s `open()` built-in function to open the file (`mode=''w''` means write
    mode), and the `write()` function to write the `txt` string to it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The undo action for the operation of creating a file is to delete that file.
    So, the `undo()` method, which we add to the class, simply uses the `delete_file()`
    function to achieve that, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The last utility gives us the ability to read the contents of a file. The `execute()`
    method of the `ReadFile` class uses `open()` again, this time in read mode, and
    just prints the content of the file using `print()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ReadFile` class is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `main()` function makes use of the utilities we have defined. The `orig_name`
    and `new_name` parameters are the original and new names of the file that is created
    and renamed. A commands list is used to add (and configure) all the commands that
    we want to execute at a later point. Note that the commands are not executed unless
    we explicitly call `execute()` for each command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to ask the users whether they want to undo the executed commands
    or not. The user selects whether the commands will be undone or not. If they choose
    to undo them, `undo()` is executed for all commands in the commands list. However,
    since not all commands support undo, exception handling is used to catch (and
    ignore) the `AttributeError` exception generated when the `undo()` method is missing.
    The code would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Using exception handling for such cases is an acceptable practice, but if you
    don't like it, you can check explicitly whether a command supports the undo operation
    by adding a `supports_undo()` or `can_be_undone()`. Again, that is not mandatory.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see two sample executions using the `python command.py` command line.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first one, there is no undo of commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the second one, we have the undo of commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'But wait! Let''s see what can be improved in our command implementation example.
    Among the things to consider are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: What happens if we try to rename a file that doesn't exist?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What about files that exist but cannot be renamed because we don't have the
    proper filesystem permissions?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can try improving the utilities by doing some kind of error handling. Checking
    the return status of the functions in the `os` module can be useful. We could
    check whether the file exists before trying the delete action, using the `os.path.exists()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, the file creation utility creates a file using the default file permissions
    as decided by the filesystem. For example, in POSIX systems, the permissions are
    `-rw-rw-r--`. You might want to give the ability to the user to provide their
    own permissions by passing the appropriate parameter to `CreateFile`. How can
    you do that? Hint: one way is by using `os.fdopen()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'And now, here''s something for you to think about. I mentioned earlier that
    a command does not necessarily need to be a class. That''s how the delete utility
    was implemented; there is just a `delete_file()` function. What are the advantages
    and disadvantages of this approach? Here''s a hint: is it possible to put a delete
    command in the commands list as was done for the rest of the commands? We know
    that functions are first-class citizens in Python, so we can do something such
    as the following (see the `first-class.py` file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Running `first-class.py` gives us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We see that this variant of the implementation example works as intended, as
    the second delete throws an error saying that the action was not successful.
  prefs: []
  type: TYPE_NORMAL
- en: With that said, there are some potential improvements to this program that you
    could think about. First, the code we have is not uniform; we rely too much on
    exception handling, which is not the normal flow of a program. While all the other
    commands we implemented have an `execute()` method, in this case, there is no
    `execute()`.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, the delete file utility currently has no undo support. What happens
    if we eventually decide to add undo support for it? Normally, we add an `undo()`
    method to the class that represents the command. However, in this case, there
    is no class. We could create another function to handle undo, but creating a class
    is a better approach.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the command pattern. Using this design pattern,
    we can encapsulate an operation, such as copy and paste, as an object. Using this
    pattern, we can execute a command whenever we want, and not necessarily at creation
    time, while the client code that executes a command does not need to know any
    details about how it is implemented. Moreover, we can group commands and execute
    them in a specific order.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate command, we implemented some basic file utilities on top of Python's
    `os` module. Our utilities supported undo and had a uniform interface, which makes
    grouping commands easy.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter covers the Observer pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The answers to these questions can be found in the *Assessments* section at
    the end of the book:'
  prefs: []
  type: TYPE_NORMAL
- en: What are the high-level benefits of the command pattern?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the perspective of the client of an application, how is the command pattern
    specifically useful?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How is the command pattern implemented in the Python example of file management?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
