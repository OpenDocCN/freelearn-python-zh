- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: 'Domain-Driven Design: Crafting the Core Business Logic'
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 领域驱动设计：构建核心业务逻辑
- en: 'In the previous chapters, we laid the groundwork for understanding Clean Architecture
    and its principles. We explored the SOLID principles that guide robust software
    design and learned how to leverage Python’s type system to create more maintainable
    code. Now, we turn our attention to the innermost layer of Clean Architecture:
    the **Entity layer**, also commonly known as the **Domain layer**.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们为理解清洁架构及其原则奠定了基础。我们探讨了指导稳健软件设计的 SOLID 原则，并学习了如何利用 Python 的类型系统创建更易于维护的代码。现在，我们将注意力转向清洁架构的最内层：**实体层**，也常被称为**领域层**。
- en: The Entity layer represents the core of our application, encapsulating the essential
    business concepts and rules. This layer is independent of external concerns and
    forms the foundation upon which the rest of our Clean Architecture is built. By
    focusing on this core, we ensure that our application remains true to its fundamental
    purpose, regardless of the technologies or frameworks used in outer layers.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 实体层代表了我们的应用程序的核心，封装了基本业务概念和规则。这一层独立于外部关注点，并构成了我们其余清洁架构的基础。通过关注这个核心，我们确保我们的应用程序无论使用的外部技术或框架如何，都始终忠于其基本目的。
- en: In this chapter, we’ll dive deep into the implementation of the Entity layer,
    using **Domain-Driven Design (DDD) principles**. We’ll use a personal task management
    application as our ongoing example, demonstrating how to model and implement core
    business concepts in Python. You’ll learn how to identify and model domain entities,
    maintain a clear separation of concerns, and create a robust foundation for our
    Clean Architecture implementation. By the end, you’ll understand how to create
    entities that embody core concepts and business rules, setting the stage for the
    layers that will build upon this solid core.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨实体层的实现，使用**领域驱动设计（DDD）原则**。我们将使用一个个人任务管理应用程序作为我们的持续示例，展示如何在 Python
    中建模和实现核心业务概念。您将学习如何识别和建模领域实体，保持关注点的清晰分离，并为我们的清洁架构实现创建一个坚实的基础。到本章结束时，您将了解如何创建体现核心概念和业务规则的实体，为构建在此坚实基础之上的层奠定舞台。
- en: 'In this chapter, we’ll cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: Identifying and modeling core entities using DDD principles
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 DDD 原则识别和建模核心实体
- en: Implementing entities in Python
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Python 中实现实体
- en: Advanced domain concepts
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级领域概念
- en: Ensuring the independence of the Entity layer
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保实体层的独立性
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code examples presented in this chapter and throughout the rest of the book
    are tested with Python 3.13\. All examples can be found in the book’s accompanying
    GitHub repository at [https://github.com/PacktPublishing/Clean-Architecture-with-Python](https://github.com/PacktPublishing/Clean-Architecture-with-Python).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章及本书其余部分提供的代码示例均使用 Python 3.13 进行测试。所有示例均可在本书配套的 GitHub 仓库中找到，网址为 [https://github.com/PacktPublishing/Clean-Architecture-with-Python](https://github.com/PacktPublishing/Clean-Architecture-with-Python)。
- en: Identifying and modeling the Domain layer using DDD
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 DDD 识别和建模领域层
- en: In [*Chapter 1*](Chapter_01.xhtml#_idTextAnchor015), we emphasized the critical
    importance of the Entity layer in Clean Architecture. This layer forms the heart
    of your software, encapsulating the core business logic and rules. DDD provides
    a systematic approach to effectively model this crucial component.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第一章*](Chapter_01.xhtml#_idTextAnchor015)中，我们强调了实体层在清洁架构中的关键重要性。这一层构成了您软件的核心，封装了核心业务逻辑和规则。DDD
    提供了一种系统化的方法来有效地建模这个关键组件。
- en: DDD offers tools and techniques to identify, model, and implement the essential
    components of our Entity layer, bridging the gap between business realities and
    software design. By applying DDD principles within our Clean Architecture framework,
    we create a domain model that not only accurately reflects business needs but
    also serves as a solid foundation for a flexible, maintainable software system.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 领域驱动设计（DDD）提供了工具和技术来识别、建模和实现我们实体层的基本组件，弥合业务现实与软件设计之间的差距。通过在我们的清洁架构框架内应用 DDD
    原则，我们创建了一个领域模型，它不仅准确反映了业务需求，而且为灵活、可维护的软件系统提供了一个坚实的基础。
- en: 'Key benefits of integrating DDD with Clean Architecture include the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 将 DDD 与清洁架构集成的主要好处包括以下内容：
- en: Alignment with business needs
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与业务需求的一致性
- en: Improved communication between developers and domain experts
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发者与领域专家之间的沟通改进
- en: Enhanced flexibility and maintainability
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高灵活性和可维护性
- en: Natural scalability through clear boundaries and interfaces
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过清晰的边界和接口实现自然可扩展性
- en: Throughout this chapter, we’ll use a personal task management system as our
    running example to illustrate these concepts. This practical example will help
    us ground the abstract concepts of DDD in a relatable, real-world scenario.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用个人任务管理系统作为我们的示例来阐述这些概念。这个实际例子将帮助我们使DDD的抽象概念在可联系的现实场景中得到具体化。
- en: Understanding DDD
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解DDD
- en: Having established the importance of the Domain layer in Clean Architecture,
    we now turn to DDD’s specific techniques for implementing this layer effectively.
    Introduced by Eric Evans in 2003 ([https://en.wikipedia.org/wiki/Domain-driven_design](https://en.wikipedia.org/wiki/Domain-driven_design)),
    DDD provides concrete practices that help us translate business requirements into
    robust domain models.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在确立了领域层在Clean Architecture中的重要性之后，我们现在转向DDD实现这一层具体的技术。由埃里克·埃文斯于2003年提出([https://en.wikipedia.org/wiki/Domain-driven_design](https://en.wikipedia.org/wiki/Domain-driven_design))，DDD提供了具体的实践，帮助我们将业务需求转化为健壮的领域模型。
- en: 'While Clean Architecture tells us that domain entities should be at our system’s
    core, DDD provides the how: specific modeling techniques like **entities**, **value
    objects**, and **domain services** that we’ll explore in this chapter. These practices
    help us create domain models that not only enforce business rules but also communicate
    their intent clearly through code. Where Clean Architecture provides the structural
    blueprint for organizing code layers, DDD offers the tactical patterns for implementing
    that core business logic effectively.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Clean Architecture 告诉我们领域实体应该是我们系统核心，但 DDD 提供了如何做：在本章中我们将探讨的特定建模技术，如**实体**、**值对象**和**领域服务**。这些实践帮助我们创建领域模型，不仅执行业务规则，而且通过代码清晰地传达其意图。当
    Clean Architecture 提供了组织代码层的结构蓝图时，DDD 提供了实现核心业务逻辑的有效战术模式。
- en: 'At its core, DDD emphasizes a close collaboration between technical and domain
    experts. This collaboration aims to:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在其核心，DDD强调技术专家和领域专家之间的紧密合作。这种合作旨在：
- en: Develop a shared understanding of the domain
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 建立对领域的共同理解
- en: Create a model that accurately represents the domain’s complexities
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个准确反映领域复杂性的模型
- en: Implement this model in code, preserving its integrity and expressiveness
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在代码中实现此模型，保持其完整性和表达性
- en: 'By adopting DDD principles in our Clean Architecture approach, we gain several
    key benefits:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在我们的Clean Architecture方法中采用DDD原则，我们获得几个关键的好处：
- en: '**Alignment with business needs**: Our software becomes a true reflection of
    the business domain, making it more valuable and easier to adapt as business needs
    evolve'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与业务需求对齐**：我们的软件成为业务领域的真实反映，使其更具价值，并随着业务需求的变化更容易适应'
- en: '**Improved communication**: DDD establishes a common language between developers
    and domain experts, reducing misunderstandings and improving overall project cohesion'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**改进沟通**：DDD在开发人员和领域专家之间建立了一种共同语言，减少了误解并提高了整体项目的凝聚力'
- en: '**Flexibility and maintainability**: A well-designed domain model is inherently
    more flexible and easier to maintain, as it’s built around core business concepts
    rather than technical constraints'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灵活性和可维护性**：一个设计良好的领域模型本质上更加灵活且易于维护，因为它围绕核心业务概念构建，而不是技术约束'
- en: '**Scalability**: DDD’s focus on bounded contexts (covered in the *Core concepts
    of domain modeling* section) and clear interfaces between different parts of the
    system naturally leads to more scalable architectures'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：DDD对边界上下文（在*领域建模的核心概念*部分有所涉及）和系统不同部分之间清晰接口的关注，自然地导致更可扩展的架构'
- en: By integrating DDD principles with Clean Architecture, we forge a powerful methodology
    for developing software that aligns closely with business needs while maintaining
    technical flexibility. DDD provides the tools and techniques to effectively model
    the core of our system—the Entity layer—which is central in Clean Architecture
    and independent of external concerns. This synergy ensures that our Domain layer
    truly encapsulates essential business concepts and rules, supporting the creation
    of systems that are flexible, maintainable, and resilient to technological changes.
    As we delve into DDD concepts and apply them to our task management system, we’ll
    begin with the crucial step of analyzing our business requirements.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将DDD原则与Clean Architecture相结合，我们锻造了一种强大的软件开发方法论，这种方法论与业务需求紧密一致，同时保持技术灵活性。DDD提供了工具和技术来有效地建模我们系统的核心——实体层，这在Clean
    Architecture中是核心的，并且独立于外部关注点。这种协同作用确保我们的领域层真正封装了关键的业务概念和规则，支持创建灵活、可维护且对技术变化具有弹性的系统。当我们深入研究DDD概念并将它们应用于我们的任务管理系统时，我们将从分析业务需求这一关键步骤开始。
- en: Analyzing business requirements
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析业务需求
- en: The first step in applying DDD principles is to thoroughly analyze the business
    requirements. This process involves more than just listing features; it requires
    a deep dive into the core concepts, workflows, and rules that govern the domain.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 应用DDD原则的第一步是彻底分析业务需求。这个过程不仅涉及列出功能，还需要深入核心概念、工作流程和规则，这些规则支配着领域。
- en: 'For our task management system, we need to consider questions such as the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的任务管理系统，我们需要考虑以下问题：
- en: What defines a task’s uniqueness?
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是定义任务独特性的因素？
- en: How does the priority of a task affect its behavior in the system?
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务优先级如何影响其在系统中的行为？
- en: What rules govern the transition of a task between different statuses?
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪些规则支配着任务在不同状态之间的转换？
- en: How do task lists or projects relate to individual tasks?
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务列表或项目如何与单个任务相关联？
- en: What happens to a task when its deadline passes?
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当任务的截止日期过去后，任务会发生什么？
- en: These types of question help us understand the fundamental aspects of our domain.
    For instance, we might determine that a task is uniquely identified by a globally
    unique ID and that its priority can influence its position in a task list. We
    might define rules such as “a completed task cannot be moved back to *In Progress*
    without first being reopened.”
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型的问题帮助我们理解我们领域的根本方面。例如，我们可能会确定一个任务可以通过一个全局唯一ID来唯一标识，并且其优先级可以影响其在任务列表中的位置。我们可能会定义规则，例如“一个完成的任务在没有首先重新打开的情况下不能被移回*进行中*状态。”
- en: It’s crucial to note that, at this stage of DDD, we’re not writing any code.
    As a developer, you might feel an urge to start implementing these concepts immediately.
    However, resist this temptation. The power of DDD lies in thoroughly understanding
    and modeling the domain before writing a single line of code. This upfront investment
    in domain analysis will pay dividends in the form of a more robust, flexible,
    and accurate software model down the line.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，在这个DDD阶段，我们并没有编写任何代码。作为一个开发者，你可能会感到立即开始实施这些概念的冲动。然而，要抵制这种诱惑。DDD的力量在于在编写任何代码之前彻底理解和建模领域。这种对领域分析的前期投资将在未来带来更稳健、灵活和准确的软件模型。
- en: Core concepts of domain modeling
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 领域建模的核心概念
- en: DDD provides several key concepts for modeling our domain effectively. Central
    to these is the idea of a **ubiquitous language**, which is a common, rigorous
    vocabulary shared by both developers and domain experts. This language is used
    consistently in code, tests, and conversations, helping to prevent misunderstandings
    and keep the model aligned with the business domain.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: DDD为有效地建模我们的领域提供了几个关键概念。其中最重要的是**通用语言**的概念，这是一种由开发者和领域专家共同拥有的、严谨的共同词汇。这种语言在代码、测试和对话中始终如一地使用，有助于防止误解并确保模型与业务领域保持一致。
- en: 'In our task management system, this language includes terms such as the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的任务管理系统中，这种语言包括以下术语：
- en: '**Task**: A unit of work to be completed'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**任务**：需要完成的单元工作'
- en: '**Project**: A collection of related tasks'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**项目**：一系列相关的任务'
- en: '**Due Date**: The deadline for task completion'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**截止日期**：任务完成的最后期限'
- en: '**Priority**: The task’s importance level (e.g. *Low*, *Medium*, or *High*)'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优先级**：任务的重要性级别（例如 *低*，*中* 或 *高*）'
- en: '**Status**: The task’s current state (e.g. *To Do*, *In Progress*, or *Done*)'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状态**：任务当前的状态（例如 *待办*，*进行中* 或 *完成*）'
- en: 'With this ubiquitous language established, let’s explore the fundamental structural
    concepts of DDD that will help us implement our domain model:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在建立了这种普遍语言之后，让我们探索DDD的基本结构概念，这将帮助我们实现我们的领域模型：
- en: '![Figure 4.1: Clean Architecture layers and DDD concepts](img/B31577_04_1.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图4.1：Clean Architecture层和DDD概念](img/B31577_04_1.png)'
- en: 'Figure 4.1: Clean Architecture layers and DDD concepts'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1：Clean Architecture层和DDD概念
- en: 'As shown in *Figure 4.1*, Clean Architecture places the Entity layer at the
    core of our system, while DDD provides the specific components (entities, value
    objects, and domain services) that populate this layer. Let’s review them now:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图4.1*所示，Clean Architecture将实体层置于我们系统的核心，而DDD提供了填充这一层的具体组件（实体、值对象和域服务）。现在让我们来回顾一下：
- en: '**Entities**: These are objects defined by their identity that persists even
    when their attributes change. An `Order` remains the same `Order` even if its
    status changes from pending to shipped. In Clean Architecture, these core business
    objects embody the most stable rules at the system’s center.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实体**：这些是由其身份定义的对象，即使其属性发生变化，其身份也会持续存在。一个`Order`即使其状态从待处理变为已发货，也仍然是同一个`Order`。在Clean
    Architecture中，这些核心业务对象体现了系统中心的最高稳定规则。'
- en: '**Value objects**: These are immutable objects defined by their attributes
    rather than identity. Two `Money` objects with the same currency and amount are
    considered equal. They encapsulate cohesive behaviors without needing unique identification,
    increasing domain expressiveness while reducing complexity.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**值对象**：这些是由其属性定义而不是身份的不可变对象。具有相同货币和金额的两个`Money`对象被认为是相等的。它们封装了连贯的行为，无需唯一标识，增加了领域表达性，同时减少了复杂性。'
- en: '**Domain services**: These represent stateless operations that don’t naturally
    belong to a single entity or value object. They handle domain logic that spans
    multiple objects, like calculating shipping costs based on an order’s items and
    a customer’s location.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**域服务**：这些代表无状态的运算，它们不属于单个实体或值对象。它们处理跨越多个对象的领域逻辑，例如根据订单的项目和客户的地理位置计算运费。'
- en: These modeling components form the foundation of our Entity layer in Clean Architecture.
    While DDD gives us the vocabulary and techniques to identify and model these components
    based on business realities, Clean Architecture provides the framework for organizing
    them within our codebase, ensuring they remain independent from external concerns.
    This complementary relationship will become even clearer as we implement these
    concepts in Python.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这些建模组件构成了我们在Clean Architecture中实体层的基石。虽然DDD为我们提供了词汇和技巧，以基于业务现实来识别和建模这些组件，但Clean
    Architecture为我们提供了在代码库中组织它们的框架，确保它们独立于外部关注点。随着我们在Python中实现这些概念，这种互补关系将变得更加清晰。
- en: Modeling the task management domain
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 建模任务管理领域
- en: Let’s apply the core concepts of DDD to our task management system, translating
    theoretical concepts into practical components of our domain model.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将DDD的核心概念应用于我们的任务管理系统，将理论概念转化为我们领域模型的实际组件。
- en: Task management application entities and value objects
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 任务管理应用程序实体和值对象
- en: 'Our system has two primary entities:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的系统有两个主要实体：
- en: '**Task**: The core entity representing a unit of work, with a persistent identity
    despite changing attributes (e.g., status transitions)'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**任务**：代表一个工作单元的核心实体，尽管属性发生变化（例如，状态转换），但其身份持续存在'
- en: '**User**: Represents a system user who manages tasks, also with a persistent
    identity'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户**：代表管理任务的系统用户，也具有持久性身份'
- en: 'We also have several important value objects:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有几个重要的值对象：
- en: '**Task status**: An enumeration (e.g., *To Do*, *In Progress*, or *Done*) representing
    a task’s state'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**任务状态**：一个枚举（例如，*待办*、*进行中*或*完成*），表示任务的状态'
- en: '**Priority**: Indicates task importance (e.g., *Low*, *Medium*, or *High*)'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优先级**：表示任务的重要性（例如，*低*、*中*或*高*）'
- en: '**Deadline**: Represents due date and time, encapsulating related behaviors
    such as overdue checking'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**截止日期**：表示到期日期和时间，封装了相关的行为，如逾期检查'
- en: These value objects enhance our model’s expressiveness. For instance, a task
    has a task status rather than a simple string, carrying more semantic meaning
    and potential behavior.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值对象增强了我们模型的表达能力。例如，一个任务有一个任务状态，而不是一个简单的字符串，它携带更多的语义意义和潜在的行为。
- en: Task management application domain services
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 任务管理应用程序域服务
- en: 'Complex operations that don’t belong to a single entity or value object are
    implemented as domain services:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 不属于单个实体或值对象的复杂操作作为域服务实现：
- en: '**Task priority calculator**: Calculates a task’s priority based on various
    factors'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**任务优先级计算器**：根据各种因素计算任务的优先级'
- en: '**Reminder service**: Manages the creation and sending of task reminders'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提醒服务**：管理任务提醒的创建和发送'
- en: These services keep our entities and value objects focused and cohesive.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这些服务使我们的实体和价值对象保持专注和一致。
- en: Leveraging bounded contexts
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 利用边界上下文
- en: '**Bounded contexts** are conceptual boundaries that define where specific domain
    models apply. They encapsulate domain details, ensure model consistency, and interact
    through well-defined interfaces. This aligns with Clean Architecture’s emphasis
    on clear component boundaries, facilitating modular and maintainable system design.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**边界上下文**是定义特定领域模型适用的概念边界。它们封装领域细节，确保模型一致性，并通过定义良好的接口进行交互。这与 Clean Architecture
    对清晰组件边界的强调相一致，有助于模块化和可维护的系统设计。'
- en: 'We can identify three distinct bounded contexts in our system:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在系统中识别出三个不同的边界上下文：
- en: '**Task management**: The core context, handling task-related operations'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**任务管理**：核心上下文，处理与任务相关的操作'
- en: '**User account management**: Handles user-related operations'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户账户管理**：处理与用户相关的操作'
- en: '**Notification**: Manages generating and sending notifications to users'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通知**：管理生成和向用户发送通知'
- en: These contexts create clear boundaries within our system, allowing independent
    development while enabling necessary interactions.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这些上下文在我们的系统中创建了清晰的边界，允许独立开发同时实现必要的交互。
- en: '![Figure 4.2: Three potential bounded contexts for our task management application](img/B31577_04_2.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.2：我们的任务管理应用的三种潜在边界上下文](img/B31577_04_2.png)'
- en: 'Figure 4.2: Three potential bounded contexts for our task management application'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2：我们的任务管理应用的三种潜在边界上下文
- en: This model forms the core of our Clean Architecture design, with entities and
    value objects at the center of our Entity layer. Our ubiquitous language ensures
    code reflects domain concepts accurately; domain services house complex multi-object
    logic, and bounded contexts manage system complexity at a higher level.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 此模型构成了我们 Clean Architecture 设计的核心，实体和价值对象位于我们的实体层中心。我们的通用语言确保代码准确反映领域概念；领域服务包含复杂的多对象逻辑，边界上下文在更高层次上管理系统复杂性。
- en: In the next section, we’ll implement this conceptual model in Python, creating
    rich domain entities that encapsulate fundamental business rules.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将使用 Python 实现这个概念模型，创建封装基本业务规则的丰富领域实体。
- en: Implementing entities in Python
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Python 中实现实体
- en: With our domain model conceptualized using DDD principles, we now turn to the
    practical implementation of these concepts in Python. This section will focus
    on creating rich domain entities that encapsulate fundamental business rules,
    laying the groundwork for our Clean Architecture implementation.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于 DDD 原理的概念化领域模型，我们现在转向这些概念在 Python 中的实际实现。本节将专注于创建封装基本业务规则的丰富领域实体，为我们的 Clean
    Architecture 实现奠定基础。
- en: Introduction to Python entities
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python 实体介绍
- en: Having established our understanding of entities in DDD, let’s explore how to
    implement them effectively in Python. Our implementation will focus on creating
    classes with unique identifiers and methods that encapsulate business logic, translating
    DDD concepts into practical Python code.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在建立了我们对 DDD 中实体的理解之后，让我们探讨如何在 Python 中有效地实现它们。我们的实现将侧重于创建具有唯一标识符和封装业务逻辑的方法的类，将
    DDD 概念转化为实际的 Python 代码。
- en: 'Key implementation considerations include the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 关键实现考虑因素包括以下内容：
- en: '**Identity**: Implementing unique identifiers using Python’s Universally Unique
    Identifier (UUID) system'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标识符**：使用 Python 的通用唯一标识符（UUID）系统实现唯一标识符'
- en: '**Mutability**: Leveraging Python’s object-oriented features to manage state
    changes'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可变性**：利用 Python 的面向对象特性来管理状态变化'
- en: '**Life cycle**: Managing object creation, modification, and deletion through
    Python class methods'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生命周期**：通过 Python 类方法管理对象的创建、修改和删除'
- en: '**Business rules**: Using Python’s type system and class methods to enforce
    business rules'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**业务规则**：使用 Python 的类型系统和类方法来强制执行业务规则'
- en: '**An introduction to data classes in Python**'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**Python 数据类的介绍**'
- en: In our implementation, we’ll be using Python’s data classes, introduced in Python
    3.7\. **Data classes** are a concise way to create classes that mainly store data
    but can also have behavior. They automatically generate several special methods,
    such as `__init__()`, `__repr__()`, and `__eq__()`, reducing boilerplate code.
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的实现中，我们将使用Python 3.7中引入的数据类。**数据类**是一种简洁的方式来创建主要存储数据但也可以具有行为的类。它们自动生成几个特殊方法，如`__init__()`、`__repr__()`和`__eq__()`，减少了样板代码。
- en: 'Key advantages of data classes include the following:'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 数据类的关键优势包括以下内容：
- en: '**Reduced boilerplate**: Automatically generates common methods'
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减少样板代码**：自动生成常见方法'
- en: '**Clarity**: Clearly expresses the structure of the data'
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**清晰性**：清楚地表达了数据结构'
- en: '**Immutability option**: Can create immutable objects, aligning with DDD principles
    for value objects'
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不可变性选项**：可以创建不可变对象，与DDD原则中的值对象保持一致'
- en: '**Default values**: Easily specifies default values for attributes'
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**默认值**：轻松指定属性的默认值'
- en: Data classes align well with Clean Architecture principles by promoting clear,
    focused entities that encapsulate data and behavior. They help us create entities
    that are easy to understand, maintain, and test.
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 数据类与Clean Architecture原则相吻合，通过促进清晰、专注的实体来封装数据和行为。它们帮助我们创建易于理解、维护和测试的实体。
- en: 'For more information on data classes, refer to the official Python documentation:
    [https://docs.python.org/3/library/dataclasses.html](https://docs.python.org/3/library/dataclasses.html).'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有关数据类的更多信息，请参阅官方Python文档：[https://docs.python.org/3/library/dataclasses.html](https://docs.python.org/3/library/dataclasses.html)。
- en: 'Now, let’s examine how we can use data classes to implement our `Entity` base
    class:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们如何使用数据类来实现我们的`Entity`基类：
- en: '[PRE0]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This `Entity` base class provides a foundation for all our entities, ensuring
    they have a unique identifier and appropriate equality and hashing behavior.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Entity`基类为所有我们的实体提供了一个基础，确保它们有一个唯一的标识符和适当的相等性和散列行为。
- en: '**Ensuring proper class equality in Python**'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**确保Python中类的正确相等性**'
- en: As we’ve seen in our `Entity` base class, we’ve implemented the `__eq__` and
    `__hash__` methods to ensure proper identity and equality checks. This is crucial
    for entities, as two tasks with the same attributes but different IDs should be
    considered different entities.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在`Entity`基类中看到的，我们已经实现了`__eq__`和`__hash__`方法，以确保适当的身份和相等性检查。这对于实体至关重要，因为具有相同属性但不同ID的两个任务应被视为不同的实体。
- en: Creating domain entities
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建领域实体
- en: 'Now, let’s implement our core domain entity: the `Task` entity. This entity
    will encapsulate the fundamental concepts and rules related to tasks in our task
    management system.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实现我们的核心领域实体：`Task`实体。这个实体将封装与我们的任务管理系统相关的任务的基本概念和规则。
- en: Implementing the Task entity
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现Task实体
- en: 'First, let’s look at the basic structure of our `Task` entity:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看我们的`Task`实体的基本结构：
- en: '[PRE1]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This `Task` entity encapsulates the core attributes of a task in our system.
    Let’s break down each attribute:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Task`实体封装了我们系统中任务的核心理念。让我们逐一分析每个属性：
- en: '`title`: A string representing the name or brief description of the task'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`title`：一个字符串，表示任务的名称或简要描述'
- en: '`description`: A more detailed explanation of what the task entails'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`description`：对任务所包含内容的更详细说明'
- en: '`due_date`: An optional `Deadline` object indicating when the task should be
    completed'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`due_date`：一个可选的`Deadline`对象，表示任务应完成的日期'
- en: '`priority`: Represents the importance of the task, defaulting to `MEDIUM`'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`priority`：表示任务的优先级，默认为`MEDIUM`'
- en: '`status`: Indicates the current state of the task, defaulting to `TODO`'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`status`：表示任务的当前状态，默认为`TODO`'
- en: 'Now, let’s implement our value objects:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实现我们的值对象：
- en: '[PRE2]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: These value objects help to constrain the possible values for task status, priority,
    and deadline, ensuring data integrity and providing semantic meaning to these
    attributes.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值对象有助于约束任务状态、优先级和截止日期的可能值，确保数据完整性并提供这些属性的语义意义。
- en: 'Here are some usage examples of the `Task` entity with these value objects:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些使用这些值对象的`Task`实体的示例：
- en: '[PRE3]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: After establishing our core `Task` entity structure and its supporting value
    objects, let’s explore how to enhance these foundations by incorporating business
    rules that govern task behavior and maintain data consistency.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在建立我们的核心`Task`实体结构和其支持值对象之后，让我们探索如何通过纳入管理任务行为和保持数据一致性的业务规则来增强这些基础。
- en: Encapsulating business rules in entities
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在实体中封装业务规则
- en: When implementing domain entities, it’s crucial to enforce business rules to
    ensure the entity always remains in a valid state. **Business rules**, often called
    **invariants**, are fundamental to the entity’s definition in the domain. Entities
    should encapsulate the business rules that apply directly to them.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现领域实体时，强制执行业务规则至关重要，以确保实体始终保持在有效状态。**业务规则**，通常称为**不变性**，是领域中对实体定义的基本要素。实体应封装直接适用于它们的业务规则。
- en: 'Let’s add some basic business rules to our `Task` entity:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`Task`实体中添加一些基本业务规则：
- en: '[PRE4]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, let’s explore how these business rules work in practice. The following
    examples demonstrate how the `Task` entity enforces its invariants and maintains
    its internal consistency:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们探索这些业务规则在实际中的工作方式。以下示例演示了`Task`实体如何强制执行其不变性并保持其内部一致性：
- en: '[PRE5]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'These methods enforce business rules such as the following:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法强制执行以下业务规则：
- en: A task can only be started if it’s in the `TODO` status
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有在任务处于`TODO`状态时，才能开始任务
- en: A completed task cannot be completed again
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完成的任务不能再次完成
- en: The task knows if it’s overdue based on its deadline
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务根据其截止日期知道是否已过期
- en: By encapsulating these rules within the entity, we ensure that the `Task` entity
    always adheres to the core business rules of our domain, regardless of how it’s
    used in the application.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将这些规则封装在实体中，我们确保`Task`实体始终遵循我们领域的核心业务规则，无论它在应用程序中的使用方式如何。
- en: Distinguishing entity-level rules from domain-level rules
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 区分实体级规则和领域级规则
- en: While the rules we’ve implemented are appropriate for the `Task` entity, not
    all business rules belong at the entity level. For example, consider a rule such
    as “*A user can’t have more than five high-priority tasks at one time*.” This
    rule involves multiple tasks and possibly user settings, so it doesn’t belong
    in the `Task` entity.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们实现的规则适用于`Task`实体，但并非所有业务规则都属于实体级别。例如，考虑以下规则：“*用户一次不能有超过五个高优先级任务*。”这个规则涉及多个任务和可能的用户设置，因此它不属于`Task`实体。
- en: Such rules are more appropriately implemented in domain services or application-layer
    use cases. We’ll explore how to implement these higher-level rules in the *Implementing
    domain services* section later in this chapter.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规则更适合在领域服务或应用层用例中实现。我们将在本章后面的*实现领域服务*部分探讨如何实现这些高级规则。
- en: By structuring our entities this way, we maintain a clear separation between
    entity-specific rules and broader domain rules, adhering to Clean Architecture
    principles and keeping our entities focused and maintainable.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以这种方式构建我们的实体，我们保持了实体特定规则和更广泛领域规则之间的清晰分离，遵循Clean Architecture原则，并保持我们的实体专注且易于维护。
- en: Value objects in Clean Architecture
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Clean Architecture中的值对象
- en: 'Having introduced value objects conceptually, let’s examine their specific
    implementation in our task management system. We’ve created several key value
    objects:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在概念上介绍了值对象之后，让我们来检查它们在我们任务管理系统中的具体实现。我们已经创建了几个关键值对象：
- en: '`TaskStatus`: Represents the current state of a task (e.g., *To Do*, *In Progress*,
    or *Done*)'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TaskStatus`：表示任务的当前状态（例如，*待办*、*进行中*或*完成*）'
- en: '`Priority`: Indicates the importance of a task (e.g., *Low*, *Medium*, or *High*)'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Priority`：表示任务的优先级（例如，*低*、*中*或*高*）'
- en: '`Deadline`: Represents the due date and time for a task, with additional behavior
    such as checking whether it’s overdue'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Deadline`：表示任务的截止日期和时间，具有额外的行为，例如检查是否已过期'
- en: 'Beyond the conceptual benefits already discussed, our implementation demonstrates
    specific advantages in Clean Architecture:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 除了已经讨论的概念性好处之外，我们的实现展示了在Clean Architecture中的具体优势：
- en: '**Immutability**: Once created, their state cannot be changed. This helps prevent
    bugs and makes our code easier to reason about.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不可变性**：一旦创建，其状态不能更改。这有助于防止错误并使我们的代码更容易推理。'
- en: '**Equality based on attributes**: Two value objects with the same attributes
    are considered equal, unlike entities that have a unique identity.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于属性的相等性**：具有相同属性的值对象被认为是相等的，而具有唯一身份的实体则不同。'
- en: '**Encapsulation of domain concepts**: They represent domain ideas as first-class
    citizens in our code, improving expressiveness.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**封装领域概念**：它们将领域思想作为我们代码中的第一类公民，提高了表达性。'
- en: '**Prevention of primitive obsession**: They replace the use of primitive types
    to represent domain concepts, adding semantic meaning and type safety.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**防止原始依赖**：它们用具有语义意义和类型安全性的方式替换了用于表示领域概念的原始类型。'
- en: '**Simplified testing**: Value objects are easy to create and use in tests,
    improving the testability of our system.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简化测试**：值对象易于创建和使用于测试中，提高了我们系统的可测试性。'
- en: 'Consider the difference between using a string for task status versus a `TaskStatus`
    enum:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑使用字符串表示任务状态与使用 `TaskStatus` 枚举之间的区别：
- en: '[PRE6]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Python’s support for lightweight value objects (such as enums) and modern IDE
    features enhances the developer experience, making it easier to implement a Clean
    Architecture that truly reflects the domain model.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Python 对轻量级值对象（如枚举）的支持以及现代 IDE 功能增强了开发者的体验，使得实现真正反映领域模型的 Clean Architecture
    更加容易。
- en: Implementing domain services
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现领域服务
- en: 'While many business rules can be encapsulated within entities and value objects,
    some rules or operations involve multiple entities or complex logic that doesn’t
    naturally fit within a single entity. For these cases, we can encapsulate the
    needed logic into domain services. Let’s implement a simple `TaskPriorityCalculator`
    service:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然许多业务规则可以封装在实体和值对象中，但有些规则或操作涉及多个实体或复杂的逻辑，这些逻辑并不自然地适合于单个实体。对于这些情况，我们可以将所需的逻辑封装到领域服务中。让我们实现一个简单的
    `TaskPriorityCalculator` 服务：
- en: '[PRE7]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This domain service encapsulates the logic for calculating a task’s priority
    based on its due date. It’s a stateless operation that doesn’t belong to any specific
    entity but is still an important part of our domain logic.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这个领域服务封装了根据任务截止日期计算任务优先级的逻辑。这是一个无状态的运算，不属于任何特定实体，但仍然是我们的领域逻辑的重要组成部分。
- en: By implementing our domain model in this way, we create a rich, expressive set
    of Python classes that accurately represent our task management domain. These
    classes encapsulate fundamental business rules, ensuring that our core domain
    logic remains consistent and well-organized.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以这种方式实现我们的领域模型，我们创建了一个丰富、表达性强的 Python 类集合，准确地代表了我们的任务管理领域。这些类封装了基本业务规则，确保我们的核心领域逻辑保持一致性和良好的组织结构。
- en: 'At its current state, our application might be organized thusly (the full code
    is available on GitHub at [https://github.com/PacktPublishing/Clean-Architecture-with-Python](https://github.com/PacktPublishing/Clean-Architecture-with-Python)):'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前状态下，我们的应用程序可能组织如下（完整代码可在 GitHub 上找到：[https://github.com/PacktPublishing/Clean-Architecture-with-Python](https://github.com/PacktPublishing/Clean-Architecture-with-Python))：
- en: '![Figure 4.3: Todo app structure with domain components implemented](img/B31577_04_3.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.3：实现领域组件的待办事项应用结构](img/B31577_04_3.png)'
- en: 'Figure 4.3: Todo app structure with domain components implemented'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3：实现领域组件的待办事项应用结构
- en: In the next section, we’ll explore more advanced domain concepts, building upon
    this foundation to create a comprehensive domain model that fully leverages the
    power of DDD in our Clean Architecture implementation.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探索更多高级领域概念，在此基础上构建一个全面的领域模型，充分利用 DDD 在我们的 Clean Architecture 实现中的力量。
- en: Enhancing the domain model with aggregates and factories
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用聚合和工厂增强领域模型
- en: Having established our core entities, value objects, and domain services, we
    now turn our attention to more advanced domain concepts. These concepts will help
    us create a more robust and flexible domain model, further enhancing our Clean
    Architecture implementation.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在确立了我们的核心实体、值对象和领域服务之后，我们现在将注意力转向更高级的领域概念。这些概念将帮助我们创建一个更健壮和灵活的领域模型，进一步增强我们的
    Clean Architecture 实现。
- en: DDD patterns
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DDD 模式
- en: DDD offers several advanced patterns that can help us manage complexity and
    maintain consistency in our domain model. Let’s explore some of these patterns
    and how they apply to our task management system.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: DDD 提供了几个高级模式，可以帮助我们管理领域模型的复杂性并保持一致性。让我们探索一些这些模式以及它们如何应用于我们的任务管理系统。
- en: Aggregates
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 聚合
- en: '**Aggregates** are a crucial pattern in DDD for maintaining consistency and
    defining transactional boundaries within the domain. An aggregate is a cluster
    of domain objects that we treat as a single unit for data changes. Each aggregate
    has a root and a boundary. The root is a single, specific entity contained in
    the aggregate, and the boundary defines what is inside the aggregate.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**聚合**是 DDD 中一个关键的模型，用于维护一致性并在领域内定义事务边界。聚合是一组被视为单一数据变更单元的领域对象。每个聚合都有一个根和一个边界。根是聚合中包含的单一、特定实体，边界定义了聚合内部的内容。'
- en: 'In our task management system, a natural aggregate would be a project containing
    multiple tasks. Let’s implement this:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的任务管理系统中，一个自然的聚合将是一个包含多个任务的工程。让我们来实现这个：
- en: '[PRE8]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this implementation, `Project` serves as the aggregate root. It encapsulates
    operations that maintain the consistency of the aggregate, such as adding, removing,
    or getting tasks.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实现中，`Project`作为聚合根。它封装了维护聚合一致性的操作，例如添加、删除或获取任务。
- en: 'The usage of `Project` would look like this:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`Project`的使用方式如下：'
- en: '[PRE9]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Key points about this aggregate are as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个聚合的关键点如下：
- en: '**Encapsulation**: `Project` controls access to its tasks. External code can’t
    directly modify the task collection.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**封装**：`Project`控制对其任务的访问。外部代码不能直接修改任务集合。'
- en: '**Consistency**: Methods such as `add_task` and `remove_task` ensure that the
    aggregate remains in a consistent state.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性**：`add_task`和`remove_task`等方法确保聚合保持一致状态。'
- en: '**Identity**: While individual `Task` entities have their own global identities
    (UUIDs), within the context of `Project`, they are also identified by their relationship
    to the project. This means that `Project` can manage tasks using project-specific
    concepts (such as order or position) in addition to their global IDs.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**身份**：虽然单个`Task`实体有其自己的全局身份（UUIDs），但在`Project`的上下文中，它们也通过其与项目的关联来识别。这意味着`Project`除了使用全局ID外，还可以使用项目特定的概念（如顺序或位置）来管理任务。'
- en: '**Transactional boundary**: Any operation that affects multiple tasks within
    a list (such as marking all as complete) should be done through `Project` to ensure
    consistency.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事务边界**：任何影响列表中多个任务的操作（如标记所有任务为完成）都应该通过`Project`来完成，以确保一致性。'
- en: '**Invariants**: `Project` can enforce invariants that apply to the collection
    as a whole. For example, we could add a method to ensure that no two tasks in
    the list have the same title.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不变性**：`Project`可以强制执行适用于整个集合的不变性。例如，我们可以添加一个方法来确保列表中的两个任务没有相同的标题。'
- en: Using aggregates like this helps us manage complex domains by grouping related
    entities and value objects into cohesive units. This not only simplifies our domain
    model but also helps in maintaining data integrity and consistency.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这样的聚合可以帮助我们通过将相关的实体和值对象分组到统一的单元中来管理复杂的领域。这不仅简化了我们的领域模型，还有助于保持数据完整性和一致性。
- en: When designing aggregates, it’s important to consider performance implications.
    Aggregates should be designed to be as small as possible while still maintaining
    consistency. In our case, if a project grows too large, we might need to consider
    pagination or lazy loading strategies when accessing tasks.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计聚合时，考虑性能影响是很重要的。聚合应该设计得尽可能小，同时保持一致性。在我们的例子中，如果项目变得过大，我们可能需要考虑分页或懒加载策略来访问任务。
- en: By implementing a project as an aggregate, we’ve created a powerful abstraction
    that encapsulates the complexities of managing multiple tasks. This aligns perfectly
    with Clean Architecture principles, as it allows us to express complex domain
    rules and relationships in a clear, encapsulated manner.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将项目实现为一个聚合，我们创建了一个强大的抽象，它封装了管理多个任务的复杂性。这与Clean Architecture原则完美契合，因为它允许我们以清晰、封装的方式表达复杂的领域规则和关系。
- en: The factory pattern
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工厂模式
- en: In traditional object-oriented programming, the **factory pattern** is often
    used to encapsulate object creation logic. However, modern Python features have
    reduced the need for standalone factories in many cases. Let’s explore how Python’s
    language features address object creation and when factories might still be useful.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的面向对象编程中，**工厂模式**常用于封装对象创建逻辑。然而，现代Python特性在很多情况下减少了独立工厂的需求。让我们探讨Python的语言特性如何处理对象创建，以及何时工厂可能仍然有用。
- en: Data classes and object creation
  id: totrans-187
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 数据类和对象创建
- en: 'Our `Task` entity, implemented as a `dataclass` type, already provides a clean
    and efficient way to create objects:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Task`实体，作为`dataclass`类型实现，已经提供了一种干净且高效的方式来创建对象：
- en: '[PRE10]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This `dataclass` definition automatically generates an `__init__` method, handling
    much of what a traditional factory might do. It sets default values, manages optional
    parameters, and ensures type consistency (when using type checkers).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`dataclass`定义自动生成一个`__init__`方法，处理传统工厂可能做的大部分工作。它设置默认值，管理可选参数，并确保类型一致性（当使用类型检查器时）。
- en: Extending object creation with Python features
  id: totrans-191
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用Python特性扩展对象创建
- en: 'For more complex initialization scenarios, Python offers a couple of idiomatic
    approaches:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更复杂的初始化场景，Python提供了一些惯用的方法：
- en: '**Class methods as alternative constructors:**'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类方法作为替代构造函数**：'
- en: '[PRE11]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '**Using the** `__post_init__` **feature from** `dataclass` **for complex initialization:**'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: These methods allow for more complex object creation logic while maintaining
    the benefits of data classes.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: When traditional factories might still be appropriate
  id: totrans-198
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Despite these Python features, there are scenarios where a standalone factory
    might still be beneficial:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '**Complex object graphs**: When creating an object requires setting up relationships
    with other objects or performing complex calculations'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependency injection**: When the creation process requires external dependencies
    that you want to keep separate from the entity itself'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Polymorphic creation**: When you need to create different subclasses based
    on runtime conditions'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s an example where a factory might be appropriate:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this case, the factory encapsulates the complex logic of creating a task
    within the context of a project and an assignee, including business rules that
    depend on the project and user status.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: By understanding these patterns and when to apply them, we can create a more
    expressive and maintainable domain model that aligns with Clean Architecture principles
    while leveraging Python’s strengths.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring domain independence
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The independence of the Domain layer is a cornerstone of Clean Architecture,
    directly tied to the Dependency Rule we first introduced in [*Chapter 1*](Chapter_01.xhtml#_idTextAnchor015).
    This rule, stating that dependencies should only point inward toward the Domain
    layer, is crucial for maintaining the purity and flexibility of our core business
    logic. In this section, we’ll explore practical applications of this rule and
    strategies to ensure domain independence.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: The Dependency Rule in practice
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s examine how the Dependency Rule applies to our task management system,
    using examples that highlight common violations and their corrections.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Example 1
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Task entity with database dependency:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this example, the `TaskWithDatabase` class violates the Dependency Rule by
    directly depending on a database connection. The `db` attribute and the `update`
    call in `mark_as_complete` introduce external concerns into our domain entity.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Example 2
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Project aggregate with UI dependency:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, `ProjectWithUI` incorrectly depends on a UI component, mixing presentation
    concerns with domain logic.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: These examples not only violate the Dependency Rule but also break the **Single
    Responsibility Principle** (**SRP**) from SOLID. The `TaskWithDatabase` class
    is responsible for both task management and database operations, while `ProjectWithUI`
    handles both project management and UI updates. These violations compromise the
    independence and focus of our Domain layer, making it less flexible, harder to
    test, and more challenging to maintain.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: By removing these external dependencies and adhering to the SRP, we create pure
    domain entities that focus solely on core business concepts and rules. This approach
    ensures that our Domain layer remains the stable core of our application, unaffected
    by changes in external systems, databases, or user interfaces.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll explore strategies for avoiding external dependencies
    and maintaining the purity of our Domain layer.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding external dependencies
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To maintain the purity and independence of our Domain layer, we need to be vigilant
    about avoiding dependencies on external frameworks, databases, or UI components.
    One key strategy is to use abstractions for external concerns. Let’s see how this
    works in practice with our task management system.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s define an abstract `TaskRepository` in the Domain layer:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This abstract class defines the contract for task persistence without specifying
    any implementation details. It belongs to the Domain layer and represents the
    interface that any task storage mechanism must fulfill.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s see how a domain service might use this repository:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This `TaskService` demonstrates how domain logic can interact with the persistence
    abstraction without knowing anything about the actual storage mechanism.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'The concrete implementation of the `TaskRepository` would reside in an outer
    layer, such as the Infrastructure layer:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This structure demonstrates the Dependency Rule in action:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: The Domain layer (`TaskRepository` and `TaskService`) defines and uses abstractions
    without knowledge of concrete implementations
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Infrastructure layer (`SQLiteTaskRepository`) implements the abstractions
    defined by the Domain layer
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The flow of dependency points inward; the Infrastructure layer depends on the
    Domain layer’s abstraction, not vice versa
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our Domain layer remains independent of specific database technologies or other
    external concerns
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can easily swap out SQLite for another database or storage mechanism without
    modifying the Domain layer
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By adhering to the Dependency Rule, we ensure that our Domain layer remains
    the stable core of our application, unaffected by changes in external systems
    or technologies. This separation allows us to evolve different parts of our system
    independently, facilitating easier testing, maintenance, and adaptation to changing
    requirements.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: For instance, if we decided to switch from SQLite to PostgreSQL, we would only
    need to create a new `PostgreSQLTaskRepository` in the Infrastructure layer, implementing
    the `TaskRepository` interface. The Domain layer, including our `TaskService`,
    would remain unchanged.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: This approach to structuring our code not only maintains the purity of our Domain
    layer but also provides flexibility for future changes and ease of testing, which
    are key benefits of Clean Architecture.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Domain layer independence and testability
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The independence of the Domain layer significantly enhances testability. By
    keeping domain logic separate from infrastructure concerns, we can easily unit
    test our core business rules without the need for complex setup or external dependencies.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'When our Domain layer is independent, we can do the following:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Write unit tests that run quickly, without the need for database setup or network
    connections
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test our business logic in isolation, without worrying about the complexities
    of UI or persistence layers
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use simple stubs or mocks for any external dependencies, focusing our tests
    on the business logic itself
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This independence makes our tests more reliable, faster to run, and easier to
    maintain. We’ll dive deeper into testing in [*Chapter 8*](Chapter_08.xhtml#_idTextAnchor192).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring toward a purer domain model
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Maintaining a pure domain model is an ongoing process that requires vigilance
    and regular refactoring. As our understanding of the domain evolves and as we
    face practical constraints in development, our initial implementations may drift
    from the ideal. This is a natural part of the software development process. What’s
    crucial is that we remain diligent in reviewing and refining our domain models,
    recognizing their foundational importance to our application.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 'Two key factors drive the need for refactoring:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '**Evolving domain understanding**: As we work with stakeholders and gain deeper
    insights into the business domain, we often discover that our initial models need
    adjustment to better reflect reality.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Practical compromises**: Sometimes, to meet deadlines or work within existing
    constraints, we may make compromises that introduce non-domain concerns into our
    model. While these compromises can be necessary in the short term, it’s important
    to revisit and address them to maintain the long-term health of our application.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s explore some strategies for maintaining and refactoring toward a purer
    domain model:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '**Conduct regular code reviews**: Focus on identifying any violations of the
    Dependency Rule or introductions of non-domain concerns.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Refactor continuously**: As your understanding of the domain evolves, continually
    refactor your domain model to better reflect this understanding.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Be wary of frameworks**: Resist the temptation to use convenient framework
    features in your Domain layer. The short-term gain in development speed often
    leads to long-term pain in maintainability and flexibility.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use DDD patterns**: Patterns such as entities, value objects, and aggregates
    help keep your domain model focused and pure.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Favor explicitness over implicitness**: Avoid *magic* behaviors that implicitly
    call external services. Make dependencies and behaviors explicit.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s an example of refactoring to maintain domain purity:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding version, there are indications that the `Task` entity may be
    implementing an excessive amount of behavior, violating the SRP of SOLID.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the refactored version:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the refactored version, we have done the following:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: We’ve removed the `send_completion_email` method from the `Task` entity. Sending
    notifications is not a core responsibility of a task and should be handled in
    an outer layer.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ve introduced an abstract `TaskCompleteNotifier` class. The actual implementation
    of this (e.g., sending an email) would be done in an outer layer. This allows
    us to keep the notion of *notifying about task completion* in our domain model
    without including the details of how that notification happens.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These changes keep our domain model pure and focused on core business concepts
    and rules. The `Task` entity now only concerns itself with what a task is and
    its basic behaviors, not with how to send emails or interact with the system clock.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: This example demonstrates how we can refactor our domain model to remove non-domain
    concerns and make it more testable and maintainable. It also shows how we can
    use abstractions (such as `TaskCompleteNotifier`) to represent domain concepts
    without including implementation details in our Domain layer.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: By regularly reviewing and refactoring our domain model, we ensure that it remains
    a true representation of our business domain, free from external concerns. This
    ongoing process is crucial for maintaining the integrity of our Clean Architecture
    implementation and the long-term maintainability of our application.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Remember, the goal isn’t perfection from the start but, rather, continuous improvement.
    Each refactoring step moves us closer to a cleaner, more expressive domain model
    that serves as a solid foundation for our entire application.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, maintaining the independence of domain concepts from external
    frameworks and systems is crucial for effective Clean Architecture. By using abstractions
    such as the `TaskRepository` interface and adhering to the Dependency Rule, we
    ensure our Domain layer remains focused on core business logic. This approach
    creates clear boundaries between the domain and external concerns, allowing infrastructure
    changes without affecting central business rules. Through dependency inversion
    and careful interface design, we create a robust, flexible foundation that can
    adapt to changing requirements while preserving the integrity of our core domain
    model.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we delved into the heart of Clean Architecture: the Entity
    layer, also known as the Domain layer. We explored how to identify, model, and
    implement core business concepts using DDD principles.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: We began by analyzing business requirements and defining a ubiquitous language
    for our task management system. We then examined key DDD concepts such as entities,
    value objects, and bounded contexts, seeing how they align with Clean Architecture
    principles.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: Next, we implemented these concepts in Python, creating rich domain entities
    such as `Task` and value objects such as `Priority` and `Deadline`. We encapsulated
    business rules within these entities, ensuring they maintain their integrity regardless
    of how they’re used in the broader application.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we focused on ensuring the independence of the Entity layer, exploring
    strategies to avoid external dependencies and maintain clear boundaries between
    our core domain logic and infrastructure concerns.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: By applying these principles, we’ve created a robust foundation for our Clean
    Architecture implementation. This Entity layer (focused purely on business logic
    and free from external concerns) will serve as the stable core around which the
    rest of our application will be built.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll explore the Application layer, where we’ll see how
    to orchestrate our domain objects to fulfill specific use cases while maintaining
    the separation of concerns established in our Entity layer.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Domain-Driven Design: Tackling Complexity in the Heart of Software* by Eric
    Evans ([https://www.informit.com/store/domain-driven-design-tackling-complexity-in-the-heart-9780321125217](https://www.informit.com/store/domain-driven-design-tackling-complexity-in-the-heart-9780321125217)).
    This book provides a systematic approach to DDD, offering best practices and techniques
    to develop software projects facing complex domains.'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Implementing Domain-Driven Design* by Vaughn Vernon ([https://www.oreilly.com/library/view/implementing-domain-driven-design/9780133039900/](https://www.oreilly.com/library/view/implementing-domain-driven-design/9780133039900/)).
    This book presents a top-down approach to understanding DDD, connecting strategic
    patterns with fundamental tactical programming tools.'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Building Evolutionary Architectures: Support Constant Change* by Rebecca Parsons,
    Neal Ford and Patrick Kua ([https://www.thoughtworks.com/en-us/insights/books/building-evolutionary-architectures](https://www.thoughtworks.com/en-us/insights/books/building-evolutionary-architectures)).
    This book offers guidance on enabling incremental architectural change over time
    to support constant evolution in software development.'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
