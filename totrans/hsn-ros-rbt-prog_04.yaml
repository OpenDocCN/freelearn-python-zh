- en: Getting Started with ROS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ROS 入门
- en: '**Robot Operating System** (**ROS**) is an open source piece of software. Its
    development started at Willow Garage, a technology incubator and robotics research
    laboratory. Its origin dates back to several projects at Stanford University from
    the mid-2000s, where researchers found themselves reinventing the wheel every
    time they had to build the software for each project.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**机器人操作系统**（**ROS**）是一个开源软件。其开发始于 Willow Garage，一个技术孵化器和机器人研究实验室。其起源可以追溯到 2000
    年中叶斯坦福大学的几个项目，当时研究人员每次都必须为每个项目构建软件时，都会发现自己是在重新发明轮子。'
- en: In 2007, Willow Garage took the lead and gave rise to ROS. The main goal was
    to reuse existing code and make it possible to prototype new robot designs quickly,
    focusing on high-level functionality and minimizing the need for editing code.
    If you are curious about how ROS has become the *de facto* standard for robot
    application development, you can view an interactive page at [https://www.ros.org/history](https://www.ros.org/history).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 2007 年，Willow Garage 率先推出了 ROS。主要目标是重用现有代码，并使快速原型化新机器人设计成为可能，专注于高级功能并最大限度地减少编辑代码的需求。如果您对
    ROS 如何成为机器人应用程序开发的**事实上的**标准感兴趣，可以查看一个交互式页面[https://www.ros.org/history](https://www.ros.org/history)。
- en: ROS is intended for the development of applications where different devices
    have to talk to each other in order to create a flexible and scalable environment. This
    chapter explains the basic concepts of ROS. It will introduce you to the framework
    using an easy language while avoiding very technical descriptions. This is because
    our first goal is to neatly show you what ROS is in a conceptual sense. In the
    following chapters, we will have the opportunity to cover technical descriptions;
    the ones that, in any case, you will need later in order to be able to use ROS
    in your projects.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: ROS 旨在开发需要不同设备相互通信以创建灵活和可扩展环境的应用程序。本章将解释 ROS 的基本概念。它将使用通俗易懂的语言介绍框架，同时避免过于技术性的描述。这是因为我们的首要目标是干净利落地向你展示
    ROS 在概念上的含义。在接下来的章节中，我们将有机会涵盖技术描述；这些描述在任何情况下你都需要，以便能够在项目中使用 ROS。
- en: In the first section of this chapter, we will cover how ROS works under the
    hood, and why it should not be simply considered as a specific-purpose programming
    language, but a framework for developing robotics apps. You will dive into the
    core concepts of the ROS graph and the asynchronous communication between nodes.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第一部分，我们将介绍 ROS 在底层是如何工作的，以及为什么它不应仅仅被视为一种特定用途的编程语言，而应被视为开发机器人应用程序的框架。您将深入了解
    ROS 图的核心概念和节点之间的异步通信。
- en: In the second section, you will be guided step by step to configure the ROS
    environment on your laptop.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二部分，您将逐步引导配置笔记本电脑上的 ROS 环境。
- en: In the third section, guided with a practical exercise, you will learn how to
    exchange simple messages between nodes using the command line.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三部分，通过一个实际练习的引导，你将学习如何使用命令行在节点之间交换简单的消息。
- en: Finally, we will give you an overview of the many available ROS packages that
    have been contributed by the open source community.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将为您概述许多由开源社区贡献的可用 ROS 包。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: ROS basic concepts and the ROS graph
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ROS 基本概念和 ROS 图
- en: Configuring your ROS development environment
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置您的 ROS 开发环境
- en: 'Communication between ROS nodes: messages and topics'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ROS 节点之间的通信：消息和主题
- en: Using publicly available packages for ROS
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 ROS 的公开可用包
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The practical aspects of this chapter require you to have access to a desktop
    computer or laptop with either of these two Ubuntu versions:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的实践方面要求您能够访问带有以下两种 Ubuntu 版本之一的台式计算机或笔记本电脑：
- en: Ubuntu 16.04 Xenial
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ubuntu 16.04 Xenial
- en: Ubuntu 18.04 Bionic
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ubuntu 18.04 Bionic
- en: '**Long-term support** (**LTS**) Ubuntu versions are maintained by Canonical
    for the next 5 years. Also, these kind of versions are released in even years.
    Hence, Ubuntu 16.04- released in 2016- will be maintained up to 2021, while Ubuntu
    18.04- released in 2018- will be maintained up to 2023\. We will not consider
    odd-year versions, that is, Ubuntu 17 or Ubuntu 19 because they are development
    releases that are not LTS.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**长期支持**（**LTS**）Ubuntu 版本由 Canonical 维护长达 5 年。此外，这类版本在偶数年发布。因此，2016 年发布的 Ubuntu
    16.04 将会维护到 2021 年，而 2018 年发布的 Ubuntu 18.04 将会维护到 2023 年。我们不会考虑奇数年版本，即 Ubuntu
    17 或 Ubuntu 19，因为它们是开发版本，不是 LTS 版本。'
- en: 'Open Robotics releases a new version of ROS every year coinciding with every
    Ubuntu version. The correspondence is as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Open Robotics 每年都会发布一个新的 ROS 版本，与每个 Ubuntu 版本同步。对应关系如下：
- en: ROS Kinetic running under Ubuntu 16.04 Xenial
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Ubuntu 16.04 Xenial 下运行的 ROS Kinetic
- en: ROS Melodic running under Ubuntu 18.04 Bionic
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Ubuntu 18.04 Bionic 下运行的 ROS Melodic
- en: The most used version as of the writing of this book is ROS Kinetic. The practical
    examples provided in the following chapters are valid for both Ubuntu 16.04 and
    Ubuntu 18.04\. Hence, they will work for ROS Kinetic as well as for ROS Melodic.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 到本书写作时，最常用的版本是 ROS Kinetic。以下章节中提供的实际例子适用于 Ubuntu 16.04 和 Ubuntu 18.04。因此，它们也适用于
    ROS Kinetic 和 ROS Melodic。
- en: When we don't make any distinction between Ubuntu or ROS versions, you should
    assume that they work for the two versions covered. If there is some difference
    in the commands or scripts to be run depending on the version, we will mention
    it explicitly.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们不区分 Ubuntu 或 ROS 版本时，你应该假设它们适用于这两个版本。如果根据版本的不同，命令或要运行的脚本有所不同，我们将明确指出。
- en: The code for this chapter can be found in `Chapter3_ROS_basics` of the book
    repository, which is hosted on GitHub at [https://github.com/PacktPublishing/Hands-On-ROS-for-Robotics-Programming/tree/master/Chapter3_ROS_basics](https://github.com/PacktPublishing/Hands-On-ROS-for-Robotics-Programming/tree/master/Chapter3_ROS_basics).
    In the *Setting up the ROS package* section, you will learn how to download the
    code and make it work with your ROS installation.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在本书仓库的 `Chapter3_ROS_basics` 中找到，该仓库托管在 GitHub 上，网址为 [https://github.com/PacktPublishing/Hands-On-ROS-for-Robotics-Programming/tree/master/Chapter3_ROS_basics](https://github.com/PacktPublishing/Hands-On-ROS-for-Robotics-Programming/tree/master/Chapter3_ROS_basics)。在
    *设置 ROS 软件包* 部分中，你将学习如何下载代码并将其与你的 ROS 安装一起使用。
- en: ROS basic concepts
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ROS 基本概念
- en: Early on, researchers of robotics at Stanford University found that prototyping
    software for robots was an intensive programming task, as they had to start coding
    from scratch for every project. There was a time in which programming languages
    such as C++ and Python were used for robotics as the general programming languages
    they are, and that fact required great efforts to build every piece of software
    to provide a robotic level of functionality, such as navigation or manipulation.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期，斯坦福大学机器人学的研究人员发现，为机器人原型设计软件是一项繁重的编程任务，因为他们必须为每个项目从头开始编码。曾经有一段时间，C++ 和 Python
    等编程语言被用作机器人的一般编程语言，而这一事实要求人们付出巨大的努力来构建每一块软件，以提供机器人级别的功能，例如导航或操作。
- en: 'It was not only a question of the reusability of the code, but it was also
    a matter of how things worked in robotics. In procedural programming, the typical
    flow of a program executes one step after another, as shown in the following diagram:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅是一个代码可重用性的问题，而且也是一个机器人工作方式的问题。在过程式编程中，程序的典型流程是按顺序执行一个步骤接着另一个步骤，如下面的图所示：
- en: '![](img/6dd10742-5596-4ac9-8267-479e8e7570be.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6dd10742-5596-4ac9-8267-479e8e7570be.png)'
- en: The task that this program executes is to combine multiple images into one,
    as can be easily inferred. From our robotic point of view, the main drawback of
    a process working like this is that, if some steps fail to execute, then the process
    cannot go on and, therefore, fails to deliver its results, that is, a combined
    image. If we use the analogy of robotics, this would mean that a humanoid robot
    transporting a light object (for example, a paper book) from one place to another
    may fail in its task if one of its arms does not work properly (the motor that
    drives the articulation of its elbow is broken, for example). The humanoid should
    be able to do the task with the other arm for sure. And this is what ROS does!
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序执行的任务是将多个图像合并成一个，这一点很容易推断。从我们的机器人角度来看，这种工作流程的主要缺点是，如果某些步骤未能执行，那么流程就无法继续，因此无法提供其结果，即合并后的图像。如果我们用机器人的类比，这意味着一个类人机器人如果其一只手臂（例如，肘关节的驱动电机损坏）不能正常工作，那么它可能无法完成其任务。类人机器人当然应该能够用另一只手臂完成任务。这正是
    ROS 所做的！
- en: Let's take a look at the following example of a ROS graph.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下 ROS 图的例子。
- en: The ROS graph
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ROS 图
- en: 'This graph is to ROS what a workflow diagram is to procedural programming:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图对于 ROS 来说，就像工作流程图对于过程式编程来说一样：
- en: '![](img/72ca14dd-2590-4f14-9ad6-3de7fdc49162.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/72ca14dd-2590-4f14-9ad6-3de7fdc49162.png)'
- en: 'In the preceding graph, each circle—called a **node**—represents an independent
    program (this can be written in Python, Java, C++, Ruby, Node.js, or any of the
    other programming languages that ROS has implemented). The connections between
    them—called **edges**—represent the exchange of information. The meaning behind
    the direction of the arrows is self-explanatory: the emitter of data is the node
    where the arrow starts, and the receiver node is the one where the arrow points
    to. The words that appear above the edges are what ROS calls **topics**, and they
    constitute the channels through which flows the information exchanged between
    the nodes. When a node needs to use the information of a topic, it does so by
    subscribing to it and this operation adds a new arrow to the graph from the producer
    (of the data for such topic) to the subscriber node.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，每个圆圈——称为**节点**——代表一个独立的程序（这可以用Python、Java、C++、Ruby、Node.js或ROS已实现的任何其他编程语言编写）。它们之间的连接——称为**边缘**——代表信息的交换。箭头方向的意义是显而易见的：数据发射器是箭头开始的节点，接收节点是箭头指向的节点。出现在边缘上方的单词是ROS所说的**主题**，它们构成了节点之间交换信息的通道。当一个节点需要使用主题的信息时，它会通过订阅它来这样做，这个操作会在图中从数据提供者（此类主题的数据）到订阅节点添加一个新的箭头。
- en: 'So, what does this graph do from the point of view of the robot? Remember that
    GoPiGo3 is a classical differential drive robot, where each wheel can be turned
    independently, and the sensor—for example, a distance sensor—provides the robot
    with information about how far away the obstacle is while moving:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，从机器人的角度来看，这个图做了什么？记住，GoPiGo3是一个经典的差速驱动机器人，其中每个轮子都可以独立转动，传感器——例如，距离传感器——在移动时为机器人提供有关障碍物距离的信息：
- en: '![](img/9401dda2-996f-40c9-9f80-b4b20ab4f812.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9401dda2-996f-40c9-9f80-b4b20ab4f812.png)'
- en: 'Image courtesy: Dexter Industries https://32414320wji53mwwch1u68ce-wpengine.netdna-ssl.com/wp-content/uploads/2017/05/GPG3_FullServoDistanceGoogly_1-800x800.jpg'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图片来源：Dexter Industries https://32414320wji53mwwch1u68ce-wpengine.netdna-ssl.com/wp-content/uploads/2017/05/GPG3_FullServoDistanceGoogly_1-800x800.jpg
- en: Therefore, you might have already guessed that in the preceding ROS graph, the `L_servo` node
    is the program that controls the left servomotor (by rotating that wheel) and
    the `R_servo` node does the same with the right wheel.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可能已经猜到了，在前面的ROS图中，`L_servo`节点是控制左伺服电机的程序（通过旋转该轮子），而`R_servo`节点对右轮做同样的操作。
- en: The `sensor` node is the one that takes the readings from the distance sensor
    and makes them available to the `control` node through the edge that is connected
    to it, that is, by using the `/sharp_data` topic.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`sensor`节点是那个从距离传感器读取数据并通过连接到它的边缘（即使用`/sharp_data`主题）使它们对`control`节点可用的节点。'
- en: Within the `control` node resides the program that takes the decision of what
    to do if GoPiGo3 is facing an obstacle. For example, it can rotate the robot until
    it finds a direction without any obstacles. Rotating means that the `control`
    node sends opposite commands to the `L_servo` and `R_Servo` nodes.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在`control`节点中运行着决定如果GoPiGo3遇到障碍物时应该做什么的程序。例如，它可以旋转机器人直到找到一个没有障碍物的方向。旋转意味着`control`节点向`L_servo`和`R_Servo`节点发送相反的命令。
- en: 'These signals are the ones that flow through the corresponding edges of the
    graph: the `/speed_left` topic or the left servo and `/speed_right` for the other
    one. In the ROS language, we say that the `control` node publishes the command
    for the left servo in the `/speed_left` topic.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这些信号是通过图中的相应边缘流动的：`/speed_left`主题或左舵机，以及`/speed_right`用于另一个。在ROS语言中，我们说`control`节点在`/speed_left`主题中发布左舵机的命令。
- en: roscore
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: roscore
- en: '**roscore** is the mandatory and first node that has to be launched so that
    the ROS environment can be running. This allows every node to be capable of finding
    any other node by subscribing to the topics it publishes. roscore also manages
    the database for ROS parameters—the values that define the robot configuration.
    As a result, if the roscore process dies, the master node fails, and the robot
    stops working. You may guess that this single point of failure is a clear limitation
    for a distributed computed framework such as ROS. For this reason, ROS2 has addressed
    this issue, and the running software no longer requires a master node. Communication
    between the nodes relies on the **DDS** (short for **Data Distribution Service**) architecture for
    real-time systems.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**roscore**是必须启动的第一个节点，以便ROS环境可以运行。这允许每个节点通过订阅它发布的主题来找到任何其他节点。roscore还管理ROS参数的数据库——定义机器人配置的值。因此，如果roscore进程崩溃，主节点失败，机器人将停止工作。您可以猜测，这个单点故障对于像ROS这样的分布式计算框架来说是一个明显的限制。因此，ROS2解决了这个问题，运行中的软件不再需要主节点。节点之间的通信依赖于**DDS**（数据分发服务）架构，适用于实时系统。'
- en: Can you see how different programming a robot is from writing a software application?
    In robotics, you focus on the top-level functionalities of your application and
    integrate premade software pieces written by others.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 您能看出编写机器人程序与编写软件应用程序的不同之处吗？在机器人领域，您关注应用程序的顶层功能，并集成其他人编写的预制软件组件。
- en: Do take into account that not all software in robotics follows this approach.
    In fact, among its many uses, we selected ROS because its philosophy adapts very
    well to the *learn-through-practice* methodology that we have adopted for this
    book.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，并非所有机器人领域的软件都遵循这种方法。实际上，在其众多用途中，我们选择ROS是因为其哲学与本书所采用的*实践学习*方法论非常契合。
- en: These pieces of software, which consist of code blocks grouped into nodes, form
    what we call a **ROS package**. Several related nodes constitute a ROS package
    that delivers a specific functionality, for example, object recognition with a
    camera.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这些软件组件，由代码块组成的节点群组，构成了我们所说的**ROS软件包**。几个相关的节点构成了一个ROS软件包，提供特定的功能，例如，使用摄像头进行物体识别。
- en: Workspaces and catkin
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作空间和catkin
- en: A workspace in ROS is an isolated environment for building and running your
    software. You may use different workspaces to manage different projects. The workspace
    will contain all the ROS packages you will need for your project.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在ROS中，工作空间是一个用于构建和运行您软件的独立环境。您可以使用不同的工作空间来管理不同的项目。工作空间将包含您项目所需的全部ROS软件包。
- en: Physically, it is a folder in your home directory that contains all of the specific
    files of your application in such a way that deploying this workspace in another
    machine with ROS preinstalled will work properly and do the same as it did on
    the original computer.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在物理上，它是在您的家目录中的一个文件夹，其中包含您应用程序的所有特定文件，这样部署这个工作空间到另一个预装了ROS的机器上时可以正常工作，并且与原始计算机上的表现相同。
- en: Tightly attached to the concept of the workspace is catkin, the build system
    of ROS that combines CMake macros and Python scripts to provide functionality
    on top of CMake's normal workflow. At this point, it is enough that you are aware
    that this is a tool used to build the software each time you include new packages
    in your workspace. You can find an in-depth conceptual explanation of catkin at [http://wiki.ros.org/catkin/conceptual_overview](http://wiki.ros.org/catkin/conceptual_overview).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: catkin与工作空间的概念紧密相连，它是ROS的构建系统，结合了CMake宏和Python脚本，在CMake的正常工作流程之上提供功能。在此阶段，您只需知道这是一个工具，每次您在工作空间中包含新的软件包时都会用来构建软件。您可以在[http://wiki.ros.org/catkin/conceptual_overview](http://wiki.ros.org/catkin/conceptual_overview)找到catkin的深入概念解释。
- en: Configuring your ROS development environment
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置您的ROS开发环境
- en: 'In this section, we will guide you on how to install and configure the tools
    that you will need to work comfortably with ROS on your laptop. In short, these
    are the steps you need to complete before starting the practical exercises in
    this chapter:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将指导您如何安装和配置您在笔记本电脑上舒适地使用ROS所需的工具。简而言之，在开始本章的实践练习之前，您需要完成以下步骤：
- en: Make sure that your computer runs **Ubuntu 16.04** or **Ubuntu 18.04**. Both
    are the LTS releases that have the most extensive collection of ROS packages at
    the time of writing this book.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请确保您的计算机运行**Ubuntu 16.04**或**Ubuntu 18.04**。这两个都是LTS版本，在撰写本书时拥有最广泛的ROS软件包集合。
- en: Install and set up **ROS** on your laptop. You will also be provided with the
    guidelines to install ROS in the Raspberry Pi, the CPU of the GoPiGO3 robot. However,
    in part 2 of the book, you will only need your laptop, since we will be dealing
    with a virtual model of the robot. The inclusion of the physical robot is left
    for part 3 of the book.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的笔记本电脑上安装和设置 **ROS**。您还将获得在 Raspberry Pi、GoPiGO3 机器人的 CPU 上安装 ROS 的指南。然而，在本书的第二部分，您只需要笔记本电脑，因为我们将会处理一个机器人的虚拟模型。物理机器人的包含留待本书的第三部分。
- en: For the *Integrated Development Environment* (**IDE**) we will use **RoboWare
    Studio**, which is based on the general purpose IDE by Microsoft called **Visual
    Studio Code**. We provide the instructions to set it up in the *Installing RoboWare
    Studio* section below.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 *集成开发环境*（**IDE**），我们将使用 **RoboWare Studio**，它基于微软的通用 IDE **Visual Studio
    Code**。我们将在下面的 *安装 RoboWare Studio* 部分提供设置说明。
- en: So, provided your laptop has the required operating system, let's now move on
    to the second step of the configuration.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，假设您的笔记本电脑具备所需的操作系统，我们现在继续进行配置的第二步。
- en: Installing ROS
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 ROS
- en: If you work under Ubuntu 16.04, you will need to install the Kinetic distribution of
    ROS. On the other hand, if you have Ubuntu 18.04, the corresponding version of ROS to
    install is called Melodic. Remember that these choices were explained in detail
    in the *Technical requirements* section.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是 Ubuntu 16.04，您需要安装 ROS 的 Kinetic 发行版。另一方面，如果您有 Ubuntu 18.04，要安装的 ROS
    版本称为 Melodic。请记住，这些选择在 *技术要求* 部分中已有详细解释。
- en: 'Before installing the software, make sure that you have the two basic `curl`
    and `git` tools. If this is not the case, then run the following command to install
    the missing ones:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装软件之前，请确保您有这两个基本的 `curl` 和 `git` 工具。如果不是这种情况，请运行以下命令来安装缺少的工具：
- en: '[PRE0]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The instructions on the **ROS Kinetic** installation page ([http://wiki.ros.org/kinetic/Installation/Ubuntu](http://wiki.ros.org/kinetic/Installation/Ubuntu))
    are pretty clear and straightforward. They are the same for your laptop (*amd64/i386*)
    and for the Raspberry Pi (the *armhf* architecture). They are included here for
    the completion of the description.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**ROS Kinetic** 安装页面上的说明（[http://wiki.ros.org/kinetic/Installation/Ubuntu](http://wiki.ros.org/kinetic/Installation/Ubuntu)）非常清晰且直接。它们适用于您的笔记本电脑（*amd64/i386*）和
    Raspberry Pi（*armhf* 架构）。它们包含在此处以完成描述。'
- en: '**ROS Melodic** also has an installation page at [http://wiki.ros.org/melodic/Installation/Ubuntu](http://wiki.ros.org/melodic/Installation/Ubuntu).
    There, you will find that the commands are the same as those for Kinetic, because
    they are written in such a way that are not dependent on the Ubuntu version of
    choice.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**ROS Melodic** 也有一个安装页面 [http://wiki.ros.org/melodic/Installation/Ubuntu](http://wiki.ros.org/melodic/Installation/Ubuntu)。在那里，您会发现命令与
    Kinetic 相同，因为它们是以一种不依赖于所选 Ubuntu 版本的方式编写的。'
- en: 'Following the next steps you will get ROS up and running in your laptop:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤，您将在笔记本电脑上安装并运行 ROS：
- en: 'First, add the source repository for ROS:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，添加 ROS 的源仓库：
- en: '[PRE1]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This command adds ROS repository sources to your system. Since such a source
    is dependent on the Ubuntu version, the inner command  `$(lsb_release -sc)` in
    the snippet above outputs the version, i.e. **xenial** for Ubuntu 16.04 and **bionic** or
    Ubuntu 18.04.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将 ROS 仓库源添加到您的系统中。由于此类源依赖于 Ubuntu 版本，上面片段中的内部命令 `$(lsb_release -sc)` 输出的是版本，即
    Ubuntu 16.04 的 **xenial** 和 Ubuntu 18.04 的 **bionic**。
- en: 'Then, set up your keys:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，设置您的密钥：
- en: '[PRE2]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Alternatively, you can use `curl` instead of the `apt-key` command. This is
    useful if you are behind a proxy server:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用 `curl` 而不是 `apt-key` 命令。如果您在代理服务器后面，这将很有用：
- en: '[PRE3]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If you do not get the key to be validated, then it may have been changed for
    security reasons (as of February 2020, the key remains active). If it is not the
    case at this moment, go to the official installation page at [http://wiki.ros.org/melodic/Installation/Ubuntu](http://wiki.ros.org/melodic/Installation/Ubuntu) and
    find the section, where the key value `0xC1CF6E31E6BADE8868B172B4F42ED6FBAB17C654`
    needs to be replaced.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有得到验证密钥，那么它可能因安全原因而更改（截至 2020 年 2 月，密钥仍然有效）。如果此刻不是这种情况，请访问官方安装页面 [http://wiki.ros.org/melodic/Installation/Ubuntu](http://wiki.ros.org/melodic/Installation/Ubuntu)，并找到需要替换密钥值
    `0xC1CF6E31E6BADE8868B172B4F42ED6FBAB17C654` 的部分。
- en: 'Update your sources:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新您的源：
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you have Ubuntu 16.04 on your laptop, install the full stack of ROS Kinetic,
    including the simulator called **Gazebo**, navigation, and robot perception packages
    (recommended):'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你的笔记本电脑上安装了 Ubuntu 16.04，请安装完整的 ROS Kinetic 堆栈，包括名为 **Gazebo** 的模拟器、导航和机器人感知包（推荐）：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you are working in Ubuntu 18.04, perform the installation of ROS Melodic
    instead:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用 Ubuntu 18.04，请执行 ROS Melodic 的安装：
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Alternatively, you may install the desktop version, which only includes the ROS
    GUI tools (`rqt`, `rviz`). Later on, you can add the packages for simulation (Gazebo),
    navigation, and perception when needed (remember that these are installed with
    full version outlined in step 4 above):'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以安装桌面版，它只包括 ROS GUI 工具（`rqt`，`rviz`）。稍后，当需要时，你可以添加模拟（Gazebo）、导航和感知的包（记住，这些包在上述第
    4 步中概述的完整版本中安装）：
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Alternatively, if you are in Ubuntu 18.04, you can use the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你使用的是 Ubuntu 18.04，你可以使用以下方法：
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Initialize `rosdep`. This is the component that enables you to easily install
    system dependencies for the source code to compile. It is also required in order
    to run some core components in ROS:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化 `rosdep`。这是使你能够轻松安装源代码编译所需系统依赖的组件。它也是运行 ROS 中一些核心组件所必需的：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Set up the ROS environment for your interactive shell session:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为你的交互式 shell 会话设置 ROS 环境：
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Alternatively, if you are in Ubuntu 18.04, use the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你使用的是 Ubuntu 18.04，请使用以下方法：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To avoid having to run this command each time you open a new terminal, include
    it at the end of your `.bashrc` file with the following command:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免每次打开新终端时都需要运行此命令，请使用以下命令将其包含在 `.bashrc` 文件的末尾：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The second command in the snippet above executes the **.bashrc** file refreshing
    your custom setup. If in Ubuntu 18.04, just replace `kinetic` for `melodic`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码片段中的第二个命令执行了 **.bashrc** 文件，刷新你的自定义设置。如果在 Ubuntu 18.04 中，只需将 `kinetic`
    替换为 `melodic`：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, install `rosinstall`, the command-line tool that enables you to easily
    download many source trees for ROS packages:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，安装 `rosinstall`，这是一个命令行工具，它使你能够轻松下载许多 ROS 包的源代码树：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Bear in mind that, as you become more familiar with the communication between
    the Raspberry Pi in the robot and your laptop, you can make all the desktop interactions
    from your computer and let the Raspberry Pi execute only robotics-specific tasks.
    This approach will make GoPiGo3 more responsive because you will have a minimal
    Ubuntu server in the Raspberry Pi and the ROS base version, which excludes the
    GUI tools and has only the core packages, as well as the build and communication
    libraries.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，随着你对机器人中的 Raspberry Pi 和你的笔记本电脑之间的通信越来越熟悉，你可以从你的电脑上执行所有桌面交互，让 Raspberry
    Pi 只执行机器人特定的任务。这种方法将使 GoPiGo3 更加响应，因为你将在 Raspberry Pi 上有一个最小的 Ubuntu 服务器和 ROS
    基础版本，它不包括 GUI 工具，只包含核心包以及构建和通信库。
- en: You can refer to the next section for specific details on how to prepare the
    ROS environment for the robot.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以参考下一节，了解如何为机器人准备 ROS 环境的具体细节。
- en: Ubuntu and ROS in the Raspberry Pi
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ubuntu 和 Raspberry Pi 上的 ROS
- en: Since you will be using only the core ROS packages in your Raspberry Pi, it
    is recommended that you install the latest Ubuntu LTS version, that is, Ubuntu
    Mate 18.04 Bionic ([https://ubuntu-mate.org/download/](https://ubuntu-mate.org/download/)).
    This is because, although almost all contributed ROS packages are available for ROS
    Kinetic, it is also true that core packages are already available in the 2018
    version of ROS Melodic. Therefore, it is safe to install this release in the Raspberry
    Pi under Ubuntu 18.04.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你将在 Raspberry Pi 上仅使用核心 ROS 包，因此建议你安装最新的 Ubuntu LTS 版本，即 Ubuntu Mate 18.04
    Bionic ([https://ubuntu-mate.org/download/](https://ubuntu-mate.org/download/))。这是因为，尽管几乎所有贡献的
    ROS 包都适用于 ROS Kinetic，但同样真实的是，核心包已经在 ROS Melodic 2018 版本中可用。因此，在 Ubuntu 18.04
    下在 Raspberry Pi 上安装此版本是安全的。
- en: As mentioned already, the instructions on the ROS Melodic installation page
    ([http://wiki.ros.org/melodic/Installation/Ubuntu](http://wiki.ros.org/melodic/Installation/Ubuntu))
    are pretty clear and straightforward.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，ROS Melodic 安装页面 ([http://wiki.ros.org/melodic/Installation/Ubuntu](http://wiki.ros.org/melodic/Installation/Ubuntu))
    上的说明非常清晰和直接。
- en: 'Follow the next guidelines to decide which version to install:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下指南决定安装哪个版本：
- en: 'If installing ROS Desktop (which is recommended for beginners and for covering
    the contents of this book), use the following command:'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果安装 ROS 桌面版（对于初学者和涵盖本书内容来说推荐使用），请使用以下命令：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If you wish to install the bare-bones version, that is, ROS Base, and so get
    a better performance from your Raspberry Pi, then use this command (this is only
    recommended for advanced users; at the moment, there is no desktop GUI):'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您希望安装基础版本，即 ROS Base，从而从您的 Raspberry Pi 获得更好的性能，那么请使用此命令（这仅推荐给高级用户；目前，没有桌面
    GUI）：
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As mentioned at the beginning of the section, for this chapter you will only
    need a laptop. The physical robot is left for part 3 of the book, starting from
    [Chapter 6](0b20bdff-f1dc-42e8-ae83-fc290da31381.xhtml), *Programming in ROS –
    Commands and Tools*. In that chapter, we will provide the necessary details to
    correctly set up the software in the Raspberry Pi.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如本节开头所述，对于本章，您只需要一台笔记本电脑。物理机器人留到本书的第 3 部分，从 [第 6 章](0b20bdff-f1dc-42e8-ae83-fc290da31381.xhtml)
    开始，即 *ROS 编程 – 命令和工具*。在该章中，我们将提供正确设置 Raspberry Pi 上软件的必要细节。
- en: Integrated Development Environment (IDE)
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成开发环境 (IDE)
- en: 'In the section of ROS wiki devoted to *Integrated Development Environments* ([http://wiki.ros.org/IDEs](http://wiki.ros.org/IDEs))
    are described the currently available IDEs for ROS—a total of 15 IDEs exist at
    the time of writing this book. Out of all of these options, we have selected to
    work with RoboWare Studio because of the following factors:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ROS wiki 专门介绍 *集成开发环境* 的部分 ([http://wiki.ros.org/IDEs](http://wiki.ros.org/IDEs))
    中，描述了目前可用的 ROS IDE——在撰写本书时，共有 15 个 IDE。在所有这些选项中，我们选择使用 RoboWare Studio，原因如下：
- en: It is a fork of **Visual Studio Code** (**VSC**), the general-purpose and customizable
    IDE by Microsoft that is extensively used in the developer community. It is open
    source, light, easy to use and offers lots of contributed plugins, making it possible
    to customize the IDE environment to your own specific needs. **RoboWare Studio**
    is built on top of VSC code to provide ROS development functionalities. Furthermore,
    the plugin panel of the IDE is customized so that you can easily install ROS packages
    on demand. The current version is 1.2.0, which was issued in June 2018\. Its code
    is open source and it is publicly available in GitHub at *TonyRobotics/RoboWare-Studio*
    ([https://github.com/TonyRobotics/RoboWare-Studio](https://github.com/TonyRobotics/RoboWare-Studio)).
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是微软的通用和可定制的 IDE **Visual Studio Code**（**VSC**）的一个分支，在开发者社区中被广泛使用。它是开源的、轻量级的、易于使用，并提供大量贡献的插件，使得您可以定制
    IDE 环境以满足自己的特定需求。**RoboWare Studio** 是基于 VSC 代码构建的，以提供 ROS 开发功能。此外，IDE 的插件面板已定制，以便您可以轻松按需安装
    ROS 软件包。当前版本是 1.2.0，于 2018 年 6 月发布。其代码是开源的，并在 GitHub 上公开提供，地址为 *TonyRobotics/RoboWare-Studio*
    ([https://github.com/TonyRobotics/RoboWare-Studio](https://github.com/TonyRobotics/RoboWare-Studio))。
- en: '**RoboWare Studio **out-of-the-box features allow you to start working with
    all of ROS''s main characteristics: workspaces, packages, nodes, messages/services/actions,
    and more.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RoboWare Studio** 的即开即用功能让您可以开始使用 ROS 的所有主要特性：工作空间、软件包、节点、消息/服务/动作等。'
- en: For all of the explanations in this book, we will always give you the commands
    to be executed in `bash`, as this is the native way of commanding ROS.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的所有解释中，我们都会为您提供在 `bash` 中执行的命令，因为这是指挥 ROS 的原生方式。
- en: 'IDEs such as RoboWare Studio may be of help in at least two scenarios:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: RoboWare Studio 等集成开发环境在至少两种场景下可能会有所帮助：
- en: When beginning with ROS, to avoid dealing with the complexity of the command
    line if you are not very familiar with it
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您刚开始使用 ROS 时，如果您不太熟悉命令行，可以避免处理其复杂性
- en: When developing projects, where the IDE facilitates the management of the large
    number of files that are spread along with the ROS packages that make up your
    application. Such packages provide functionalities such as coordinate transformations,
    computer vision, robot navigation, and so on.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开发项目时，IDE 可以帮助管理与您的应用程序组成的 ROS 软件包一起散布的大量文件。这些软件包提供诸如坐标变换、计算机视觉、机器人导航等功能。
- en: In any case, our advice is that you do the first round of this book using RoboWare
    Studio, and, for the second round, go directly to `bash`. If you want to skip
    one of them, then discard the IDE option and keep learning with the command line.
    Practicing `bash` commands is the best way to really understand how ROS works,
    and you surely know that this applies not only for ROS but for any other software
    tool running under Linux OS.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，我们的建议是使用 RoboWare Studio 完成这本书的第一轮学习，然后在第二轮学习中直接进入 `bash`。如果你想跳过其中一个，那么就放弃
    IDE 选项，并继续使用命令行学习。练习 `bash` 命令是真正理解 ROS 的工作方式的最佳方法，你当然知道这不仅仅适用于 ROS，也适用于任何在 Linux
    OS 下运行的软件工具。
- en: Therefore, from now on, use the IDE of your choice for editing files, and always
    work with the ROS command line (or RoboWare if you prefer to keep working with
    a GUI interface).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，从现在开始，使用你选择的 IDE 编辑文件，并且始终使用 ROS 命令行（或者如果你更喜欢使用 GUI 界面，则使用 RoboWare）。
- en: Installing RoboWare Studio
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 RoboWare Studio
- en: 'Provided that you have already installed ROS on your computer, execute the
    following block of commands in a terminal to install the required dependencies,
    as indicated in the manual of RoboWare Studio available at [https://github.com/TonyRobotics/RoboWare/blob/master/Studio/RoboWare_Studio_Manual_1.2.0_EN.pdf](https://github.com/TonyRobotics/RoboWare/blob/master/Studio/RoboWare_Studio_Manual_1.2.0_EN.pdf):'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经在你的计算机上安装了 ROS，请在终端中执行以下命令块以安装所需的依赖项，如 RoboWare Studio 可用手册中所示，手册链接为 [https://github.com/TonyRobotics/RoboWare/blob/master/Studio/RoboWare_Studio_Manual_1.2.0_EN.pdf](https://github.com/TonyRobotics/RoboWare/blob/master/Studio/RoboWare_Studio_Manual_1.2.0_EN.pdf)：
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, install the `clang-format-3.8` package:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，安装 `clang-format-3.8` 包：
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Binaries are hosted in GitHub at [https://github.com/TonyRobotics/RoboWare/blob/master/Studio](https://github.com/TonyRobotics/RoboWare/blob/master/Studio).
    You can download the latest version of RoboWare Studio in your Ubuntu OS for AMD64
    from this link: [https://github.com/TonyRobotics/RoboWare/raw/master/Studio/roboware-studio_1.2.0-1524709819_amd64.deb](https://github.com/TonyRobotics/RoboWare/raw/master/Studio/roboware-studio_1.2.0-1524709819_amd64.deb).
    You also have the source code available in GitHub at [https://github.com/tonyrobotics/roboware-studio](https://github.com/tonyrobotics/roboware-studio).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制文件托管在 GitHub 上，链接为 [https://github.com/TonyRobotics/RoboWare/blob/master/Studio](https://github.com/TonyRobotics/RoboWare/blob/master/Studio)。你可以从以下链接下载适用于
    Ubuntu OS AMD64 的 RoboWare Studio 最新版本：[https://github.com/TonyRobotics/RoboWare/raw/master/Studio/roboware-studio_1.2.0-1524709819_amd64.deb](https://github.com/TonyRobotics/RoboWare/raw/master/Studio/roboware-studio_1.2.0-1524709819_amd64.deb)。你还可以在
    GitHub 上找到源代码，链接为 [https://github.com/tonyrobotics/roboware-studio](https://github.com/tonyrobotics/roboware-studio)。
- en: 'Installation is pretty easy; execute the following command from the location
    where you got the `.deb` file:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 安装相当简单；从你获取 `.deb` 文件的位置执行以下命令：
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: After finishing, you can launch the IDE by clicking on the RoboWare Studio icon.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，你可以通过点击 RoboWare Studio 图标来启动 IDE。
- en: Communication between ROS nodes – messages and topics
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ROS 节点之间的通信 – 消息和主题
- en: We will accomplish the goal of getting two nodes talking to each other by going
    step by step. First, you need to create a personal workspace, and then you will
    pull the book repository at [https://github.com/PacktPublishing/Hands-On-ROS-for-Robotics-Programming](https://github.com/PacktPublishing/Hands-On-ROS-for-Robotics-Programming),
    and go into the `Chapter3_ROS_basics` folder to follow the exercises by yourself.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过逐步进行的方式实现让两个节点相互通信的目标。首先，你需要创建一个个人工作空间，然后从 [https://github.com/PacktPublishing/Hands-On-ROS-for-Robotics-Programming](https://github.com/PacktPublishing/Hands-On-ROS-for-Robotics-Programming)
    拉取书籍仓库，并进入 `Chapter3_ROS_basics` 文件夹，自行完成练习。
- en: Creating a workspace
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建工作空间
- en: 'Follow these steps to create a workspace from the command line:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤从命令行创建工作空间：
- en: 'First, create the folders that you will need later to place your ROS packages:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建你稍后需要放置 ROS 包的文件夹：
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The following are the folder descriptions:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对文件夹的描述：
- en: '`catkin_ws` will be the root location of your workspace.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`catkin_ws` 将成为你工作空间的根位置。'
- en: '`src` is where you will place your code, that is, inside the ROS packages.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src` 是你放置代码的地方，即在 ROS 包内部。'
- en: Be aware that **~** is equivalent to the home folder, that is, `/home/bronquillo`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`**~**` 等同于主目录，即 `/home/bronquillo`。
- en: 'Move to this last folder and issue the following command to initialize the
    workspace:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移动到最后一个文件夹，并执行以下命令以初始化工作空间：
- en: '[PRE21]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The last command will generate the `~/catkin_ws/src/CMakeLists.txt` file, which
    contains the definition and configuration of the workspace. That file really is a
    symlink to a location in the ROS installation folder where the workspace configuration
    is defined:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一条命令将生成 `~/catkin_ws/src/CMakeLists.txt` 文件，该文件包含工作空间的定义和配置。该文件实际上是一个指向 ROS
    安装文件夹中定义工作空间配置位置的符号链接：
- en: '[PRE22]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Build the workspace for the first time; it does not matter that the folder
    is empty at this time:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首次构建工作空间；此时文件夹为空无关紧要：
- en: '[PRE23]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'By listing the content, you will see two new folders:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 通过列出内容，你会看到两个新的文件夹：
- en: '`build` contains the result of the compilation of our workspace, and makes
    available all the code you will place later when creating a package for its execution
    with ROS commands.'
  id: totrans-140
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`build` 包含我们工作空间的编译结果，并在创建用于执行 ROS 命令的包时提供所有代码。'
- en: '`devel` contains the configuration of the workspace, and it will be sourced
    every time you open a terminal (refer to the following steps).'
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`devel` 包含工作空间的配置，每次你打开终端时都会源生它（参考以下步骤）。'
- en: Be aware that compilation has to be done at the root folder, `~/catkin_ws`,
    while workspace initialization was done in the application code folder, `~/catkin_ws/src`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，编译必须在根文件夹 `~/catkin_ws` 中完成，而工作空间初始化是在应用程序代码文件夹 `~/catkin_ws/src` 中完成的。
- en: 'To add the workspace to your ROS environment, you need to source the generated
    `setup` file:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将工作空间添加到你的 ROS 环境中，你需要源生生成的 `setup` 文件：
- en: '[PRE24]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To avoid having to run this command each time you open a new terminal, include
    it in your `.bashrc` file:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了避免每次打开新终端时都要运行此命令，将其包含在你的 `.bashrc` 文件中：
- en: '[PRE25]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then, you should have the following two lines added to your `.bashrc` file:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你应该在你的 `.bashrc` 文件中添加以下两行：
- en: '[PRE26]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Remember that the first line accounts for the ROS system configuration and the
    second for your workspace settings.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，第一行负责 ROS 系统配置，第二行负责你的工作空间设置。
- en: Creating a workspace and building it using RoboWare
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建工作空间并使用 RoboWare 构建
- en: 'The following instructions allow you to use the RoboWare IDE to create the
    workspace, avoiding the use of the command line:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 以下说明允许你使用 RoboWare IDE 创建工作空间，避免使用命令行：
- en: 'Launch RoboWare and click on the New Workspace... item:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 RoboWare 并点击“新建工作空间...”项：
- en: '![](img/b39dca13-5fac-4b07-a04e-1509e187509d.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/b39dca13-5fac-4b07-a04e-1509e187509d.png)'
- en: 'In the pop-up window, indicate the name of the workspace and select the folder
    where you want to place it:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在弹出的窗口中，指定工作空间名称并选择你想要放置它的文件夹：
- en: '![](img/1dc1df84-ee79-4d87-806b-b6731188f727.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/1dc1df84-ee79-4d87-806b-b6731188f727.png)'
- en: 'After setting the folder name, RoboWare executes `catkin_init_workspace` transparently
    for the user, and you will see a new file and a new folder on the left-hand side
    of your IDE window. They are the `src` folder and the file inside, `CMakeLists.txt`,
    which contains your workspace definition and configuration:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 设置文件夹名称后，RoboWare 会为用户透明地执行 `catkin_init_workspace`，你将在 IDE 窗口的左侧看到一个新的文件和一个新的文件夹。它们是
    `src` 文件夹和其中的文件 `CMakeLists.txt`，该文件包含你的工作空间定义和配置：
- en: '![](img/13f96ac6-236c-459e-9303-244edf80ecf4.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/13f96ac6-236c-459e-9303-244edf80ecf4.png)'
- en: For now, it is enough that you notice that the file has a symlink to a ROS system
    file located in the ROS installation folder,`/opt/ros/kinetic`. This folder contains
    the common configuration for all the workspaces you may create.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你只需要注意到该文件有一个指向 ROS 安装文件夹 `/opt/ros/kinetic` 中的 ROS 系统文件的符号链接。此文件夹包含所有可能创建的工作空间的通用配置。
- en: 'You can open a terminal in RoboWare and list all files with the `ls -la` command from
    the specific `~/catkin/src` location:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 RoboWare 中打开一个终端，并使用 `ls -la` 命令从特定的 `~/catkin/src` 位置列出所有文件：
- en: '![](img/9e5a5de7-cd9e-47bf-8d29-9183f7ec4539.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/9e5a5de7-cd9e-47bf-8d29-9183f7ec4539.png)'
- en: Such a terminal is accessed from the top-bar menu, by clicking on the View item,
    and then selecting Integrated terminal (*Ctrl* + *`*) from the drop-down menu.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的终端可以通过顶部菜单栏访问，通过点击“视图”项，然后从下拉菜单中选择“集成终端 (*Ctrl* + *`*)”：
- en: 'Select the build mode and set it to Debug, as shown in the following screenshot:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择构建模式并将其设置为调试，如下面的截图所示：
- en: '![](img/de495ea1-2116-4932-a056-64dd67b6854c.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/de495ea1-2116-4932-a056-64dd67b6854c.png)'
- en: 'Then, from the top-bar menu, select ROS | Build:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，从顶部菜单栏中选择 ROS | 构建：
- en: '![](img/c91c6db5-f60e-4e51-b9fb-63e8b579f266.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/c91c6db5-f60e-4e51-b9fb-63e8b579f266.png)'
- en: 'You will see the following log in the OUTPUT window at the bottom of the screen:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在屏幕底部的输出窗口中看到以下日志：
- en: '![](img/32182be7-c0b4-47bb-80b9-892e5de41995.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/32182be7-c0b4-47bb-80b9-892e5de41995.png)'
- en: 'The last lines should look like this if successful:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果成功，最后几行应该看起来像这样：
- en: '![](img/827dfbb8-08b5-4842-833b-f496dba956bf.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/827dfbb8-08b5-4842-833b-f496dba956bf.png)'
- en: Next, let's set up the ROS package.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们设置 ROS 软件包。
- en: Setting up the ROS package
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 ROS 软件包
- en: 'Follow these steps for setting up the ROS package:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤设置 ROS 软件包：
- en: 'From a terminal, clone the book repository, [https://github.com/PacktPublishing/Hands-On-ROS-for-Robotics-Programming](https://github.com/PacktPublishing/Hands-On-ROS-for-Robotics-Programming), into
    your home folder:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从终端克隆书籍仓库 [https://github.com/PacktPublishing/Hands-On-ROS-for-Robotics-Programming](https://github.com/PacktPublishing/Hands-On-ROS-for-Robotics-Programming)
    到您的家目录：
- en: '[PRE27]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We are going to copy the code of this chapter into the ROS workspace. That
    way, you will have a cleaner ROS environment:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将把本章的代码复制到 ROS 工作区。这样，您将有一个更干净的 ROS 环境：
- en: '[PRE28]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Do not add a backslash, `\n`, after the `src` folder name. If you do, the files
    will be copied directly into the `src` folder, not under **`src/Chapter3_ROS_basics`**.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 不要在 `src` 文件夹名称后添加反斜杠，`\n`。如果您这样做，文件将直接复制到 `src` 文件夹，而不是在 **`src/Chapter3_ROS_basics`**
    之下。
- en: 'Within the `Chapter3_ROS_basics` folder, you can find the files of this chapter
    belonging to the first ROS package you will play with. Its configuration is contained
    in the `package.xml` file. Be aware that the package name is defined within the
    `<name>ros_basics</name>`tags. You can find it inside the following code file:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Chapter3_ROS_basics` 文件夹中，您可以找到属于您将要使用的第一个 ROS 软件包的本章文件。其配置包含在 `package.xml`
    文件中。请注意，软件包名称定义在 `<name>ros_basics</name>` 标签内。您可以在以下代码文件中找到它：
- en: '[PRE29]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, go to the workspace root and build again:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，前往工作区根目录并再次构建：
- en: '[PRE30]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In general, you will have to rebuild the workspace in at least two cases:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您至少需要在以下两种情况下重新构建工作区：
- en: Each time you include a new package
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次您包含一个新的软件包
- en: If your code contains pieces written in a compilable language such as C++
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您的代码包含用可编译语言（如 C++）编写的部分
- en: 'In this book, we will be working mainly with Python, the widely used open source
    language that makes it easier to get started with ROS. Since Python is an interpreted
    language, you will not need to rebuild the workspace each time you modify the
    code base of the package. Hence, the rebuild will only be necessary when adding
    or removing ROS packages. The way to check whether the newly added package—`ros_basics`—is
    known to ROS is to execute this simple command:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将主要使用 Python，这是一种广泛使用的开源语言，它使得开始使用 ROS 更加容易。由于 Python 是一种解释型语言，因此您不需要每次修改软件包的代码库时都重新构建工作区。因此，只有在添加或删除
    ROS 软件包时才需要重新构建。检查新添加的软件包 `ros_basics` 是否为 ROS 所知的方法是执行此简单命令：
- en: '[PRE31]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The output should look like this:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该看起来像这样：
- en: '[PRE32]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Although here, we will be working from a premade ROS package, it is relevant
    that you know at this point how to create your own package from scratch. Issue
    this command from the `src` location of your workspace (`$ cd ~/catkin_ws/src/`):'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在这里，我们将从一个预制的 ROS 软件包开始工作，但了解在此阶段如何从头开始创建自己的软件包是相关的。从您工作区 `src` 位置运行此命令（`$
    cd ~/catkin_ws/src/`）：
- en: '[PRE33]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '`<YOUR-PACKAGE-NAME>` stands for the name you want to assign to your package. `<DEPENDENCIES>`
    refers to the list of ROS packages you will need for your code to run. For example,
    if your package is going to contain code in Python and C++, you will need `rospy`
    for the former and `roscpp` for the latter. Then, the command will be as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`<YOUR-PACKAGE-NAME>` 代表您想要分配给软件包的名称。`<DEPENDENCIES>` 指的是您代码运行所需的 ROS 软件包列表。例如，如果您的软件包将包含
    Python 和 C++ 代码，您将需要 `rospy` 用于前者，`roscpp` 用于后者。然后，命令将如下所示：'
- en: '[PRE34]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This will create a folder with the name given to the package and two files:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个以软件包名称命名的文件夹和两个文件：
- en: '`package.xml`: The package configuration as shown previously'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`package.xml`：如前所述的软件包配置'
- en: '`CMakelists.txt`: The input to the CMake build system for building software
    packages'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMakelists.txt`：CMake 构建系统的输入，用于构建软件包'
- en: '`CMakelists.txt` also contains the reference to`<YOUR-PACKAGE-NAME>`. For our
    case, this file is as simple as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`CMakelists.txt` 也包含对 `<YOUR-PACKAGE-NAME>` 的引用。在我们的例子中，此文件如下所示：'
- en: '[PRE35]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Accessing package files and building the workspace using RoboWare
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 RoboWare 访问软件包文件并构建工作区
- en: Here's an alternative method. The following demonstrates that you can clone
    a package repository and build the workspace using RoboWare.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个替代方法。以下演示了您可以使用 RoboWare 克隆软件包仓库并构建工作区。
- en: 'After cloning and placing the code of the chapter, as explained in the *Setting
    up the ROS package* section, you can explore the content in the file tree view
    on the left-hand side of the IDE window. Clicking on any of the files will let
    you see the content in the main window:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在按照*设置ROS包*部分中解释的方法克隆并放置章节代码后，你可以在IDE窗口左侧的文件树视图中探索内容。点击任何文件都会让你在主窗口中看到内容：
- en: '![](img/134e7da1-e4ea-4699-b96a-8e60222d0d5f.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/134e7da1-e4ea-4699-b96a-8e60222d0d5f.png)'
- en: Finally, build the workspace; note that this is something you will have to do
    each time you create a new package on your own or when you clone an external one.
    To do that, go to the top bar menu, select ROS, and then click on Build as before.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，构建工作空间；请注意，每次你创建自己的新包或克隆外部包时，你都需要做这件事。为此，转到顶部菜单栏，选择ROS，然后像以前一样点击构建。
- en: A node publishing a topic
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布主题的节点
- en: 'For the next steps, since we will need to deal with several simultaneous terminals,
    we will make use of a very handy tool, Terminator, that allows you to simultaneously
    handle several terminals. Launch these commands to install it on your system:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 对于接下来的步骤，由于我们需要处理多个同时终端，我们将使用一个非常方便的工具，即Terminator，它允许你同时处理多个终端。运行以下命令在你的系统上安装它：
- en: '[PRE36]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Launch Terminator and divide the screen into four terminals (you can right-click
    on the mouse to divide the windows successively). We will reference them as `T1`,
    `T2`, `T3`, and `T4`, as shown in the following screenshot:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 启动Terminator并将屏幕分为四个终端（你可以通过鼠标右键连续分割窗口）。我们将它们分别称为`T1`、`T2`、`T3`和`T4`，如下面的截图所示：
- en: '![](img/06cbf42b-79ef-48dc-a1be-d481b96891d6.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/06cbf42b-79ef-48dc-a1be-d481b96891d6.png)'
- en: 'Launch the roscore node in terminal 1 (the top-left window):'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端1（左上角的窗口）中启动roscore节点：
- en: '[PRE37]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You should be able to see this output in `T1`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能在`T1`中看到这个输出：
- en: '![](img/6cd71e1e-4ecf-4ccc-92b8-ed8b90a9bc37.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6cd71e1e-4ecf-4ccc-92b8-ed8b90a9bc37.png)'
- en: This is the root process of ROS. roscore launches a node and starts the master
    service, as ROS is a centralized system. The master node is always needed so that
    other nodes may execute and it has to be launched prior to any other node.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这是ROS的根进程。roscore启动一个节点并启动主服务，因为ROS是一个集中式系统。主节点始终是必需的，以便其他节点可以执行，并且必须在任何其他节点之前启动。
- en: 'In the next terminal, `T2`, run this command to launch the publisher node:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个终端`T2`中，运行以下命令来启动发布者节点：
- en: '[PRE38]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This launches the `topic_publisher` node, but nothing happens! That's right.
    A publisher is just that, a publisher. We need a listener to know what data is
    being sent.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动`topic_publisher`节点，但没有任何事情发生！没错。发布者就是那样，一个发布者。我们需要一个监听器来了解正在发送什么数据。
- en: 'Go to terminal 3 and list the topics currently declared:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 前往终端3并列出当前声明的主题：
- en: '[PRE39]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In the listing, it appears that `/counter` is the topic that updates an incremental
    counter every 0.5 seconds. The other two topics, `/rosout` and `/rosout_agg`,
    are the console log-reporting ([http://wiki.ros.org/rosout](http://wiki.ros.org/rosout))
    mechanisms in ROS.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表中，`/counter`似乎是一个每0.5秒更新增量计数器的主题。其他两个主题`/rosout`和`/rosout_agg`是ROS中的控制台日志报告机制。
- en: 'This line of the `topic_publisher.py` file is the one that sets up the `/counter`
    topic publisher:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`topic_publisher.py`文件中的这一行设置了`/counter`主题发布者：'
- en: '[PRE40]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'To watch the published messages, launch this command in the terminal:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看发布的消息，请在终端中运行此命令：
- en: '[PRE41]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This will output the next five messages that will be published in the `/counter` topic:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出将在`/counter`主题中发布的下五条消息：
- en: '[PRE42]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Finally, we will show a live view that will print the real-time frequency at
    which the messages are sent:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将展示一个实时视图，它会打印发送消息的实时频率：
- en: '[PRE43]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Press *Ctrl* + *C* to stop the log in `T3`. Bear in mind that, if you do this
    in any of the two previous terminals, the process that each one controls will
    die with the following consequences:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 按*Ctrl* + *C*停止`T3`中的日志。请注意，如果你在前两个终端中的任何一个终端这样做，每个终端控制的进程都将终止，并产生以下后果：
- en: '**Terminal T2**: The publisher process will end and no more messages will be
    sent through the `/counter` topic.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**终端T2**：发布者进程将结束，并且不再通过`/counter`主题发送消息。'
- en: '**Terminal T1**: Pressing *Ctrl* + *C* in this terminal will kill roscore,
    making it evident that this process is a single point of failure in ROS, that
    is, all related processes (including nodes and messages) will die.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**终端T1**：在此终端中按下*Ctrl* + *C*将终止roscore，这使人们明显看出，这个过程是ROS的单点故障，也就是说，所有相关进程（包括节点和消息）都将终止。'
- en: A node that listens to the topic
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监听主题的节点
- en: As there is one node that publishes the incremental counter in the `/counter` topic,
    we will now launch a node that subscribes to this topic.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 由于有一个节点在`/counter`主题上发布增量计数，我们现在将启动一个订阅此主题的节点。
- en: 'To start, let''s visualize the current ROS graph by issuing the following command
    in `T3`:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们通过在`T3`中发出以下命令来可视化当前的ROS图：
- en: '[PRE44]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'A window pops up and shows this:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 一个窗口会弹出并显示以下内容：
- en: '![](img/d2782ae9-27d4-4dbc-8bd8-524bc33c7434.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d2782ae9-27d4-4dbc-8bd8-524bc33c7434.png)'
- en: 'There is a single node, that is, the one we launched in `T2`. The `/counter` topic does
    not appear because no other node is listening to it. In order to make the topic
    show, launch the listener in `T4`:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 只有一个节点，即我们在`T2`中启动的那个。`/counter`主题没有出现，因为没有其他节点在监听它。为了使主题显示，请在`T4`中启动监听器：
- en: '[PRE45]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: You will see this log in the bottom-right terminal window, a neverending live
    data stream unless you kill (press *Ctrl* + *C*) any of  `T1` or `T2`, that correspond
    to `roscore` and `topic_publisher` respectively.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在右下角的终端窗口中看到这个日志，除非你终止（按*Ctrl* + *C*）`T1`或`T2`中的任何一个，它们分别对应于`roscore`和`topic_publisher`。
- en: '![](img/ae94c3ac-996c-45f7-ace7-99c50c2aee9e.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ae94c3ac-996c-45f7-ace7-99c50c2aee9e.png)'
- en: 'If you go back to the ROS graph window and click on the update icon, you will
    see the `/topic_publisher` node, the `/counter` topic that routes the messages,
    and the `/topic_subscriber` listening node:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回到ROS图窗口并点击更新图标，你会看到`/topic_publisher`节点，路由消息的`/counter`主题，以及监听节点`/topic_subscriber`：
- en: '![](img/e892e914-fe48-46cb-94ed-433fec69914a.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e892e914-fe48-46cb-94ed-433fec69914a.png)'
- en: This simple example illustrates the publish/subscribe architecture of communication
    in ROS. You can already appreciate how it works and how simple the underlying
    communication principle is, which is in the base of the ROS framework. We will
    now do something practical.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的例子说明了ROS中通信的发布/订阅架构。你已经可以欣赏到它是如何工作的，以及底层通信原理是多么简单，这是ROS框架的基础。我们现在将做一些实际的操作。
- en: 'Let''s make our counter behave like a chronometer. How can we do this? Well,
    you just need to modify the script `topic_publisher.py`, by changing the parameter
    that specifies the number of times per second that a message is sent to the topic,
    a concept known as the publishing **frequency**, whose units are *Hertz* (= number
    of times/second). In the script, the Python object that accounts for this behavior
    is:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们的计数器表现得像一个计时器。我们该如何做呢？嗯，你只需要修改脚本`topic_publisher.py`，通过更改指定每秒向主题发送消息次数的参数，这个概念被称为发布的**频率**，其单位是*赫兹*（=次数/秒）。在脚本中，负责这种行为的Python对象是：
- en: '[PRE46]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In the loop below in the script, the configured behavior is achieved by applying
    the **rospy** method `sleep` method to the defined `rate` object:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本下面的循环中，通过将**rospy**的`sleep`方法应用于定义的`rate`对象来实现配置的行为：
- en: '[PRE47]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Remember that **rospy** is the ROS library that allows us to run nodes whose
    code is written in Python. **rospy** defines a set of methods to make useful stuff
    in ROS, such as setting a publishing frequency in this way.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，**rospy**是允许我们运行用Python编写的节点的ROS库。**rospy**定义了一组方法来在ROS中实现有用的功能，例如以这种方式设置发布频率。
- en: 'The line above states that two messages are published every second, that is,
    one message every 0.5 seconds. Hence if `rate` is set to 1 Hz, the frequency will
    be one message per second, therefore emulating a chronometer. You can modify such
    script `topic_publisher.py` without needing to stop ROS, and, as soon as you execute
    it again, the node is back in the graph. Let''s show you how to do it step by
    step:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的行表示每秒发布两条消息，即每0.5秒一条消息。因此，如果`rate`设置为1 Hz，频率将是每秒一条消息，因此模拟了一个计时器。你可以在不需要停止ROS的情况下修改这样的脚本`topic_publisher.py`，并且一旦再次执行它，节点就会回到图中。让我们一步一步地展示如何做：
- en: Hit *Ctrl* + *C* in terminal `T2` to stop the execution of the node.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端`T2`中按*Ctrl* + *C*停止节点的执行。
- en: Modify the file to publish at a rate of 1 Hz, as shown previously.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改文件以以1 Hz的速率发布，如之前所示。
- en: 'Then, relaunch the node:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，重新启动节点：
- en: '[PRE48]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: You will see the effect in terminal `T4` from where `topic_subscriber.py` was
    launched. Therefore, the speed of new lines appearing (that is, counts) will be
    double compared to before when the rate was 2 Hz. This will produce one counter
    update (+1) per second, which corresponds to the rate of 1 Hz.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在启动`topic_subscriber.py`的终端`T4`中看到效果。因此，新行出现的速度（即计数）将是之前的两倍，当速率是2 Hz时。这将产生每秒一次的计数更新（+1），对应于1
    Hz的速率。
- en: Combining the publisher and subscriber in the same node
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在同一节点中结合发布者和订阅者
- en: 'Can a node talk and listen at the same time as a real human does? Well, if
    ROS is a framework for robotics, it should be possible. Let''s explore this:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 一个节点能否像真实人类一样同时说话和监听？嗯，如果 ROS 是一个机器人框架，那么这是可能的。让我们来探索这个问题：
- en: 'Launch these two commands in the first two terminals, with each one in an independent
    terminal:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前两个终端中启动这两个命令，每个命令都在一个独立的终端中：
- en: '[PRE49]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '`/doubler` is a node that subscribes to the `/number` topic, as specified in
    these two lines of the `doubler.py` script:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`/doubler` 是一个订阅 `/number` 主题的节点，如 `doubler.py` 脚本中的这两行所述：'
- en: '[PRE50]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Additionally, `/doubler` publishes its result in the `/doubled` topic:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`/doubler` 还在 `/doubled` 主题中发布其结果：
- en: '[PRE51]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'You will notice that nothing happens, because it needs to be fed with a number
    that can be multiplied by 2, as shown in the callback of `topic_subscriber.py`:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到没有任何事情发生，因为它需要被喂以可以乘以 2 的数字，如 `topic_subscriber.py` 的回调中所示：
- en: '[PRE52]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Launch a terminal for listening to the `/doubled` topic:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动一个用于监听 `/doubled` 主题的终端：
- en: '[PRE53]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Then, let''s publish a `/number` topic by hand:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们手动发布一个 `/number` 主题：
- en: '[PRE54]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The output in terminal `T3` is `4`, as expected:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`T3` 终端的输出是 `4`，正如预期的那样：'
- en: '[PRE55]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Try sending other numbers in `T4` and check that the double is shown immediately
    in `T3`.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `T4` 中尝试发送其他数字，并检查双倍值是否立即在 `T3` 中显示。
- en: 'If you issue `rqt_graph` in a fifth terminal, you will see something like this:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个第五个终端中发出 `rqt_graph`，你会看到类似这样的内容：
- en: '![](img/dee74e53-1ffc-4bdd-a5fa-2817f9659f63.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dee74e53-1ffc-4bdd-a5fa-2817f9659f63.png)'
- en: 'Here, you can see the `/number` and `/doubled` topics, the `/doubler` node,
    and two other nodes with large machine names whose correspondence are as follows:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，你可以看到 `/number` 和 `/doubled` 主题，`/doubler` 节点，以及两个具有大机器名称的其他节点，它们的对应关系如下：
- en: 'The node on the left of the preceding diagram, `/rostopic_5469_`, is created
    from the command in `T4`:'
  id: totrans-274
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前一图中左侧的节点 `/rostopic_5469_` 是由 `T4` 中的命令创建的：
- en: '[PRE56]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The node on the right, `/rostopic_5631_`, is created from the command in `T3`:'
  id: totrans-276
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右侧的节点 `/rostopic_5631_` 是由 `T3` 中的命令创建的：
- en: '[PRE57]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'To finish this exercise, we will feed the number to the `/counter` topic, not
    from the command line, but from the script of the publisher node we saw in the
    last section: `topic_publisher.py`. For the script to work properly, you have
    to modify the topic name in `doubler.py`, renaming it from `number` to `counter`:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成这个练习，我们将把数字喂给 `/counter` 主题，不是从命令行，而是从上一节中看到的发布节点脚本 `topic_publisher.py`
    中：将 `doubler.py` 中的主题名称修改为 `counter`：
- en: '[PRE58]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Then, after stopping all of the terminals, execute each of the following lines
    in an independent terminal:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在停止所有终端后，在每个独立的终端中执行以下每一行：
- en: '[PRE59]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'In this terminal, you will see the result of `counter` * 2 every time `/counter`
    is published. Take a look at the ROS graph (remember to click on the refresh button)
    and you will find that it reflects what is happening:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个终端中，每次发布 `/counter` 时，你将看到 `counter` * 2 的结果。看看 ROS 图（记得点击刷新按钮），你会发现它反映了正在发生的事情：
- en: '![](img/a16bfec5-d221-4e4e-8c10-5bfa81673fcc.png)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a16bfec5-d221-4e4e-8c10-5bfa81673fcc.png)'
- en: 'Bear in mind that `rqt_graph` will give you very useful information when debugging
    the code, for example, detecting any mistakes in the topic names. Take a look
    at the following figure, where multiplication by 2 does not work because `/topic_publisher` is
    subscribed to the `count` topic (note that the end `r` character is missing).
    The nodes are disconnected from one another, and the wrongly typed topic, which
    is not listened to by anyone, does not appear:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`rqt_graph` 在调试代码时将提供非常有用的信息，例如，检测主题名称中的任何错误。看看下面的图，其中乘以 2 不起作用，因为 `/topic_publisher`
    订阅了 `count` 主题（注意末尾缺少 `r` 字符）。节点彼此断开连接，错误输入的主题（没有人监听）没有出现：
- en: '![](img/45629828-fd88-4178-bc7b-9f7108aabb5f.png)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![](img/45629828-fd88-4178-bc7b-9f7108aabb5f.png)'
- en: In the next section, we will provide an overview of the extension of the ROS
    package system.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将概述 ROS 包系统的扩展。
- en: Using publicly available packages for ROS
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ROS 的公共包
- en: ROS-contributed packages are indexed on the official website at [http://www.ros.org/browse/list.php](http://www.ros.org/browse/list.php).
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: ROS 贡献的包在官方网站 [http://www.ros.org/browse/list.php](http://www.ros.org/browse/list.php)
    上索引。
- en: 'As of July 2018, ROS Indigo (the distribution released for Ubuntu 14.04 LTS)
    has more than 2,900 packages, while ROS Kinetic (2016, Ubuntu 16.04 LTS) has over
    1,600\. Some of the more popularly downloaded ones include the following:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 截至2018年7月，ROS Indigo（为Ubuntu 14.04 LTS发布的发行版）有超过2900个包，而ROS Kinetic（2016年，Ubuntu
    16.04 LTS）有超过1600个。其中一些下载量较大的包括以下内容：
- en: '`rviz` ([http://wiki.ros.org/rviz](http://wiki.ros.org/rviz)): The 3D visualization
    tool for ROS. You will start using this in [Chapter 4](742e6846-70e4-4bd4-8576-f3e4f445df3f.xhtml),
    *Creating the Virtual Two-**Wheeled ROS Robot*.'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rviz` ([http://wiki.ros.org/rviz](http://wiki.ros.org/rviz)): 这是ROS的3D可视化工具。您将在[第4章](742e6846-70e4-4bd4-8576-f3e4f445df3f.xhtml)，*创建虚拟双轮ROS机器人*中开始使用它。'
- en: '`gazebo_ros_pkgs` ([http://wiki.ros.org/gazebo_ros_pkgs](http://wiki.ros.org/gazebo_ros_pkgs)):
    This allows you to use the Gazebo 3D simulator from inside ROS. We will introduce
    Gazebo in [Chapter 5](74284adc-e0d7-4e40-a54b-e2e447b8e2fe.xhtml), *Simulating
    Robot Behavior with Gazebo*.'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gazebo_ros_pkgs` ([http://wiki.ros.org/gazebo_ros_pkgs](http://wiki.ros.org/gazebo_ros_pkgs)):
    这允许您在ROS内部使用Gazebo 3D模拟器。我们将在[第5章](74284adc-e0d7-4e40-a54b-e2e447b8e2fe.xhtml)，*使用Gazebo模拟机器人行为*中介绍Gazebo。'
- en: '`sensor-msgs` ([http://wiki.ros.org/sensor_msgs](http://wiki.ros.org/sensor_msgs)):
    This is a package that defines messages for commonly used sensors, such as cameras
    and scanning laser rangefinders.'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sensor-msgs` ([http://wiki.ros.org/sensor_msgs](http://wiki.ros.org/sensor_msgs)):
    这是一个定义常用传感器（如摄像头和扫描激光测距仪）消息的包。'
- en: '`tf2` ([http://wiki.ros.org/tf2](http://wiki.ros.org/tf2)): This is the package
    that deals with the transformation of coordinates between the many reference systems
    used in the environment.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tf2` ([http://wiki.ros.org/tf2](http://wiki.ros.org/tf2)): 这是一个处理环境中所用到的多个参考系之间坐标变换的包。'
- en: '`laser-geometry` ([http://wiki.ros.org/laser_geometry](http://wiki.ros.org/laser_geometry)):
    This makes it possible to transform a 2D laser scan into a point cloud for use
    in navigation.'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`laser-geometry` ([http://wiki.ros.org/laser_geometry](http://wiki.ros.org/laser_geometry)):
    这使得将2D激光扫描转换为点云以用于导航成为可能。'
- en: This should give you a neat view of what programming in ROS will mean for you.
    In other words, integrate software developed by others (that is, packages) and
    make them work together—by designing a coherent ROS graph—to build up the functionality
    you wish your robot to have.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该能给您一个清晰的了解，ROS编程对您意味着什么。换句话说，集成其他开发者（即包）开发的软件，并通过设计一个连贯的ROS图来使它们协同工作，以构建您希望机器人拥有的功能。
- en: Summary
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we introduced ROS and practiced with simple examples in order
    to help you understand the architecture of ROS. The top-level entity is the workspace,
    which is an isolated environment for building and running your software.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了ROS，并通过简单的示例进行实践，以便帮助您理解ROS的架构。顶级实体是工作空间，它是一个用于构建和运行软件的独立环境。
- en: The workspace is constituted by ROS packages, that is, premade pieces of software that
    provide specific functionalities to integrate into your robot. Following this,
    catkin is the tool used to build the software each time you include new packages
    in your workspace.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 工作空间由ROS包组成，即提供特定功能以集成到您的机器人中的预制的软件块。随后，catkin是每次您在工作空间中包含新包时用于构建软件的工具。
- en: The node is the basic entity in ROS and holds the functional pieces of code
    that make the robot work. A collection of related nodes providing specific functionalities
    constitute a ROS package. **roscore**, the process that runs the master node,
    is the one that allows each node to be capable of finding others by subscribing to
    the published topics. **roscore** also manages the database for the ROS parameters.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 节点是ROS中的基本实体，它包含使机器人工作的功能代码块。提供特定功能的节点集合构成了一个ROS包。**roscore**，运行主节点的进程，允许每个节点通过订阅发布的主题来找到其他节点。**roscore**还管理ROS参数的数据库。
- en: Communication between nodes is possible thanks to topics, the channels—edges
    of the ROS graph—through which the exchanged information flows. When a node needs
    to use the information of a topic, it does so by subscribing to it.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 节点之间的通信是通过主题实现的，主题是ROS图中的通道——信息流过的边缘。当一个节点需要使用主题的信息时，它通过订阅它来实现。
- en: In the next chapter, you will learn how to build a virtual model of a differential
    drive robot, one that emulates GoPiGo3 characteristics. The chapter will also
    provide you with the methodology to test your code first with the virtual robot,
    and then install and execute it in the physical robot.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何构建一个差速驱动机器人的虚拟模型，该模型模拟GoPiGo3的特性。本章还将为你提供方法，首先使用虚拟机器人测试你的代码，然后安装并在物理机器人上执行它。
- en: Questions
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the top-level component in a ROS environment?
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ROS环境中的顶级组件是什么？
- en: A) Package
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: A) 包
- en: B) Workspace
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: B) 工作空间
- en: C) ROS graph
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: C) ROS图
- en: What is the purpose of the roscore process?
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: roscore进程的目的是什么？
- en: A) To allow a node to communicate with others and manage the robot parameters
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: A) 允许节点与其他节点通信并管理机器人参数
- en: B) To provide a master node for driving all other nodes in the graph
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: B) 为图中的所有其他节点提供主节点
- en: C) To allow ROS nodes to be found from outside of the LAN
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: C) 允许ROS节点从LAN外部被发现
- en: 'Mark the correct sentence: A node can __ .'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 标记正确的句子：一个节点可以 __ 。
- en: A) only publish topics or only subscribe to topics
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: A) 只发布主题或只订阅主题
- en: B) publish topics and subscrib to topics at the same time
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: B) 同时发布主题和订阅主题
- en: C) publish topics and/or subscribe to other topics
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: C) 发布主题和/或订阅其他主题
- en: What happens if one node fails to execute its program?
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一个节点未能执行其程序，会发生什么？
- en: A) Some functions of the robot will fail
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: A) 机器人的一些功能将失败
- en: B) The robot will not work
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: B) 机器人将无法工作
- en: C) The topics it publishes will be set to undefined
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: C) 它发布的主题将被设置为未定义
- en: 'Mark the incorrect sentence: The way to identify a message in a published topic
    is __.'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 标记错误的句子：在发布的主题中识别消息的方法是 __。
- en: A) to launch a node that publishes data in such topic
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: A) 启动一个发布此类主题数据的节点
- en: B) to issue the `$ rostopic echo </topic_name>` command
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: B) 输入 `$ rostopic echo </topic_name>` 命令
- en: C) to write a node that subscribes to that topic
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: C) 编写一个订阅该主题的节点
- en: Further reading
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To go deeper into the concepts we have explained in this chapter, you can follow
    the links and tutorials:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 要深入了解本章中解释的概念，你可以遵循以下链接和教程：
- en: ROS tutorial*s:*[http://wiki.ros.org/ROS/Tutorials](http://wiki.ros.org/ROS/Tutorials) (sections
    1 through 6)
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ROS教程*s:*[http://wiki.ros.org/ROS/Tutorials](http://wiki.ros.org/ROS/Tutorials) (第1节至第6节)
- en: '*ROS Robotics By Example, Second Edition, Fairchild C*., *Harman*, *Packt Publishing*,
    T. L. (2017), *Chapter 1, Getting Started with ROS:* [https://www.packtpub.com/hardware-and-creative/ros-robotics-example-second-edition](https://www.packtpub.com/hardware-and-creative/ros-robotics-example-second-edition).'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ROS机器人实例，第二版，Fairchild C.，Harman，Packt Publishing，T. L*。（2017），*第一章，ROS入门*：[https://www.packtpub.com/hardware-and-creative/ros-robotics-example-second-edition](https://www.packtpub.com/hardware-and-creative/ros-robotics-example-second-edition)。'
- en: '*Programming Robots with ROS*, *Quigley M., Gerkey B., Bill Smart B*. (2015),
    *First Edition, O''Reilly*: [http://shop.oreilly.com/product/0636920024736.do](http://shop.oreilly.com/product/0636920024736.do) (*Chapter
    2*, *Preliminaries,* and *Chapter 3*, *Topics)*.'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用ROS编程机器人*，*Quigley M.，Gerkey B.，Bill Smart B*。（2015），*第一版，O''Reilly*：[http://shop.oreilly.com/product/0636920024736.do](http://shop.oreilly.com/product/0636920024736.do) (*第二章*，*预备知识*和*第三章*，*主题*）。'
