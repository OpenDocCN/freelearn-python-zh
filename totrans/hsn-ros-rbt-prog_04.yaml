- en: Getting Started with ROS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Robot Operating System** (**ROS**) is an open source piece of software. Its
    development started at Willow Garage, a technology incubator and robotics research
    laboratory. Its origin dates back to several projects at Stanford University from
    the mid-2000s, where researchers found themselves reinventing the wheel every
    time they had to build the software for each project.'
  prefs: []
  type: TYPE_NORMAL
- en: In 2007, Willow Garage took the lead and gave rise to ROS. The main goal was
    to reuse existing code and make it possible to prototype new robot designs quickly,
    focusing on high-level functionality and minimizing the need for editing code.
    If you are curious about how ROS has become the *de facto* standard for robot
    application development, you can view an interactive page at [https://www.ros.org/history](https://www.ros.org/history).
  prefs: []
  type: TYPE_NORMAL
- en: ROS is intended for the development of applications where different devices
    have to talk to each other in order to create a flexible and scalable environment. This
    chapter explains the basic concepts of ROS. It will introduce you to the framework
    using an easy language while avoiding very technical descriptions. This is because
    our first goal is to neatly show you what ROS is in a conceptual sense. In the
    following chapters, we will have the opportunity to cover technical descriptions;
    the ones that, in any case, you will need later in order to be able to use ROS
    in your projects.
  prefs: []
  type: TYPE_NORMAL
- en: In the first section of this chapter, we will cover how ROS works under the
    hood, and why it should not be simply considered as a specific-purpose programming
    language, but a framework for developing robotics apps. You will dive into the
    core concepts of the ROS graph and the asynchronous communication between nodes.
  prefs: []
  type: TYPE_NORMAL
- en: In the second section, you will be guided step by step to configure the ROS
    environment on your laptop.
  prefs: []
  type: TYPE_NORMAL
- en: In the third section, guided with a practical exercise, you will learn how to
    exchange simple messages between nodes using the command line.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will give you an overview of the many available ROS packages that
    have been contributed by the open source community.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: ROS basic concepts and the ROS graph
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring your ROS development environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Communication between ROS nodes: messages and topics'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using publicly available packages for ROS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The practical aspects of this chapter require you to have access to a desktop
    computer or laptop with either of these two Ubuntu versions:'
  prefs: []
  type: TYPE_NORMAL
- en: Ubuntu 16.04 Xenial
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ubuntu 18.04 Bionic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Long-term support** (**LTS**) Ubuntu versions are maintained by Canonical
    for the next 5 years. Also, these kind of versions are released in even years.
    Hence, Ubuntu 16.04- released in 2016- will be maintained up to 2021, while Ubuntu
    18.04- released in 2018- will be maintained up to 2023\. We will not consider
    odd-year versions, that is, Ubuntu 17 or Ubuntu 19 because they are development
    releases that are not LTS.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open Robotics releases a new version of ROS every year coinciding with every
    Ubuntu version. The correspondence is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: ROS Kinetic running under Ubuntu 16.04 Xenial
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ROS Melodic running under Ubuntu 18.04 Bionic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most used version as of the writing of this book is ROS Kinetic. The practical
    examples provided in the following chapters are valid for both Ubuntu 16.04 and
    Ubuntu 18.04\. Hence, they will work for ROS Kinetic as well as for ROS Melodic.
  prefs: []
  type: TYPE_NORMAL
- en: When we don't make any distinction between Ubuntu or ROS versions, you should
    assume that they work for the two versions covered. If there is some difference
    in the commands or scripts to be run depending on the version, we will mention
    it explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: The code for this chapter can be found in `Chapter3_ROS_basics` of the book
    repository, which is hosted on GitHub at [https://github.com/PacktPublishing/Hands-On-ROS-for-Robotics-Programming/tree/master/Chapter3_ROS_basics](https://github.com/PacktPublishing/Hands-On-ROS-for-Robotics-Programming/tree/master/Chapter3_ROS_basics).
    In the *Setting up the ROS package* section, you will learn how to download the
    code and make it work with your ROS installation.
  prefs: []
  type: TYPE_NORMAL
- en: ROS basic concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Early on, researchers of robotics at Stanford University found that prototyping
    software for robots was an intensive programming task, as they had to start coding
    from scratch for every project. There was a time in which programming languages
    such as C++ and Python were used for robotics as the general programming languages
    they are, and that fact required great efforts to build every piece of software
    to provide a robotic level of functionality, such as navigation or manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: 'It was not only a question of the reusability of the code, but it was also
    a matter of how things worked in robotics. In procedural programming, the typical
    flow of a program executes one step after another, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6dd10742-5596-4ac9-8267-479e8e7570be.png)'
  prefs: []
  type: TYPE_IMG
- en: The task that this program executes is to combine multiple images into one,
    as can be easily inferred. From our robotic point of view, the main drawback of
    a process working like this is that, if some steps fail to execute, then the process
    cannot go on and, therefore, fails to deliver its results, that is, a combined
    image. If we use the analogy of robotics, this would mean that a humanoid robot
    transporting a light object (for example, a paper book) from one place to another
    may fail in its task if one of its arms does not work properly (the motor that
    drives the articulation of its elbow is broken, for example). The humanoid should
    be able to do the task with the other arm for sure. And this is what ROS does!
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at the following example of a ROS graph.
  prefs: []
  type: TYPE_NORMAL
- en: The ROS graph
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This graph is to ROS what a workflow diagram is to procedural programming:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/72ca14dd-2590-4f14-9ad6-3de7fdc49162.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding graph, each circle—called a **node**—represents an independent
    program (this can be written in Python, Java, C++, Ruby, Node.js, or any of the
    other programming languages that ROS has implemented). The connections between
    them—called **edges**—represent the exchange of information. The meaning behind
    the direction of the arrows is self-explanatory: the emitter of data is the node
    where the arrow starts, and the receiver node is the one where the arrow points
    to. The words that appear above the edges are what ROS calls **topics**, and they
    constitute the channels through which flows the information exchanged between
    the nodes. When a node needs to use the information of a topic, it does so by
    subscribing to it and this operation adds a new arrow to the graph from the producer
    (of the data for such topic) to the subscriber node.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what does this graph do from the point of view of the robot? Remember that
    GoPiGo3 is a classical differential drive robot, where each wheel can be turned
    independently, and the sensor—for example, a distance sensor—provides the robot
    with information about how far away the obstacle is while moving:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9401dda2-996f-40c9-9f80-b4b20ab4f812.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Image courtesy: Dexter Industries https://32414320wji53mwwch1u68ce-wpengine.netdna-ssl.com/wp-content/uploads/2017/05/GPG3_FullServoDistanceGoogly_1-800x800.jpg'
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, you might have already guessed that in the preceding ROS graph, the `L_servo` node
    is the program that controls the left servomotor (by rotating that wheel) and
    the `R_servo` node does the same with the right wheel.
  prefs: []
  type: TYPE_NORMAL
- en: The `sensor` node is the one that takes the readings from the distance sensor
    and makes them available to the `control` node through the edge that is connected
    to it, that is, by using the `/sharp_data` topic.
  prefs: []
  type: TYPE_NORMAL
- en: Within the `control` node resides the program that takes the decision of what
    to do if GoPiGo3 is facing an obstacle. For example, it can rotate the robot until
    it finds a direction without any obstacles. Rotating means that the `control`
    node sends opposite commands to the `L_servo` and `R_Servo` nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'These signals are the ones that flow through the corresponding edges of the
    graph: the `/speed_left` topic or the left servo and `/speed_right` for the other
    one. In the ROS language, we say that the `control` node publishes the command
    for the left servo in the `/speed_left` topic.'
  prefs: []
  type: TYPE_NORMAL
- en: roscore
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**roscore** is the mandatory and first node that has to be launched so that
    the ROS environment can be running. This allows every node to be capable of finding
    any other node by subscribing to the topics it publishes. roscore also manages
    the database for ROS parameters—the values that define the robot configuration.
    As a result, if the roscore process dies, the master node fails, and the robot
    stops working. You may guess that this single point of failure is a clear limitation
    for a distributed computed framework such as ROS. For this reason, ROS2 has addressed
    this issue, and the running software no longer requires a master node. Communication
    between the nodes relies on the **DDS** (short for **Data Distribution Service**) architecture for
    real-time systems.'
  prefs: []
  type: TYPE_NORMAL
- en: Can you see how different programming a robot is from writing a software application?
    In robotics, you focus on the top-level functionalities of your application and
    integrate premade software pieces written by others.
  prefs: []
  type: TYPE_NORMAL
- en: Do take into account that not all software in robotics follows this approach.
    In fact, among its many uses, we selected ROS because its philosophy adapts very
    well to the *learn-through-practice* methodology that we have adopted for this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: These pieces of software, which consist of code blocks grouped into nodes, form
    what we call a **ROS package**. Several related nodes constitute a ROS package
    that delivers a specific functionality, for example, object recognition with a
    camera.
  prefs: []
  type: TYPE_NORMAL
- en: Workspaces and catkin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A workspace in ROS is an isolated environment for building and running your
    software. You may use different workspaces to manage different projects. The workspace
    will contain all the ROS packages you will need for your project.
  prefs: []
  type: TYPE_NORMAL
- en: Physically, it is a folder in your home directory that contains all of the specific
    files of your application in such a way that deploying this workspace in another
    machine with ROS preinstalled will work properly and do the same as it did on
    the original computer.
  prefs: []
  type: TYPE_NORMAL
- en: Tightly attached to the concept of the workspace is catkin, the build system
    of ROS that combines CMake macros and Python scripts to provide functionality
    on top of CMake's normal workflow. At this point, it is enough that you are aware
    that this is a tool used to build the software each time you include new packages
    in your workspace. You can find an in-depth conceptual explanation of catkin at [http://wiki.ros.org/catkin/conceptual_overview](http://wiki.ros.org/catkin/conceptual_overview).
  prefs: []
  type: TYPE_NORMAL
- en: Configuring your ROS development environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will guide you on how to install and configure the tools
    that you will need to work comfortably with ROS on your laptop. In short, these
    are the steps you need to complete before starting the practical exercises in
    this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that your computer runs **Ubuntu 16.04** or **Ubuntu 18.04**. Both
    are the LTS releases that have the most extensive collection of ROS packages at
    the time of writing this book.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install and set up **ROS** on your laptop. You will also be provided with the
    guidelines to install ROS in the Raspberry Pi, the CPU of the GoPiGO3 robot. However,
    in part 2 of the book, you will only need your laptop, since we will be dealing
    with a virtual model of the robot. The inclusion of the physical robot is left
    for part 3 of the book.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the *Integrated Development Environment* (**IDE**) we will use **RoboWare
    Studio**, which is based on the general purpose IDE by Microsoft called **Visual
    Studio Code**. We provide the instructions to set it up in the *Installing RoboWare
    Studio* section below.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So, provided your laptop has the required operating system, let's now move on
    to the second step of the configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Installing ROS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you work under Ubuntu 16.04, you will need to install the Kinetic distribution of
    ROS. On the other hand, if you have Ubuntu 18.04, the corresponding version of ROS to
    install is called Melodic. Remember that these choices were explained in detail
    in the *Technical requirements* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before installing the software, make sure that you have the two basic `curl`
    and `git` tools. If this is not the case, then run the following command to install
    the missing ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The instructions on the **ROS Kinetic** installation page ([http://wiki.ros.org/kinetic/Installation/Ubuntu](http://wiki.ros.org/kinetic/Installation/Ubuntu))
    are pretty clear and straightforward. They are the same for your laptop (*amd64/i386*)
    and for the Raspberry Pi (the *armhf* architecture). They are included here for
    the completion of the description.
  prefs: []
  type: TYPE_NORMAL
- en: '**ROS Melodic** also has an installation page at [http://wiki.ros.org/melodic/Installation/Ubuntu](http://wiki.ros.org/melodic/Installation/Ubuntu).
    There, you will find that the commands are the same as those for Kinetic, because
    they are written in such a way that are not dependent on the Ubuntu version of
    choice.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Following the next steps you will get ROS up and running in your laptop:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, add the source repository for ROS:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This command adds ROS repository sources to your system. Since such a source
    is dependent on the Ubuntu version, the inner command  `$(lsb_release -sc)` in
    the snippet above outputs the version, i.e. **xenial** for Ubuntu 16.04 and **bionic** or
    Ubuntu 18.04.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, set up your keys:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can use `curl` instead of the `apt-key` command. This is
    useful if you are behind a proxy server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If you do not get the key to be validated, then it may have been changed for
    security reasons (as of February 2020, the key remains active). If it is not the
    case at this moment, go to the official installation page at [http://wiki.ros.org/melodic/Installation/Ubuntu](http://wiki.ros.org/melodic/Installation/Ubuntu) and
    find the section, where the key value `0xC1CF6E31E6BADE8868B172B4F42ED6FBAB17C654`
    needs to be replaced.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update your sources:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have Ubuntu 16.04 on your laptop, install the full stack of ROS Kinetic,
    including the simulator called **Gazebo**, navigation, and robot perception packages
    (recommended):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are working in Ubuntu 18.04, perform the installation of ROS Melodic
    instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you may install the desktop version, which only includes the ROS
    GUI tools (`rqt`, `rviz`). Later on, you can add the packages for simulation (Gazebo),
    navigation, and perception when needed (remember that these are installed with
    full version outlined in step 4 above):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, if you are in Ubuntu 18.04, you can use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize `rosdep`. This is the component that enables you to easily install
    system dependencies for the source code to compile. It is also required in order
    to run some core components in ROS:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Set up the ROS environment for your interactive shell session:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, if you are in Ubuntu 18.04, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'To avoid having to run this command each time you open a new terminal, include
    it at the end of your `.bashrc` file with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The second command in the snippet above executes the **.bashrc** file refreshing
    your custom setup. If in Ubuntu 18.04, just replace `kinetic` for `melodic`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, install `rosinstall`, the command-line tool that enables you to easily
    download many source trees for ROS packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Bear in mind that, as you become more familiar with the communication between
    the Raspberry Pi in the robot and your laptop, you can make all the desktop interactions
    from your computer and let the Raspberry Pi execute only robotics-specific tasks.
    This approach will make GoPiGo3 more responsive because you will have a minimal
    Ubuntu server in the Raspberry Pi and the ROS base version, which excludes the
    GUI tools and has only the core packages, as well as the build and communication
    libraries.
  prefs: []
  type: TYPE_NORMAL
- en: You can refer to the next section for specific details on how to prepare the
    ROS environment for the robot.
  prefs: []
  type: TYPE_NORMAL
- en: Ubuntu and ROS in the Raspberry Pi
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since you will be using only the core ROS packages in your Raspberry Pi, it
    is recommended that you install the latest Ubuntu LTS version, that is, Ubuntu
    Mate 18.04 Bionic ([https://ubuntu-mate.org/download/](https://ubuntu-mate.org/download/)).
    This is because, although almost all contributed ROS packages are available for ROS
    Kinetic, it is also true that core packages are already available in the 2018
    version of ROS Melodic. Therefore, it is safe to install this release in the Raspberry
    Pi under Ubuntu 18.04.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned already, the instructions on the ROS Melodic installation page
    ([http://wiki.ros.org/melodic/Installation/Ubuntu](http://wiki.ros.org/melodic/Installation/Ubuntu))
    are pretty clear and straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow the next guidelines to decide which version to install:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If installing ROS Desktop (which is recommended for beginners and for covering
    the contents of this book), use the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If you wish to install the bare-bones version, that is, ROS Base, and so get
    a better performance from your Raspberry Pi, then use this command (this is only
    recommended for advanced users; at the moment, there is no desktop GUI):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned at the beginning of the section, for this chapter you will only
    need a laptop. The physical robot is left for part 3 of the book, starting from
    [Chapter 6](0b20bdff-f1dc-42e8-ae83-fc290da31381.xhtml), *Programming in ROS –
    Commands and Tools*. In that chapter, we will provide the necessary details to
    correctly set up the software in the Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: Integrated Development Environment (IDE)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the section of ROS wiki devoted to *Integrated Development Environments* ([http://wiki.ros.org/IDEs](http://wiki.ros.org/IDEs))
    are described the currently available IDEs for ROS—a total of 15 IDEs exist at
    the time of writing this book. Out of all of these options, we have selected to
    work with RoboWare Studio because of the following factors:'
  prefs: []
  type: TYPE_NORMAL
- en: It is a fork of **Visual Studio Code** (**VSC**), the general-purpose and customizable
    IDE by Microsoft that is extensively used in the developer community. It is open
    source, light, easy to use and offers lots of contributed plugins, making it possible
    to customize the IDE environment to your own specific needs. **RoboWare Studio**
    is built on top of VSC code to provide ROS development functionalities. Furthermore,
    the plugin panel of the IDE is customized so that you can easily install ROS packages
    on demand. The current version is 1.2.0, which was issued in June 2018\. Its code
    is open source and it is publicly available in GitHub at *TonyRobotics/RoboWare-Studio*
    ([https://github.com/TonyRobotics/RoboWare-Studio](https://github.com/TonyRobotics/RoboWare-Studio)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RoboWare Studio **out-of-the-box features allow you to start working with
    all of ROS''s main characteristics: workspaces, packages, nodes, messages/services/actions,
    and more.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For all of the explanations in this book, we will always give you the commands
    to be executed in `bash`, as this is the native way of commanding ROS.
  prefs: []
  type: TYPE_NORMAL
- en: 'IDEs such as RoboWare Studio may be of help in at least two scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: When beginning with ROS, to avoid dealing with the complexity of the command
    line if you are not very familiar with it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When developing projects, where the IDE facilitates the management of the large
    number of files that are spread along with the ROS packages that make up your
    application. Such packages provide functionalities such as coordinate transformations,
    computer vision, robot navigation, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In any case, our advice is that you do the first round of this book using RoboWare
    Studio, and, for the second round, go directly to `bash`. If you want to skip
    one of them, then discard the IDE option and keep learning with the command line.
    Practicing `bash` commands is the best way to really understand how ROS works,
    and you surely know that this applies not only for ROS but for any other software
    tool running under Linux OS.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, from now on, use the IDE of your choice for editing files, and always
    work with the ROS command line (or RoboWare if you prefer to keep working with
    a GUI interface).
  prefs: []
  type: TYPE_NORMAL
- en: Installing RoboWare Studio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Provided that you have already installed ROS on your computer, execute the
    following block of commands in a terminal to install the required dependencies,
    as indicated in the manual of RoboWare Studio available at [https://github.com/TonyRobotics/RoboWare/blob/master/Studio/RoboWare_Studio_Manual_1.2.0_EN.pdf](https://github.com/TonyRobotics/RoboWare/blob/master/Studio/RoboWare_Studio_Manual_1.2.0_EN.pdf):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, install the `clang-format-3.8` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Binaries are hosted in GitHub at [https://github.com/TonyRobotics/RoboWare/blob/master/Studio](https://github.com/TonyRobotics/RoboWare/blob/master/Studio).
    You can download the latest version of RoboWare Studio in your Ubuntu OS for AMD64
    from this link: [https://github.com/TonyRobotics/RoboWare/raw/master/Studio/roboware-studio_1.2.0-1524709819_amd64.deb](https://github.com/TonyRobotics/RoboWare/raw/master/Studio/roboware-studio_1.2.0-1524709819_amd64.deb).
    You also have the source code available in GitHub at [https://github.com/tonyrobotics/roboware-studio](https://github.com/tonyrobotics/roboware-studio).
  prefs: []
  type: TYPE_NORMAL
- en: 'Installation is pretty easy; execute the following command from the location
    where you got the `.deb` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: After finishing, you can launch the IDE by clicking on the RoboWare Studio icon.
  prefs: []
  type: TYPE_NORMAL
- en: Communication between ROS nodes – messages and topics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will accomplish the goal of getting two nodes talking to each other by going
    step by step. First, you need to create a personal workspace, and then you will
    pull the book repository at [https://github.com/PacktPublishing/Hands-On-ROS-for-Robotics-Programming](https://github.com/PacktPublishing/Hands-On-ROS-for-Robotics-Programming),
    and go into the `Chapter3_ROS_basics` folder to follow the exercises by yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a workspace
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to create a workspace from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create the folders that you will need later to place your ROS packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the folder descriptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`catkin_ws` will be the root location of your workspace.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`src` is where you will place your code, that is, inside the ROS packages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be aware that **~** is equivalent to the home folder, that is, `/home/bronquillo`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Move to this last folder and issue the following command to initialize the
    workspace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The last command will generate the `~/catkin_ws/src/CMakeLists.txt` file, which
    contains the definition and configuration of the workspace. That file really is a
    symlink to a location in the ROS installation folder where the workspace configuration
    is defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Build the workspace for the first time; it does not matter that the folder
    is empty at this time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'By listing the content, you will see two new folders:'
  prefs: []
  type: TYPE_NORMAL
- en: '`build` contains the result of the compilation of our workspace, and makes
    available all the code you will place later when creating a package for its execution
    with ROS commands.'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '`devel` contains the configuration of the workspace, and it will be sourced
    every time you open a terminal (refer to the following steps).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Be aware that compilation has to be done at the root folder, `~/catkin_ws`,
    while workspace initialization was done in the application code folder, `~/catkin_ws/src`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add the workspace to your ROS environment, you need to source the generated
    `setup` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'To avoid having to run this command each time you open a new terminal, include
    it in your `.bashrc` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you should have the following two lines added to your `.bashrc` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Remember that the first line accounts for the ROS system configuration and the
    second for your workspace settings.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a workspace and building it using RoboWare
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following instructions allow you to use the RoboWare IDE to create the
    workspace, avoiding the use of the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Launch RoboWare and click on the New Workspace... item:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b39dca13-5fac-4b07-a04e-1509e187509d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the pop-up window, indicate the name of the workspace and select the folder
    where you want to place it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1dc1df84-ee79-4d87-806b-b6731188f727.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After setting the folder name, RoboWare executes `catkin_init_workspace` transparently
    for the user, and you will see a new file and a new folder on the left-hand side
    of your IDE window. They are the `src` folder and the file inside, `CMakeLists.txt`,
    which contains your workspace definition and configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/13f96ac6-236c-459e-9303-244edf80ecf4.png)'
  prefs: []
  type: TYPE_IMG
- en: For now, it is enough that you notice that the file has a symlink to a ROS system
    file located in the ROS installation folder,`/opt/ros/kinetic`. This folder contains
    the common configuration for all the workspaces you may create.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can open a terminal in RoboWare and list all files with the `ls -la` command from
    the specific `~/catkin/src` location:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9e5a5de7-cd9e-47bf-8d29-9183f7ec4539.png)'
  prefs: []
  type: TYPE_IMG
- en: Such a terminal is accessed from the top-bar menu, by clicking on the View item,
    and then selecting Integrated terminal (*Ctrl* + *`*) from the drop-down menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the build mode and set it to Debug, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/de495ea1-2116-4932-a056-64dd67b6854c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, from the top-bar menu, select ROS | Build:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c91c6db5-f60e-4e51-b9fb-63e8b579f266.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You will see the following log in the OUTPUT window at the bottom of the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/32182be7-c0b4-47bb-80b9-892e5de41995.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The last lines should look like this if successful:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/827dfbb8-08b5-4842-833b-f496dba956bf.png)'
  prefs: []
  type: TYPE_IMG
- en: Next, let's set up the ROS package.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the ROS package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps for setting up the ROS package:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From a terminal, clone the book repository, [https://github.com/PacktPublishing/Hands-On-ROS-for-Robotics-Programming](https://github.com/PacktPublishing/Hands-On-ROS-for-Robotics-Programming), into
    your home folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to copy the code of this chapter into the ROS workspace. That
    way, you will have a cleaner ROS environment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Do not add a backslash, `\n`, after the `src` folder name. If you do, the files
    will be copied directly into the `src` folder, not under **`src/Chapter3_ROS_basics`**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the `Chapter3_ROS_basics` folder, you can find the files of this chapter
    belonging to the first ROS package you will play with. Its configuration is contained
    in the `package.xml` file. Be aware that the package name is defined within the
    `<name>ros_basics</name>`tags. You can find it inside the following code file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, go to the workspace root and build again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In general, you will have to rebuild the workspace in at least two cases:'
  prefs: []
  type: TYPE_NORMAL
- en: Each time you include a new package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If your code contains pieces written in a compilable language such as C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this book, we will be working mainly with Python, the widely used open source
    language that makes it easier to get started with ROS. Since Python is an interpreted
    language, you will not need to rebuild the workspace each time you modify the
    code base of the package. Hence, the rebuild will only be necessary when adding
    or removing ROS packages. The way to check whether the newly added package—`ros_basics`—is
    known to ROS is to execute this simple command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Although here, we will be working from a premade ROS package, it is relevant
    that you know at this point how to create your own package from scratch. Issue
    this command from the `src` location of your workspace (`$ cd ~/catkin_ws/src/`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '`<YOUR-PACKAGE-NAME>` stands for the name you want to assign to your package. `<DEPENDENCIES>`
    refers to the list of ROS packages you will need for your code to run. For example,
    if your package is going to contain code in Python and C++, you will need `rospy`
    for the former and `roscpp` for the latter. Then, the command will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create a folder with the name given to the package and two files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`package.xml`: The package configuration as shown previously'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CMakelists.txt`: The input to the CMake build system for building software
    packages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CMakelists.txt` also contains the reference to`<YOUR-PACKAGE-NAME>`. For our
    case, this file is as simple as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Accessing package files and building the workspace using RoboWare
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here's an alternative method. The following demonstrates that you can clone
    a package repository and build the workspace using RoboWare.
  prefs: []
  type: TYPE_NORMAL
- en: 'After cloning and placing the code of the chapter, as explained in the *Setting
    up the ROS package* section, you can explore the content in the file tree view
    on the left-hand side of the IDE window. Clicking on any of the files will let
    you see the content in the main window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/134e7da1-e4ea-4699-b96a-8e60222d0d5f.png)'
  prefs: []
  type: TYPE_IMG
- en: Finally, build the workspace; note that this is something you will have to do
    each time you create a new package on your own or when you clone an external one.
    To do that, go to the top bar menu, select ROS, and then click on Build as before.
  prefs: []
  type: TYPE_NORMAL
- en: A node publishing a topic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the next steps, since we will need to deal with several simultaneous terminals,
    we will make use of a very handy tool, Terminator, that allows you to simultaneously
    handle several terminals. Launch these commands to install it on your system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Launch Terminator and divide the screen into four terminals (you can right-click
    on the mouse to divide the windows successively). We will reference them as `T1`,
    `T2`, `T3`, and `T4`, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/06cbf42b-79ef-48dc-a1be-d481b96891d6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Launch the roscore node in terminal 1 (the top-left window):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'You should be able to see this output in `T1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6cd71e1e-4ecf-4ccc-92b8-ed8b90a9bc37.png)'
  prefs: []
  type: TYPE_IMG
- en: This is the root process of ROS. roscore launches a node and starts the master
    service, as ROS is a centralized system. The master node is always needed so that
    other nodes may execute and it has to be launched prior to any other node.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next terminal, `T2`, run this command to launch the publisher node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This launches the `topic_publisher` node, but nothing happens! That's right.
    A publisher is just that, a publisher. We need a listener to know what data is
    being sent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to terminal 3 and list the topics currently declared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In the listing, it appears that `/counter` is the topic that updates an incremental
    counter every 0.5 seconds. The other two topics, `/rosout` and `/rosout_agg`,
    are the console log-reporting ([http://wiki.ros.org/rosout](http://wiki.ros.org/rosout))
    mechanisms in ROS.
  prefs: []
  type: TYPE_NORMAL
- en: 'This line of the `topic_publisher.py` file is the one that sets up the `/counter`
    topic publisher:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'To watch the published messages, launch this command in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This will output the next five messages that will be published in the `/counter` topic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will show a live view that will print the real-time frequency at
    which the messages are sent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Press *Ctrl* + *C* to stop the log in `T3`. Bear in mind that, if you do this
    in any of the two previous terminals, the process that each one controls will
    die with the following consequences:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Terminal T2**: The publisher process will end and no more messages will be
    sent through the `/counter` topic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Terminal T1**: Pressing *Ctrl* + *C* in this terminal will kill roscore,
    making it evident that this process is a single point of failure in ROS, that
    is, all related processes (including nodes and messages) will die.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A node that listens to the topic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As there is one node that publishes the incremental counter in the `/counter` topic,
    we will now launch a node that subscribes to this topic.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, let''s visualize the current ROS graph by issuing the following command
    in `T3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'A window pops up and shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d2782ae9-27d4-4dbc-8bd8-524bc33c7434.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There is a single node, that is, the one we launched in `T2`. The `/counter` topic does
    not appear because no other node is listening to it. In order to make the topic
    show, launch the listener in `T4`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: You will see this log in the bottom-right terminal window, a neverending live
    data stream unless you kill (press *Ctrl* + *C*) any of  `T1` or `T2`, that correspond
    to `roscore` and `topic_publisher` respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ae94c3ac-996c-45f7-ace7-99c50c2aee9e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you go back to the ROS graph window and click on the update icon, you will
    see the `/topic_publisher` node, the `/counter` topic that routes the messages,
    and the `/topic_subscriber` listening node:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e892e914-fe48-46cb-94ed-433fec69914a.png)'
  prefs: []
  type: TYPE_IMG
- en: This simple example illustrates the publish/subscribe architecture of communication
    in ROS. You can already appreciate how it works and how simple the underlying
    communication principle is, which is in the base of the ROS framework. We will
    now do something practical.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make our counter behave like a chronometer. How can we do this? Well,
    you just need to modify the script `topic_publisher.py`, by changing the parameter
    that specifies the number of times per second that a message is sent to the topic,
    a concept known as the publishing **frequency**, whose units are *Hertz* (= number
    of times/second). In the script, the Python object that accounts for this behavior
    is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'In the loop below in the script, the configured behavior is achieved by applying
    the **rospy** method `sleep` method to the defined `rate` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Remember that **rospy** is the ROS library that allows us to run nodes whose
    code is written in Python. **rospy** defines a set of methods to make useful stuff
    in ROS, such as setting a publishing frequency in this way.
  prefs: []
  type: TYPE_NORMAL
- en: 'The line above states that two messages are published every second, that is,
    one message every 0.5 seconds. Hence if `rate` is set to 1 Hz, the frequency will
    be one message per second, therefore emulating a chronometer. You can modify such
    script `topic_publisher.py` without needing to stop ROS, and, as soon as you execute
    it again, the node is back in the graph. Let''s show you how to do it step by
    step:'
  prefs: []
  type: TYPE_NORMAL
- en: Hit *Ctrl* + *C* in terminal `T2` to stop the execution of the node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify the file to publish at a rate of 1 Hz, as shown previously.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, relaunch the node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: You will see the effect in terminal `T4` from where `topic_subscriber.py` was
    launched. Therefore, the speed of new lines appearing (that is, counts) will be
    double compared to before when the rate was 2 Hz. This will produce one counter
    update (+1) per second, which corresponds to the rate of 1 Hz.
  prefs: []
  type: TYPE_NORMAL
- en: Combining the publisher and subscriber in the same node
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Can a node talk and listen at the same time as a real human does? Well, if
    ROS is a framework for robotics, it should be possible. Let''s explore this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Launch these two commands in the first two terminals, with each one in an independent
    terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '`/doubler` is a node that subscribes to the `/number` topic, as specified in
    these two lines of the `doubler.py` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, `/doubler` publishes its result in the `/doubled` topic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'You will notice that nothing happens, because it needs to be fed with a number
    that can be multiplied by 2, as shown in the callback of `topic_subscriber.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Launch a terminal for listening to the `/doubled` topic:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, let''s publish a `/number` topic by hand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The output in terminal `T3` is `4`, as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Try sending other numbers in `T4` and check that the double is shown immediately
    in `T3`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you issue `rqt_graph` in a fifth terminal, you will see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dee74e53-1ffc-4bdd-a5fa-2817f9659f63.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, you can see the `/number` and `/doubled` topics, the `/doubler` node,
    and two other nodes with large machine names whose correspondence are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The node on the left of the preceding diagram, `/rostopic_5469_`, is created
    from the command in `T4`:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The node on the right, `/rostopic_5631_`, is created from the command in `T3`:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'To finish this exercise, we will feed the number to the `/counter` topic, not
    from the command line, but from the script of the publisher node we saw in the
    last section: `topic_publisher.py`. For the script to work properly, you have
    to modify the topic name in `doubler.py`, renaming it from `number` to `counter`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, after stopping all of the terminals, execute each of the following lines
    in an independent terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'In this terminal, you will see the result of `counter` * 2 every time `/counter`
    is published. Take a look at the ROS graph (remember to click on the refresh button)
    and you will find that it reflects what is happening:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a16bfec5-d221-4e4e-8c10-5bfa81673fcc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Bear in mind that `rqt_graph` will give you very useful information when debugging
    the code, for example, detecting any mistakes in the topic names. Take a look
    at the following figure, where multiplication by 2 does not work because `/topic_publisher` is
    subscribed to the `count` topic (note that the end `r` character is missing).
    The nodes are disconnected from one another, and the wrongly typed topic, which
    is not listened to by anyone, does not appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/45629828-fd88-4178-bc7b-9f7108aabb5f.png)'
  prefs: []
  type: TYPE_IMG
- en: In the next section, we will provide an overview of the extension of the ROS
    package system.
  prefs: []
  type: TYPE_NORMAL
- en: Using publicly available packages for ROS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ROS-contributed packages are indexed on the official website at [http://www.ros.org/browse/list.php](http://www.ros.org/browse/list.php).
  prefs: []
  type: TYPE_NORMAL
- en: 'As of July 2018, ROS Indigo (the distribution released for Ubuntu 14.04 LTS)
    has more than 2,900 packages, while ROS Kinetic (2016, Ubuntu 16.04 LTS) has over
    1,600\. Some of the more popularly downloaded ones include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`rviz` ([http://wiki.ros.org/rviz](http://wiki.ros.org/rviz)): The 3D visualization
    tool for ROS. You will start using this in [Chapter 4](742e6846-70e4-4bd4-8576-f3e4f445df3f.xhtml),
    *Creating the Virtual Two-**Wheeled ROS Robot*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gazebo_ros_pkgs` ([http://wiki.ros.org/gazebo_ros_pkgs](http://wiki.ros.org/gazebo_ros_pkgs)):
    This allows you to use the Gazebo 3D simulator from inside ROS. We will introduce
    Gazebo in [Chapter 5](74284adc-e0d7-4e40-a54b-e2e447b8e2fe.xhtml), *Simulating
    Robot Behavior with Gazebo*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sensor-msgs` ([http://wiki.ros.org/sensor_msgs](http://wiki.ros.org/sensor_msgs)):
    This is a package that defines messages for commonly used sensors, such as cameras
    and scanning laser rangefinders.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tf2` ([http://wiki.ros.org/tf2](http://wiki.ros.org/tf2)): This is the package
    that deals with the transformation of coordinates between the many reference systems
    used in the environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`laser-geometry` ([http://wiki.ros.org/laser_geometry](http://wiki.ros.org/laser_geometry)):
    This makes it possible to transform a 2D laser scan into a point cloud for use
    in navigation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This should give you a neat view of what programming in ROS will mean for you.
    In other words, integrate software developed by others (that is, packages) and
    make them work together—by designing a coherent ROS graph—to build up the functionality
    you wish your robot to have.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced ROS and practiced with simple examples in order
    to help you understand the architecture of ROS. The top-level entity is the workspace,
    which is an isolated environment for building and running your software.
  prefs: []
  type: TYPE_NORMAL
- en: The workspace is constituted by ROS packages, that is, premade pieces of software that
    provide specific functionalities to integrate into your robot. Following this,
    catkin is the tool used to build the software each time you include new packages
    in your workspace.
  prefs: []
  type: TYPE_NORMAL
- en: The node is the basic entity in ROS and holds the functional pieces of code
    that make the robot work. A collection of related nodes providing specific functionalities
    constitute a ROS package. **roscore**, the process that runs the master node,
    is the one that allows each node to be capable of finding others by subscribing to
    the published topics. **roscore** also manages the database for the ROS parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Communication between nodes is possible thanks to topics, the channels—edges
    of the ROS graph—through which the exchanged information flows. When a node needs
    to use the information of a topic, it does so by subscribing to it.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to build a virtual model of a differential
    drive robot, one that emulates GoPiGo3 characteristics. The chapter will also
    provide you with the methodology to test your code first with the virtual robot,
    and then install and execute it in the physical robot.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the top-level component in a ROS environment?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A) Package
  prefs: []
  type: TYPE_NORMAL
- en: B) Workspace
  prefs: []
  type: TYPE_NORMAL
- en: C) ROS graph
  prefs: []
  type: TYPE_NORMAL
- en: What is the purpose of the roscore process?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A) To allow a node to communicate with others and manage the robot parameters
  prefs: []
  type: TYPE_NORMAL
- en: B) To provide a master node for driving all other nodes in the graph
  prefs: []
  type: TYPE_NORMAL
- en: C) To allow ROS nodes to be found from outside of the LAN
  prefs: []
  type: TYPE_NORMAL
- en: 'Mark the correct sentence: A node can __ .'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A) only publish topics or only subscribe to topics
  prefs: []
  type: TYPE_NORMAL
- en: B) publish topics and subscrib to topics at the same time
  prefs: []
  type: TYPE_NORMAL
- en: C) publish topics and/or subscribe to other topics
  prefs: []
  type: TYPE_NORMAL
- en: What happens if one node fails to execute its program?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A) Some functions of the robot will fail
  prefs: []
  type: TYPE_NORMAL
- en: B) The robot will not work
  prefs: []
  type: TYPE_NORMAL
- en: C) The topics it publishes will be set to undefined
  prefs: []
  type: TYPE_NORMAL
- en: 'Mark the incorrect sentence: The way to identify a message in a published topic
    is __.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A) to launch a node that publishes data in such topic
  prefs: []
  type: TYPE_NORMAL
- en: B) to issue the `$ rostopic echo </topic_name>` command
  prefs: []
  type: TYPE_NORMAL
- en: C) to write a node that subscribes to that topic
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To go deeper into the concepts we have explained in this chapter, you can follow
    the links and tutorials:'
  prefs: []
  type: TYPE_NORMAL
- en: ROS tutorial*s:*[http://wiki.ros.org/ROS/Tutorials](http://wiki.ros.org/ROS/Tutorials) (sections
    1 through 6)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*ROS Robotics By Example, Second Edition, Fairchild C*., *Harman*, *Packt Publishing*,
    T. L. (2017), *Chapter 1, Getting Started with ROS:* [https://www.packtpub.com/hardware-and-creative/ros-robotics-example-second-edition](https://www.packtpub.com/hardware-and-creative/ros-robotics-example-second-edition).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Programming Robots with ROS*, *Quigley M., Gerkey B., Bill Smart B*. (2015),
    *First Edition, O''Reilly*: [http://shop.oreilly.com/product/0636920024736.do](http://shop.oreilly.com/product/0636920024736.do) (*Chapter
    2*, *Preliminaries,* and *Chapter 3*, *Topics)*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
