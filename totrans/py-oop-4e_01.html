<html><head></head><body>
  <div id="_idContainer024">
    <h1 class="chapterNumber">1</h1>
    <h1 id="_idParaDest-13" class="chapterTitle">Object-Oriented Design</h1>
    <p class="normal">In software development, design is often considered as the step that's done <em class="italic">before</em> programming. This isn't true; in reality, analysis, programming, and design tend to overlap, combine, and interweave. Throughout this book, we'll be covering a mixture of design and programming issues without trying to parse them into separate buckets. One of the advantages of a language like Python is the ability to express the design clearly. </p>
    <p class="normal">In this chapter, we will talk a little about how we can move from a good idea toward writing software. We'll create some design artifacts – like diagrams – that can help clarify our thinking before we start writing code. We'll cover the following topics:</p>
    <ul>
      <li class="bullet">What object-oriented means</li>
      <li class="bullet">The difference between object-oriented design and object-oriented programming</li>
      <li class="bullet">The basic principles of object-oriented design</li>
      <li class="bullet">Basic <strong class="keyword">Unified Modeling Language</strong> (<strong class="keyword">UML</strong>) and when it isn't evil</li>
    </ul>
    <p class="normal">We will also introduce this book's object-oriented design case study, using the "4+1" architectural view model. We'll touch on a number of topics here:</p>
    <ul>
      <li class="bullet">An overview of a classic machine learning application, the famous Iris classification problem</li>
      <li class="bullet">The general processing context for this classifier</li>
      <li class="bullet">Sketching out two views of the class hierarchy that look like they'll be adequate to solve the problem</li>
    </ul>
    <h1 id="_idParaDest-14" class="title">Introducing object-oriented</h1>
    <p class="normal">Everyone knows what an<a id="_idIndexMarker000"/> object is: a tangible thing that we can sense, feel, and manipulate. The earliest objects we interact with are typically baby toys. Wooden blocks, plastic shapes, and over-sized puzzle pieces are common first objects. Babies learn quickly that certain objects do certain things: bells ring, buttons are pressed, and levers are pulled.</p>
    <p class="normal">The definition of an object in software development is not terribly different. Software objects may not be tangible things that you can pick up, sense, or feel, but they are models of something that can do certain things and have certain things done to them. Formally, an object is a<a id="_idIndexMarker001"/> collection of <strong class="keyword">data</strong> and <a id="_idIndexMarker002"/>associated <strong class="keyword">behaviors</strong>.</p>
    <p class="normal">Considering what an object is, what does it mean to be object-oriented? In the dictionary, <em class="italic">oriented</em> means <em class="italic">directed toward</em>. Object-oriented programming<a id="_idIndexMarker003"/> means writing code directed toward modeling objects. This is one of many techniques used for describing the actions of complex systems. It is defined by describing a collection of interacting objects via their data and behavior.</p>
    <p class="normal">If you've read any hype, you've probably come across the terms <em class="italic">object-oriented analysis</em>, <em class="italic">object-oriented design</em>, <em class="italic">object-oriented analysis and design</em>, and <em class="italic">object-oriented programming</em>. These are all related concepts under the general <em class="italic">object-oriented</em> umbrella.</p>
    <p class="normal">In fact, analysis, design, and programming are all stages of software development. Calling them object-oriented simply specifies what kind of software development is being pursued.</p>
    <p class="normal"><strong class="keyword">Object-oriented analysis</strong> (<strong class="keyword">OOA</strong>) is the <a id="_idIndexMarker004"/>process of looking at a problem, system, or task (that somebody wants to turn into a working software application) and identifying the objects and interactions between those objects. The analysis stage is all about <em class="italic">what</em> needs to be done.</p>
    <p class="normal">The output of the analysis stage is a description of the system, often in the form of <em class="italic">requirements</em>. If we were to complete the analysis stage in one step, we would have turned a task, such as <em class="italic">As a botanist, I need a website to help users classify plants so I can help with correct identification</em>, into a set of required features. As an example, here are some requirements as to what a website visitor might need to do. Each item is an action bound to an object; we've written them with <em class="italic">italics</em> to highlight the actions, and <strong class="keyword">bold</strong> to highlight the objects:</p>
    <ul>
      <li class="bullet"><em class="italic">Browse</em> <strong class="keyword">Previous Uploads</strong></li>
      <li class="bullet"><em class="italic">Upload new</em> <strong class="keyword">Known Examples</strong></li>
      <li class="bullet"><em class="italic">Test</em> for <strong class="keyword">Quality</strong></li>
      <li class="bullet"><em class="italic">Browse</em> <strong class="keyword">Products</strong></li>
      <li class="bullet"><em class="italic">See</em> <strong class="keyword">Recommendations</strong></li>
    </ul>
    <p class="normal">In some ways, the term <em class="italic">analysis</em> is a misnomer. The baby we discussed earlier doesn't analyze the blocks and puzzle pieces. Instead, she explores her environment, manipulates shapes, and sees where they might fit. A better turn of phrase might be <em class="italic">object-oriented exploration</em>. In <a id="_idIndexMarker005"/>software development, the initial stages of analysis include interviewing customers, studying their processes, and eliminating possibilities.</p>
    <p class="normal"><strong class="keyword">Object-oriented design</strong> (<strong class="keyword">OOD</strong>) is <a id="_idIndexMarker006"/>the process of converting such requirements into an implementation specification. The designer must name the objects, define the behaviors, and formally specify which objects can activate specific behaviors on other objects. The design stage is all about transforming <em class="italic">what</em> should be done into <em class="italic">how</em> it should be done.</p>
    <p class="normal">The output of the design stage is an implementation specification. If we were to complete the design stage in a single step, we would have turned the requirements defined during object-oriented analysis into a set of classes and interfaces that could be implemented in (ideally) any object-oriented programming language.</p>
    <p class="normal"><strong class="keyword">Object-oriented programming</strong> (<strong class="keyword">OOP</strong>) is the<a id="_idIndexMarker007"/> process of converting a design into a working program that does what the product owner originally requested.</p>
    <p class="normal">Yeah, right! It would be lovely if the world met this ideal and we could follow these stages one by one, in perfect order, like all the old textbooks told us to. As usual, the real world is much murkier. No matter how hard we try to separate these stages, we'll always find things that need further analysis while we're designing. When we're programming, we find features that need clarification in the design.</p>
    <p class="normal">Most 21st century development recognizes that this cascade (or waterfall) of stages doesn't work out well. What seems to be better is an <em class="italic">iterative</em> development model. In iterative development, a small part of the task is modeled, designed, and programmed, and then the product is reviewed and expanded to improve each feature and include new features in a series of short development cycles.</p>
    <p class="normal">The rest of this book is about object-oriented programming, but in this chapter, we will cover the basic object-oriented principles in the context of design. This allows us to understand concepts without having to argue with software syntax or Python tracebacks.</p>
    <h1 id="_idParaDest-15" class="title">Objects and classes</h1>
    <p class="normal">An <strong class="keyword">object</strong><strong class="keyword"><a id="_idIndexMarker008"/></strong> is a collection of data with associated behaviors. How do we differentiate between types of objects? Apples and oranges are both objects, but it is a common adage that they cannot be compared. Apples and oranges aren't modeled very often in computer programming, but let's pretend we're doing an inventory application for a fruit farm. To facilitate this example, we can assume that apples go in barrels and oranges go in baskets.</p>
    <p class="normal">The problem domain we've uncovered so far has four kinds of objects: apples, oranges, baskets, and barrels. In object-oriented modeling, the term used for a <em class="italic">kind of object</em> is <strong class="keyword">class</strong>. So, in <a id="_idIndexMarker009"/>technical terms, we now have four classes of objects.</p>
    <p class="normal">It's important to understand the difference between an object and a class. Classes describe related objects. They are like blueprints for creating an object. You might have three oranges sitting on the table in front of you. Each orange is a distinct object, but all three have the attributes and behaviors associated with one class: the general class of oranges.</p>
    <p class="normal">The relationship between the four classes of objects in our inventory system can be described<a id="_idIndexMarker010"/> using a <strong class="keyword">Unified Modeling Language</strong> (invariably referred to as <strong class="keyword">UML</strong>, because three-letter acronyms never go out of style) class diagram. Here is our first <em class="italic">class diagram</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17070_01_01.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 1.1: Class diagram</p>
    <p class="normal">This <a id="_idIndexMarker011"/>diagram shows that instances of the <strong class="keyword">Orange</strong> class (usually called "oranges") are somehow associated with a <strong class="keyword">Basket</strong> and that instances of the <strong class="keyword">Apple</strong> class ("apples") are also somehow associated with a <strong class="keyword">Barrel</strong>. <em class="italic">Association</em> is the most basic way for instances of two classes to be related.</p>
    <p class="normal">The syntax of a UML diagram<a id="_idIndexMarker012"/> is generally pretty obvious; you don't have to read a tutorial to (mostly) understand what is going on when you see one. UML is also fairly easy to draw, and quite intuitive. After all, many people, when describing classes and their relationships, will naturally draw boxes with lines between them. Having a standard based on these intuitive diagrams makes it easy for programmers to communicate with designers, managers, and each other.</p>
    <p class="normal">Note that the UML diagram generally depicts the class definitions, but we're describing attributes of the objects. The diagram shows the class of Apple and the class of Barrel, telling us that a given apple is in a specific barrel. While we can use UML to depict individual objects, that's rarely necessary. Showing these classes tells us enough about the objects that are members of each class.</p>
    <p class="normal">Some programmers disparage UML as a waste of time. Citing iterative development, they will argue that formal specifications done up in fancy UML diagrams are going to be redundant before they're implemented, and that maintaining these formal diagrams will only waste time and not benefit anyone.</p>
    <p class="normal">Every programming team consisting of more than one person will occasionally have to sit down and hash out the details of the components being built. UML is extremely useful for ensuring quick, easy, and consistent communication. Even those organizations that scoff at formal class diagrams tend to use some informal version of UML in their design meetings or team discussions.</p>
    <p class="normal">Furthermore, the most important person you will ever have to communicate with is your future self. We all think we can remember the design decisions we've made, but there will always be <em class="italic">Why did I do that?</em> moments hiding in our future. If we keep the scraps of papers we did our initial diagramming on when we started a design, we'll eventually find them to be a useful reference.</p>
    <p class="normal">This chapter, however, is not meant to be a tutorial on <a id="_idIndexMarker013"/>UML. There are many of those available on the internet, as well as numerous books on the topic. UML covers far more than class and object diagrams; it also has a syntax for use cases, deployment, state changes, and activities. We'll be dealing with some common class diagram syntax in this discussion of object-oriented design. You can pick up the structure by example, and then you'll subconsciously choose the UML-inspired syntax in your own team or personal design notes.</p>
    <p class="normal">Our initial diagram, while correct, does not remind us that apples go in barrels or how many barrels a single apple can go in. It only tells us that apples are somehow associated with barrels. The association between classes is often obvious and needs no further explanation, but we have the option to add further clarification as needed.</p>
    <p class="normal">The beauty of UML is that most things are optional. We only need to specify as much information in a diagram as makes sense for the current situation. In a quick whiteboard session, we might just draw simple lines between boxes. In a formal document, we might go into more detail. </p>
    <p class="normal">In the case of apples and barrels, we can be fairly confident that the association is <strong class="keyword">many apples go in one barrel</strong>, but just to make sure nobody confuses it with <strong class="keyword">one apple spoils one barrel</strong>, we can enhance the diagram, as shown here:</p>
    <figure class="mediaobject"><img src="../Images/B17070_01_02.png" alt="Diagram  Description automatically generated with medium confidence"/></figure>
    <p class="packt_figref">Figure 1.2: Class diagram with more detail</p>
    <p class="normal">This <a id="_idIndexMarker014"/>diagram tells us that oranges <strong class="keyword">go in</strong> baskets, with a little arrow showing what goes in what. It also tells us the number of that object that can be used in the association on both sides of the relationship. One <strong class="keyword">Basket</strong> can hold many (represented by a <strong class="keyword">*</strong>) <strong class="keyword">Orange</strong> objects. Any one <strong class="keyword">Orange</strong> can go in exactly one <strong class="keyword">Basket</strong>. This number is referred to as the <em class="italic">multiplicity</em> of the object. You may also hear it described as the <em class="italic">cardinality</em>; it can help to think of cardinality as a specific number or range, and what we're using here, multiplicity, as a generalized "more-than-one instance".</p>
    <p class="normal">We may sometimes forget which end of the relationship line is supposed to have which multiplicity number. The multiplicity nearest to a class is the number of objects of that class that can be associated with any one object at the other end of the association. For the apple goes in barrel association, reading from left to right, many instances of the <strong class="keyword">Apple</strong> class (that is, many <strong class="keyword">Apple</strong> objects) can go in any one <strong class="keyword">Barrel</strong>. Reading from right to left, exactly one <strong class="keyword">Barrel</strong> can be associated with any one <strong class="keyword">Apple</strong>.</p>
    <p class="normal">We've seen the basics of classes, and how they specify relationships among objects. Now, we need to talk about the attributes that define an object's state, and the behaviors of an object that may involve state change or interaction with other objects.</p>
    <h1 id="_idParaDest-16" class="title">Specifying attributes and behaviors</h1>
    <p class="normal">We now have a <a id="_idIndexMarker015"/>grasp of some basic object-oriented terminology. Objects are instances of classes that can be associated with each other. A class instance is a specific object with its own set of data and behaviors; a specific orange on the table in front of us is said to be an instance of the general class of oranges.</p>
    <p class="normal">The orange has a <a id="_idIndexMarker016"/>state, for example, ripe or raw; we implement the state of an object via the values of specific attributes. An orange also has behaviors. By themselves, oranges are generally passive. State changes are imposed on them. Let's dive into the meaning of those two words, <em class="italic">state</em> and <em class="italic">behaviors</em>.</p>
    <h2 id="_idParaDest-17" class="title">Data describes object state</h2>
    <p class="normal">Let's start with data. Data <a id="_idIndexMarker017"/>represents the individual characteristics of a certain object; its current state. A class can define specific sets of characteristics that are part of all objects that are members of that class. Any specific object can have different data values for the given characteristics. For example, the three oranges on our table (if we haven't eaten any) could each weigh a different amount. The orange class could have a weight attribute to represent that datum. All instances of the orange class have a weight attribute, but each orange has a different value for this attribute. Attributes don't have to be unique, though; any two oranges may weigh the same amount. </p>
    <p class="normal">Attributes<a id="_idIndexMarker018"/> are frequently referred to<a id="_idIndexMarker019"/> as <strong class="keyword">members</strong> or <strong class="keyword">properties</strong>. Some authors suggest that the terms have different <a id="_idIndexMarker020"/>meanings, usually that attributes are settable, while properties are read-only. A Python property can be defined as read-only, but the value will be based on attribute values that are – ultimately – writable, making the concept of <em class="italic">read-only</em> rather pointless; throughout this book, we'll see the two terms used interchangeably. In addition, as we'll discuss in <em class="chapterRef">Chapter 5</em>, <em class="italic">When to Use Object-Oriented Programming</em>, the <code class="Code-In-Text--PACKT-">property</code> keyword has a special meaning in Python for a particular kind of attribute.</p>
    <p class="normal">In Python, we can also call an attribute an <strong class="keyword">instance variable</strong>. This can help clarify the way attributes work. They are variables with unique values for each instance of a class. Python has other kinds of attributes, but we'll focus on the most common kind to get started.</p>
    <p class="normal">In our fruit inventory application, the fruit farmer may want to know what orchard the orange came from, when it was picked, and how much it weighs. They might also want to keep track of where each <strong class="keyword">Basket</strong> is stored. Apples might have a color attribute, and barrels might come in different sizes. </p>
    <p class="normal">Some of these properties may also belong to multiple classes (we may want to know when apples are picked, too), but for this first example, let's just add a few <a id="_idIndexMarker021"/>different attributes to our class diagram:</p>
    <figure class="mediaobject"><img src="../Images/B17070_01_03.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 1.3: Class diagram with attributes</p>
    <p class="normal">Depending on how detailed our design needs to be, we can also specify the type for each attribute's value. In UML, attribute types are often generic names common to many programming languages, such as integer, floating-point number, string, byte, or Boolean. However, they can also represent generic collections such as lists, trees, or graphs, or most notably, other, non-generic, application-specific classes. This is one area where the design stage can overlap with the programming stage. The various primitives and built-in collections available in one programming language may be different from what is available in another.</p>
    <p class="normal">Here's a version with (mostly) Python-specific type hints:</p>
    <figure class="mediaobject"><img src="../Images/B17070_01_04.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 1.4: Class diagram with attributes and their types</p>
    <p class="normal">Usually, we don't<a id="_idIndexMarker022"/> need to be overly concerned with data types at the design stage, as implementation-specific details are chosen during the programming stage. Generic names are normally sufficient for design; that's why we included <code class="Code-In-Text--PACKT-">date</code> as a placeholder for a Python type like <code class="Code-In-Text--PACKT-">datetime.datetime</code>. If our design calls for a list container type, Java programmers can choose to use a <code class="Code-In-Text--PACKT-">LinkedList</code> or an <code class="Code-In-Text--PACKT-">ArrayList</code> when implementing it, while Python programmers (that's us!) might specify <code class="Code-In-Text--PACKT-">List[Apple]</code> as a type hint, and use the <code class="Code-In-Text--PACKT-">list</code> type for the implementation.</p>
    <p class="normal">In our fruit-farming example so far, our attributes are all basic primitives. However, there are some implicit attributes that we can make explicit – the associations. For a given orange, we have an attribute referring to the basket that holds that orange, the <code class="Code-In-Text--PACKT-">basket</code> attribute, with a type hint of <code class="Code-In-Text--PACKT-">Basket</code>.</p>
    <h2 id="_idParaDest-18" class="title">Behaviors are actions</h2>
    <p class="normal">Now that we know how data defines the object's state, the last undefined term we need to look at is <em class="italic">behaviors</em>. Behaviors are<a id="_idIndexMarker023"/> actions that can occur on an object. The behaviors that can be performed<a id="_idIndexMarker024"/> on a specific class of object are expressed as<a id="_idIndexMarker025"/> the <strong class="keyword">methods</strong> of the class. At the programming level, methods are like functions in structured programming, but they have access to the attributes – in particular, the instance variables with the data associated with this object. Like functions, methods can also accept <strong class="keyword">parameters</strong> and return <strong class="keyword">values</strong>.</p>
    <p class="normal">A method's parameters are provided to it as a collection of objects that need to be <strong class="keyword">passed</strong> into that method. The actual object instances that are passed into a method during a specific invocation are usually referred to as <strong class="keyword">arguments</strong>. These objects are bound to <strong class="keyword">parameter</strong> variables in the method body. They are used by the method to perform whatever behavior or task it is meant to do. Returned values are the results of that task. Internal state changes are another possible effect of evaluating a method.</p>
    <p class="normal">We've stretched our <em class="italic">comparing apples and oranges</em> example into a basic (if far-fetched) inventory application. Let's stretch it a little further and see whether it breaks. One action that can be associated with oranges is the <strong class="keyword">pick</strong> action. If you think about implementation, <strong class="keyword">pick</strong> would need to do two things:</p>
    <ul>
      <li class="bullet">Place the orange in a basket by updating the <strong class="keyword">Basket</strong> attribute of the orange.</li>
      <li class="bullet">Add the orange to the <strong class="keyword">Orange</strong> list on the given <strong class="keyword">Basket</strong>.</li>
    </ul>
    <p class="normal">So, <strong class="keyword">pick</strong> needs to know what basket it is dealing with. We do this by giving the <strong class="keyword">pick</strong> method a <strong class="keyword">Basket</strong> parameter. Since our fruit farmer also sells juice, we can add a <strong class="keyword">squeeze</strong> method to the <strong class="keyword">Orange</strong> class. When called, the <strong class="keyword">squeeze</strong> method might return the amount of juice retrieved, while also removing the <strong class="keyword">Orange</strong> from the <strong class="keyword">Basket</strong> it was in.</p>
    <p class="normal">The class <strong class="keyword">Basket</strong> can have a <strong class="keyword">sell</strong> action. When a basket is sold, our inventory system might update some data on as-yet unspecified objects for accounting and profit calculations. Alternatively, our basket of oranges might go bad before we can sell them, so we add a <strong class="keyword">discard</strong> method. Let's add these methods to our diagram:</p>
    <figure class="mediaobject"><img src="../Images/B17070_01_05.png" alt="Diagram  Description automatically generated with medium confidence"/></figure>
    <p class="packt_figref">Figure 1.5: Class diagram with attributes and methods</p>
    <p class="normal">Adding attributes and<a id="_idIndexMarker026"/> methods to individual objects allows us to create a <strong class="keyword">system</strong> of interacting objects. Each object in the system is a member of a certain class. These classes specify what types of data the object can hold and what methods can be invoked on it. The data in each object can be in a different state from other instances of the same class; each object may react to method calls differently because of the differences in state.</p>
    <p class="normal">Object-oriented analysis and design is all about figuring out what those objects are and how they should interact. Each class has responsibilities and collaborations. The next section describes principles that can be used to make those interactions as simple and intuitive as possible.</p>
    <p class="normal">Note that selling a basket is not unconditionally a feature of the <strong class="keyword">Basket</strong> class. It may be that some other class (not shown) cares about the various Baskets and where they are. We often have boundaries around our design. We will also have questions about responsibilities allocated to various classes. The responsibility allocation problem doesn't always have a tidy technical solution, forcing us to draw (and redraw) our UML diagrams more than once to examine alternative designs.</p>
    <h1 id="_idParaDest-19" class="title">Hiding details and creating the public interface</h1>
    <p class="normal">The key purpose of modeling an object in object-oriented design is to determine what the public <strong class="keyword">interface</strong> of that object will be. The interface<a id="_idIndexMarker027"/> is the collection of attributes and methods that other objects can access to interact with that object. Other objects do not need, and in some languages are not allowed, to access the internal workings of the object.</p>
    <p class="normal">A common real-world example is the television. Our interface to the television is the remote control. Each button on the remote control represents a method that can be called on the television object. When we, as the calling object, access these methods, we do not know or care if the television is getting its signal from a cable connection, a satellite dish, or an internet-enabled device. We don't care what electronic signals are being sent to adjust the volume, or whether the sound is destined for speakers or headphones. If we open the television to access its internal workings, for example, to split the output signal to both external speakers and a set of headphones, we may void the warranty.</p>
    <p class="normal">This process of hiding<a id="_idIndexMarker028"/> the implementation of an object is suitably called <strong class="keyword">information hiding</strong>. It is also sometimes referred to <a id="_idIndexMarker029"/>as <strong class="keyword">encapsulation</strong>, but encapsulation is actually a more encompassing term. Encapsulated data is not necessarily hidden. Encapsulation is, literally, creating a capsule (or wrapper) on the attributes. The TV's external case encapsulates the state and behavior of the television. We have access to the external screen, the speakers, and the remote. We don't have direct access to the wiring of the amplifiers or receivers within the TV's case. </p>
    <p class="normal">When we buy a component entertainment system, we change the level of encapsulation, exposing more of the interfaces between components. If we're an Internet of Things maker, we may decompose this even further, opening cases and breaking the information hiding attempted by the manufacturer.</p>
    <p class="normal">The distinction between encapsulation and information hiding is largely irrelevant, especially at the design level. Many practical references use these terms interchangeably. As Python programmers, we don't actually have or need information hiding via completely private, inaccessible variables (we'll discuss the reasons for this in <em class="chapterRef">Chapter 2</em>, <em class="italic">Objects in Python</em>), so the more encompassing definition for encapsulation is suitable. </p>
    <p class="normal">The public interface, however, is very important. It needs to be carefully designed as it can be difficult to change when other classes depend on it. Changing an interface can break any client objects that depend on it. We can change the internals all we like, for example, to make it more efficient, or to access data over the network as well as locally, and the client objects will still be able to talk to it, unmodified, using the public interface. On the other hand, if we alter the interface by changing publicly accessed attribute names or the order or types of arguments that a method can accept, all client classes will also have to be modified. When designing public interfaces, keep it simple. Always design the interface of an object based on how easy it is to use, not how hard it is to code (this advice applies to user interfaces as well). For this reason, you'll sometimes see Python variables with a leading _ in their name as a warning that these aren't part of the public interface.</p>
    <p class="normal">Remember, program objects may represent real objects, but that does not make them real objects. They are models. One of the greatest gifts of modeling is the ability to ignore irrelevant details. The model car one of the authors built as a child looked like a real 1956 Thunderbird on the outside, but it obviously didn't run. When they were too young to drive, these details were overly complex and irrelevant. The model is an <strong class="keyword">abstraction</strong> of a real concept.</p>
    <p class="normal"><strong class="keyword">Abstraction</strong> is another<a id="_idIndexMarker030"/> object-oriented term related to encapsulation and information hiding. Abstraction means dealing with the level of detail that is most appropriate to a given task. It is the process of extracting a public interface from the inner details. A car's driver needs to interact with the steering, accelerator, and brakes. The workings of the motor, drive train, and brake subsystem don't matter to the driver. A mechanic, on the other hand, works at a different level of abstraction, tuning the engine and bleeding the brakes. Here's an example of two abstraction levels for a car:</p>
    <figure class="mediaobject"><img src="../Images/B17070_01_06.png" alt="Diagram  Description automatically generated"/></figure>
    <figure class="mediaobject">Figure 1.6: Abstraction levels for a car</figure>
    <p class="normal">Now, we have several<a id="_idIndexMarker031"/> new terms that refer to similar concepts. Let's summarize all this jargon in a couple of sentences: abstraction is the process of encapsulating information with a separate public interface. Any private elements can be subject to information hiding. In UML diagrams, we might use a leading – instead of a leading + to suggest it's not part of a public interface.</p>
    <p class="normal">The important lesson to take away from all these definitions is to make our models understandable to other objects that have to interact with them. This means paying careful attention to small details. </p>
    <p class="normal">Ensure methods and properties have sensible names. When analyzing a system, objects typically represent nouns in the original problem, while methods are normally verbs. Attributes may show up as adjectives or more nouns. Name your classes, attributes, and methods accordingly.</p>
    <p class="normal">When designing the interface, imagine you are the object; you want clear definitions of your responsibility and you have a very strong preference for privacy to meet those responsibilities. Don't let other objects have access to data about you unless you feel it is in your best interest for them to have it. Don't give them an interface to force you to perform a specific task unless you are certain it's your responsibility to do that.</p>
    <h1 id="_idParaDest-20" class="title">Composition</h1>
    <p class="normal">So far, we have learned to design systems as a group of interacting objects, where each interaction involves viewing objects at an appropriate level of abstraction. But we don't yet know how to create these levels of abstraction. There are a variety of ways to do this; we'll discuss some advanced design patterns in <em class="chapterRef">Chapters 10</em>, <em class="chapterRef">11</em>, and <em class="chapterRef">12</em>. But even most design patterns rely on two<a id="_idIndexMarker032"/> basic object-oriented principles known as <strong class="keyword">composition</strong> and <strong class="keyword">inheritance</strong>. Composition is <a id="_idIndexMarker033"/>simpler, so let's start with that.</p>
    <p class="normal">Composition<a id="_idIndexMarker034"/> is the act of collecting several objects together to create a new one. Composition is usually a good choice when one object is part of another object. We've already seen a first hint of composition when talking about cars. A fossil-fueled car is composed of an engine, transmission, starter, headlights, and windshield, among numerous other parts. The engine, in turn, is composed of pistons, a crank shaft, and valves. In this example, composition is a good way to provide levels of abstraction. The <strong class="keyword">Car</strong> object can provide the interface required by a driver, while also giving access to its component parts, which offers the deeper level of abstraction suitable for a mechanic. Those component parts can, of course, be further decomposed into details if the mechanic needs more information to diagnose a problem or tune the engine.</p>
    <p class="normal">A car is a common introductory example of composition, but it's not overly useful when it comes to designing computer systems. Physical objects are easy to break into component objects. People have been doing this at least since the ancient Greeks originally postulated that atoms were the smallest units of matter (they, of course, didn't have access to particle accelerators). Because computer systems involve a lot of peculiar concepts, identifying the component objects does not happen as naturally as with real-world valves and pistons.</p>
    <p class="normal">The objects in an object-oriented system occasionally represent physical objects such as people, books, or telephones. More often, however, they represent concepts. People have names, books have titles, and telephones are used to make calls. Calls, titles, accounts, names, appointments, and payments are not usually considered objects in the physical world, but they are all frequently-modeled components in computer systems.</p>
    <p class="normal">Let's try modeling a more computer-oriented example to see composition in action. We'll be looking at the design of a computerized chess game. This was a very popular pastime in the 80s and 90s. People were predicting that computers would one day be able to defeat a human chess master. When this happened in 1997 (IBM's Deep Blue defeated world chess champion, Gary Kasparov), interest in the problem of chess waned. Nowadays, the descendants of Deep Blue always win.</p>
    <p class="normal">A <em class="italic">game</em> of chess is <strong class="keyword">played</strong> between two <em class="italic">players</em>, using a chess set featuring a <em class="italic">board</em> containing 64 <em class="italic">positions</em> in an 8×8 grid. The board can have two sets of 16 <em class="italic">pieces</em> that can be <strong class="keyword">moved</strong>, in alternating <em class="italic">turns</em> by the two players in different ways. Each piece can <strong class="keyword">take</strong> other pieces. The board will be required to <strong class="keyword">draw</strong> itself on the computer <em class="italic">screen</em> after each turn.</p>
    <p class="normal">I've identified some of the possible objects in the description using <em class="italic">italics</em>, and a few key methods using <strong class="keyword">bold</strong>. This is a common first step in turning an object-oriented analysis into a design. At this point, to emphasize composition, we'll focus on the board, without worrying too much about the players or the different types of pieces.</p>
    <p class="normal">Let's start at the highest<a id="_idIndexMarker035"/> level of abstraction possible. We have two players interacting with a <strong class="keyword">Chess Set</strong> by taking turns making moves:</p>
    <figure class="mediaobject"><img src="../Images/B17070_01_07.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 1.7: Object/instance diagram for a chess game</p>
    <p class="normal">This doesn't quite look like our earlier class diagrams, which is a good thing since it isn't one! This is<a id="_idIndexMarker036"/> an <strong class="keyword">object diagram</strong>, also called an <strong class="keyword">instance diagram</strong>. It describes the system at a specific state in time, and is describing <a id="_idIndexMarker037"/>specific instances of objects, not the interaction between classes. Remember, both players are members of the same class, so the class diagram looks a little different:</p>
    <figure class="mediaobject"><img src="../Images/B17070_01_08.png" alt=""/></figure>
    <p class="packt_figref">Figure 1.8: Class diagram for a chess game</p>
    <p class="normal">This diagram<a id="_idIndexMarker038"/> shows that exactly two players can interact with one chess set. This also indicates that any one player can be playing with only one <strong class="keyword">Chess Set</strong> at a time.</p>
    <p class="normal">However, we're discussing composition, not UML, so let's think about what the <strong class="keyword">Chess Set</strong> is composed of. We don't care what the player is composed of at this time. We can assume that the player has a heart and brain, among other organs, but these are irrelevant to our model. Indeed, there is nothing stopping said player from being Deep Blue itself, which has neither a heart nor a brain.</p>
    <p class="normal">The chess set, then, is composed of a board and 32 pieces. The board further comprises 64 positions. You could argue that these pieces are not part of the chess set, because you could replace the pieces of a chess set with a different set of pieces. While this is unlikely or impossible in a computerized version of chess, it introduces us to <strong class="keyword">aggregation</strong>.</p>
    <p class="normal">Aggregation<a id="_idIndexMarker039"/> is almost exactly like composition. The difference is that aggregate objects can exist independently. It would be impossible for a position to be associated with a different chess board, so we say the board is composed of positions. But the pieces, which might exist independently of the chess set, are said to be in an aggregate relationship with that set.</p>
    <p class="normal">Another way to differentiate between <a id="_idIndexMarker040"/>aggregation and <a id="_idIndexMarker041"/>composition is to think about the lifespan of the object:</p>
    <ul>
      <li class="bullet">If the composite (outside) object controls when the related (inside) objects are created and destroyed, composition is most suitable. </li>
      <li class="bullet">If the related object is created independently of the composite object, or can outlast that object, an aggregate relationship makes more sense.</li>
    </ul>
    <p class="normal">Also, keep in mind that composition is aggregation; aggregation is simply a more general form of composition. Any composite relationship is also an aggregate relationship, but not vice versa.</p>
    <p class="normal">Let's describe our current <strong class="keyword">Chess Set</strong> composition and add some attributes to the objects to hold the composite relationships:</p>
    <figure class="mediaobject"><img src="../Images/B17070_01_09.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 1.9: Class diagram for a chess game</p>
    <p class="normal">The composition relationship is represented in UML as a solid diamond. The hollow diamond represents the aggregate relationship. You'll notice that the board and pieces are stored as part of the <strong class="keyword">Chess Set</strong> in exactly the same way a reference to them is stored as an attribute on the chess set. This shows that, once again, in practice, the distinction between aggregation and composition is often irrelevant once you get past the design stage. When implemented, they behave in much the same way. </p>
    <p class="normal">This distinction can help you differentiate between the two when your team is discussing how the different objects interact. You'll often need to distinguish between them when talking about how long related objects exist. In many cases, deleting a composite object (like the board) deletes all the locations. The aggregated objects, however, are not deleted automatically.</p>
    <h1 id="_idParaDest-21" class="title">Inheritance</h1>
    <p class="normal">We discussed <a id="_idIndexMarker042"/>three types of relationships between objects: association, composition, and aggregation. However, we have not fully specified our chess set, and these tools don't seem to give us all the power we need. We discussed the possibility that a player might be a human or it might be a piece of software featuring artificial intelligence. It doesn't seem right to say that a player is <em class="italic">associated</em> with a human, or that the artificial intelligence implementation is <em class="italic">part of</em> the player object. What we really need is the ability to say that <em class="italic">Deep Blue is a player</em>, or that <em class="italic">Gary Kasparov is a player</em>.</p>
    <p class="normal">The <em class="italic">is a</em> relationship is formed by <strong class="keyword">inheritance</strong>. Inheritance<a id="_idIndexMarker043"/> is the most famous, well-known, and overused relationship in object-oriented programming. Inheritance is sort of like a family tree. Dusty Phillips is one of this book's authors. </p>
    <p class="normal">His grandfather's last name was Phillips, and his father inherited that name. Dusty inherited it from him. In object-oriented programming, instead of inheriting features and behaviors from a person, one class can inherit attributes and methods from another class.</p>
    <p class="normal">For example, there are 32 chess<a id="_idIndexMarker044"/> pieces in our chess set, but there are only six different types of pieces (pawns, rooks, bishops, knights, king, and queen), each of which behaves differently when it is moved. All of these classes of piece have properties, such as color and the chess set they are part of, but they also have unique shapes when drawn on the chess board, and make different moves. Let's see how the six types of pieces can inherit from a <strong class="keyword">Piece</strong> class:</p>
    <figure class="mediaobject"><img src="../Images/B17070_01_10.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 1.10: How chess pieces inherit from the Piece class</p>
    <p class="normal">The hollow arrows<a id="_idIndexMarker045"/> indicate that the individual classes of pieces inherit from the <strong class="keyword">Piece</strong> class. All the child classes automatically have a <strong class="keyword">chess_set</strong> and <strong class="keyword">color</strong> attribute inherited from the base class. Each piece provides a different shape property (to be drawn on the screen when rendering the board), and a different <strong class="keyword">move</strong> method to move the piece to a new position on the board at each turn.</p>
    <p class="normal">We actually know that all subclasses of the <strong class="keyword">Piece</strong> class need to have a <strong class="keyword">move</strong> method; otherwise, when the board tries to move the piece, it will get confused. It is possible that we would want to create a new version of the game of chess that has one additional piece (the wizard). Our current design will allow us to design this piece without giving it a <strong class="keyword">move</strong> method. The board would then choke when it asked the piece to move itself.</p>
    <p class="normal">We can fix this by creating a dummy move method on the <strong class="keyword">Piece</strong> class. The subclasses can then <strong class="keyword">override</strong> this method with a more specific implementation. The default implementation might, for example, pop up an error message that says <strong class="keyword">That piece cannot be moved</strong>.</p>
    <p class="normal">Overriding methods in subclasses allows very powerful object-oriented systems to be developed. For example, if we wanted to implement a <strong class="keyword">Player</strong> class with artificial intelligence, we might provide a <strong class="keyword">calculate_move</strong> method that takes a <strong class="keyword">Board</strong> object and decides which piece to move where. A very basic class might randomly choose a piece and direction and move it accordingly. We could then override this method in a subclass with the Deep Blue implementation. The first class would be suitable for play against a raw beginner; the latter would challenge a grand master. The important thing is that other methods in the class, such as the ones that inform the board as to which move was chosen, need not be changed; this implementation can be shared between the two classes.</p>
    <p class="normal">In the case of <a id="_idIndexMarker046"/>chess pieces, it doesn't really make sense to provide a default implementation of the move method. All we need to do is specify that the move method is required in any subclasses. This can be done by making <strong class="keyword">Piece</strong> an <strong class="keyword">abstract class</strong> with the <strong class="keyword">move</strong> method declared as <strong class="keyword">abstract</strong>. Abstract methods basically say this:</p>
    <blockquote class="packt_quote">"We demand this method exist in any non-abstract subclass, but we are declining to specify an implementation in this class."</blockquote>
    <p class="normal">Indeed, it is possible to make an abstraction that does not implement any methods at all. Such a class would simply tell us what the class <em class="italic">should</em> do, but provides absolutely no advice on how to do it. In some languages, these purely abstract classes are called <strong class="keyword">interfaces</strong>. It's possible to define a class with only abstract method placeholders in Python, but it's very rare.</p>
    <h2 id="_idParaDest-22" class="title">Inheritance provides abstraction</h2>
    <p class="normal">Let's explore the longest word in object-oriented argot. <strong class="keyword">Polymorphism</strong> is the ability to treat a class differently, depending on which subclass is<a id="_idIndexMarker047"/> implemented. We've already seen it in action with the pieces system we've described. If we took the design a bit further, we'd probably see that the <strong class="keyword">Board</strong> object can accept a move from the player and call the <strong class="keyword">move</strong> function on the piece. The board need not ever know what type of piece it is dealing with. All it has to do is call the <strong class="keyword">move</strong> method, and the proper subclass will take care of moving it as a <strong class="keyword">Knight</strong> or a <strong class="keyword">Pawn</strong>.</p>
    <p class="normal">Polymorphism is <a id="_idIndexMarker048"/>pretty cool, but it is a word that is rarely used in Python programming. Python goes an extra step past allowing a subclass of an object to be treated like a parent class. A board implemented in Python could take any object that has a <strong class="keyword">move</strong> method, whether it is a bishop piece, a car, or a duck. When <strong class="keyword">move</strong> is called, the <strong class="keyword">Bishop</strong> will move diagonally on the board, the car will drive someplace, and the duck will swim or fly, depending on its mood.</p>
    <p class="normal">This sort of polymorphism in Python is typically referred <a id="_idIndexMarker049"/>to as <strong class="keyword">duck typing</strong>: <em class="italic">if it walks like a duck or swims like a duck, we call it a duck</em>. We don't care if it really <em class="italic">is a</em> duck (<em class="italic">is a</em> being a cornerstone of inheritance), only that it swims or walks. Geese and swans might easily be able to provide the duck-like behavior we are looking for. This allows future designers to create new types of birds without actually specifying a formal inheritance hierarchy for all possible kinds of aquatic birds. The chess examples, above, use formal inheritance to cover all possible pieces in the chess set. Duck typing also allows a programmer to extend a design, creating completely different drop-in behaviors the original designers never planned for. For example, future designers might be able to make a walking, swimming penguin that works with the same interface without ever suggesting that penguins have a common superclass with ducks.</p>
    <h2 id="_idParaDest-23" class="title">Multiple inheritance</h2>
    <p class="normal">When we think of <a id="_idIndexMarker050"/>inheritance in our own family tree, we can see that we inherit features from more than just one parent. When strangers tell a proud mother that her son has <em class="italic">his father's eyes</em>, she will typically respond along the lines of, <em class="italic">yes, but he got my nose</em>.</p>
    <p class="normal">Object-oriented <a id="_idIndexMarker051"/>design can also feature such <strong class="keyword">multiple inheritance</strong>, which allows a subclass to inherit functionality from multiple parent classes. In practice, multiple inheritance can be a tricky business, and some programming languages (most famously, Java) strictly prohibit it. However, multiple inheritance can have its uses. Most often, it can be used to create objects that have two distinct sets of behaviors. For example, an object designed to connect to a scanner to make an image and send a fax of the scanned image might be created by inheriting from two separate <code class="Code-In-Text--PACKT-">scanner</code> and <code class="Code-In-Text--PACKT-">faxer</code> objects.</p>
    <p class="normal">As long as two classes have distinct interfaces, it is not normally harmful for a subclass to inherit from both of them. However, it gets messy if we inherit from two classes that provide overlapping interfaces. The scanner and faxer don't have any overlapping features, so combining features from both is easy. Our counterexample is a motorcycle class that has a <code class="Code-In-Text--PACKT-">move</code> method, and a boat class also featuring a <code class="Code-In-Text--PACKT-">move</code> method. </p>
    <p class="normal">If we want to merge them into the ultimate amphibious vehicle, how does the resulting class know what to do when we call <code class="Code-In-Text--PACKT-">move</code>? At the design level, this needs to be explained. (As a sailor who lived on a boat, one of the authors really wants to know how this is supposed to work.)</p>
    <p class="normal">Python has a defined <strong class="keyword">method resolution order</strong> (<strong class="keyword">MRO</strong>) to help us understand which of the alternative <a id="_idIndexMarker052"/>methods will be used. While the MRO rules are simple, avoiding overlap is even simpler. Multiple inheritance as a "mixin" technique for combining unrelated aspects can be helpful. In many cases, though, a composite object may be easier to design.</p>
    <p class="normal">Inheritance <a id="_idIndexMarker053"/>is a powerful tool for extending behavior and reusing features. It is also <a id="_idIndexMarker054"/>one of the most marketable advancements of object-oriented design over earlier paradigms. Therefore, it is often the first tool that object-oriented programmers reach for. However, it is important to recognize that owning a hammer does not turn screws into nails. Inheritance is the perfect solution for obvious <em class="italic">is a</em> relationships. Beyond this, it can be abused. Programmers often use inheritance to share code between two kinds of objects that are only distantly related, with no <em class="italic">is a</em> relationship in sight. While this is not necessarily a bad design, it is a terrific opportunity to ask just why they decided to design it that way, and whether a different relationship or design pattern would have been more suitable.</p>
    <h1 id="_idParaDest-24" class="title">Case study</h1>
    <p class="normal">Our case study<a id="_idIndexMarker055"/> will span many of the chapters of this book. We'll be examining a single problem closely from a variety of perspectives. It's very important to look at alternative designs and design patterns; more than once, we'll point out that there's no single right answer: there are a number of good answers. Our intent here is to provide a realistic example that involves realistic depth and complications and leads to difficult trade-off decisions. Our goal is to help the reader apply object-oriented programming and design concepts. This means choosing among the technical alternatives to create something useful. </p>
    <p class="normal">This first part of the case study is an overview of the problem and why we're tackling it. This background will cover a number of aspects of the problem to set up the design and construction of solutions in later chapters. Part of this overview will include some UML diagrams to capture elements of the problem to be solved. These will evolve in later chapters as we dive into the consequences of design choices and make changes to those design choices.</p>
    <p class="normal">As with many realistic problems, the authors bring personal bias and assumptions. For information on the consequences of this, consider books like <em class="italic">Technically Wrong</em>, by Sara Wachter-Boettcher.</p>
    <p class="normal">Our users want<a id="_idIndexMarker056"/> to automate a job often called <strong class="keyword">classification</strong>. This is the underpinning idea behind product recommendations: last time, a customer bought product X, so perhaps they'd be interested in a similar product, Y. We've classified their desires and can locate other items in that class of products. This problem can involve complex data organization issues.</p>
    <p class="normal">It helps to start with something smaller and more manageable. The users eventually want to tackle complex consumer products, but recognize that solving a difficult problem is not a good way to learn how to build this kind of application. It's better to start with something of a manageable level of complexity and then refine and expand it until it does everything they need. In this case study, therefore, we'll be building a classifier for iris species. This is a classic problem, and there's a great deal written about approaches to classifying iris flowers.</p>
    <p class="normal">A training set of data is required, which the classifier uses as examples of correctly classified irises. We will discuss what the training data looks like in the next section. </p>
    <p class="normal">We'll create a collection of diagrams using<a id="_idIndexMarker057"/> the <strong class="keyword">Unified Modeling Language</strong> (<strong class="keyword">UML</strong>) to help depict and summarize the software we're going to build.</p>
    <p class="normal">We'll examine the problem using a<a id="_idIndexMarker058"/> technique called <strong class="keyword">4+1 Views</strong>. The views are:</p>
    <ul>
      <li class="bullet">A <strong class="keyword">logical view</strong> of the <a id="_idIndexMarker059"/>data entities, their static attributes, and their relationships. This is the heart of object-oriented design.</li>
      <li class="bullet">A <strong class="keyword">process view</strong> that <a id="_idIndexMarker060"/>describes how the data is processed. This can take a variety of forms, including state models, activity diagrams, and sequence diagrams.</li>
      <li class="bullet">A <strong class="keyword">development view</strong> of the <a id="_idIndexMarker061"/>code components to be built. This diagram shows relationships among software components. This is used to show how class definitions are gathered into modules and packages.</li>
      <li class="bullet">A <strong class="keyword">physical view</strong> of the <a id="_idIndexMarker062"/>application to be integrated and deployed. In cases where an application follows a common design pattern, a sophisticated diagram isn't necessary. In other cases, a diagram is essential to show how a collection of components are integrated and deployed.</li>
      <li class="bullet">A <strong class="keyword">context view</strong> that <a id="_idIndexMarker063"/>provides a unifying context for the other four views. The context view will often describe the actors that use (or interact) with the system to be built. This can involve human actors as well as automated interfaces: both are outside the system, and the system must respond to these external actors.</li>
    </ul>
    <p class="normal">It's common to start with the context view so that we have a sense of what the other views describe. As our understanding of the users and the problem domain evolves, the context will evolve also.</p>
    <p class="normal">It's very important to recognize that all of these 4+1 views evolve together. A change to one will generally be reflected in other views. It's a common mistake to think that one view is in some way foundational, and that the other views build on it in a cascade of design steps that always lead to software.</p>
    <p class="normal">We'll start with a summary of the problem and some background before we start trying to analyze the application or design software.</p>
    <h2 id="_idParaDest-25" class="title">Introduction and problem overview</h2>
    <p class="normal">As we mentioned<a id="_idIndexMarker064"/> previously, we'll be starting with a simpler problem – classifying flowers. We want to implement one popular approach called <em class="italic">k</em>-<strong class="keyword">nearest neighbors</strong>, or <em class="italic">k</em>-<strong class="keyword">NN</strong> for short. We require a training set of data, which the classifier algorithm uses as examples of correctly classified irises. Each training sample has a number of attributes, reduced to numeric scores, and a final, correct, classification (i.e. iris species). In this iris example, each training sample is an iris, with its attributes, such as petal shape, size, and so on, encoded into a numeric vector that is an overall representation of the iris, along with a correct species label for that iris.</p>
    <p class="normal">Given an unknown sample, an iris whose species we want to know, we can measure the distance between the unknown sample and any of the known samples in the vector space. For some small group of nearby neighbors, we can take a vote. The unknown sample can be classified into the sub-population selected by the majority of the nearby neighbors.</p>
    <p class="normal">If we only have two<a id="_idIndexMarker065"/> dimensions (or attributes), we can diagram the <em class="italic">k</em>-NN classification like this:</p>
    <figure class="mediaobject"><img src="../Images/B17070_01_11.png" alt="Diagram, engineering drawing  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 1.11: k-nearest neighbors</p>
    <p class="normal">Our unknown <a id="_idIndexMarker066"/>sample is a diamond tagged with "??". It's surrounded by known samples of the square and circle species. When we locate the three nearest neighbors, shown inside the dashed circle, we can take a vote and decide that the unknown is most like the Circle species. </p>
    <p class="normal">One underpinning concept is having tangible, numeric measurements for the various attributes. Converting words, addresses, and other non-ordinal data into an ordinal measurement can be challenging. The good news is that the data we're going to start with data that already has properly ordinal measurements with explicit units of measure.</p>
    <p class="normal">Another<a id="_idIndexMarker067"/> supporting concept is the number of neighbors involved in the voting. This is the <em class="italic">k</em> factor in <em class="italic">k</em>-nearest neighbors. In our conceptual diagram, we've shown <em class="italic">k</em>=3 neighbors; two of the three nearest neighbors are circles, with the third being a square. If we change the <em class="italic">k</em>-value to 5, this will change the composition of the pool and tip the vote in favor of the squares. Which is right? This is checked by having test data with known right answers to confirm that the classification algorithm works acceptably well. In the preceding diagram, it's clear the diamond was cleverly chosen to be a midway between two clusters, intentionally creating a difficult classification problem.</p>
    <p class="normal">A popular dataset for learning how this works is the Iris Classification data. See <a href="https://archive.ics.uci.edu/ml/datasets/iris"><span class="url">https://archive.ics.uci.edu/ml/datasets/iris</span></a> for some background on this data. This is also available at <a href="https://www.kaggle.com/uciml/iris"><span class="url">https://www.kaggle.com/uciml/iris</span></a> and many other places. </p>
    <p class="normal">More experienced readers may notice some gaps and possible contradictions as we move through the object-oriented analysis and design work. This is intentional. An initial analysis of a problem of any scope will involve learning and rework. This case study will evolve as we learn more. If you've spotted a gap or contradiction, formulate your own design and see if it converges with the lessons learned in subsequent chapters.</p>
    <p class="normal">Having looked at some aspects of the problem, we can provide a more concrete context with actors and the use cases or scenarios that describe how an actor interacts with the system to be built. We'll start with the context view.</p>
    <h2 id="_idParaDest-26" class="title">Context view</h2>
    <p class="normal">The context<a id="_idIndexMarker068"/> for our application that classifies iris species involves these two classes of actors:</p>
    <ul>
      <li class="bullet">A "Botanist" who provides the properly classified training data and a properly classified set of test data. The Botanist also runs the test cases to establish the proper parameters for the classification. In the simple case of <em class="italic">k</em>-NN, they can decide which <em class="italic">k</em> value should be used.</li>
      <li class="bullet">A "User" who needs to do classification of unknown data. The user has made careful measurements and makes a request with the measurement data to get a classification from this classifier system. The name "User" seems vague, but we're not sure what's better. We'll leave it for now, and put off changing it until we foresee a problem.</li>
    </ul>
    <p class="normal">This UML context<a id="_idIndexMarker069"/> diagram illustrates the two actors and the three scenarios we will explore:</p>
    <figure class="mediaobject"><img src="../Images/B17070_01_12.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 1.12: UML context diagram</p>
    <p class="normal">The system as a whole is depicted as a rectangle. It encloses ovals to represent user stories. In the UML, specific shapes have meanings, and we reserve rectangles for objects. Ovals (and circles) are for user stories, which are interfaces to the system. </p>
    <p class="normal">In order to do any useful processing, we need training data, properly classified. There are two parts to each set of data: a training set and a test set. We'll call the whole assembly "training data" instead of the longer (but more precise) "training and test data."</p>
    <p class="normal">The tuning<a id="_idIndexMarker070"/> parameters are set by the botanist, who must examine the test results to be sure the classifier works. These are the two parameters that can be tuned:</p>
    <ul>
      <li class="bullet">The distance computation to use</li>
      <li class="bullet">The number of neighbors to consider for voting</li>
    </ul>
    <p class="normal">We'll look at these parameters in detail in the <em class="italic">Processing view</em> section later in this chapter. We'll also revisit these ideas in subsequent case study chapters. The distance computation is an interesting problem.</p>
    <p class="normal">We can define a set of experiments as a grid of each alternative and methodically fill in the grid with the results of measuring the test set. The combination that provides the best fit will be the recommended parameter set from the botanist. In our case, there are two choices, and the grid is a two-dimensional table, like the one shown below. With more complex algorithms, the "grid" may be a multidimensional space:</p>
    <table id="table001" class="No-Table-Style _idGenTablePara-1">
      <colgroup>
        <col/>
        <col/>
        <col/>
        <col/>
        <col/>
      </colgroup>
      <tbody>
        <tr class="No-Table-Style">
          <td class="No-Table-Style"/>
          <td class="No-Table-Style"/>
          <td class="No-Table-Style" colspan="3">
            <p class="Table-Column-Heading--PACKT-">Various k factors</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style"/>
          <td class="No-Table-Style"/>
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">k=3</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">k=5</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">k=7</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style" rowspan="5">
            <p class="Table-Column-Heading--PACKT-">Distance computation</p>
            <p class="Table-Column-Heading--PACKT-">algorithms</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Euclidean</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Test results…</p>
          </td>
          <td class="No-Table-Style"/>
          <td class="No-Table-Style"/>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Manhattan</p>
          </td>
          <td class="No-Table-Style"/>
          <td class="No-Table-Style"/>
          <td class="No-Table-Style"/>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Chebyshev</p>
          </td>
          <td class="No-Table-Style"/>
          <td class="No-Table-Style"/>
          <td class="No-Table-Style"/>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Sorensen</p>
          </td>
          <td class="No-Table-Style"/>
          <td class="No-Table-Style"/>
          <td class="No-Table-Style"/>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Other?</p>
          </td>
          <td class="No-Table-Style"/>
          <td class="No-Table-Style"/>
          <td class="No-Table-Style"/>
        </tr>
      </tbody>
    </table>
    <p class="normal">After the testing, a User can make requests. They provide unknown data to receive classification results from this trained classifier process. In the long run, this "User" won't be a person – they'll be a connection from some website's sales or catalog engine to our clever classifier-based recommendation engine.</p>
    <p class="normal">We can summarize <a id="_idIndexMarker071"/>each of these scenarios with a <strong class="keyword">use case</strong> or <strong class="keyword">user story</strong> statement:</p>
    <ul>
      <li class="bullet">As a Botanist, I want to provide properly classified training and testing data to this system so users can correctly identify plants.</li>
      <li class="bullet">As a Botanist, I want to examine the test results from the classifier to be sure that new samples are likely to be correctly classified.</li>
      <li class="bullet">As a User, I want to be able to provide a few key measurements to the classifier and have the iris species correctly classified.</li>
    </ul>
    <p class="normal">Given the nouns and verbs in the user stories, we can use that information to create a logical view of the data the application will process. </p>
    <h2 id="_idParaDest-27" class="title">Logical view</h2>
    <p class="normal">Looking at the context <a id="_idIndexMarker072"/>diagram, processing starts with training data and testing data. This is properly classified sample data used to test our classification algorithm. The following diagram shows one way to look at a class that contains various training and testing datasets:</p>
    <figure class="mediaobject"><img src="../Images/B17070_01_13.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 1.13: Class diagram for training and testing</p>
    <p class="normal">This shows a <code class="Code-In-Text--PACKT-">Training Data</code> class of objects with the attributes of each instance of this class. The <code class="Code-In-Text--PACKT-">TrainingData</code> object gives our sample collection a name, and some dates where uploading and testing were completed. For now, it seems like each <code class="Code-In-Text--PACKT-">TrainingData</code> object should have a single tuning parameter, <code class="Code-In-Text--PACKT-">k</code>, used for the <em class="italic">k</em>-NN classifier algorithm. An instance also includes two lists of individual samples: a training list and a testing list.</p>
    <p class="normal">Each class of objects is<a id="_idIndexMarker073"/> depicted in a rectangle with a number of individual sections: </p>
    <ul>
      <li class="bullet">The top-most section provides a name for the class of objects. In two cases, we've used a type hint, <code class="Code-In-Text--PACKT-">List[Sample]</code>; the generic class, <code class="Code-In-Text--PACKT-">list</code>, is used in a way that ensures the contents of the list are only <code class="Code-In-Text--PACKT-">Sample</code> objects.</li>
      <li class="bullet">The next section of a class rectangle shows the attributes of each object; these attributes are also called the instance variables of this class.</li>
      <li class="bullet">Later, we'll add "methods" to the bottom section for instances of the class.</li>
    </ul>
    <p class="normal">Each object of the <code class="Code-In-Text--PACKT-">Sample</code> class has a handful of attributes: four floating-point measurement values and a string value, which is the botanist-assigned classification for the sample. In this case, we used the attribute name <code class="Code-In-Text--PACKT-">class</code> because that's what it's called in the source data. </p>
    <p class="normal">The UML arrows show two specific kinds of relationships, highlighted by filled or empty diamonds. A filled diamond shows <strong class="keyword">composition</strong>: a <code class="Code-In-Text--PACKT-">TrainingData</code> object is composed – in part – of two collections. The open diamond shows <strong class="keyword">aggregation</strong>: a <code class="Code-In-Text--PACKT-">List[Sample]</code> object is an aggregate of <code class="Code-In-Text--PACKT-">Sample</code> items. To recap what we learned earlier:</p>
    <ul>
      <li class="bullet">A <strong class="keyword">composition</strong> is an <a id="_idIndexMarker074"/>existential relationship: we can't have <code class="Code-In-Text--PACKT-">TrainingData</code> without the two <code class="Code-In-Text--PACKT-">List[Sample]</code> objects. And, conversely, a <code class="Code-In-Text--PACKT-">List[Sample]</code> object isn't used in our application without being part of a <code class="Code-In-Text--PACKT-">TrainingData</code> object. </li>
      <li class="bullet">An <strong class="keyword">aggregation</strong>, on the <a id="_idIndexMarker075"/>other hand, is a relationship where items can exist independently of each other. In this diagram, a number of <code class="Code-In-Text--PACKT-">Sample</code> objects can be part of <code class="Code-In-Text--PACKT-">List[Sample]</code> or can exist independently of the list.</li>
    </ul>
    <p class="normal">It's not clear that the open diamond to show the aggregation of <code class="Code-In-Text--PACKT-">Sample</code> objects into a <code class="Code-In-Text--PACKT-">List</code> object is relevant. It may be an unhelpful design detail. When in doubt, it's better to omit these kinds of the details until they're clearly required to ensure there's an implementation that meets the user's expectations.</p>
    <p class="normal">We've shown a <code class="Code-In-Text--PACKT-">List[Sample]</code> as a separate class of objects. This is Python's generic <code class="Code-In-Text--PACKT-">List</code>, qualified with a specific class of objects, <code class="Code-In-Text--PACKT-">Sample</code>, that will be in the list. It's common to avoid this level of detail and summarize the relationships in a diagram like the following:</p>
    <figure class="mediaobject"><img src="../Images/B17070_01_14.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 1.14: Condensed class diagram</p>
    <p class="normal">This slightly abbreviated<a id="_idIndexMarker076"/> form can help with doing analytical work, where the underlying data structures don't matter. It's less helpful for design work, as specific Python class information becomes more important.</p>
    <p class="normal">Given an initial sketch, we'll compare this logical view with each of the three scenarios mentioned in the context diagram, shown in <em class="italic">Figure 1.12</em> in the previous section. We want to be sure all of the data and processing in the user stories can be allocated as responsibilities scattered among the classes, attributes, and methods in the diagram. </p>
    <p class="normal">Walking through the user stories, we uncover these two problems:</p>
    <ul>
      <li class="bullet">It's not clear how the testing and parameter tuning fit with this diagram. We know there's a <em class="italic">k</em> factor that's required, but there are no relevant test results to show alternative <em class="italic">k</em> factors and the consequence of those choices.</li>
      <li class="bullet">The user's request is not shown at all. Nor is the response to the user. No classes have these items as part of their responsibilities.</li>
    </ul>
    <p class="normal">The first point suggests we'll need to re-read the user stories and try again to create a better logical view. The second point is a question of boundaries. While the web request and response details are missing, it's more important to describe the essential problem domain – classification and <em class="italic">k</em>-NN – first. The web services for handling a user's requests is one (of many) solution technologies, and we should set that aside when getting started.</p>
    <p class="normal">Now, we'll turn our focus to the processing for the data. We're following what seems to be an effective order for creating a description of an application. The data has to be described first; it's the most enduring part, and the thing that is always preserved through each refinement of the processing. The processing can be secondary to the data, because this changes as the context changes and user experience and preferences change.</p>
    <h2 id="_idParaDest-28" class="title">Process view</h2>
    <p class="normal">There are three <a id="_idIndexMarker077"/>separate user stories. This does not necessarily force us to create three process diagrams. For complex processing, there may be more process diagrams than user stories. In some cases, a user story may be too simple to require a carefully designed diagram.</p>
    <p class="normal">For our application, it seems as though there are at least three unique processes of interest, specifically these:</p>
    <ul>
      <li class="bullet">Upload the initial set of <code class="Code-In-Text--PACKT-">Samples</code> that comprise some <code class="Code-In-Text--PACKT-">TrainingData</code>.</li>
      <li class="bullet">Run a test of the classifier with a given <em class="italic">k</em> value.</li>
      <li class="bullet">Make a classification request with a new <code class="Code-In-Text--PACKT-">Sample</code> object.</li>
    </ul>
    <p class="normal">We'll sketch activity diagrams for these use cases. An activity diagram summarizes a number of state changes. The processing begins with a start node and proceeds until an end node is reached. In transaction-based applications, like web services, it's common to omit showing the overall web server engine. This saves us from describing common features of HTTP, including standard headers, cookies, and security concerns. Instead, we generally focus on the unique processing that's performed to create a response for each distinct kind of request.</p>
    <p class="normal">The activities are shown in round-corner rectangles. Where specific classes of objects or software components are relevant, they can be linked to relevant activities.</p>
    <p class="normal">What's more important is making sure that the logical view is updated as ideas arise while working on the processing view. It's difficult to get either view done completely in isolation. It's far more important to make incremental changes in each view as new solution ideas arise. In some cases, additional user input is required, and this too will lead to the evolution of these views.</p>
    <p class="normal">We can sketch a diagram to show how the system responds when the Botanist provides the initial data. Here's the first example:</p>
    <figure class="mediaobject"><img src="../Images/B17070_01_15.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 1.15: Activity diagram</p>
    <p class="normal">The <a id="_idIndexMarker078"/>collection of <code class="Code-In-Text--PACKT-">KnownSample</code> values will be partitioned into two subsets: a training subset and a testing subset. There's no rule in our problem summary or user stories for making this distinction; the gap shows we're missing details in the original user story. When details are missing from the user stories, then the logical view may be incomplete, also. For now, we can labor under an assumption that most of the data – say 75% - will be used for training, and the rest, 25%, will be used for testing.</p>
    <p class="normal">It often helps to create similar diagrams for each of the user stories. It also helps to be sure that the activities all have relevant classes to implement the steps and represent state changes caused by each step.</p>
    <p class="normal">We've included a verb, <code class="Code-In-Text--PACKT-">Partition</code>, in this diagram. This suggests a method will be required to implement the verb. This may lead to rethinking the class model to be sure the processing can be implemented.</p>
    <p class="normal">We'll turn next to considering some of the components to be built. Since this is a preliminary analysis, our ideas will evolve as we do more detailed design and start creating class definitions.</p>
    <h2 id="_idParaDest-29" class="title">Development view</h2>
    <p class="normal">There's often a delicate <a id="_idIndexMarker079"/>balance between the final deployment and the components to be developed. In rare cases, there are few deployment constraints, and the designer can think freely about the components to be developed. A physical view will evolve from the development. In more common cases, there's a specific target architecture that must be used, and elements of the physical view are fixed.</p>
    <p class="normal">There are several ways to deploy this classifier as part of a larger application. We might build a desktop application, a mobile application, or a website. Because of the ubiquity of internetworked computers, one common approach is to create a website and connect to it from desktops and mobile apps.</p>
    <p class="normal">A web services architecture, for example, means requests can be made to a server; the responses could be HTML pages for presentation in a browser, or JSON documents that can be displayed by a mobile application. Some requests will provide whole new sets of training data. Other requests will be seek to classify unknown samples. We'll detail the architecture in the physical view below. We might want to use the Flask framework to build a web service. For more information on Flask, see <em class="italic">Mastering Flask Web Development</em>, <a href="https://www.packtpub.com/product/mastering-flask-web-development-second-edition/9781788995405"><span class="url">https://www.packtpub.com/product/mastering-flask-web-development-second-edition/9781788995405</span></a>, or <em class="italic">Learning Flask Framework</em>, <a href="https://www.packtpub.com/product/learning-flask-framework/9781783983360"><span class="url">https://www.packtpub.com/product/learning-flask-framework/9781783983360</span></a>.</p>
    <p class="normal">The following diagram shows some of the components we need would need to build for a Flask-based application:</p>
    <figure class="mediaobject"><img src="../Images/B17070_01_16.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 1.16: Components to be built</p>
    <p class="normal">This diagram shows a <a id="_idIndexMarker080"/>Python package, <code class="Code-In-Text--PACKT-">Classifier</code>, that contains a number of modules. The three top-level modules are:</p>
    <ul>
      <li class="bullet"><strong class="keyword">Data Model</strong>: (Since this is still analysis time, the name here is not properly Pythonic; we'll change it later as we move into implementation.) It's often helpful to separate the classes that define the problem domain into modules. This makes it possible for us to test them in isolation from any particular application that uses those classes. We'll focus on this part, since it is foundational.</li>
      <li class="bullet"><strong class="keyword">View Functions</strong>: (Also an analysis name, not a Pythonic implementation name.) This module will create an instance of the <code class="Code-In-Text--PACKT-">Flask</code> class, our application. It will define the functions that handle requests by creating responses that can be displayed by a mobile app or a browser. These functions expose features of the model, and don't involve the same depth and complexity of the model itself; we won't focus on this component in the case study.</li>
      <li class="bullet"><strong class="keyword">Tests</strong>: This will have unit tests for the model and view functions. While tests are essential for being sure the software is usable, they are the subject of <em class="chapterRef">Chapter 13</em>, <em class="italic">Testing Object-Oriented Programs</em>.</li>
    </ul>
    <p class="normal">We have included <a id="_idIndexMarker081"/>dependency arrows, using dashed lines. These can be annotated with the Python-specific "imports" label to help clarify how the various packages and modules are related.</p>
    <p class="normal">As we move through the design in later chapters, we'll expand on this initial view. Having thought about what needs to be built, we can now consider how it's deployed by drawing a physical view of the application. As noted above, there's a delicate dance between development and deployment. The two views are often built together.</p>
    <h2 id="_idParaDest-30" class="title">Physical view</h2>
    <p class="normal">The physical view<a id="_idIndexMarker082"/> shows how the software will be installed into physical hardware. For<a id="_idIndexMarker083"/> web services, we often talk about a <strong class="keyword">continuous integration and continuous deployment</strong> (<strong class="keyword">CI/CD</strong>) pipeline. This means that a change to the software is tested as a unit, integrated with the existing applications, tested as an integrated whole, then deployed for the users.</p>
    <p class="normal">While it's common to assume a website, this can also be deployed as a command-line application. It might be run on a local computer. It might also be run on a computer in the cloud. Another choice is to build a web application around the core classifier.</p>
    <p class="normal">The following diagram shows a view of a web application server:</p>
    <figure class="mediaobject"><img src="../Images/B17070_01_17.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 1.17: Application server diagram</p>
    <p class="normal">This diagram shows the<a id="_idIndexMarker084"/> client and server nodes as three-dimensional "boxes" with "components" installed on them. We've identified three components:</p>
    <ul>
      <li class="bullet">A Client running the <strong class="screenText">client app</strong> application. This application connects to the classifier web service and makes RESTful requests. It might be a website, written in JavaScript. It might be a mobile application, written in Kotlin or Swift. All of these frontends have a common <strong class="screenText">HTTPS</strong> connection to our web server. This secure connection requires some configuration of certificates and encryption key pairs.</li>
      <li class="bullet">The <strong class="screenText">GUnicorn</strong> web server. This server can handle a number of details of web service requests, including the important HTTPS protocol. See <a href="https://docs.gunicorn.org/en/stable/index.html"><span class="url">https://docs.gunicorn.org/en/stable/index.html</span></a> for details.</li>
      <li class="bullet">Our <strong class="screenText">Classifier</strong> application. From this view, the complexities have been omitted, and the entire <code class="Code-In-Text--PACKT-">Classifier</code> package is reduced to a small component in a larger web services framework. This could be built using the Flask framework.</li>
    </ul>
    <p class="normal">Of these components, the Client's <strong class="screenText">client app</strong> is not part of the work being done to develop the classifier. We've included this to illustrate the context, but we're not really going to be building it.</p>
    <p class="normal">We've used a dotted dependency arrow to show that our <code class="Code-In-Text--PACKT-">Classifier</code> application is a dependency from the web server. <strong class="screenText">GUnicorn</strong> will import our web server object and use it to respond to requests.</p>
    <p class="normal">Now that we've sketched out the application, we can consider writing some code. As we write, it helps to keep the diagrams up-to-date. Sometimes, they serve as a handy roadmap in a wilderness of code.</p>
    <h2 id="_idParaDest-31" class="title">Conclusion</h2>
    <p class="normal">There are several key concepts<a id="_idIndexMarker085"/> in this case study:</p>
    <ol>
      <li class="numbered" value="1">Software applications can be rather complicated. There are five views to depict the users, the data, the processing, the components to be built, and the target physical implementation.</li>
      <li class="numbered">Mistakes will be made. This overview has some gaps in it. It's important to move forward with partial solutions. One of Python's advantages is the ability to build software quickly, meaning we're not deeply invested in bad ideas. We can (and should) remove and replace code quickly.</li>
      <li class="numbered">Be open to extensions. After we implement this, we'll see that setting the <em class="italic">k</em> parameter is a tedious exercise. An important next step is to automate tuning using a grid search tuning algorithm. It's often helpful to set these things aside and get something that works first, then extend working software later to add this helpful feature.</li>
      <li class="numbered">Try to assign clear responsibilities to each class. This has been moderately successful, and some responsibilities are vague or omitted entirely. We'll revisit this as we expand this initial analysis into implementation details.</li>
    </ol>
    <p class="normal">In later chapters, we'll dive more deeply into these various topics. Because our intent is to present realistic work, this will involve rework. Some design decisions may be revised as the reader is exposed to more and more of the available objected-oriented programming techniques in Python. Additionally, some parts of the solution will evolve as our understanding of design choices and the problem itself evolves. Rework based on lessons learned is a consequence of an agile approach to development.</p>
    <h1 id="_idParaDest-32" class="title">Recall</h1>
    <p class="normal">Some key points in this chapter:</p>
    <ul>
      <li class="bullet">Analyzing problem requirements in an object-oriented context</li>
      <li class="bullet">How to draw <strong class="keyword">Unified Modeling Language</strong> (<strong class="keyword">UML</strong>) diagrams to communicate how the system works</li>
      <li class="bullet">Discussing object-oriented systems using the correct terminology and jargon</li>
      <li class="bullet">Understanding the distinction between class, object, attribute, and behavior</li>
      <li class="bullet">Some OO design techniques are used more than others. In our case study example, we focused on a few:<ul>
          <li class="bullet-l2">Encapsulating features into classes</li>
          <li class="bullet-l2">Inheritance to extend a class with new features</li>
          <li class="bullet-l2">Composition to build a class from component objects</li>
        </ul>
      </li>
    </ul>
    <h1 id="_idParaDest-33" class="title">Exercises</h1>
    <p class="normal">This is a practical book. As such, we're not assigning a bunch of fake object-oriented analysis problems to create designs for you to analyze and design. Instead, we want to give you some ideas that you can apply to your own projects. If you have previous object-oriented experience, you won't need to put much effort into this chapter. However, they are useful mental exercises if you've been using Python for a while, but have never really cared about all that class stuff.</p>
    <p class="normal">First, think about a recent programming project you've completed. Identify the most prominent object in the design. Try to think of as many attributes for this object as possible. Did it have the following: Color? Weight? Size? Profit? Cost? Name? ID number? Price? Style?</p>
    <p class="normal">Think about the attribute types. Were they primitives or classes? Were some of those attributes actually behaviors in disguise? Sometimes, what looks like data is actually calculated from other data on the object, and you can use a method to do those calculations. What other methods or behaviors did the object have? Which objects called those methods? What kinds of relationships did they have with this object?</p>
    <p class="normal">Now, think about an upcoming project. It doesn't matter what the project is; it might be a fun free-time project or a multi-million-dollar contract. It doesn't have to be a complete application; it could just be one subsystem. Perform a basic object-oriented analysis. Identify the requirements and the interacting objects. Sketch out a class diagram featuring the highest level of abstraction on that system. Identify the major interacting objects. Identify minor supporting objects. Go into detail for the attributes and methods of some of the most interesting ones. Take different objects to different levels of abstraction. Look for places where you can use inheritance or composition. Look for places where you should avoid inheritance.</p>
    <p class="normal">The goal is not to design a system (although you're certainly welcome to do so if inclination meets both ambition and available time). The goal is to think about object-oriented design. Focusing on projects that you have worked on, or are expecting to work on in the future, simply makes it real.</p>
    <p class="normal">Lastly, visit your favorite search engine and look up some tutorials on UML. There are dozens, so find one that suits your preferred method of study. Sketch some class diagrams or a sequence diagram for the objects you identified earlier. Don't get too hung up on memorizing the syntax (after all, if it is important, you can always look it up again); just get a feel for the language. Something will stay lodged in your brain, and it can make communicating a bit easier if you can quickly sketch a diagram for your next OOP discussion.</p>
    <h1 id="_idParaDest-34" class="title">Summary</h1>
    <p class="normal">In this chapter, we took a whirlwind tour through the terminology of the object-oriented paradigm, focusing on object-oriented design. We can separate different objects into a taxonomy of different classes and describe the attributes and behaviors of those objects via the class interface. Abstraction, encapsulation, and information hiding are highly-related concepts. There are many different kinds of relationships between objects, including association, composition, and inheritance. UML syntax can be useful for fun and communication.</p>
    <p class="normal">In the next chapter, we'll explore how to implement classes and methods in Python.</p>
  </div>
</body></html>