<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04" class="calibre1"/>Chapter 4. Wrapping States Around Execution Modules</h1></div></div></div><p class="calibre8">Now that we've covered execution modules and configuration modules, it's time to talk about configuration management. The idea behind a state module is to use execution modules as a mechanism for bringing a resource to a certain state: a package is in an installed state, a service is in a running state, a file's contents match the state defined on the Master. In this chapter, we'll discuss:</p><div><ul class="itemizedlist"><li class="listitem">The concepts behind a basic state module layout</li><li class="listitem">Deciding how far to take each state</li><li class="listitem">Troubleshooting state modules</li></ul></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch04lvl1sec23" class="calibre1"/>Forming a state module</h1></div></div></div><p class="calibre8">State modules <a id="id119" class="calibre1"/>are more structured than most other kinds of modules, but as you'll soon see, that actually makes them easier to write.</p></div></div>

<div><div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec42" class="calibre1"/>Determining state</h2></div></div></div><p class="calibre8">There<a id="id120" class="calibre1"/> is a set <a id="id121" class="calibre1"/>of operations that a state module must take in order to perform its job, and as those operations are done, there is certain data that is stored. Let's start off with a pseudo piece of code, and explain each component in turn:</p><div><pre class="programlisting">def __virtual__():
    '''
    Only load if the necesaary modules available in __salt__
    '''
    if 'module.function' in __salt__:
        return True
    return False


def somestate(name):
    '''
    Achieve the desired state

    nane
        The name of the item to achieve statefulness
    '''
    ret = {'name': name,
           'changes': {},
           'result': None,
           'comment': ''}
    if &lt;item is already in the desired state&gt;:
        ret['result'] = True
        ret['comment'] = 'The item is already in the desired state'
        return ret
    if __opts__['test']:
        ret['comment'] = 'The item is not in the desired state'
        return ret
    &lt;attempt to configure the item correctly&gt;
    if &lt;we are able to put the item in the correct state&gt;:
        ret['changes'] = {'desired state': name}
        ret['result'] = True
        ret['comment'] = 'The desired state was successfully achieved'
        return ret
    else:
        ret['result'] = False
        ret['comment'] = 'The desired state failed to be achieved'
        return ret</pre></div><div><div><div><div><h3 class="title2"><a id="ch04lvl3sec01" class="calibre1"/>The __virtual__() function</h3></div></div></div><p class="calibre8">By now, you're <a id="id122" class="calibre1"/>already familiar with this function, but I want to mention it here again. Because execution modules are meant to perform the heavy lifting, it is crucial to make sure that they are available before trying to make use of them.</p><p class="calibre8">There's a good chance you'll need to cross-call multiple functions inside your state module. Usually, you'll call at least one function to check for the status of the item in question, and at least one more to bring the item into the desired configuration. But if they're all in the same execution module, you really only need to check for the presence of one of them.</p><p class="calibre8">Say you were going to write a state that used the <code class="email">http.query</code> execution module to perform lookups <a id="id123" class="calibre1"/>and make changes to a web resource. That function should always be available, but for the sake of demonstration, we'll assume that we need to check for it. One way to write the function would be:</p><div><pre class="programlisting">def __virtual__():
    '''
    Check for http.query
    '''
    if 'http.query' in __salt__:
        return True
    return False</pre></div><p class="calibre8">There is also a shorter way to do this:</p><div><pre class="programlisting">def __virtual__():
    '''
    Check for http.query
    '''
    return 'http.query' in __salt__</pre></div></div><div><div><div><div><h3 class="title2"><a id="ch04lvl3sec02" class="calibre1"/>Setting up defaults</h3></div></div></div><p class="calibre8">With <a id="id124" class="calibre1"/>the <code class="email">__virtual__()</code> function out of the way, we can move on to the stateful function itself. First we set up some default variables in a dictionary. In our example, and in most state modules, the dictionary is called <code class="email">ret</code>. This is by convention only, and is not an actual requirement. However, the keys and their data types inside the dictionary are a hard requirement. These keys are:</p><div><ul class="itemizedlist"><li class="listitem"><code class="email">name</code> (string) – This is <a id="id125" class="calibre1"/>the name of the resource that is passed into the state. This is also known as the ID from the state. For instance, in the following state:<div><pre class="programlisting">nginx:
  - pkg.installed</pre></div><div><ul class="itemizedlist1"><li class="listitem">The name passed in would be <code class="email">nginx</code>.</li></ul></div></li><li class="listitem"><code class="email">changes</code> (dictionary) – If the <a id="id126" class="calibre1"/>state applies any changes to the Minion, this dictionary will contain an entry for each of the changes that was applied. For instance, if <code class="email">pkg.installed</code> was used to install <code class="email">nginx</code>, the <code class="email">changes</code> dictionary would look like:<div><pre class="programlisting">{'nginx': {'new': '1.8.0-2',  'old': ''}}</pre></div><div><ul class="itemizedlist1"><li class="listitem">There is no restriction imposed on the type of data stored in <code class="email">changes</code>, so long as <code class="email">changes</code> itself is a dictionary. If changes are made, then this dictionary <em class="calibre9">must</em> have something in it.</li></ul></div></li><li class="listitem"><code class="email">result</code> (boolean) – This <a id="id127" class="calibre1"/>field is one of three values: <code class="email">True</code>, <code class="email">False</code>, or <code class="email">None</code>. If the specified resource is already in the state that it was meant to be in, or it was successfully made to be in that state, this field will be <code class="email">True</code>. If the resource was not in the correct state, but <code class="email">salt</code> was run with <code class="email">test=True</code>, then this field is set to <code class="email">None</code>. If the resource was not in the correct state, and Salt was unable to put it into the correct state, then this field will be set to <code class="email">False</code>.<div><ul class="itemizedlist1"><li class="listitem">When performing a state run, such as <code class="email">state.highstate</code>, the value of the result will affect the color of the output. States that are <code class="email">True</code>, but have no <code class="email">changes</code>, will be green. States that are <code class="email">True</code> and have <code class="email">changes</code> will be blue. States that are <code class="email">None</code> will be yellow. States that are <code class="email">False</code> will be red.</li></ul></div></li><li class="listitem"><code class="email">comment</code> (string) – This <a id="id128" class="calibre1"/>field is entirely freeform: it may contain any comments you want, or no comments. However, it is better to have some comment, even as short as <code class="email">The requested resource is already in the desired state</code>. If the result is <code class="email">None</code> or <code class="email">False</code>, then the <code class="email">comment</code> should contain a message that is as helpful as possible concerning why the resource is not configured properly, and how that may be corrected.<div><ul class="itemizedlist1"><li class="listitem">The defaults that we use in our example will be good for almost any state:<div><pre class="programlisting">    ret = {'name': name,
           'changes': {},
           'result': None,
           'comment': ''}</pre></div></li></ul></div></li></ul></div></div><div><div><div><div><h3 class="title2"><a id="ch04lvl3sec03" class="calibre1"/>Checking for truth</h3></div></div></div><p class="calibre8">After the <a id="id129" class="calibre1"/>defaults have been set, the next task is to check the resource and see whether or not it is in the desired state:</p><div><pre class="programlisting">    if &lt;item is already in the desired state&gt;:
        ret['result'] = True
        ret['comment'] = 'The item is already in the desired state'
        return ret</pre></div><p class="calibre8">This may be a quick check using a single function in an execution module, or it may consist of much more logic requiring several functions to be cross-called. Don't add any more code here than is necessary to check the state of the resource; remember that all heavy lifting should be performed in the execution module.</p><p class="calibre8">If the resource is found to be properly configured, then the <code class="email">result</code> is set to <code class="email">True</code>, a helpful <code class="email">comment</code> is added, and the function <code class="email">return</code>s. If the resource is not properly configured, then we<a id="id130" class="calibre1"/> move on to the next section.</p></div><div><div><div><div><h3 class="title2"><a id="ch04lvl3sec04" class="calibre1"/>Checking for test mode</h3></div></div></div><p class="calibre8">If the <a id="id131" class="calibre1"/>code makes it past the check for truth, then we can assume that something is wrong. But before we make any changes to the system, we need to see whether or not <code class="email">salt</code> was called with <code class="email">test=True</code>.</p><div><pre class="programlisting">    if __opts__['test']:
        ret['comment'] = 'The item is not in the desired state'
        return ret</pre></div><p class="calibre8">If so, we set a helpful <code class="email">comment</code> for the user, and then <code class="email">return</code> the <code class="email">ret</code> dictionary. If there is any more logic that happens once it has been determined that <code class="email">salt</code> is running in <code class="email">test</code> mode, then it should only be to give the user more helpful information in the comment. No changes should ever be made in <code class="email">test</code> mode!</p></div><div><div><div><div><h3 class="title2"><a id="ch04lvl3sec05" class="calibre1"/>Attempting to configure the resource</h3></div></div></div><p class="calibre8">If we get <a id="id132" class="calibre1"/>past the check for <code class="email">test</code> mode, then we know that we can try to make changes to correctly configure the resource:</p><div><pre class="programlisting">    &lt;attempt to configure the item correctly&gt;
    if &lt;we are able to put the item in the correct state&gt;:
        ret['changes'] = {'desired state': name}
        ret['result'] = True
        ret['comment'] = 'The desired state was successfully achieved'
        return ret</pre></div><p class="calibre8">Again, this section of the code should only contain enough logic to correctly configure the resource in question, and then notify the user if it was successful. If the change was successful, then we update the <code class="email">changes</code> dictionary, add a <code class="email">comment</code> that describes how those <code class="email">changes</code> were achieved, set the <code class="email">result</code> to <code class="email">True</code>, and then <code class="email">return</code>.</p></div><div><div><div><div><h3 class="title2"><a id="ch04lvl3sec06" class="calibre1"/>Notifying about False</h3></div></div></div><p class="calibre8">If we <a id="id133" class="calibre1"/>get past that piece of code, we are now assured that something has gone wrong, and that we are unable to fix it:</p><div><pre class="programlisting">    else:
        ret['result'] = False
        ret['comment'] = 'The desired state failed to be achieved'
        return ret</pre></div><p class="calibre8">This is the most important section of code to be helpful to the user, because user interaction will likely be required to fix whatever the problem is.</p><p class="calibre8">It could be <a id="id134" class="calibre1"/>that the SLS file was just poorly written, and that the next state run will fix it. It could also be that the state module has a bug that needs to be fixed. Or there could be some other situation that is beyond Salt's ability to control, such as a web service that is temporarily unavailable. The comment should contain as much information as is helpful to track down and fix the problem, and no more. This is also the time to set the result to <code class="email">False</code> before <code class="email">return</code>ing.</p></div></div></div></div>

<div><div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch04lvl2sec43" class="calibre1"/>Example: checking an HTTP service</h2></div></div></div><p class="calibre8">There is <a id="id135" class="calibre1"/>already a<a id="id136" class="calibre1"/> state for contacting web services: the <code class="email">http.query</code> state. However, it is very general-purpose, and using it directly has limited use. In fact, it doesn't really have the logic to do much more than check whether a URL responds as expected. In order to make it more intelligent, we need to add some logic on our own.</p><div><div><div><div><h3 class="title2"><a id="ch04lvl3sec07" class="calibre1"/>Checking credentials</h3></div></div></div><p class="calibre8">Let's start by <a id="id137" class="calibre1"/>setting up our <code class="email">docstring</code>, a library import, and a <code class="email">__virtual__()</code> function with some credentials for a theoretical web service:</p><div><pre class="programlisting">'''
This state connects to an imaginary web service.
The following credentials must be configured:

    webapi_username: &lt;your username&gt;
    webapi_password: &lt;your password&gt;

This module should be saved as salt/states/fake_webapi.py
'''
import salt.utils.http


def __virtual__():
    '''
    Make sure there are credentials
    '''
    username = __salt__['config.get']('webapi_username', False)
    password = __salt__['config.get']('webapi_password', False)
    if username and password:
        return True
    return False</pre></div><p class="calibre8">In this case, we aren't checking for the existence of the <code class="email">http.query</code> function; as we said before, it's already there. But this module won't function without being able to connect to the web service, so we do a quick check to make sure the credentials are in place.</p><p class="calibre8">We aren't <a id="id138" class="calibre1"/>checking to see if the service itself responds, or if the credentials are correct. The <code class="email">__virtual__()</code> function is checked when the Minion starts, and doing all that checking then is unnecessary and, in the event of downtime, possibly inaccurate. It will also slow the Minion from loading. It is better to do that checking later, when we actually make the call to the service.</p></div><div><div><div><div><h3 class="title2"><a id="ch04lvl3sec08" class="calibre1"/>The first stateful function</h3></div></div></div><p class="calibre8">Next, we <a id="id139" class="calibre1"/>need to set up a state function. For our example, we're going to allow users to make sure that a specific user's account on that web service is locked out. First, we set up our defaults, and then check to see if that user's account has been locked out yet:</p><div><pre class="programlisting">def locked(name):
    '''
    Ensure that the user is locked out
    '''
    username = __salt__['config.get']('webapi_username', False)
    password = __salt__['config.get']('webapi_password', False)

    ret = {'name': name,
           'changes': {},
           'result': None,
           'comment': ''}

    result = salt.utils.http.query(
        'https://api.example.com/v1/users/{0}'.format(name),
        username=username,
        password=password,
        decode=True,
        decode_type='json',
    )

    if result('dict', {}).get('access', '') == 'locked':
        ret['result'] = True
        ret['comment'] = 'The account is already locked'
        return ret</pre></div><p class="calibre8">You may see a problem right away. Making an authenticated web call is a little heavy, especially when you have to decode the return data, no matter how you do it. We're going to make <a id="id140" class="calibre1"/>another web call in this function, and then more in other functions. Let's break out what we can into another function:</p><div><pre class="programlisting">def _query(action, resource='', data=None):
    '''
    Make a query against the API
    '''
    username = __salt__['config.get']('webapi_username', False)
    password = __salt__['config.get']('webapi_password', False)

    result = salt.utils.http.query(
        'https://api.example.com/v1/{0}/{1}'.format(action, resource),
        username=username,
        password=password,
        decode=True,
        decode_type='json',
        data=data,
    )


def locked(name):
    '''
    Ensure that the user is locked out
    '''
    ret = {'name': name,
           'changes': {},
           'result': None,
           'comment': ''}

    result = _query('users', name)
    if result('dict', {}).get('access', '') == 'locked':
        ret['result'] = True
        ret['comment'] = 'The account is already locked'
        return ret</pre></div><p class="calibre8">The new <code class="email">_query()</code> function expects at least one argument: the type of query (<code class="email">action</code>) that is going to be performed against the API. It's very common for this kind of API to be expected to list all items for that query if a specific resource isn't specified, so we've allowed the resource to be blank. We've also set up another optional parameter called data, which we'll make use of in a moment.</p><p class="calibre8">Now we have a check for whether the account is locked, and are able to <code class="email">return True</code> if it is. If we get <a id="id141" class="calibre1"/>past that point, we know the account isn't locked, so let's do our check for <code class="email">test</code> mode:</p><div><pre class="programlisting">    if __opts__['test']:
        ret['comment'] = 'The {0} account is not locked'.format(name)
        return ret</pre></div><p class="calibre8">This part is easy enough; we have all of the information that is needed for <code class="email">test</code> mode, and we don't need to do anything else besides <code class="email">return</code> it. Let's go ahead and try to apply the correct setting to the account.</p><div><pre class="programlisting">    _query('users', name, {'access': 'locked'})</pre></div><p class="calibre8">Remember that <code class="email">data</code> option? We used it to pass in a dictionary that sets the access value for that user to <code class="email">locked</code>. This is also a very common way to modify data with a web API.</p><p class="calibre8">Of course, we don't necessarily know that the setting was applied correctly, so let's do one more check, just to make sure:</p><div><pre class="programlisting">    result = _query('users', name)
    if result('dict', {}).get('access', '') == 'locked':
        ret['changes'] = {'locked': name}
        ret['result'] = True
        ret['comment'] = 'The {0} user account is now locked'.format(name)
        return ret
    else:
        ret['result'] = False
        ret['comment'] = 'Failed to set the {0} user account to locked'.format(name)
        return ret</pre></div><p class="calibre8">If the account is now locked, then we can return that we were successful. If the account is still not locked, then we can return a failure message.</p></div><div><div><div><div><h3 class="title2"><a id="ch04lvl3sec09" class="calibre1"/>Another stateful function</h3></div></div></div><p class="calibre8">Let's go <a id="id142" class="calibre1"/>ahead and add another function, to allow a user account to be unlocked. We'll also take this opportunity to show you the entire module, with all of the public and private functions:</p><div><pre class="programlisting">'''
This state connects to an imaginary web service.
The following credentials must be configured:

    webapi_username: &lt;your username&gt;
    webapi_password: &lt;your password&gt;

This module should be saved as salt/states/fake_webapi.py
'''
import salt.utils.http


def __virtual__():
    '''
    Make sure there are credentials
    '''
    username = __salt__['config.get']('webapi_username', False)
    password = __salt__['config.get']('webapi_password', False)
    if username and password:
        return True
    return False


def _query(action, resource='', data=None):
    '''
    Make a query against the API
    '''
    username = __salt__['config.get']('webapi_username', False)
    password = __salt__['config.get']('webapi_password', False)

    result = salt.utils.http.query(
        'https://api.example.com/v1/{0}/{1}'.format(action, resource),
        username=username,
        password=password,
        decode=True,
        decode_type='json',
        data=data,
    )
return result


def locked(name):
    '''
    Ensure that the user is locked out
    '''
    ret = {'name': name,
           'changes': {},
           'result': None,
           'comment': ''}

    result = _query('users', name)
    if result('dict', {}).get('access', '') == 'locked':
        ret['result'] = True
        ret['comment'] = 'The account is already locked'
        return ret

    if __opts__['test']:
        ret['comment'] = 'The {0} account is not locked'.format(name)
        return ret

    _query('users', name, {'access': 'locked'})

    result = _query('users', name)
    if result('dict', {}).get('access', '') == 'locked':
        ret['changes'] = {'locked': name}
        ret['result'] = True
        ret['comment'] = 'The {0} user account is now locked'.format(name)
        return ret
    else:
        ret['result'] = False
        ret['comment'] = 'Failed to set the {0} user account to locked'.format(name)
        return ret


def unlocked(name):
    '''
    Ensure that the user is NOT locked out
    '''
    ret = {'name': name,
           'changes': {},
           'result': None,
           'comment': ''}

    result = _query('users', name)
    if result('dict', {}).get('access', '') == 'unlocked':
        ret['result'] = True
        ret['comment'] = 'The account is already unlocked'
        return ret

    if __opts__['test']:
        ret['comment'] = 'The {0} account is locked'.format(name)
        return ret

    _query('users', name, {'access': 'unlocked'})

    result = _query('users', name)
    if result('dict', {}).get('access', '') == 'unlocked':
        ret['changes'] = {'locked': name}
        ret['result'] = True
        ret['comment'] = 'The {0} user account is no longer locked'.format(name)
        return ret
    else:
        ret['result'] = False
        ret['comment'] = 'Failed to unlock the {0} user account'.format(name)
        return ret</pre></div><p class="calibre8">You can see<a id="id143" class="calibre1"/> that there's not much difference between these two functions. In fact, really, they do exactly the same thing, but with opposing logic: one locks an account and one unlocks an account.</p><p class="calibre8">It is very common for a state module to contain two opposites for the same configuration. You will frequently see function names like <code class="email">installed</code> and <code class="email">removed</code>, <code class="email">present</code> and <code class="email">absent</code>, and <code class="email">running</code> and <code class="email">dead</code>.</p></div></div></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec24" class="calibre1"/>Troubleshooting state modules</h1></div></div></div><p class="calibre8">Even <a id="id144" class="calibre1"/>though the code is more structured, it can be a little tricky to troubleshoot state modules. This is because you need to test all four types of return results:</p><div><ul class="itemizedlist"><li class="listitem">True – The resource is already correctly configured</li><li class="listitem">None – The resource is not correctly configured, and <code class="email">test</code> mode is True</li><li class="listitem">True with changes – The resource was not correctly configured, but now it is</li><li class="listitem">False – The resource could not be correctly configured</li></ul></div><p class="calibre8">What makes this even trickier is that in the course of troubleshooting, you are likely to change configuration to be correct, and then incorrect, and then back again several times before the code is right. I suggest breaking it up.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec44" class="calibre1"/>Step 1: test for truth</h2></div></div></div><p class="calibre8">Your <a id="id145" class="calibre1"/>first step, after setting up your defaults, is to check whether the resource is correctly configured. This is likely to require you to manually toggle settings to make sure it is properly checking both desired and undesired configuration. Add two returns: one for <code class="email">True</code> and one for <code class="email">False</code>:</p><div><pre class="programlisting">    ret = {'name': name,
           'changes': {},
           'result': None,
           'comment': ''}
    if &lt;item is already in the desired state&gt;:
        ret['result'] = True
        ret['comment'] = 'The item is already in the desired state'
        return ret
    ret['result'] = False
    return ret</pre></div><p class="calibre8">You can <a id="id146" class="calibre1"/>remove those last two lines later, once you know the code is correct. You don't need to set up an entire SLS file to test your state; you can use <code class="email">state.single</code> to perform a one-off state command:</p><div><pre class="programlisting">
<strong class="calibre2"># salt-run --local state.single fake_webapi.locked larry</strong>
</pre></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec45" class="calibre1"/>Step 2: test mode</h2></div></div></div><p class="calibre8">Once you're sure<a id="id147" class="calibre1"/> it's correctly detecting the current configuration, manually set the configuration to an undesired value, and make sure <code class="email">test</code> mode is working properly:</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch04lvl2sec46" class="calibre1"/>Step 3: applying changes</h2></div></div></div><p class="calibre8">When you <a id="id148" class="calibre1"/>are sure that your code will not try to apply changes without first checking for test mode, you can move on to applying changes.</p><p class="calibre8">This is the trickiest part, for two reasons. First, you'll end up setting and resetting your configuration a lot. This can be tedious at best, but there's no avoiding it. Second, you'll be both setting the correct configuration, and then testing to see if it was set, at the same time:</p><div><pre class="programlisting">    &lt;attempt to configure the item correctly&gt;
    if &lt;we are able to put the item in the correct state&gt;:
        ret['changes'] = {'desired state': name}
        ret['result'] = True
        ret['comment'] = 'The desired state was successfully achieved'
        return ret
    else:
        ret['result'] = False
        ret['comment'] = 'The desired state failed to be achieved'
        return ret</pre></div><p class="calibre8">You may think <a id="id149" class="calibre1"/>that you can split this part up, but before long you're likely to realize that in order to make sure the configuration was applied properly, you still need to perform the same check as you would normally be performing in your own tests, so you might as well get it out of the way now.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch04lvl2sec47" class="calibre1"/>Testing opposites</h2></div></div></div><p class="calibre8">Thankfully, if <a id="id150" class="calibre1"/>you're writing functions that perform opposite functions, the second one tends to go much faster. That's because once you have the first one out of the way, you can keep running it to reset the configuration back to the undesired value for the second one. In the case of our example, once you are able to lock an account, you can easily lock it while testing the unlock functionality.</p></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec25" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">State modules are more structured than execution modules, but that often makes them easier to write. A state's return result can be True (green), None (yellow), True with changes (blue), or False (red). State modules frequently contain pairs of functions that perform opposing functionality.</p><p class="calibre8">Now that you know how to write state modules, it's time to take a look at the data that we pass to them. Next up: renderers!</p></div></body></html>