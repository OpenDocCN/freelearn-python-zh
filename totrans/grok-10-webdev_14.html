<html><head></head><body>
  <div id="sbo-rt-content"><div class="chapter" title="Chapter 13. Testing and Debugging"><div class="titlepage"><div><div><h1 class="title"><a id="ch13"/>Chapter 13. Testing and Debugging</h1></div></div></div><p>Throughout this book, we have been discussing how Grok offers an agile way of working with Zope. However, up to this point, we have neglected to perform one activity that is considered most important in agile projects:<span class="emphasis"><em> testing</em></span>.</p><p>Grok offers some tools for testing, and in fact, a project created by<code class="literal"> grokproject</code> (as the one that we have been extending) includes a functional test suite. In this chapter, we are going to discuss testing, and will then write some tests for the functionality that our application has so far.</p><p>Testing helps us to avoid bugs, but it does not eliminate them completely, of course. There will be times when we will have to dive into the code to find out what's going wrong in it. A good set of debugging aids becomes very valuable in this situation. We'll see that there are several ways of debugging a Grok application, and will try out a couple of them.</p><p>Some of the things that we will cover includes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The need for testing</li><li class="listitem" style="list-style-type: disc">Testing in Grok</li><li class="listitem" style="list-style-type: disc">Extending the functional test suite provided by<code class="literal"> grokproject</code></li><li class="listitem" style="list-style-type: disc">Other kinds of testing</li><li class="listitem" style="list-style-type: disc">Debugging tools</li></ul></div><div class="section" title="Testing"><div class="titlepage"><div><div><h1 class="title"><a id="ch13lvl1sec01"/>Testing</h1></div></div></div><p>It's important to understand that testing should not be treated as an afterthought. It's just that in a book like this one, which focuses a lot on testing, it can be harder to follow explanations and code in the initial stages of your reading.<a id="id452" class="indexterm"/>
</p><p>As mentioned earlier, agile methodologies place a lot of emphasis on testing. In fact, there's even a methodology called <span class="strong"><strong>Test Driven Development</strong></span> (<span class="strong"><strong>TDD</strong></span>), which not only encourages writing tests for our code, but also encourages writing tests before writing a single line of code.</p><p>There are various kinds of testing, but here we'll briefly describe only two:<a id="id453" class="indexterm"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Unit testing</li><li class="listitem" style="list-style-type: disc">Integration or functional tests</li></ul></div><div class="section" title="Unit testing"><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec01"/>Unit testing</h2></div></div></div><p>The idea of unit testing is to break a program into its constituent parts and test each one of them in isolation. Every method or function call is tested separately to make sure that it returns the expected results and handles all of the possible inputs correctly.<a id="id454" class="indexterm"/>
</p><p>An application that has unit tests that cover a majority of its lines of code allows its developers to constantly run the tests after a change, and makes sure that modifications to the code do not break the existing functionality.</p></div><div class="section" title="Functional tests"><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec02"/>Functional tests</h2></div></div></div><p>Functional tests are concerned with how the application behaves as a whole. In a web application, this means, how it responds to a browser request and whether it returns the expected HTML for a given call.<a id="id455" class="indexterm"/>
</p><p>Ideally, the customer himself has a hand in defining these tests, usually through explicit functionality requirements or acceptance criteria. The more formal that the requirements from the customer are, the easier it is to define appropriate functional tests.</p></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Testing in Grok"><div class="titlepage"><div><div><h1 class="title"><a id="ch13lvl1sec02"/>Testing in Grok</h1></div></div></div><p>Grok highly encourages the use of both kinds of tests, and in fact includes a powerful testing tool that is automatically configured with every project. In the Zope world — from where Grok originated — a lot of value is placed in a kind of test known as a "doctest", so Grok comes with a sample test suite of this kind.<a id="id456" class="indexterm"/>
</p><div class="section" title="Doctests"><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec03"/>Doctests</h2></div></div></div><p>A<span class="strong"><strong> doctest</strong></span> is a test that's written as a text file, with lines of code mixed with explanations of what the code is doing. The code is written in a way that simulates a Python interpreter session. As tests exercise large portions of the code (ideally 100%), they usually offer a good way of finding out of what an application does and how. So if an application has no written documentation, its tests would be the next obvious way of finding out what it does. Doctests take this idea further, by allowing the developer to explain in the text file exactly what each test is doing.<a id="id457" class="indexterm"/>
</p><p>Doctests are especially useful for functional testing, because it makes more sense to document the high-level operations of a program. Unit tests, on the other hand, are expected to evaluate the program bit by bit, and it can be cumbersome to write a text explanation for every little piece of code.</p><p>A possible drawback of doctests is that they can make the developer think that he needs no other documentation for his project. In almost all cases, this is not true. Documenting an application or package makes it immediately more accessible and useful, so it is strongly recommended that doctests should not be used as a replacement for good documentation. We'll show an example of using doctests in the<span class="emphasis"><em> Looking at the test code</em></span> section of this chapter.<a id="id458" class="indexterm"/>
</p></div><div class="section" title="Default test setup for Grok projects"><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec04"/>Default test setup for Grok projects</h2></div></div></div><p>As mentioned earlier, Grok projects that are started with the<code class="literal"> grokproject</code> tool already include a simple functional test suite, by default. Let's examine this in detail.<a id="id459" class="indexterm"/>
</p><div class="section" title="Test configuration"><div class="titlepage"><div><div><h3 class="title"><a id="ch13lvl3sec01"/>Test configuration</h3></div></div></div><p>The default test configuration looks for packages or modules that have the word 'tests' in their name and tries to run the tests inside. For functional tests, any files ending with<code class="literal"> .txt</code> or<code class="literal"> .rst</code> are considered.<a id="id460" class="indexterm"/>
</p><p>For functional tests that need to simulate a browser, a special configuration is needed to tell Grok which packages to initialize in addition to the Grok infrastructure (these are usually the ones that are being worked on). The<code class="literal"> ftesting.zcml</code> file in the<code class="literal"> package</code> directory holds this configuration. This file also includes a couple of user definitions that are used by certain tests to examine functionality that is specific to a certain role, such as manager.</p></div><div class="section" title="Test files"><div class="titlepage"><div><div><h3 class="title"><a id="ch13lvl3sec02"/>Test files</h3></div></div></div><p>In addition to the already mentioned<code class="literal"> ftesting.zcml</code> file, in the same directory there is a<code class="literal"> tests.py</code> file added by<code class="literal"> grokproject</code>, which basically loads the ZCML declarations and registers all of the tests in the package.<a id="id461" class="indexterm"/>
</p><p>The actual tests that are included with the default project files are contained in the<code class="literal"> app.txt</code> file. These are doctests that perform a functional test run by loading the entire Grok environment and imitating a browser. We'll take a look at the contents of the file soon, but first let's run the tests.<a id="id462" class="indexterm"/>
</p></div><div class="section" title="Running the tests"><div class="titlepage"><div><div><h3 class="title"><a id="ch13lvl3sec03"/>Running the tests</h3></div></div></div><p>As a part of the project's build process, a script named<code class="literal"> test</code> is included in the<code class="literal"> bin</code> directory when you create a new project. This is the<span class="strong"><strong> test runner</strong></span>, and calling it without arguments finds and executes all of the tests in the packages that are included in the configuration.<a id="id463" class="indexterm"/>
</p><p>We haven't added a single test so far, so if we type<code class="literal"> bin/test</code> in our project directory, we'll see more or less the same thing that doing this on a new project would show:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ bin/test
Running tests at level 1
Running todo.FunctionalLayer tests:
Set up
in 12.319 seconds.
Running:
...2009-09-30 15:00:47,490 INFO sqlalchemy.engine.base.Engine.0x...782c PRAGMA table_info("users")
2009-09-30 15:00:47,490 INFO sqlalchemy.engine.base.Engine.0x...782c ()
Ran 3 tests with 0 failures and 0 errors in 0.465 seconds.
Tearing down left over layers:
Tear down todo.FunctionalLayer ... not supported
</strong></span>
</pre></div><p>The only difference between our output and that of a newly created Grok package is in the<code class="literal"> sqlalchemy</code> lines. Of course, the most important part of the output is the penultimate line, which shows the number of tests that were run and whether there were any failures or errors. A<span class="emphasis"><em> failure</em></span> means that a test didn't pass, which means that the code is not doing what it's supposed to do and needs to be checked. An<span class="emphasis"><em> error</em></span> signifies that the code crashed unexpectedly at some point, and the test couldn't even be executed, so it's necessary to find the error and correct it before worrying about the tests.</p></div></div><div class="section" title="The test runner"><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec05"/>The test runner</h2></div></div></div><p>The test runner program looks for modules that contain tests. The test can be of three different types: Python tests, simple doctests, and full-functionality doctests. To let the test runner know which test file includes which kind of tests, a comment similar to the following is placed at the top of the file:<a id="id464" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">Do a Python test on the app.
:unittestt:
</pre></div><p>In this case, the Python unit test layer will be used to run the tests. The other value that we are going to use is doctest, when we learn how to write doctests.</p><p>The test runner then finds all of the test modules and runs them in the corresponding layer. Although unit tests are considered very important in regular development, we may find functional tests more necessary for a Grok web application, as we will usually be testing views and forms, which require the full Zope/Grok stack to be loaded, in order to work. That's the reason why we find only functional doctests in the default setup.<a id="id465" class="indexterm"/>
</p><div class="section" title="Test layers"><div class="titlepage"><div><div><h3 class="title"><a id="ch13lvl3sec04"/>Test layers</h3></div></div></div><p>A<span class="strong"><strong> test layer</strong></span> is a specific test setup that is used to differentiate the tests that are executed. By default, there is a test layer for each of the three types of tests handled by the test runner. It's possible to run a test layer without running the others. It is also possible to create new test layers in order to cluster together tests that require a specific setup.<a id="id466" class="indexterm"/>
</p></div><div class="section" title="Invoking the test runner"><div class="titlepage"><div><div><h3 class="title"><a id="ch13lvl3sec05"/>Invoking the test runner</h3></div></div></div><p>As shown above, running<code class="literal"> bin/test</code> will start the test runner with the default options. It's also possible to specify a number of options, and the most important ones of these are summarized below. In the following table, command-line options are shown to the left. Most options can be expressed using a short form (one dash) or a long form (two dashes). Arguments for each option are shown in uppercase.<a id="id467" class="indexterm"/>
</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Option</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="bottom">
<p>
<code class="literal">-s PACKAGE, --package=PACKAGE, --dir=PACKAGE</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Search the given package's directories for tests. This can be specified more than once, to run tests in multiple parts of the source tree. For example, when refactoring interfaces, you don't want to see the way you have broken setups for tests in other packages. You just want to run the interface tests. Packages are supplied as dotted names. For compatibility with the old test runner, forward and backward slashes in package names are converted to dots. (In the special case of packages, which are spread over multiple directories, only directories within the test search path are searched.)</p>
</td></tr><tr><td style="text-align: left" valign="bottom">
<p>
<code class="literal">-m MODULE, --module=MODULE</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Specify a test-module filter as a regular expression. This is a case-sensitive regular expression that is used in<span class="emphasis"><em> search</em></span> (not match) mode to limit which test modules are searched for tests. The regular expressions are checked against dotted module names. In an extension of Python regexp notation, a leading "!" is stripped and causes the sense of the remaining regexp to be negated (so "!bc" matches any string that does not match "bc", and vice versa). This option can specify multiple test-module filters. Test modules matching any of the test filters are searched. If no test-module filter is specified, then all of the test modules are used.</p>
</td></tr><tr><td style="text-align: left" valign="bottom">
<p>
<code class="literal">-t TEST, --test=TEST</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Specify a test filter as a regular expression. This is a case-sensitive regular expression that is used in<span class="emphasis"><em> search</em></span> (not match) mode to limit which tests are run. In an extension of Python regexp notation, a leading "!" is stripped and causes the sense of the remaining regexp to be negated (so "!bc" matches any string that does not match "bc", and vice versa). This option can specify multiple test filters. Tests matching any of the test filters are included. If no test filter is specified, then all of the tests are executed.</p>
</td></tr><tr><td style="text-align: left" valign="bottom">
<p>
<code class="literal">--layer=LAYER</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Specify a test layer to run. This option can be provided multiple times in order to specify more than one layer. If not specified, all of the layers are executed. It is common for the running script to provide default values for this option. Layers are specified regular expressions that are used in search mode, for dotted names of objects that define a layer. In an extension of Python regexp notation, a leading "!" is stripped and causes the sense of the remaining regexp to be negated (so "!bc" matches any string that does not match "bc", and vice versa). The layer named 'unit' is reserved for unit tests; however, take note of the<span class="emphasis"><em> unit</em></span> and<span class="emphasis"><em> non-unit</em></span> options.</p>
</td></tr><tr><td style="text-align: left" valign="bottom">
<p>
<code class="literal">-u, --unit</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Executes only unit tests, ignoring any layer options.</p>
</td></tr><tr><td style="text-align: left" valign="bottom">
<p>
<code class="literal">-f, --non-unit</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Executes tests other than unit tests.</p>
</td></tr><tr><td style="text-align: left" valign="bottom">
<p>
<code class="literal">-v, --verbose</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Makes the output more verbose.</p>
</td></tr><tr><td style="text-align: left" valign="bottom">
<p>
<code class="literal">-q, --quiet</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Provides minimal output, by overriding any verbosity options.</p>
</td></tr></tbody></table></div></div></div><div class="section" title="Looking at the test code"><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec06"/>Looking at the test code</h2></div></div></div><p>Let's take a look at the three default test files of a Grok project, to see what each one does.<a id="id468" class="indexterm"/>
</p><div class="section" title="ftesting.zcml"><div class="titlepage"><div><div><h3 class="title"><a id="ch13lvl3sec06"/>ftesting.zcml</h3></div></div></div><p>As we explained earlier,<code class="literal"> ftesting.zcml</code> is a configuration file for the test runner. Its main objective is to help us set up the test instance with users, so that we can test different roles according to our needs.<a id="id469" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">&lt;configure

i18n_domain="todo"
package="todo"
&gt;
&lt;include package="todo" /&gt;
&lt;include package="todo_plus" /&gt;
&lt;!-- Typical functional testing security setup --&gt;
&lt;securityPolicy
component="zope.securitypolicy.zopepolicy.ZopeSecurityPolicy"
/&gt;
&lt;unauthenticatedPrincipal
id="zope.anybody"
title="Unauthenticated User"
/&gt;
&lt;grant
permission="zope.View"
principal="zope.anybody"
/&gt;
&lt;principal
id="zope.mgr"
title="Manager"
login="mgr"
password="mgrpw"
/&gt;
&lt;role id="zope.Manager" title="Site Manager" /&gt;
&lt;grantAll role="zope.Manager" /&gt;
&lt;grant role="zope.Manager" principal="zope.mgr" /&gt;
</pre></div><p>As shown in the preceding code, the configuration simply includes a security policy, complete with users and roles, and the packages that should be loaded by the instance, in addition to the regular Grok infrastructure. If we run any tests that require an authenticated user to work, we'll use these special users.</p><p>The includes at the top of the file make sure that the entire Zope Component Architecture setup needed by our application is performed prior to running the tests.<a id="id470" class="indexterm"/>
</p></div><div class="section" title="tests.py"><div class="titlepage"><div><div><h3 class="title"><a id="ch13lvl3sec07"/>tests.py</h3></div></div></div><p>The default test module is very simple. It defines the functional layer and registers the tests for our package:<a id="id471" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">import os.path
import z3c.testsetup
import todo
from zope.app.testing.functional import ZCMLLayer
ftesting_zcml = os.path.join(
os.path.dirname(todo.__file__), 'ftesting.zcml')
FunctionalLayer = ZCMLLayer(ftesting_zcml, __name__, 'FunctionalLayer', allow_teardown=True)
test_suite = z3c.testsetup.register_all_tests('todo')
</pre></div><p>After the imports, the first line gets the path for the<code class="literal"> ftesting.zcml</code> file, which is then passed to the layer definition method<code class="literal"> ZCMLLayer</code>. The final line in the module tells the test runner to find and register all of the tests in the package.</p><p>This will be enough for our testing needs in this chapter, but if we needed to create another non-Grok package for our application, we would need to add a line like the last one to it, so that all of its tests are found by the test runner. This is pretty much boilerplate code, as only the package name has to be changed.<a id="id472" class="indexterm"/>
</p></div><div class="section" title="app.txt"><div class="titlepage"><div><div><h3 class="title"><a id="ch13lvl3sec08"/>app.txt</h3></div></div></div><p>We finally come to the reason for this entire configuration the actual tests that will be executed by the test runner. By default, the tests are included inside the<code class="literal"> app.txt</code> file:<a id="id473" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">Do a functional doctest test on the app.
========================================
:doctest:
:layer: todo.tests.FunctionalLayer
Let's first create an instance of Todo at the top level:
&gt;&gt;&gt; from todo.app import Todo
&gt;&gt;&gt; root = getRootFolder()
&gt;&gt;&gt; root['app'] = Todo()
Run tests in the testbrowser
----------------------------
The zope.testbrowser.browser module exposes a Browser class that
simulates a web browser similar to Mozilla Firefox or IE. We use that to test how our application behaves in a browser. For more
information, see http://pypi.python.org/pypi/zope.testbrowser.
Create a browser and visit the instance you just created:
&gt;&gt;&gt; from zope.testbrowser.testing import Browser
&gt;&gt;&gt; browser = Browser()
&gt;&gt;&gt; browser.open('http://localhost/app')
Check some basic information about the page you visit:
&gt;&gt;&gt; browser.url
'http://localhost/app/@@login?camefrom=%2Fapp%2F%40%40index'
&gt;&gt;&gt; browser.headers.get('Status').upper()
'200 OK'
</pre></div><p>The text file has a title, and immediately after that a<code class="literal"> :doctest:</code> declaration a declaration that tells the test runner that these tests need a functional layer to be loaded for their execution. Then comes a<code class="literal"> :layer:</code> declaration, which is a path that points to the layer that we defined earlier in<code class="literal"> tests.py</code>. After that comes the test code. Lines starting with three brackets represent the Python code that is tested. Anything else is commentary.<a id="id474" class="indexterm"/>
</p><p>When using the Python interpreter, a line of code may return a value, in which case the expected return value must be written immediately below that line. This expected value will be compared with the real return value of the tested code, and a failure will be reported if the values don't match. Similarly, a line that is followed by an empty line will produce a failure when the code is executed and a result is returned, because it is assumed that the expected return value in that case is<code class="literal"> None</code>.</p><p>For example, in the last line of the Python doctest below the expression<code class="literal"> browser.headers.get('Status').upper()</code> is expected to return the value<code class="literal"> 200 OK</code>. If anything else at all is returned, the test will fail.</p></div></div><div class="section" title="Adding our own tests"><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec07"/>Adding our own tests</h2></div></div></div><p>Now, let's add a few functional tests that are specific to our application. We will need to emulate a browser for that. The<code class="literal"> zope.testbrowser</code> package includes a browser emulator. We can pass any valid URL to this browser by using<code class="literal"> browser.open</code>, and it will send a request to our application exactly like a browser would. The response from our application will be then available as<code class="literal"> browser.contents</code>, so that we can perform our testing comparisons on it.<a id="id475" class="indexterm"/>
</p><div class="section" title="The Browser class"><div class="titlepage"><div><div><h3 class="title"><a id="ch13lvl3sec09"/>The Browser class</h3></div></div></div><p>Before writing our tests, it will be useful to see what exactly our<code class="literal"> testbrowser</code> can do. Of course, anything that depends on JavaScript will not work here, but other than that, we can interact with links and even forms in a very straightforward manner. Here's a look at the main functionality offered by the<code class="literal"> Browser</code> class:<a id="id476" class="indexterm"/>
</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p>Initialization</p>
</td><td style="text-align: left" valign="top">
<p>&gt;&gt;&gt; from zope.testbrowser.testing import Browser</p>
<p>&gt;&gt;&gt; browser = Browser()</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Page contents</p>
</td><td style="text-align: left" valign="top">
<p>&gt;&gt;&gt; print browser.contents</p>
<p>&lt;html&gt;</p>
<p>&lt;head&gt;</p>
<p>&lt;title&gt;Simple Page&lt;/title&gt;</p>
<p>&lt;/head&gt;</p>
<p>&lt;body&gt;</p>
<p>&lt;h1&gt;Simple Page&lt;/h1&gt;</p>
<p>&lt;/body&gt;</p>
<p>&lt;/html&gt;</p>
<p>&gt;&gt;&gt; '&lt;h1&gt;Simple Page&lt;/h1&gt;' in browser.contents</p>
<p>True</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Headers</p>
</td><td style="text-align: left" valign="top">
<p>&gt;&gt;&gt; print browser.headers</p>
<p>Status: 200 OK</p>
<p>Content-Length: 123</p>
<p>Content-Type: text/html;charset=utf-8</p>
<p>X-Powered-By: Zope (www.zope.org), Python (www.python.org)</p>
<p>&gt;&gt;&gt; browser.headers['content-type']</p>
<p>'text/html;charset=utf-8'</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Cookies</p>
</td><td style="text-align: left" valign="top">
<p>&gt;&gt;&gt; browser.cookies['foo']</p>
<p>'bar'</p>
<p>&gt;&gt;&gt; browser.cookies.keys()</p>
<p>['foo']</p>
<p>&gt;&gt;&gt; browser.cookies.values()</p>
<p>['bar']</p>
<p>&gt;&gt;&gt; browser.cookies.items()</p>
<p>[('foo', 'bar')]</p>
<p>&gt;&gt;&gt; 'foo' in browser.cookies</p>
<p>True</p>
<p>&gt;&gt;&gt; browser.cookies['sha'] = 'zam'</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Links</p>
</td><td style="text-align: left" valign="top">
<p>&gt;&gt;&gt; link = browser.getLink('Link Text')</p>
<p>&gt;&gt;&gt; link</p>
<p>&lt;Link text='Link Text'</p>
<p>url='http://localhost/@@/testbrowser/navigate.html?message=By+Link+Text'&gt;</p>
<p>&gt;&gt;&gt; link.text</p>
<p>'Link Text'</p>
<p>&gt;&gt;&gt; link.tag # links can also be image maps.</p>
<p>'a'</p>
<p>&gt;&gt;&gt; link.url # it's normalized</p>
<p>'http://localhost/@@/testbrowser/navigate.html?message=By+Link+Text'</p>
<p>&gt;&gt;&gt; link.attrs</p>
<p>{'href': 'navigate.html?message=By+Link+Text'}</p>
<p>&gt;&gt;&gt; link.click()</p>
<p>&gt;&gt;&gt; browser.url</p>
<p>'http://localhost/@@/testbrowser/navigate.html?message=By+Link+Text'</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Form controls</p>
</td><td style="text-align: left" valign="top">
<p>&gt;&gt;&gt; control = browser.getControl('Text Control')</p>
<p>&gt;&gt;&gt; control</p>
<p>&lt;Control name='text-value' type='text'&gt;</p>
<p>&gt;&gt;&gt; browser.getControl(label='Text Control') # equivalent</p>
<p>&lt;Control name='text-value' type='text'&gt;</p>
<p>&gt;&gt;&gt; browser.getControl('Text Control').value = 'Other Text'</p>
<p>&gt;&gt;&gt; browser.getControl('Submit').click()</p>
</td></tr></tbody></table></div><p>Now that we know what we can do, let's try our hand at writing some tests.<a id="id477" class="indexterm"/>
</p></div><div class="section" title="Our first to-do application tests"><div class="titlepage"><div><div><h3 class="title"><a id="ch13lvl3sec10"/>Our first to-do application tests</h3></div></div></div><p>Ideally, we should have been adding a couple of doctests to the<code class="literal"> app.txt</code> file every time we added a new functionality to our application. We have gone through the reasons why we didn't do so, but let's recover some lost ground. At the very least, we'll get a feeling of how doctests work.<a id="id478" class="indexterm"/>
</p><p>We'll add our new tests to the existing<code class="literal"> app.txt</code> file. The last test that we saw left us at the to-do instance URL. We are not logged in, so if we print the browser contents, we will get the login page. Let's add a test for this:</p><div class="informalexample"><pre class="programlisting">Since we haven't logged in, we can't see the application. The login page appears:
&gt;&gt;&gt; 'Username' in browser.contents
True
&gt;&gt;&gt; 'Password' in browser.contents
True
</pre></div><p>As we mentioned earlier, when visiting a URL with the<code class="literal"> testbrowser</code>, the entire HTML content of the page is stored in<code class="literal"> browser.contents</code>. Now we know that our login page has a username field and a password field, so we simply use a couple of<code class="literal"> in</code> expressions and check if these fields evaluate to<code class="literal"> True</code>. If they do, it would mean that the browser is effectively looking at the login page.</p><p>Let's add a test for logging in. When we start the application in the tests, the user database is empty, therefore, the most economical way of logging in is to use basic authentication. This can be easily done by changing the request headers:</p><p>Let's log in with the manager user defined in<code class="literal"> ftesting.zcml</code>. To keep things simple, let's use the basic authentication headers to get in:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; browser.addHeader('Authorization', 'Basic mgr:mgrpw')
&gt;&gt;&gt; browser.open('http://localhost/app')
&gt;&gt;&gt; 'Logged in as Manager' in browser.contents
True
</pre></div><p>That's it. We just add the header, "reload" the home page, and we should be logged in. We verify it by looking for the<span class="strong"><strong> Logged in as</strong></span> message, which we know has to be there after a successful login.<a id="id479" class="indexterm"/>
</p><p>Once we are logged in, we can finally test our application properly. Let's begin by adding a project:</p><p>We are now in. Let's create a project:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; browser.getLink('Create a new project').click()
&gt;&gt;&gt; browser.getControl(name='form.title').value='a project'
&gt;&gt;&gt; browser.getControl(name='form.description').value='The description.'
&gt;&gt;&gt; browser.getControl('Add project').click()
&gt;&gt;&gt; browser.url
'http://localhost/app/0'
&gt;&gt;&gt; 'Create new list' in browser.contents
True
</pre></div><p>First, we find the link on the home page that will take us to the 'add form' project. This is done easily with the help of the<code class="literal"> getLink</code> method and the text of the link. We click on the link and then should have the form ready to fill in. We then use<code class="literal"> getControl</code> to find each field by its name, and change its value. Finally, we submit the form by getting the submit button control and clicking on it. The result is that the project is created and we are redirected to its main view. We can confirm this by comparing the<code class="literal"> browser url</code> with the URL that we would expect in this case.</p><p>Adding a list to the project is just as easy. We get the form controls, assign them some values, and click on the submit button. The list and the link for adding new items to it should appear in the browser contents:</p><p>We have added a project. Now, we'll add a list to it. If we are successful, we will see a link for adding a new item for the list:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; browser.getControl(name='title').value='a list'
&gt;&gt;&gt; browser.getControl(name='description').value='The list description.'
&gt;&gt;&gt; browser.getControl(name='new_list').click()
&gt;&gt;&gt; 'New item' in browser.contents
True
</pre></div><p>Good. Let's see how we are doing so far:<a id="id480" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ bin/testRunning tests at level 1
Running todo.FunctionalLayer tests:
Set up
in 3.087 seconds.
Running:
.......2009-09-30 21:35:44,585 INFO sqlalchemy.engine.base.Engine.0x...69ec PRAGMA table_info("users")
2009-09-30 21:35:44,585 INFO sqlalchemy.engine.base.Engine.0x...69ec ()
Ran 7 tests with 0 failures and 0 errors in 0.428 seconds.
Tearing down left over layers:
Tear down todo.FunctionalLayer ... not supported
</strong></span>
</pre></div><p>Not bad. We now have four more working tests than when we started.</p><p>Note that the test browser handles<code class="literal"> HTTP</code> errors gracefully, returning a string similar to what a real browser would return when running into an error. For example, take a look at the following test:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; browser.open('http://localhost/invalid')
Traceback (most recent call last):
...
HTTPError: HTTP Error 404: Not Found
</pre></div><p>That's the default behavior because this is how real browsers work, but sometimes, when we are debugging, it's better to take a look at the original exception caused by our application. In such a case, we can make the browser stop handling errors automatically and throw the original exceptions, so that we can handle them. This is done by setting the<code class="literal"> browser.handleErrors</code> property to<code class="literal"> False:</code>
</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; browser.handleErrors = False
&gt;&gt;&gt; browser.open('http://localhost/invalid')
Traceback (most recent call last):
...
NotFound: Object: &lt;zope.site.folder.Folder object at ...&gt;,
name: u'invalid'
</pre></div></div><div class="section" title="Adding unit tests"><div class="titlepage"><div><div><h3 class="title"><a id="ch13lvl3sec11"/>Adding unit tests</h3></div></div></div><p>Apart from functional tests, we can also create pure Python test cases that the test runner can find. Whereas functional tests cover application behavior, unit tests focus on program correctness. Ideally, every single Python method in the application should be tested.<a id="id481" class="indexterm"/>
</p><p>The unit test layer does not load the Grok infrastructure, so tests should not take anything that comes with it for granted just the basic Python behavior.</p><p>To add our unit tests, we'll create a module named<code class="literal"> unit_tests.py</code>. Remember, in order for the test runner to find our test modules, their names have to end with 'tests'. Here's what we will put in this file:</p><div class="informalexample"><pre class="programlisting">"""
Do a Python test on the app.
:unittest:
"""
import unittest
from todo.app import Todo
class InitializationTest(unittest.TestCase):
todoapp = None
def setUp(self):
self.todoapp = Todo()
def test_title_set(self):
self.assertEqual(self.todoapp.title,u'To-do list manager')
def test_next_id_set(self):
self.assertEqual(self.todoapp.next_id,0)
</pre></div><p>The<code class="literal"> :unittest:</code> comment at the top, is very important. Without it, the test runner will not know in which layer your tests should be executed, and will simply ignore them.</p><p>Unit tests are composed of test cases, and, in theory, each should contain several tests related to a specific area of the application's functionality. The test cases use the<code class="literal"> TestCase</code> class from the Python<code class="literal"> unittest</code> module. In these tests, we define a single test case that contains two very simple tests.</p><p>We are not getting into the details here. Just notice that the test case can include a<code class="literal"> setUp</code> method and a<code class="literal"> tearDown</code> method that can be used to perform any common initialization and destruction tasks that are required in order to get the tests working and finishing cleanly.</p><p>Every test inside a test case needs to have the prefix 'test' in its name, so we have exactly two tests that fulfill this condition. Both of the tests need an instance of the<code class="literal"> Todo</code> class to be executed, so we assign it to the test case as a class variable, and create it inside the<code class="literal"> setUp</code> method. The tests are very simple and they just verify that the default property values are set upon instance creation.<a id="id482" class="indexterm"/>
</p><p>Both of the tests use the<code class="literal"> assertEqual</code> method to tell the test runner that if the two values passed are different, the test should fail. To see them in action, we just run the<code class="literal"> bin/test</code> command once more:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ bin/test
Running tests at level 1
Running todo.FunctionalLayer tests:
Set up
in 2.691 seconds.
Running:
.......2009-09-30 22:00:50,703 INFO sqlalchemy.engine.base.Engine.0x...684c PRAGMA table_info("users")
2009-09-30 22:00:50,703 INFO sqlalchemy.engine.base.Engine.0x...684c ()
Ran 7 tests with 0 failures and 0 errors in 0.420 seconds.
Running zope.testing.testrunner.layer.UnitTests tests:
Tear down todo.FunctionalLayer ... not supported
Running in a subprocess.
Set up zope.testing.testrunner.layer.UnitTests in 0.000 seconds.
Ran 2 tests with 0 failures and 0 errors in 0.000 seconds.
Tear down zope.testing.testrunner.layer.UnitTests in 0.000 seconds.
Total: 9 tests, 0 failures, 0 errors in 5.795 seconds
</strong></span>
</pre></div><p>Now, both the functional and unit test layers contain some tests, and they are both run, one after the other. We can see the subtotal for each layer at the end of these tests for that layer, as well as the grand total of the nine passed tests, when the test runner finishes its work.</p></div><div class="section" title="Extending the test suite"><div class="titlepage"><div><div><h3 class="title"><a id="ch13lvl3sec12"/>Extending the test suite</h3></div></div></div><p>Of course, we have only scratched the surface of which tests should be added to our application. If we continue to add tests, we may have hundreds of tests, by the time we finish. However, this chapter is not the place to do this.<a id="id483" class="indexterm"/>
</p><p>As mentioned earlier, it is much easier to have tests for each part of our application, if we add them as we code. There's no hiding from the fact that testing is a lot of work, but there is great value in having a complete test suite for our applications. This is even more so when third parties might use our product independently.</p></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Debugging"><div class="titlepage"><div><div><h1 class="title"><a id="ch13lvl1sec03"/>Debugging</h1></div></div></div><p>We will now take a quick look at the debugging facilities offered by Grok. Even if we have a very thorough test suite, the chances are there that we will find a fair number of bugs in our application. When that happens, we need a quick and effective way to inspect the code as it runs and easily find the problem spots.</p><p>Often, developers will use<code class="literal"> print</code> statements (placed at key lines) throughout the code, in the hopes of finding the problem spot. Although this is usually a good way to begin locating sore spots in the code, we often need some way to follow the code line by line in order to really find out what's wrong. In the next section, we'll see how to use the Python debugger to step through the code and find the problem spots. We'll also take a quick look at how to perform post-mortem debugging in Grok, which involves jumping into the debugger to analyze the program state immediately after an exception has occurred.</p><div class="section" title="Debugging in Grok"><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec08"/>Debugging in Grok</h2></div></div></div><p>For regular debugging, where we need to step through the code to see what's going on inside it, the Python debugger is an excellent tool. To use it, you just have to add the next line at the point where you wish to start debugging:<a id="id484" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">import pdb; pdb.set_trace()
</pre></div><p>Let's try it out. Open the<code class="literal"> app.py</code> module and change the<code class="literal"> add</code> method of the<code class="literal"> AddProjectForm</code> class (line 108) to look like this:</p><div class="informalexample"><pre class="programlisting">@grok.action('Add project')
def add(self,**data):
import pdb; pdb.set_trace()
project = Project()
project.creator = self.request.principal.title
project.creation_date = datetime.datetime.now()
project.modification_date = datetime.datetime.now()
self.applyData(project,**data)
id = str(self.context.next_id)
self.context.next_id = self.context.next_id+1
self.context[id] = project
return self.redirect(self.url(self.context[id]))
</pre></div><p>Notice that we invoke the debugger at the beginning of the method. Now, start the instance, go to the 'add project' form, fill it in, and submit it. Instead of seeing the new project view, the browser will stay at the 'add form' page, and display the<span class="strong"><strong> waiting for..</strong></span>. message. This is because control has been transferred to the console in order for the debugger to act. Your console will look like this:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; /home/cguardia/work/virtual/grok1/todo/src/todo/app.py(109)add()
-&gt; project = Project()
(Pdb) |
</strong></span>
</pre></div><p>The debugger is now active and waiting for input. Notice that the line number where debugging started appears right beside the path of the module in which we are located. After the line number, comes the name of the method,<code class="literal"> add()</code>. Below that, the next line of code to be executed is shown.</p><p>The debugger commands are simple. To execute the current line, click on<span class="emphasis"><em> n:</em></span>
<a id="id485" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>(Pdb) n
&gt; /home/cguardia/work/virtual/grok1/todo/src/todo/app.py(110)add()
-&gt; project.creator = self.request.principal.title
(Pdb)
</strong></span>
</pre></div><p>You can see the available commands if you type<span class="emphasis"><em> h:</em></span>
</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>(Pdb) h
Documented commands (type help &lt;topic&gt;):
========================================
EOF break condition disable help list q step w
a bt cont down ignore n quit tbreak whatis
alias c continue enable j next r u where
args cl d exit jump p return unalias
b clear debug h l pp s up
Miscellaneous help topics:
==========================
exec pdb
Undocumented commands:
======================
retval rv
(Pdb)
</strong></span>
</pre></div><p>The list command<code class="literal"> id</code> is used for getting a bird's eye view of where in the code we are:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>(Pdb) list
105
106 @grok.action('Add project')
107 def add(self,**data):
108 import pdb; pdb.set_trace()
109 project = Project()
110 -&gt; project.creator = self.request.principal.title
111 project.creation_date = datetime.datetime.now()
112 project.modification_date = datetime.datetime.now()
113 self.applyData(project,**data)
114 id = str(self.context.next_id)
115 self.context.next_id = self.context.next_id+1
(Pdb)
</strong></span>
</pre></div><p>As you can see, the current line is identified by an arrow.</p><p>It's possible to type in the names of objects within the current execution context and find out their values:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>(Pdb) project
&lt;todo.app.Project object at 0xa0ef72c&gt;
(Pdb) data
{'kind': 'personal', 'description': u'Nothing', 'title': u'Project about nothing'}
(Pdb)
</strong></span>
</pre></div><p>We can, of course, continue stepping line-by-line through all of the code in the application, including Grok's own code, checking values as we proceed. When we are through reviewing, we can click on<span class="emphasis"><em> c</em></span> to return control to the browser. At this point, we will see the project view.<a id="id486" class="indexterm"/>
</p><p>The Python debugger is very easy to use, and it can be invaluable for finding obscure bugs in your code.</p><div class="section" title="The default Ajax debugger"><div class="titlepage"><div><div><h3 class="title"><a id="ch13lvl3sec13"/>The default Ajax debugger</h3></div></div></div><p>The other kind of debugging is known as<span class="emphasis"><em> post-mortem debugging</em></span>. In the previous section, we stepped through the code at leisure while the application was in a stable and running condition. Many times, however, we can run into an error condition that stops the program and we need to analyze what the state of the program was at the time at which the error occurred. That's what post-mortem debugging is about.<a id="id487" class="indexterm"/>
</p><p>We'll now intentionally introduce an error in our code. Remove the<code class="literal"> import pdb</code> line from the<code class="literal"> add</code> method, and change the first line after that to the following:</p><div class="informalexample"><pre class="programlisting">project = Project(**data)
</pre></div><p>The<code class="literal"> Project</code> class'<code class="literal"> __init__</code> method does not expect this argument, so a<code class="literal"> TypeError</code> will be raised. Restart the instance and add a project. Instead of a view, a blank screen with the error message<span class="strong"><strong> A system error occurred</strong></span> will be shown.</p><p>Recall that, so far, we have been using the<code class="literal"> deploy.ini</code> file to start the instance, by using the following command:<a id="id488" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ bin/paster serve parts/etc/deploy.ini
</strong></span>
</pre></div><p>To run a post-mortem debugger session, we have to start our instance with the debug profile instead:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ bin/paster serve parts/etc/debug.ini
</strong></span>
</pre></div><p>Try to add a project again. Now, instead of the simple error message, a full traceback of the error will be shown on screen, as shown in the following screenshot:</p><div class="mediaobject"><img src="images/7481_13_01.jpg" alt="The default Ajax debugger"/></div><p>One nice thing about the traceback is that it is expandable. Clicking on the brackets to the left will show the lines of code around the line where the error occurred, while clicking on the plus sign to the right of a module and line message will show additional traceback information. Above this information you will also see a text box that can be used to evaluate expressions within the current context (refer to the next screenshot).<a id="id489" class="indexterm"/>
</p><div class="mediaobject"><img src="images/7481_13_02.jpg" alt="The default Ajax debugger"/></div></div><div class="section" title="Post-mortem debugging with the Python debugger"><div class="titlepage"><div><div><h3 class="title"><a id="ch13lvl3sec14"/>Post-mortem debugging with the Python debugger</h3></div></div></div><p>The Ajax debugger is great, but if you are really used to the Python debugger, you might wish to use that instead for your post-mortem analysis. This is no problem; Grok comes prepared for this.<a id="id490" class="indexterm"/>
</p><p>For a quick test, edit the<code class="literal"> parts/etc/debug.ini</code> file in the project and change the word<code class="literal"> ajax</code> to<code class="literal"> pdb</code> in the<code class="literal"> [filter-app:main]</code> section. It should look like this when you are done:</p><div class="informalexample"><pre class="programlisting">[filter-app:main]
# Change the last part from 'ajax' to 'pdb' for a post-mortem debugger
# on the console:
use = egg:z3c.evalexception#pdb # &lt;--- change here to pdb
next = zope
</pre></div><p>Now, restart the instance with the debug profile and try to add a project. Instead of seeing the Ajax screen, control will be transferred to the Python debugger on the console.</p><p>Keep in mind that we just modified a file that will be rewritten when we run the<code class="literal"> buildout</code> again, so do this only for quick tests, as we just did, and never depend upon changes to the files in the<code class="literal"> parts/etc</code> directory. In order to make this change permanent, remember to edit the<code class="literal"> etc/debug.ini.in</code> file instead of the one in the<code class="literal"> parts/etc</code> directory. You will then need to run the<code class="literal"> buildout</code> again.<a id="id491" class="indexterm"/>
</p></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch13lvl1sec04"/>Summary</h1></div></div></div><p>This chapter discussed how to test Grok applications and why it's important to do so. We also covered debugging, and looked at some useful debugging tools for the Grok developer. Now that we have added tests, in the following chapter, we'll see how to deploy our application.</p></div></div>
</body></html>