- en: '*Chapter 23*: Other Structural Patterns'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第23章*：其他结构模式'
- en: 'Besides the patterns we covered in the previous chapters, there are other structural
    patterns we can cover: **flyweight**, **model-view-controller** (**MVC**), and
    **proxy**. These patterns are different from those discussed in previous chapters.
    The flyweight pattern is an optimization design pattern that''s suitable for memory
    usage minimization. The MVC pattern, on the other hand, is popular in object-orient
    programming and is designed to separate different parts of a larger application.
    Finally, the proxy pattern is used to maintain actions that are taken on important
    objects.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们在前几章中介绍的模式之外，我们还可以介绍其他一些结构模式：**享元模式**、**模型-视图-控制器模式（MVC**）和**代理模式**。这些模式与前面章节中讨论的模式不同。享元模式是一种适用于最小化内存使用的优化设计模式。另一方面，MVC模式在面向对象编程中很受欢迎，旨在分离大型应用程序的不同部分。最后，代理模式用于维护对重要对象执行的操作。
- en: These three patterns will complete our discussion on structural patterns.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个模式将完成我们对结构模式的讨论。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下主题：
- en: Implementing the flyweight pattern
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现享元模式
- en: Implementing the model-view-controller pattern
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现模型-视图-控制器模式
- en: Applying the proxy pattern
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用代理模式
- en: By the end of this chapter, we will have gained an overall understanding of
    various structural patterns and the use cases of each.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们将对各种结构模式及其用例有一个全面的了解。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code files for this chapter can be found at [https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter23](https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter23).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在[https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter23](https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter23)找到。
- en: Implementing the flyweight pattern
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现享元模式
- en: '*What is the flyweight pattern?* Object-oriented systems can face performance
    issues due to the overhead of object creation. Performance issues usually appear
    in embedded systems with limited resources, such as smartphones and tablets. They
    can also appear in large and complex systems where we need to create a very large
    number of objects (and possibly users) that need to coexist at the same time.
    The **flyweight** pattern teaches programmers how to minimize memory usage by
    sharing resources with similar objects as much as possible.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*什么是享元模式？* 面向对象系统可能会因为对象创建的开销而面临性能问题。性能问题通常出现在资源有限的嵌入式系统中，例如智能手机和平板电脑。它们也可能出现在需要创建大量对象（以及可能用户）的大型和复杂系统中，这些对象需要同时共存。享元模式教导程序员如何通过尽可能多地共享相似对象来最小化内存使用。'
- en: Whenever we create a new object, extra memory needs to be allocated. Although
    virtual memory provides us, theoretically, with unlimited memory, the reality
    is different. If all the physical memory of a system gets exhausted, it will start
    swapping pages with the secondary storage – usually a **hard disk drive** (**HDD**)
    – which, in most cases, is unacceptable due to the performance differences between
    the main memory and the HDD. **Solid-state drives** (**SSDs**) generally have
    better performance than HDDs, but not everybody is expected to use SSDs. So, SSDs
    are not going to completely replace HDDs anytime soon.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们创建一个新的对象时，都需要分配额外的内存。虽然虚拟内存从理论上为我们提供了无限的内存，但现实情况却不同。如果一个系统的所有物理内存都用完了，它将开始与二级存储（通常是一个**硬盘驱动器（HDD**））交换页面，这在大多数情况下是不可接受的，因为主内存和HDD之间的性能差异很大。**固态硬盘（SSD**）通常比HDD有更好的性能，但并不是每个人都期望使用SSD。因此，SSD不太可能在不久的将来完全取代HDD。
- en: Apart from memory usage, performance is also a consideration. Graphics software,
    including computer games, should be able to render 3D information (for example,
    a forest with thousands of trees, a village full of soldiers, or an urban area
    with a lot of cars) extremely quickly. If each object in a 3D terrain is created
    individually and no data sharing is used, the performance will be prohibitive.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 除了内存使用之外，性能也是一个考虑因素。图形软件，包括计算机游戏，应该能够非常快速地渲染3D信息（例如，有成千上万树木的森林，满是士兵的村庄，或者有很多汽车的城区）。如果3D地形中的每个对象都是单独创建的，并且没有使用数据共享，性能将是不可接受的。
- en: As software engineers, we should solve software problems by writing better software,
    instead of forcing the customer to buy extra or better hardware. The flyweight
    design pattern is a technique that's used to minimize memory usage and improve
    performance by introducing data sharing between similar objects ([http://j.mp/wflyw](http://j.mp/wflyw)).
    A flyweight is a shared object that contains state-independent, immutable (also
    known as **intrinsic**) data. The state-dependent, mutable (also known as **extrinsic**)
    data should not be part of the flyweight pattern because this information cannot
    be shared since it differs per object. If the flyweight pattern needs extrinsic
    data, it should be provided explicitly by the client code.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 作为软件工程师，我们应该通过编写更好的软件来解决软件问题，而不是强迫客户购买额外的或更好的硬件。享元设计模式是一种技术，通过在相似对象之间引入数据共享来最小化内存使用并提高性能（[http://j.mp/wflyw](http://j.mp/wflyw)）。享元是一个包含状态无关、不可变（也称为**内在的**）数据的共享对象。状态相关、可变（也称为**外在的**）数据不应成为享元模式的一部分，因为这种信息不能共享，因为它在每个对象中都是不同的。如果享元模式需要外在数据，它应该由客户端代码明确提供。
- en: An example may help clarify how the flyweight pattern can be used practically.
    Let's assume that we are creating a performance-critical game, such as a **first-person
    shooter** (**FPS**). In FPS games, the players (soldiers) share some states, such
    as representation and behavior. In *Counter-Strike*, for instance, all the soldiers
    on the same team (counter-terrorists versus terrorists) look the same (representation).
    In the same game, all the soldiers (on both teams) have some common actions, such
    as *jump*, *duck*, and so forth (behavior). This means that we can create a flyweight
    that will contain all of the common data. Of course, the soldiers also have a
    lot of data that is different per soldier and will not be a part of the flyweight,
    such as weapons, health, and location.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子可以帮助阐明如何实际使用享元模式。假设我们正在创建一个性能关键的游戏，例如一款**第一人称射击游戏**（**FPS**）。在FPS游戏中，玩家（士兵）共享一些状态，例如表示和行为。例如，在《反恐精英》中，同一队的所有士兵（反恐分子与恐怖分子）看起来都一样（表示）。在同一个游戏中，所有士兵（两队）都有一些共同的动作，如**跳跃**、**蹲下**等等（行为）。这意味着我们可以创建一个享元来包含所有这些共同的数据。当然，士兵们也有许多不同的数据，这些数据对于每个士兵来说是独特的，并且不会成为享元的一部分，例如武器、健康和位置。
- en: '*What are other real-world examples of the flyweight pattern?* We will discuss
    them in the next section.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*享元模式的其他现实世界示例有哪些？* 我们将在下一节中讨论。'
- en: Real-world examples
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 现实世界示例
- en: 'Flyweight is an optimization design pattern. Therefore, it is not easy to find
    a good non-computing example of it. We can think of flyweight as caching in real
    life. For example, many bookstores have dedicated shelves containing the newest
    and most popular publications. This is a cache: first, you can look at the dedicated
    shelves for the book you are looking for, and if you cannot find it, you can ask
    the bookseller to assist you.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 享元是一种优化设计模式。因此，很难找到一个好的非计算示例。我们可以将享元视为现实生活中的缓存。例如，许多书店都有专门的货架，存放最新和最受欢迎的出版物。这是一个缓存：首先，你可以查看专门的货架寻找你想要的书籍，如果你找不到，你可以请书店老板协助你。
- en: The *Exaile* music player uses flyweight to reuse objects (in this case, music
    tracks) that are identified by the same URL. There's no point in creating a new
    object if it has the same URL as an existing object, so the same object is reused
    to save resources.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*Exaile*音乐播放器使用享元来重用具有相同URL标识的对象（在这种情况下，是音乐曲目）。如果它与现有对象具有相同的URL，就没有必要创建新的对象，因此可以重用相同的对象以节省资源。'
- en: '*Peppy*, an XEmacs-like editor that''s implemented in Python, uses the flyweight
    pattern to store the state of a major mode status bar. That''s because, unless
    they''re modified by the user, all the status bars share the same properties.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*Peppy*，一个类似于XEmacs的Python实现编辑器，使用享元模式来存储主要模式状态栏的状态。这是因为，除非用户修改它们，否则所有状态栏都共享相同的属性。'
- en: Use cases
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用例
- en: Flyweight is all about improving performance and memory usage. All embedded
    systems (phones, tablets, games consoles, microcontrollers, and so forth) and
    performance-critical applications (games, 3D graphics processing, real-time systems,
    and so forth) can benefit from it.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 享元完全是关于提高性能和内存使用。所有嵌入式系统（手机、平板电脑、游戏机、微控制器等等）和性能关键的应用程序（游戏、3D图形处理、实时系统等等）都可以从中受益。
- en: 'The *Gang of Four* (*GoF*) book lists the following requirements that need
    to be satisfied to effectively use the flyweight pattern:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*四人帮*（*GoF*）书籍列出了以下需要满足的要求，以有效地使用享元模式：'
- en: The application needs to use many objects.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序需要使用许多对象。
- en: There are so many objects that it's too expensive to store/render them. Once
    the mutable state is removed (because if it is required, it should be passed explicitly
    to the flyweight pattern by the client code), many groups of distinct objects
    can be replaced by relatively few shared objects.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有如此多的对象，存储/渲染它们太昂贵了。一旦移除了可变状态（因为如果需要，它应该由客户端代码显式传递给享元模式），许多不同的对象组可以被相对较少的共享对象所替代。
- en: Object identity is not important for the application. We cannot rely on object
    identity because object sharing causes identity comparisons to fail (objects that
    appear different to the client code end up having the same identity).
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象标识对于应用程序来说并不重要。我们不能依赖于对象标识，因为对象共享会导致标识比较失败（对客户端代码看起来不同的对象最终具有相同的标识）。
- en: Now, let's look at our hands-on implementation of the flyweight pattern.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们对享元模式的实际实现。
- en: Implementation
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: Let's see how we can implement the example that we briefly mentioned in the
    introduction to this section for cars in an area. We will create a small car park
    to illustrate the idea, making sure that the whole output can be read on a single
    Terminal page. However, no matter how large you make the car park, the memory
    allocation stays the same.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何将本节介绍中简要提到的示例实现应用于区域内的汽车。我们将创建一个小型停车场来阐述这个想法，确保整个输出可以在单个终端页面上阅读。然而，无论停车场有多大，内存分配保持不变。
- en: Before diving into the code, let's spend a moment noting the differences between
    memoization and the flyweight pattern. **Memoization** is an optimization technique
    that uses a cache to avoid recomputing results that were already computed in an
    earlier execution step. Memoization does not focus on a specific programming paradigm
    such as **object-oriented programming** (**OOP**). In Python, memoization can
    be applied to both methods and simple functions. Flyweight is an OOP-specific
    optimization design pattern that focuses on sharing object data.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入代码之前，让我们花一点时间来指出记忆化和享元模式之间的区别。**记忆化**是一种优化技术，它使用缓存来避免在早期执行步骤中已经计算过的结果的重新计算。记忆化并不专注于特定的编程范式，如**面向对象编程**（**OOP**）。在Python中，记忆化可以应用于方法和简单函数。享元是面向对象编程特定的优化设计模式，它专注于共享对象数据。
- en: 'First, we need an `Enum` parameter that describes the three different types
    of cars that are in the car park:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个`Enum`参数来描述停车场中的三种不同类型的汽车：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, we will define the class at the core of our implementation: `Car`. The
    `pool` variable is the object pool (in other words, our cache). Notice that `pool`
    is a class attribute (a variable that''s shared by all instances).'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将定义实现的核心类：`Car`。`pool`变量是对象池（换句话说，我们的缓存）。请注意，`pool`是一个类属性（一个由所有实例共享的变量）。
- en: 'Using the `__new__()` special method, which is called before `__init__()`,
    we are converting the `Car` class into a metaclass that supports self-references.
    This means that `cls` references the `Car` class. When the client code creates
    an instance of `Car`, it passes the type of the car as `car_type`. The car''s
    type is used to check if a car of the same type has already been created. If that''s
    the case, the previously created object is returned; otherwise, the new car type
    is added to the pool and returned:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用在`__init__()`之前被调用的特殊方法`__new__()`，我们将`Car`类转换为一个支持自引用的元类。这意味着`cls`引用了`Car`类。当客户端代码创建`Car`的实例时，它将汽车类型作为`car_type`传递。汽车类型用于检查是否已经创建了相同类型的汽车。如果是这样，则返回先前创建的对象；否则，将新的汽车类型添加到池中并返回：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `render()` method is what will be used to render a car on the screen. Notice
    how all the mutable information not known by flyweight needs to be explicitly
    passed by the client code. In this case, a random color and the coordinates of
    a location (of the *x, y* form) are used for each car.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`render()`方法将用于在屏幕上渲染汽车。注意所有未知于享元的信息都需要由客户端代码显式传递。在这种情况下，每个汽车使用随机颜色和位置坐标（*x,
    y*形式）。'
- en: 'Also, note that to make `render()` more useful, it is necessary to ensure that
    no cars are rendered on top of each other. Consider this as an exercise: if you
    want to make rendering more fun, you can use a graphics toolkit such as Tkinter,
    Pygame, or Kivy.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，为了使`render()`函数更加有用，必须确保没有汽车渲染在彼此之上。把这当作一个练习：如果你想使渲染更有趣，你可以使用Tkinter、Pygame或Kivy等图形工具包。
- en: 'The `render()` method is defined as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`render()`方法定义如下：'
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `main()` function shows how we can use the flyweight pattern. The color
    of a car is a random value from a predefined list of colors. The coordinates use
    random values between `1` and `100`. As we will see shortly, although 18 cars
    are rendered, memory is only allocated for 3\. The last line of the output, which
    we will see later, proves that when using flyweight, we cannot rely on object
    identity.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()`函数展示了我们如何使用flyweight模式。汽车的颜色是从预定义的颜色列表中随机选择的值。坐标使用`1`到`100`之间的随机值。正如我们很快就会看到的，尽管渲染了18辆汽车，但只分配了3个内存。输出中的最后一行，我们稍后会看到，证明了在使用flyweight时，我们不能依赖于对象身份。'
- en: The `id()` function returns the memory address of an object. This is not the
    default behavior in Python because, by default, `id()` returns a unique ID (the
    memory address of an object as an integer) for each object. In our case, even
    if two objects appear to be different, they have the same identity if they belong
    to the same flyweight family (in this case, the family is defined by `car_type`).
    Of course, different identity comparisons can still be used for objects of different
    families, but that is only possible if the client knows the implementation details.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`id()`函数返回对象的内存地址。在Python中，这并不是默认行为，因为默认情况下，`id()`为每个对象返回一个唯一的ID（对象的内存地址作为整数）。在我们的例子中，即使两个对象看起来不同，如果它们属于同一个flyweight家族（在这种情况下，家族由`car_type`定义），它们仍然具有相同的身份。当然，对于不同家族的对象，仍然可以使用不同的身份比较，但这只有在客户端知道实现细节的情况下才可能。'
- en: 'Our example `main()` function''s code is as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例`main()`函数的代码如下：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here is the full code listing (the `flyweight.py` file) to show you how the
    flyweight pattern is implemented and used:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是完整的代码列表（`flyweight.py`文件），以展示如何实现和使用flyweight模式：
- en: 'First, we need a couple of imports:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要导入一些模块：
- en: '[PRE4]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `Enum` for the types of cars is shown here:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里展示了汽车类型的`Enum`：
- en: '[PRE5]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, we have the `Car` class, with its `pool` attribute and the `__new__()`
    and `render()` methods:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们有`Car`类，它具有`pool`属性和`__new__()`和`render()`方法：
- en: '[PRE6]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the first part of the `main` function, we define some variables and render
    a set of cars of the `subcompact` type:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main`函数的第一部分，我们定义了一些变量并渲染了一组`subcompact`类型的汽车：
- en: '[PRE7]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The second part of the `main` function is as follows, which renders another
    set of cars of the `compact` type:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`main`函数的第二部分如下，这次渲染了另一组`compact`类型的汽车：'
- en: '[PRE8]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The third part of the `main` function is as follows, this time with `suv` cars:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`main`函数的第三部分如下，这次是`SUV`汽车：'
- en: '[PRE9]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, here is the fourth part of the `main` function, where we create three
    additional cars of the three types:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，这里是`main`函数的第四部分，其中我们创建了三种类型的另外三辆汽车：
- en: '[PRE10]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We do not forget our usual `__name__ == ''__main__''` trick and good practice,
    as follows:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们没有忘记我们常用的`__name__ == '__main__'`技巧和良好的实践，如下所示：
- en: '[PRE11]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The execution of the Python `flyweight.py` command shows the type, random color,
    and coordinates of the rendered objects, as well as the identity comparison results
    between flyweight objects of the same/different families:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 执行Python `flyweight.py`命令显示了渲染对象的类型、随机颜色和坐标，以及同一/不同家族的flyweight对象之间的身份比较结果：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Do not expect to see the same output since the colors and coordinates are random,
    and the object identities depend on the memory map.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 不要期望看到相同的输出，因为颜色和坐标是随机的，并且对象身份取决于内存映射。
- en: This program marks the end of our discussion of the flyweight pattern. In the
    next section, we will learn about the MVC pattern.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序标志着我们对flyweight模式的讨论结束。在下一节中，我们将学习MVC模式。
- en: Implementing the model-view-controller pattern
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现模型-视图-控制器（MVC）模式
- en: The MVC pattern is useful mainly in application development and helps developers
    improve the maintainability of their applications by avoiding mixing the business
    logic with the user interface.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: MVC模式主要在应用程序开发中很有用，它帮助开发者通过避免将业务逻辑与用户界面混合来提高应用程序的可维护性。
- en: One of the design principles related to software engineering is the **separation
    of concerns** (**SoC**) principle. The idea behind the SoC principle is to split
    an application into distinct sections, where each section addresses a separate
    concern. Examples of such concerns are the layers that are used in a layered design
    (data access layer, business logic layer, presentation layer, and so forth). Using
    the SoC principle simplifies the development and maintenance of software applications.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 与软件工程相关的其中一个设计原则是**关注点分离**（SoC）原则。SoC原则背后的思想是将应用程序分割成不同的部分，每个部分解决一个单独的关注点。这样的关注点的例子包括分层设计中使用的层（数据访问层、业务逻辑层、表示层等等）。使用SoC原则简化了软件应用程序的开发和维护。
- en: 'The MVC pattern is nothing more than the SoC principle applied to OOP. The
    name of the pattern comes from the three main components that are used to split
    a software application: the **model**, the **view**, and the **controller**. MVC
    is considered an architectural pattern rather than a design pattern. The difference
    between an architectural and a design pattern is that the former has a broader
    scope than the latter. Nevertheless, MVC is too important to skip just for this
    reason. Even if we will never have to implement it from scratch, we need to be
    familiar with it because all common frameworks use MVC or a slightly different
    version of it (more on this shortly).'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: MVC模式不过是将SoC原则应用于面向对象编程。模式的名称来源于用于分割软件应用程序的三个主要组件：**模型**、**视图**和**控制器**。MVC被认为是一种架构模式，而不是设计模式。架构模式和设计模式之间的区别在于前者比后者具有更广泛的范围。尽管如此，MVC的重要性不容忽视。即使我们永远不需要从头开始实现它，我们也需要熟悉它，因为所有常见的框架都使用MVC或其略微不同的版本（稍后将有更多介绍）。
- en: The model is the core component. It represents knowledge. It contains and manages
    the (business) logic, data, state, and rules of an application. The view is a
    visual representation of the model. Examples of views include a computer GUI,
    the text output of a computer terminal, a smartphone's application GUI, a PDF
    document, a pie chart, a bar chart, and so forth. The view only displays the data;
    it doesn't handle it. The controller is the link/glue between the model and view.
    All communication between the model and the view happens through a controller.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 模型是核心组件。它代表知识。它包含并管理应用程序的（业务）逻辑、数据、状态和规则。视图是模型的视觉表示。视图的例子包括计算机GUI、计算机终端的文本输出、智能手机应用程序GUI、PDF文档、饼图、柱状图等等。视图只显示数据；它不处理数据。控制器是模型和视图之间的链接/粘合剂。模型和视图之间的所有通信都通过控制器进行。
- en: 'A typical use case for an application that uses MVC, after the initial screen
    is rendered for the user, is as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一个使用MVC的应用程序的典型用例，在用户初始屏幕渲染后如下：
- en: The user triggers a view by clicking (typing, touching, and so on) a button.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户通过点击（输入、触摸等）按钮来触发视图。
- en: The view informs the controller of the user's action.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 视图通知控制器用户的行为。
- en: The controller processes user input and interacts with the model.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 控制器处理用户输入并与模型交互。
- en: The model performs all the necessary validation and state changes and informs
    the controller about what should be done.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模型执行所有必要的验证和状态更改，并通知控制器应该做什么。
- en: The controller instructs the view to update and display the output appropriately,
    following the instructions that are given by the model.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 控制器根据模型给出的指令，指示视图适当地更新并显示输出。
- en: 'This is summarized in the following diagram:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这在以下图中进行了总结：
- en: '![Figure 23.1 — An MVC diagram for a typical computer program ](img/Figure_23.1_B17499.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图23.1 — 典型计算机程序的MVC图](img/Figure_23.1_B17499.jpg)'
- en: Figure 23.1 — An MVC diagram for a typical computer program
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图23.1 — 典型计算机程序的MVC图
- en: '*You might be wondering, why is the controller part necessary? Can''t we just
    skip it?* We could, but then we would lose a big benefit that MVC provides: the
    ability to use more than one view (even at the same time, if that''s what we want)
    without modifying the model. To achieve decoupling between the model and its representation,
    every view typically needs a controller. If the model communicated directly with
    a specific view, we wouldn''t be able to use multiple views (or at least, not
    in a clean and modular way).'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可能想知道，控制器部分为什么是必要的？我们不能跳过它吗？* 我们可以，但那样我们就会失去MVC提供的一个大优势：能够在不修改模型的情况下使用多个视图（甚至如果需要，同时使用）。为了在模型及其表示之间实现解耦，每个视图通常都需要一个控制器。如果模型直接与特定的视图通信，我们就无法使用多个视图（或者至少，不能以一种干净和模块化的方式使用）。'
- en: Now, let's see where the MVC pattern is used in the real world.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看MVC模式在现实世界中的应用。
- en: Real-world examples
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 现实世界的例子
- en: 'As we mentioned previously, MVC is the SoC principle applied to OOP. The SoC
    principle is used a lot in real life. For example, if you build a new house, you
    usually assign different professionals to do the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，MVC是将SoC原则应用于OOP。SoC原则在现实生活中被广泛使用。例如，如果你建造一栋新房子，你通常会指派不同的专业人士来完成以下工作：
- en: Install the plumbing and electricity
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装管道和电路
- en: Paint the house
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 油漆房屋
- en: Another example is a restaurant. In a restaurant, the waiters receive orders
    and serve dishes to the customers, but the meals are cooked by the chefs.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是餐厅。在餐厅里，服务员接收订单并为顾客上菜，但饭菜是由厨师烹制的。
- en: 'In web development, several frameworks use the MVC idea:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web开发中，几个框架使用了MVC思想：
- en: The **Web2py** framework ([http://j.mp/webtopy](http://j.mp/webtopy)) is a lightweight
    Python framework that embraces the MVC pattern. If you have never tried Web2py,
    I encourage you to do so since it is extremely simple to install. Many examples
    demonstrate how MVC can be used in Web2py on the project's web page.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Web2py** 框架([http://j.mp/webtopy](http://j.mp/webtopy))是一个轻量级的Python框架，它采用了MVC模式。如果你从未尝试过Web2py，我鼓励你试试，因为它安装起来极其简单。许多示例演示了如何在项目的网页上使用Web2py中的MVC模式。'
- en: '**Django** is also an MVC framework, although it uses different naming conventions.
    The controller is called view, and the view is called **template**. Django uses
    the name **Model-Template-View** (**MTV**). According to the designers of Django,
    the view describes what data is seen by the user, so it uses the name view as
    the Python callback function for a particular URL. The term *template* in Django
    is used to separate content from its representation. It describes *how* the data
    is seen by the user, not *which* data is seen.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Django** 也是一个MVC框架，尽管它使用了不同的命名约定。控制器被称为视图，而视图被称为**模板**。Django使用**模型-模板-视图**（**MTV**）的名称。根据Django的设计师，视图描述了用户看到的数据，因此它使用“视图”作为特定URL的Python回调函数。Django中的“模板”术语用于将内容与其表示分离。它描述了数据是如何被用户看到的，而不是用户看到了哪些数据。'
- en: In the next section, we will detail the specific use cases of the MVC pattern.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将详细介绍MVC模式的具体用例。
- en: Use cases
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用例
- en: 'MVC is a very generic and useful design pattern. All popular web frameworks
    (Django, Rails, and Symfony or Yii) and application frameworks (iPhone SDK, Android,
    and QT) make use of MVC or a variation of it – **model-view-adapter** (**MVA**),
    **model-view-presenter** (**MVP**), and so forth. However, even if we don''t use
    any of these frameworks, it makes sense to implement the pattern on our own because
    of the benefits it provides, which are as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: MVC是一个非常通用且有用的设计模式。所有流行的Web框架（Django、Rails和Symfony或Yii）以及应用程序框架（iPhone SDK、Android和QT）都使用了MVC或其变体——**模型-视图-适配器**（**MVA**）、**模型-视图-表示器**（**MVP**）等等。然而，即使我们不使用这些框架，由于它提供的优势，我们自己实现这个模式也是有意义的，这些优势如下：
- en: The separation between the view and model allows graphic designers to focus
    on the UI part and programmers to focus on development, without them interfering
    with each other.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图和模型之间的分离使得图形设计师可以专注于UI部分，程序员可以专注于开发，而不会相互干扰。
- en: Because of the loose coupling between the view and the model, each part can
    be modified/extended without them affecting the other. For example, adding a new
    view is trivial – just implement a new controller for it.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于视图和模型之间的松散耦合，每个部分都可以在不影响其他部分的情况下进行修改/扩展。例如，添加一个新的视图是微不足道的——只需为它实现一个新的控制器即可。
- en: Maintaining each part is easier because the responsibilities are clear.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于责任明确，维护每个部分都更容易。
- en: When you implement MVC from scratch, ensure that you create smart models, thin
    controllers, and dumb views.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当您从头开始实现 MVC 时，请确保您创建智能模型、瘦控制器和愚视图。
- en: 'A model is considered smart because it does the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一个模型被认为智能，因为它执行以下操作：
- en: Contains all the validation/business rules/logic
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含所有验证/业务规则/逻辑
- en: Handles the state of the application
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理应用程序的状态
- en: Has access to application data (database, cloud, and so on)
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有权访问应用程序数据（数据库、云等）
- en: Does not depend on the UI
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不依赖于 UI
- en: 'A controller is considered thin because it does the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一个控制器被认为瘦，因为它执行以下操作：
- en: Updates the model when the user interacts with the view
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户与视图交互时更新模型
- en: Updates the view when the model changes
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当模型更改时更新视图
- en: Processes the data before delivering it to the model/view, if necessary
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在必要时在将数据交付给模型/视图之前处理数据
- en: Does not display the data
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不显示数据
- en: Does not access the application data directly
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不直接访问应用程序数据
- en: Does not contain validation/business rules/logic
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不包含验证/业务规则/逻辑
- en: 'A view is considered dumb because it does the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一个视图被认为是无脑的，因为它执行以下操作：
- en: Displays the data
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示数据
- en: Allows the user to interact with it
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许用户与之交互
- en: Does only minimal processing, usually provided by a template language (for example,
    using simple variables and loop controls)
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只进行最小处理，通常由模板语言提供（例如，使用简单的变量和循环控制）
- en: Does not store any data
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不存储任何数据
- en: Does not access the application data directly
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不直接访问应用程序数据
- en: Does not contain validation/business rules/logic
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不包含验证/业务规则/逻辑
- en: 'If you are implementing MVC from scratch and want to find out if you did it
    right, you can try answering some key questions:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您从头开始实现 MVC 并想了解您是否做得正确，您可以尝试回答一些关键问题：
- en: '*If your application has a GUI, is it skinnable? How easily can you change
    the skin/look and feel of it? Can you give the user the ability to change the
    skin of your application during runtime?* If these tasks cannot be done easily,
    it means that something is going wrong with your MVC implementation.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*如果您的应用程序有 GUI，它是可定制的吗？您有多容易改变它的外观和感觉？您能否在运行时让用户更改应用程序的外观？* 如果这些任务不容易完成，则意味着您的
    MVC 实现出了问题。'
- en: '*If your application has no GUI (for instance, if it''s a terminal application),
    how hard is it to add GUI support? Or, if adding a GUI is irrelevant, is it easy
    to add views to display the results in a chart (pie chart, bar chart, and so on)
    or a document (PDF, spreadsheet, and so on)?* If these changes are not trivial
    (a matter of creating a new controller with a view attached to it, without modifying
    the model), MVC has not been implemented properly.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*如果您的应用程序没有 GUI（例如，如果它是一个终端应用程序），添加 GUI 支持有多难？或者，如果添加 GUI 不相关，是否容易添加视图以在图表（饼图、条形图等）或文档（PDF、电子表格等）中显示结果？*
    如果这些更改不是微不足道的（只需创建一个新的控制器并将其附加到视图上，而不修改模型），则 MVC 没有得到正确实现。'
- en: If you make sure that these conditions are satisfied, your application will
    be more flexible and maintainable compared to an application that does not use
    MVC. We'll look at an example of this in the next section, where we will implement
    an application to maintain a collection of quotes.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您确保这些条件得到满足，与不使用 MVC 的应用程序相比，您的应用程序将更加灵活和易于维护。我们将在下一节中通过实现一个用于维护引言集合的应用程序来查看这个例子。
- en: Implementation
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: 'I could use any of the common frameworks to demonstrate how to use MVC, but
    I feel that the picture would be incomplete. So, I have decided to show you how
    to implement MVC from scratch using a very simple example: a quote printer. The
    idea is extremely simple. The user enters a number and sees the quote related
    to that number. The quotes are stored in a `quotes` tuple. This is the data that
    normally exists in a database, a file, and so on, and only the model has direct
    access to it.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以使用任何常见的框架来演示如何使用 MVC，但我感觉这样会不完整。因此，我决定向您展示如何使用一个非常简单的示例从头开始实现 MVC：一个引言打印机。这个想法非常简单。用户输入一个数字，然后看到与该数字相关的引言。引言存储在
    `quotes` 元组中。这是通常存在于数据库、文件等中的数据，并且只有模型可以直接访问它。
- en: 'Let''s consider the following code example:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下代码示例：
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The model is minimalistic; it only has a `get_quote()` method that returns
    the quote (string) of the `quotes` tuple based on its index, *n*. Note that *n*
    can be less than or equal to `0`, due to the way indexing works in Python:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 模型是最简的；它只有一个 `get_quote()` 方法，该方法根据索引 *n* 返回 `quotes` 元组的引言（字符串）。请注意，*n* 可以小于或等于
    `0`，这是由于 Python 中索引工作方式的原因：
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The view has three methods:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 视图有三种方法：
- en: '`Show()`, which is used to print a quote (or the message; that is, `Not found!`)
    on the screen.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Show()`，用于在屏幕上打印引用（或消息；即“未找到！”）。'
- en: '`error()`, which is used to print an error message on the screen.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`error()`，用于在屏幕上打印错误消息。'
- en: '`select_quote()`, which reads the user''s selection.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`select_quote()`，用于读取用户的选项。'
- en: 'This can be seen in the following code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以在以下代码中看到：
- en: '[PRE15]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The controller does the coordination. The `__init__()` method initializes the
    model and view. The `run()` method validates the quoted index that''s been given
    by the user, gets the quote from the model, and passes it back to the view to
    be displayed, as shown in the following code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器负责协调。`__init__()`方法初始化模型和视图。`run()`方法验证用户给出的引用索引，从模型获取引用，并将其传递回视图以显示，如下面的代码所示：
- en: '[PRE16]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Last but not least, the `main()` function initializes and fires the controller,
    as shown in the following code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，`main()`函数初始化并启动控制器，如下面的代码所示：
- en: '[PRE17]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The following is the complete workflow for this example (the `mvc.py` file):'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是这个示例的完整工作流程（`mvc.py`文件）：
- en: We start by defining a variable for the list of quotes.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先定义一个用于引用列表的变量。
- en: We implement the model class, `QuoteModel`.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们实现模型类，`QuoteModel`。
- en: Then, we implement the view class, `QuoteTerminalView`.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们实现视图类，`QuoteTerminalView`。
- en: Finally, we implement the controller class, `QuoteTerminalController`.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们实现控制器类，`QuoteTerminalController`。
- en: At the end of our example code with the `main()` function, we initialize and
    run the controller.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的示例代码的`main()`函数结束时，我们初始化并运行控制器。
- en: 'The following sample execution of the Python `mvc.py` command shows how the
    program prints out quotes for the user:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 以下Python `mvc.py`命令的示例执行显示了程序如何为用户打印引用：
- en: '[PRE18]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, we can see that everything is working as intended!
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到一切都在按预期工作！
- en: 'And with that, we will move on to the last topic of this chapter: the proxy
    pattern.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们将继续本章的最后一个主题：代理模式。
- en: Applying the proxy pattern
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用代理模式
- en: In some applications, we want to execute one or more important actions before
    accessing an object. This is where the **proxy pattern** comes in. An example
    is accessing sensitive information. Before we allow any user to access sensitive
    information, we want to make sure that the user has sufficient privileges. The
    important action is not necessarily related to security issues. **Lazy initialization**
    ([http://j.mp/wikilazy](http://j.mp/wikilazy)) is another case; we want to delay
    the creation of a computationally expensive object until the first time the user
    needs to use it. The idea of the proxy pattern is to help with performing such
    an action before accessing the actual object.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些应用程序中，我们希望在访问对象之前执行一个或多个重要操作。这就是**代理模式**的用武之地。一个例子是访问敏感信息。在我们允许任何用户访问敏感信息之前，我们想确保用户有足够的权限。这个重要操作不一定与安全问题相关。**延迟初始化**（[http://j.mp/wikilazy](http://j.mp/wikilazy)）是另一个例子；我们希望在用户第一次需要使用它时才创建计算密集型对象。代理模式的想法是在访问实际对象之前帮助执行此类操作。
- en: 'The proxy design pattern gets its name from the *proxy* (also known as *surrogate*)
    object, which is used to perform an important action before the actual object
    is accessed. There are four different well-known proxy types ([http://j.mp/proxypat](http://j.mp/proxypat)).
    They are as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 代理设计模式的名字来源于**代理**（也称为**替代者**）对象，它在访问实际对象之前执行重要操作。有四种不同的知名代理类型（[http://j.mp/proxypat](http://j.mp/proxypat)）。它们如下：
- en: A **remote proxy**, which acts as the local representation of an object that
    exists in a different address space (for example, a network server).
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种**远程代理**，作为存在于不同地址空间（例如，网络服务器）的对象的本地表示。
- en: A **virtual proxy**, which uses lazy initialization to defer the creation of
    a computationally expensive object until the moment it is needed.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种**虚拟代理**，使用延迟初始化来推迟计算密集型对象的创建，直到需要时。
- en: A **protection/protective proxy**, which controls access to a sensitive object.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种**保护/防护代理**，用于控制对敏感对象的访问。
- en: A **smart (reference) proxy**, which performs extra actions when an object is
    accessed. Examples of such actions include reference counting and thread-safety
    checks.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种**智能（引用）代理**，在访问对象时执行额外操作。此类操作的示例包括引用计数和线程安全检查。
- en: I find virtual proxies very useful, so let's look at an example of how we can
    implement them in Python right now. In the *Implementation* subsection of this
    section, you will learn how to create protective proxies.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现虚拟代理非常有用，所以让我们看看如何在 Python 中实现它们的例子。在本节的 *实现* 子节中，你将学习如何创建保护代理。
- en: 'There are many ways to create a virtual proxy in Python, but I always like
    focusing on the idiomatic/Pythonic implementations. The code shown here is based
    on the great answer by Cyclone, a user of the following site: [http://stackoverflow.com/](http://stackoverflow.com/)
    ([http://j.mp/solazyinit](http://j.mp/solazyinit)). To avoid confusion, I should
    clarify that in this section, the terms *property*, *variable*, and *attribute*
    are used interchangeably.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中创建虚拟代理有许多方法，但我总是喜欢专注于惯用/Pythonic 的实现。这里展示的代码基于 Cyclone 的优秀回答，Cyclone
    是以下网站的用户：[http://stackoverflow.com/](http://stackoverflow.com/) ([http://j.mp/solazyinit](http://j.mp/solazyinit))。为了避免混淆，我应该明确指出，在本节中，术语
    *属性*、*变量* 和 *属性* 是可以互换使用的。
- en: 'First, we must create a `LazyProperty` class that can be used as a decorator.
    When it decorates a property, `LazyProperty` loads the property lazily (on the
    first use), instead of instantly. The `__init__()` method creates two variables
    that are used as aliases to the method that initializes a property. The `method`
    variable is an alias to the actual method, while the `method_name` variable is
    an alias to the method''s name. To get a better understanding of how the two aliases
    are used, print their values to the output (uncomment the two commented lines
    in the following code):'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须创建一个 `LazyProperty` 类，它可以作为装饰器使用。当它装饰一个属性时，`LazyProperty` 会延迟加载属性（在第一次使用时），而不是立即加载。`__init__()`
    方法创建了两个变量，这些变量用作初始化属性的方法的别名。`method` 变量是实际方法的别名，而 `method_name` 变量是方法名的别名。为了更好地理解这两个别名是如何使用的，可以将它们的值打印到输出（取消以下代码中的两行注释）：
- en: '[PRE19]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `LazyProperty` class is a descriptor ([http://j.mp/pydesc](http://j.mp/pydesc)).
    Descriptors are the recommended mechanisms to use in Python to override the default
    behavior of its attribute access methods: `__get__()`, `__set__()`, and `__delete__()`.
    The `LazyProperty` class only overrides `__set__()` because that is the only access
    method it needs to override. In other words, we don''t have to override all the
    access methods. The `__get__()` method accesses the value of the property the
    underlying method wants to assign and uses `setattr()` to do the assignment manually.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`LazyProperty` 类是一个描述符 ([http://j.mp/pydesc](http://j.mp/pydesc)). 描述符是在 Python
    中推荐使用的机制，用于覆盖其属性访问方法的默认行为：`__get__()`, `__set__()` 和 `__delete__()`。`LazyProperty`
    类仅覆盖 `__set__()`，因为这是它需要覆盖的唯一访问方法。换句话说，我们不必覆盖所有访问方法。`__get__()` 方法访问底层方法想要分配的属性的值，并使用
    `setattr()` 手动进行分配。'
- en: 'What `__get()__`does is very neat: it replaces the method with the value! This
    means that not only is the property lazily loaded, but it can also only be set
    once. We will see what this means in a moment. Again, uncomment the commented
    line in the following code to get some extra information:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`__get()__` 所做的非常巧妙：它用值替换了方法！这意味着属性不仅会延迟加载，而且只能设置一次。我们将在稍后看到这意味着什么。再次提醒，取消以下代码中的注释行以获取更多信息：'
- en: '[PRE20]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `Test` class shows how we can use the `LazyProperty` class. There are three
    attributes: `x`, `y`, and `_resource`. We want the `_resource` variable to be
    loaded lazily; thus, we must initialize it to `None`, as shown in the following
    code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`Test` 类展示了我们如何使用 `LazyProperty` 类。有三个属性：`x`、`y` 和 `_resource`。我们希望 `_resource`
    变量能够延迟加载；因此，我们必须将其初始化为 `None`，如下所示：'
- en: '[PRE21]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `resource()` method is decorated with the `LazyProperty` class. For demonstration
    purposes, the `LazyProperty` class initializes the `_resource` attribute as a
    tuple, as shown in the following code. Normally, this would be a slow/expensive
    initialization process (database, graphics, and so on):'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`resource()` 方法被 `LazyProperty` 类装饰。为了演示目的，`LazyProperty` 类将 `_resource` 属性初始化为一个元组，如下所示。通常，这会是一个缓慢/昂贵的初始化过程（数据库、图形等）：'
- en: '[PRE22]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `main()` function, as follows, shows how lazy initialization behaves:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示的 `main()` 函数展示了延迟初始化的行为：
- en: '[PRE23]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Notice how overriding the `__get()__` access method makes it possible to treat
    the `resource()` method as a simple attribute (we can use `t.resource` instead
    of `t.resource()`).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，覆盖 `__get()__` 访问方法使得将 `resource()` 方法视为一个简单的属性成为可能（我们可以使用 `t.resource` 而不是
    `t.resource()`）。
- en: 'In the execution output of this example (the `lazy.py` file), we can see the
    following:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在此例的执行输出（`lazy.py` 文件）中，我们可以看到以下内容：
- en: The `_resource` variable is initialized not by the time the `t` instance is
    created, but the first time that we use `t.resource`.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_resource`变量不是在创建`t`实例时初始化，而是在我们第一次使用`t.resource`时初始化。'
- en: The second time `t.resource` is used, the variable is not initialized again.
    That's why the initialization string that's initializing `self._resource` is shown
    only once.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二次使用`t.resource`时，变量不会被再次初始化。这就是为什么初始化`self._resource`的初始化字符串只显示一次的原因。
- en: 'Here is the output we get when we execute the Python `lazy.py` command:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们执行Python `lazy.py`命令时得到的输出：
- en: '[PRE24]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'There are two basic, different kinds of lazy initialization in OOP. They are
    as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程中，存在两种基本的、不同的懒加载初始化方式。具体如下：
- en: '**At the instance level**: This means that an object''s property is initialized
    lazily, but the property has an object scope. Each instance (object) of the same
    class has its own (different) copy of the property.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在实例级别**：这意味着对象的属性是懒加载初始化的，但属性具有对象作用域。同一类的每个实例（对象）都有自己的（不同的）属性副本。'
- en: '**At the class or module level**: In this case, we do not want a different
    copy per instance, but all the instances share the same property, which is lazily
    initialized. This case is not covered in this chapter. If you find it interesting,
    consider it as an exercise.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在类或模块级别**：在这种情况下，我们不希望每个实例都有一个不同的副本，而是所有实例共享同一个属性，该属性是懒加载初始化的。这种情况在本章中没有涉及。如果你对此感兴趣，可以将其视为练习。'
- en: Now, let's see what real-world examples follow the proxy pattern.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看遵循代理模式的现实世界中的例子。
- en: Real-world examples
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 现实世界中的例子
- en: '**Chip** (also known as **Chip and PIN**) cards ([http://j.mp/wichpin](http://j.mp/wichpin))
    offer a good example of how a protective proxy is used in real life. A debit/credit
    card contains a chip that needs to be read by the ATM or card reader. Once the
    chip has been verified, a password (PIN) is required to complete the transaction.
    This means that you cannot make any transactions without physically presenting
    the card and knowing the PIN.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**Chip**（也称为**Chip and PIN**）卡（[http://j.mp/wichpin](http://j.mp/wichpin)）是现实生活中如何使用保护代理的一个很好的例子。借记卡/信用卡包含一个需要由ATM或读卡器读取的芯片。一旦芯片被验证，就需要密码（PIN）来完成交易。这意味着，如果没有物理出示卡片并知道PIN，就无法进行任何交易。'
- en: A bank check, which is used instead of cash to make purchases and deals, is
    an example of a remote proxy. The check gives access to a bank account.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 银行支票，用于代替现金进行购买和交易，是远程代理的一个例子。支票可以访问银行账户。
- en: In software, the `weakref` module of Python contains a `proxy()` method, which
    accepts an input object and returns a smart proxy to it. Weak references are the
    recommended way to add reference-counting support to an object.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件中，Python的`weakref`模块包含一个`proxy()`方法，它接受一个输入对象并返回一个智能代理。弱引用是向对象添加引用计数支持的推荐方式。
- en: Use cases
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用例
- en: 'Since there are at least four common proxy types, the proxy design pattern
    has many use cases, as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 由于至少有四种常见的代理类型，因此代理设计模式有许多用例，如下所示：
- en: It is used to create a distributed system using either a private network or
    the cloud. In a distributed system, some objects exist in the local memory, while
    other objects exist in the memory of remote computers. If we don't want the client
    code to be aware of such differences, we can create a remote proxy that hides/encapsulates
    them, making the distributed nature of the application transparent.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它用于创建使用私有网络或云的分布式系统。在分布式系统中，一些对象存在于本地内存中，而其他对象存在于远程计算机的内存中。如果我们不希望客户端代码意识到这些差异，我们可以创建一个远程代理来隐藏/封装它们，使应用程序的分布式特性透明。
- en: It is used when our application is suffering from performance issues due to
    the early creation of expensive objects. Introducing lazy initialization using
    a virtual proxy to create the objects only at the moment they are required can
    give us significant performance improvements.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们的应用程序由于早期创建昂贵的对象而遭受性能问题时，使用虚拟代理在需要时才创建对象可以实现显著的性能提升。
- en: It is used to check if a user has sufficient privileges to access a piece of
    information. If our application handles sensitive information (for example, medical
    data), we want to make sure that the user who's trying to access/modify it is
    allowed to do so. A protection/protective proxy can handle all security-related
    actions.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它用于检查用户是否有足够的权限访问某些信息。如果我们的应用程序处理敏感信息（例如，医疗数据），我们希望确保尝试访问/修改这些信息的用户被允许这样做。保护/保护代理可以处理所有与安全相关的操作。
- en: It is used when our application (or library, toolkit, framework, and so forth)
    uses multiple threads and we want to move the burden of thread safety from the
    client code to the application. In this case, we can create a smart proxy to hide
    the thread-safety complexities from the client.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们的应用程序（或库、工具包、框架等）使用多个线程，并且我们希望将线程安全的问题从客户端代码转移到应用程序时，会用到它。在这种情况下，我们可以创建一个智能代理来隐藏线程安全的复杂性，不让客户端看到。
- en: An **object-relational mapping** (**ORM**) API is also an example of how to
    use a remote proxy. Many popular web frameworks, including Django, use an ORM
    to provide OOP-like access to a relational database. An ORM acts as a proxy to
    a relational database that can be located anywhere, either at a local or remote
    server.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对象关系映射**（**ORM**）API 也是如何使用远程代理的一个例子。许多流行的Web框架，包括Django，使用ORM来提供面向对象的数据库访问。ORM充当一个代理，可以位于任何地方，无论是本地还是远程服务器。'
- en: Now, let's apply the proxy pattern to build a simple interface that provides
    example users' information.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们应用代理模式来构建一个简单的接口，该接口提供示例用户的详细信息。
- en: Implementation
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: 'To demonstrate the proxy pattern, we will implement a simple protection proxy
    to view and add users. The service provides two options:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示代理模式，我们将实现一个简单的保护代理来查看和添加用户。该服务提供两种选项：
- en: '**Viewing the list of users**: This operation does not require special privileges.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**查看用户列表**：此操作不需要特殊权限。'
- en: '**Adding a new user**: This operation requires the client to provide a special
    secret message.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**添加新用户**：此操作需要客户端提供一条特殊的秘密信息。'
- en: The `SensitiveInfo` class contains the information that we want to protect.
    The `users` variable contains the list of existing users. The `read()` method
    prints the list of users. The `add()` method adds a new user to the list.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`SensitiveInfo` 类包含我们想要保护的信息。`users` 变量包含现有用户的列表。`read()` 方法打印用户列表。`add()`
    方法将新用户添加到列表中。'
- en: 'Let''s consider the following code:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下代码：
- en: '[PRE25]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `Info` class is a protection proxy of `SensitiveInfo`. The `secret` variable
    is the message that''s required to be known/provided by the client code to add
    a new user. Note that this is just an example. In reality, you should never do
    the following:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`Info` 类是 `SensitiveInfo` 的保护代理。`secret` 变量是客户端代码添加新用户时需要知道/提供的消息。请注意，这只是一个例子。在现实中，你永远不应该做以下事情：'
- en: Store passwords in the source code
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在源代码中存储密码
- en: Store passwords in a cleartext form
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以明文形式存储密码
- en: Use a weak (for example, MD5) or custom form of encryption
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用弱（例如，MD5）或自定义形式的加密
- en: 'In the `Info` class, as shown in the following code, the `read()` method is
    a wrapper to `SensitiveInfo.read()`, and the `add()` method ensures that a new
    user can only be added if the client code knows the secret message:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，`Info` 类中，`read()` 方法是对 `SensitiveInfo.read()` 的包装，而 `add()` 方法确保只有当客户端代码知道秘密信息时，才能添加新用户：
- en: '[PRE26]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `main()` function shows how the proxy pattern can be used by the client
    code. The client code creates an instance of the `Info` class and uses the displayed
    menu to read the list, add a new user, or exit the application. Let''s consider
    the following code:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()` 函数展示了客户端代码如何使用代理模式。客户端代码创建 `Info` 类的一个实例，并使用显示的菜单来读取列表、添加新用户或退出应用程序。让我们考虑以下代码：'
- en: '[PRE27]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The following is the sample output of the program when executing the Python
    `proxy.py` command:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在执行 Python `proxy.py` 命令时程序的样本输出：
- en: '[PRE28]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*Have you already spotted flaws or missing features that could improve our
    proxy example?* I have a few suggestions. They are as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '*你已经发现了可以改进我们代理示例的缺陷或缺失功能吗？* 我有几个建议。如下：'
- en: This example has a very big security flaw. Nothing prevents the client code
    from bypassing the security of the application by creating an instance of `SensitiveInfo`
    directly. Improve this example to prevent this situation. One way to do this is
    to use the `abc` module to forbid direct instantiation of `SensitiveInfo`. *What
    other code changes are required in this case?*
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个例子有一个很大的安全漏洞。没有任何东西阻止客户端代码通过直接创建`SensitiveInfo`实例来绕过应用程序的安全。改进这个例子以防止这种情况。一种方法是通过使用`abc`模块禁止直接实例化`SensitiveInfo`。*在这种情况下还需要进行哪些代码更改？*
- en: A basic security rule is that we should never store cleartext passwords. Storing
    a password safely is not very hard, so long as we know which libraries to use
    ([http://j.mp/hashsec](http://j.mp/hashsec)). If you are interested in security,
    try to implement a secure way to store the secret message externally (for example,
    in a file or database).
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个基本的安全规则是我们永远不应该存储明文密码。只要我们知道使用哪些库，安全地存储密码并不难（[http://j.mp/hashsec](http://j.mp/hashsec)）。如果你对安全感兴趣，尝试实现一种安全的方式来外部存储秘密信息（例如，在文件或数据库中）。
- en: '*The application only supports adding new users, but what about removing an
    existing user?* Add a `remove()` method.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*应用程序仅支持添加新用户，但如何删除现有用户呢？* 添加一个`remove()`方法。'
- en: Summary
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we covered three other structural design patterns: flyweight,
    MVC, and proxy. Throughout this chapter, we learned about the differences between
    these and the other structural patterns we have discussed. Then, we implemented
    each of these patterns in hands-on examples. As we saw, the flyweight pattern
    is designed for memory usage minimization, the MVC pattern maintains a logical
    organization of different parts of an application, and the proxy pattern is typically
    used when sensitive information is accessed.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了三种其他结构设计模式：飞跃模式、MVC模式和代理模式。在本章中，我们了解了这些模式与其他我们已经讨论过的结构模式之间的区别。然后，我们在实际示例中实现了这些模式。正如我们所看到的，飞跃模式是为了最小化内存使用而设计的，MVC模式维护应用程序不同部分之间的逻辑组织，而代理模式通常用于访问敏感信息时。
- en: In the next chapter, we will start exploring behavioral design patterns. Behavioral
    patterns cope with object interconnection and algorithms. The first behavioral
    pattern we will cover is the chain of responsibility.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始探索行为设计模式。行为模式处理对象之间的交互和算法。我们将要介绍的第一个行为模式是责任链模式。
- en: Questions
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the main motivation for the flyweight pattern?
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 飞跃模式的主要动机是什么？
- en: What is the main motivation for the MVC pattern?
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: MVC模式的主要动机是什么？
- en: What is the main motivation for the proxy pattern?
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代理模式的主要动机是什么？
