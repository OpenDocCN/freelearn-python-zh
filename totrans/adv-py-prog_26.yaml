- en: '*Chapter 23*: Other Structural Patterns'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Besides the patterns we covered in the previous chapters, there are other structural
    patterns we can cover: **flyweight**, **model-view-controller** (**MVC**), and
    **proxy**. These patterns are different from those discussed in previous chapters.
    The flyweight pattern is an optimization design pattern that''s suitable for memory
    usage minimization. The MVC pattern, on the other hand, is popular in object-orient
    programming and is designed to separate different parts of a larger application.
    Finally, the proxy pattern is used to maintain actions that are taken on important
    objects.'
  prefs: []
  type: TYPE_NORMAL
- en: These three patterns will complete our discussion on structural patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the flyweight pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the model-view-controller pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying the proxy pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, we will have gained an overall understanding of
    various structural patterns and the use cases of each.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code files for this chapter can be found at [https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter23](https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter23).
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the flyweight pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*What is the flyweight pattern?* Object-oriented systems can face performance
    issues due to the overhead of object creation. Performance issues usually appear
    in embedded systems with limited resources, such as smartphones and tablets. They
    can also appear in large and complex systems where we need to create a very large
    number of objects (and possibly users) that need to coexist at the same time.
    The **flyweight** pattern teaches programmers how to minimize memory usage by
    sharing resources with similar objects as much as possible.'
  prefs: []
  type: TYPE_NORMAL
- en: Whenever we create a new object, extra memory needs to be allocated. Although
    virtual memory provides us, theoretically, with unlimited memory, the reality
    is different. If all the physical memory of a system gets exhausted, it will start
    swapping pages with the secondary storage – usually a **hard disk drive** (**HDD**)
    – which, in most cases, is unacceptable due to the performance differences between
    the main memory and the HDD. **Solid-state drives** (**SSDs**) generally have
    better performance than HDDs, but not everybody is expected to use SSDs. So, SSDs
    are not going to completely replace HDDs anytime soon.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from memory usage, performance is also a consideration. Graphics software,
    including computer games, should be able to render 3D information (for example,
    a forest with thousands of trees, a village full of soldiers, or an urban area
    with a lot of cars) extremely quickly. If each object in a 3D terrain is created
    individually and no data sharing is used, the performance will be prohibitive.
  prefs: []
  type: TYPE_NORMAL
- en: As software engineers, we should solve software problems by writing better software,
    instead of forcing the customer to buy extra or better hardware. The flyweight
    design pattern is a technique that's used to minimize memory usage and improve
    performance by introducing data sharing between similar objects ([http://j.mp/wflyw](http://j.mp/wflyw)).
    A flyweight is a shared object that contains state-independent, immutable (also
    known as **intrinsic**) data. The state-dependent, mutable (also known as **extrinsic**)
    data should not be part of the flyweight pattern because this information cannot
    be shared since it differs per object. If the flyweight pattern needs extrinsic
    data, it should be provided explicitly by the client code.
  prefs: []
  type: TYPE_NORMAL
- en: An example may help clarify how the flyweight pattern can be used practically.
    Let's assume that we are creating a performance-critical game, such as a **first-person
    shooter** (**FPS**). In FPS games, the players (soldiers) share some states, such
    as representation and behavior. In *Counter-Strike*, for instance, all the soldiers
    on the same team (counter-terrorists versus terrorists) look the same (representation).
    In the same game, all the soldiers (on both teams) have some common actions, such
    as *jump*, *duck*, and so forth (behavior). This means that we can create a flyweight
    that will contain all of the common data. Of course, the soldiers also have a
    lot of data that is different per soldier and will not be a part of the flyweight,
    such as weapons, health, and location.
  prefs: []
  type: TYPE_NORMAL
- en: '*What are other real-world examples of the flyweight pattern?* We will discuss
    them in the next section.'
  prefs: []
  type: TYPE_NORMAL
- en: Real-world examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Flyweight is an optimization design pattern. Therefore, it is not easy to find
    a good non-computing example of it. We can think of flyweight as caching in real
    life. For example, many bookstores have dedicated shelves containing the newest
    and most popular publications. This is a cache: first, you can look at the dedicated
    shelves for the book you are looking for, and if you cannot find it, you can ask
    the bookseller to assist you.'
  prefs: []
  type: TYPE_NORMAL
- en: The *Exaile* music player uses flyweight to reuse objects (in this case, music
    tracks) that are identified by the same URL. There's no point in creating a new
    object if it has the same URL as an existing object, so the same object is reused
    to save resources.
  prefs: []
  type: TYPE_NORMAL
- en: '*Peppy*, an XEmacs-like editor that''s implemented in Python, uses the flyweight
    pattern to store the state of a major mode status bar. That''s because, unless
    they''re modified by the user, all the status bars share the same properties.'
  prefs: []
  type: TYPE_NORMAL
- en: Use cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Flyweight is all about improving performance and memory usage. All embedded
    systems (phones, tablets, games consoles, microcontrollers, and so forth) and
    performance-critical applications (games, 3D graphics processing, real-time systems,
    and so forth) can benefit from it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *Gang of Four* (*GoF*) book lists the following requirements that need
    to be satisfied to effectively use the flyweight pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: The application needs to use many objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are so many objects that it's too expensive to store/render them. Once
    the mutable state is removed (because if it is required, it should be passed explicitly
    to the flyweight pattern by the client code), many groups of distinct objects
    can be replaced by relatively few shared objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object identity is not important for the application. We cannot rely on object
    identity because object sharing causes identity comparisons to fail (objects that
    appear different to the client code end up having the same identity).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let's look at our hands-on implementation of the flyweight pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's see how we can implement the example that we briefly mentioned in the
    introduction to this section for cars in an area. We will create a small car park
    to illustrate the idea, making sure that the whole output can be read on a single
    Terminal page. However, no matter how large you make the car park, the memory
    allocation stays the same.
  prefs: []
  type: TYPE_NORMAL
- en: Before diving into the code, let's spend a moment noting the differences between
    memoization and the flyweight pattern. **Memoization** is an optimization technique
    that uses a cache to avoid recomputing results that were already computed in an
    earlier execution step. Memoization does not focus on a specific programming paradigm
    such as **object-oriented programming** (**OOP**). In Python, memoization can
    be applied to both methods and simple functions. Flyweight is an OOP-specific
    optimization design pattern that focuses on sharing object data.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need an `Enum` parameter that describes the three different types
    of cars that are in the car park:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will define the class at the core of our implementation: `Car`. The
    `pool` variable is the object pool (in other words, our cache). Notice that `pool`
    is a class attribute (a variable that''s shared by all instances).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `__new__()` special method, which is called before `__init__()`,
    we are converting the `Car` class into a metaclass that supports self-references.
    This means that `cls` references the `Car` class. When the client code creates
    an instance of `Car`, it passes the type of the car as `car_type`. The car''s
    type is used to check if a car of the same type has already been created. If that''s
    the case, the previously created object is returned; otherwise, the new car type
    is added to the pool and returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `render()` method is what will be used to render a car on the screen. Notice
    how all the mutable information not known by flyweight needs to be explicitly
    passed by the client code. In this case, a random color and the coordinates of
    a location (of the *x, y* form) are used for each car.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, note that to make `render()` more useful, it is necessary to ensure that
    no cars are rendered on top of each other. Consider this as an exercise: if you
    want to make rendering more fun, you can use a graphics toolkit such as Tkinter,
    Pygame, or Kivy.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `render()` method is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `main()` function shows how we can use the flyweight pattern. The color
    of a car is a random value from a predefined list of colors. The coordinates use
    random values between `1` and `100`. As we will see shortly, although 18 cars
    are rendered, memory is only allocated for 3\. The last line of the output, which
    we will see later, proves that when using flyweight, we cannot rely on object
    identity.
  prefs: []
  type: TYPE_NORMAL
- en: The `id()` function returns the memory address of an object. This is not the
    default behavior in Python because, by default, `id()` returns a unique ID (the
    memory address of an object as an integer) for each object. In our case, even
    if two objects appear to be different, they have the same identity if they belong
    to the same flyweight family (in this case, the family is defined by `car_type`).
    Of course, different identity comparisons can still be used for objects of different
    families, but that is only possible if the client knows the implementation details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our example `main()` function''s code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the full code listing (the `flyweight.py` file) to show you how the
    flyweight pattern is implemented and used:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need a couple of imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `Enum` for the types of cars is shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we have the `Car` class, with its `pool` attribute and the `__new__()`
    and `render()` methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the first part of the `main` function, we define some variables and render
    a set of cars of the `subcompact` type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The second part of the `main` function is as follows, which renders another
    set of cars of the `compact` type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The third part of the `main` function is as follows, this time with `suv` cars:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, here is the fourth part of the `main` function, where we create three
    additional cars of the three types:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We do not forget our usual `__name__ == ''__main__''` trick and good practice,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The execution of the Python `flyweight.py` command shows the type, random color,
    and coordinates of the rendered objects, as well as the identity comparison results
    between flyweight objects of the same/different families:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Do not expect to see the same output since the colors and coordinates are random,
    and the object identities depend on the memory map.
  prefs: []
  type: TYPE_NORMAL
- en: This program marks the end of our discussion of the flyweight pattern. In the
    next section, we will learn about the MVC pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the model-view-controller pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The MVC pattern is useful mainly in application development and helps developers
    improve the maintainability of their applications by avoiding mixing the business
    logic with the user interface.
  prefs: []
  type: TYPE_NORMAL
- en: One of the design principles related to software engineering is the **separation
    of concerns** (**SoC**) principle. The idea behind the SoC principle is to split
    an application into distinct sections, where each section addresses a separate
    concern. Examples of such concerns are the layers that are used in a layered design
    (data access layer, business logic layer, presentation layer, and so forth). Using
    the SoC principle simplifies the development and maintenance of software applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'The MVC pattern is nothing more than the SoC principle applied to OOP. The
    name of the pattern comes from the three main components that are used to split
    a software application: the **model**, the **view**, and the **controller**. MVC
    is considered an architectural pattern rather than a design pattern. The difference
    between an architectural and a design pattern is that the former has a broader
    scope than the latter. Nevertheless, MVC is too important to skip just for this
    reason. Even if we will never have to implement it from scratch, we need to be
    familiar with it because all common frameworks use MVC or a slightly different
    version of it (more on this shortly).'
  prefs: []
  type: TYPE_NORMAL
- en: The model is the core component. It represents knowledge. It contains and manages
    the (business) logic, data, state, and rules of an application. The view is a
    visual representation of the model. Examples of views include a computer GUI,
    the text output of a computer terminal, a smartphone's application GUI, a PDF
    document, a pie chart, a bar chart, and so forth. The view only displays the data;
    it doesn't handle it. The controller is the link/glue between the model and view.
    All communication between the model and the view happens through a controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical use case for an application that uses MVC, after the initial screen
    is rendered for the user, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The user triggers a view by clicking (typing, touching, and so on) a button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The view informs the controller of the user's action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The controller processes user input and interacts with the model.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The model performs all the necessary validation and state changes and informs
    the controller about what should be done.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The controller instructs the view to update and display the output appropriately,
    following the instructions that are given by the model.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is summarized in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 23.1 — An MVC diagram for a typical computer program ](img/Figure_23.1_B17499.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 23.1 — An MVC diagram for a typical computer program
  prefs: []
  type: TYPE_NORMAL
- en: '*You might be wondering, why is the controller part necessary? Can''t we just
    skip it?* We could, but then we would lose a big benefit that MVC provides: the
    ability to use more than one view (even at the same time, if that''s what we want)
    without modifying the model. To achieve decoupling between the model and its representation,
    every view typically needs a controller. If the model communicated directly with
    a specific view, we wouldn''t be able to use multiple views (or at least, not
    in a clean and modular way).'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's see where the MVC pattern is used in the real world.
  prefs: []
  type: TYPE_NORMAL
- en: Real-world examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we mentioned previously, MVC is the SoC principle applied to OOP. The SoC
    principle is used a lot in real life. For example, if you build a new house, you
    usually assign different professionals to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Install the plumbing and electricity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Paint the house
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another example is a restaurant. In a restaurant, the waiters receive orders
    and serve dishes to the customers, but the meals are cooked by the chefs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In web development, several frameworks use the MVC idea:'
  prefs: []
  type: TYPE_NORMAL
- en: The **Web2py** framework ([http://j.mp/webtopy](http://j.mp/webtopy)) is a lightweight
    Python framework that embraces the MVC pattern. If you have never tried Web2py,
    I encourage you to do so since it is extremely simple to install. Many examples
    demonstrate how MVC can be used in Web2py on the project's web page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Django** is also an MVC framework, although it uses different naming conventions.
    The controller is called view, and the view is called **template**. Django uses
    the name **Model-Template-View** (**MTV**). According to the designers of Django,
    the view describes what data is seen by the user, so it uses the name view as
    the Python callback function for a particular URL. The term *template* in Django
    is used to separate content from its representation. It describes *how* the data
    is seen by the user, not *which* data is seen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we will detail the specific use cases of the MVC pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Use cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'MVC is a very generic and useful design pattern. All popular web frameworks
    (Django, Rails, and Symfony or Yii) and application frameworks (iPhone SDK, Android,
    and QT) make use of MVC or a variation of it – **model-view-adapter** (**MVA**),
    **model-view-presenter** (**MVP**), and so forth. However, even if we don''t use
    any of these frameworks, it makes sense to implement the pattern on our own because
    of the benefits it provides, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The separation between the view and model allows graphic designers to focus
    on the UI part and programmers to focus on development, without them interfering
    with each other.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because of the loose coupling between the view and the model, each part can
    be modified/extended without them affecting the other. For example, adding a new
    view is trivial – just implement a new controller for it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintaining each part is easier because the responsibilities are clear.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you implement MVC from scratch, ensure that you create smart models, thin
    controllers, and dumb views.
  prefs: []
  type: TYPE_NORMAL
- en: 'A model is considered smart because it does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Contains all the validation/business rules/logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handles the state of the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Has access to application data (database, cloud, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does not depend on the UI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A controller is considered thin because it does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Updates the model when the user interacts with the view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updates the view when the model changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processes the data before delivering it to the model/view, if necessary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does not display the data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does not access the application data directly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does not contain validation/business rules/logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A view is considered dumb because it does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Displays the data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allows the user to interact with it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does only minimal processing, usually provided by a template language (for example,
    using simple variables and loop controls)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does not store any data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does not access the application data directly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does not contain validation/business rules/logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you are implementing MVC from scratch and want to find out if you did it
    right, you can try answering some key questions:'
  prefs: []
  type: TYPE_NORMAL
- en: '*If your application has a GUI, is it skinnable? How easily can you change
    the skin/look and feel of it? Can you give the user the ability to change the
    skin of your application during runtime?* If these tasks cannot be done easily,
    it means that something is going wrong with your MVC implementation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*If your application has no GUI (for instance, if it''s a terminal application),
    how hard is it to add GUI support? Or, if adding a GUI is irrelevant, is it easy
    to add views to display the results in a chart (pie chart, bar chart, and so on)
    or a document (PDF, spreadsheet, and so on)?* If these changes are not trivial
    (a matter of creating a new controller with a view attached to it, without modifying
    the model), MVC has not been implemented properly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you make sure that these conditions are satisfied, your application will
    be more flexible and maintainable compared to an application that does not use
    MVC. We'll look at an example of this in the next section, where we will implement
    an application to maintain a collection of quotes.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I could use any of the common frameworks to demonstrate how to use MVC, but
    I feel that the picture would be incomplete. So, I have decided to show you how
    to implement MVC from scratch using a very simple example: a quote printer. The
    idea is extremely simple. The user enters a number and sees the quote related
    to that number. The quotes are stored in a `quotes` tuple. This is the data that
    normally exists in a database, a file, and so on, and only the model has direct
    access to it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The model is minimalistic; it only has a `get_quote()` method that returns
    the quote (string) of the `quotes` tuple based on its index, *n*. Note that *n*
    can be less than or equal to `0`, due to the way indexing works in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The view has three methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Show()`, which is used to print a quote (or the message; that is, `Not found!`)
    on the screen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`error()`, which is used to print an error message on the screen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`select_quote()`, which reads the user''s selection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This can be seen in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The controller does the coordination. The `__init__()` method initializes the
    model and view. The `run()` method validates the quoted index that''s been given
    by the user, gets the quote from the model, and passes it back to the view to
    be displayed, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Last but not least, the `main()` function initializes and fires the controller,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the complete workflow for this example (the `mvc.py` file):'
  prefs: []
  type: TYPE_NORMAL
- en: We start by defining a variable for the list of quotes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We implement the model class, `QuoteModel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we implement the view class, `QuoteTerminalView`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we implement the controller class, `QuoteTerminalController`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the end of our example code with the `main()` function, we initialize and
    run the controller.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following sample execution of the Python `mvc.py` command shows how the
    program prints out quotes for the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that everything is working as intended!
  prefs: []
  type: TYPE_NORMAL
- en: 'And with that, we will move on to the last topic of this chapter: the proxy
    pattern.'
  prefs: []
  type: TYPE_NORMAL
- en: Applying the proxy pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In some applications, we want to execute one or more important actions before
    accessing an object. This is where the **proxy pattern** comes in. An example
    is accessing sensitive information. Before we allow any user to access sensitive
    information, we want to make sure that the user has sufficient privileges. The
    important action is not necessarily related to security issues. **Lazy initialization**
    ([http://j.mp/wikilazy](http://j.mp/wikilazy)) is another case; we want to delay
    the creation of a computationally expensive object until the first time the user
    needs to use it. The idea of the proxy pattern is to help with performing such
    an action before accessing the actual object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The proxy design pattern gets its name from the *proxy* (also known as *surrogate*)
    object, which is used to perform an important action before the actual object
    is accessed. There are four different well-known proxy types ([http://j.mp/proxypat](http://j.mp/proxypat)).
    They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A **remote proxy**, which acts as the local representation of an object that
    exists in a different address space (for example, a network server).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **virtual proxy**, which uses lazy initialization to defer the creation of
    a computationally expensive object until the moment it is needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **protection/protective proxy**, which controls access to a sensitive object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **smart (reference) proxy**, which performs extra actions when an object is
    accessed. Examples of such actions include reference counting and thread-safety
    checks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I find virtual proxies very useful, so let's look at an example of how we can
    implement them in Python right now. In the *Implementation* subsection of this
    section, you will learn how to create protective proxies.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many ways to create a virtual proxy in Python, but I always like
    focusing on the idiomatic/Pythonic implementations. The code shown here is based
    on the great answer by Cyclone, a user of the following site: [http://stackoverflow.com/](http://stackoverflow.com/)
    ([http://j.mp/solazyinit](http://j.mp/solazyinit)). To avoid confusion, I should
    clarify that in this section, the terms *property*, *variable*, and *attribute*
    are used interchangeably.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we must create a `LazyProperty` class that can be used as a decorator.
    When it decorates a property, `LazyProperty` loads the property lazily (on the
    first use), instead of instantly. The `__init__()` method creates two variables
    that are used as aliases to the method that initializes a property. The `method`
    variable is an alias to the actual method, while the `method_name` variable is
    an alias to the method''s name. To get a better understanding of how the two aliases
    are used, print their values to the output (uncomment the two commented lines
    in the following code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `LazyProperty` class is a descriptor ([http://j.mp/pydesc](http://j.mp/pydesc)).
    Descriptors are the recommended mechanisms to use in Python to override the default
    behavior of its attribute access methods: `__get__()`, `__set__()`, and `__delete__()`.
    The `LazyProperty` class only overrides `__set__()` because that is the only access
    method it needs to override. In other words, we don''t have to override all the
    access methods. The `__get__()` method accesses the value of the property the
    underlying method wants to assign and uses `setattr()` to do the assignment manually.'
  prefs: []
  type: TYPE_NORMAL
- en: 'What `__get()__`does is very neat: it replaces the method with the value! This
    means that not only is the property lazily loaded, but it can also only be set
    once. We will see what this means in a moment. Again, uncomment the commented
    line in the following code to get some extra information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Test` class shows how we can use the `LazyProperty` class. There are three
    attributes: `x`, `y`, and `_resource`. We want the `_resource` variable to be
    loaded lazily; thus, we must initialize it to `None`, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `resource()` method is decorated with the `LazyProperty` class. For demonstration
    purposes, the `LazyProperty` class initializes the `_resource` attribute as a
    tuple, as shown in the following code. Normally, this would be a slow/expensive
    initialization process (database, graphics, and so on):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `main()` function, as follows, shows how lazy initialization behaves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Notice how overriding the `__get()__` access method makes it possible to treat
    the `resource()` method as a simple attribute (we can use `t.resource` instead
    of `t.resource()`).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the execution output of this example (the `lazy.py` file), we can see the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `_resource` variable is initialized not by the time the `t` instance is
    created, but the first time that we use `t.resource`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second time `t.resource` is used, the variable is not initialized again.
    That's why the initialization string that's initializing `self._resource` is shown
    only once.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is the output we get when we execute the Python `lazy.py` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two basic, different kinds of lazy initialization in OOP. They are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**At the instance level**: This means that an object''s property is initialized
    lazily, but the property has an object scope. Each instance (object) of the same
    class has its own (different) copy of the property.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**At the class or module level**: In this case, we do not want a different
    copy per instance, but all the instances share the same property, which is lazily
    initialized. This case is not covered in this chapter. If you find it interesting,
    consider it as an exercise.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let's see what real-world examples follow the proxy pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Real-world examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Chip** (also known as **Chip and PIN**) cards ([http://j.mp/wichpin](http://j.mp/wichpin))
    offer a good example of how a protective proxy is used in real life. A debit/credit
    card contains a chip that needs to be read by the ATM or card reader. Once the
    chip has been verified, a password (PIN) is required to complete the transaction.
    This means that you cannot make any transactions without physically presenting
    the card and knowing the PIN.'
  prefs: []
  type: TYPE_NORMAL
- en: A bank check, which is used instead of cash to make purchases and deals, is
    an example of a remote proxy. The check gives access to a bank account.
  prefs: []
  type: TYPE_NORMAL
- en: In software, the `weakref` module of Python contains a `proxy()` method, which
    accepts an input object and returns a smart proxy to it. Weak references are the
    recommended way to add reference-counting support to an object.
  prefs: []
  type: TYPE_NORMAL
- en: Use cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since there are at least four common proxy types, the proxy design pattern
    has many use cases, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It is used to create a distributed system using either a private network or
    the cloud. In a distributed system, some objects exist in the local memory, while
    other objects exist in the memory of remote computers. If we don't want the client
    code to be aware of such differences, we can create a remote proxy that hides/encapsulates
    them, making the distributed nature of the application transparent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is used when our application is suffering from performance issues due to
    the early creation of expensive objects. Introducing lazy initialization using
    a virtual proxy to create the objects only at the moment they are required can
    give us significant performance improvements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is used to check if a user has sufficient privileges to access a piece of
    information. If our application handles sensitive information (for example, medical
    data), we want to make sure that the user who's trying to access/modify it is
    allowed to do so. A protection/protective proxy can handle all security-related
    actions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is used when our application (or library, toolkit, framework, and so forth)
    uses multiple threads and we want to move the burden of thread safety from the
    client code to the application. In this case, we can create a smart proxy to hide
    the thread-safety complexities from the client.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An **object-relational mapping** (**ORM**) API is also an example of how to
    use a remote proxy. Many popular web frameworks, including Django, use an ORM
    to provide OOP-like access to a relational database. An ORM acts as a proxy to
    a relational database that can be located anywhere, either at a local or remote
    server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let's apply the proxy pattern to build a simple interface that provides
    example users' information.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To demonstrate the proxy pattern, we will implement a simple protection proxy
    to view and add users. The service provides two options:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Viewing the list of users**: This operation does not require special privileges.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Adding a new user**: This operation requires the client to provide a special
    secret message.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `SensitiveInfo` class contains the information that we want to protect.
    The `users` variable contains the list of existing users. The `read()` method
    prints the list of users. The `add()` method adds a new user to the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Info` class is a protection proxy of `SensitiveInfo`. The `secret` variable
    is the message that''s required to be known/provided by the client code to add
    a new user. Note that this is just an example. In reality, you should never do
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Store passwords in the source code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Store passwords in a cleartext form
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a weak (for example, MD5) or custom form of encryption
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the `Info` class, as shown in the following code, the `read()` method is
    a wrapper to `SensitiveInfo.read()`, and the `add()` method ensures that a new
    user can only be added if the client code knows the secret message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `main()` function shows how the proxy pattern can be used by the client
    code. The client code creates an instance of the `Info` class and uses the displayed
    menu to read the list, add a new user, or exit the application. Let''s consider
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the sample output of the program when executing the Python
    `proxy.py` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '*Have you already spotted flaws or missing features that could improve our
    proxy example?* I have a few suggestions. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: This example has a very big security flaw. Nothing prevents the client code
    from bypassing the security of the application by creating an instance of `SensitiveInfo`
    directly. Improve this example to prevent this situation. One way to do this is
    to use the `abc` module to forbid direct instantiation of `SensitiveInfo`. *What
    other code changes are required in this case?*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A basic security rule is that we should never store cleartext passwords. Storing
    a password safely is not very hard, so long as we know which libraries to use
    ([http://j.mp/hashsec](http://j.mp/hashsec)). If you are interested in security,
    try to implement a secure way to store the secret message externally (for example,
    in a file or database).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The application only supports adding new users, but what about removing an
    existing user?* Add a `remove()` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we covered three other structural design patterns: flyweight,
    MVC, and proxy. Throughout this chapter, we learned about the differences between
    these and the other structural patterns we have discussed. Then, we implemented
    each of these patterns in hands-on examples. As we saw, the flyweight pattern
    is designed for memory usage minimization, the MVC pattern maintains a logical
    organization of different parts of an application, and the proxy pattern is typically
    used when sensitive information is accessed.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will start exploring behavioral design patterns. Behavioral
    patterns cope with object interconnection and algorithms. The first behavioral
    pattern we will cover is the chain of responsibility.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the main motivation for the flyweight pattern?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the main motivation for the MVC pattern?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the main motivation for the proxy pattern?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
