- en: '*Chapter 19*: The Adapter Pattern'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, we covered creational patterns, which are **Object-Oriented
    Programming** (**OOP**) patterns that help us with object creation procedures.
    The next category of patterns we want to present is **structural design patterns**.
  prefs: []
  type: TYPE_NORMAL
- en: A structural design pattern proposes a way of composing objects to create new
    functionality. The first of these patterns we will cover is the **adapter** pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the adapter pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Real-world examples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you will know how to use this design pattern to create
    interfaces that could help application layers that otherwise could not communicate.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code files for this chapter can be accessed through this link: [https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter19](https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter19).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the adapter pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The adapter pattern is a structural design pattern that helps us make two incompatible
    interfaces compatible. *What does that really mean?* If we have an old component
    and we want to use it in a new system, or a new component that we want to use
    in an old system, the two can rarely communicate without requiring code changes.
    But changing the code is not always possible, either because we don't have access
    to it or because it is impractical. In such cases, we can write an extra layer
    that makes all the required modifications for enabling communication between the
    two interfaces. This layer is called an *adapter*.
  prefs: []
  type: TYPE_NORMAL
- en: To further understand this design pattern, let's consider some real-life examples.
  prefs: []
  type: TYPE_NORMAL
- en: Real-world examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you are traveling from most European countries to the UK or US, or the
    other way around, you need to use a plug adapter for charging your laptop. Another
    kind of adapter is needed for connecting some devices to your computer: a USB
    adapter.'
  prefs: []
  type: TYPE_NORMAL
- en: In the software category, the Zope application server ([http://www.zope.org](http://www.zope.org))
    is known for its **Zope Component Architecture** (**ZCA**), which contributed
    to the implementation of interfaces and adapters used by several big Python web
    projects. *Pyramid*, built by former Zope developers, is a Python web framework
    that took good ideas from Zope to provide a more modular approach for developing
    web apps. Pyramid uses adapters to make it possible for existing objects to conform
    to specific APIs without the need to modify them. Another project from the Zope
    ecosystem, *Plone CMS*, uses adapters under the hood.
  prefs: []
  type: TYPE_NORMAL
- en: Use cases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Usually, one of the two incompatible interfaces is either foreign or old/legacy.
    If the interface is foreign, it means that we have no access to the source code.
    If it is old, it is usually impractical to refactor it.
  prefs: []
  type: TYPE_NORMAL
- en: Using an adapter to make things work after they have been implemented is a good
    approach because it does not require access to the source code of the foreign
    interface. It is also often a pragmatic solution if we have to reuse some legacy
    code.
  prefs: []
  type: TYPE_NORMAL
- en: With that, let's start implementing a hands-on application in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's look at a relatively simple application to illustrate the concept of adaptation.
    Consider an example of a club's activities. It mainly needs to organize performances
    and events for the entertainment of its clients, by hiring talented artists.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the core, we have a `Club` class that represents the club where hired artists
    perform some evenings. The `organize_performance()` method is the main action
    that the club can perform. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Most of the time, our club hires a DJ to perform, but our application addresses
    the need to organize a diverse range of performances by a musician or music band,
    a dancer, a one-man or one-woman show, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Through our research to try and reuse existing code, we find an open source
    contributed library that brings us two interesting classes: `Musician` and `Dancer`.
    In the `Musician` class, the main action is performed by the `play()` method.
    In the `Dancer` class, it is performed by the `dance()` method.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, to indicate that these two classes are external, we place them
    in a separate module. The code for the `Musician` class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the `Dancer` class is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The client code, using these classes, only knows how to call the `organize_performance()`
    method (on the `Club` class); it has no idea about `play()` or `dance()` (on the
    respective classes from the external library).
  prefs: []
  type: TYPE_NORMAL
- en: '*How can we make the code work without changing the* `Musician` *and* `Dancer`
    *classes?*'
  prefs: []
  type: TYPE_NORMAL
- en: Adapters to the rescue! We create a generic `Adapter` class that allows us to
    adapt several objects with different interfaces into one unified interface. The
    `obj` argument of the `__init__()` method is the object that we want to adapt,
    and `adapted_methods` is a dictionary containing key/value pairs matching the
    method the client calls and the method that should be called.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for the `Adapter` class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'When dealing with different instances of the classes, we have two cases:'
  prefs: []
  type: TYPE_NORMAL
- en: The compatible object that belongs to the `Club` class needs no adaptation.
    We can treat it as it is.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The incompatible objects need to be adapted first, using the `Adapter` class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The result is that the client code can continue using the known `organize_performance()`
    method on all objects without the need to be aware of any interface differences
    between the used classes. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s recapitulate the complete code of our adapter pattern implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: We define the `Musician` and `Dancer` classes (in `external.py`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, we need to import those classes from the external module (in `adapter.py`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We then define the `Adapter` class (in `adapter.py`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We add the `main()` function, as shown earlier, and the usual trick to call
    it (in `adapter.py`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is the output when executing the `python adapter.py` command, as usual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we managed to make the `Musician` and `Dancer` classes compatible
    with the interface expected by the client, without changing their source code.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covered the adapter design pattern. The adapter makes things work
    after they have been implemented. The Pyramid web framework, the Plone CMS, and
    other Zope-based or related frameworks use the adapter pattern to achieve interface
    compatibility. In the *Implementation* section, we saw how to achieve interface
    conformance using the adapter pattern without modifying the source code of the
    incompatible model. This is achieved through a generic `Adapter` class that does
    the work for us.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, we could use the adapter pattern to make two (or more) incompatible
    interfaces compatible, which has a lot of usage in software engineering.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover the decorator pattern.
  prefs: []
  type: TYPE_NORMAL
