- en: '*Chapter 19*: The Adapter Pattern'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第19章*：适配器模式'
- en: In previous chapters, we covered creational patterns, which are **Object-Oriented
    Programming** (**OOP**) patterns that help us with object creation procedures.
    The next category of patterns we want to present is **structural design patterns**.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们介绍了创建型模式，这些是**面向对象编程**（**OOP**）模式，帮助我们处理对象创建过程。我们接下来要介绍的下一个模式类别是**结构型设计模式**。
- en: A structural design pattern proposes a way of composing objects to create new
    functionality. The first of these patterns we will cover is the **adapter** pattern.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 结构型设计模式提出了一种组合对象以创建新功能的方法。我们将要介绍的第一个模式是**适配器**模式。
- en: 'In this chapter, we will discuss the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Understanding the adapter pattern
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解适配器模式
- en: Real-world examples
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现实世界示例
- en: Use cases
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用例
- en: Implementation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现
- en: By the end of the chapter, you will know how to use this design pattern to create
    interfaces that could help application layers that otherwise could not communicate.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将知道如何使用这种设计模式来创建接口，这些接口可以帮助那些否则无法通信的应用层。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code files for this chapter can be accessed through this link: [https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter19](https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter19).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以通过以下链接访问：[https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter19](https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter19).
- en: Understanding the adapter pattern
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解适配器模式
- en: The adapter pattern is a structural design pattern that helps us make two incompatible
    interfaces compatible. *What does that really mean?* If we have an old component
    and we want to use it in a new system, or a new component that we want to use
    in an old system, the two can rarely communicate without requiring code changes.
    But changing the code is not always possible, either because we don't have access
    to it or because it is impractical. In such cases, we can write an extra layer
    that makes all the required modifications for enabling communication between the
    two interfaces. This layer is called an *adapter*.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器模式是一种结构型设计模式，它帮助我们使两个不兼容的接口兼容。*这究竟意味着什么？*如果我们有一个旧的组件，我们想在新的系统中使用它，或者我们想在旧系统中使用的新组件，这两个组件很少能够通信而不需要代码更改。但是改变代码并不总是可能的，要么因为我们没有访问权限，要么因为这是不切实际的。在这种情况下，我们可以编写一个额外的层，它会对两个接口之间的通信所需的所有修改进行必要的修改。这个层被称为*适配器*。
- en: To further understand this design pattern, let's consider some real-life examples.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步理解这种设计模式，让我们考虑一些现实生活中的例子。
- en: Real-world examples
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现实世界示例
- en: 'When you are traveling from most European countries to the UK or US, or the
    other way around, you need to use a plug adapter for charging your laptop. Another
    kind of adapter is needed for connecting some devices to your computer: a USB
    adapter.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当你从大多数欧洲国家前往英国或美国，或者相反方向旅行时，你需要使用一个插头适配器来给你的笔记本电脑充电。另一种适配器是用于将某些设备连接到你的电脑：USB适配器。
- en: In the software category, the Zope application server ([http://www.zope.org](http://www.zope.org))
    is known for its **Zope Component Architecture** (**ZCA**), which contributed
    to the implementation of interfaces and adapters used by several big Python web
    projects. *Pyramid*, built by former Zope developers, is a Python web framework
    that took good ideas from Zope to provide a more modular approach for developing
    web apps. Pyramid uses adapters to make it possible for existing objects to conform
    to specific APIs without the need to modify them. Another project from the Zope
    ecosystem, *Plone CMS*, uses adapters under the hood.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件类别中，Zope应用程序服务器（[http://www.zope.org](http://www.zope.org)）因其**Zope组件架构**（**ZCA**）而闻名，它有助于实现接口和适配器，这些接口被几个大型Python网络项目所使用。由前Zope开发者构建的*Pyramid*是一个Python网络框架，它从Zope中吸取了好的想法，为开发Web应用提供了一种更模块化的方法。Pyramid使用适配器使得现有的对象能够符合特定的API，而无需对其进行修改。Zope生态系统中的另一个项目，*Plone
    CMS*，在底层使用适配器。
- en: Use cases
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用例
- en: Usually, one of the two incompatible interfaces is either foreign or old/legacy.
    If the interface is foreign, it means that we have no access to the source code.
    If it is old, it is usually impractical to refactor it.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，两个不兼容的接口中有一个是外来的，或者是旧的/遗留的。如果接口是外来的，这意味着我们没有访问源代码。如果是旧的，通常重构它是不可行的。
- en: Using an adapter to make things work after they have been implemented is a good
    approach because it does not require access to the source code of the foreign
    interface. It is also often a pragmatic solution if we have to reuse some legacy
    code.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 使用适配器在实现后使事物工作是一种好的方法，因为它不需要访问外部接口的源代码。如果我们必须重用一些旧代码，这通常也是一个实用的解决方案。
- en: With that, let's start implementing a hands-on application in Python.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，让我们开始用Python实现一个动手应用。
- en: Implementation
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现
- en: Let's look at a relatively simple application to illustrate the concept of adaptation.
    Consider an example of a club's activities. It mainly needs to organize performances
    and events for the entertainment of its clients, by hiring talented artists.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个相对简单的应用来阐述适配的概念。考虑一个俱乐部的活动示例。它主要需要通过雇佣有才华的艺术家来组织表演和活动，以娱乐其客户。
- en: 'At the core, we have a `Club` class that represents the club where hired artists
    perform some evenings. The `organize_performance()` method is the main action
    that the club can perform. The code is as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在核心上，我们有一个`Club`类，它代表俱乐部，聘请的艺术家在某个晚上进行表演。`organize_performance()`方法是俱乐部可以执行的主要动作。代码如下：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Most of the time, our club hires a DJ to perform, but our application addresses
    the need to organize a diverse range of performances by a musician or music band,
    a dancer, a one-man or one-woman show, and so on.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，我们的俱乐部会雇佣DJ进行表演，但我们的应用解决了组织由音乐家或音乐乐队、舞者、单口或单场表演等多种表演的需求。
- en: 'Through our research to try and reuse existing code, we find an open source
    contributed library that brings us two interesting classes: `Musician` and `Dancer`.
    In the `Musician` class, the main action is performed by the `play()` method.
    In the `Dancer` class, it is performed by the `dance()` method.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 通过我们的研究尝试重用现有代码，我们发现了一个开源贡献的库，它为我们带来了两个有趣的类：`Musician`和`Dancer`。在`Musician`类中，主要动作是通过`play()`方法执行的。在`Dancer`类中，是通过`dance()`方法执行的。
- en: 'In our example, to indicate that these two classes are external, we place them
    in a separate module. The code for the `Musician` class is as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，为了表明这两个类是外部的，我们将它们放在一个单独的模块中。`Musician`类的代码如下：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, the `Dancer` class is defined as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`Dancer`类的定义如下：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The client code, using these classes, only knows how to call the `organize_performance()`
    method (on the `Club` class); it has no idea about `play()` or `dance()` (on the
    respective classes from the external library).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端代码使用这些类，只知道如何调用`organize_performance()`方法（在`Club`类上）；它对`play()`或`dance()`（在外部库的相应类上）一无所知。
- en: '*How can we make the code work without changing the* `Musician` *and* `Dancer`
    *classes?*'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们如何在不改变* `Musician` *和* `Dancer` *类的情况下使代码工作？*'
- en: Adapters to the rescue! We create a generic `Adapter` class that allows us to
    adapt several objects with different interfaces into one unified interface. The
    `obj` argument of the `__init__()` method is the object that we want to adapt,
    and `adapted_methods` is a dictionary containing key/value pairs matching the
    method the client calls and the method that should be called.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器来拯救！我们创建了一个通用的`Adapter`类，它允许我们将具有不同接口的多个对象适配到一个统一的接口。`__init__()`方法的`obj`参数是我们想要适配的对象，而`adapted_methods`是一个包含键/值对的字典，这些键/值对匹配客户端调用的方法和应该调用的方法。
- en: 'The code for the `Adapter` class is as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`Adapter`类的代码如下：'
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When dealing with different instances of the classes, we have two cases:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理不同类的实例时，我们有两种情况：
- en: The compatible object that belongs to the `Club` class needs no adaptation.
    We can treat it as it is.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属于`Club`类的兼容对象不需要适配。我们可以将其视为原样。
- en: The incompatible objects need to be adapted first, using the `Adapter` class.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要先使用`Adapter`类来适配不兼容的对象。
- en: 'The result is that the client code can continue using the known `organize_performance()`
    method on all objects without the need to be aware of any interface differences
    between the used classes. Consider the following code:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，客户端代码可以继续在所有对象上使用已知的`organize_performance()`方法，而无需意识到所使用类之间的任何接口差异。考虑以下代码：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s recapitulate the complete code of our adapter pattern implementation:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下我们适配器模式实现的完整代码：
- en: We define the `Musician` and `Dancer` classes (in `external.py`).
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了`Musician`和`Dancer`类（在`external.py`中）。
- en: 'Then, we need to import those classes from the external module (in `adapter.py`):'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要从外部模块（在`adapter.py`中）导入这些类：
- en: '[PRE5]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We then define the `Adapter` class (in `adapter.py`).
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们随后定义`Adapter`类（在`adapter.py`中）。
- en: We add the `main()` function, as shown earlier, and the usual trick to call
    it (in `adapter.py`).
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加了`main()`函数，如前所述，以及通常的调用它的技巧（在`adapter.py`中）。
- en: 'Here is the output when executing the `python adapter.py` command, as usual:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是执行`python adapter.py`命令时的输出，就像往常一样：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, we managed to make the `Musician` and `Dancer` classes compatible
    with the interface expected by the client, without changing their source code.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们成功使`Musician`和`Dancer`类与客户端期望的接口兼容，而无需更改它们的源代码。
- en: Summary
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter covered the adapter design pattern. The adapter makes things work
    after they have been implemented. The Pyramid web framework, the Plone CMS, and
    other Zope-based or related frameworks use the adapter pattern to achieve interface
    compatibility. In the *Implementation* section, we saw how to achieve interface
    conformance using the adapter pattern without modifying the source code of the
    incompatible model. This is achieved through a generic `Adapter` class that does
    the work for us.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了适配器设计模式。适配器使得在实现之后的事物能够工作。Pyramid Web框架、Plone CMS以及其他基于Zope或相关框架使用适配器模式来实现接口兼容性。在*实现*部分，我们看到了如何使用适配器模式来实现接口一致性，而无需修改不兼容模型的源代码。这是通过一个通用的`Adapter`类来完成的，它为我们做了这项工作。
- en: Overall, we could use the adapter pattern to make two (or more) incompatible
    interfaces compatible, which has a lot of usage in software engineering.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来说，我们可以使用适配器模式使两个（或更多）不兼容的接口兼容，这在软件工程中有许多用途。
- en: In the next chapter, we will cover the decorator pattern.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍装饰器模式。
