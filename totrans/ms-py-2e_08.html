<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer137" class="Basic-Text-Frame">&#13;
    <h1 class="chapterNumber">8</h1>&#13;
    <h1 id="_idParaDest-195" class="chapterTitle">Metaclasses – Making Classes (Not Instances) Smarter</h1>&#13;
    <p class="normal">The previous chapters have already shown us how to modify classes and functions using decorators. But that’s not the only option to modify or extend a class. An even more advanced technique for modifying your classes before creation is the usage of metaclasses. The name already gives you a hint as to what it could be; a metaclass is a class containing meta information about a class. </p>&#13;
    <p class="normal">The basic premise of a metaclass is a class that generates another class for you at definition time, so generally you wouldn’t use it to change the class instances, but only the class definitions. By changing the class definitions, it is possible to automatically add some properties to a class, validate whether certain properties are set, change inheritance, automatically register the class with a manager, and many other things.</p>&#13;
    <p class="normal">Although metaclasses are generally considered to be a more powerful technique than (class) decorators, effectively they don’t differ too much in possibilities. The choice usually comes down to either convenience or personal preference.</p>&#13;
    <p class="normal">In this chapter, we will cover the following topics:</p>&#13;
    <ul>&#13;
      <li class="bulletList">Basic dynamic class creation</li>&#13;
      <li class="bulletList">Metaclasses with arguments</li>&#13;
      <li class="bulletList">Abstract base classes, examples, and inner workings</li>&#13;
      <li class="bulletList">Automatic plugin systems using metaclasses</li>&#13;
      <li class="bulletList">Internals of class creation and the order of operations</li>&#13;
      <li class="bulletList">Storing the definition order of class attributes</li>&#13;
    </ul>&#13;
    <h1 id="_idParaDest-196" class="heading-1">Dynamically creating classes</h1>&#13;
    <p class="normal">Metaclasses are<a id="_idIndexMarker537"/> the factories that create new classes in Python. In fact, even though you may not be aware of it, Python will always execute the <code class="inlineCode">type</code> metaclass whenever you create a class.</p>&#13;
    <p class="normal">A few common examples where metaclasses are used internally are <code class="inlineCode">abc</code> (abstract base classes), <code class="inlineCode">dataclasses</code>, and the Django framework, which <a id="_idIndexMarker538"/>heavily relies on metaclasses for the <code class="inlineCode">Model</code> class.</p>&#13;
    <p class="normal">When creating classes in a procedural way, the <code class="inlineCode">type</code> metaclass is used as a function that takes three arguments: <code class="inlineCode">name</code>, <code class="inlineCode">bases</code>, and <code class="inlineCode">dict</code>.<code class="inlineCode">name</code> will become the <code class="inlineCode">__name__</code> attribute, <code class="inlineCode">bases</code> is the list of inherited base classes and will be stored in <code class="inlineCode">__bases__</code>, and <code class="inlineCode">dict</code> is the namespace dictionary that contains all variables and will be stored in <code class="inlineCode">__dict__</code>.</p>&#13;
    <p class="normal">It should be noted that the <code class="inlineCode">type()</code> function has another use as well. Given the arguments documented above, it will create a class with those specifications. Given a single argument with the instance of a class (for example, <code class="inlineCode">type(spam)</code>), it will return the class object/definition.</p>&#13;
    <p class="normal">Your next question might be, what happens if I call <code class="inlineCode">type()</code> on a class definition instead of a class instance? Well, that returns the metaclass for the class, which is <code class="inlineCode">type</code> by default.</p>&#13;
    <p class="normal">Let’s clarify this using a few examples:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">Spam</span><span class="hljs-con-class">(</span><span class="hljs-con-built_in">object</span><span class="hljs-con-class">):</span>&#13;
<span class="hljs-con-meta">...</span>     eggs = <span class="hljs-con-string">'my eggs'</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> Spam = <span class="hljs-con-built_in">type</span>(<span class="hljs-con-string">'Spam'</span>, (<span class="hljs-con-built_in">object</span>,), <span class="hljs-con-built_in">dict</span>(eggs=<span class="hljs-con-string">'my eggs'</span>))&#13;
</code></pre>&#13;
    <p class="normal">The above two definitions of <code class="inlineCode">Spam</code> are completely identical; they both create a class with an instantiated property of <code class="inlineCode">eggs</code> and <code class="inlineCode">object</code> as a base. Let’s test whether this actually works as you would expect:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">Spam</span><span class="hljs-con-class">(</span><span class="hljs-con-built_in">object</span><span class="hljs-con-class">):</span>&#13;
<span class="hljs-con-meta">...</span>     eggs = <span class="hljs-con-string">'my eggs'</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> spam = Spam()&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> spam.eggs&#13;
'my eggs'&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">type</span>(spam)&#13;
&lt;class ' ...Spam'&gt;&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">type</span>(Spam)&#13;
&lt;class 'type'&gt;&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> Spam = <span class="hljs-con-built_in">type</span>(<span class="hljs-con-string">'Spam'</span>, (<span class="hljs-con-built_in">object</span>,), <span class="hljs-con-built_in">dict</span>(eggs=<span class="hljs-con-string">'my eggs'</span>))&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> spam = Spam()&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> spam.eggs&#13;
'my eggs'&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">type</span>(spam)&#13;
&lt;class '...Spam'&gt;&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">type</span>(Spam)&#13;
&lt;class 'type'&gt;&#13;
</code></pre>&#13;
    <p class="normal">As expected, the<a id="_idIndexMarker539"/> results for the two are the same. When creating a class, Python will silently add the <code class="inlineCode">type</code> metaclass, and custom metaclasses are classes that inherit <code class="inlineCode">type</code>. A simple class definition has a silent metaclass, making a simple definition such as:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Spam</span><span class="hljs-class">(</span><span class="hljs-built_in">object</span><span class="hljs-class">):</span>&#13;
    <span class="hljs-keyword">pass</span>&#13;
</code></pre>&#13;
    <p class="normal">essentially identical to:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Spam</span><span class="hljs-class">(</span><span class="hljs-built_in">object</span><span class="hljs-params">, metaclass=</span><span class="hljs-built_in">type</span><span class="hljs-class">):</span>&#13;
    <span class="hljs-keyword">pass</span>&#13;
</code></pre>&#13;
    <p class="normal">This raises the question: if every class is created by a (silent) metaclass, what is the metaclass of <code class="inlineCode">type</code>? This is a recursive definition; the metaclass of <code class="inlineCode">type</code> is <code class="inlineCode">type</code>. That is the essence of what a custom metaclass is: a class that inherits <code class="inlineCode">type</code> to allow class modification without needing to modify the class definition itself.</p>&#13;
    <h1 id="_idParaDest-197" class="heading-1">A basic metaclass</h1>&#13;
    <p class="normal">Since metaclasses can<a id="_idIndexMarker540"/> modify any class attribute, you can do absolutely anything you wish. Before we continue with more advanced metaclasses, let’s create a metaclass that does the following:</p>&#13;
    <ol class="numberedList" style="list-style-type: decimal;">&#13;
      <li class="numberedList" value="1">Makes the class inherit <code class="inlineCode">int</code></li>&#13;
      <li class="numberedList">Adds a <code class="inlineCode">lettuce</code> attribute to the class</li>&#13;
      <li class="numberedList">Changes the name of the class</li>&#13;
    </ol>&#13;
    <p class="normal">First we create the<a id="_idIndexMarker541"/> metaclass. After that, we create a class both with and without the metaclass:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-comment"># The metaclass definition, note the inheritance of type instead</span>&#13;
<span class="hljs-con-comment"># of object</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">MetaSandwich</span><span class="hljs-con-class">(</span><span class="hljs-con-built_in">type</span><span class="hljs-con-class">):</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-comment"># Notice how the __new__ method has the same arguments</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-comment"># as the type function we used earlier?</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__new__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">metaclass, name, bases, namespace</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>         name = <span class="hljs-con-string">'SandwichCreatedByMeta'</span>&#13;
<span class="hljs-con-meta">...</span>         bases = (<span class="hljs-con-built_in">int</span>,) + bases&#13;
<span class="hljs-con-meta">...</span>         namespace[<span class="hljs-con-string">'lettuce'</span>] = <span class="hljs-con-number">1</span>&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">return</span> <span class="hljs-con-built_in">type</span>.__new__(metaclass, name, bases, namespace)&#13;
</code></pre>&#13;
    <p class="normal">First, the regular Sandwich:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">Sandwich</span><span class="hljs-con-class">(</span><span class="hljs-con-built_in">object</span><span class="hljs-con-class">):</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">pass</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> Sandwich.__name__&#13;
'Sandwich'&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">issubclass</span>(Sandwich, <span class="hljs-con-built_in">int</span>)&#13;
False&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> Sandwich.lettuce&#13;
Traceback (most recent call last):&#13;
    ...&#13;
AttributeError: type object 'Sandwich' has no attribute 'lettuce'&#13;
</code></pre>&#13;
    <p class="normal">Now, the meta-Sandwich:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">Sandwich</span><span class="hljs-con-class">(</span><span class="hljs-con-built_in">object</span><span class="hljs-con-params">, metaclass=MetaSandwich</span><span class="hljs-con-class">):</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">pass</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> Sandwich.__name__&#13;
'SandwichCreatedByMeta'&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">issubclass</span>(Sandwich, <span class="hljs-con-built_in">int</span>)&#13;
True&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> Sandwich.lettuce&#13;
1&#13;
</code></pre>&#13;
    <p class="normal">As you can see, the class with the custom metaclass now inherits <code class="inlineCode">int</code>, has the <code class="inlineCode">lettuce</code> attribute, and has a different name.</p>&#13;
    <p class="normal">With metaclasses, you<a id="_idIndexMarker542"/> can modify any aspect of the class definition. That makes them a tool that is both very powerful and potentially very confusing. With just a few small modifications, you can cause the strangest of bugs in your (or others’) code.</p>&#13;
    <h2 id="_idParaDest-198" class="heading-2">Arguments to metaclasses</h2>&#13;
    <p class="normal">The possibility of <a id="_idIndexMarker543"/>adding arguments to a metaclass is a<a id="_idIndexMarker544"/> little-known feature, but very useful nonetheless. In many cases, simply adding attributes or methods to a class definition is enough to detect what to do, but there are cases where it is useful to be more specific:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">AddClassAttributeMeta</span><span class="hljs-con-class">(</span><span class="hljs-con-built_in">type</span><span class="hljs-con-class">):</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__init__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">metaclass, name, bases, namespace, **kwargs</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-comment"># The kwargs should not be passed on to the</span>&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-comment"># type.__init__</span>&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-built_in">type</span>.__init__(metaclass, name, bases, namespace)&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__new__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">metaclass, name, bases, namespace, **kwargs</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">for</span> k, v <span class="hljs-con-keyword">in</span> kwargs.items():&#13;
<span class="hljs-con-meta">...</span>             <span class="hljs-con-comment"># setdefault so we don't overwrite attributes</span>&#13;
<span class="hljs-con-meta">...</span>             namespace.setdefault(k, v)&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">return</span> <span class="hljs-con-built_in">type</span>.__new__(metaclass, name, bases, namespace)&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">WithArgument</span><span class="hljs-con-class">(</span><span class="hljs-con-params">metaclass=AddClassAttributeMeta, a=</span><span class="hljs-con-number">1234</span><span class="hljs-con-class">):</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">pass</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> WithArgument.a&#13;
1234&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> with_argument = WithArgument()&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> with_argument.a&#13;
1234&#13;
</code></pre>&#13;
    <p class="normal">This simplistic example may not be useful, but the possibilities are. For example, a metaclass that automatically registers a plugin in a plugin registry could use this to specify plugin name aliases.</p>&#13;
    <p class="normal">With this feature, instead of having to include all class-creating parameters as attributes and methods on the class, you can pass these arguments without polluting your class. The only thing you need to keep in mind is that both the <code class="inlineCode">__new__</code> and <code class="inlineCode">__init__</code> methods need to be extended in order for this to work because the arguments are passed to the metaclass constructor (<code class="inlineCode">__init__</code>).</p>&#13;
    <p class="normal">Since Python 3.6, however, we have <a id="_idIndexMarker545"/>had a simpler alternative to get this <a id="_idIndexMarker546"/>effect. Python 3.6 introduced the <code class="inlineCode">__init_subclass__</code> magic method, which allows for similar modifications in a slightly easier way:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">AddClassAttribute</span><span class="hljs-con-class">:</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__init_subclass__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">cls, **kwargs</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-built_in">super</span>().__init_subclass__()&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">for</span> k, v <span class="hljs-con-keyword">in</span> kwargs.items():&#13;
<span class="hljs-con-meta">...</span>             <span class="hljs-con-built_in">setattr</span>(cls, k, v)&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">WithAttribute</span><span class="hljs-con-class">(</span><span class="hljs-con-params">metaclass=AddClassAttributeMeta, a=</span><span class="hljs-con-number">1234</span><span class="hljs-con-class">):</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">pass</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> WithAttribute.a&#13;
1234&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> with_attribute = WithAttribute()&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> with_attribute.a&#13;
1234&#13;
</code></pre>&#13;
    <p class="normal">Several of the metaclasses in this chapter could be replaced with the <code class="inlineCode">__init_subclass__</code> method, and it is a very useful option for small modifications. For larger changes, I would recommend using a full metaclass instead to make the distinction between the regular class and the metaclass slightly more obvious. </p>&#13;
    <h2 id="_idParaDest-199" class="heading-2">Accessing metaclass attributes through classes</h2>&#13;
    <p class="normal">When using <a id="_idIndexMarker547"/>metaclasses, it might be confusing that the <a id="_idIndexMarker548"/>class actually does more than simply construct the class; it’s actually inheriting the class during the creation. To illustrate:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">Meta</span><span class="hljs-con-class">(</span><span class="hljs-con-built_in">type</span><span class="hljs-con-class">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-meta">    @property</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">some_property</span><span class="hljs-con-function">(</span><span class="hljs-con-params">cls</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">return</span> <span class="hljs-con-string">'property of %r'</span> % cls&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">some_method</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">return</span> <span class="hljs-con-string">'method of %r'</span> % self&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">SomeClass</span><span class="hljs-con-class">(</span><span class="hljs-con-params">metaclass=Meta</span><span class="hljs-con-class">):</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">pass</span>&#13;
&#13;
<span class="hljs-con-comment"># Accessing through the class definition</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> SomeClass.some_property&#13;
"property of &lt;class '...SomeClass'&gt;"&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> SomeClass.some_method&#13;
&lt;bound method Meta.some_method of &lt;class '__main__.SomeClass'&gt;&gt;&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> SomeClass.some_method()&#13;
"method of &lt;class '__main__.SomeClass'&gt;"&#13;
&#13;
<span class="hljs-con-comment"># Accessing through an instance</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> some_class = SomeClass()&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> some_class.some_property&#13;
Traceback (most recent call last):&#13;
    ...&#13;
AttributeError: 'SomeClass' object has no attribute 'some_property'&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> some_class.some_method&#13;
Traceback (most recent call last):&#13;
    ...&#13;
AttributeError: 'SomeClass' object has no attribute 'some_method'&#13;
</code></pre>&#13;
    <p class="normal">As can be seen in the preceding example, these methods are only available for the class objects and not the instances. The <code class="inlineCode">some_property</code> and <code class="inlineCode">some_method</code> are not accessible through the instance, while they are accessible through the class. This can be useful for making some functions class- (as opposed to instance-) only, and it keeps your class namespace <a id="_idIndexMarker549"/>cleaner.</p>&#13;
    <p class="normal">In the general case, however, I <a id="_idIndexMarker550"/>suspect this only adds confusion, so I would typically recommend against it.</p>&#13;
    <h1 id="_idParaDest-200" class="heading-1">Abstract classes using collections.abc</h1>&#13;
    <p class="normal">The abstract base <a id="_idIndexMarker551"/>classes (also known as interface classes) module <a id="_idIndexMarker552"/>is one of the most useful and most widely used examples of metaclasses in Python, as it makes it easy to ensure that a class adheres to a certain interface without a lot of manual checks. We have already seen some examples of abstract base classes in previous chapters, but now we will also look at their inner workings and some more advanced features, such as custom abstract base classes (ABCs).</p>&#13;
    <h2 id="_idParaDest-201" class="heading-2">Internal workings of the abstract classes</h2>&#13;
    <p class="normal">First, let’s demonstrate the <a id="_idIndexMarker553"/>usage of the regular abstract base class:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> abc&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">AbstractClass</span><span class="hljs-con-class">(</span><span class="hljs-con-params">metaclass=abc.ABCMeta</span><span class="hljs-con-class">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-meta">    @abc.abstractmethod</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">some_method</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">raise</span> <span class="hljs-con-literal">NotImplemented</span>()&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">ConcreteClass</span><span class="hljs-con-class">(</span><span class="hljs-con-params">AbstractClass</span><span class="hljs-con-class">):</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">pass</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> ConcreteClass()&#13;
Traceback (most recent call last):&#13;
    ...&#13;
TypeError: Can't instantiate abstract class ConcreteClass with&#13;
abstract methods some_method&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">ImplementedConcreteClass</span><span class="hljs-con-class">(</span><span class="hljs-con-params">ConcreteClass</span><span class="hljs-con-class">):</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">some_method</span><span class="hljs-con-function">():</span>&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">pass</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> instance = ImplementedConcreteClass()&#13;
</code></pre>&#13;
    <p class="normal">As you can see, the abstract base class blocks us from instantiating the classes until all abstract methods have been inherited. This is really useful when your code expects certain properties or methods to be available, but a sane default value is not an option. A common example of this is with base classes for plugins and data models.</p>&#13;
    <p class="normal">In addition to regular <a id="_idIndexMarker554"/>methods, <code class="inlineCode">property</code>, <code class="inlineCode">staticmethod</code>, and <code class="inlineCode">classmethod</code> are also supported:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> abc&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">AbstractClass</span><span class="hljs-con-class">(</span><span class="hljs-con-built_in">object</span><span class="hljs-con-params">, metaclass=abc.ABCMeta</span><span class="hljs-con-class">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-meta">    @property</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-meta">    @abc.abstractmethod</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">some_property</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">raise</span> <span class="hljs-con-literal">NotImplemented</span>()&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-meta">    @classmethod</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-meta">    @abc.abstractmethod</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">some_classmethod</span><span class="hljs-con-function">(</span><span class="hljs-con-params">cls</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">raise</span> <span class="hljs-con-literal">NotImplemented</span>()&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-meta">    @staticmethod</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-meta">    @abc.abstractmethod</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">some_staticmethod</span><span class="hljs-con-function">():</span>&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">raise</span> <span class="hljs-con-literal">NotImplemented</span>()&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-meta">    @abc.abstractmethod</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">some_method</span><span class="hljs-con-function">():</span>&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">raise</span> <span class="hljs-con-literal">NotImplemented</span>()&#13;
</code></pre>&#13;
    <p class="normal">So what does Python do internally? You could, of course, read the <code class="inlineCode">abc.py</code> source code, but I think a simple explanation would be better.</p>&#13;
    <p class="normal">First, the <code class="inlineCode">abc.abstractmethod</code> sets the <code class="inlineCode">__isabstractmethod__</code> property on the function to <code class="inlineCode">True</code>. So if you don’t want to use the decorator, you could simply emulate the behavior by doing something along the lines of:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">some_method.__isabstractmethod__ = <span class="hljs-literal">True</span>&#13;
</code></pre>&#13;
    <p class="normal">After that, the <code class="inlineCode">abc.ABCMeta</code> metaclass walks through all of the items in the <code class="inlineCode">namespace</code> and looks for objects <a id="_idIndexMarker555"/>where the <code class="inlineCode">__isabstractmethod__</code> attribute evaluates to <code class="inlineCode">True</code>. In addition to that, it will walk through all <code class="inlineCode">bases</code> and check the <code class="inlineCode">__abstractmethods__</code> set for every base class, in case the class inherits an abstract class. All of the items where <code class="inlineCode">__isabstractmethod__</code> still evaluates to <code class="inlineCode">True</code> will be added to the <code class="inlineCode">__abstractmethods__</code> set that is stored in the class as a <code class="inlineCode">frozenset</code>.</p>&#13;
    <div class="note">&#13;
      <p class="normal">Note that we don’t use <code class="inlineCode">abc.abstractproperty</code>, <code class="inlineCode">abc.abstractclassmethod</code>, and <code class="inlineCode">abc.abstractstaticmethod</code>. Since Python 3.3, these have been deprecated as the <code class="inlineCode">classmethod</code>, <code class="inlineCode">staticmethod</code>, and <code class="inlineCode">property</code> decorators are recognized by <code class="inlineCode">abc.abstractmethod</code>, so a simple <code class="inlineCode">property</code> decorator followed by an <code class="inlineCode">abc.abstractmethod</code> is recognized as well. Take care when ordering the decorators; <code class="inlineCode">abc.abstractmethod</code> needs to be the innermost decorator for this to work properly.</p>&#13;
    </div>&#13;
    <p class="normal">The next question now is where the actual checks come in, the checks to see whether the classes are completely implemented. This actually functions through a few Python internals:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">AbstractMeta</span><span class="hljs-con-class">(</span><span class="hljs-con-built_in">type</span><span class="hljs-con-class">):</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__new__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">metaclass, name, bases, namespace</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>         cls = <span class="hljs-con-built_in">super</span>().__new__(metaclass, name, bases,&#13;
<span class="hljs-con-meta">...</span>                               namespace)&#13;
<span class="hljs-con-meta">...</span>         cls.__abstractmethods__ = <span class="hljs-con-built_in">frozenset</span>((<span class="hljs-con-string">'something'</span>,))&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">return</span> cls&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">ConcreteClass</span><span class="hljs-con-class">(</span><span class="hljs-con-params">metaclass=AbstractMeta</span><span class="hljs-con-class">):</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">pass</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> ConcreteClass()&#13;
Traceback (most recent call last):&#13;
    ...&#13;
TypeError: Can't instantiate abstract class ConcreteClass with &#13;
abstract methods something&#13;
</code></pre>&#13;
    <p class="normal">We can easily emulate the<a id="_idIndexMarker556"/> same behavior with a metaclass ourselves, but it should be noted that <code class="inlineCode">abc.ABCMeta</code> actually does more, which we will demonstrate in the next section. To illustrate the behavior as described above, let’s create an abstract base metaclass that mimics <code class="inlineCode">abc.ABCMeta</code>:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> functools&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">AbstractMeta</span><span class="hljs-con-class">(</span><span class="hljs-con-built_in">type</span><span class="hljs-con-class">):</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__new__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">metaclass, name, bases, namespace</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-comment"># Create the class instance</span>&#13;
<span class="hljs-con-meta">...</span>         cls = <span class="hljs-con-built_in">super</span>().__new__(metaclass, name, bases,&#13;
<span class="hljs-con-meta">...</span>                               namespace)&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-comment"># Collect all local methods marked as abstract</span>&#13;
<span class="hljs-con-meta">...</span>         abstracts = <span class="hljs-con-built_in">set</span>()&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">for</span> k, v <span class="hljs-con-keyword">in</span> namespace.items():&#13;
<span class="hljs-con-meta">...</span>             <span class="hljs-con-keyword">if</span> <span class="hljs-con-built_in">getattr</span>(v, <span class="hljs-con-string">'__abstract__'</span>, <span class="hljs-con-literal">False</span>):&#13;
<span class="hljs-con-meta">...</span>                 abstracts.add(k)&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-comment"># Look for abstract methods in the base classes and</span>&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-comment"># add them to the list of abstracts</span>&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">for</span> base <span class="hljs-con-keyword">in</span> bases:&#13;
<span class="hljs-con-meta">...</span>             <span class="hljs-con-keyword">for</span> k <span class="hljs-con-keyword">in</span> <span class="hljs-con-built_in">getattr</span>(base, <span class="hljs-con-string">'</span><span class="hljs-con-string">__abstracts__'</span>, ()):&#13;
<span class="hljs-con-meta">...</span>                 v = <span class="hljs-con-built_in">getattr</span>(cls, k, <span class="hljs-con-literal">None</span>)&#13;
<span class="hljs-con-meta">...</span>                 <span class="hljs-con-keyword">if</span> <span class="hljs-con-built_in">getattr</span>(v, <span class="hljs-con-string">'__abstract__'</span>, <span class="hljs-con-literal">False</span>):&#13;
<span class="hljs-con-meta">...</span>                     abstracts.add(k)&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-comment"># Store the abstracts in a frozenset so they cannot be</span>&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-comment"># modified</span>&#13;
<span class="hljs-con-meta">...</span>         cls.__abstracts__ = <span class="hljs-con-built_in">frozenset</span>(abstracts)&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-comment"># Decorate the __new__ function to check if all</span>&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-comment"># abstract functions were implemented</span>&#13;
<span class="hljs-con-meta">...</span>         original_new = cls.__new__&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-meta">        @functools.wraps(</span><span class="hljs-con-params">original_new</span><span class="hljs-con-meta">)</span>&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">new</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self, *args, **kwargs</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>             <span class="hljs-con-keyword">for</span> k <span class="hljs-con-keyword">in</span> self.__abstracts__:&#13;
<span class="hljs-con-meta">...</span>                 v = <span class="hljs-con-built_in">getattr</span>(self, k)&#13;
<span class="hljs-con-meta">...</span>                 <span class="hljs-con-keyword">if</span> <span class="hljs-con-built_in">getattr</span>(v, <span class="hljs-con-string">'__abstract__'</span>, <span class="hljs-con-literal">False</span>):&#13;
<span class="hljs-con-meta">...</span>                     <span class="hljs-con-keyword">raise</span> RuntimeError(&#13;
<span class="hljs-con-meta">...</span>                         <span class="hljs-con-string">'%r is not implemented'</span> % k)&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span>             <span class="hljs-con-keyword">return</span> original_new(self, *args, **kwargs)&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span>         cls.__new__ = new&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">return</span> cls&#13;
&#13;
<span class="hljs-con-comment"># Create a decorator that sets the '__abstract__' attribute</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">abstractmethod</span><span class="hljs-con-function">(</span><span class="hljs-con-params">function</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>     function.__abstract__ = <span class="hljs-con-literal">True</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">return</span> function&#13;
</code></pre>&#13;
    <p class="normal">Now that we have the metaclass and decorator for creating abstract classes, let’s see if it works as expected:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">ConcreteClass</span><span class="hljs-con-class">(</span><span class="hljs-con-params">metaclass=AbstractMeta</span><span class="hljs-con-class">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-meta">    @abstractmethod</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">some_method</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">pass</span>&#13;
&#13;
<span class="hljs-con-comment"># Instantiating the function, we can see that it functions as the</span>&#13;
<span class="hljs-con-comment"># regular ABCMeta does</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> ConcreteClass()&#13;
Traceback (most recent call last):&#13;
    ...&#13;
RuntimeError: 'some_method' is not implemented&#13;
</code></pre>&#13;
    <p class="normal">The actual implementation is much more complicated since it needs to handle decorators such as <code class="inlineCode">property</code>, <code class="inlineCode">classmethod</code>, and <code class="inlineCode">staticmethod</code>. It also has some caching to features, but this code covers the most useful part of the implementation. One of the most important tricks to note here is that the actual check is executed by decorating the <code class="inlineCode">__new__</code> function of the actual class. This method is only executed once within a class, so we can avoid the overhead of these checks for multiple instantiations.</p>&#13;
    <div class="note">&#13;
      <p class="normal">The actual implementation of the abstract methods can be found by looking for <code class="inlineCode">__isabstractmethod__</code> in the Python source code in the following files: <code class="inlineCode">Objects/descrobject.c</code>, <code class="inlineCode">Objects/funcobject.c,</code> and <code class="inlineCode">Objects/object.c</code>. The Python part of the implementation can be found in <code class="inlineCode">Lib/abc.py</code>.</p>&#13;
    </div>&#13;
    <h2 id="_idParaDest-202" class="heading-2">Custom type checks</h2>&#13;
    <p class="normal">Defining your own interfaces using <a id="_idIndexMarker557"/>abstract base classes is great, of course. But it can also be very convenient to tell Python what your class actually resembles and what kind of types are similar. For that, <code class="inlineCode">abc.ABCMeta</code> offers a register function that allows you to specify which types are similar. For example, a custom <code class="inlineCode">list</code> that sees the <code class="inlineCode">list</code> type as similar:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> abc&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">CustomList</span><span class="hljs-con-class">(</span><span class="hljs-con-params">abc.ABC</span><span class="hljs-con-class">):</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-string">'''This class implements a list-like interface'''</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">CustomInheritingList</span><span class="hljs-con-class">(</span><span class="hljs-con-built_in">list</span><span class="hljs-con-params">, abc.ABC</span><span class="hljs-con-class">):</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-string">'''This class implements a list-like interface'''</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">issubclass</span>(<span class="hljs-con-built_in">list</span>, CustomList)&#13;
False&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">issubclass</span>(<span class="hljs-con-built_in">list</span>, CustomInheritingList)&#13;
False&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> CustomList.register(<span class="hljs-con-built_in">list</span>)&#13;
&lt;class 'list'&gt;&#13;
&#13;
<span class="hljs-con-comment"># We can't make it go both ways, however</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> CustomInheritingList.register(<span class="hljs-con-built_in">list</span>)&#13;
Traceback (most recent call last):&#13;
    ...&#13;
RuntimeError: Refusing to create an inheritance cycle&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">issubclass</span>(<span class="hljs-con-built_in">list</span>, CustomList)&#13;
True&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">issubclass</span>(<span class="hljs-con-built_in">list</span>, CustomInheritingList)&#13;
False&#13;
&#13;
<span class="hljs-con-comment"># We need to inherit list to make it work the other way around</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">issubclass</span>(CustomList, <span class="hljs-con-built_in">list</span>)&#13;
False&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">isinstance</span>(CustomList(), <span class="hljs-con-built_in">list</span>)&#13;
False&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">issubclass</span>(CustomInheritingList, <span class="hljs-con-built_in">list</span>)&#13;
True&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">isinstance</span>(CustomInheritingList(), <span class="hljs-con-built_in">list</span>)&#13;
True&#13;
</code></pre>&#13;
    <p class="normal">As demonstrated by the last eight lines, this is a one-way relationship. The other way around requires inheriting <code class="inlineCode">list</code>, but due to inheritance cycles, it can’t be done both ways. Otherwise, <code class="inlineCode">CustomInheritingList</code> would inherit <code class="inlineCode">list</code> and <code class="inlineCode">list</code> would inherit <code class="inlineCode">CustomInheritingList</code>, which could recurse forever during the <code class="inlineCode">issubclass()</code> call.</p>&#13;
    <p class="normal">To be able to handle<a id="_idIndexMarker558"/> cases like these, there is another useful feature in <code class="inlineCode">abc.ABCMeta</code>. When subclassing <code class="inlineCode">abc.ABCMeta</code>, the <code class="inlineCode">__subclasshook__</code> method can be extended to customize the behavior of <code class="inlineCode">issubclass</code> and with that, <code class="inlineCode">isinstance</code>:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> abc&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">UniversalClass</span><span class="hljs-con-class">(</span><span class="hljs-con-params">abc.ABC</span><span class="hljs-con-class">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-meta">   @classmethod</span>&#13;
<span class="hljs-con-meta">...</span>    <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__subclasshook__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">cls, subclass</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>        <span class="hljs-con-keyword">return</span> <span class="hljs-con-literal">True</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">issubclass</span>(<span class="hljs-con-built_in">list</span>, UniversalClass)&#13;
True&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">issubclass</span>(<span class="hljs-con-built_in">bool</span>, UniversalClass)&#13;
True&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">isinstance</span>(<span class="hljs-con-literal">True</span>, UniversalClass)&#13;
True&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">issubclass</span>(UniversalClass, <span class="hljs-con-built_in">bool</span>)&#13;
False&#13;
</code></pre>&#13;
    <p class="normal">The <code class="inlineCode">__subclasshook__</code> should <a id="_idIndexMarker559"/>return <code class="inlineCode">True</code>, <code class="inlineCode">False</code>, or <code class="inlineCode">NotImplemented</code>, which results in <code class="inlineCode">issubclass</code> returning <code class="inlineCode">True</code>, <code class="inlineCode">False</code>, or the usual behavior when <code class="inlineCode">NotImplemented</code> is returned.</p>&#13;
    <h1 id="_idParaDest-203" class="heading-1">Automatically registering plugin systems</h1>&#13;
    <p class="normal">One very useful way to <a id="_idIndexMarker560"/>use metaclasses is to have classes automatically register themselves as plugins/handlers. </p>&#13;
    <p class="normal">Instead of manually adding a register call after creating the class or by adding a decorator, you can make it completely automatic for the user. That means that the user of your library or plugin system cannot accidentally forget to add the register call.</p>&#13;
    <div class="note">&#13;
      <p class="normal">Note the distinction between registering and importing. While this first example shows automatic registering, automatic importing is covered in later sections.</p>&#13;
    </div>&#13;
    <p class="normal">Examples of these can be seen in many projects such as web frameworks. The Django web framework, for example, uses metaclasses for its database models (effectively tables) to automatically generate the table and column names based on the class and attribute names.</p>&#13;
    <p class="normal">The actual code base of projects like these is too extensive to usefully explain here though. Hence, we’ll show a simpler example that demonstrates the power of metaclasses as a self-registering plugin system:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> abc&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">Plugins</span><span class="hljs-con-class">(</span><span class="hljs-con-params">abc.ABCMeta</span><span class="hljs-con-class">):</span>&#13;
<span class="hljs-con-meta">...</span>     plugins = <span class="hljs-con-built_in">dict</span>()&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__new__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">metaclass, name, bases, namespace</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>         cls = abc.ABCMeta.__new__(metaclass, name, bases,&#13;
<span class="hljs-con-meta">...</span>                                   namespace)&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">if</span> <span class="hljs-con-built_in">isinstance</span>(cls.name, <span class="hljs-con-built_in">str</span>):&#13;
<span class="hljs-con-meta">...</span>             metaclass.plugins[cls.name] = cls&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">return</span> cls&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-meta">    @classmethod</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">get</span><span class="hljs-con-function">(</span><span class="hljs-con-params">cls, name</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">return</span> cls.plugins[name]&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">PluginBase</span><span class="hljs-con-class">(</span><span class="hljs-con-params">metaclass=Plugins</span><span class="hljs-con-class">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-meta">    @property</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-meta">    @abc.abstractmethod</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">name</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">raise</span> <span class="hljs-con-literal">NotImplemented</span>()&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">PluginA</span><span class="hljs-con-class">(</span><span class="hljs-con-params">PluginBase</span><span class="hljs-con-class">):</span>&#13;
<span class="hljs-con-meta">...</span>     name = <span class="hljs-con-string">'a'</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">PluginB</span><span class="hljs-con-class">(</span><span class="hljs-con-params">PluginBase</span><span class="hljs-con-class">):</span>&#13;
<span class="hljs-con-meta">...</span>     name = <span class="hljs-con-string">'b'</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> Plugins.get(<span class="hljs-con-string">'a'</span>)&#13;
&lt;class '...PluginA'&gt;&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> Plugins.plugins&#13;
{'a': &lt;class '...PluginA'&gt;,&#13;
 'b': &lt;class '...PluginB'&gt;}&#13;
</code></pre>&#13;
    <p class="normal">This example is a tad <a id="_idIndexMarker561"/>simplistic of course, but it’s the basis for many plugin systems. </p>&#13;
    <div class="note">&#13;
      <p class="normal">While metaclasses run at definition time, the module still needs to be <strong class="keyWord">imported</strong> to work. There are several options for doing this; loading on-demand through the <code class="inlineCode">get</code> method would have my vote if possible, as that also doesn’t add load time if the plugin is not used.</p>&#13;
    </div>&#13;
    <p class="normal">The following examples will use the following file structure to get reproducible results. All files will be contained in a <code class="inlineCode">plugins</code> directory. Note that all the code for this book, including this example, can be found on GitHub: <a href="https://github.com/mastering-python/code_2"><span class="url">https://github.com/mastering-python/code_2</span></a>.</p>&#13;
    <p class="normal">The <code class="inlineCode">__init__.py</code> file is used to create shortcuts, so a simple <code class="inlineCode">import plugins</code> will result in having <code class="inlineCode">plugins.Plugins</code> available, instead of requiring the import of <code class="inlineCode">plugins.base</code> explicitly:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># plugins/__init__.py</span>&#13;
<span class="hljs-keyword">from</span> .base <span class="hljs-keyword">import</span> Plugin&#13;
<span class="hljs-keyword">from</span> .base <span class="hljs-keyword">import</span> Plugins&#13;
&#13;
__all__ = [<span class="hljs-string">'Plugin'</span>, <span class="hljs-string">'Plugins'</span>]&#13;
</code></pre>&#13;
    <p class="normal">Here’s the <code class="inlineCode">base.py</code> file <a id="_idIndexMarker562"/>containing the <code class="inlineCode">Plugins</code> collection and the <code class="inlineCode">Plugin</code> base class:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># plugins/base.py</span>&#13;
<span class="hljs-keyword">import</span> abc&#13;
&#13;
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Plugins</span><span class="hljs-class">(</span><span class="hljs-params">abc.ABCMeta</span><span class="hljs-class">):</span>&#13;
    plugins = <span class="hljs-built_in">dict</span>()&#13;
&#13;
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__new__</span><span class="hljs-function">(</span><span class="hljs-params">metaclass, name, bases, namespace</span><span class="hljs-function">):</span>&#13;
        cls = abc.ABCMeta.__new__(&#13;
            metaclass, name, bases, namespace)&#13;
        metaclass.plugins[name.lower()] = cls&#13;
        <span class="hljs-keyword">return</span> cls&#13;
&#13;
<span class="hljs-meta">    @classmethod</span>&#13;
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">get</span><span class="hljs-function">(</span><span class="hljs-params">cls, name</span><span class="hljs-function">):</span>&#13;
        <span class="hljs-keyword">return</span> cls.plugins[name]&#13;
&#13;
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Plugin</span><span class="hljs-class">(</span><span class="hljs-params">metaclass=Plugins</span><span class="hljs-class">):</span>&#13;
    <span class="hljs-keyword">pass</span>&#13;
</code></pre>&#13;
    <p class="normal">And two simple plugins, <code class="inlineCode">a.py</code> and <code class="inlineCode">b.py</code> (omitted since it’s functionally identical to <code class="inlineCode">a.py</code>):</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> . <span class="hljs-keyword">import</span> base&#13;
&#13;
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">A</span><span class="hljs-class">(</span><span class="hljs-params">base.Plugin</span><span class="hljs-class">):</span>&#13;
    <span class="hljs-keyword">pass</span>&#13;
</code></pre>&#13;
    <p class="normal">Now that we have set up the plugins and the automatic registering, we need to take care of the loading of <code class="inlineCode">a.py</code> and <code class="inlineCode">b.py</code>. While <code class="inlineCode">A</code> and <code class="inlineCode">B</code> will automatically register within <code class="inlineCode">Plugins</code>, if you forget to <code class="inlineCode">import</code> them, they will not be registered. To solve this, we have several options; first <a id="_idIndexMarker563"/>we will look at on-demand loading.</p>&#13;
    <h2 id="_idParaDest-204" class="heading-2">Importing plugins on-demand</h2>&#13;
    <p class="normal">The first of the solutions for<a id="_idIndexMarker564"/> the import problem is simply taking care of it in the <code class="inlineCode">get</code> method of the <code class="inlineCode">Plugins</code> metaclass. Whenever the plugin is not found in the registry, the <code class="inlineCode">get</code> method should automatically <code class="inlineCode">import</code> the module from the <code class="inlineCode">plugins</code> directory.</p>&#13;
    <p class="normal">The advantages of this approach are that the plugins don’t explicitly need to be preloaded, but also that the plugins are only loaded when the need is there. Unused plugins won’t be touched, so this method can help in reducing your applications’ load times.</p>&#13;
    <p class="normal">The downsides are that the code will not be run or tested, so it might be completely broken and you won’t know about it until it is finally loaded. Solutions for this problem will be covered in the chapter on testing, <em class="chapterRef">Chapter 10</em>. The other problem is that if the code self-registers into other parts of an application, then that code won’t be executed either, unless you add the required <code class="inlineCode">import</code> in other parts of the code, that is.</p>&#13;
    <p class="normal">Modifying the <code class="inlineCode">Plugins.get</code> method, we get the following:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> importlib&#13;
&#13;
<span class="hljs-comment"># Plugins class omitted for brevity</span>&#13;
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">PluginsOnDemand</span><span class="hljs-class">(</span><span class="hljs-params">Plugins</span><span class="hljs-class">):</span>&#13;
<span class="hljs-meta">    @classmethod</span>&#13;
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">get</span><span class="hljs-function">(</span><span class="hljs-params">cls, name</span><span class="hljs-function">):</span>&#13;
        <span class="hljs-keyword">if</span> name <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> cls.plugins:&#13;
            print(<span class="hljs-string">'Loading plugins from plugins.%s'</span> % name)&#13;
            importlib.import_module(<span class="hljs-string">'plugins.%s'</span> % name)&#13;
        <span class="hljs-keyword">return</span> cls.plugins[name]&#13;
</code></pre>&#13;
    <p class="normal">Now we run this from a Python file:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> plugins&#13;
&#13;
print(plugins.PluginsOnDemand.get(<span class="hljs-string">'a'</span>))&#13;
print(plugins.PluginsOnDemand.get(<span class="hljs-string">'a'</span>))&#13;
</code></pre>&#13;
    <p class="normal">Which results in:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">Loading plugins from plugins.a&#13;
&lt;class 'plugins.a.A'&gt;&#13;
&lt;class 'plugins.a.A'&gt;&#13;
</code></pre>&#13;
    <p class="normal">As you can see, this <a id="_idIndexMarker565"/>approach only results in running the <code class="inlineCode">import</code> once; the second time, the plugin will be available in the plugins dictionary, so no loading will be necessary.</p>&#13;
    <h2 id="_idParaDest-205" class="heading-2">Importing plugins through configuration</h2>&#13;
    <p class="normal">While only loading the<a id="_idIndexMarker566"/> required plugins is useful because it reduces <a id="_idIndexMarker567"/>your initial load time and memory overhead, there is something to be said about preloading the plugins you will likely need. As dictated by the Zen of Python, explicit is better than implicit, so an explicit list of plugins to load is generally a good solution. The added advantages of this method are that you are able to make the registration a bit more advanced as you are guaranteed it is run, and that you can load plugins from multiple packages. The disadvantage is, of course, that you need to explicitly define which plugins to load, which could be considered a violation of the DRY (Don’t Repeat Yourself) principle.</p>&#13;
    <p class="normal">Instead of importing in the <code class="inlineCode">get</code> method, we will add a <code class="inlineCode">load</code> method this time, which imports all the given module names:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># PluginsOnDemand class omitted for brevity</span>&#13;
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">PluginsThroughConfiguration</span><span class="hljs-class">(</span><span class="hljs-params">PluginsOnDemand</span><span class="hljs-class">):</span>&#13;
<span class="hljs-meta">    @classmethod</span>&#13;
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">load</span><span class="hljs-function">(</span><span class="hljs-params">cls, *plugin_names</span><span class="hljs-function">):</span>&#13;
        <span class="hljs-keyword">for</span> plugin_name <span class="hljs-keyword">in</span> plugin_names:&#13;
            cls.get(plugin_name)&#13;
</code></pre>&#13;
    <p class="normal">Which can be called using the following code:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> plugins&#13;
&#13;
plugins.PluginsThroughConfiguration.load(&#13;
    <span class="hljs-string">'a'</span>,&#13;
    <span class="hljs-string">'b'</span>,&#13;
)&#13;
&#13;
print(<span class="hljs-string">'After load'</span>)&#13;
print(plugins.PluginsThroughConfiguration.get(<span class="hljs-string">'</span><span class="hljs-string">a'</span>))&#13;
print(plugins.PluginsThroughConfiguration.get(<span class="hljs-string">'a'</span>))&#13;
</code></pre>&#13;
    <p class="normal">This results in the following output:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">Loading plugins from plugins.a&#13;
Loading plugins from plugins.b&#13;
After load&#13;
&lt;class 'plugins.a.A'&gt;&#13;
&lt;class 'plugins.a.A'&gt;&#13;
</code></pre>&#13;
    <p class="normal">A fairly simple and <a id="_idIndexMarker568"/>straightforward system to load the<a id="_idIndexMarker569"/> plugins based on settings, this could easily be combined with any type of settings system to fill the <code class="inlineCode">load</code> method. An example of this method is <code class="inlineCode">INSTALLED_APPS</code> in Django.</p>&#13;
    <h2 id="_idParaDest-206" class="heading-2">Importing plugins through the filesystem</h2>&#13;
    <p class="normal">The most convenient<a id="_idIndexMarker570"/> method of loading plugins is one you <a id="_idIndexMarker571"/>don’t have to think about because it happens automatically. While this is very convenient, very important caveats should be considered.</p>&#13;
    <p class="normal">First, they often make debugging much more difficult. Similar automatic import systems in Django have caused me a fair share of headaches, as they tend to obfuscate errors or even completely hide them, making you debug for hours.</p>&#13;
    <p class="normal">Second, it can be a security risk. If someone has write access to one of your plugin directories, they can effectively execute code within your application.</p>&#13;
    <p class="normal">Having that said, especially for beginners and/or new users of your framework, automatic plugin loading can be very convenient and certainly warrants a demonstration.</p>&#13;
    <p class="normal">This time, we inherit the <code class="inlineCode">PluginsThroughConfiguration</code> class we created in the previous example, and <a id="_idIndexMarker572"/>add an <code class="inlineCode">autoload</code> method to detect available<a id="_idIndexMarker573"/> plugins.</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> re&#13;
<span class="hljs-keyword">import</span> pathlib&#13;
<span class="hljs-keyword">import</span> importlib&#13;
&#13;
CURRENT_FILE = pathlib.Path(__file__)&#13;
PLUGINS_DIR = CURRENT_FILE.parent&#13;
MODULE_NAME_RE = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">'[a-z][a-z0-9_]*'</span>, re.IGNORECASE)&#13;
&#13;
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">PluginsThroughFilesystem</span><span class="hljs-class">(</span><span class="hljs-params">PluginsThroughConfiguration</span><span class="hljs-class">):</span>&#13;
<span class="hljs-meta">    @classmethod</span>&#13;
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">autoload</span><span class="hljs-function">(</span><span class="hljs-params">cls</span><span class="hljs-function">):</span>&#13;
        <span class="hljs-keyword">for</span> filename <span class="hljs-keyword">in</span> PLUGINS_DIR.glob(<span class="hljs-string">'*.py'</span>):&#13;
            <span class="hljs-comment"># Skip __init__.py and other non-plugin files</span>&#13;
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> MODULE_NAME_RE.match(filename.stem):&#13;
                <span class="hljs-keyword">continue</span>&#13;
                cls.get(filename.stem)&#13;
&#13;
            <span class="hljs-comment"># Skip this file</span>&#13;
            <span class="hljs-keyword">if</span> filename == CURRENT_FILE:&#13;
                <span class="hljs-keyword">continue</span>&#13;
&#13;
            <span class="hljs-comment"># Load the plugin</span>&#13;
            cls.get(filename.stem)&#13;
</code></pre>&#13;
    <p class="normal">Now, let’s give this code a try:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> pprint&#13;
<span class="hljs-keyword">import</span> plugins&#13;
&#13;
plugins.PluginsThroughFilesystem.autoload()&#13;
&#13;
print(<span class="hljs-string">'After load'</span>)&#13;
pprint.pprint(plugins.PluginsThroughFilesystem.plugins)&#13;
</code></pre>&#13;
    <p class="normal">This results in:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">Loading plugins from plugins.a&#13;
Loading plugins from plugins.b&#13;
After load&#13;
{'a': &lt;class 'plugins.a.A'&gt;,&#13;
 'b': &lt;class 'plugins.b.B'&gt;,&#13;
 'plugin': &lt;class 'plugins.base.Plugin'&gt;}&#13;
</code></pre>&#13;
    <p class="normal">Now every file in the <code class="inlineCode">plugins</code> directory will automatically be loaded. But note that it can obscure certain errors. For example, if one of your plugins imports a library that you do not have installed, you<a id="_idIndexMarker574"/> will get the <code class="inlineCode">ImportError</code> from the <a id="_idIndexMarker575"/>plugin, not the actual library.</p>&#13;
    <p class="normal">To make this system a bit smarter (even importing packages outside of your Python path), you can create a plugin loader using the abstract base classes in <code class="inlineCode">importlib.abc</code>; note that you will most likely still need to somehow list the files and/or directories though. To improve this, you could also take a look at the loaders in <code class="inlineCode">importlib</code>. Using these loaders, you can load plugins from ZIP files and other sources as well.</p>&#13;
    <p class="normal">Now that we are done with plugin systems, it is time to look at how <code class="inlineCode">dataclasses</code> could be implemented using metaclasses instead of decorators.</p>&#13;
    <h1 id="_idParaDest-207" class="heading-1">Dataclasses</h1>&#13;
    <p class="normal">In <em class="chapterRef">Chapter 4,</em> <em class="italic">Pythonic Design Patterns</em>, we already saw the <code class="inlineCode">dataclasses</code> module, which makes it possible to implement easy type hinting and even enforce some structure in your classes. </p>&#13;
    <p class="normal">Now let’s look at how we can implement our own version using a metaclass. The actual <code class="inlineCode">dataclasses</code> module<a id="_idIndexMarker576"/> mostly relies on a class decorator, but that is no issue. Metaclasses can be seen as a more powerful version of a class decorator, so they will work fine. With metaclasses, you can use inheritance to reuse them, or make the class inherit other classes, but above all, they allow you to modify the class object, instead of the instance with decorators.</p>&#13;
    <p class="normal">The <code class="inlineCode">dataclasses</code> module <a id="_idIndexMarker577"/>has several tricks up its sleeve that are non-trivial to replicate. Beyond adding documentation and some utility methods, it also generates an <code class="inlineCode">__init__</code> method with a <code class="inlineCode">signature</code> that matches the fields of the <code class="inlineCode">dataclass</code>. Since the entire <code class="inlineCode">dataclasses</code> module is roughly 1,300 lines, we will not get close with our implementation. So we will implement the <code class="inlineCode">__init__()</code> method, including a generated <code class="inlineCode">signature</code> and <code class="inlineCode">__annotations__</code> for type hinting, and a <code class="inlineCode">__repr__</code> method to show the results:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> inspect&#13;
&#13;
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Dataclass</span><span class="hljs-class">(</span><span class="hljs-built_in">type</span><span class="hljs-class">):</span>&#13;
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">_get_signature</span><span class="hljs-function">(</span><span class="hljs-params">namespace</span><span class="hljs-function">):</span>&#13;
        <span class="hljs-comment"># Get the annotations from the class</span>&#13;
        annotations = namespace.get(<span class="hljs-string">'__annotations__'</span>, <span class="hljs-built_in">dict</span>())&#13;
&#13;
        <span class="hljs-comment"># Signatures are immutable so we need to build the</span>&#13;
        <span class="hljs-comment"># parameter list before creating the signature</span>&#13;
        parameters = []&#13;
        <span class="hljs-keyword">for</span> name, annotation <span class="hljs-keyword">in</span> annotations.items():&#13;
&#13;
            <span class="hljs-comment"># Create Parameter shortcut for readability</span>&#13;
            Parameter = inspect.Parameter&#13;
            <span class="hljs-comment"># Create the parameter with the correct type</span>&#13;
            <span class="hljs-comment"># annotation and default. You could also choose to</span>&#13;
            <span class="hljs-comment"># make the arguments keyword/positional only here</span>&#13;
            parameters.append(Parameter(&#13;
                name=name,&#13;
                kind=Parameter.POSITIONAL_OR_KEYWORD,&#13;
                default=namespace.get(name, Parameter.empty),&#13;
                annotation=annotation,&#13;
            ))&#13;
&#13;
        <span class="hljs-keyword">return</span> inspect.Signature(parameters)&#13;
&#13;
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">_create_init</span><span class="hljs-function">(</span><span class="hljs-params">namespace, signature</span><span class="hljs-function">):</span>&#13;
        <span class="hljs-comment"># If init exists we don't need to do anything</span>&#13;
        <span class="hljs-keyword">if</span> <span class="hljs-string">'__init__'</span> <span class="hljs-keyword">in</span> namespace:&#13;
            <span class="hljs-keyword">return</span>&#13;
&#13;
        <span class="hljs-comment"># Create the __init__ method and use the signature to</span>&#13;
        <span class="hljs-comment"># process the arguments</span>&#13;
        <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span><span class="hljs-params">self, *args, **kwargs</span><span class="hljs-function">):</span>&#13;
            bound = signature.bind(*args, **kwargs)&#13;
            bound.apply_defaults()&#13;
&#13;
            <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> bound.arguments.items():&#13;
                <span class="hljs-comment"># Convert to the annotation to enforce types</span>&#13;
                parameter = signature.parameters[key]&#13;
                <span class="hljs-comment"># Set the casted value</span>&#13;
                <span class="hljs-built_in">setattr</span>(self, key, parameter.annotation(value))&#13;
&#13;
        <span class="hljs-comment"># Override the signature for __init__ so help() works</span>&#13;
        __init__.__signature__ = signature&#13;
&#13;
        namespace[<span class="hljs-string">'__init__'</span>] = __init__&#13;
&#13;
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">_create_repr</span><span class="hljs-function">(</span><span class="hljs-params">namespace, signature</span><span class="hljs-function">):</span>&#13;
        <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__repr__</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>&#13;
            arguments = []&#13;
            <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> <span class="hljs-built_in">vars</span>(self).items():&#13;
                arguments.append(<span class="hljs-string">f'</span><span class="hljs-subst">{key}</span><span class="hljs-string">=</span><span class="hljs-subst">{value!r}</span><span class="hljs-string">'</span>)&#13;
            arguments = <span class="hljs-string">', '</span>.join(arguments)&#13;
            <span class="hljs-keyword">return</span> <span class="hljs-string">f'</span><span class="hljs-subst">{self.__class__.__name__}</span><span class="hljs-string">(</span><span class="hljs-subst">{arguments}</span><span class="hljs-string">)'</span>&#13;
&#13;
        namespace[<span class="hljs-string">'__repr__'</span>] = __repr__&#13;
&#13;
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__new__</span><span class="hljs-function">(</span><span class="hljs-params">metaclass, name, bases, namespace</span><span class="hljs-function">):</span>&#13;
        signature = metaclass._get_signature(namespace)&#13;
        metaclass._create_init(namespace, signature)&#13;
        metaclass._create_repr(namespace, signature)&#13;
&#13;
        cls = <span class="hljs-built_in">super</span>().__new__(metaclass, name, bases, namespace)&#13;
&#13;
        <span class="hljs-keyword">return</span> cls&#13;
</code></pre>&#13;
    <p class="normal">At first glance, this might <a id="_idIndexMarker578"/>look complicated, but the general process is actually fairly simple:</p>&#13;
    <ol class="numberedList" style="list-style-type: decimal;">&#13;
      <li class="numberedList" value="1">We generate a signature from the <code class="inlineCode">__annotations__</code> and defaults in the class.</li>&#13;
      <li class="numberedList">We generate an <code class="inlineCode">__init__</code> method based on the signature.</li>&#13;
      <li class="numberedList">We make the <code class="inlineCode">__init__</code> method use the signature to automatically bind the arguments passed to the function and apply those to the instance.</li>&#13;
      <li class="numberedList">We generate a <code class="inlineCode">__repr__</code> method, which simply prints the class name and the values stored in the instance. Note that this method is rather limited and will show anything you’ve added to the class.</li>&#13;
    </ol>&#13;
    <p class="normal">Note that as an extra little touch, we have<a id="_idIndexMarker579"/> a cast to the annotated type to enforce the type correctly.</p>&#13;
    <p class="normal">Let’s see if it works as expected by using the <code class="inlineCode">dataclass</code> example from <em class="chapterRef">Chapter 4</em> with a few small additions to test the type conversions:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">from</span> T_10_dataclasses <span class="hljs-con-keyword">import</span> Dataclass&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">Sandwich</span><span class="hljs-con-class">(</span><span class="hljs-con-params">metaclass=Dataclass</span><span class="hljs-con-class">):</span>&#13;
<span class="hljs-con-meta">...</span>     spam: <span class="hljs-con-built_in">int</span>&#13;
<span class="hljs-con-meta">...</span>     eggs: <span class="hljs-con-built_in">int</span> = <span class="hljs-con-number">3</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> Sandwich(<span class="hljs-con-number">1</span>, <span class="hljs-con-number">2</span>)&#13;
Sandwich(spam=1, eggs=2)&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> sandwich = Sandwich(<span class="hljs-con-number">4</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> sandwich&#13;
Sandwich(spam=4, eggs=3)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> sandwich.eggs&#13;
3&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">help</span>(Sandwich.__init__)&#13;
Help on function __init__ in ...&#13;
&lt;BLANKLINE&gt;&#13;
__init__(spam: int, eggs: int = 3)&#13;
&lt;BLANKLINE&gt;&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> Sandwich(<span class="hljs-con-string">'a'</span>)&#13;
Traceback (most recent call last):&#13;
    ...&#13;
ValueError: invalid literal for int() with base 10: 'a'&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> Sandwich(<span class="hljs-con-string">'1234'</span>, <span class="hljs-con-number">56.78</span>)&#13;
Sandwich(spam=1234, eggs=56)&#13;
</code></pre>&#13;
    <p class="normal">That all functions as expected, with similar output to the original <code class="inlineCode">dataclass</code>. Naturally, it’s far more limited in features, but it shows how you can generate your own classes and functions dynamically, and how easy it is to add automatic annotation-based type casting to your code.</p>&#13;
    <p class="normal">Next up is a deep dive into the creation and instantiation of classes.</p>&#13;
    <h1 id="_idParaDest-208" class="heading-1">Order of operations when instantiating classes</h1>&#13;
    <p class="normal">The order of operations during class instantiation<a id="_idIndexMarker580"/> is very important to keep in mind when debugging issues with dynamically created and/or modified classes. Assuming an incorrect order can cause difficult-to-trace bugs. The instantiation of a class happens in the following order:</p>&#13;
    <ol class="numberedList" style="list-style-type: decimal;">&#13;
      <li class="numberedList" value="1">Finding the metaclass</li>&#13;
      <li class="numberedList">Preparing the namespace</li>&#13;
      <li class="numberedList">Executing the class body</li>&#13;
      <li class="numberedList">Creating the class object</li>&#13;
      <li class="numberedList">Executing the class decorators</li>&#13;
      <li class="numberedList">Creating the class instance </li>&#13;
    </ol>&#13;
    <p class="normal">We will go through each of these now.</p>&#13;
    <h2 id="_idParaDest-209" class="heading-2">Finding the metaclass</h2>&#13;
    <p class="normal">The metaclass<a id="_idIndexMarker581"/> comes from either the explicitly given metaclass on the class or <code class="inlineCode">bases</code>, or by using the default <code class="inlineCode">type</code> metaclass.</p>&#13;
    <p class="normal">For every class, the class itself and the bases, the first matching of the following will be used:</p>&#13;
    <ul>&#13;
      <li class="bulletList">Explicitly given metaclass</li>&#13;
      <li class="bulletList">Explicit metaclass from <code class="inlineCode">bases</code></li>&#13;
      <li class="bulletList"><code class="inlineCode">type()</code></li>&#13;
    </ul>&#13;
    <div class="note">&#13;
      <p class="normal"> Note that if no metaclass is found that is a subtype of all of the candidate metaclasses, a <code class="inlineCode">TypeError</code> will be raised. This scenario is not that likely to occur, but is certainly a possibility when using multiple inheritance/mixins with metaclasses.</p>&#13;
    </div>&#13;
    <h2 id="_idParaDest-210" class="heading-2">Preparing the namespace</h2>&#13;
    <p class="normal">The class <a id="_idIndexMarker582"/>namespace is prepared through the metaclass selected above. If the metaclass has a <code class="inlineCode">__prepare__</code> method, it will be called as <code class="inlineCode">namespace = metaclass.__prepare__(names, bases, **kwargs)</code> where the <code class="inlineCode">**kwargs</code> originate from the class definition. If no <code class="inlineCode">__prepare__</code> method is available, the result will be <code class="inlineCode">namespace = dict()</code>.</p>&#13;
    <p class="normal">Note that there are multiple ways of achieving custom namespaces. As we saw in the previous section, the <code class="inlineCode">type()</code> function call also takes a <code class="inlineCode">dict</code> argument, which can be used to alter the namespace as well.</p>&#13;
    <h2 id="_idParaDest-211" class="heading-2">Executing the class body</h2>&#13;
    <p class="normal">The body of the class is <a id="_idIndexMarker583"/>executed very similarly to normal code execution with one key difference: the separate namespace. Since a class has a separate namespace, which shouldn’t pollute the <code class="inlineCode">globals()</code>/<code class="inlineCode">locals()</code> namespaces, it is executed within that context. The resulting call looks something like this: </p>&#13;
    <pre class="programlisting code"><code class="hljs-code">exec(body, <span class="hljs-built_in">globals</span>(), namespace)&#13;
</code></pre>&#13;
    <p class="normal">where the <code class="inlineCode">namespace</code> is the previously produced namespace.</p>&#13;
    <h2 id="_idParaDest-212" class="heading-2">Creating the class object (not instance)</h2>&#13;
    <p class="normal">Now that we have all <a id="_idIndexMarker584"/>components ready, the actual class object can be produced. This is done through the <code class="inlineCode">class_ = metaclass(name, bases, namespace, **kwargs)</code> call, which is, as you can see, actually identical to the <code class="inlineCode">type()</code> call previously discussed. The <code class="inlineCode">**kwargs</code> here are the same as the ones passed to the <code class="inlineCode">__prepare__</code> method earlier.</p>&#13;
    <p class="normal">It might be useful to note that this is also the object that will be referenced from the <code class="inlineCode">super()</code> call without arguments.</p>&#13;
    <h2 id="_idParaDest-213" class="heading-2">Executing the class decorators</h2>&#13;
    <p class="normal">Now that the class <a id="_idIndexMarker585"/>object is actually done already, the class decorators will be executed. Since this is only executed after everything else in the class object has already been constructed, it becomes difficult to modify class attributes such as which classes are being inherited and the name of the class. By modifying the <code class="inlineCode">__class__</code> object, you can still modify or overwrite these, but it is, at the very least, more difficult.</p>&#13;
    <h2 id="_idParaDest-214" class="heading-2">Creating the class instance</h2>&#13;
    <p class="normal">From the class object produced<a id="_idIndexMarker586"/> above, we can now finally create the actual instances as you normally would with a class. It should be noted that, unlike the steps above, this step and the class decorators step, are the only ones that are executed every time you instantiate a class. The steps before these two are only executed once per class definition.</p>&#13;
    <h2 id="_idParaDest-215" class="heading-2">Example</h2>&#13;
    <p class="normal">Enough theory – let’s <a id="_idIndexMarker587"/>illustrate the creation and instantiation of the class objects so we can check the order of operations:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> functools&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">decorator</span><span class="hljs-con-function">(</span><span class="hljs-con-params">name</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">_decorator</span><span class="hljs-con-function">(</span><span class="hljs-con-params">cls</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-meta">        @functools.wraps(</span><span class="hljs-con-params">cls</span><span class="hljs-con-meta">)</span>&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__decorator</span><span class="hljs-con-function">(</span><span class="hljs-con-params">*args, **kwargs</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>             print(<span class="hljs-con-string">'decorator(%s)'</span> % name)&#13;
<span class="hljs-con-meta">...</span>             <span class="hljs-con-keyword">return</span> cls(*args, **kwargs)&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">return</span> __decorator&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">return</span> _decorator&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">SpamMeta</span><span class="hljs-con-class">(</span><span class="hljs-con-built_in">type</span><span class="hljs-con-class">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-meta">    @decorator(</span><span class="hljs-con-string">'SpamMeta.__init__'</span><span class="hljs-con-meta">)</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__init__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self, name, bases, namespace, **kwargs</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>         print(<span class="hljs-con-string">'</span><span class="hljs-con-string">SpamMeta.__init__()'</span>)&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">return</span> <span class="hljs-con-built_in">type</span>.__init__(self, name, bases, namespace)&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-meta">    @staticmethod</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-meta">    @decorator(</span><span class="hljs-con-string">'</span><span class="hljs-con-string">SpamMeta.__new__'</span><span class="hljs-con-meta">)</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__new__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">cls, name, bases, namespace, **kwargs</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>         print(<span class="hljs-con-string">'SpamMeta.__new__()'</span>)&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">return</span> <span class="hljs-con-built_in">type</span>.__new__(cls, name, bases, namespace)&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-meta">    @classmethod</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-meta">    @decorator(</span><span class="hljs-con-string">'SpamMeta.__prepare__'</span><span class="hljs-con-meta">)</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__prepare__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">cls, names, bases, **kwargs</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>         print(<span class="hljs-con-string">'SpamMeta.__prepare__()'</span>)&#13;
<span class="hljs-con-meta">...</span>         namespace = <span class="hljs-con-built_in">dict</span>(spam=<span class="hljs-con-number">5</span>)&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">return</span> namespace&#13;
</code></pre>&#13;
    <p class="normal">With the created class and decorator, we can now illustrate when methods such as <code class="inlineCode">__prepare__</code> and <code class="inlineCode">__new__</code> are called:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-meta">@decorator(</span><span class="hljs-con-string">'Spam'</span><span class="hljs-con-meta">)</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">Spam</span><span class="hljs-con-class">(</span><span class="hljs-con-params">metaclass=SpamMeta</span><span class="hljs-con-class">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-meta">    @decorator(</span><span class="hljs-con-string">'Spam.__init__'</span><span class="hljs-con-meta">)</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__init__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self, eggs=</span><span class="hljs-con-number">10</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>         print(<span class="hljs-con-string">'Spam.__init__()'</span>)&#13;
<span class="hljs-con-meta">...</span>         self.eggs = eggs&#13;
decorator(SpamMeta.__prepare__)&#13;
SpamMeta.__prepare__()&#13;
decorator(SpamMeta.__new__)&#13;
SpamMeta.__new__()&#13;
decorator(SpamMeta.__init__)&#13;
SpamMeta.__init__()&#13;
&#13;
<span class="hljs-con-comment"># Testing with the class object</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> spam = Spam&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> spam.spam&#13;
5&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> spam.eggs&#13;
Traceback (most recent call last):&#13;
  ...&#13;
  File "&lt;doctest T_11_order_of_operations.rst[6]&gt;", line 1, in ...&#13;
AttributeError: 'function' object has no attribute 'eggs'&#13;
&#13;
<span class="hljs-con-comment"># Testing with a class instance</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> spam = Spam()&#13;
decorator(Spam)&#13;
decorator(Spam.__init__)&#13;
Spam.__init__()&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> spam.spam&#13;
5&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> spam.eggs&#13;
10&#13;
</code></pre>&#13;
    <p class="normal">The example clearly shows the creation order of the class:</p>&#13;
    <ol class="numberedList" style="list-style-type: decimal;">&#13;
      <li class="numberedList" value="1">Preparing the namespace through <code class="inlineCode">__prepare__</code></li>&#13;
      <li class="numberedList">Creating the class body using <code class="inlineCode">__new__</code></li>&#13;
      <li class="numberedList">Initializing the metaclass using <code class="inlineCode">__init__</code> (note: this is not the class <code class="inlineCode">__init__</code>)</li>&#13;
      <li class="numberedList">Initializing the class through the class decorator</li>&#13;
      <li class="numberedList">Initializing the class through the class <code class="inlineCode">__init__</code> function</li>&#13;
    </ol>&#13;
    <p class="normal">One thing we can <a id="_idIndexMarker588"/>note from this is that class decorators are executed each and every time the class is actually instantiated and not before that. This can be both an advantage and a disadvantage, of course, but if you wish to build a register of all subclasses, it is definitely more convenient to use a metaclass since the decorator will not register until you instantiate the class.</p>&#13;
    <p class="normal">In addition to this, having the power to modify the namespace before actually creating the class object (not the instance) can be very powerful as well. This can be convenient for sharing a certain scope between several class objects, for example, or to easily ensure that certain items are always available in the scope.</p>&#13;
    <h1 id="_idParaDest-216" class="heading-1">Storing class attributes in definition order</h1>&#13;
    <p class="normal">There are cases where the<a id="_idIndexMarker589"/> definition order makes a difference. For example, let’s assume we are creating a class that represents a CSV (Comma-Separated Values) format. The CSV format expects fields to have a particular order. In some cases, this will be indicated by a header, but it’s still useful to have a consistent field order. Similar systems are used in ORM systems such as SQLAlchemy to store the column order for table definitions, and for the input field order within forms in Django.</p>&#13;
    <h2 id="_idParaDest-217" class="heading-2">The classic solution without metaclasses</h2>&#13;
    <p class="normal">An easy way to store the<a id="_idIndexMarker590"/> order of the fields is by giving the field instances a special <code class="inlineCode">__init__</code> method that increments for every definition, so the fields have an incrementing index property. This solution could be considered the classic solution, as it would also work in Python 2:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> itertools&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">Field</span><span class="hljs-con-class">(</span><span class="hljs-con-built_in">object</span><span class="hljs-con-class">):</span>&#13;
<span class="hljs-con-meta">...</span>     counter = itertools.count()&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__init__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self, name=</span><span class="hljs-con-literal">None</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>         self.name = name&#13;
<span class="hljs-con-meta">...</span>         self.index = <span class="hljs-con-built_in">next</span>(Field.counter)&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__repr__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">return</span> <span class="hljs-con-string">'&lt;%s[%d] %s&gt;'</span> % (&#13;
<span class="hljs-con-meta">...</span>             self.__class__.__name__,&#13;
<span class="hljs-con-meta">...</span>             self.index,&#13;
<span class="hljs-con-meta">...</span>             self.name,&#13;
<span class="hljs-con-meta">...</span>         )&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">FieldsMeta</span><span class="hljs-con-class">(</span><span class="hljs-con-built_in">type</span><span class="hljs-con-class">):</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__new__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">metaclass, name, bases, namespace</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>         cls = <span class="hljs-con-built_in">type</span>.__new__(metaclass, name, bases, namespace)&#13;
<span class="hljs-con-meta">...</span>         fields = []&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">for</span> k, v <span class="hljs-con-keyword">in</span> namespace.items():&#13;
<span class="hljs-con-meta">...</span>             <span class="hljs-con-keyword">if</span> <span class="hljs-con-built_in">isinstance</span>(v, Field):&#13;
<span class="hljs-con-meta">...</span>                 fields.append(v)&#13;
<span class="hljs-con-meta">...</span>                 v.name = v.name <span class="hljs-con-keyword">or</span> k&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span>         cls.fields = <span class="hljs-con-built_in">sorted</span>(fields, key=<span class="hljs-con-keyword">lambda</span> f: f.index)&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">return</span> cls&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">Fields</span><span class="hljs-con-class">(</span><span class="hljs-con-params">metaclass=FieldsMeta</span><span class="hljs-con-class">):</span>&#13;
<span class="hljs-con-meta">...</span>     spam = Field()&#13;
<span class="hljs-con-meta">...</span>     eggs = Field()&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> Fields.fields&#13;
[&lt;Field[0] spam&gt;, &lt;Field[1] eggs&gt;]&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> fields = Fields()&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> fields.eggs.index&#13;
1&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> fields.spam.index&#13;
0&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> fields.fields&#13;
[&lt;Field[0] spam&gt;, &lt;Field[1] eggs&gt;]&#13;
</code></pre>&#13;
    <p class="normal">For convenience, and <a id="_idIndexMarker591"/>to make things prettier, we have added the <code class="inlineCode">FieldsMeta</code> class. </p>&#13;
    <p class="normal">It is not strictly required here, but it automatically takes care of filling in the <code class="inlineCode">name</code> if needed, and adds the <code class="inlineCode">fields</code> list, which contains a sorted list of fields.</p>&#13;
    <h2 id="_idParaDest-218" class="heading-2">Using metaclasses to get a sorted namespace</h2>&#13;
    <p class="normal">The previous <a id="_idIndexMarker592"/>solution is a bit more straightforward<a id="_idIndexMarker593"/> and supports Python 2 as well, but with Python 3 we have more options. As you have seen in the previous section, Python 3 gave us the <code class="inlineCode">__prepare__</code> method, which returns the namespace. From <em class="chapterRef">Chapter 4</em>, you might remember <code class="inlineCode">collections.OrderedDict</code>, so let’s see what happens when we combine them:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> collections&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">Field</span><span class="hljs-con-class">(</span><span class="hljs-con-built_in">object</span><span class="hljs-con-class">):</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__init__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self, name=</span><span class="hljs-con-literal">None</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>         self.name = name&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__repr__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">return</span> <span class="hljs-con-string">'&lt;%s %s&gt;'</span> % (&#13;
<span class="hljs-con-meta">...</span>             self.__class__.__name__,&#13;
<span class="hljs-con-meta">...</span>             self.name,&#13;
<span class="hljs-con-meta">...</span>         )&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">FieldsMeta</span><span class="hljs-con-class">(</span><span class="hljs-con-built_in">type</span><span class="hljs-con-class">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-meta">    @classmethod</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__prepare__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">metaclass, name, bases</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">return</span> collections.OrderedDict()&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__new__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">metaclass, name, bases, namespace</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>         cls = <span class="hljs-con-built_in">type</span>.__new__(metaclass, name, bases, namespace)&#13;
<span class="hljs-con-meta">...</span>         cls.fields = []&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">for</span> k, v <span class="hljs-con-keyword">in</span> namespace.items():&#13;
<span class="hljs-con-meta">...</span>             <span class="hljs-con-keyword">if</span> <span class="hljs-con-built_in">isinstance</span>(v, Field):&#13;
<span class="hljs-con-meta">...</span>                 cls.fields.append(v)&#13;
<span class="hljs-con-meta">...</span>                 v.name = v.name <span class="hljs-con-keyword">or</span> k&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">return</span> cls&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">Fields</span><span class="hljs-con-class">(</span><span class="hljs-con-params">metaclass=FieldsMeta</span><span class="hljs-con-class">):</span>&#13;
<span class="hljs-con-meta">...</span>     spam = Field()&#13;
<span class="hljs-con-meta">...</span>     eggs = Field()&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> Fields.fields&#13;
[&lt;Field spam&gt;, &lt;Field eggs&gt;]&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> fields = Fields()&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> fields.fields&#13;
[&lt;Field spam&gt;, &lt;Field eggs&gt;]&#13;
</code></pre>&#13;
    <p class="normal">As you can see, the <a id="_idIndexMarker594"/>fields are indeed in the order we<a id="_idIndexMarker595"/> defined them. Spam first, eggs after that. Since the class namespace is now a <code class="inlineCode">collections.OrderedDict</code> instance, we know that the order is guaranteed. It should be noted that, since Python 3.6, the order of the regular <code class="inlineCode">dict</code> is also consistent, but the usage example of <code class="inlineCode">__prepare__</code> is still useful. It demonstrates how convenient metaclasses can be to extend your classes in a generic way. Another big advantage of metaclasses instead of a custom <code class="inlineCode">__init__</code> method is that users won’t lose the functionality if they <a id="_idIndexMarker596"/>forget to call the parent <code class="inlineCode">__init__</code> method. The <a id="_idIndexMarker597"/>metaclass will always be executed, unless a different metaclass is added, that is.</p>&#13;
    <h1 id="_idParaDest-219" class="heading-1">Exercises</h1>&#13;
    <p class="normal">The most important point of this chapter is to teach you how metaclasses work internally: a metaclass is just a class that creates a class, which, in turn, is created by another metaclass (eventually ending up recursively at <code class="inlineCode">type</code>). If you want to challenge yourself, however, there is more you can do with metaclasses:</p>&#13;
    <ul>&#13;
      <li class="bulletList">Validation is one of the most prominent examples of where metaclasses can be useful. You can validate to check if attributes/methods are available, you can check if required classes are inherited, and so on. The possibilities are endless.</li>&#13;
      <li class="bulletList">Build a metaclass that wraps every method with a decorator (could be useful for logging/debugging purposes), something with a signature like this:&#13;
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">SomeClass</span><span class="hljs-class">(</span><span class="hljs-params">metaclass=WrappingMeta, wrapper=some_wrapper</span><span class="hljs-class">):</span>&#13;
</code></pre>&#13;
      </li>&#13;
    </ul>&#13;
    <div class="note">&#13;
      <p class="normal">Example answers for these exercises can be found on GitHub: <a href="Chapter_8.xhtml"><span class="url">https://github.com/mastering-python/exercises</span></a>. You are encouraged to submit your own solutions and learn about alternative solutions from others.</p>&#13;
    </div>&#13;
    <h1 id="_idParaDest-220" class="heading-1">Summary</h1>&#13;
    <p class="normal">The Python metaclass system is something every Python programmer uses all the time, perhaps without even knowing about it. Every class is created through some (subclass of) <code class="inlineCode">type</code>, which allows for endless customization and magic. </p>&#13;
    <p class="normal">Instead of statically defining your class, you can now have it created as you normally would and dynamically add, modify, or remove attributes from your class during definition; very magical but very useful. The magic component, however, is also the reason why metaclasses should be used with a lot of caution. While they can be used to make your life much easier, they are also among the easiest ways of producing completely incomprehensible code.</p>&#13;
    <p class="normal">Regardless, there are some great use cases for metaclasses, and many libraries such as SQLAlchemy and Django use metaclasses to make your code work much more easily and arguably better. Actually comprehending the magic that is used inside is generally not needed for the usage of these libraries, which makes the cases defendable. </p>&#13;
    <p class="normal">The question becomes whether a much better experience for beginners is worth some dark magic internally, and looking at the success of these libraries, I would say <em class="italic">yes</em> in this case.</p>&#13;
    <p class="normal">To conclude, when thinking about using metaclasses, keep in mind what Tim Peters once said: </p>&#13;
    <blockquote class="packt_quote">&#13;
      <p class="quote"> “Metaclasses are deeper magic than 99% of users should ever worry about.If you wonder whether you need them, you don’t.”</p>&#13;
    </blockquote>&#13;
    <p class="normal">With the introduction of class decorators and methods such as <code class="inlineCode">__init_subclass__</code> and <code class="inlineCode">__set_name__</code>, the need for metaclasses has dwindled even further. So when in doubt, you probably have no real need for them.</p>&#13;
    <p class="normal">Now we will continue with a solution to remove some of the magic that metaclasses generate – documentation. The next chapter will show us how your code can be documented, how that documentation can be tested, and most importantly, how the documentation can be made smarter by annotating types.</p>&#13;
    <h1 class="heading-1">Join our community on Discord</h1>&#13;
    <p class="normal">Join our community’s Discord space for discussions with the author and other readers: <a href="https://discord.gg/QMzJenHuJf"><span class="url">https://discord.gg/QMzJenHuJf</span></a></p>&#13;
    <p class="normal"><img src="Images/QR_Code156081100001293319171.png" alt="" width="177" height="177"/></p>&#13;
  </div>&#13;
</div></body></html>