<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer213">
<h1 class="chapter-number" id="_idParaDest-157"><a id="_idTextAnchor157"/>10</h1>
<h1 id="_idParaDest-158"><a id="_idTextAnchor158"/>Integrating LoRa with the Internet</h1>
<p>In this chapter, we will take the sensory information from our remotely placed LoRa sensory transmitter and publish it to the internet using our Raspberry Pi Pico W-equipped <strong class="bold">LoRa</strong> receiver. Our internet destination<a id="_idIndexMarker750"/> will be an MQTT instance on our CloudAMQP server. We will then connect a modified version of the analog-metered weather indicator we created in <a href="B21282_03.xhtml#_idTextAnchor048"><span class="No-Break"><em class="italic">Chapter 3</em></span></a> to our MQTT server and use this data to position the needle and set the color of the LED indicator based on the humidity reading. This modification will entail swapping out the Raspberry Pi we installed on the analog-metered weather indicator for a Raspberry Pi Pico WH (also referred to as a Raspberry Pi Pico W with headers) and the single-color LED with an <span class="No-Break">RGB LED.</span></p>
<p>By transitioning from a standard weather web service to utilizing a remote LoRa sensory transmitter that measures temperature and humidity, and subsequently converts this data into MQTT messages, we are effectively creating a customized weather web service – a service that is powered by LoRa technology for its data transmission needs and MQTT for <span class="No-Break">internet communication.</span></p>
<p>We will conclude this chapter with<a id="_idIndexMarker751"/> a look at various other technologies for <strong class="bold">Internet of Things</strong> (<strong class="bold">IoT</strong>) communication, such <a id="_idIndexMarker752"/>as <strong class="bold">LoRaWAN</strong> and cellular technologies, and explore the benefits and drawbacks of <span class="No-Break">each technology.</span></p>
<p>We will cover the following in <span class="No-Break">this chapter:</span></p>
<ul>
<li>Connecting our LoRa receiver to <span class="No-Break">the internet</span></li>
<li>Creating a new <span class="No-Break">weather indicator</span></li>
<li>Exploring other IoT <span class="No-Break">communication protocols</span></li>
</ul>
<p><span class="No-Break">Let’s begin!</span></p>
<h1 id="_idParaDest-159"><a id="_idTextAnchor159"/>Technical requirements</h1>
<p>The following are the requirements for completing <span class="No-Break">this chapter:</span></p>
<ul>
<li>Intermediate knowledge of <span class="No-Break">Python programming.</span></li>
<li>1 X Raspberry Pi <span class="No-Break">Pico WH.</span></li>
<li>1 X LoRa sensory transmitter from <a href="B21282_09.xhtml#_idTextAnchor140"><span class="No-Break"><em class="italic">Chapter 9</em></span></a><span class="No-Break">.</span></li>
<li>1 X LoRa receiver built with the Raspberry Pi Pico W from <a href="B21282_09.xhtml#_idTextAnchor140"><span class="No-Break"><em class="italic">Chapter 9</em></span></a><span class="No-Break">.</span></li>
<li>A CloudAMQP account for the MQTT <span class="No-Break">server instance.</span></li>
<li>1 X SG90 <span class="No-Break">servo motor.</span></li>
<li>1 X common anode <span class="No-Break">RGB LED.</span></li>
<li>3 X 220 <span class="No-Break">Ohm resistors.</span></li>
<li>1 X 8 mm <span class="No-Break">LED holder.</span></li>
<li>9 X M3 10 <span class="No-Break">mm bolts.</span></li>
<li>4 X M2 8 <span class="No-Break">mm screws.</span></li>
<li>1 X M5 20 <span class="No-Break">mm bolt.</span></li>
<li>1 X <span class="No-Break">M5 nut.</span></li>
<li>Epoxy glue for constructing the weather <span class="No-Break">indicator faceplate.</span></li>
<li>A hot <span class="No-Break">glue gun.</span></li>
<li>A color printer to print out the <span class="No-Break">faceplate graphic.</span></li>
<li>A digital cutting machine such as a Silhouette Cameo. This is optional as the faceplate graphic may be cut out by hand. Silhouette Studio 3 <span class="No-Break">file provided.</span></li>
<li>Access to a 3D printer to print the weather <span class="No-Break">indicator stand.</span></li>
</ul>
<p>The code for this chapter may be found <span class="No-Break">here: </span><a href="https://github.com/PacktPublishing/Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter10%20"><span class="No-Break">https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter10</span></a></p>
<h1 id="_idParaDest-160"><a id="_idTextAnchor160"/>Connecting our LoRa receiver to the internet</h1>
<p>Our first task is to revise the code on our CircuitPython-based LoRa receiver, enabling it to forward LoRa messages <a id="_idIndexMarker753"/>received by our CloudAMQP server. We’ll use Adafruit CircuitPython libraries for this update. Before building and programming our new weather indicator to process MQTT messages, we’ll test the MQTT functionality using the MQTT-Explorer app in Windows. We can see an outline of this chapter’s project in the <span class="No-Break">following diagram:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer195">
<img alt="Figure 10.1 – Controlling an analog-metered weather indicator with LoRa-transmitted sensory data" height="876" src="image/B21282_10_01.jpg" width="1427"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.1 – Controlling an analog-metered weather indicator with LoRa-transmitted sensory data</p>
<p>In <span class="No-Break"><em class="italic">Figure 10</em></span><em class="italic">.1</em>, we can see that our Raspberry Pi Pico LoRa sensory transmitter from <a href="B21282_09.xhtml#_idTextAnchor140"><span class="No-Break"><em class="italic">Chapter 9</em></span></a> sends temperature and humidity data through LoRa to the LoRa receiver we also built in <a href="B21282_09.xhtml#_idTextAnchor140"><span class="No-Break"><em class="italic">Chapter 9</em></span></a>. We do not need to change the code for our transmitter as it performs what we need it to do. As mentioned, we will update the code for our LoRa receiver as we require it to connect to the internet and send <span class="No-Break">MQTT messages.</span></p>
<p>Once we establish that our MQTT code is working properly, we will build a new version of the weather indicator <a id="_idIndexMarker754"/>and program it to respond accordingly to the <span class="No-Break">MQTT messages.</span></p>
<p>We will start by adding the CircuitPython MQTT library to our <span class="No-Break">LoRa receiver.</span></p>
<h2 id="_idParaDest-161"><a id="_idTextAnchor161"/>Installing the CircuitPython library for MQTT</h2>
<p>MQTT libraries for <a id="_idIndexMarker755"/>microcontrollers enable IoT devices to use the MQTT protocol, a messaging system optimized for low bandwidth and <a id="_idIndexMarker756"/>minimal device resources. These libraries, designed for various microcontroller platforms, enable connections to MQTT brokers, message publishing, and <span class="No-Break">topic subscriptions.</span></p>
<p>Among these, the Adafruit MiniMQTT library is notable for CircuitPython devices. This library offers a straightforward API, suitable for boards such as the Raspberry Pi Pico W. It supports key MQTT features such as publish/subscribe and works with various <span class="No-Break">MQTT brokers.</span></p>
<p>To install the MiniMQTT library, we do <span class="No-Break">the following:</span></p>
<ol>
<li>Using a web browser, we navigate to the <span class="No-Break">URL </span><a href="https://circuitpython.org/libraries"><span class="No-Break">https://circuitpython.org/libraries</span></a><span class="No-Break">.</span></li>
<li>As we are using CircuitPython 8, we download the <strong class="source-inline">adafruit-circuitpython-bundle-8.x-mpy-20231205.zip</strong> ZIP file and unzip it to a location on <span class="No-Break">our computer.</span></li>
<li>We want to install the library files in the <strong class="source-inline">lib</strong> folder on our Raspberry Pi Pico W and not the root directory. So, we need to double-click on the <strong class="source-inline">lib</strong> folder under the <strong class="bold">CircuitPython</strong> section in Thonny to <span class="No-Break">open it.</span></li>
<li>The files we are interested in from the Adafruit library are in the <strong class="source-inline">adafruit_minimqtt</strong> folder. To install these files onto our Raspberry Pi Pico W from Thonny, we open the folder in the <strong class="bold">Files</strong> section in Thonny and right-click to get the <span class="No-Break">following dialog:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer196">
<img alt="Figure 10.2 – Uploading the MQTT library to the Raspberry Pi Pico" height="552" src="image/B21282_10_02.jpg" width="692"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.2 – Uploading the MQTT library to the Raspberry Pi Pico</p>
<ol>
<li value="5">After uploading<a id="_idIndexMarker757"/> the libraries to the Pico W, the<a id="_idIndexMarker758"/> file structure on our Pico should look like <span class="No-Break">the following:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer197">
<img alt="Figure 10.3 – Pico W file structure after uploading Mini MQTT" height="260" src="image/B21282_10_03.jpg" width="859"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.3 – Pico W file structure after uploading Mini MQTT</p>
<p>With the Adafruit MQTT library<a id="_idIndexMarker759"/> set up on our <a id="_idIndexMarker760"/>Raspberry Pi Pico W, our next step is to configure a CloudAMQP instance to broker our <span class="No-Break">MQTT messages.</span></p>
<p>Let’s do <span class="No-Break">that now.</span></p>
<h2 id="_idParaDest-162"><a id="_idTextAnchor162"/>Creating a CloudAMQP instance for our application</h2>
<p>Having already set up<a id="_idIndexMarker761"/> an account in <a href="B21282_07.xhtml#_idTextAnchor107"><span class="No-Break"><em class="italic">Chapter 7</em></span></a>, we’re now prepared to create a CloudAMQP instance to act as the broker for MQTT messages from our Raspberry Pi Pico W. Following the steps outlined in the <em class="italic">Setting up a CloudAMQP instance</em> section of <a href="B21282_07.xhtml#_idTextAnchor107"><span class="No-Break"><em class="italic">Chapter 7</em></span></a>, we create a new instance, call it <strong class="source-inline">RemoteWeatherStation</strong>, and record the details for use in our LoRa <span class="No-Break">receiver code.</span></p>
<p>We’ll utilize the WebSocket UI of our CloudAMQP instance to observe messages from our LoRa transmitter, enabling us to test our application thoroughly before constructing and implementing our new <span class="No-Break">weather indicator.</span></p>
<p>Let’s go ahead and modify the code on our LoRa receiver by adding MQTT functionality so that it can publish MQTT messages to the <span class="No-Break"><strong class="source-inline">RemoteWeatherStation</strong></span><span class="No-Break"> instance.</span></p>
<h2 id="_idParaDest-163"><a id="_idTextAnchor163"/>Adding MQTT functionality to the LoRa receiver</h2>
<p>With our CloudAMQP instance <a id="_idIndexMarker762"/>created, we will now<a id="_idIndexMarker763"/> enhance the code on our LoRa receiver to incorporate Wi-Fi and MQTT functionalities. This modification enables the receiver to effectively utilize LoRa to receive sensory data from our transmitter and then leverage Wi-Fi for <span class="No-Break">internet connectivity.</span></p>
<p>Utilizing the MQTT protocol, the receiver can transmit this sensory data to our CloudAMQP server. This integration not only demonstrates the synergy between different communication technologies – LoRa for local, long-range transmission and MQTT over Wi-Fi for global reach – but also greatly expands the capabilities of our IoT ecosystem. Our LoRa receiver becomes a bridge, gathering sensory information locally and distributing it over <span class="No-Break">the</span><span class="No-Break"><a id="_idIndexMarker764"/></span><span class="No-Break"> internet.</span></p>
<p>To modify the LoRa receiver<a id="_idIndexMarker765"/> code, we do <span class="No-Break">the following:</span></p>
<ol>
<li>We connect our Raspberry Pi Pico W from our LoRa receiver to a USB port and launch Thonny using a computer and operating system of <span class="No-Break">our choice.</span></li>
<li>We then activate the CircuitPython environment on our Pico W by selecting it from the bottom right-hand side of <span class="No-Break">the screen.</span></li>
<li>In a new tab in the editor section (hit <em class="italic">Ctrl</em> + <em class="italic">N</em>), we start by entering <span class="No-Break">our imports:</span><pre class="source-code">
import time
import board
import busio
import digitalio
import adafruit_rfm9x
import wifi
import socketpool
from adafruit_minimqtt.adafruit_minimqtt import MQTT</pre><p class="list-inset">In our code, we have <span class="No-Break">the following:</span></p><ul><li>The <strong class="source-inline">time</strong> library is used for timing and delays in <span class="No-Break">the code.</span></li><li>The <strong class="source-inline">board</strong> module provides access to the basic pin setup of <span class="No-Break">the microcontroller.</span></li><li>The <strong class="source-inline">busio</strong> module is used to create bus communication interfaces, essential for devices such as the RFM9x <span class="No-Break">LoRa module.</span></li><li><strong class="source-inline">digitalio</strong> is utilized for managing digital <span class="No-Break">I/O pins.</span></li><li>The <strong class="source-inline">adafruit_rfm9x</strong> module is specifically for interfacing with the RFM95W LoRa radio modules installed on the <span class="No-Break">LoRa receiver.</span></li><li>The <strong class="source-inline">wifi</strong> module is included to handle Wi-Fi connections on <span class="No-Break">the microcontroller.</span></li><li><strong class="source-inline">socketpool</strong> provides <a id="_idIndexMarker766"/>a way to manage network sockets, which are needed for internet <a id="_idIndexMarker767"/>communication. In our CircuitPython code, this module is essential for efficiently managing network sockets, which is crucial for MQTT communications via the <strong class="source-inline">adafruit_minimqtt</strong> library. It provides stable TCP/IP connections <span class="No-Break">over Wi-Fi.</span></li><li><strong class="source-inline">adafruit_minimqtt</strong> is imported to enable MQTT protocol communication, allowing the device to publish and subscribe to <span class="No-Break">MQTT topics.</span></li></ul></li> <li>After our imports, we set our Wi-Fi network (SSID) and <span class="No-Break">Wi-Fi password:</span><pre class="source-code">
WIFI_SSID = 'MySSID'
WIFI_PASSWORD = 'wifi-password'</pre></li> <li>We then enter code to initialize the <strong class="source-inline">GP5</strong> GPIO pin as a digital output to control an LED connected to that pin on <span class="No-Break">the microcontroller:</span><pre class="source-code">
led = digitalio.DigitalInOut(board.GP5)
led.direction = digitalio.Direction.OUTPUT</pre></li> <li>We define the <strong class="source-inline">flash_led()</strong> method, which blinks an LED a specified number of times, with each blink lasting for the duration set <span class="No-Break">in seconds:</span><pre class="source-code">
def flash_led(times, duration):
    for _ in range(times):
        led.value = True
        time.sleep(duration)
        led.value = False
        time.sleep(duration)</pre></li> <li>Next, we define the <strong class="source-inline">connect_to_wifi()</strong> function. This function repeatedly tries to connect to Wi-Fi with the provided SSID and password, signaling a failed attempt by blinking an<a id="_idIndexMarker768"/> LED twice for 2 seconds each, followed by a 5-second pause before retrying. Upon successful<a id="_idIndexMarker769"/> connection, it exits the loop and blinks the LED four times, each for 1 second, to indicate a successful <span class="No-Break">Wi-Fi connection:</span><pre class="source-code">
def connect_to_wifi(ssid, password):
    while True:
        try:
            print("Trying to connect to WiFi...")
            wifi.radio.connect(ssid, password)
            print("Connected to Wi-Fi!")
            flash_led(4, 1)
            break
        except Exception as e:
            print("Failed to connect to WiFi. Retrying...")
            flash_led(2, 2)
            time.sleep(5)
connect_to_wifi(WIFI_SSID, WIFI_PASSWORD)
flash_led(4, 1)</pre></li> <li>We then create the <strong class="source-inline">pool</strong> variable, an instance of <strong class="source-inline">socketpool.SocketPool</strong>, using the <strong class="source-inline">wifi.radio</strong> object, which manages and provides network socket connections for <span class="No-Break">Wi-Fi communication:</span><pre class="source-code">
pool = socketpool.SocketPool(wifi.radio)</pre></li> <li>Next, our code sets up the<a id="_idIndexMarker770"/> MQTT configuration, defining the server address (<strong class="source-inline">MQTT_SERVER</strong>), port <a id="_idIndexMarker771"/>number (<strong class="source-inline">MQTT_PORT</strong>), user credentials (<strong class="source-inline">USERNAME</strong> and <strong class="source-inline">PASSWORD</strong>), device identifier (<strong class="source-inline">DEVICE_ID</strong>), and MQTT topic (<strong class="source-inline">MQTT_TOPIC</strong>) for communication. We obtain these values from the CloudAMQP instance we set up for <span class="No-Break">our application:</span><pre class="source-code">
MQTT_SERVER = "mqtt-server-url"
MQTT_PORT = 18756
USERNAME = "instance-username"
PASSWORD = "instance-password"
DEVICE_ID = "LoRaReceiver"
MQTT_TOPIC = "WeatherInfo"</pre></li> <li>We then configure the <strong class="bold">Serial Peripheral Interface</strong> (<strong class="bold">SPI</strong>) for the RFM95W LoRa module, setting up<a id="_idIndexMarker772"/> the SPI bus with GPIO pins <strong class="source-inline">GP18</strong>, <strong class="source-inline">GP19</strong>, and <strong class="source-inline">GP16</strong> for SCK, MOSI, and MISO, respectively, and initialize digital I/O pins <strong class="source-inline">GP17</strong> and <strong class="source-inline">GP14</strong> for <strong class="bold">chip select</strong> (<strong class="bold">CS</strong>) and <strong class="bold">reset</strong> (<strong class="bold">RST</strong>) functions. The CS pin is used to select the LoRa module for communication, while the RST pin is employed to reset the module, ensuring it starts in a <span class="No-Break">known state:</span><pre class="source-code">
spi = busio.SPI(board.GP18, MOSI=board.GP19, MISO=board.GP16)
cs = digitalio.DigitalInOut(board.GP17)
rst = digitalio.DigitalInOut(board.GP14)</pre></li> <li>We initialize the RFM9x LoRa radio module by creating an instance of <strong class="source-inline">adafruit_rfm9x.RFM9x</strong> with the previously configured SPI bus (<strong class="source-inline">spi</strong>), chip select (<strong class="source-inline">cs</strong>), and reset (<strong class="source-inline">rst</strong>) pins, and set the operating frequency to 915.0 MHz as our example is built for <a id="_idIndexMarker773"/>use in <span class="No-Break">North America:</span><pre class="source-code">
rfm9x = adafruit_rfm9x.RFM9x(spi, cs, rst, 915.0)</pre></li> <li>We then set up an <a id="_idIndexMarker774"/>MQTT client by creating an instance of MQTT with the specified MQTT broker details (<strong class="source-inline">MQTT_SERVER</strong> and <strong class="source-inline">MQTT_PORT</strong>), user credentials (<strong class="source-inline">USERNAME</strong> and <strong class="source-inline">PASSWORD</strong>), and the previously created socket pool (<strong class="source-inline">pool</strong>) for <span class="No-Break">network communication:</span><pre class="source-code">
mqtt_client = MQTT(broker=MQTT_SERVER, port=MQTT_PORT, username=USERNAME, password=PASSWORD, socket_pool=pool)</pre></li> <li>Our code connects the MQTT client to the MQTT broker and prints a message indicating that the system is now ready to listen for incoming <span class="No-Break">LoRa messages:</span><pre class="source-code">
mqtt_client.connect()
print("Listening for LoRa messages...")</pre></li> <li>We create a continuous loop to check for incoming packets from the RFM9x LoRa module; upon receiving a packet, our code decodes the message to UTF-8 format, prints the received message, flashes the LED twice for 0.5 seconds each, then publishes the message to the specified MQTT topic and prints a confirmation of the sent<a id="_idIndexMarker775"/> <span class="No-Break">MQTT message:</span><pre class="source-code">
while True:
    packet = rfm9x.receive()
    if packet is not None:
        message = packet.decode("utf-8")
        print("Received LoRa message:", message)
        flash_led(2, 0.5)
        mqtt_client.publish(MQTT_TOPIC, message)
        print("Sent MQTT message:", message)</pre></li> <li>To save the file, we <a id="_idIndexMarker776"/>click on <strong class="bold">File</strong> | <strong class="bold">Save as...</strong> from the drop-down menu. This will open the <strong class="bold">Where to save </strong><span class="No-Break"><strong class="bold">to?</strong></span><span class="No-Break"> dialog.</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer198">
<img alt="Figure 10.4 – Saving our file to our Raspberry Pi Pico W" height="244" src="image/B21282_10_04.jpg" width="818"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.4 – Saving our file to our Raspberry Pi Pico W</p>
<ol>
<li value="16">In this dialog, we are given the option to choose where to store our file. To save it on our Raspberry Pi Pico W (CircuitPython device), we click on the <span class="No-Break">corresponding button.</span></li>
<li>We then give the file the name <strong class="source-inline">code.py</strong> and <span class="No-Break">click </span><span class="No-Break"><strong class="bold">Ok</strong></span><span class="No-Break">.</span></li>
<li>To run our code, we click on the green run button, hit <em class="italic">F5</em> on the keyboard or click on the <strong class="bold">Run</strong> menu option at the top, and then select <strong class="bold">Run </strong><span class="No-Break"><strong class="bold">current script</strong></span><span class="No-Break">.</span></li>
<li>If it is not already running, we<a id="_idIndexMarker777"/> power up and run the LoRa <span class="No-Break">sensory transmitter.</span></li>
<li>We verify the correct functioning of our code by checking the receipt of MQTT messages in the MQTT-Explorer app <span class="No-Break">in Windows.</span></li>
<li>We should also observe our LED <span class="No-Break">flashes twice.</span></li>
</ol>
<p>By taking temperature and humidity readings from the LoRa sensory transmitter and relaying them to our MQTT <a id="_idIndexMarker778"/>server using our LoRa receiver, much like a baton pass in a relay race, we have effectively established our own weather information <span class="No-Break">web service.</span></p>
<p>With our setup ready, we <a id="_idIndexMarker779"/>can now utilize the MQTT message data to operate our improved analog meter-style weather indicator. Our first step is to construct the device, followed by programming it to respond to <span class="No-Break">incoming data.</span></p>
<h1 id="_idParaDest-164"><a id="_idTextAnchor164"/>Creating a new weather indicator</h1>
<p>In this section, we introduce an upgraded weather indicator, building on the version from <a href="B21282_03.xhtml#_idTextAnchor048"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>. This model features <a id="_idIndexMarker780"/>an RGB LED instead of a single-color LED. We will use it to indicate humidity by setting the color to red for low humidity, green for a humidity level between 30 and 50 percent (considered a comfortable humidity level for people), and blue for a humidity above 50 percent. The device now uses the economical Raspberry Pi Pico WH as opposed to the more expensive Raspberry Pi 5. A new addition is the reset button for the Raspberry Pi Pico WH, allowing us to reset the Pico if we <span class="No-Break">need to.</span></p>
<p>The design of our upgraded weather indicator includes a new feature: a split stand specifically engineered for easier printing using a <strong class="bold">Fused Deposition Modeling</strong> (<strong class="bold">FDM</strong>) 3D printer. By dividing the <a id="_idIndexMarker781"/>stand into two separate parts, each piece can be printed flat. When printed flat, the layer lines in each section of the stand run perpendicular to the primary stress axis encountered during use. This perpendicular arrangement of the layers effectively distributes stress across the structure, making the stand more resilient and less prone to breakage or warping <span class="No-Break">under load.</span></p>
<p>We will start the construction of our new weather indicator by building the <span class="No-Break">split stand.</span></p>
<h2 id="_idParaDest-165"><a id="_idTextAnchor165"/>Building the split stand</h2>
<p>We may use any of the <a id="_idIndexMarker782"/>stands we have built so far in the book to mount our weather indicator faceplate. For our example, we introduce a split stand that may be printed using a standard FDM 3D printer or a liquid resin 3D printer. The parts of the split stand can be seen in the <span class="No-Break">following figure:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer199">
<img alt="Figure 10.5 – Split stand printed with PLA and a FDM 3D printe" height="670" src="image/B21282_10_05.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.5 – Split stand printed with PLA and a FDM 3D printer</p>
<p>The parts of the split<a id="_idIndexMarker783"/> stand are <span class="No-Break">as follows:</span></p>
<ul>
<li><em class="italic">A</em>: Right <span class="No-Break">split stand</span></li>
<li><em class="italic">B</em>: Left <span class="No-Break">split stand</span></li>
<li><span class="No-Break"><em class="italic">C</em></span><span class="No-Break">: Base</span></li>
<li><em class="italic">D</em> (not shown): 9 X M3 10 <span class="No-Break">mm bolts</span></li>
<li><em class="italic">E</em> (not shown): 4 X 12 mm rubber <span class="No-Break">pads (optional)</span></li>
</ul>
<p>The <strong class="source-inline">.stl</strong> files for our split stand are located in the <strong class="source-inline">Build Files</strong> folder of this chapter’s GitHub repository. All three parts shown in <span class="No-Break"><em class="italic">Figure 10</em></span><em class="italic">.5</em> may be printed together on a standard Ender-3-sized print bed (220 mm by 220 mm by <span class="No-Break">250 mm).</span></p>
<p>When using an FDM printer, it’s important to slice the print file with support structures, especially since the outer ring of the split stand <em class="italic">floats</em> in space when printed flat. For the split stand, <strong class="bold">Polylactic Acid</strong> (<strong class="bold">PLA</strong>) material is<a id="_idIndexMarker784"/> the optimal choice due to its printing ease and <span class="No-Break">reliable results.</span></p>
<p>We can see how we may position the parts of the split stand on a print bed in the <span class="No-Break">following figure.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer200">
<img alt="Figure 10.6 – Laying out the parts of the split stand for 3D printing on a print bed" height="515" src="image/B21282_10_06.jpg" width="1136"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.6 – Laying out the parts of the split stand for 3D printing on a print bed</p>
<p>To construct the stand, we<a id="_idIndexMarker785"/> follow the steps shown in <span class="No-Break"><em class="italic">Figure 10</em></span><span class="No-Break"><em class="italic">.7</em></span><span class="No-Break">:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer201">
<img alt="Figure 10.7 – Constructing the split stand" height="660" src="image/B21282_10_07.jpg" width="1483"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.7 – Constructing the split stand</p>
<ol>
<li>Utilizing an M3 tap, we carefully create screw threads on the right side of the split stand (<em class="italic">A</em> from <span class="No-Break"><em class="italic">Figure 10</em></span><em class="italic">.5</em>). This step is optional as the holes should be large enough to allow M3 bolts to screw in <span class="No-Break">without tapping.</span></li>
<li>Using five M3 10 <a id="_idIndexMarker786"/>mm bolts, we secure the left split stand (<em class="italic">C</em> from <span class="No-Break"><em class="italic">Figure 10</em></span><em class="italic">.5</em>) to the right split stand (<em class="italic">A</em> from <span class="No-Break"><em class="italic">Figure 10</em></span><span class="No-Break"><em class="italic">.5</em></span><span class="No-Break">).</span></li>
<li>Next, we attach four standard 12 mm rubber pads to the base’s bottom as feet, using epoxy glue for enhanced adhesion. This step, while not mandatory, adds stability as the stand can function without the <span class="No-Break">rubber pads.</span></li>
<li>Using an M3 tap, we create screw threads in the base. This step is optional as the holes should be large enough to allow M3 bolts to screw in <span class="No-Break">without tapping.</span></li>
<li>Using four M3 bolts, we secure the assembled stand to the base (<em class="italic">C</em> from <span class="No-Break"><em class="italic">Figure 10</em></span><span class="No-Break"><em class="italic">.5</em></span><span class="No-Break">).</span></li>
</ol>
<p>The assembled split stand can be painted for aesthetic improvement. Once the split stand is finished, the next step is to assemble the faceplate of our <span class="No-Break">weather indicator.</span></p>
<h2 id="_idParaDest-166"><a id="_idTextAnchor166"/>Building the faceplate</h2>
<p>The faceplate for our new enhanced <a id="_idIndexMarker787"/>weather indicator is very similar to the faceplate we built in <a href="B21282_03.xhtml#_idTextAnchor048"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>. The exceptions are the use of a Raspberry Pi Pico WH over a Raspberry Pi 5 and an RBG LED, which will allow us to use various colors for <span class="No-Break">our indicator.</span></p>
<p>We can see the parts that make up the faceplate in the <span class="No-Break">following figure:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer202">
<img alt="Figure 10.8 – Parts that make up the faceplate of our weather indicator" height="908" src="image/B21282_10_08.jpg" width="1480"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.8 – Parts that make up the faceplate of our weather indicator</p>
<ul>
<li><em class="italic">A</em>: <span class="No-Break">Faceplate front.</span></li>
<li><em class="italic">B</em>: Faceplate <span class="No-Break">alignment tool.</span></li>
<li><em class="italic">C</em>: Raspberry Pi <span class="No-Break">Pico WH.</span></li>
<li><em class="italic">D</em>: Faceplate front button. Used to reset the Raspberry Pi <span class="No-Break">Pico WH.</span></li>
<li><span class="No-Break"><em class="italic">E</em></span><span class="No-Break">: Hook.</span></li>
<li><em class="italic">F</em>: <span class="No-Break">Faceplate back.</span></li>
<li><em class="italic">G</em>: <span class="No-Break">Faceplate graphic.</span></li>
<li><em class="italic">H</em>: RGB LED with resistors and jumper wires (jump ahead to the upcoming section <em class="italic">Adding jumper wires up our RGB LED</em> for construction of <span class="No-Break">this component).</span></li>
<li><em class="italic">I</em>: SG90 <span class="No-Break">servo motor.</span></li>
<li><em class="italic">J</em>: 8 mm <span class="No-Break">LED holder.</span></li>
</ul>
<p>To build the faceplate<a id="_idIndexMarker788"/> for our new weather indicator, we follow the steps in the <span class="No-Break">following diagram:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer203">
<img alt="Figure 10.9 – Construction of the faceplate for our new weather indicator" height="669" src="image/B21282_10_09.jpg" width="1364"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.9 – Construction of the faceplate for our new weather indicator</p>
<ol>
<li>Using the alignment tool (<em class="italic">B</em> from <span class="No-Break"><em class="italic">Figure 10</em></span><em class="italic">.8</em>) and epoxy glue, we align and glue the front of the faceplate (<em class="italic">A</em> from <span class="No-Break"><em class="italic">Figure 10</em></span><em class="italic">.8</em>) to the back of the faceplate (<em class="italic">F</em> from <span class="No-Break"><em class="italic">Figure 10</em></span><span class="No-Break"><em class="italic">.8</em></span><span class="No-Break">).</span></li>
<li>We glue the hook (<em class="italic">E</em> from <span class="No-Break"><em class="italic">Figure 10</em></span><em class="italic">.8</em>) to the back of the faceplate (<em class="italic">F</em> from <span class="No-Break"><em class="italic">Figure 10</em></span><em class="italic">.8</em>) into the <span class="No-Break">slot provided.</span></li>
<li>We print the faceplate<a id="_idIndexMarker789"/> graphic (<em class="italic">G</em> from <span class="No-Break"><em class="italic">Figure 10</em></span><em class="italic">.8</em>) on printable vinyl using a color printer. Next, we trim the graphic using a digital cutter, such as a Silhouette Cameo, or by hand and attach it to the faceplate’s front, ensuring proper alignment of <span class="No-Break">the holes.</span></li>
<li>We align the SG90 servo motor (<em class="italic">I</em> from <span class="No-Break"><em class="italic">Figure 10</em></span><em class="italic">.8</em>) with its corresponding hole and secure it in place to the back of the faceplate (<em class="italic">F</em> from <span class="No-Break"><em class="italic">Figure 10</em></span><em class="italic">.8</em>) with glue from a hot <span class="No-Break">glue gun.</span></li>
<li>We secure the Raspberry Pi Pico WH (<em class="italic">C</em> from <span class="No-Break"><em class="italic">Figure 10</em></span><em class="italic">.8</em>) to the back of the faceplate (<em class="italic">F</em> from <span class="No-Break"><em class="italic">Figure 10</em></span><em class="italic">.8</em>) with four M3 8 mm screws such that the pins are facing up and the USB port is <span class="No-Break">facing out.</span></li>
<li>We push the RGB LED (<em class="italic">H</em> from <span class="No-Break"><em class="italic">Figure 10</em></span><em class="italic">.8</em>) from the back of the faceplate to the front and secure it in place with the 8 mm LED holder (<em class="italic">J</em> from <span class="No-Break"><em class="italic">Figure 10</em></span><span class="No-Break"><em class="italic">.8</em></span><span class="No-Break">).</span></li>
</ol>
<p>Having constructed the faceplate and stand, we can now fasten the faceplate to the stand using an M5 20 mm bolt and nut. Once this is done, we’re prepared to proceed with connecting the RGB LED and servo motor to the Raspberry Pi <span class="No-Break">Pico WH.</span></p>
<h2 id="_idParaDest-167"><a id="_idTextAnchor167"/>Configuring the RGB LED indicator</h2>
<p>For our application, we <a id="_idIndexMarker790"/>will use an RGB LED to represent the humidity reading we get from our remote LoRa transmitter. An RGB LED allows us to represent any color as it combines three LEDs (red, green, and blue) into <span class="No-Break">one </span><span class="No-Break"><a id="_idIndexMarker791"/></span><span class="No-Break">housing.</span></p>
<p>Before we wire up and install our RGB LED, let’s get a little understanding of what RGB <span class="No-Break">LEDs are.</span></p>
<h3>Understanding RGB LEDs</h3>
<p>RGB LEDs combine red, green, and blue light <a id="_idIndexMarker792"/>to produce various colors. Each color has a pin for control. There are two types: common cathode and common anode (<span class="No-Break"><em class="italic">Figure 10</em></span><em class="italic">.10</em>). Common cathode LEDs have a single ground pin shared by all colors, requiring a positive voltage to the color pins for illumination. Common anode LEDs share a positive pin, needing a ground connection on the color pins to <span class="No-Break">light up.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer204">
<img alt="Figure 10.10 – Two different types of RGB LEDs" height="673" src="image/B21282_10_10.jpg" width="1097"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.10 – Two different types of RGB LEDs</p>
<p>The type determines how we connect and control them, with common cathode LEDs needing a high signal and common<a id="_idIndexMarker793"/> anode LEDs needing a low signal <span class="No-Break">for activation.</span></p>
<p class="callout-heading">Differentiating between common cathode and common anode RGB LEDs</p>
<p class="callout">To determine whether our RGB LED is a common anode or common cathode type, we use a multimeter set to diode test mode. First, we identify the longest leg of the LED, as this is usually the common connection. We then connect the multimeter red probe to the longest leg and the black probe to one of the other legs. If the LED lights up, the longest leg is the anode, indicating a<a id="_idIndexMarker794"/> common anode LED. If it doesn’t light up, we’ll switch the probes. A lit LED with the black probe on the longest leg means it’s a <span class="No-Break">common cathode.</span></p>
<p>For our application, we will be using a common anode RGB LED, and we will program it to change colors based on humidity levels. For low humidity levels, it will be red, indicating dry conditions. It will be green to indicate a humidity level between 30 and 50 percent and blue to represent humidity levels higher than <span class="No-Break">50 percent.</span></p>
<h3>Adding jumper wires to our RGB LED</h3>
<p>To prepare our RGB LED for connection with the Raspberry Pi Pico WH, we’ll solder female jumper wires to each of its<a id="_idIndexMarker795"/> leads. For the RGB LED’s protection, we’ll solder 220 Ohm resistors onto the red, green, and blue leads, positioning them between the LED’s legs and the jumper wires. In our example, we use a yellow wire for power, a red wire for the red LED, a green wire for the green LED, and a blue wire for the blue LED, as shown in the <span class="No-Break">following figure.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer205">
<img alt="Figure 10.11 – Adding jumper wires to the RGB LED" height="596" src="image/B21282_10_11.jpg" width="971"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.11 – Adding jumper wires to the RGB LED</p>
<p>Applying heat shrink, as shown in Step <em class="italic">2</em> of <span class="No-Break"><em class="italic">Figure 10</em></span><em class="italic">.11</em>, reinforces the solder connections by providing both physical strength and <span class="No-Break">electrical insulation.</span></p>
<h3>Connecting the RGB LED to our Raspberry Pi Pico WH</h3>
<p>We will power our RGB LED with the<a id="_idIndexMarker796"/> 3V3 power port from our Raspberry Pi Pico WH. For wiring, use the <span class="No-Break">following diagram:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer206">
<img alt="Figure 10.12 – Wiring diagram for RGB LED and Raspberry Pi Pico WH" height="773" src="image/B21282_10_12.jpg" width="1260"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.12 – Wiring diagram for RGB LED and Raspberry Pi Pico WH</p>
<p>The connections are<a id="_idIndexMarker797"/> <span class="No-Break">as follows:</span></p>
<ul>
<li>3V3 power connects to the <span class="No-Break">common anode.</span></li>
<li>Red connects to <strong class="source-inline">GP15</strong> using a 220 <span class="No-Break">Ohm resistor.</span></li>
<li>Green connects to <strong class="source-inline">GP13</strong> using a 220 <span class="No-Break">Ohm</span><span class="No-Break"> resistor.</span></li>
<li>Blue connects to <strong class="source-inline">GP12</strong> using a 220 <span class="No-Break">Ohm resistor.</span></li>
</ul>
<p>With the RGB LED connected to the Raspberry Pi Pico WH, it is time to test it <span class="No-Break">with code.</span></p>
<h3>Testing our RGB LED circuit</h3>
<p>To test out our RGB LED circuit, we<a id="_idIndexMarker798"/> will run code to turn on each of the three colors. We will write our code in MicroPython and use the <span class="No-Break">Thonny IDE.</span></p>
<p>To test our RGB LED with code, we do <span class="No-Break">the following:</span></p>
<ol>
<li>We connect our Raspberry Pi Pico WH to a USB port and launch Thonny. We may use our Raspberry Pi or another operating system for this. If MicroPython has not been installed, we follow the steps from the <em class="italic">Using a Raspberry Pi Pico W with MQTT</em> section in <a href="B21282_06.xhtml#_idTextAnchor091"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, to install it on our Raspberry Pi <span class="No-Break">Pico WH.</span></li>
<li>We then activate the MicroPython environment on our Pico by selecting it from the bottom right-hand side of <span class="No-Break">the screen.</span></li>
<li>In a new tab in the <a id="_idIndexMarker799"/>editor section (hit <em class="italic">Ctrl</em> + <em class="italic">N</em>), we enter the <span class="No-Break">following code:</span><pre class="source-code">
from machine import Pin
import utime
red = Pin(15, Pin.OUT)
green = Pin(13, Pin.OUT)
blue = Pin(12, Pin.OUT)
def set_color(r, g, b):
    red.value(r)
    green.value(g)
    blue.value(b)
while True:
    # Red
    set_color(0, 1, 1)
    utime.sleep(1)
    # Green
    set_color(1, 0, 1)
    utime.sleep(1)
    # Blue
    set_color(1, 1, 0)
    utime.sleep(1)</pre></li> <li>To save the file, we <a id="_idIndexMarker800"/>click on <strong class="bold">File</strong> | <strong class="bold">Save as...</strong> from the drop-down menu. This will open the <span class="No-Break">following dialog:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer207">
<img alt="Figure 10.13 – Saving a file to our Raspberry Pi Pico" height="246" src="image/B21282_10_13.jpg" width="272"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.13 – Saving a file to our Raspberry Pi Pico</p>
<ol>
<li value="5">In this dialog, we are given the option to choose where to store our file. To save it on our Raspberry Pi Pico WH, we click on the <span class="No-Break">corresponding button.</span></li>
<li>We then give the file the name <strong class="source-inline">main.py</strong> and click <strong class="bold">Ok</strong>. In the MicroPython environment, the name <strong class="source-inline">main.py</strong> is special because the system automatically executes this file upon startup or reset, making it the default script that runs when the device <span class="No-Break">powers up.</span><p class="list-inset">Before we test out our code, let’s break <span class="No-Break">it down:</span></p><ol><li class="upper-roman">We start by importing the <strong class="source-inline">Pin</strong> class from the <strong class="source-inline">machine</strong> module and the <span class="No-Break"><strong class="source-inline">utime</strong></span><span class="No-Break"> module.</span></li><li class="upper-roman">We then initialize GPIO pins GP15, GP13, and GP12 as output for red, green, and blue <span class="No-Break">LEDs, respectively.</span></li><li class="upper-roman">We then <a id="_idIndexMarker801"/>define the <strong class="source-inline">set_color(r, g, b)</strong> function to control the RGB <span class="No-Break">LED color.</span></li><li class="upper-roman">We define an <span class="No-Break">infinite loop:</span><ol><li class="lower-roman">We set the LED to red for <span class="No-Break">1 second.</span></li><li class="lower-roman">We then change the LED to green for <span class="No-Break">1 second.</span></li><li class="lower-roman">Finally, we set the LED to blue for <span class="No-Break">1 second.</span></li></ol></li></ol></li>
<li>To run our code, we click on the green run button, hit <em class="italic">F5</em> on the keyboard or click on the <strong class="bold">Run</strong> menu option at the top, and then select <strong class="bold">Run </strong><span class="No-Break"><strong class="bold">current script</strong></span><span class="No-Break">.</span></li>
<li>We should observe the RGB LED on our weather indicator cycle turning red, then green, <span class="No-Break">then blue.</span></li>
</ol>
<p>With our RGB LED successfully wired and tested, it is time to hook up the servo motor to our Raspberry Pi <span class="No-Break">Pico WH.</span></p>
<h2 id="_idParaDest-168"><a id="_idTextAnchor168"/>Configuring the servo motor</h2>
<p>With our RGB LED installed and tested, it is now time to shift our focus to the servo motor on our weather indicator. Echoing our approach in <a href="B21282_03.xhtml#_idTextAnchor048"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, integrating a servo motor into our design offers an <a id="_idIndexMarker802"/>excellent means to bridge the analog and digital worlds; it enables us to create an analog-style meter where a <a id="_idIndexMarker803"/>needle, moved precisely by the servo, visually represents various <span class="No-Break">data points.</span></p>
<p>We will start by wiring up our servo motor before turning our attention to testing it <span class="No-Break">through code.</span></p>
<h3>Wiring up our servo motor</h3>
<p>For our weather indicator, we will be incorporating an SG90 servo motor. The SG90 servo typically comes with three wires: the power wire (usually red), the ground wire (usually brown or black), and the<a id="_idIndexMarker804"/> signal wire (usually orange <span class="No-Break">or yellow).</span></p>
<p>To wire our servo motor to our Raspberry Pi Pico WH, we will start by removing the wires from the connector housing just as we did in <a href="B21282_03.xhtml#_idTextAnchor048"><span class="No-Break"><em class="italic">Chapter 3</em></span></a><span class="No-Break">.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer208">
<img alt="Figure 10.14 – Removing wires from the connector of the SG90 servo" height="382" src="image/B21282_10_14.jpg" width="839"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.14 – Removing wires from the connector of the SG90 servo</p>
<p>Instead of reinserting the wires into the connector housing, we’ll directly connect them to the pins of the Raspberry Pi <span class="No-Break">Pico WH.</span></p>
<p>We will power our servo motor with the VBUS power port from our Raspberry Pi Pico WH, as VBUS provides the necessary 5V power supply directly from the USB connection, which is ideal for the typical operating voltage of most servo motors such as <span class="No-Break">the SG90.</span></p>
<p>For wiring, use the <span class="No-Break">following diagram:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer209">
<img alt="Figure 10.15 – Wiring the servo motor to the Raspberry Pi Pico WH" height="880" src="image/B21282_10_15.jpg" width="890"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.15 – Wiring the servo motor to the Raspberry Pi Pico WH</p>
<p>The connections are <span class="No-Break">as follows:</span></p>
<ul>
<li>VBUS power <a id="_idIndexMarker805"/>connects to the positive wire of <span class="No-Break">the servo.</span></li>
<li>The signal wire connects <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">GP14.</strong></span></li>
<li>GND connects to a GND port on the Raspberry Pi <span class="No-Break">Pico WH.</span></li>
</ul>
<p class="callout-heading">Important note</p>
<p class="callout">For simplicity, <span class="No-Break"><em class="italic">Figure 10</em></span><em class="italic">.15</em> illustrates only the servo motor connected to the Raspberry Pi Pico WH. However, our actual circuit includes both the RGB LED and the <span class="No-Break">servo motor.</span></p>
<p>With the servo motor connected to the Raspberry Pi Pico WH, it is time to test it <span class="No-Break">with code.</span></p>
<h3>Testing our servo motor</h3>
<p>To verify the functionality of our servo <a id="_idIndexMarker806"/>motor circuit, we’ll execute a test code that cycles the motor through a full 180-degree range, ending at its minimum position. Once the motor reaches this minimum point, we will attach the arrow to our device. We will write our code in MicroPython and use the Thonny IDE. Our code will be organized into two files: <strong class="source-inline">servo.py</strong>, dedicated to managing the servo motor’s control, and <strong class="source-inline">main.py</strong>, which will serve as the primary <span class="No-Break">execution script.</span></p>
<p>To test our servo motor with code, we do <span class="No-Break">the following:</span></p>
<ol>
<li>We connect our Raspberry Pi Pico WH to a USB port on our computer and launch Thonny. We may use our Raspberry Pi or another operating system <span class="No-Break">for this.</span></li>
<li>We then activate the MicroPython environment on our Pico by selecting it from the bottom right-hand side of <span class="No-Break">the screen.</span></li>
<li>We will start with the code to control the servo motor. In a new tab in the editor section (hit <em class="italic">Ctrl</em> + <em class="italic">N</em>), we enter the <span class="No-Break">following code:</span><pre class="source-code">
from machine import Pin, PWM
import utime
class Servo:
    def __init__(self, pin):
        self.servo = PWM(Pin(pin))
        self.servo.freq(50)
    def set_position(self, angle):
        # Reverse the angle
        reversed_angle = 180 - angle
        # Convert the reversed angle to duty cycle
        duty = int((reversed_angle / 18) + 2)
        self.servo.duty_u16(duty * 65536 // 100)</pre><p class="list-inset">In our code, we start by importing the necessary modules: <strong class="source-inline">Pin</strong> and <strong class="source-inline">PWM</strong> from <strong class="source-inline">machine</strong> for hardware <a id="_idIndexMarker807"/>control and <strong class="source-inline">utime</strong> for <span class="No-Break">time-related functions.</span></p><p class="list-inset">We then define the <strong class="source-inline">Servo</strong> class to control a <span class="No-Break">servo motor:</span></p><ol><li class="upper-roman">The <strong class="source-inline">__init__()</strong> method initializes the servo on a specified GPIO pin as a <strong class="bold">Pulse-Width Modulation</strong> (<strong class="bold">PWM</strong>) output <a id="_idIndexMarker808"/>and sets the PWM frequency to 50 Hz, suitable for standard <span class="No-Break">servo motors</span></li><li class="upper-roman">The <strong class="source-inline">set_position()</strong> method sets the servo to a <span class="No-Break">specified angle:</span><ol><li class="lower-roman">We invert the angle to allow for reversed movement of <span class="No-Break">the servo.</span></li><li class="lower-roman">We then convert this reversed angle to a corresponding PWM <span class="No-Break">duty cycle.</span></li><li class="lower-roman">We use the <strong class="source-inline">duty_u16()</strong> method to set the duty cycle, scaling it to a 16-bit value for <span class="No-Break">PWM control.</span></li></ol></li></ol></li> <li>To save the file, we click on <strong class="bold">File</strong> | <strong class="bold">Save as...</strong> from the <span class="No-Break">drop-down menu.</span></li>
<li>We are given the option to choose where to store our file. To save it on our Raspberry Pi Pico WH, we click on the <span class="No-Break">corresponding button.</span></li>
<li>We then give the file the name <strong class="source-inline">servo.py</strong> and <span class="No-Break">click </span><span class="No-Break"><strong class="bold">Ok</strong></span><span class="No-Break">.</span></li>
<li>To create our <strong class="source-inline">main.py</strong> file, we open a new editor tab in the editor section (hit <em class="italic">Ctrl</em> + <em class="italic">N</em>) and enter the <span class="No-Break">following code:</span><pre class="source-code">
from servo import Servo
import utime
servo = Servo(14)
servo.set_position(0)
utime.sleep(1)
servo.set_position(90)
utime.sleep(1)
servo.set_position(180)
utime.sleep(1)
# Return servo to initial position
servo.set_position(0)</pre><p class="list-inset">In our code, we have <span class="No-Break">the following:</span></p><ol><li class="upper-roman">We start by importing the <strong class="source-inline">Servo</strong> class from our newly created <strong class="source-inline">servo</strong> module and <strong class="source-inline">utime</strong> for <span class="No-Break">timing functions.</span></li><li class="upper-roman">We then create an instance of the <strong class="source-inline">Servo</strong> class that we call <strong class="source-inline">servo</strong>, using GPIO <span class="No-Break">pin GP</span><span class="No-Break"><strong class="source-inline">14</strong></span><span class="No-Break">.</span></li><li class="upper-roman">Our code moves the servo to 0 degrees and waits for <span class="No-Break">1 second.</span></li><li class="upper-roman">Our code then adjusts<a id="_idIndexMarker809"/> the servo to 90 degrees and waits for another <span class="No-Break">1 second.</span></li><li class="upper-roman">We set the servo to 180 degrees, followed by a <span class="No-Break">1-second pause.</span></li><li class="upper-roman">Finally, our code returns the servo to the initial position of <span class="No-Break">0 degrees.</span></li></ol></li> <li>To run our code, we click on the green run button, hit <em class="italic">F5</em> on the keyboard or click on the <strong class="bold">Run</strong> menu option at the top, and then select <strong class="bold">Run </strong><span class="No-Break"><strong class="bold">current script</strong></span><span class="No-Break">.</span></li>
<li>We should observe our servo motor go through a range of motions before stopping at the minimum position. One notable improvement with using the Raspberry Pi Pico WH over the Raspberry Pi 5 for connecting servo motors is the absence of servo motor jittering. The servo motor exhibits less jitter when used with the Raspberry Pi Pico WH compared to the Raspberry Pi due to the Pico’s direct, hardware-level <a id="_idIndexMarker810"/>PWM control, which ensures more precise and stable signal delivery to <span class="No-Break">the servo.</span></li>
<li>It is at this point where we place the arrow on the servo motor. We place the arrow such that it is pointing toward the gloves on our graphic. The arrow should fit snuggly; however, a bit of sanding may be required to get it <span class="No-Break">to fit.</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer210">
<img alt="Figure 10.16 – Placing the needle at the zero position" height="760" src="image/B21282_10_16.jpg" width="1145"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.16 – Placing the needle at the zero position</p>
<p>Having successfully wired and tested the RGB LED and servo motor with our Raspberry Pi Pico WH, we’re now ready to develop the code that will control our weather indicator, utilizing data extracted from <span class="No-Break">MQTT messages.</span></p>
<h2 id="_idParaDest-169"><a id="_idTextAnchor169"/>Programming our weather indicator</h2>
<p>The development of our<a id="_idIndexMarker811"/> weather indicator is streamlined, as the components’ direct placement on the faceplate allows for immediate code implementation and testing, eliminating the need for breadboarding. This also reduces the chance of error as we do not need to configure the circuit a <span class="No-Break">second time.</span></p>
<p> The software architecture of our application is shown in the <span class="No-Break">following figure.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer211">
<img alt="Figure 10.17 – Weather display code layout" height="950" src="image/B21282_10_17.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.17 – Weather display code layout</p>
<p>Our code is organized into three files, each containing a distinct class. The <strong class="source-inline">main.py</strong> file houses the <strong class="source-inline">WeatherDisplay</strong> class, which retrieves and parses MQTT messages from our CloudAMQP instance. Based on<a id="_idIndexMarker812"/> the temperature value in these messages, the <strong class="source-inline">WeatherDisplay</strong> class adjusts the servo position (and thus the weather indicator’s needle) using the <strong class="source-inline">Servo</strong> class. It also interprets humidity data to control the RGB LED’s color via the <span class="No-Break"><strong class="source-inline">Indicator</strong></span><span class="No-Break"> class.</span></p>
<p>To create our weather indicator code, we do <span class="No-Break">the following:</span></p>
<ol>
<li>We connect our Raspberry Pi Pico WH from our weather indicator to a USB port on our computer and launch Thonny. We may use our Raspberry Pi or another operating system <span class="No-Break">for this.</span></li>
<li>We then activate the MicroPython environment on our Pico WH by selecting it from the bottom right-hand side of <span class="No-Break">the screen.</span></li>
<li>We will start with the <a id="_idIndexMarker813"/>code to control the RGB LED. This code will introduce the <strong class="source-inline">Indicator</strong> class, designed to manage the RGB LED’s color transition from red to green to blue, reflecting changes in humidity levels. In a new tab in the editor section (hit <em class="italic">Ctrl</em> + <em class="italic">N</em>), we enter the <span class="No-Break">following code:</span><pre class="source-code">
from machine import Pin
import utime
class Indicator:
    def __init__(self):
        self.red = Pin(15, Pin.OUT)
        self.green = Pin(13, Pin.OUT)
        self.blue = Pin(12, Pin.OUT)
    def set_color(self, r, g, b):
        self.red.value(r)
        self.green.value(g)
        self.blue.value(b)
    def set_indicator(self, value):
        # Turn off all LEDs initially
        self.set_color(1, 1, 1)
        if value &lt;= 30:
            # Turn on red LED
            self.set_color(0, 1, 1)
        elif 30 &lt; value &lt;= 50:
            # Turn on green LED
            self.set_color(1, 0, 1)
        else:
            # Turn on blue LED
            self.set_color(1, 1, 0)
    def flash_led(self, times):
        for _ in range(times):
            self.set_color(0, 0, 0)
            utime.sleep(0.5)
            self.set_color(1, 1, 1)
            utime.sleep(0.5)</pre><p class="list-inset">In our code, we have<a id="_idIndexMarker814"/> <span class="No-Break">the following:</span></p><ol><li class="upper-roman">We start by importing the <strong class="source-inline">Pin</strong> class from the <strong class="source-inline">machine</strong> module and <strong class="source-inline">utime</strong> for handling <span class="No-Break">time-based functions.</span></li><li class="upper-roman">We define the <strong class="source-inline">Indicator</strong> class and initialize it with three attributes representing red, green, and blue LEDs, set as output pins on GP15, GP13, and <span class="No-Break">GP12, respectively.</span></li><li class="upper-roman">The <strong class="source-inline">set_color()</strong> method controls the state of each color in the RGB LED based on the input parameters. In this method, for a common anode RGB LED, a binary <strong class="source-inline">0</strong> activates a color (turns it on), while a <strong class="source-inline">1</strong> deactivates it (turns it off). The method is used to selectively turn on either the red, green, or blue component of <span class="No-Break">the LED.</span></li><li class="upper-roman">We then create the <span class="No-Break"><strong class="source-inline">set_indicator()</strong></span><span class="No-Break"> method:</span><ol><li class="lower-roman">Our code turns off all <span class="No-Break">LEDs initially.</span></li><li class="lower-roman">Our code turns on the red LED for values ≤ 30, the green LED for values between 30 and 50, and the blue LED for values &gt; <span class="No-Break">50.</span></li></ol></li><li class="upper-roman">In our <strong class="source-inline">flash_led()</strong> method, we flash all three LEDs (white light) for a specified number of times (<strong class="source-inline">times</strong>), with each flash lasting 0.5 seconds with a 0.5-second interval where LEDs <span class="No-Break">are off.</span></li></ol></li> <li>To save the file, we click on <strong class="bold">File</strong> | <strong class="bold">Save as...</strong> from the <span class="No-Break">drop-down menu.</span></li>
<li>We are given the<a id="_idIndexMarker815"/> option to choose where to store our file. To save it on our Raspberry Pi Pico WH, we click on the <span class="No-Break">corresponding button.</span></li>
<li>We then give the file the name <strong class="source-inline">indicator.py</strong> and <span class="No-Break">click </span><span class="No-Break"><strong class="bold">Ok</strong></span><span class="No-Break">.</span></li>
<li>The second class in our code is a new version of the servo class. To create this class, we open a new tab in the editor section (hit <em class="italic">Ctrl</em> + <em class="italic">N</em>), and enter the <span class="No-Break">following code:</span><pre class="source-code">
from machine import Pin, PWM
import utime
class Servo:
    def __init__(self, pin):
        self.servo = PWM(Pin(pin))
        self.servo.freq(50)
    def set_position(self, value):
        int_value = int(value)
        angle = 180 - (int_value / 40) * 180
        angle = max(0, min(angle, 180))
        # Convert the angle to duty cycle
        duty = int((angle / 18) + 2)
        self.servo.duty_u16(duty * 65536 // 100)</pre><p class="list-inset">In our code, we start by importing the <strong class="source-inline">Pin</strong> and <strong class="source-inline">PWM</strong> modules from <strong class="source-inline">machine</strong>, and <strong class="source-inline">utime</strong> for<a id="_idIndexMarker816"/> <span class="No-Break">time-related functions.</span></p><p class="list-inset">We then define the <strong class="source-inline">Servo</strong> class to control <span class="No-Break">servo motors:</span></p><ol><li class="upper-roman">In the constructor (<strong class="source-inline">__init__()</strong>), we initialize a PWM object on the <span class="No-Break">specified pin.</span></li><li class="upper-roman">We set the PWM frequency to 50 Hz, a standard frequency suitable for <span class="No-Break">servo motors.</span></li><li class="upper-roman">We then create a <strong class="source-inline">set_position()</strong> method that does <span class="No-Break">the following:</span><ol><li class="lower-roman">Converts the input value into <span class="No-Break">an integer.</span></li><li class="lower-roman">Maps the input range (0-40) to a servo angle range (0-180 degrees) in reverse to align with the installation of our <span class="No-Break">servo motor.</span></li><li class="lower-roman">Ensures the calculated angle is within the valid range (<span class="No-Break">0-180 degrees).</span></li><li class="lower-roman">Converts the angle to a duty cycle suitable for <span class="No-Break">the servo.</span></li><li class="lower-roman">Sets the PWM duty cycle to position <span class="No-Break">the servo.</span></li></ol></li></ol></li> <li>To save the file, we click on <strong class="bold">File</strong> | <strong class="bold">Save as...</strong> from the <span class="No-Break">drop-down menu.</span></li>
<li>We are given the option to choose where to store our file. To save it on our Raspberry Pi Pico WH, we click on the <span class="No-Break">corresponding button.</span></li>
<li>We then give the file the name <strong class="source-inline">servo.py</strong> and <span class="No-Break">click </span><span class="No-Break"><strong class="bold">Ok</strong></span><span class="No-Break">.</span></li>
<li>The <strong class="source-inline">WeatherDisplay</strong> class, located in the main execution file, is responsible for subscribing to the <strong class="source-inline">WeatherInfo</strong> MQTT topic and handling the messages received. For its operation, the <strong class="source-inline">micropython-umqtt.simple</strong> library is necessary. To install this library, refer to the <em class="italic">Improving on our IoT button with the Raspberry Pi Pico W</em> section in <a href="B21282_07.xhtml#_idTextAnchor107"><span class="No-Break"><em class="italic">Chapter 7</em></span></a><span class="No-Break">.</span></li>
<li>To create the <strong class="source-inline">WeatherDisplay</strong> class, we begin by entering the import statements<a id="_idIndexMarker817"/> in a new tab in the editor section (hit <em class="italic">Ctrl</em> + <span class="No-Break"><em class="italic">N</em></span><span class="No-Break">):</span><pre class="source-code">
import network
import utime
from umqtt.simple import MQTTClient
from servo import Servo
from indicator import Indicator</pre><p class="list-inset">In our code, we do <span class="No-Break">the following:</span></p><ol><li class="upper-roman">We import the <strong class="source-inline">network</strong> module for Wi-Fi <span class="No-Break">connectivity functions.</span></li><li class="upper-roman">We import the <strong class="source-inline">utime</strong> module for <span class="No-Break">time-related functions.</span></li><li class="upper-roman">Our code imports <strong class="source-inline">MQTTClient</strong> from <strong class="source-inline">umqtt.simple</strong> to handle <span class="No-Break">MQTT communications.</span></li><li class="upper-roman">We import our <strong class="source-inline">Servo</strong> class from our newly created local module for servo <span class="No-Break">motor control.</span></li><li class="upper-roman">We then import our <strong class="source-inline">Indicator</strong> class from our newly created local module for RGB LED <span class="No-Break">indicator control.</span></li></ol></li> <li>We then define the class name and initialization method where we define our Wi-Fi and <span class="No-Break">MQTT parameters:</span><pre class="source-code">
class WeatherDisplay:
    def __init__(self):
        # WiFi Information
        self.ssid = "MySSID"
        self.wifi_password = "ssid-password"
        # MQTT Information
        self.mqtt_server = "driver.cloudmqtt.com"
        self.mqtt_port = 18756
        self.username = "mqtt-username"
        self.mqtt_password = "mqtt-password"
        self.device_id = "WeatherDisplay"
        self.mqtt_topic = "WeatherInfo"
        self.indicator = Indicator()
        self.servo = Servo(14)</pre></li> <li>The <strong class="source-inline">connect_wifi()</strong> method establishes a connection between the Raspberry Pi Pico WH and<a id="_idIndexMarker818"/> the local Wi-Fi network. It continuously attempts to connect until successful, and upon establishing a connection, it indicates success by flashing the RGB LED in white <span class="No-Break">four times:</span><pre class="source-code">
    def connect_wifi(self):
        wlan = network.WLAN(network.STA_IF)
        wlan.active(True)
        if not wlan.isconnected():
            print('Connecting to WiFi...')
            wlan.connect(self.ssid, self.wifi_password)
            while not wlan.isconnected():
                pass
        print('WiFi connected, IP:', wlan.ifconfig()[0])
        self.indicator.flash_led(4)</pre></li> <li>We use the <strong class="source-inline">connect_mqtt()</strong> method to connect to our CloudAMQP instance and subscribe<a id="_idIndexMarker819"/> to the <strong class="source-inline">WeatherInfo</strong> topic (as set by the <strong class="source-inline">mqtt_topic</strong>) variable and set our callback function <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">on_message_received()</strong></span><span class="No-Break">:</span><pre class="source-code">
    def connect_mqtt(self):
        self.client = MQTTClient(self.device_id,
                                 self.mqtt_server,
                                 self.mqtt_port,
                                 self.username,
                                 self.mqtt_password)
        self.client.set_callback(
                     self.on_message_received)
        self.client.connect()
        self.client.subscribe(self.mqtt_topic)</pre></li> <li>The <strong class="source-inline">on_message_received()</strong> function processes received MQTT messages by parsing temperature and humidity data and then updating the servo position and RGB LED <span class="No-Break">indicator accordingly:</span><pre class="source-code">
    def on_message_received(self, topic, msg):
        print("Received:", topic, msg.decode())
        temperature, humidity =
            self.parse_message(msg)
        if temperature is not None:
            self.servo.set_position(temperature)
        if humidity is not None:
            self.indicator.set_indicator(humidity)</pre></li> <li>The <strong class="source-inline">parse_message()</strong> function extracts and returns temperature and humidity values from a <a id="_idIndexMarker820"/>decoded MQTT message, handling any exceptions and returning <strong class="source-inline">None</strong> values if <span class="No-Break">parsing fails:</span><pre class="source-code">
    def parse_message(self, msg):
        try:
            parts = msg.decode().split(',')
            temperature_str = parts[0].split('Temp:')[1].split('C')[0].strip()
            humidity_str = parts[1].split('Humidity:')[1].split('%')[0].strip()
            temperature = float(temperature_str)
            humidity = float(humidity_str)
            return temperature, humidity
        except Exception as e:
            print("Error parsing message:", str(e))
            return None, None</pre></li> <li>The <strong class="source-inline">run</strong> method, the final method defined in the <strong class="source-inline">WeatherDisplay</strong> class, initiates the Wi-Fi connection, connects <a id="_idIndexMarker821"/>to the MQTT client, and continuously checks for MQTT messages, handling any errors encountered during <span class="No-Break">message reception:</span><pre class="source-code">
    def run(self):
        self.connect_wifi()
        self.connect_mqtt()
        while True:
            try:
                self.client.check_msg()
            except Exception as e:
                print("Error checking MQTT message:",
                       str(e))
                utime.sleep(5)</pre></li> <li>After writing the <strong class="source-inline">WeatherDisplay</strong> class code, we instantiate it and call its <strong class="source-inline">run()</strong> method, initiating the weather display functionality, which includes establishing Wi-Fi and MQTT connections and processing <span class="No-Break">incoming messages:</span><pre class="source-code">
# Create and run the weather display
weather_display = WeatherDisplay()
weather_display.run()</pre></li> <li>To save our file, we click on <strong class="bold">File</strong> | <strong class="bold">Save as...</strong> from the <span class="No-Break">drop-down menu.</span></li>
<li>We are given the option to choose where to store our file. To save it on our Raspberry Pi Pico WH, we click on the <span class="No-Break">corresponding button.</span></li>
<li>We then give the file the name <strong class="source-inline">main.py</strong> and <span class="No-Break">click </span><span class="No-Break"><strong class="bold">Ok</strong></span><span class="No-Break">.</span></li>
<li>To run our code, we click on the green run button, hit <em class="italic">F5</em> on the keyboard, or click on the <strong class="bold">Run</strong> menu option at the top, and then select <strong class="bold">Run </strong><span class="No-Break"><strong class="bold">current script</strong></span><span class="No-Break">.</span></li>
<li>We should observe the RGB LED flashing four times after connection to our <span class="No-Break">Wi-Fi network.</span></li>
<li>We should observe<a id="_idIndexMarker822"/> that the arrow moves to a position indicating the temperature coming from the temperature sensor on our LoRa <span class="No-Break">sensory transmitter.</span></li>
<li>We should observe that the color of the RGB LED is either red, green, or blue, indicating the humidity level measured by our LoRa <span class="No-Break">sensory transmitter.</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer212">
<img alt="Figure 10.18 – The three devices that make up our IoT weather service, starting from the left, are the LoRa sensory transmitter (Chapter 9), the LoRa receiver/internet gateway (Chapter 9), and the analog-metered weather indicator" height="933" src="image/B21282_10_18.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.18 – The three devices that make up our IoT weather service, starting from the left, are the LoRa sensory transmitter (<a href="B21282_09.xhtml#_idTextAnchor140"><em class="italic" xml:lang="en-GB">Chapter 9</em></a>), the LoRa receiver/internet gateway (<a href="B21282_09.xhtml#_idTextAnchor140"><em class="italic" xml:lang="en-GB">Chapter 9</em></a>), and the analog-metered weather indicator</p>
<p>With the completion of our<a id="_idIndexMarker823"/> project, we’ve successfully built an IoT weather service and display console, combining real-time data collection with an interactive display. This system utilizes MQTT for data transmission, servo motors for representing data physically, and an RGB LED for <span class="No-Break">visual alerts.</span></p>
<h1 id="_idParaDest-170"><a id="_idTextAnchor170"/>Exploring other IoT communication protocols</h1>
<p>LoRaWAN, operating on the same sub-gigahertz radio frequencies as LoRa, is an advanced protocol for wireless communication that enables long-range transmissions with low power consumption. This<a id="_idIndexMarker824"/> shared frequency band is a key feature that allows both LoRaWAN and LoRa to transmit data over several kilometers, which is especially beneficial in areas where traditional connectivity <span class="No-Break">is scarce.</span></p>
<p>In the context of IoT applications such as weather monitoring, LoRaWAN offers significant advantages. For example, a network of sensors collecting environmental data such as temperature and humidity could transmit this information over long distances to a central gateway connected to the internet, leveraging LoRa’s long-range capabilities. This gateway then relays the data to a cloud server for processing <span class="No-Break">and analysis.</span></p>
<p>However, for our weather indicator project, using the full LoRaWAN setup would be considered overkill. Our project utilizes a simpler setup involving two Raspberry Pi Pico microcontrollers – one equipped with LoRa for data transmission (Raspberry Pi Pico) and the other with Wi-Fi capability (Raspberry Pi Pico W). This setup effectively demonstrates the capabilities of LoRa for short-range IoT communication, capitalizing on the same long-range, low-power characteristics of the LoRa frequencies, but without the complexity and infrastructure requirements of a complete <span class="No-Break">LoRaWAN network.</span></p>
<p>Cellular services can also be used for IoT communication, offering extensive coverage and higher data transfer speeds. Cellular IoT devices, such as those using 4G LTE or 5G networks, can transmit larger amounts of data over long distances. This makes cellular services suitable for more data-intensive applications or those requiring real-time, <span class="No-Break">high-speed communication.</span></p>
<p>While cellular IoT offers broader coverage and higher data throughput, it often comes with higher power consumption and complexity compared to LoRa-based solutions. Thus, for small-scale or low-power projects such as our weather indicator, the simplicity and efficiency of using LoRa modules with Raspberry Pi Pico microcontrollers provide a more suitable and <span class="No-Break">cost-effective solution.</span></p>
<p><strong class="bold">Sigfox</strong> is a global network operator providing<a id="_idIndexMarker825"/> dedicated cellular connectivity for IoT and <strong class="bold">Machine-to-Machine</strong> (<strong class="bold">M2M</strong>) communications. It <a id="_idIndexMarker826"/>uses a unique technology for wireless transmission that allows for long-range, low-power communication. Sigfox operates in the sub-gigahertz frequency band and is designed for small data payload transmissions, typically up to 12 bytes per message. This limited data capacity makes it ideal for devices that need to send small, infrequent bursts of data, such as sensors in smart meters, agricultural monitors, and asset tracking systems. Sigfox’s network architecture is distinguished by its simplicity, efficiency, and cost-effectiveness, making it a popular choice for applications where low-cost and low-power operations <span class="No-Break">are critical.</span></p>
<p>LoRaWAN, cellular <a id="_idIndexMarker827"/>networks, and Sigfox are among the leading communication protocols used in IoT applications. Each has its unique features and use cases. Here’s a comparative table outlining their advantages <span class="No-Break">and disadvantages:</span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-2">
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<thead>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold">Protocol</strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold">Advantages</strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold">Disadvantages</strong></span></p>
</td>
</tr>
</thead>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break">LoRaWAN</span></p>
</td>
<td class="No-Table-Style">
<ul>
<li>Long range (up to <span class="No-Break">15 km)</span></li>
<li>Low <span class="No-Break">power consumption</span></li>
<li>Good penetration in <span class="No-Break">urban environments</span></li>
<li>Open protocol with a <span class="No-Break">growing ecosystem</span></li>
</ul>
</td>
<td class="No-Table-Style">
<ul>
<li>Lower <span class="No-Break">data rates</span></li>
<li>Limited bandwidth and duty <span class="No-Break">cycle restrictions</span></li>
<li>Requires gateway for <span class="No-Break">internet connectivity</span></li>
</ul>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break">Cellular (4G/5G)</span></p>
</td>
<td class="No-Table-Style">
<ul>
<li>High <span class="No-Break">data throughput</span></li>
<li>Wide coverage <span class="No-Break">and reliability</span></li>
<li>Supports real-time <span class="No-Break">communication</span></li>
<li><span class="No-Break">Well-established infrastructure</span></li>
</ul>
</td>
<td class="No-Table-Style">
<ul>
<li>Higher <span class="No-Break">power consumption</span></li>
<li><span class="No-Break">Subscription costs</span></li>
<li>Potentially overpowered for <span class="No-Break">simple tasks</span></li>
</ul>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break">Sigfox</span></p>
</td>
<td class="No-Table-Style">
<ul>
<li>Ultra-low <span class="No-Break">power consumption</span></li>
<li><span class="No-Break">Long-range capabilities</span></li>
<li>Simple to deploy <span class="No-Break">and maintain</span></li>
<li>Ideal for small, infrequent <span class="No-Break">data transmissions</span></li>
</ul>
</td>
<td class="No-Table-Style">
<ul>
<li>Very limited data payload (<span class="No-Break">12 bytes/message)</span></li>
<li>Limited to 140 messages <span class="No-Break">per day</span></li>
<li>Proprietary technology with <span class="No-Break">limited flexibility</span></li>
</ul>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>LoRa with Wi-Fi <span class="No-Break">microcontroller</span></p>
</td>
<td class="No-Table-Style">
<ul>
<li>Long range (up to 15 km <span class="No-Break">for LoRa)</span></li>
<li>Low power consumption for <span class="No-Break">LoRa transmissions</span></li>
<li>Cost-effective solution for <span class="No-Break">small-scale projects</span></li>
<li>Flexible <a id="_idIndexMarker828"/>and easy integration with existing <span class="No-Break">Wi-Fi networks</span></li>
</ul>
</td>
<td class="No-Table-Style">
<ul>
<li>Limited to the range of the Wi-Fi network for <span class="No-Break">internet connectivity</span></li>
<li>Tied to a single microcontroller and may not be used for <span class="No-Break">mobile applications</span></li>
<li>Requires additional hardware (Wi-Fi microcontroller) for <span class="No-Break">internet connectivity</span></li>
<li>May require a more complex setup and coding compared to using a <span class="No-Break">single protocol</span></li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 10.1 – Comparing IoT communication protocols</p>
<p>Each protocol serves different <span class="No-Break">IoT scenarios:</span></p>
<ul>
<li><strong class="bold">LoRaWAN</strong>: Ideal for applications requiring<a id="_idIndexMarker829"/> long-range communication and low power usage, such as agricultural sensors or smart <span class="No-Break">city applications.</span></li>
<li><strong class="bold">Cellular networks</strong>: Suitable for <a id="_idIndexMarker830"/>high-data, real-time applications such as video surveillance, automotive<a id="_idIndexMarker831"/> applications, or any scenario requiring broad <span class="No-Break">geographic coverage.</span></li>
<li><strong class="bold">Sigfox</strong>: Excels in scenarios<a id="_idIndexMarker832"/> where devices only need to send small amounts of data over long distances, such as utility metering or <span class="No-Break">asset tracking.</span></li>
<li><strong class="bold">LoRa with Wi-Fi microcontroller</strong>: Best for small-scale, localized IoT projects requiring the long-range capability of LoRa and <a id="_idIndexMarker833"/>the internet connectivity provided by Wi-Fi, such as home automation, local environmental monitoring, or DIY <span class="No-Break">IoT projects.</span></li>
</ul>
<p>For small-scale or low-power projects such as our weather indicator, using LoRa modules with Raspberry Pi Pico microcontrollers presents a more suitable and cost-effective solution than the options mentioned. LoRa with microcontrollers balances range, data handling, and power efficiency without the need for more <span class="No-Break">complex infrastructure.</span></p>
<h1 id="_idParaDest-171"><a id="_idTextAnchor171"/>Summary</h1>
<p>In this chapter, we integrated LoRa-based data transmission with internet connectivity using MQTT. We modified our CircuitPython-based LoRa receiver’s code, allowing it to send sensory data to the CloudAMQP server, transforming it into an internet gateway. The weather indicator was upgraded, replacing the Raspberry Pi 5 and single-color LED with a Raspberry Pi Pico WH and an RGB LED, which displayed temperature and humidity data via <span class="No-Break">MQTT messages.</span></p>
<p>Additionally, we constructed a new split stand for the indicator, designed for easy assembly and improved stability. We concluded the chapter by examining IoT communication protocols such as LoRaWAN, cellular networks, and Sigfox, assessing their suitability for different <span class="No-Break">IoT applications.</span></p>
<p>We engaged in a hands-on exploration of integrating LoRa with internet connectivity via MQTT, a practical demonstration of how disparate technologies can work together in IoT applications. By upgrading the weather indicator, we not only learned about iterative design and troubleshooting but also gained insights into the decision-making process involved in IoT projects, such as choosing the Raspberry Pi Pico WH over the Raspberry Pi 5 for controlling <span class="No-Break">servo motors.</span></p>
<p>This chapter marks the end of the book’s third part, focused on IoT communications with an emphasis on LoRa. In the next chapter, we transition to robotics, where we’ll start on our journey to build an internet-connected <span class="No-Break">robot car.</span></p>
</div>
</div>

<div id="sbo-rt-content"><div class="Content" id="_idContainer214">
<h1 id="_idParaDest-172" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor172"/>Part 4: Building an IoT Robot Car</h1>
<p>In this part, we use all the knowledge we’ve gained from the previous chapters to build an IoT robot car that is controlled through the internet. This project will be the most advanced and demonstrate the ultimate power of IoT technology, controlling anything <span class="No-Break">from anywhere.</span></p>
<p>This part has the <span class="No-Break">following chapters:</span></p>
<ul>
<li><a href="B21282_11.xhtml#_idTextAnchor173"><em class="italic">Chapter 11</em></a>, <em class="italic">Introducing ROS</em></li>
<li><a href="B21282_12.xhtml#_idTextAnchor195"><em class="italic">Chapter 12</em></a>, <em class="italic">Creating an IoT Joystick</em></li>
<li><a href="B21282_13.xhtml#_idTextAnchor209"><em class="italic">Chapter 13</em></a>, <em class="italic">Introducing Advanced Robotic Eyes for Security (A.R.E.S.)</em></li>
<li><a href="B21282_14.xhtml#_idTextAnchor228"><em class="italic">Chapter 14</em></a>, <em class="italic">Adding Computer Vision to A.R.E.S.</em></li>
</ul>
</div>
<div>
<div id="_idContainer215">
</div>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer216">
</div>
</div>
</div></body></html>