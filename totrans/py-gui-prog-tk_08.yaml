- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Navigating Records with Treeview and Notebook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You've received another request for features in the application. Now that your
    users can open arbitrary files for appending, they'd like to be able to see what's
    in those files and correct old records using the data entry form they've grown
    accustomed to, rather than having to switch over to a spreadsheet. In a nutshell,
    it's finally time to implement read and update capabilities in our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: In *Implementing read and update in the model*, we'll modify our CSV model for
    read and update capabilities.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In *The Ttk Treeview*, we'll explore the Ttk `Treeview` widget.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In *Implementing a record list with Treeview*, we'll use our knowledge of the
    `Treeview` widget to create an interactive display of records in the CSV file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In *Adding the record list to the application*, we'll incorporate our new record
    list view into our application using the Ttk `Notebook` widget.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing read and update in the model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our entire design up to this point has been centered around a form that only
    appends data to a file; adding read and update capabilities is a fundamental change
    that will touch nearly every portion of the application.
  prefs: []
  type: TYPE_NORMAL
- en: It may seem like a daunting task, but by taking it one component at a time,
    we'll see that the changes are not so overwhelming.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we should do is update our documentation. Open the `abq_data_entry_spec.rst`
    file in the `docs` folder, and let''s start with the Requirements section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'And, of course, we should also update the part that is not required, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now, it's a simple matter of making the code match with the documentation. Let's
    get started!
  prefs: []
  type: TYPE_NORMAL
- en: Adding read and update to the CSVModel class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Take a moment to consider what''s missing from the `CSVModel` class that we''ll
    need to add for read and update functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: We'll need a method that can retrieve all records in a file so we can display
    them. We'll call it `get_all_records()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll need a method to fetch individual records from the file by row number.
    We can call this one `get_record()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll need to save records in a way that can not only append new records but
    update existing records as well. We can update our `save_record()` method to accommodate
    this.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open up `models.py` in your editor, and let's work through making these changes.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing get_all_records()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s start a new method in `CSVModel` called `get_all_records()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we've done is check if the model's file exists yet (recall that
    `self.file` is a `Path` object, so we can just call `exists()` to see if it exists).
    When our users start the program each morning, the `CSVModel` generates a default
    filename pointing to a file that likely doesn't exist yet, so `get_all_records()`
    will need to handle this situation gracefully. It makes sense to return an empty
    list in this case, since there's no data if the file doesn't exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the file does exist, we will open it in read-only mode and get all the records.
    We could do that like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'While not terribly efficient, pulling the entire file into memory and converting
    it into a list is acceptable in our case, since we know that our largest files
    should be limited to a mere 241 rows: 20 plots times 3 labs times 4 check sessions,
    plus a header row. That amount of data is easy work for Python, even on an old
    workstation. This method is just a little too trusting, however. We should at
    least do some sanity checks to make sure that the user has actually opened a CSV
    file containing the proper fields and not some other arbitrary file, which would
    likely crash the program.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s revise the method so that it will check the file for the correct field
    structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In this version, we first find any missing fields by comparing the `CSVModel.fields`
    dictionary keys to the `fieldnames` list in the CSV file. To find the missing
    fields, we''re using a simple trick involving the Python `set` type: if we convert
    both lists to `set` objects, we can subtract one from the other, leaving us with
    a `set` object containing the fields from the first list (our `fields` keys) that
    were missing from the second list (the CSV field names).'
  prefs: []
  type: TYPE_NORMAL
- en: If `missing_fields` has any items, those are missing fields from the CSV file.
    We'll raise an exception in this case, detailing which fields are absent. Otherwise,
    we convert the CSV data to a list, as we did in our simpler version of the method.
  prefs: []
  type: TYPE_NORMAL
- en: Python `set` objects are very useful for comparing the content of the list,
    tuple, and other sequence objects. They provide an easy way to get information
    such as the difference (items in *x* that are not in *y*) or intersection (items
    in both *x* and *y*) between two sets and allow you to compare sequences without
    respect to order.
  prefs: []
  type: TYPE_NORMAL
- en: Before we can return the `records` list from the method, we need to correct
    one issue; all data in a CSV file is stored as text, and read by Python as a string.
    Most of this is not a problem, since Tkinter will take care of converting strings
    to `float` or `int` as necessary. Boolean values, however, are stored in the CSV
    file as the strings `True` and `False`, and coercing these values directly back
    to `bool` doesn't work. The string `False` is a non-empty string, and all non-empty
    strings evaluate to `True` in Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix this, let''s first define a list of strings that should be interpreted
    as `True`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Any values not in this list will be considered `False`. We'll do a case-insensitive
    comparison, so there are only lowercase values in our list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we create a list of model fields that are Boolean using a list comprehension,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Technically, we know that Equipment Fault is our only Boolean field, so in reality,
    we could just hard-code the method to correct that field. However, it's wiser
    to design the model so that any changes to the schema will be automatically handled
    appropriately by the logic portions. If fields are added or altered, we should
    ideally only need to alter the field specification and the rest of the model code
    should behave correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s iterate through the records and correct all the Boolean fields
    in each row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: For every record, we iterate through our list of the Boolean fields and check
    the field's value against our list of truthy strings, setting the value of the
    item accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the Boolean values fixed, we can finish our function by returning the
    list of records, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note that the rows returned by this method are dictionaries in the same format
    expected by the `save_record()` method when saving data. It's good practice for
    the model to be consistent about the way it represents data. In a more robust
    model, you might even make a class to represent a row of data, though for simpler
    applications a dictionary usually serves as well.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing get_record()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `get_record()` method needs to take a row number and return a single dictionary
    containing the data for that row. Given that we are dealing in very small amounts
    of data, we can simply leverage the `get_all_records()` method we just wrote and
    take care of this in just a few lines, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Keep in mind, however, that it's possible to pass a `rownum` value that doesn't
    exist in our records list; in this case, Python would raise an `IndexError` exception.
  prefs: []
  type: TYPE_NORMAL
- en: Since there's no meaningful way for us to handle that situation inside the model,
    we'll need to remember to have our controller catch this exception and deal with
    it appropriately when using this method.
  prefs: []
  type: TYPE_NORMAL
- en: Adding update capability to save_record()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To convert our `save_record()` method so that we can update records, the first
    thing we'll need to do is provide the ability to pass in a row number to update.
    The default will be `None`, which will indicate that the data is a new row that
    should be appended to the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The updated method signature looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Our existing record-saving logic doesn't need to change, but it should only
    be run if `rownum` is `None`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the first thing to do in the method is check `rownum`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If `rownum` is `None`, we''re just running our existing code: writing a header
    if the file doesn''t exist, and then appending the row to the end of the file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case that the `rownum` is *not* `None`, we''ll need to update the given
    row and save the file. There are several approaches to this task, but for relatively
    small files, the simplest way to update a single row is:'
  prefs: []
  type: TYPE_NORMAL
- en: Load the entire file into a list
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the row in the list
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the entire list back to a clean file
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That may seem inefficient, but again, we're dealing with very small amounts
    of data. A more surgical approach would only be required with much larger sets
    of data (more than should be stored in a CSV file, for sure!).
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s add the following code that does this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Once again, we leverage our `get_all_records()` method to fetch the CSV file's
    content into a list. We then replace the dictionary in the requested row with
    the data dictionary provided. Finally, we open the file in write mode (`w`), which
    will clear its content and replace it with whatever content we write to the file.
    We then write the header and all records back to the empty file.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the approach we're taking makes it unsafe for two users to work in
    the same CSV file simultaneously. Creating software that allows multiple users
    to edit a single file at the same time is notoriously difficult, and many programs
    simply opt to prevent it in the first place using lock files or other protection
    mechanisms. In *Chapter 12*, *Improving Data Storage with SQL*, we'll update our
    program so that multiple users can use it simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: This method is finished, and that's all we need to change in our model to enable
    the updating and viewing of data. Now, it's time to add the necessary features
    to our GUI.
  prefs: []
  type: TYPE_NORMAL
- en: The Ttk Treeview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For users to be able to view the contents of a CSV file and select records to
    edit, we'll need to implement a new view in the application capable of displaying
    tabular data. This record list view will allow our users to browse the content
    of the file and open records for viewing or editing.
  prefs: []
  type: TYPE_NORMAL
- en: Our users are accustomed to seeing this data in a spreadsheet, laid out in a
    table-like format, so it makes sense to design our view in a similar fashion.
  prefs: []
  type: TYPE_NORMAL
- en: For building table-like views with selectable rows, Tkinter gives us the **Ttk
    Treeview** widget. To build our record list view, we'll need to learn about `Treeview`.
  prefs: []
  type: TYPE_NORMAL
- en: Anatomy of a Treeview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To help us explore the treeview, let''s go through a few basic terms and concepts
    related to the widget. A treeview is designed to display **hierarchical data**;
    that is, data that is organized into **nodes**, where each node can have exactly
    one parent node and zero or more child nodes. The following diagram shows an example
    of hierarchical data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17578_08_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.1: A small hierarchical data structure. Nodes 1, 2, and 3 are children
    of the root, nodes 4 and 5 are children of node 1; "value" is an attribute of
    each node.'
  prefs: []
  type: TYPE_NORMAL
- en: The `Treeview` widget displays hierarchical data in a table format; each row
    of the table represents a single node, which it calls an **item**. Each column
    of the table represents some attribute of the node. When a node has child nodes,
    those rows are displayed under their parent and can be hidden or shown by clicking
    the parent row.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the hierarchy pictured above in a `Treeview` would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17578_08_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.2: The berry hierarchy displayed in a Treeview widget'
  prefs: []
  type: TYPE_NORMAL
- en: Each item in a treeview is identified by a unique **item identifier** (**IID**),
    and each column by a **column identifier** (**CID**). These values are strings,
    and you can either assign them manually or let the widget choose them automatically.
  prefs: []
  type: TYPE_NORMAL
- en: At the top of the treeview's columns are **header widgets**. These are buttons
    that can display the name of each column, and optionally run a callback when clicked.
  prefs: []
  type: TYPE_NORMAL
- en: The first column of the `Treeview` widget is known as the **icon column** and
    has a CID of `#0`. It cannot be removed, nor can its CID be altered. Typically
    it contains identifying information about the item.
  prefs: []
  type: TYPE_NORMAL
- en: Building a file browser
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perhaps the best example of the kind of data we can represent in a treeview
    is a filesystem tree:'
  prefs: []
  type: TYPE_NORMAL
- en: Each row can represent a file or directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each directory can contain additional files or directories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each row can have additional data properties, such as permissions, size, or
    ownership information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To better understand how a `Treeview` widget works, let's create a simple file
    browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a new file called `treeview_demo.py` and start with this template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll start by getting a list of all the file paths under the current working
    directory. `Path` has a method called `glob()` that will give us such a list.
    Add this line just below the `root = tk.Tk()` line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`glob()` searches a file path for files or directories matching a filesystem-matching
    expression. The expression can contain wildcard characters like `*` (which means
    "zero or more characters") and `?` (which means "a single character"). The name
    "glob" goes back to a very early Unix command, though this same wildcard syntax
    is now used across most modern operating systems'' command-line interfaces.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Path(''.'')` creates a path object referencing the current working directory,
    and `**/*` is a special wildcard syntax that recursively grabs all objects under
    the path. Given that wildcard expression, the `glob()` method returns a list of
    the `Path` objects that include every directory and file under our current directory.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating and configuring a Treeview
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we have some data to display, let''s create a `Treeview` widget to
    display it, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Like any Tkinter widget, the first argument to `Treeview` is its parent widget.
    Next, we''ve passed in a list of strings to the `column` argument. These are the
    CID values for our columns. Note that these columns are *in addition to* the default
    icon column, so this `Treeview` widget will have 3 total columns: `#0`, `size`,
    and `modified`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `selectmode` argument determines how users can select items in the tree.
    The different options for `selectmode` are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Value | Behavior |'
  prefs: []
  type: TYPE_TB
- en: '| `"none"` | No selections can be made |'
  prefs: []
  type: TYPE_TB
- en: '| `"browse"` | User can select one item only |'
  prefs: []
  type: TYPE_TB
- en: '| `"extended"` | User can select multiple items |'
  prefs: []
  type: TYPE_TB
- en: In this case, we're preventing selection, so we set it to `none` (note that
    this is the string `none`, not a `None` object).
  prefs: []
  type: TYPE_NORMAL
- en: 'While Tkinter will add a column for each CID value, it will not automatically
    give those columns a header label. We need to do that ourselves using the `Treeview.heading()`
    method, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The treeview's `heading()` method allows us to configure the column heading
    widget; it takes the CID of the column we wish to operate on, followed by any
    number of keyword arguments to configure the header widget.
  prefs: []
  type: TYPE_NORMAL
- en: 'Those attributes can include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`text`: The text displayed for the heading. By default, it''s blank.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`anchor`: The alignment of the text; it can be any of eight cardinal directions
    or `center`, specified as strings or Tkinter constants.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`command`: A callback to run when the heading is clicked. This might be used
    to order the rows by that column, or select all the values in the column, for
    example.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`image`: An image to display in the heading.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to configuring the headers, we can configure some attributes that
    affect the entire column using the `Treeview.column()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we've set `stretch=True` in the first column, which will cause
    it to expand to fill any available space. Then we've set the `width` value on
    the `size` column to `200` pixels.
  prefs: []
  type: TYPE_NORMAL
- en: 'The column parameters that can be set include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`stretch`: Whether or not to expand this column to fill the available space.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`width`: The width of the column in pixels.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`minwidth`: The minimum width to which the column can be resized, in pixels.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`anchor`: The alignment of the text in the column. Can be any of eight cardinal
    directions or `center`, specified as strings or Tkinter constants.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With the treeview configured, let''s add it into the GUI, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Populating a Treeview with data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we've finished the GUI portion, our view needs to be filled with data.
    Populating a `Treeview` widget with data is done one row at a time using its `insert()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'A basic call to the `insert()` method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The first argument specifies the **parent item** for the inserted row. This
    is *not* the parent widget, but rather the IID of the parent node under which
    the inserted node belongs in the hierarchical structure. For top-level items,
    this value should be an empty string.
  prefs: []
  type: TYPE_NORMAL
- en: The next argument specifies where the item should be inserted under its parent
    node with respect to its sibling nodes. It can be either a numerical index or
    the string `end`, which places the item at the end of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'After those positional arguments, `insert()` takes a number of keyword arguments,
    which can include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`text`: This is the value to be shown in the icon column (CID `#0`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`values`: This is a list of values for the remaining columns. Note that we
    need to specify them in order.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`image`: This is an image object to display in the far left of the icon column.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`iid`: The row''s IID string. This will be automatically assigned if you don''t
    specify it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`open`: For nodes with children, this sets if the row is initially open (displaying
    child items) or not.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tags`: A list of tag strings. We''ll learn more about tags when we discuss
    styling in *Chapter 9*, *Improving the Look with Styles and Themes*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To insert our file paths into the treeview, let''s iterate the `paths` list
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Before calling `insert()`, we need to extract and prepare some data from the
    `path` object. The `path.stat()` method will give us an object containing various
    file information, from which we'll extract the size and modified time. `path.parent`
    provides us with the containing path; however, we need to change the name of the
    root path (currently a single dot) to an empty string, which is how `Treeview`
    represents the root node.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, still in the `for` loop, we add the `insert()` method call as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: By using the path string as the IID, we can then specify it as a parent for
    its child objects. We use only the path name (that is, the file or directory name
    without the containing path) as our display value, then retrieve `st_size` and
    `st_mtime` from the `stat()` data for populating the size and modification time
    columns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run this script and you should see a simple file tree browser that looks something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1: Our Treeview filebrowser running on Ubuntu Linux](img/B17578_08_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.3: Our Treeview widget file browser running on Ubuntu Linux'
  prefs: []
  type: TYPE_NORMAL
- en: Sorting Treeview records
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Treeview` widget doesn't offer any kind of sorting functionality by default,
    but we can implement sorting by adding a callback function to the column headers.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting through hierarchical data of an unknown depth is a bit tricky; to do
    it, we're going to write a **recursive function**. A recursive function is a function
    that calls itself, and they are most commonly employed when dealing with hierarchical
    data of unknown depth.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by defining our function signature, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This `sort()` function takes a `Treeview` widget, a CID string of the column
    we want to sort on, an optional parent node IID, and a Boolean value indicating
    if the sort should be reversed. The default value for `parent` is an empty string,
    indicating the root of the hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we''re going to do is build a list of tuples, each containing
    the value we want to sort on and the IID of the row containing that value, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `Treeview.get_children()` method retrieves a list of IID strings that are
    immediate children of the given `parent` IID. For example, in our file browser,
    calling `tv.get_children('')` would return a list of all the IID values for the
    files and folders in the current directory (not in any sub-directories).
  prefs: []
  type: TYPE_NORMAL
- en: Once we have this list, we iterate through it and start building a list we can
    sort on. To do this, we need to retrieve the contents of the sort column for each
    IID. Rather confusingly, this is done using the `Treeview.set()` method. `Treeview.set()`
    can be called with either two or three arguments, the first two always being the
    IID and CID of the cell we want to reference. If the third argument is present,
    `set()` will write that value to the cell. If it is omitted, `set()` will return
    the current value of that cell. There is no `Treeview.get()` method, so this is
    how we retrieve the value of a particular cell.
  prefs: []
  type: TYPE_NORMAL
- en: However, `set()` cannot be called on CID `#0`, even if we only want to retrieve
    the value. So we have added a check in case the user is sorting on that column,
    and return the IID instead. After obtaining the contents of the table cell, we
    add it with its IID to the `sort_index` list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can sort the index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Because our table cell value is first in each tuple, the tuples will be sorted
    on it by default. Note that we've passed in the `reverse` value, to indicate which
    direction the list will be sorted in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a sorted list, we''ll need to move each node accordingly.
    Add this code next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `enumerate()` function returns a tuple containing each item in the list
    with an integer indicating its index in the list. Since each item in our list
    is already a tuple, we''re expanding that as well, giving us three variables:
    `index`, the index number of the list item; `_`, the sort value (which we no longer
    need, so we''re naming it with an underscore); and `iid`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For each item in the list, we call `Treeview.move()`, which takes three arguments:
    the IID of the row we want to move, the parent node to which we want to move it,
    and the index under that node into which it should be inserted. This will effectively
    sort the rows according to the order of the `sort_index` list.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, though, this has only sorted the immediate children of our root node.
    Now it is time to employ recursion so that we can sort all the child nodes; this
    takes only one additional line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The last line of the `for` loop calls the `sort()` function again, this time
    passing in the child IID as the parent, and all other arguments the same. `sort()`
    will continue to call itself recursively until it reaches a node that has no children.
    In the case where a node has no children, that call to `sort()` will return without
    doing anything. In this way, all sub-directories containing files will be individually
    sorted by their own call to `sort()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use our `sort()` function, we need to bind it to our column headers; we
    can do that once again by calling the `Treeview.heading()` method, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Here we're looping through each of our CID values, calling the `heading()` method
    to add a `command` argument to the heading. We're doing this in the form of a
    `lambda` function with a default argument for the CID.
  prefs: []
  type: TYPE_NORMAL
- en: Why use a default argument to pass in the CID? The body of a `lambda` function
    is evaluated using **late binding**, meaning that the value of the variables isn't
    established until the moment the body is run. By that point, `cid` will be the
    last value in the list (`'modified'`) no matter which column is calling the callback.
    The signature of the `lambda` function, however, is evaluated immediately, meaning
    the default value of `col` will be whatever `cid` is when we create the function.
  prefs: []
  type: TYPE_NORMAL
- en: One last fix to make to this function; typically, a sort will reverse with a
    second click of the header. We can implement this with a second set of calls to
    the `heading()` method inside the `sort()` function that will replace the `lambda`
    function with a reversed version.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `sort()` function, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Since the function is called recursively, we do not want to call this more than
    once per sorting; so, we'll only run this code for the root node, indicated by
    the `parent` value being a blank string. Inside that block, we reset the `lambda`
    function on the column being sorted, this time setting `reverse` to be the opposite
    of its current value.
  prefs: []
  type: TYPE_NORMAL
- en: Now when you run the application, you should be able to sort in both directions
    by clicking the headers of each column.
  prefs: []
  type: TYPE_NORMAL
- en: Note that even though two of the columns contain numbers, they are sorted in
    **lexical order** – that is, as though they were strings, not numerical values.
    This is because the values put into a `Treeview` widget are implicitly converted
    to strings, so the sort value returned by `Treeview.set()` is a string. To sort
    these using a numerical sort, you would need to cast them back to integer or float
    values before sorting.
  prefs: []
  type: TYPE_NORMAL
- en: Using Treeview virtual events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make it possible to respond to user interaction with the `Treeview` widget''s
    items, the widget includes three virtual events, shown in this table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Event | Generated |'
  prefs: []
  type: TYPE_TB
- en: '| `<<TreeviewSelect>>` | When the user selects an item |'
  prefs: []
  type: TYPE_TB
- en: '| `<<TreeviewOpen>>` | When a parent item is expanded to display child items
    |'
  prefs: []
  type: TYPE_TB
- en: '| `<<TreeviewClose>>` | When an open parent item is closed again |'
  prefs: []
  type: TYPE_TB
- en: 'For example, we can use these events to display some directory information
    in a status bar when the user opens a directory. First, let''s add a status bar
    to the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll create a callback for the event that will get some information
    about the opened directory and display it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: When a user clicks on an item to open it, that item gains focus, so we can use
    the treeview's `focus()` method to get the IID of the item that was clicked on.
    We've converted that to a `Path` and calculated the number of child objects in
    the directory using the `Path` object's `iterdir()` method. Then, we update the
    `status` variable with that information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can bind this callback to the appropriate virtual events, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In addition to binding the open event to our callback, we've bound the close
    event to a `lambda` function that clears the status control variable. Now, run
    the demo script and click on a directory. You should see some information show
    up in the status bar. Click it again and the information goes away.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a record list with Treeview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we understand how to use the `Treeview` widget, it''s time to implement
    a GUI that will allow us to browse the records in the CSV file and open them for
    editing. Let''s take a moment to plan out what it is that we need to create:'
  prefs: []
  type: TYPE_NORMAL
- en: We want to lay out the CSV data in a table structure, similar to how it would
    look in a spreadsheet. This will be a flat table, not a hierarchy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each table row will represent a record in the file. When a user double-clicks
    the row, or highlights it and presses Enter, we want the record form to open with
    the selected record.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We don't really need to show every field in the table, since its purpose is
    merely to locate records for editing. Instead, we'll show only the rows that uniquely
    identify a record to the user. Namely, those are `Date`, `Time`, `Lab`, and `Plot`.
    We can also show the CSV row number.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There isn't really a need to sort the data, so we won't implement sorting. The
    point is to visualize the CSV file, and its order shouldn't change.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To make all of this work, we'll first implement a widget, using a treeview,
    to display all the records and allow the selection of a record. Then, we'll go
    through the rest of the application components and integrate the new functionality.
    Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Creating the RecordList class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll begin building our `RecordList` class by subclassing `tkinter.Frame`,
    just as we did with our record form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'To save ourselves from some repetitious code, we''ll define our treeview''s
    column properties and defaults as class attributes. This will also make it easier
    to tweak them later to suit our evolving needs. Add these properties to the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Recall that we're going to be displaying `Date`, `Time`, `Lab`, and `Plot`.
    For the `#0` column, we'll show the CSV row number. We've also set the `width`
    and `anchor` values for some columns and configured the `Date` field to `stretch`.
    We'll use these values when configuring the `Treeview` widget in the `RecordList`
    class's initializer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving on to the initializer method, let''s begin it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Here, after running the superclass initializer, we've configured the grid layout
    to expand the first row and first column. This is where our `Treeview` widget
    will be placed, so we want it to take up any available space on the frame.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a Treeview widget
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now we''re ready to create our `Treeview` widget, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've created a `Treeview` widget and added it to the frame's layout.
    We've generated the `columns` list by retrieving the keys from the `column_defs`
    dictionary and excluding the first entry (`#0`). Remember that `#0` is automatically
    created and should not be included in the `columns` list. We're also choosing
    the `browse` selection mode so that users can select only individual rows of the
    CSV file. This will be important in the way we communicate back to the controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll configure the columns and headings of the `Treeview` widget by
    iterating through the `column_defs` dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: For each entry in `column_defs`, we're extracting the configuration values specified,
    then passing them to `Treeview.heading()` or `Treeview.column()` as appropriate.
    If the values aren't specified in the dictionary, the class default values will
    be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we''re going to set up some bindings so that double-clicking or hitting
    Enter on a record will cause a record to be opened, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The event `<Double-1>` refers to double-clicking mouse button 1 (that is, the
    left mouse button), while the `<Return>` event signifies striking the Return or
    Enter key (depending on how it''s labeled on your hardware). These are both bound
    to an instance method called `_on_open_record()`. Let''s go ahead and implement
    that method, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Since opening a record is something that happens outside the `RecordList` class,
    we''re simply going to generate a custom event called `<<OpenRecord>>` that our
    `Application` class can listen for. Of course, `Application` will need to know
    which record to switch to, so we''ll need a way for it to retrieve the currently
    selected row from the table. We''ll do this using a feature of Python classes
    called a **property**. A class property appears to outside code to be a regular
    attribute, but runs a method to determine its value whenever it is evaluated.
    We could use a method here, of course, but using a property simplifies access
    for code outside the class. To create a property, we need to write a method that
    takes only `self` as an argument and returns a value, then use the `@property`
    decorator on it. We''ll call our property `selected_id`; add it to the `RecordList`
    class like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In this method, we first retrieve a list of selected items using the `selection()`
    method. This method always returns a list, even when only one item is selected
    (and even when only one item *can* be selected). Since we only want to return
    one IID, we retrieve item 0 from the list if it exists, or `None` if nothing is
    selected. Remember that the IID of each row in our treeview is the CSV row number
    *as a string*. We'll want to convert that to an integer so that the controller
    can easily use it to locate the CSV record from the model.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a scrollbar for the Treeview
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since the CSV files are going to get several hundred records long, the record
    list is bound to overflow the height of the application window, even if the application
    is maximized. If this should happen, it would be helpful for users to have a scroll
    bar to navigate the list vertically.
  prefs: []
  type: TYPE_NORMAL
- en: The `Treeview` widget does not have a scrollbar by default; it can be scrolled
    using the keyboard or mouse-wheel controls, but users would reasonably expect
    a scrollbar on a scrollable area like the `Treeview` to help them visualize the
    size of the list and their current position in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, Ttk provides us with a `Scrollbar` widget that can be connected
    to our `Treeview` widget. Back in the initializer, let''s add one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Scrollbar` class takes two important keyword arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`orient`: This argument determines whether it is a horizontal or vertical scroll.
    The strings `horizontal` or `vertical` can be used, or the Tkinter constants `tk.HORIZONTAL`
    and `tk.VERTICAL`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`command`: This argument provides a callback for scrollbar move events. The
    callback will be passed arguments describing the scroll movement that happened.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this case, we set the callback to the treeview's `yview()` method, which
    is used to make the treeview scroll up and down. (The other option would be `xview()`,
    which would be used for horizontal scrolling.) The result is that when the scrollbar
    is moved, the position data is sent to `Treeview.yview()`, causing the treeview
    to scroll up and down.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to connect our `Treeview` back to the scrollbar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This tells the `Treeview` to send its current vertical position to the `Scrollbar`
    widget's `set()` method whenever it is scrolled. If we don't do this, our scrollbar
    won't know how far down the list we've scrolled or how long the list is, and won't
    be able to set the size or location of the bar widget appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: 'With our `Scrollbar` widget configured, we need to place it on the frame. By
    convention, it should be just to the right of the widget being scrolled, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Notice we set `sticky` to north, south, and west. North and south make sure
    the scrollbar stretches the entire height of the widget, and west makes sure it's
    snug against the `Treeview` widget to the left of it.
  prefs: []
  type: TYPE_NORMAL
- en: Populating the Treeview
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we have created and configured our `Treeview` widget, we''ll need
    a way to fill it with data. Let''s create a `populate()` method to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The `rows` argument will take a list of dictionaries, such as what is returned
    from the model's `get_all_records()` method. The idea is that the controller will
    fetch a list from the model and then pass it to the `RecordList` via this method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before refilling `Treeview`, we need to empty it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: To delete records from the treeview, we just need to call its `delete()` method
    with the IID of the row we want to delete. Here, we've retrieved all row IIDs
    using `get_children()`, then passed them one by one to `delete()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the treeview is cleared, we can iterate through the `rows` list and
    populate the table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we do here is create a list of all the CIDs we actually want
    to fetch from each row by retrieving the treeview's `columns` value.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we iterate through the provided data rows using the `enumerate()` function
    to generate a row number. For each row, we'll create a list of values in the proper
    order using a list comprehension, then insert the list at the end of the `Treeview`
    widget with the `insert()` method. Notice that we're just using the row number
    (converted to a string) as both the IID and text for the first column of the row.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do in this function is a small usability tweak. To
    make our record list keyboard-friendly, we need to initially focus the first item
    so that keyboard users can immediately start to navigate it via the arrow keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'Doing this in a `Treeview` widget actually takes three method calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: First, the `focus_set()` method moves focus to the `Treeview` widget. Next,
    `selection_set('0')` selects the first record in the list (note that the string
    `0` is the IID of the first record). Finally, `focus('0')` focuses the row with
    an IID of `0`. And, of course, we only do this if there are any rows at all; if
    we called these methods on an empty `Treeview`, we would cause an exception.
  prefs: []
  type: TYPE_NORMAL
- en: The `RecordList` class is now complete. Now it's time to update the rest of
    the application to make use of it.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the record list to the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have a model capable of reading and updating data, and a `RecordList`
    widget capable of displaying the contents of a file, we need to make changes to
    the rest of the application to enable everything to work together. Specifically,
    we''ll have to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We'll need to update the `DataRecordForm` to be suitable for updating existing
    records as well as adding new ones.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll need to update the layout of the `Application` window to accommodate the
    new record list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll need to create new `Application` callbacks to handle loading records and
    navigating the application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we'll need to update the main menu with new options for the added functionality.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the record form for read and update
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As long as we're still in `views.py`, let's scroll up to look at our `DataRecordForm`
    class and adjust it to make it capable of loading and updating existing records.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a moment and consider the following changes we''ll need to make:'
  prefs: []
  type: TYPE_NORMAL
- en: The form will need to keep track of what record it's editing, or if it's a new
    record.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user will need some visual indication of what record is being edited.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The form will need some way to load in a record provided by the controller.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's implement these changes.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a current record property
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To keep track of the current record being edited, we''ll just use an instance
    property. In the `__init__()` method, just above where the first `LabelFrame`
    widget is created, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The `current_record` instance attribute is initially set to `None`, which we'll
    use to indicate that no record is loaded and the form is being used to create
    a new record. When we edit a record, we'll update this value to an integer referencing
    a row in the CSV data. We could use a Tkinter variable here, but there's no real
    advantage in this case, and we wouldn't be able to use `None` as a value.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a label to show what is being edited
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Since the form might now be editing an existing record or a new one, it would
    be helpful to the user to be able to see what is going on at a glance. To do that,
    let''s add a `Label` to the top of the form to display the current record being
    edited, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re placing the new `Label` widget in `row 0`, `column 0`, which is going
    to cause the other widgets to bump down one row. This won''t affect our `Frame`
    widgets generated by `_add_frame()`, since they use implicit row numbers, but
    our Notes input and buttons will need to be moved. Let''s update those widgets
    with a new position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Feel free to adjust the height of the Notes field if this change pushes the
    bottom of the form off-screen on your system!
  prefs: []
  type: TYPE_NORMAL
- en: Adding a load_record() method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The last thing to add to the `DataRecordForm` class is a method for loading
    in a new record. This method will need to accept a row number and dictionary of
    data from the controller and use them to update the `current_record`, the data
    in the form, and the label at the top. This will be a public method, since it
    will be called from the controller, and it will begin like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: After updating the `current_record` attribute, we check to see if `rownum` is
    `None`. Recall that this indicates we're requesting a blank form to enter a new
    record. In that case, we'll call the `reset()` method and configure the label
    to show **New Record**.
  prefs: []
  type: TYPE_NORMAL
- en: Note that our `if` condition here checks specifically whether `rownum` is `None`;
    we can't just check the truth value of `rownum`, since 0 is a valid `rownum` for
    updating!
  prefs: []
  type: TYPE_NORMAL
- en: 'If we do have a valid `rownum`, we''ll need it to act differently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: In this block, we first set the label appropriately with the row number we're
    editing. Then, we iterate over the form's `_vars` dictionary, retrieving matching
    values from the `data` dictionary that was passed to the function. Finally, we
    attempt to call the `trigger_focusout_validation()` method on each variable's
    input widget, since it's possible that the CSV file contains invalid data. If
    the input has no such method (that is, if we used a regular Tkinter widget rather
    than one of our validated widgets), we just do nothing.
  prefs: []
  type: TYPE_NORMAL
- en: Our form is now ready to load data records!
  prefs: []
  type: TYPE_NORMAL
- en: Updating the application layout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have the form ready for loading records, and we have the record list ready
    to display them. We now need to incorporate all of this into the main application.
    First, though, we need to consider how we can accommodate both forms into our
    GUI layout.
  prefs: []
  type: TYPE_NORMAL
- en: Back in *Chapter 2*, *Designing GUI Applications*, we listed a few options for
    widgets that can help us group GUI components and cut down on the clutter of the
    GUI. We chose to use framed boxes to organize our data entry form; could we do
    the same again?
  prefs: []
  type: TYPE_NORMAL
- en: 'A quick mockup of the idea might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2: A layout of our application using side-by-side frames](img/B17578_08_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.4: A layout of our application using side-by-side frames'
  prefs: []
  type: TYPE_NORMAL
- en: This could work, but it's a lot of information on the screen at once, and the
    user doesn't really need to see all of this at the same time. The Record List
    is primarily for navigating, and the Data Entry form is for editing or entering
    data. It would probably be better if we showed only one component at a time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another option for organizing these two large components into the same GUI
    is the **notebook**. This type of widget can switch between multiple pages in
    a GUI by using tabs. Ttk offers us a `Notebook` widget that implements this feature;
    you''ve seen it before, back in *Chapter 1*, *Introduction to Tkinter*, when we
    looked at the IDLE configuration dialog. It can be seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Ttk Notebook tabs in IDLE''s config dialog](img/B17578_08_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.5: Ttk Notebook tabs in IDLE''s config dialog'
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a quick look at the Ttk `Notebook` to see how it can be used in an
    application.
  prefs: []
  type: TYPE_NORMAL
- en: The Ttk Notebook widget
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Notebook` widget is part of the `ttk` module, so we don''t need to add
    any additional imports to use it. Creating one is fairly simple, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'To add pages to the widgets, we need to create some child widgets. Let''s create
    a couple of `Label` widgets with some informative content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've created a couple of labels to be pages in our notebook. Typically
    your notebook page widgets would probably be `Frame` objects or subclasses like
    our `RecordList` or `DataRecordForm` components, but any widget can be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rather than use a geometry manager to place these components in the notebook,
    we instead use the widget''s `add()` method, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The `add()` method creates a new page containing the given widget at the end
    of the notebook. If we wanted to insert the page somewhere other than the end,
    we could also use the `insert()` method, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: This method is identical, except that it takes an index number as the first
    argument. The page will be inserted at that index.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both methods take a number of keyword arguments to configure the page and its
    tab, shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Argument | Values | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `text` | String | The text shown on the label. By default, tabs are blank.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `padding` | Integer | Padding in pixels to add around the widget on the page.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `sticky` | Cardinal values (`N`, `S`, `E`, `W`) | Where to stick the widget
    on the notebook page. `NSEW` by default. |'
  prefs: []
  type: TYPE_TB
- en: '| `underline` | Integer | Index of a letter in the `text` to bind for keyboard
    traversal. |'
  prefs: []
  type: TYPE_TB
- en: '| `image` | Tkinter `Photoimage` | An image to display on the tab. See *Chapter
    9*, *Improving the Look with Styles and Themes*. |'
  prefs: []
  type: TYPE_TB
- en: '| `compound` | `LEFT`, `RIGHT`, `CENTER`, `TOP`, `BOTTOM` | If both text and
    image are specified, where to display the image in relation to the text. |'
  prefs: []
  type: TYPE_TB
- en: The `underline` option is one we've seen before on other widgets (see *Chapter
    3*, *Creating Basic Forms with Tkinter and Ttk Widgets*); however, in the `ttk.Notebook`
    widget, the option actually sets up a keyboard binding when we use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try that out on our example notebook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The `tab()` method, similar to a widget's `config()` method, allows us to change
    configuration options on the tab after we've already added it.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we're specifying `underline=0` for both tabs, meaning the first
    letter of each tab's `text` string will be underlined. In addition, a keybinding
    will be created so that the key combination of Alt plus the underlined letter
    will switch to the matching tab. For example, in our application, we underlined
    letter 0 in the tab labeled **Banana**, so Alt-B will switch to that tab; we also
    underlined letter 0 in the tab labeled **Plantain**, so Alt-P will switch to the
    **Plantain** tab.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these bindings, we can enable general keyboard traversal of
    the notebook by calling its `enable_traversal()` method, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: If this method is called, Control-Tab will cycle through the tabs from left
    to right, and Shift-Control-Tab will cycle through them right to left.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our code may sometimes need to select a tab; for this, we can use the `select()`
    method, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we''re passing in the integer `0`, which indicates the first
    tab. We could also pass in the name of the widget contained by the tab, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: This works for the `tab()` method as well, and any method that requires a tab
    ID.
  prefs: []
  type: TYPE_NORMAL
- en: The `Notebook` widget has a `<<NotebookTabChanged>>` virtual signal that is
    generated whenever the user changes tabs. You might use this to refresh pages
    or display help messages, for example.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we're familiar with the notebook, let's incorporate one into our application.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a notebook to our application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To add a `Notebook` widget to our layout, we''ll need to create one in `Application.__init__()`
    before we create the `DataRecordForm` and `RecordList` widgets. Open the `application.py`
    file and locate the lines that currently create the `DataRecordForm` object, and
    let''s create a notebook just above them, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we''re enabling keyboard traversal for our keyboard-only users, and
    sticking the widget to all sides of the grid. Now, update the lines that create
    the record form as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we''ve simply removed the call to `self.recordform.grid()` and replaced
    it with `self.notebook.add()`. Next, let''s create an instance of the `RecordList`
    class and add it to the notebook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Although we're adding the `RecordList` widget second, we'd like it to display
    first; so, we're using `insert()` to add it to the beginning of the tab list.
    That completes adding our pages, but let's start adding the necessary callbacks
    to make them work.
  prefs: []
  type: TYPE_NORMAL
- en: Adding and updating application callbacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To bring all of these new widgets together in a functional way, we need to
    create a few callback methods on the `Application` object that will allow the
    application to get the user and the data to appropriate areas of the GUI when
    required. Specifically, we need to create four methods:'
  prefs: []
  type: TYPE_NORMAL
- en: A `_show_recordlist()` method we can use to display the record list when required
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `_populate_recordlist()` method we can call to repopulate the record list
    from file data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `_new_record()` method that we can use to switch to a new, empty record
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `_open_record()` method we can call to load a particular record into the
    form from the record list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also need to fix the `Application._on_save()` method to make sure it's passing
    the model all the information necessary for both updating existing records and
    creating new records.
  prefs: []
  type: TYPE_NORMAL
- en: Let's go through each method, creating or updating the method and binding or
    calling it where appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: The _show_recordlist() method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first method we''ll write is `_show_recordlist()`. This method is fairly
    simple, as you can see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: It's almost not worth writing such a simple method, but by having this as a
    method we can easily bind it as a callback without resorting to a `lambda` function.
    Note that we could have written this as `self.notebook.select(0)`, but passing
    the widget reference is more explicit about our intentions. Should we decide to
    switch the order of the tabs, this method will continue to work without alteration.
  prefs: []
  type: TYPE_NORMAL
- en: 'One place we''ll want to bind this callback is in our main menu. Back in the
    initializer for `Application`, let''s add this method to our dictionary of callback
    functions, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll add the necessary code for the menu itself in the next section. One
    other place we ought to call this method is at the end of `__init__()`, to ensure
    that the record list is displayed when the user opens the program. Add this at
    the end of `Application.__init__()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The _populate_recordlist() method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `_populate_recordlist()` method needs to retrieve data from the model and
    hand it to the record list''s `populate()` method. We could write it like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'However, remember that `CSVModel.get_all_records()` can potentially raise an
    `Exception` if there are problems with the data in the file. It''s the controller''s
    responsibility to catch that exception and take appropriate action, so we''ll
    write the method like this instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: In this version, if we get an exception from `get_all_records()`, we'll display
    its message in an error dialog. It will then be up to the user to deal with that
    issue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have this method, when should it be called? To begin with, it should
    be called whenever we select a new file to work with; so, let''s add a call to
    it at the end of `_on_file_select()`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, we need to populate the list whenever we open the program, since
    it will automatically load the default file. Let''s add a call to this method
    in the initializer just after creating the record list widget, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, whenever we save a record, this should also update the record list,
    since the new record will have been added to the file. We need to add a call to
    the method in `_on_save()`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Now our record list should stay in sync with the state of the file we're working
    on.
  prefs: []
  type: TYPE_NORMAL
- en: The _new_record() method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next, we need a method that can open the data record form for the entry of a
    new record. Remember that our `DataRecordForm.load_record()` method can take `None`
    as arguments for the record number and data, indicating that we want to work on
    a new record, so we just need to write a callback that will do this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this method to `Application`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: After calling `load_record()` to prepare the form for a new record entry, we
    switch the notebook to the record form using `notebook.select()`. To enable users
    to call this method, we'll create a menu entry, so we'll need to add another entry
    to the `event_callbacks` dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Application.__init__()`, update the dictionary as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: We'll add the necessary code to the menu in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The _open_record() method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, we need to write a callback method that will open an existing record
    when the user selects one from the record list. Add this method to the `Application`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Remember that the `RecordList` object updates its `selected_id` property whenever
    a record is double-clicked or activated with the Enter key. We're retrieving this
    ID number and passing it to the model's `get_record()` method. Because `get_record()`
    calls `get_all_records()`, it can also potentially raise an exception if there
    is a problem with the file. Therefore, just as we did in `_populate_recordlist()`,
    we're catching the exception and displaying its message to the user in the case
    of problem.
  prefs: []
  type: TYPE_NORMAL
- en: If there's no problem, we've retrieved the data, and we need only pass the row
    number and dictionary of data to the form's `load_record()` method. Last of all,
    we call `notebook.select()` to switch to the record form view.
  prefs: []
  type: TYPE_NORMAL
- en: This callback needs to be called whenever the user chooses a file from the record
    list. Remember that we have written our `RecordList` objects to generate an `<<OpenRecord>>`
    event whenever this happens. Back in the application's initializer method, we
    need to set up a binding to this event.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in `Application.__init__()`, add this binding just after creating the
    `RecordList` widget, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Now a double-click or Enter keypress will open the selected record in the form.
  prefs: []
  type: TYPE_NORMAL
- en: The _on_save() method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Finally, now that our model can handle updating existing records, we need to
    alter the call that we make to the model's `save_record()` method to make sure
    we're passing in all the information it needs to either update an existing record
    or insert a new one. Recall that we updated `save_record()` to take a `rownum`
    argument. When this value is `None`, a new record is added; when it is an integer,
    the indicated row number is updated.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Application._on_save()`, update the code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Recall that the record form object's `current_record` holds the value of the
    current row being edited, or `None` if it is a new record. We can pass that value
    directly on to the model's `save()` method, ensuring that the data is saved to
    the proper place.
  prefs: []
  type: TYPE_NORMAL
- en: Main menu changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last change we need to make to our application is updating the main menu
    with the new options for navigating the application; specifically, we need to
    add a command for adding a new file, and a command for going back to the record
    list. Remember that the `Application` object has bound callbacks for these operations
    to the `<<ShowRecordlist>>` and `<<NewRecord>>` events, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'There isn''t really a standard location for commands that navigate around the
    application, so we''ll create a new sub-menu called Go. Open the `mainmenu.py`
    file, and let''s add a new sub-menu in the initializer method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we''ve added a new sub-menu widget and added our two navigation commands,
    once again taking advantage of the `_event()` method, which gives us a reference
    to a method that generates the given event. Now add the `Go` menu between the
    File and Options menus, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Testing our program
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At this point, you should be able to run the application and load in a sample
    CSV file as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Selecting an existing file for writing with our new menu and record list](img/B17578_08_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.6: Selecting an existing file for writing with our new menu and record
    list'
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure to try opening a record, editing and saving it, as well as inserting
    new records and opening different files. You should also test the following error
    conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: Try opening a file that isn't a CSV file, or a CSV with incorrect fields. What
    happens?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open a valid CSV file, select a record for editing, then, before clicking **Save**,
    select a different or empty file. What happens?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open two copies of the program and point them to the saved CSV file. Try alternating
    edit or update actions between the programs. Note what happens.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider how you might address some of these issues; in some cases it may not
    be possible, and users will just have to be informed of the limitations. Also,
    if possible, try the last test on different operating systems. Are the results
    different?
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have changed our program from being an append-only data entry form to an
    application capable of loading, viewing, and updating data from existing files.
    In the process, you learned how to update our model so that it could read and
    update CSV files. You also explored the `Treeview` widget, including its basic
    use, virtual events, and column callbacks. You explored using the `Treeview` widget
    with hierarchical data structures by creating a file-browsing tool. You learned
    how to organize multi-form applications using a `Notebook` widget, and how to
    create scrolling interfaces using the `Scrollbar` widget. Finally, you integrated
    these concepts into the ABQ Data Entry application to address user needs.
  prefs: []
  type: TYPE_NORMAL
- en: In our next chapter, we'll be learning how to modify the look and feel of our
    application. We'll learn about using widget attributes, styles, and themes, as
    well as working with bitmapped graphics.
  prefs: []
  type: TYPE_NORMAL
