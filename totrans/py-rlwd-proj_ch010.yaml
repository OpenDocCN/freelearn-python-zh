- en: Chapter 6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Project 2.1: Data Inspection Notebook'
  prefs: []
  type: TYPE_NORMAL
- en: We often need to do an ad hoc inspection of source data. In particular, the
    very first time we acquire new data, we need to see the file to be sure it meets
    expectations. Additionally, debugging and problem-solving also benefit from ad
    hoc data inspections. This chapter will guide you through using a Jupyter notebook
    to survey data and find the structure and domains of the attributes.
  prefs: []
  type: TYPE_NORMAL
- en: The previous chapters have focused on a simple dataset where the data types
    look like obvious floating-point values. For such a trivial dataset, the inspection
    isn’t going to be very complicated.
  prefs: []
  type: TYPE_NORMAL
- en: It can help to start with a trivial dataset and focus on the tools and how they
    work together. For this reason, we’ll continue using relatively small datasets
    to let you learn about the tools without having the burden of **also** trying
    to understand the data.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter’s projects cover how to create and use a Jupyter notebook for data
    inspection. This permits tremendous flexibility, something often required when
    looking at new data for the first time. It’s also essential when diagnosing problems
    with data that has — unexpectedly — changed.
  prefs: []
  type: TYPE_NORMAL
- en: A Jupyter notebook is inherently interactive and saves us from having to design
    and build an interactive application. Instead, we need to be disciplined in using
    a notebook only to examine data, never to apply changes.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter has one project, to build an inspection notebook. We’ll start with
    a description of the notebook’s purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 6.1 Description
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When confronted with raw data acquired from a source application, database,
    or web API, it’s prudent to inspect the data to be sure it really can be used
    for the desired analysis. It’s common to find that data doesn’t precisely match
    the given descriptions. It’s also possible to discover that the metadata is out
    of date or incomplete.
  prefs: []
  type: TYPE_NORMAL
- en: 'The foundational principle behind this project is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**We don’t always know what the actual data looks like.**'
  prefs: []
  type: TYPE_NORMAL
- en: Data may have errors because source applications have bugs. There could be ”undocumented
    features,” which are similar to bugs but have better explanations. There may have
    been actions made by users that have introduced new codes or status flags. For
    example, an application may have a ”comments” field on an accounts-payable record,
    and accounting clerks may have invented their own set of coded values, which they
    put in the last few characters of this field. This defines a manual process outside
    the enterprise software. It’s an essential business process that contains valuable
    data; it’s not part of any software.
  prefs: []
  type: TYPE_NORMAL
- en: 'The general process for building a useful Jupyter notebook often proceeds through
    the following phases:'
  prefs: []
  type: TYPE_NORMAL
- en: Start with a simple display of selected rows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, show ranges for what appear to be numerical fields.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Later, in a separate analysis notebook, we can find central tendency (mean,
    median, and standard deviation) values after they’ve been cleaned.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using a notebook moves us away from the previous chapters’ focus on CLI applications.
    This is necessary because a notebook is interactive. It is designed to allow exploration
    with few constraints.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **User Experience** (**UX**) has two general steps to it:'
  prefs: []
  type: TYPE_NORMAL
- en: Run a data acquisition application. This is one of the CLI commands for projects
    in any of the previous chapters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start a Jupyter Lab server. This is a second CLI command to start the server.
    The `jupyter`` lab` command will launch a browser session. The rest of the work
    is done through the browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a notebook by clicking the notebook icon.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Load data by entering some Python code into a cell.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Determine if the data is useful by creating cells to show the data and show
    properties of the data.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: For more information on Jupyter, see [https://www.packtpub.com/product/learning-jupyter/9781785884870](https://www.packtpub.com/product/learning-jupyter/9781785884870).
  prefs: []
  type: TYPE_NORMAL
- en: 6.1.1 About the source data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An essential ingredient here is that all of the data acquisition projects **must**
    produce output in a consistent format. We’ve suggested using NDJSON (sometimes
    called JSON NL) as a format for preserving the raw data. See [*Chapter** 3*](ch007.xhtml#x1-560003),
    [*Project 1.1: Data Acquisition Base Application*](ch007.xhtml#x1-560003), for
    more information on the file format.'
  prefs: []
  type: TYPE_NORMAL
- en: It’s imperative to review the previous projects’ acceptance test suites to be
    sure there is a test to confirm the output files have the correct, consistent
    format.
  prefs: []
  type: TYPE_NORMAL
- en: 'To recap the data flow, we’ve done the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Read from some source. This includes files, RESTful APIs, HTML pages, and SQL
    databases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preserved the raw data in an essentially textual form, stripping away any data
    type information that may have been imposed by a SQL database or RESTful JSON
    document.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The inspection step will look at the text versions of values in these files.
    Later projects, starting with [*Chapter** 9*](ch013.xhtml#x1-2080009), [*Project
    3.1: Data Cleaning Base Application*](ch013.xhtml#x1-2080009), will look at converting
    data from text into something more useful for analytic work.'
  prefs: []
  type: TYPE_NORMAL
- en: An inspection notebook will often be required to do some data cleanup in order
    to show data problems. This will be enough cleanup to understand the data and
    no more. Later projects will expand the cleanup to cover all of the data problems.
  prefs: []
  type: TYPE_NORMAL
- en: In many data acquisition projects, it’s unwise to attempt any data conversion
    before an initial inspection. This is because the data is highly variable and
    poorly documented. A disciplined, three-step approach separates acquisition and
    inspection from attempts at data conversion and processing.
  prefs: []
  type: TYPE_NORMAL
- en: We may find a wide variety of unexpected things in a data source. For example,
    a CSV file may have an unexpected header, leading to a row of bad data. Or, a
    CSV file may — sometimes — lack headers, forcing the acquire application to supply
    default headers. A file that’s described as CSV may not have delimiters, but may
    have fixed-size text fields padded with spaces. There may be empty rows that can
    be ignored. There may be empty rows that delimit the useful data and separate
    it from footnotes or other non-data in the file. A ZIP archive may contain a surprising
    collection of irrelevant files in addition to the desired data file.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps one of the worst problems is trying to process files that are not prepared
    using a widely used character encoding such as UTF-8\. Files encoded with CP-1252
    encoding may have a few odd-looking characters when the decoder assumes it’s UTF-8
    encoding. Python’s `codecs` module provides a number of forms of alternative file
    encoding to handle this kind of problem. This problem seems rare; some organizations
    will note the encoding for text to prevent problems.
  prefs: []
  type: TYPE_NORMAL
- en: Inspection notebooks often start as `print()` functions in the data acquisition
    process to show what the data is. The idea here is to extend this concept a little
    and use an interactive notebook instead of `print()` to get a look at the data
    and see that it meets expectations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Not all managers agree with taking time to build an inspection notebook. Often,
    this is a conflict between assumptions and reality with the following potential
    outcomes:'
  prefs: []
  type: TYPE_NORMAL
- en: A manager can assume there will be no surprises in the data; the data will be
    entirely as specified in a data contract or other schema definition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the data doesn’t match expectations, a data inspection notebook will be
    a helpful part of the debugging effort.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In the unlikely event the data does match expectations, the data inspection
    notebook can be used to show that the data is valid.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A manager can assume the data is unlikely to be correct. In this case, the data
    inspection notebook will be seen as useful for uncovering the inevitable problems.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notebooks often start as `print()` or logger output to confirm the data is useful.
    This debugging output can be migrated to an informal notebook — at a low cost
    — and evolve into something more complete and focused on inspection and data quality
    assurance.
  prefs: []
  type: TYPE_NORMAL
- en: This initial project won’t build a complicated notebook. The intent is to provide
    an **interactive** display of data, allowing exploration and investigation. In
    the next section, we’ll outline an approach to this project, and to working with
    notebooks in general.
  prefs: []
  type: TYPE_NORMAL
- en: 6.2 Approach
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll take some guidance from the C4 model ( [https://c4model.com](https://c4model.com))
    when looking at our approach.
  prefs: []
  type: TYPE_NORMAL
- en: '**Context**: For this project, the context diagram has two use cases: acquire
    and inspect'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Containers**: There’s one container for the various applications: the user’s
    personal computer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Components**: There are two significantly different collections of software
    components: the acquisition program and inspection notebooks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code**: We’ll touch on this to provide some suggested directions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A context diagram for this application is shown in [*Figure 6.1*](#6.1).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1: Context Diagram ](img/file31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.1: Context Diagram'
  prefs: []
  type: TYPE_NORMAL
- en: The data analyst will use the CLI to run the data acquisition program. Then,
    the analyst will use the CLI to start a Jupyter Lab server. Using a browser, the
    analyst can then use Jupyter Lab to inspect the data.
  prefs: []
  type: TYPE_NORMAL
- en: The components fall into two overall categories. The component diagram is shown
    in [*Figure **6.2*](#6.2).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2: Component diagram ](img/file32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.2: Component diagram'
  prefs: []
  type: TYPE_NORMAL
- en: The diagram shows the interfaces seen by the data analyst, the `terminal` and
    the `browser`. These are shown with the *boundary* icon from the **Unified Modeling**
    **Language** (**UML**).
  prefs: []
  type: TYPE_NORMAL
- en: The `Acquisition` group of components contains the various modules and the overall
    acquire application. This is run from the command line to acquire the raw data
    from an appropriate source. The `db_extract` module is associated with an external
    SQL database. The `api_download` module is associated with an external RESTful
    API. Additional sources and processing modules could be added to this part of
    the diagram.
  prefs: []
  type: TYPE_NORMAL
- en: The processing performed by the `Acquisition` group of components creates the
    data files shown in the `Storage` group. This group depicts the raw data files
    acquired by the `acquire` application. These files will be refined and processed
    by further analytic applications.
  prefs: []
  type: TYPE_NORMAL
- en: The `Inspection` group shows the `jupyter` component. This is the entire Jupyter
    Lab application, summarized as a single icon. The `notebook` component is the
    notebook we’ll build in this application. This notebook depends on Jupyter Lab.
  prefs: []
  type: TYPE_NORMAL
- en: The `browser` is shown with the boundary icon. The intention is to characterize
    the notebook interaction via the browser as the user experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `notebook` component will use a number of built-in Python modules. This
    notebook’s cells can be decomposed into two smaller kinds of components:'
  prefs: []
  type: TYPE_NORMAL
- en: Functions to gather data from acquisition files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions to show the raw data. The `collections.Counter` class is very handy
    for this.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will need to locate (and install) a version of Jupyter Lab for this project.
    This needs to be added to the `requirements-dev.txt` file so other developers
    know to install it.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using `conda` to manage virtual environments, the command might look like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'When using other tools to manage virtual environments, the command might look
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the `jupyter` products are installed, it must be started from the command
    line. This command will start the server and launch a browser window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: For information on using Jupyter Lab, see [https://jupyterlab.readthedocs.io/en/latest/](https://jupyterlab.readthedocs.io/en/latest/).
  prefs: []
  type: TYPE_NORMAL
- en: If you’re not familiar with Jupyter, now is the time to use tutorials and learn
    the basics before moving on with this project.
  prefs: []
  type: TYPE_NORMAL
- en: Many of the notebook examples will include `import` statements.
  prefs: []
  type: TYPE_NORMAL
- en: Developers new to working with a Jupyter notebook should not take this as advice
    to repeat `import` statements in multiple cells throughout a notebook.
  prefs: []
  type: TYPE_NORMAL
- en: In a practical notebook, the imports can be collected together, often in a separate
    cell to introduce all of the needed packages.
  prefs: []
  type: TYPE_NORMAL
- en: In some enterprises, a startup script is used to provide a common set of imports
    for a number of closely related notebooks.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll return to more flexible ways to handle Python libraries from notebooks
    in [*Chapter** 13*](ch017.xhtml#x1-29700013), [*Project 4.1: Visual Analysis Techniques*](ch017.xhtml#x1-29700013).'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two other important considerations for this project: the ability
    to write automated tests for a notebook and the interaction of Python modules
    and notebooks. We’ll look at these topics in separate sections.'
  prefs: []
  type: TYPE_NORMAL
- en: 6.2.1 Notebook test cases for the functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It’s common to require unit test cases for a Python package. To be sure the
    test cases are meaningful, some enterprises insist the test cases exercise 100%
    of the lines of code in the module. For some industries, all logic paths must
    be tested. For more information, see [*Chapter** 1*](ch005.xhtml#x1-170001), [*Project
    Zero: A Template for Other* *Projects*](ch005.xhtml#x1-170001).'
  prefs: []
  type: TYPE_NORMAL
- en: For notebooks, automated testing can be a shade more complicated than it is
    for a Python module or package. The complication is that notebooks can contain
    arbitrary code that is not designed with testability in mind.
  prefs: []
  type: TYPE_NORMAL
- en: In order to have a disciplined, repeatable approach to creating notebooks, it’s
    helpful to develop a notebook in a series of stages, evolving toward a notebook
    that supports automated testing.
  prefs: []
  type: TYPE_NORMAL
- en: A notebook is software, and without test cases, any software is untrustworthy.
    In rare cases, the notebook’s code is simple enough that we can inspect it to
    develop some sense of its overall fitness for purpose. In most cases, complex
    computations, functions, and class definitions require a test case to demonstrate
    the code can be trusted to work properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The stages of notebook evolution often work as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: At stage zero, a notebook is often started with arbitrary Python code in cells
    and few or no function or class definitions. This is a great way to start development
    because the interactive nature of the notebook provides immediate results. Some
    cells will have errors or bad ideas in them. The order for processing the cells
    is not simply top to bottom. This code is difficult (or impossible) to validate
    with any automated testing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stage one will transform cell expressions into function and class definitions.
    This version of the notebook can also have cells with examples using the functions
    and classes. The order is closer to strictly top-to-bottom; there are fewer cells
    with known errors. The presence of examples serves as a basis for validating the
    notebook’s processing, but an automated test isn’t available.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stage two has more robust tests, using formal `assert` statements or `doctest`
    comments to define a repeatable test procedure. Rerunning the notebook from the
    beginning after any change will validate the notebook by executing the `assert`
    statements. All the cells are valid and the notebook processing is strictly top
    to bottom.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When there is more complicated or reusable processing, it may be helpful to
    refactor the function and class definitions out of the notebook and into a module.
    The module will have a unit test module or may be tested via **doctest** examples.
    This new module will be imported by the notebook; the notebook is used more for
    the presentation of results than the development of new ideas.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'One easy road to automated testing is to include **doctest** examples inside
    function and class definitions. For example, we might have a notebook cell that
    contains something like the following function definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The lines in the function’s docstring marked with `>>>` are spotted by the **doctest**
    tool. The lines are evaluated and the results are compared with the example from
    the docstring.
  prefs: []
  type: TYPE_NORMAL
- en: The last cell in the notebook can execute the `doctest.testmod()` function.
    This will examine all of the class and function definitions in the notebook, locate
    their **doctest** examples, and confirm the actual results match the expectations.
  prefs: []
  type: TYPE_NORMAL
- en: For additional tools to help with notebook testing, see [https://testbook.readthedocs.io/en/latest/](https://testbook.readthedocs.io/en/latest/).
  prefs: []
  type: TYPE_NORMAL
- en: This evolution from a place for recording good ideas to an engineered solution
    is not trivially linear. There are often exploration and learning opportunities
    that lead to changes and shifts in focus. Using a notebook as a tool for tracking
    ideas, both good and bad, is common.
  prefs: []
  type: TYPE_NORMAL
- en: A notebook is also a tool for presenting a final, clear picture of whether or
    not the data is what the users expect. In this second use case, separating function
    and class definitions becomes more important. We’ll look at this briefly in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: 6.2.2 Common code in a separate module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we noted earlier, a notebook lets an idea evolve through several forms.
  prefs: []
  type: TYPE_NORMAL
- en: We might have a cell with the following
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note that this computation skips the first value in the series. This is because
    the source data has a header line that’s read by the `csv.reader()` function.
    Switching to `csv.DictReader()` can politely skip this line, but also changes
    the result structure from a list of strings into a dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: This computation of the minimum value can be restated as a function definition.
    Since it does three things — drops the first line, extracts the `’x’` attribute,
    and converts it into a float — it might be better to decompose it into three functions.
    It can be refactored again to include **doctest** examples in each function. See
    [*Notebook test cases for the functions*](#x1-1500001) for the example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Later, this function can be cut from the notebook cell and pasted into a separate
    module. We’ll assume the overall function was named `min_x()`. We might add this
    to a module named `series_stats.py`. The notebook can then import and use the
    function, leaving the definition as a sidebar detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: When refactoring a notebook to a reusable module, it’s important to use **cut**
    **and paste**, not copy and paste. A copy of the function will lead to questions
    if one of the copies is changed to improve performance or fix a problem and the
    other copy is left untouched. This is sometimes called the **Don’t Repeat** **Yourself**
    (**DRY**) principle.
  prefs: []
  type: TYPE_NORMAL
- en: When working with external modules that are still under development, any changes
    to a module will require stopping the notebook kernel and rerunning the notebook
    from the very beginning to remove and reload the function definitions. This can
    become awkward. There are some extensions to iPython that can be used to reload
    modules, or even auto-reload modules when the source module changes.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative is to wait until a function or class seems mature and unlikely
    to change before refactoring the notebook to create a separate module. Often,
    this decision is made as part of creating a final presentation notebook to display
    useful results.
  prefs: []
  type: TYPE_NORMAL
- en: We can now look at the specific list of deliverables for this project.
  prefs: []
  type: TYPE_NORMAL
- en: 6.3 Deliverables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This project has the following deliverables:'
  prefs: []
  type: TYPE_NORMAL
- en: A `pyproject.toml` file that identifies the tools used. For this book, we used
    `jupyterlab==3.5.3`. Note that while the book was being prepared for publication,
    version 4.0 was released. This ongoing evolution of components makes it important
    for you to find the latest version, not the version quoted here.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation in the `docs` folder.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit tests for any new application modules in the `tests` folder.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any new application modules in the `src` folder with code to be used by the
    inspection notebook.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A notebook to inspect the raw data acquired from any of the sources.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The project directory structure suggested in [*Chapter** 1*](ch005.xhtml#x1-170001),
    [*Project Zero: A Template* *for Other Projects*](ch005.xhtml#x1-170001) mentions
    a `notebooks` directory. See [*List of deliverables*](ch005.xhtml#x1-260003) for
    more information. Previous chapters haven’t used any notebooks, so this directory
    might not have been created in the first place. For this project, the `snotebooks`
    directory is needed.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at a few of these deliverables in a little more detail.
  prefs: []
  type: TYPE_NORMAL
- en: 6.3.1 Notebook .ipynb file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The notebook can (and should) be a mixture of Markdown cells providing notes
    and context, and computation cells showing the data.
  prefs: []
  type: TYPE_NORMAL
- en: Readers who have followed the projects up to this point will likely have a directory
    with NDJSON files that need to be read to construct useful Python objects. One
    good approach is to define a function to read lines from a file, and use `json.loads()`
    to transform the line of text into a small dictionary of useful data.
  prefs: []
  type: TYPE_NORMAL
- en: There’s no compelling reason to use the `model` module’s class definitions for
    this inspection. The class definitions can help to make the data somewhat more
    accessible.
  prefs: []
  type: TYPE_NORMAL
- en: The inspection process starts with cells that name the files, creating `Path`
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'A function code like the following example might be helpful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This function will iterate over the acquired data. In many cases, we can use
    the iterator to scan through a large collection of samples, picking individual
    attribute values or some subset of the samples.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the following statement to create a list-of-dictionary structure
    from the given path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We can start with these basics in a few cells of the notebook. Given this foundation,
    further cells can explore the available data.
  prefs: []
  type: TYPE_NORMAL
- en: Cells and functions to analyze data
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For this initial inspection project, the analysis requirements are small. The
    example datasets from the previous chapters are artificial data, designed to demonstrate
    the need to use graphical techniques for exploratory data analysis.
  prefs: []
  type: TYPE_NORMAL
- en: For other datasets, however, there may be a variety of odd or unusual problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the **CO****2** **PPM — Trends in Atmospheric Carbon** **Dioxide**
    dataset, available at [https://datahub.io/core/co2-ppm](https://datahub.io/core/co2-ppm),
    has a number of ”missing value” codes in the data. Here are two examples:'
  prefs: []
  type: TYPE_NORMAL
- en: The CO2 average values sometimes have values of −99*.*99 as a placeholder for
    a time when a measurement wasn’t available. In these cases, a statistical process
    used data from adjacent months to interpolate the missing value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, the number of days of valid data for a month’s summary wasn’t
    recorded, and a −1 value is used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This dataset requires a bit more care to be sure of the values in each column
    and what the columns mean.
  prefs: []
  type: TYPE_NORMAL
- en: Capturing the domain of values in a given column is helpful here. The `collections`
    module has a `Counter` object that’s ideal for understanding the data in a specific
    column.
  prefs: []
  type: TYPE_NORMAL
- en: 'A cell can use a three-step computation to see the domain of values:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the `samples_iter()` function to yield the source documents.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a generator with sample attribute values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `Counter` to summarize the values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This can lead to a cell in the notebook with the following statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The next cell in the notebook can display the value of the `domain_x` value.
    If the `csv.reader()` function is used, it will reveal the header along with the
    domain of values. If the `csv.DictReader()` class is used, this collection will
    not include the header. This permits a tidy exploration of the various attributes
    in the collection of samples.
  prefs: []
  type: TYPE_NORMAL
- en: 'An inspection notebook is not the place to attempt more sophisticated data
    analysis. Computing means or medians should only be done on cleaned data. We’ll
    return to this in [*Chapter** 15*](ch019.xhtml#x1-32500015), [*Project 5.1: Modeling
    Base* *Application*](ch019.xhtml#x1-32500015).'
  prefs: []
  type: TYPE_NORMAL
- en: Cells with Markdown to explain things
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It’s very helpful to include cells using Markdown to provide information, insights,
    and lessons learned about the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'For information on the markdown language, see the Daring Fireball website:
    [https://daringfireball.net/projects/markdown/basics](https://daringfireball.net/projects/markdown/basics).'
  prefs: []
  type: TYPE_NORMAL
- en: 'As noted earlier in this chapter, there are two general flavors of notebooks:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exploratory**: These notebooks are a series of blog posts about the data
    and the process of exploring and inspecting the data. Cells may not all work because
    they’re works in process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Presentation**: These notebooks are a more polished, final report on data
    or problems. The paths that lead to dead ends should be pruned into summaries
    of the lessons learned.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A bright line separates these two flavors of notebooks. The distinguishing factor
    is the reproducibility of the notebook. A notebook that’s useful for presentations
    can be run from beginning to end without manual intervention to fix problems or
    skip over cells with syntax errors or other problems. Otherwise, the notebook
    is part of an exploration. It’s often necessary to copy and edit an exploratory
    notebook to create a derived notebook focused on presentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally, a notebook designed for a presentation uses Markdown cells to create
    a narrative flow that looks like any chapter of a book or article in a journal.
    We’ll return to more formal reporting in [*Chapter** 14*](ch018.xhtml#x1-31300014),
    [*Project 4.2: Creating* *Reports*](ch018.xhtml#x1-31300014).'
  prefs: []
  type: TYPE_NORMAL
- en: Cells with test cases
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Earlier, we introduced a `samples_iter()` function that lacked any unit tests
    or examples. It’s considerably more helpful to provide a **doctest** string within
    a notebook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This function’s docstrings include an extensive test case. The test case builds
    an NDJSON document from a list of two dictionaries. The test case then applies
    the `samples_iter()` function to parse the NDJSON file and recover the original
    two samples.
  prefs: []
  type: TYPE_NORMAL
- en: 'To execute this test, the notebook needs a cell to examine the docstrings in
    all of the functions and classes defined in the notebook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This works because the global context for a notebook is treated like a module
    with a default name of `__main__`. This module will be examined by the `textmod()`
    function to find docstrings that look like they contain doc test examples.
  prefs: []
  type: TYPE_NORMAL
- en: Having the last cell run the **doctest** tool makes it easy to run the notebook,
    scroll to the end, and confirm the tests have all passed. This is an excellent
    form of validation.
  prefs: []
  type: TYPE_NORMAL
- en: 6.3.2 Executing a notebook’s test suite
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A Jupyter notebook is inherently interactive. This makes an automated acceptance
    test of a notebook potentially challenging.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, there’s a command that executes a notebook to confirm it works
    all the way through without problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the following command to execute a notebook to confirm that all
    the cells will execute without any errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: A notebook may ingest a great deal of data, making it very time-consuming to
    test the notebook as a whole. This can lead to using a cell to read a configuration
    file and using this information to use a subset of data for test purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 6.4 Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter’s project covered the basics of creating and using a Jupyter Lab
    notebook for data inspection. This permits tremendous flexibility, something often
    required when looking at new data for the first time.
  prefs: []
  type: TYPE_NORMAL
- en: We also looked at adding **doctest** examples to functions and running the **doctest**
    tool in the last cell of a notebook. This lets us validate that the code in the
    notebook is very likely to work properly.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve got an initial inspection notebook, we can start to consider
    the specific kinds of data being acquired. In the next chapter, we’ll add features
    to this notebook.
  prefs: []
  type: TYPE_NORMAL
- en: 6.5 Extras
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here are some ideas for you to add to this project.
  prefs: []
  type: TYPE_NORMAL
- en: 6.5.1 Use pandas to examine data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A common tool for interactive data exploration is the `pandas` package.
  prefs: []
  type: TYPE_NORMAL
- en: See [https://pandas.pydata.org](https://pandas.pydata.org) for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Also, see [https://www.packtpub.com/product/learning-pandas/9781783985128](https://www.packtpub.com/product/learning-pandas/9781783985128)
    for resources for learning more about pandas.
  prefs: []
  type: TYPE_NORMAL
- en: The value of using pandas for examining text may be limited. The real value
    of pandas is for doing more sophisticated statistical and graphical analysis of
    the data.
  prefs: []
  type: TYPE_NORMAL
- en: We encourage you to load NDJSON documents using pandas and do some preliminary
    investigation of the data values.
  prefs: []
  type: TYPE_NORMAL
