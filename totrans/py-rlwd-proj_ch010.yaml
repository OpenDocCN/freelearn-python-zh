- en: Chapter 6
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第六章
- en: 'Project 2.1: Data Inspection Notebook'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 项目 2.1：数据检查笔记本
- en: We often need to do an ad hoc inspection of source data. In particular, the
    very first time we acquire new data, we need to see the file to be sure it meets
    expectations. Additionally, debugging and problem-solving also benefit from ad
    hoc data inspections. This chapter will guide you through using a Jupyter notebook
    to survey data and find the structure and domains of the attributes.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常需要对源数据进行临时检查。特别是，当我们第一次获取新数据时，我们需要查看文件以确保它符合预期。此外，调试和问题解决也受益于临时数据检查。本章将指导您使用
    Jupyter 笔记本来调查数据并找到属性的结构和域。
- en: The previous chapters have focused on a simple dataset where the data types
    look like obvious floating-point values. For such a trivial dataset, the inspection
    isn’t going to be very complicated.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 前几章主要关注一个简单的数据集，其中数据类型看起来像是明显的浮点值。对于这样一个简单的数据集，检查不会非常复杂。
- en: It can help to start with a trivial dataset and focus on the tools and how they
    work together. For this reason, we’ll continue using relatively small datasets
    to let you learn about the tools without having the burden of **also** trying
    to understand the data.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个简单的数据集开始，关注工具及其如何协同工作可能会有所帮助。因此，我们将继续使用相对较小的数据集，让您了解工具，而无需承担**同时**理解数据的负担。
- en: This chapter’s projects cover how to create and use a Jupyter notebook for data
    inspection. This permits tremendous flexibility, something often required when
    looking at new data for the first time. It’s also essential when diagnosing problems
    with data that has — unexpectedly — changed.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的项目涵盖了如何创建和使用 Jupyter 笔记本进行数据检查。这提供了极大的灵活性，这在首次查看新数据时通常是非常需要的。当诊断意外发生变化的数据问题时，这也是至关重要的。
- en: A Jupyter notebook is inherently interactive and saves us from having to design
    and build an interactive application. Instead, we need to be disciplined in using
    a notebook only to examine data, never to apply changes.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Jupyter 笔记本本质上是交互式的，使我们免于设计和构建交互式应用程序。相反，我们需要自律，只使用笔记本来检查数据，绝不能用于应用更改。
- en: This chapter has one project, to build an inspection notebook. We’ll start with
    a description of the notebook’s purpose.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章有一个项目，即构建检查笔记本。我们将从描述笔记本的用途开始。
- en: 6.1 Description
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1 描述
- en: When confronted with raw data acquired from a source application, database,
    or web API, it’s prudent to inspect the data to be sure it really can be used
    for the desired analysis. It’s common to find that data doesn’t precisely match
    the given descriptions. It’s also possible to discover that the metadata is out
    of date or incomplete.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当面对从源应用程序、数据库或 Web API 获取的原始数据时，仔细检查数据以确保它确实可以用于所需的分析是明智的。通常会发现数据并不完全符合给定的描述。也可能发现元数据已过时或不完整。
- en: 'The foundational principle behind this project is the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目的根本原则如下：
- en: '**We don’t always know what the actual data looks like.**'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**我们并不总是知道实际数据看起来像什么。**'
- en: Data may have errors because source applications have bugs. There could be ”undocumented
    features,” which are similar to bugs but have better explanations. There may have
    been actions made by users that have introduced new codes or status flags. For
    example, an application may have a ”comments” field on an accounts-payable record,
    and accounting clerks may have invented their own set of coded values, which they
    put in the last few characters of this field. This defines a manual process outside
    the enterprise software. It’s an essential business process that contains valuable
    data; it’s not part of any software.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 数据可能存在错误，因为源应用程序有缺陷。可能有“未记录的功能”，这些功能类似于缺陷，但具有更好的解释。用户可能已经采取了行动，引入了新的代码或状态标志。例如，一个应用程序可能在应付账款记录上有一个“注释”字段，会计人员可能发明了自己的编码值，并将它们放在该字段的最后几个字符中。这定义了一个企业软件之外的手动流程。这是一个重要的业务流程，包含有价值的数据；它不是任何软件的一部分。
- en: 'The general process for building a useful Jupyter notebook often proceeds through
    the following phases:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个有用的 Jupyter 笔记本的一般过程通常包括以下阶段：
- en: Start with a simple display of selected rows.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从简单的选定行显示开始。
- en: Then, show ranges for what appear to be numerical fields.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，显示看似数值字段的范围。
- en: Later, in a separate analysis notebook, we can find central tendency (mean,
    median, and standard deviation) values after they’ve been cleaned.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，在单独的分析笔记本中，我们可以在数据清理后找到中心趋势（均值、中位数和标准差）值。
- en: Using a notebook moves us away from the previous chapters’ focus on CLI applications.
    This is necessary because a notebook is interactive. It is designed to allow exploration
    with few constraints.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用笔记本使我们摆脱了之前章节对CLI应用程序的关注。这是必要的，因为笔记本是交互式的。它旨在允许在很少的限制下进行探索。
- en: 'The **User Experience** (**UX**) has two general steps to it:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**用户体验**（**UX**）有两个一般步骤：'
- en: Run a data acquisition application. This is one of the CLI commands for projects
    in any of the previous chapters.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行数据采集应用程序。这是任何前几章项目中CLI命令之一。
- en: 'Start a Jupyter Lab server. This is a second CLI command to start the server.
    The `jupyter`` lab` command will launch a browser session. The rest of the work
    is done through the browser:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Jupyter Lab服务器。这是启动服务器的第二个CLI命令。`jupyter lab`命令将启动一个浏览器会话。其余的工作通过浏览器完成：
- en: Create a notebook by clicking the notebook icon.
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击笔记本图标创建一个笔记本。
- en: Load data by entering some Python code into a cell.
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在单元格中输入一些Python代码来加载数据。
- en: Determine if the data is useful by creating cells to show the data and show
    properties of the data.
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建单元格来显示数据和展示数据的属性，以确定数据是否有用。
- en: For more information on Jupyter, see [https://www.packtpub.com/product/learning-jupyter/9781785884870](https://www.packtpub.com/product/learning-jupyter/9781785884870).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于Jupyter的信息，请参阅[https://www.packtpub.com/product/learning-jupyter/9781785884870](https://www.packtpub.com/product/learning-jupyter/9781785884870)。
- en: 6.1.1 About the source data
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.1 关于源数据
- en: 'An essential ingredient here is that all of the data acquisition projects **must**
    produce output in a consistent format. We’ve suggested using NDJSON (sometimes
    called JSON NL) as a format for preserving the raw data. See [*Chapter** 3*](ch007.xhtml#x1-560003),
    [*Project 1.1: Data Acquisition Base Application*](ch007.xhtml#x1-560003), for
    more information on the file format.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这里一个基本的要素是，所有数据采集项目**必须**以一致的形式产生输出。我们建议使用NDJSON（有时称为JSON NL）作为保留原始数据的格式。有关文件格式的更多信息，请参阅[第3章](ch007.xhtml#x1-560003)，[项目1.1：数据采集基础应用程序](ch007.xhtml#x1-560003)。
- en: It’s imperative to review the previous projects’ acceptance test suites to be
    sure there is a test to confirm the output files have the correct, consistent
    format.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 必须审查之前项目的验收测试套件，以确保有一个测试来确认输出文件具有正确、一致的形式。
- en: 'To recap the data flow, we’ve done the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回顾数据流，我们做了以下工作：
- en: Read from some source. This includes files, RESTful APIs, HTML pages, and SQL
    databases.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从某些源读取。这包括文件、RESTful API、HTML页面和SQL数据库。
- en: Preserved the raw data in an essentially textual form, stripping away any data
    type information that may have been imposed by a SQL database or RESTful JSON
    document.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以基本文本形式保留了原始数据，去除了可能由SQL数据库或RESTful JSON文档强加的任何数据类型信息。
- en: 'The inspection step will look at the text versions of values in these files.
    Later projects, starting with [*Chapter** 9*](ch013.xhtml#x1-2080009), [*Project
    3.1: Data Cleaning Base Application*](ch013.xhtml#x1-2080009), will look at converting
    data from text into something more useful for analytic work.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 检查步骤将查看这些文件中值的文本版本。后续项目，从第9章开始，将研究将数据从文本转换为对分析工作更有用的形式。
- en: An inspection notebook will often be required to do some data cleanup in order
    to show data problems. This will be enough cleanup to understand the data and
    no more. Later projects will expand the cleanup to cover all of the data problems.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 检查笔记本通常需要做一些数据清理，以便展示数据问题。这将足够清理以了解数据，而无需更多。后续项目将扩展清理以涵盖所有数据问题。
- en: In many data acquisition projects, it’s unwise to attempt any data conversion
    before an initial inspection. This is because the data is highly variable and
    poorly documented. A disciplined, three-step approach separates acquisition and
    inspection from attempts at data conversion and processing.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多数据采集项目中，在初步检查之前尝试任何数据转换是不明智的。这是因为数据高度可变且文档记录不佳。一种有纪律的三步法将数据采集和检查与数据转换和处理的尝试分开。
- en: We may find a wide variety of unexpected things in a data source. For example,
    a CSV file may have an unexpected header, leading to a row of bad data. Or, a
    CSV file may — sometimes — lack headers, forcing the acquire application to supply
    default headers. A file that’s described as CSV may not have delimiters, but may
    have fixed-size text fields padded with spaces. There may be empty rows that can
    be ignored. There may be empty rows that delimit the useful data and separate
    it from footnotes or other non-data in the file. A ZIP archive may contain a surprising
    collection of irrelevant files in addition to the desired data file.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps one of the worst problems is trying to process files that are not prepared
    using a widely used character encoding such as UTF-8\. Files encoded with CP-1252
    encoding may have a few odd-looking characters when the decoder assumes it’s UTF-8
    encoding. Python’s `codecs` module provides a number of forms of alternative file
    encoding to handle this kind of problem. This problem seems rare; some organizations
    will note the encoding for text to prevent problems.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Inspection notebooks often start as `print()` functions in the data acquisition
    process to show what the data is. The idea here is to extend this concept a little
    and use an interactive notebook instead of `print()` to get a look at the data
    and see that it meets expectations.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'Not all managers agree with taking time to build an inspection notebook. Often,
    this is a conflict between assumptions and reality with the following potential
    outcomes:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: A manager can assume there will be no surprises in the data; the data will be
    entirely as specified in a data contract or other schema definition.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the data doesn’t match expectations, a data inspection notebook will be
    a helpful part of the debugging effort.
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In the unlikely event the data does match expectations, the data inspection
    notebook can be used to show that the data is valid.
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A manager can assume the data is unlikely to be correct. In this case, the data
    inspection notebook will be seen as useful for uncovering the inevitable problems.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notebooks often start as `print()` or logger output to confirm the data is useful.
    This debugging output can be migrated to an informal notebook — at a low cost
    — and evolve into something more complete and focused on inspection and data quality
    assurance.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: This initial project won’t build a complicated notebook. The intent is to provide
    an **interactive** display of data, allowing exploration and investigation. In
    the next section, we’ll outline an approach to this project, and to working with
    notebooks in general.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 6.2 Approach
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll take some guidance from the C4 model ( [https://c4model.com](https://c4model.com))
    when looking at our approach.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '**Context**: For this project, the context diagram has two use cases: acquire
    and inspect'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Containers**: There’s one container for the various applications: the user’s
    personal computer'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Components**: There are two significantly different collections of software
    components: the acquisition program and inspection notebooks'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code**: We’ll touch on this to provide some suggested directions'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A context diagram for this application is shown in [*Figure 6.1*](#6.1).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1: Context Diagram ](img/file31.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.1: Context Diagram'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: The data analyst will use the CLI to run the data acquisition program. Then,
    the analyst will use the CLI to start a Jupyter Lab server. Using a browser, the
    analyst can then use Jupyter Lab to inspect the data.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: The components fall into two overall categories. The component diagram is shown
    in [*Figure **6.2*](#6.2).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2: Component diagram ](img/file32.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.2: Component diagram'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: The diagram shows the interfaces seen by the data analyst, the `terminal` and
    the `browser`. These are shown with the *boundary* icon from the **Unified Modeling**
    **Language** (**UML**).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: The `Acquisition` group of components contains the various modules and the overall
    acquire application. This is run from the command line to acquire the raw data
    from an appropriate source. The `db_extract` module is associated with an external
    SQL database. The `api_download` module is associated with an external RESTful
    API. Additional sources and processing modules could be added to this part of
    the diagram.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: The processing performed by the `Acquisition` group of components creates the
    data files shown in the `Storage` group. This group depicts the raw data files
    acquired by the `acquire` application. These files will be refined and processed
    by further analytic applications.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: The `Inspection` group shows the `jupyter` component. This is the entire Jupyter
    Lab application, summarized as a single icon. The `notebook` component is the
    notebook we’ll build in this application. This notebook depends on Jupyter Lab.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: The `browser` is shown with the boundary icon. The intention is to characterize
    the notebook interaction via the browser as the user experience.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: 'The `notebook` component will use a number of built-in Python modules. This
    notebook’s cells can be decomposed into two smaller kinds of components:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Functions to gather data from acquisition files.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions to show the raw data. The `collections.Counter` class is very handy
    for this.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will need to locate (and install) a version of Jupyter Lab for this project.
    This needs to be added to the `requirements-dev.txt` file so other developers
    know to install it.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'When using `conda` to manage virtual environments, the command might look like
    the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When using other tools to manage virtual environments, the command might look
    like the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Once the `jupyter` products are installed, it must be started from the command
    line. This command will start the server and launch a browser window:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: For information on using Jupyter Lab, see [https://jupyterlab.readthedocs.io/en/latest/](https://jupyterlab.readthedocs.io/en/latest/).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: If you’re not familiar with Jupyter, now is the time to use tutorials and learn
    the basics before moving on with this project.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不太熟悉Jupyter，现在是时候使用教程学习基础知识，然后再继续这个项目。
- en: Many of the notebook examples will include `import` statements.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 许多笔记本示例将包括`import`语句。
- en: Developers new to working with a Jupyter notebook should not take this as advice
    to repeat `import` statements in multiple cells throughout a notebook.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 对于刚开始使用Jupyter笔记本的开发者来说，不应该将这视为在笔记本中多个单元格中重复`import`语句的建议。
- en: In a practical notebook, the imports can be collected together, often in a separate
    cell to introduce all of the needed packages.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际的笔记本中，导入可以收集在一起，通常在一个单独的单元格中引入所有需要的包。
- en: In some enterprises, a startup script is used to provide a common set of imports
    for a number of closely related notebooks.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些企业中，使用启动脚本提供一系列紧密相关的笔记本的共同导入集。
- en: 'We’ll return to more flexible ways to handle Python libraries from notebooks
    in [*Chapter** 13*](ch017.xhtml#x1-29700013), [*Project 4.1: Visual Analysis Techniques*](ch017.xhtml#x1-29700013).'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第13章*](ch017.xhtml#x1-29700013)、[*项目4.1：可视化分析技术*](ch017.xhtml#x1-29700013)中返回更多灵活的方式来处理笔记本中的Python库。
- en: 'There are two other important considerations for this project: the ability
    to write automated tests for a notebook and the interaction of Python modules
    and notebooks. We’ll look at these topics in separate sections.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，有两个其他重要的考虑因素：为笔记本编写自动化测试的能力以及Python模块和笔记本的交互。我们将在单独的章节中探讨这些主题。
- en: 6.2.1 Notebook test cases for the functions
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.1 函数的笔记本测试用例
- en: 'It’s common to require unit test cases for a Python package. To be sure the
    test cases are meaningful, some enterprises insist the test cases exercise 100%
    of the lines of code in the module. For some industries, all logic paths must
    be tested. For more information, see [*Chapter** 1*](ch005.xhtml#x1-170001), [*Project
    Zero: A Template for Other* *Projects*](ch005.xhtml#x1-170001).'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Python包来说，通常需要单元测试用例。为了确保测试用例有意义，一些企业坚持测试用例要练习模块中100%的代码行。对于某些行业，所有逻辑路径都必须经过测试。更多信息，请参阅[*第1章*](ch005.xhtml#x1-170001)、[*项目零：其他项目的模板*](ch005.xhtml#x1-170001)。
- en: For notebooks, automated testing can be a shade more complicated than it is
    for a Python module or package. The complication is that notebooks can contain
    arbitrary code that is not designed with testability in mind.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 对于笔记本来说，自动化测试可能比Python模块或包更复杂。复杂之处在于笔记本可能包含任意代码，这些代码没有考虑到可测试性。
- en: In order to have a disciplined, repeatable approach to creating notebooks, it’s
    helpful to develop a notebook in a series of stages, evolving toward a notebook
    that supports automated testing.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有一个有纪律、可重复的创建笔记本的方法，有助于在一系列阶段中开发笔记本，逐步发展成为一个支持自动化测试的笔记本。
- en: A notebook is software, and without test cases, any software is untrustworthy.
    In rare cases, the notebook’s code is simple enough that we can inspect it to
    develop some sense of its overall fitness for purpose. In most cases, complex
    computations, functions, and class definitions require a test case to demonstrate
    the code can be trusted to work properly.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 笔记本是一种软件，没有测试用例，任何软件都是不可信的。在罕见的情况下，笔记本的代码足够简单，我们可以检查它以发展对其整体适用性的某种感觉。在大多数情况下，复杂的计算、函数和类定义需要测试用例来证明代码可以信赖能正确工作。
- en: 'The stages of notebook evolution often work as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 笔记本演变的阶段通常如下所示：
- en: At stage zero, a notebook is often started with arbitrary Python code in cells
    and few or no function or class definitions. This is a great way to start development
    because the interactive nature of the notebook provides immediate results. Some
    cells will have errors or bad ideas in them. The order for processing the cells
    is not simply top to bottom. This code is difficult (or impossible) to validate
    with any automated testing.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在零阶段，笔记本通常以单元格中的任意Python代码开始，并且几乎没有函数或类定义。这是一个很好的开始开发的方式，因为笔记本的交互性提供了即时结果。一些单元格中可能会有错误或不良的想法。处理单元格的顺序并不是简单地从上到下。这段代码难以（或不可能）通过任何自动化测试进行验证。
- en: Stage one will transform cell expressions into function and class definitions.
    This version of the notebook can also have cells with examples using the functions
    and classes. The order is closer to strictly top-to-bottom; there are fewer cells
    with known errors. The presence of examples serves as a basis for validating the
    notebook’s processing, but an automated test isn’t available.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stage two has more robust tests, using formal `assert` statements or `doctest`
    comments to define a repeatable test procedure. Rerunning the notebook from the
    beginning after any change will validate the notebook by executing the `assert`
    statements. All the cells are valid and the notebook processing is strictly top
    to bottom.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When there is more complicated or reusable processing, it may be helpful to
    refactor the function and class definitions out of the notebook and into a module.
    The module will have a unit test module or may be tested via **doctest** examples.
    This new module will be imported by the notebook; the notebook is used more for
    the presentation of results than the development of new ideas.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'One easy road to automated testing is to include **doctest** examples inside
    function and class definitions. For example, we might have a notebook cell that
    contains something like the following function definition:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The lines in the function’s docstring marked with `>>>` are spotted by the **doctest**
    tool. The lines are evaluated and the results are compared with the example from
    the docstring.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: The last cell in the notebook can execute the `doctest.testmod()` function.
    This will examine all of the class and function definitions in the notebook, locate
    their **doctest** examples, and confirm the actual results match the expectations.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: For additional tools to help with notebook testing, see [https://testbook.readthedocs.io/en/latest/](https://testbook.readthedocs.io/en/latest/).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: This evolution from a place for recording good ideas to an engineered solution
    is not trivially linear. There are often exploration and learning opportunities
    that lead to changes and shifts in focus. Using a notebook as a tool for tracking
    ideas, both good and bad, is common.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: A notebook is also a tool for presenting a final, clear picture of whether or
    not the data is what the users expect. In this second use case, separating function
    and class definitions becomes more important. We’ll look at this briefly in the
    next section.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 6.2.2 Common code in a separate module
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we noted earlier, a notebook lets an idea evolve through several forms.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: We might have a cell with the following
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note that this computation skips the first value in the series. This is because
    the source data has a header line that’s read by the `csv.reader()` function.
    Switching to `csv.DictReader()` can politely skip this line, but also changes
    the result structure from a list of strings into a dictionary.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: This computation of the minimum value can be restated as a function definition.
    Since it does three things — drops the first line, extracts the `’x’` attribute,
    and converts it into a float — it might be better to decompose it into three functions.
    It can be refactored again to include **doctest** examples in each function. See
    [*Notebook test cases for the functions*](#x1-1500001) for the example.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'Later, this function can be cut from the notebook cell and pasted into a separate
    module. We’ll assume the overall function was named `min_x()`. We might add this
    to a module named `series_stats.py`. The notebook can then import and use the
    function, leaving the definition as a sidebar detail:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: When refactoring a notebook to a reusable module, it’s important to use **cut**
    **and paste**, not copy and paste. A copy of the function will lead to questions
    if one of the copies is changed to improve performance or fix a problem and the
    other copy is left untouched. This is sometimes called the **Don’t Repeat** **Yourself**
    (**DRY**) principle.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: When working with external modules that are still under development, any changes
    to a module will require stopping the notebook kernel and rerunning the notebook
    from the very beginning to remove and reload the function definitions. This can
    become awkward. There are some extensions to iPython that can be used to reload
    modules, or even auto-reload modules when the source module changes.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: An alternative is to wait until a function or class seems mature and unlikely
    to change before refactoring the notebook to create a separate module. Often,
    this decision is made as part of creating a final presentation notebook to display
    useful results.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: We can now look at the specific list of deliverables for this project.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 6.3 Deliverables
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This project has the following deliverables:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: A `pyproject.toml` file that identifies the tools used. For this book, we used
    `jupyterlab==3.5.3`. Note that while the book was being prepared for publication,
    version 4.0 was released. This ongoing evolution of components makes it important
    for you to find the latest version, not the version quoted here.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation in the `docs` folder.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit tests for any new application modules in the `tests` folder.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any new application modules in the `src` folder with code to be used by the
    inspection notebook.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A notebook to inspect the raw data acquired from any of the sources.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The project directory structure suggested in [*Chapter** 1*](ch005.xhtml#x1-170001),
    [*Project Zero: A Template* *for Other Projects*](ch005.xhtml#x1-170001) mentions
    a `notebooks` directory. See [*List of deliverables*](ch005.xhtml#x1-260003) for
    more information. Previous chapters haven’t used any notebooks, so this directory
    might not have been created in the first place. For this project, the `snotebooks`
    directory is needed.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at a few of these deliverables in a little more detail.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 6.3.1 Notebook .ipynb file
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The notebook can (and should) be a mixture of Markdown cells providing notes
    and context, and computation cells showing the data.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Readers who have followed the projects up to this point will likely have a directory
    with NDJSON files that need to be read to construct useful Python objects. One
    good approach is to define a function to read lines from a file, and use `json.loads()`
    to transform the line of text into a small dictionary of useful data.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: There’s no compelling reason to use the `model` module’s class definitions for
    this inspection. The class definitions can help to make the data somewhat more
    accessible.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: The inspection process starts with cells that name the files, creating `Path`
    objects.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'A function code like the following example might be helpful:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This function will iterate over the acquired data. In many cases, we can use
    the iterator to scan through a large collection of samples, picking individual
    attribute values or some subset of the samples.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the following statement to create a list-of-dictionary structure
    from the given path:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We can start with these basics in a few cells of the notebook. Given this foundation,
    further cells can explore the available data.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Cells and functions to analyze data
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For this initial inspection project, the analysis requirements are small. The
    example datasets from the previous chapters are artificial data, designed to demonstrate
    the need to use graphical techniques for exploratory data analysis.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: For other datasets, however, there may be a variety of odd or unusual problems.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the **CO****2** **PPM — Trends in Atmospheric Carbon** **Dioxide**
    dataset, available at [https://datahub.io/core/co2-ppm](https://datahub.io/core/co2-ppm),
    has a number of ”missing value” codes in the data. Here are two examples:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: The CO2 average values sometimes have values of −99*.*99 as a placeholder for
    a time when a measurement wasn’t available. In these cases, a statistical process
    used data from adjacent months to interpolate the missing value.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, the number of days of valid data for a month’s summary wasn’t
    recorded, and a −1 value is used.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This dataset requires a bit more care to be sure of the values in each column
    and what the columns mean.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Capturing the domain of values in a given column is helpful here. The `collections`
    module has a `Counter` object that’s ideal for understanding the data in a specific
    column.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'A cell can use a three-step computation to see the domain of values:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Use the `samples_iter()` function to yield the source documents.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a generator with sample attribute values.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `Counter` to summarize the values.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This can lead to a cell in the notebook with the following statements:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The next cell in the notebook can display the value of the `domain_x` value.
    If the `csv.reader()` function is used, it will reveal the header along with the
    domain of values. If the `csv.DictReader()` class is used, this collection will
    not include the header. This permits a tidy exploration of the various attributes
    in the collection of samples.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'An inspection notebook is not the place to attempt more sophisticated data
    analysis. Computing means or medians should only be done on cleaned data. We’ll
    return to this in [*Chapter** 15*](ch019.xhtml#x1-32500015), [*Project 5.1: Modeling
    Base* *Application*](ch019.xhtml#x1-32500015).'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Cells with Markdown to explain things
  id: totrans-145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It’s very helpful to include cells using Markdown to provide information, insights,
    and lessons learned about the data.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'For information on the markdown language, see the Daring Fireball website:
    [https://daringfireball.net/projects/markdown/basics](https://daringfireball.net/projects/markdown/basics).'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'As noted earlier in this chapter, there are two general flavors of notebooks:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '**Exploratory**: These notebooks are a series of blog posts about the data
    and the process of exploring and inspecting the data. Cells may not all work because
    they’re works in process.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Presentation**: These notebooks are a more polished, final report on data
    or problems. The paths that lead to dead ends should be pruned into summaries
    of the lessons learned.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A bright line separates these two flavors of notebooks. The distinguishing factor
    is the reproducibility of the notebook. A notebook that’s useful for presentations
    can be run from beginning to end without manual intervention to fix problems or
    skip over cells with syntax errors or other problems. Otherwise, the notebook
    is part of an exploration. It’s often necessary to copy and edit an exploratory
    notebook to create a derived notebook focused on presentation.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally, a notebook designed for a presentation uses Markdown cells to create
    a narrative flow that looks like any chapter of a book or article in a journal.
    We’ll return to more formal reporting in [*Chapter** 14*](ch018.xhtml#x1-31300014),
    [*Project 4.2: Creating* *Reports*](ch018.xhtml#x1-31300014).'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Cells with test cases
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Earlier, we introduced a `samples_iter()` function that lacked any unit tests
    or examples. It’s considerably more helpful to provide a **doctest** string within
    a notebook:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This function’s docstrings include an extensive test case. The test case builds
    an NDJSON document from a list of two dictionaries. The test case then applies
    the `samples_iter()` function to parse the NDJSON file and recover the original
    two samples.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'To execute this test, the notebook needs a cell to examine the docstrings in
    all of the functions and classes defined in the notebook:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This works because the global context for a notebook is treated like a module
    with a default name of `__main__`. This module will be examined by the `textmod()`
    function to find docstrings that look like they contain doc test examples.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Having the last cell run the **doctest** tool makes it easy to run the notebook,
    scroll to the end, and confirm the tests have all passed. This is an excellent
    form of validation.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 6.3.2 Executing a notebook’s test suite
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A Jupyter notebook is inherently interactive. This makes an automated acceptance
    test of a notebook potentially challenging.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, there’s a command that executes a notebook to confirm it works
    all the way through without problems.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the following command to execute a notebook to confirm that all
    the cells will execute without any errors:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: A notebook may ingest a great deal of data, making it very time-consuming to
    test the notebook as a whole. This can lead to using a cell to read a configuration
    file and using this information to use a subset of data for test purposes.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 6.4 Summary
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter’s project covered the basics of creating and using a Jupyter Lab
    notebook for data inspection. This permits tremendous flexibility, something often
    required when looking at new data for the first time.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: We also looked at adding **doctest** examples to functions and running the **doctest**
    tool in the last cell of a notebook. This lets us validate that the code in the
    notebook is very likely to work properly.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve got an initial inspection notebook, we can start to consider
    the specific kinds of data being acquired. In the next chapter, we’ll add features
    to this notebook.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 6.5 Extras
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here are some ideas for you to add to this project.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 6.5.1 Use pandas to examine data
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A common tool for interactive data exploration is the `pandas` package.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: See [https://pandas.pydata.org](https://pandas.pydata.org) for more information.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Also, see [https://www.packtpub.com/product/learning-pandas/9781783985128](https://www.packtpub.com/product/learning-pandas/9781783985128)
    for resources for learning more about pandas.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: The value of using pandas for examining text may be limited. The real value
    of pandas is for doing more sophisticated statistical and graphical analysis of
    the data.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: We encourage you to load NDJSON documents using pandas and do some preliminary
    investigation of the data values.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
