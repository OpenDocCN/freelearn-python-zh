- en: Chapter 10. Web Development Done Right
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章. 正确进行网络开发
- en: '|   | *"Don''t believe everything you read on the Web."* |   |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|   | *"不要相信你在网上看到的一切。"|   |'
- en: '|   | --*Confucius* |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|   | --*孔子* |'
- en: In this chapter, we're going to work on a website together. By working on a
    small project, my aim is to open a window for you to take a peek on what web development
    is, along with the main concepts and tools you should know if you want to be successful
    with it.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将一起制作一个网站。通过一个小项目，我的目标是为你打开一扇窗户，让你窥视一下网络开发是什么，以及如果你想要成功地进行网络开发，你应该了解的主要概念和工具。
- en: What is the Web?
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是网络？
- en: The **World Wide Web**, or simply **Web**, is a way of accessing information
    through the use of a medium called the **Internet**. The Internet is a huge network
    of networks, a networking infrastructure. Its purpose is to connect billions of
    devices together, all around the globe, so that they can communicate with one
    another. Information travels through the Internet in a rich variety of languages
    called **protocols**, which allow different devices to speak the same tongue in
    order to share content.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '**万维网**，或简称**Web**，是通过使用称为**互联网**的媒介来访问信息的一种方式。互联网是一个巨大的网络网络，是一个网络基础设施。它的目的是连接全球数十亿设备，以便它们可以相互通信。信息通过称为**协议**的丰富语言在互联网中传输，这些协议允许不同的设备使用相同的语言来共享内容。'
- en: 'The Web is an information-sharing model, built on top of the Internet, which
    employs the **Hypertext Transfer Protocol** (**HTTP**) as a basis for data communication.
    The Web, therefore, is just one of the several different ways information can
    be exchanged over the Internet: e-mail, instant messaging, news groups, and so
    on, they all rely on different protocols.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 网络是一种基于互联网的信息共享模型，它使用**超文本传输协议**（**HTTP**）作为数据通信的基础。因此，网络只是互联网上信息交换的几种不同方式之一：电子邮件、即时消息、新闻组等等，它们都依赖于不同的协议。
- en: How does the Web work?
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络是如何工作的？
- en: 'In a nutshell, HTTP is an asymmetric **request-response** **client-server**
    protocol. An HTTP client sends a request message to an HTTP server. The server,
    in turn, returns a response message. In other words, HTTP is a **pull protocol**
    in which the client pulls information from the server (as opposed to a **push
    protocol** in which the server pushes information down to the client). Take a
    look at the following image:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，HTTP是一种**请求-响应**的**客户端-服务器**协议。HTTP客户端向HTTP服务器发送请求消息。服务器反过来返回响应消息。换句话说，HTTP是一种**拉协议**，客户端从服务器拉取信息（与**推协议**相对，服务器将信息推送到客户端）。看看下面的图片：
- en: '![How does the Web work?](img/4715_10_01.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![网络是如何工作的？](img/4715_10_01.jpg)'
- en: HTTP is based on **TCP/IP** (**Transmission Control Protocol/Internet Protocol**),
    which provides the tools for a reliable communication exchange.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP基于**TCP/IP**（**传输控制协议/互联网协议**），它提供了可靠通信交换的工具。
- en: An important feature of the HTTP protocol is that it's *stateless*. This means
    that the current request has no knowledge about what happened in previous requests.
    This is a limitation, but you can browse a website with the illusion of being
    logged in. Under the covers though, what happens is that, on login, a token of
    user information is saved (most often on the client side, in special files called
    **cookies**) so that each request the user makes carries the means for the server
    to recognize the user and provide a custom interface by showing their name, keeping
    their basket populated, and so on.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP协议的一个重要特性是它是**无状态的**。这意味着当前请求不知道之前请求发生了什么。这是一个限制，但你可以在登录的错觉下浏览网站。然而，在幕后发生的是，在登录时，用户信息的令牌被保存（通常在客户端，在称为**cookies**的特殊文件中），这样用户发出的每个请求都携带了服务器识别用户并提供定制界面的手段，比如显示他们的名字，保持购物车内容，等等。
- en: Even though it's very interesting, we're not going to delve into the rich details
    of HTTP and how it works. However, we're going to write a small website, which
    means we'll have to write the code to handle HTTP requests and return HTTP responses.
    I won't keep prepending HTTP to the terms *request* and *response* from now on,
    as I trust there won't be any confusion.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这非常有趣，我们不会深入探讨HTTP的丰富细节以及它是如何工作的。然而，我们将编写一个小的网站，这意味着我们需要编写处理HTTP请求和返回HTTP响应的代码。从现在起，我不会再在*请求*和*响应*这些术语前加上HTTP，因为我相信不会产生任何混淆。
- en: The Django web framework
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Django网络框架
- en: 'For our project, we''re going to use one of the most popular web frameworks
    you can find in the Python ecosystem: Django.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的项目，我们将使用Python生态系统中最受欢迎的Web框架之一：Django。
- en: A **web framework** is a set of tools (libraries, functions, classes, and so
    on) that we can use to code a website. We need to decide what kind of requests
    we want to allow to be issued against our web server and how we respond to them.
    A web framework is the perfect tool to do that because it takes care of many things
    for us so that we can concentrate only on the important bits without having to
    reinvent the wheel.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**Web框架**是一组工具（库、函数、类等），我们可以使用它们来编写网站。我们需要决定我们希望允许对Web服务器发出哪些类型的请求，以及我们如何响应它们。Web框架是完成这项任务的完美工具，因为它为我们处理了许多事情，使我们能够专注于重要部分，而无需重新发明轮子。'
- en: Note
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There are different types of frameworks. Not all of them are designed for writing
    code for the web. In general, a **framework** is a tool that provides functionalities
    to facilitate the development of software applications, products and solutions.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 存在着不同类型的框架。并非所有框架都是为编写Web代码而设计的。一般来说，**框架**是一种提供功能以简化软件开发、产品和服务解决方案开发的工具。
- en: Django design philosophy
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Django设计哲学
- en: 'Django is designed according to the following principles:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Django的设计遵循以下原则：
- en: '**DRY**: As in, **Don''t Repeat Yourself**. Don''t repeat code, and code in
    a way that makes the framework deduce as much as possible from as little as possible.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DRY**：即“不要重复自己”。不要重复代码，并以一种让框架尽可能从尽可能少的代码中推断出尽可能多的内容的方式进行编码。'
- en: '**Loose coupling**: The various layers of the framework shouldn''t know about
    each other (unless absolutely necessary for whatever reason). Loose coupling works
    best when paralleled with high cohesion. To quote Robert Martin: putting together
    things which change for the same reason, and spreading apart those which change
    for different reasons.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**松耦合**：框架的各个层不应该相互了解（除非在绝对必要时）。松耦合与高内聚并行时效果最佳。用罗伯特·马丁的话来说：将因同一原因而改变的事物放在一起，将因不同原因而改变的事物分开。'
- en: '**Less code**: Applications should use the least possible amount of code, and
    be written in a way that favors reuse as much as possible.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**少代码**：应用程序应使用尽可能少的代码，并以尽可能多的方式促进重用。'
- en: '**Consistency**: When using the Django framework, regardless of which layer
    you''re coding against, your experience will be very consistent with the design
    patterns and paradigms that were chosen to lay out the project.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性**：在使用Django框架时，无论你针对哪一层进行编码，你的体验都将与用于构建项目的选定的设计模式和范式非常一致。'
- en: The framework itself is designed around the **model-template-view** (**MTV**)
    pattern, which is a variant of **model-view-controller** (**MVC**), which is widely
    employed by other frameworks. The purpose of such patterns is to separate concerns
    and promote code reuse and quality.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 框架本身是围绕**模型-模板-视图**（**MTV**）模式设计的，这是**模型-视图-控制器**（**MVC**）的变体，其他框架广泛采用这种模式。这种模式的目的在于分离关注点，促进代码重用和质量提升。
- en: The model layer
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模型层
- en: Of the three layers, this is the one that defines the structure of the data
    that is handled by the application, and deals with data sources. A **model** is
    a class that represents a data structure. Through some Django magic, models are
    mapped to database tables so that you can store your data in a relational database.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这三个层次中，这是定义应用程序处理的数据结构的层次，并处理数据源。**模型**是一个表示数据结构的类。通过一些Django魔法，模型被映射到数据库表，这样你就可以在关系数据库中存储你的数据。
- en: Note
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A **relational database** stores data in tables in which each column is a property
    of the data and each row represents a single item or entry in the collection represented
    by that table. Through the **primary key** of each table, which is that part of
    the data that allows to uniquely identify each item, it is possible to establish
    relationships between items belonging to different tables, that is, to put them
    into *relation*.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**关系数据库**将数据存储在表中，其中每一列是数据的属性，每一行代表该表所表示的集合中的单个项目或条目。通过每个表的**主键**，即允许唯一标识每个项目的数据部分，可以建立属于不同表的项目之间的关系，即将它们放入*关系*中。'
- en: 'The beauty of this system is that you don''t have to write database-specific
    code in order to handle your data. You will just have to configure your models
    correctly and simply use them. The work on the database is done for you by the
    Django **object-relational mapping** (**ORM**), which takes care of translating
    operations done on Python objects into a language that a relational database can
    understand: **SQL** (**Structured Query Language**).'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这个系统的美在于，你不需要编写特定于数据库的代码来处理你的数据。你只需正确配置你的模型并简单地使用它们。数据库的工作将由 Django 的 **对象关系映射**（**ORM**）为你完成，它负责将针对
    Python 对象执行的操作转换为关系数据库可以理解的语言：**SQL**（**结构化查询语言**）。
- en: One benefit of this approach is that you will be able to change databases without
    rewriting your code since all the database specific code is produced by Django
    on the fly, according to which database it's connected to. Relational databases
    speak SQL, but each of them has its own unique flavor of it; therefore, not having
    to hardcode any SQL in our application is a tremendous advantage.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个好处是，你将能够更改数据库而无需重写代码，因为所有特定于数据库的代码都是由 Django 在运行时根据连接的数据库自动生成的。关系数据库使用
    SQL，但每个数据库都有其独特的风味；因此，在我们的应用程序中不需要硬编码任何 SQL 是一个巨大的优势。
- en: Django allows you to modify your models at any time. When you do, you can run
    a command that creates a migration, which is the set of instructions needed to
    port the database in a state that represents the current definition of your models.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Django 允许你在任何时候修改你的模型。当你这样做时，你可以运行一个创建迁移的命令，迁移是一组指令，用于将数据库转换为表示你模型当前定义的状态。
- en: To summarize, this layer deals with defining the data structures you need to
    handle in your website and gives you the means to save and load them from and
    to the database by simply accessing the models, which are Python objects.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，这一层负责定义你在网站中需要处理的数据结构，并为你提供通过访问模型（Python 对象）来简单地从数据库中保存和加载它们的手段。
- en: The view layer
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 视图层
- en: The function of a view is handling a request, performing whatever action needs
    to be carried out, and eventually returning a response. For example, if you open
    your browser and request a page corresponding to a category of products in an
    e-commerce shop, the view will likely talk to the database, asking for all the
    categories that are children of the selected category (for example, to display
    them in a navigation sidebar) and for all the products that belong to the selected
    category, in order to display them on the page.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 视图的功能是处理请求，执行需要执行的操作，并最终返回响应。例如，如果你打开浏览器并请求一个电子商务商店中某个产品类别的页面，视图可能会与数据库通信，请求所有属于所选类别的子类别（例如，在导航侧边栏中显示它们）以及所有属于所选类别的产品，以便在页面上显示它们。
- en: 'Therefore, the view is the mechanism through which we can fulfill a request.
    Its result, the response object, can assume several different forms: a JSON payload,
    text, an HTML page, and so on. When you code a website, your responses usually
    consist of HTML or JSON.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，视图是我们满足请求的机制。其结果，响应对象，可以采取多种不同的形式：JSON 有效负载、文本、HTML 页面等。当你编写网站时，你的响应通常由 HTML
    或 JSON 组成。
- en: Note
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The **Hypertext Markup Language**, or **HTML**, is the standard markup language
    used to create web pages. Web browsers run engines that are capable of interpreting
    HTML code and render it into what we see when we open a page of a website.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**超文本标记语言**（**HTML**）是创建网页的标准标记语言。网络浏览器运行能够解释 HTML 代码并将其渲染为我们打开网站页面时所看到的内容的引擎。'
- en: The template layer
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模板层
- en: This is the layer that provides the bridge between backend and frontend development.
    When a view has to return HTML, it usually does it by preparing a **context object**
    (a dict) with some data, and then it feeds this context to a template, which is
    rendered (that is to say, transformed into HTML) and returned to the caller in
    the form of a response (more precisely, the body of the response). This mechanism
    allows for maximum code reuse. If you go back to the category example, it's easy
    to see that, if you browse a website that sells products, it doesn't really matter
    which category you click on or what type of search you perform, the layout of
    the products page doesn't change. What does change is the data with which that
    page is populated.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这是提供后端和前端开发之间桥梁的层。当一个视图需要返回HTML时，它通常通过准备一个**上下文对象**（一个字典）和一些数据来实现，然后将这个上下文传递给模板，模板被渲染（也就是说，转换成HTML）并作为响应（更准确地说，响应体）返回给调用者。这种机制允许最大程度地重用代码。如果你回到分类的例子，很容易看出，如果你浏览一个销售产品的网站，你点击哪个分类或者执行什么类型的搜索，产品页面的布局实际上并没有改变。真正改变的是填充该页面的数据。
- en: Therefore, the layout of the page is defined by a template, which is written
    in a mixture of HTML and Django template language. The view that serves that page
    collects all the products to be displayed in the context dict, and feeds it to
    the template which will be rendered into an HTML page by the Django template engine.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，页面的布局是由一个模板定义的，这个模板是用HTML和Django模板语言混合编写的。服务于该页面的视图收集所有要显示在上下文字典中的产品，并将其传递给模板，由Django模板引擎将其渲染成HTML页面。
- en: The Django URL dispatcher
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Django URL分发器
- en: The way Django associates a **Uniform Resource Locator** (**URL**) with a view
    is through matching the requested URL with the patterns that are registered in
    a special file. A URL represents a page in a website so, for example, `http://mysite.com/categories?id=123`
    would probably point to the page for the category with ID `123` on my website,
    while `https://mysite.com/login` would probably be the user login page.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Django通过将请求的URL与注册在特殊文件中的模式进行匹配来关联**统一资源定位符**（**URL**）与视图。一个URL代表网站中的一个页面，例如，`http://mysite.com/categories?id=123`可能指向我的网站上ID为`123`的分类页面，而`https://mysite.com/login`可能指向用户登录页面。
- en: Tip
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The difference between HTTP and HTTPS is that the latter adds encryption to
    the protocol so that the data that you exchange with the website is secured. When
    you put your credit card details on a website, or log in anywhere, or do anything
    around sensitive data, you want to make sure that you're using HTTPS.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP和HTTPS之间的区别在于后者在协议中添加了加密，以确保你与网站交换的数据是安全的。当你在一个网站上输入信用卡信息，或者在任何地方登录，或者处理敏感数据时，你想要确保你正在使用HTTPS。
- en: Regular expressions
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 正则表达式
- en: The way Django matches URLs to patterns is through a regular expression. A **regular
    expression** is a sequence of characters that defines a search pattern with which
    we can carry out operations such as pattern and string matching, find/replace,
    and so on.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Django通过正则表达式匹配URL到模式。**正则表达式**是一系列字符，它定义了一个搜索模式，我们可以用它执行模式匹配、字符串替换等操作。
- en: Regular expressions have a special syntax to indicate things like digits, letters,
    spaces, and so on, as well as how many times we expect a character to appear,
    and much more. A complete explanation of this topic is beyond of the scope of
    the book. However, it is a very important topic, so the project we're going to
    work on together will evolve around it, in the hope that you will be stimulated
    to find the time to explore it a bit more on your own.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式具有特殊的语法来表示数字、字母、空格等，以及我们期望字符出现的次数等，还有更多。关于这个主题的完整解释超出了本书的范围。然而，这是一个非常重要的主题，因此我们将一起工作的项目将围绕它展开，希望这能激发你抽出时间自己进一步探索。
- en: 'To give you a quick example, imagine that you wanted to specify a pattern to
    match a date such as `"26-12-1947"`. This string consists of two digits, one dash,
    two digits, one dash, and finally four digits. Therefore, we could write it like
    this: `r''[0-9]{2}-[0-9]{2}-[0-9]{4}''`. We created a class by using square brackets,
    and we defined a range of digits inside, from 0 to 9, hence all the possible digits.
    Then, between curly braces, we say that we expect two of them. Then a dash, then
    we repeat this pattern once as it is, and once more, by changing how many digits
    we expect, and without the final dash. Having a class like `[0-9]` is such a common
    pattern that a special notation has been created as a shortcut: `''\d''`. Therefore,
    we can rewrite the pattern like this: `r''\d{2}-\d{2}-\d{4}''` and it will work
    exactly the same. That `r` in front of the string stands for *raw*, and its purpose
    is to alter the way every backslash `''\''` is interpreted by the regular expression
    engine.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给你一个快速示例，想象一下你想要指定一个匹配日期模式，比如`"26-12-1947"`。这个字符串由两个数字、一个破折号、两个数字、一个破折号和最后四个数字组成。因此，我们可以写成这样：`r'[0-9]{2}-[0-9]{2}-[0-9]{4}'`。我们通过使用方括号创建了一个类，并在其中定义了从0到9的数字范围，因此包含了所有可能的数字。然后，在大括号中，我们说我们期望有两个这样的数字。然后是一个破折号，然后我们重复这个模式一次，然后再次，通过改变我们期望的数字数量，并且不包含最后的破折号。像`[0-9]`这样的类是一个非常常见的模式，因此已经创建了一个特殊的表示法作为快捷方式：`'\d'`。因此，我们可以将模式重写为`r'\d{2}-\d{2}-\d{4}'`，它将工作得完全一样。字符串前面的`r`代表*原始的*，它的目的是改变正则表达式引擎解释每个反斜杠`\'`的方式。
- en: A regex website
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个正则表达式网站
- en: So, here we are. We'll code a website that stores regular expressions so that
    we'll be able to play with them a little bit.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们现在在这里。我们将编写一个网站，用来存储正则表达式，这样我们就可以稍微玩玩它们。
- en: Note
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Before we proceed creating the project, I'd like to spend a word about CSS.
    **CSS** (**Cascading Style Sheets**) are files in which we specify how the various
    elements on an HTML page look. You can set all sorts of properties such as shape,
    size, color, margins, borders, fonts, and so on. In this project, I have tried
    my best to achieve a decent result on the pages, but I'm neither a frontend developer
    nor a designer, so please don't pay too much attention to how things look. Try
    and focus on how they work.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始创建项目之前，我想说几句关于CSS的话。**CSS**（**层叠样式表**）是包含我们指定HTML页面上各种元素外观的文件。你可以设置各种属性，如形状、大小、颜色、边距、边框、字体等。在这个项目中，我已经尽力让页面看起来不错，但
    neither a frontend developer nor a designer，所以请不要过于关注外观。试着关注它们是如何工作的。
- en: Setting up Django
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置Django
- en: 'On the Django website ([https://www.djangoproject.com/](https://www.djangoproject.com/)),
    you can follow the tutorial, which gives you a pretty good idea of Django''s capabilities.
    If you want, you can follow that tutorial first and then come back to this example.
    So, first things first; let''s install Django in your virtual environment:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在Django网站([https://www.djangoproject.com/](https://www.djangoproject.com/))上，你可以跟随教程，它给你一个相当不错的Django功能介绍。如果你想的话，可以先跟随那个教程，然后再回到这个例子。所以，首先的事情是；让我们在你的虚拟环境中安装Django：
- en: '[PRE0]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When this command is done, you can test it within a console (try doing it with
    bpython, it gives you a shell similar to IPython but with nice introspection capabilities):'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个命令完成后，你可以在控制台中测试它（尝试使用bpython，它给你一个类似于IPython的shell，但具有很好的内省能力）：
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now that Django is installed, we're good to go. We'll have to do some scaffolding,
    so I'll quickly guide you through that.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Django已经安装好了，我们可以开始了。我们得做一些脚手架，所以我会快速带你过一遍。
- en: Starting the project
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开始项目
- en: 'Choose a folder in the book''s environment and change into that. I''ll use
    `ch10`. From there, we start a Django project with the following command:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在书籍的环境中选一个文件夹并切换到那里。我会使用`ch10`。从那里，我们使用以下命令开始一个Django项目：
- en: '[PRE2]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This will prepare the skeleton for a Django project called `regex`. Change
    into the `regex` folder and run the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为名为`regex`的Django项目准备骨架。切换到`regex`文件夹并运行以下命令：
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You should be able to go to `http://127.0.0.1:8000/` with your browser and
    see the *It worked!* default Django page. This means that the project is correctly
    set up. When you''ve seen the page, kill the server with *Ctrl* + *C* (or whatever
    it says in the console). I''ll paste the final structure for the project now so
    that you can use it as a reference:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能够用浏览器访问`http://127.0.0.1:8000/`并看到默认的Django页面*It worked!*。这意味着项目已经正确设置。当你看到这个页面后，用*Ctrl*
    + *C*（或者在控制台里显示的任何内容）关闭服务器。我现在会粘贴项目的最终结构，这样你可以作为参考使用：
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Don''t worry if you''re missing files, we''ll get there. A Django project is
    typically a collection of several different applications. Each application is
    meant to provide a functionality in a self-contained, reusable fashion. We''ll
    create just one, called **entries**:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果缺少文件，不要担心，我们会解决的。一个Django项目通常是一组几个不同的应用程序。每个应用程序都旨在以自包含、可重用的方式提供功能。我们将创建一个，称为**entries**：
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Within the `entries` folder that has been created, you can get rid of the `tests.py`
    module.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建的`entries`文件夹中，你可以删除`tests.py`模块。
- en: 'Now, let''s fix the `regex/settings.py` file in the `regex` folder. We need
    to add our application to the `INSTALLED_APPS` tuple so that we can use it (add
    it at the bottom of the tuple):'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们修复`regex`文件夹中的`regex/settings.py`文件。我们需要将我们的应用程序添加到`INSTALLED_APPS`元组中，以便我们可以使用它（将其添加到元组的底部）：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, you may want to fix the language and time zone according to your personal
    preference. I live in London, so I set them like this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可能想根据个人喜好设置语言和时间区。我住在伦敦，所以我设置了如下：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: There is nothing else to do in this file, so you can save and close it.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中没有其他要做的，所以你可以保存并关闭它。
- en: 'Now it''s time to apply the **migrations** to the database. Django needs database
    support to handle users, sessions, and things like that, so we need to create
    a database and populate it with the necessary data. Luckily, this is very easily
    done with the following command:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候将**迁移**应用到数据库上了。Django需要数据库支持来处理用户、会话等，因此我们需要创建一个数据库并用必要的数据填充它。幸运的是，这可以通过以下命令轻松完成：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For this project, we use a SQLite database, which is basically just a file.
    On a real project, you would probably use a different database engine like MySQL
    or PostgreSQL.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，我们使用SQLite数据库，它基本上就是一个文件。在实际项目中，你可能使用不同的数据库引擎，如MySQL或PostgreSQL。
- en: Creating users
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建用户
- en: Now that we have a database, we can create a superuser using the console.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了数据库，我们可以使用控制台创建一个超级用户。
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'After entering username and other details, we have a user with admin privileges.
    This is enough to access the Django admin section, so try and start the server:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 输入用户名和其他详细信息后，我们就有一个具有管理员权限的用户。这足以访问Django管理部分，所以尝试启动服务器：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This will start the Django development server, which is a very useful built-in
    web server that you can use while working with Django. Now that the server is
    running, we can access the admin page at `http://localhost:8000/admin/`. I will
    show you a screenshot of this section later. If you log in with the credentials
    of the user you just created and head to the **Authentication and Authorization**
    section, you''ll find **Users**. Open that and you will be able to see the list
    of users. You can edit the details of any user you want as an admin. In our case,
    make sure you create a different one so that there are at least two users in the
    system (we''ll need them later). I''ll call the first user *Fabrizio* (username:
    `fab`) and the second one *Adriano* (username: `adri`) in honor of my father.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动Django开发服务器，这是一个非常有用的内置Web服务器，你可以在使用Django时使用它。现在服务器正在运行，我们可以访问`http://localhost:8000/admin/`上的管理页面。我稍后会展示这个部分的截图。如果你使用你刚刚创建的用户凭据登录并转到**认证和授权**部分，你会找到**用户**。打开它，你将能够看到用户列表。作为管理员，你可以编辑任何用户的详细信息。在我们的情况下，确保你创建一个不同的用户，以便系统中至少有两个用户（我们稍后会用到他们）。我将第一个用户称为*Fabrizio*（用户名：`fab`），第二个用户称为*Adriano*（用户名：`adri`），以纪念我的父亲。
- en: By the way, you should see that the Django admin panel comes for free automatically.
    You define your models, hook them up, and that's it. This is an incredible tool
    that shows how advanced Django's introspection capabilities are. Moreover, it
    is completely customizable and extendable. It's truly an excellent piece of work.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，你应该会看到Django管理面板是自动免费提供的。你定义模型，将它们连接起来，就完成了。这是一个非常出色的工具，展示了Django的反射能力是多么先进。此外，它是完全可定制和可扩展的。这确实是一件优秀的工作。
- en: Adding the Entry model
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加Entry模型
- en: 'Now that the boilerplate is out of the way, and we have a couple of users,
    we''re ready to code. We start by adding the `Entry` model to our application
    so that we can store objects in the database. Here''s the code you''ll need to
    add (remember to use the project tree for reference):'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在样板文件已经处理完毕，我们也有一两个用户，我们可以开始编码了。我们首先将`Entry`模型添加到我们的应用程序中，以便我们可以在数据库中存储对象。以下是你需要添加的代码（记得使用项目树作为参考）：
- en: '`entries/models.py`'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`entries/models.py`'
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is the model we'll use to store regular expressions in our system. We'll
    store a pattern, a test string, a reference to the user who created the entry,
    and the moment of creation. You can see that creating a model is actually quite
    easy, but nonetheless, let's go through it line by line.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将在系统中存储正则表达式的模型。我们将存储一个模式、一个测试字符串、创建条目的用户引用以及创建时刻。你可以看到创建一个模型实际上相当简单，但无论如何，让我们逐行过一遍。
- en: First we need to import the models module from `django.db`. This will give us
    the base class for our `Entry` model. Django models are special classes and much
    is done for us behind the scenes when we inherit from `models.Model`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要从`django.db`导入`models`模块。这将为我们提供`Entry`模型的基类。Django模型是特殊的类，当我们从`models.Model`继承时，幕后会为我们做很多事情。
- en: We want a reference to the user who created the entry, so we need to import
    the `User` model from Django's authorization application and we also need to import
    the timezone model to get access to the `timezone.now()` function, which provides
    us with a timezone-aware version of `datetime.now()`. The beauty of this is that
    it's hooked up with the `TIME_ZONE` settings I showed you before.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要一个指向创建条目的用户的引用，因此我们需要从Django的授权应用程序中导入`User`模型，并且我们还需要导入时区模型以获取对`timezone.now()`函数的访问权限，该函数为我们提供了一个对`datetime.now()`的时区感知版本。它的美妙之处在于它与之前向您展示的`TIME_ZONE`设置相连。
- en: As for the primary key for this class, if we don't set one explicitly, Django
    will add one for us. A **primary key** is a key that allows us to uniquely identify
    an `Entry` object in the database (in this case, Django will add an auto-incrementing
    integer ID).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个类的主键，如果我们没有明确设置一个，Django会为我们添加一个。**主键**是一个允许我们在数据库中唯一标识一个`Entry`对象（在这种情况下，Django将添加一个自动递增的整数ID）的键。
- en: So, we define our class, and we set up four class attributes. We have a `ForeignKey`
    attribute that is our reference to the *User* model. We also have two `CharField`
    attributes that hold the pattern and test strings for our regular expressions.
    We also have a `DateTimeField,` whose default value is set to `timezone.now`.
    Note that we don't call `timezone.now` right there, it's `now`, not `now()`. So,
    we're not passing a `DateTime` instance (set at the moment in time when that line
    is parsed) rather, we're passing a *callable*, a function that is called when
    we save an entry in the database. This is similar to the callback mechanism we
    used in [Chapter 8](ch08.html "Chapter 8. The Edges – GUIs and Scripts"), *The
    Edges – GUIs and Scripts*, when we were assigning commands to button clicks.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们定义我们的类，并设置四个类属性。我们有一个`ForeignKey`属性，它是我们指向`*User*`模型的引用。我们还有两个`CharField`属性，用于存储我们的正则表达式的模式和测试字符串。我们还有一个`DateTimeField`，其默认值设置为`timezone.now`。请注意，我们并没有在那里调用`timezone.now`，而是`now`，不是`now()`。因此，我们不是传递一个`DateTime`实例（在解析该行时设置的时间点），而是传递一个*可调用对象*，一个在我们在数据库中保存条目时被调用的函数。这与我们在[第8章](ch08.html
    "第8章。边缘 – GUI和脚本")中使用的回调机制类似，即当我们为按钮点击分配命令时。
- en: The last two lines are very interesting. We define a class `Meta` within the
    `Entry` class itself. The `Meta` class is used by Django to provide all sorts
    of extra information for a model. Django has a great deal of logic under the hood
    to adapt its behavior according to the information we put in the `Meta` class.
    In this case, in the admin panel, the pluralized version of `Entry` would be *Entrys*,
    which is wrong, therefore we need to manually set it. We specify the plural all
    lowercase, as Django takes care of capitalizing it for us when needed.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两行非常有趣。我们在`Entry`类本身中定义了一个名为`Meta`的类。`Meta`类被Django用于为模型提供各种额外信息。Django在其内部拥有大量的逻辑，根据我们在`Meta`类中放入的信息来调整其行为。在这种情况下，在管理面板中，`Entry`的复数形式应该是*Entrys*，这是错误的，因此我们需要手动设置它。我们指定复数全部小写，因为当需要时，Django会为我们将其大写。
- en: 'Now that we have a new model, we need to update the database to reflect the
    new state of the code. In order to do this, we need to instruct Django that it
    needs to create the code to update the database. This code is called **migration**.
    Let''s create it and execute it:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个新的模型，我们需要更新数据库以反映代码的新状态。为了做到这一点，我们需要指示Django它需要创建更新数据库的代码。这段代码被称为**迁移**。让我们创建它并执行它：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: After these two instructions, the database will be ready to store `Entry` objects.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个指令之后，数据库将准备好存储`Entry`对象。
- en: Note
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'There are two different kinds of migrations: data and schema migration. **Data
    migrations** port data from one state to another without altering its structure.
    For example, a data migration could set all products for a category as out of
    stock by switching a flag to `False` or `0`. A **schema migration** is a set of
    instructions that alter the structure of the database schema. For example, that
    could be adding an `age` column to a `Person` table, or increasing the maximum
    length of a field to account for very long addresses. When developing with Django,
    it''s quite common to have to perform both kinds of migrations over the course
    of development. Data evolves continuously, especially if you code in an agile
    environment.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移有两种不同类型：数据和模式迁移。**数据迁移**将数据从一个状态迁移到另一个状态，而不改变其结构。例如，数据迁移可以通过将标志切换为`False`或`0`来将某个类别的所有产品设置为缺货。**模式迁移**是一组改变数据库模式结构的指令。例如，这可能是向`Person`表添加一个`age`列，或者增加字段的长度以适应非常长的地址。在使用Django进行开发时，在整个开发过程中执行这两种类型的迁移是很常见的。数据持续演变，尤其是在敏捷环境中编码时。
- en: Customizing the admin panel
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定制管理面板
- en: The next step is to hook the `Entry` model up with the admin panel. You can
    do it with one line of code, but in this case, I want to add some options to customize
    a bit the way the admin panel shows the entries, both in the list view of all
    entry items in the database and in the form view that allows us to create and
    modify them.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将`Entry`模型与行政面板连接起来。你可以用一行代码完成，但在这个例子中，我想添加一些选项来定制行政面板显示条目的方式，无论是在数据库中所有条目项的列表视图中，还是在允许我们创建和修改它们的表单视图中。
- en: 'All we need to do is to add the following code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的只是添加以下代码：
- en: '`entries/admin.py`'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`entries/admin.py`'
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is simply beautiful. My guess is that you probably already understand most
    of it, even if you're new to Django.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这真是太美了。我猜你可能已经理解了大部分内容，即使你是Django的新手。
- en: So, we start by importing the admin module and the `Entry` model. Because we
    want to foster code reuse, we import the `Entry` model using a relative import
    (there's a dot before `models`). This will allow us to move or rename the app
    without too much trouble. Then, we define the `EntryAdmin` class, which inherits
    from `admin.ModelAdmin`. The decoration on the class tells Django to display the
    `Entry` model in the admin panel, and what we put in the `EntryAdmin` class tells
    Django how to customize the way it handles this model.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们首先导入admin模块和`Entry`模型。因为我们希望促进代码重用，所以我们使用相对导入（在`models`之前有一个点）。这将允许我们在不太多麻烦的情况下移动或重命名应用程序。然后，我们定义`EntryAdmin`类，它继承自`admin.ModelAdmin`。类上的装饰告诉Django在行政面板中显示`Entry`模型，而我们在`EntryAdmin`类中放入的内容告诉Django如何定制处理此模型的方式。
- en: Firstly, we specify the `fieldsets` for the create/edit page. This will divide
    the page into two sections so that we get a better visualization of the content
    (*pattern* and *test string*) and the other details (*user* and *timestamp*) separately.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们指定创建/编辑页面的`fieldsets`。这将把页面分成两个部分，以便我们更好地分别可视化内容（*模式*和*测试字符串*）和其他细节（*用户*和*时间戳*）。
- en: Then, we customize the way the list page displays the results. We want to see
    all the fields, but not the date. We also want to be able to filter on the user
    so that we can have a list of all the entries by just one user, and we want to
    be able to search on `test_string`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定制列表页面显示结果的方式。我们想看到所有字段，但不显示日期。我们还希望能够按用户过滤，以便我们能够只通过一个用户查看所有条目，并且我们希望能够在`test_string`上搜索。
- en: 'I will go ahead and add three entries, one for myself and two on behalf of
    my father. The result is shown in the next two images. After inserting them, the
    list page looks like this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我将继续添加三个条目，一个代表我自己，另外两个代表我的父亲。结果将在接下来的两张图片中展示。在插入它们之后，列表页面看起来是这样的：
- en: '![Customizing the admin panel](img/4715_10_02.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![定制管理面板](img/4715_10_02.jpg)'
- en: I have highlighted the three parts of this view that we customized in the `EntryAdmin`
    class. We can filter by user, we can search and we have all the fields displayed.
    If you click on a pattern, the edit view opens up.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经突出显示了在`EntryAdmin`类中我们定制的这个视图的三个部分。我们可以按用户过滤，可以搜索，并且显示所有字段。如果你点击一个模式，编辑视图就会打开。
- en: 'After our customization, it looks like this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们定制之后，它看起来是这样的：
- en: '![Customizing the admin panel](img/4715_10_03.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![定制管理面板](img/4715_10_03.jpg)'
- en: 'Notice how we have two sections: **Regular** **Expression** and **Other** **Information**,
    thanks to our custom `EntryAdmin` class. Have a go with it, add some entries to
    a couple of different users, get familiar with the interface. Isn''t it nice to
    have all this for free?'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们有两个部分：**正则表达式**和**其他信息**，这要归功于我们的自定义 `EntryAdmin` 类。试一试，为几个不同的用户添加一些条目，熟悉界面。所有这些都不需要付费，不是很好吗？
- en: Creating the form
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建表单
- en: Every time you fill in your details on a web page, you're inserting data in
    form fields. A **form** is a part of the **HTML Document Object Model** (**DOM**)
    **tree**. In HTML, you create a form by using the `form` tag. When you click on
    the submit button, your browser normally packs the form data together and puts
    it in the body of a `POST` request. As opposed to `GET` requests, which are used
    to ask the web server for a resource, a `POST` request normally sends data to
    the web server with the aim of creating or updating a resource. For this reason,
    handling `POST` requests usually requires more care than `GET` requests.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 每次你在网页上填写详细信息时，你都是在表单字段中插入数据。**表单**是**HTML 文档对象模型**（**DOM**）**树**的一部分。在 HTML
    中，你可以通过使用 `form` 标签来创建表单。当你点击提交按钮时，你的浏览器通常会打包表单数据并将其放入 `POST` 请求的主体中。与用于请求资源的
    `GET` 请求相反，`POST` 请求通常发送数据到 web 服务器，目的是创建或更新资源。因此，处理 `POST` 请求通常比处理 `GET` 请求需要更多的注意。
- en: When the server receives data from a `POST` request, that data needs to be validated.
    Moreover, the server needs to employ security mechanisms to protect against various
    types of attacks. One attack that is very dangerous is the **cross-site request
    forgery** (**CSRF**) attack, which happens when data is sent from a domain that
    is not the one the user is authenticated on. Django allows you to handle this
    issue in a very elegant way.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器从 `POST` 请求接收数据时，需要验证这些数据。此外，服务器需要采用安全机制来防止各种类型的攻击。一种非常危险的攻击是**跨站请求伪造**（**CSRF**）攻击，这种攻击发生在数据从一个用户未认证的域发送时。Django
    允许你以非常优雅的方式处理这个问题。
- en: So, instead of being lazy and using the Django admin to create the entries,
    I'm going to show you how to do it using a Django form. By using the tools the
    framework gives you, you get a very good degree of validation work already done
    (in fact, we won't need to add any custom validation ourselves).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，而不是懒惰地使用 Django 管理员来创建条目，我将向您展示如何使用 Django 表单来完成它。通过使用框架提供的工具，你已经完成了很多验证工作（实际上，我们不需要添加任何自定义验证）。
- en: 'There are two kinds of form classes in Django: `Form` and `ModelForm`. You
    use the former to create a form whose shape and behavior depends on how you code
    the class, what fields you add, and so on. On the other hand, the latter is a
    type of form that, albeit still customizable, infers fields and behavior from
    a model. Since we need a form for the `Entry` model, we''ll use that one.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Django 中有两种表单类：`Form` 和 `ModelForm`。你使用前者创建一个表单，其形状和行为取决于你如何编写类、添加哪些字段等。另一方面，后者是一种表单类型，尽管仍然可以自定义，但它从模型中推断字段和行为。由于我们需要为
    `Entry` 模型创建一个表单，我们将使用那个。
- en: '`entries/forms.py`'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`entries/forms.py`'
- en: '[PRE14]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Amazingly enough, this is all we have to do to have a form that we can put
    on a page. The only notable thing here is that we restrict the fields to only
    `pattern` and `test_string`. Only logged-in users will be allowed access to the
    insert page, and therefore we don''t need to ask who the user is: we know that.
    As for the date, when we save an `Entry,` the `date_added` field will be set according
    to its default, therefore we don''t need to specify that as well. We''ll see in
    the view how to feed the user information to the form before saving. So, all the
    background work is done, all we need is the views and the templates. Let''s start
    with the views.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，我们只需要做这些就能拥有一个可以放在页面上的表单。这里唯一值得注意的是，我们只限制了字段为 `pattern` 和 `test_string`。只有登录用户将被允许访问插入页面，因此我们不需要询问用户是谁：我们知道。至于日期，当我们保存
    `Entry` 时，`date_added` 字段将根据其默认值设置，因此我们也不需要指定它。我们将在视图中看到如何在保存之前将用户信息传递给表单。所以，所有背景工作都已经完成，我们需要的只是视图和模板。让我们从视图开始。
- en: Writing the views
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写视图
- en: We need to write three views. We need one for the home page, one to display
    the list of all entries for a user, and one to create a new entry. We also need
    views to log in and log out. But thanks to Django, we don't need to write them.
    I'll paste all the code, and then we'll go through it together, step by step.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要编写三个视图。我们需要一个用于主页的视图，一个用于显示用户所有条目的列表，一个用于创建新条目。我们还需要登录和注销的视图。但是，多亏了Django，我们不需要编写它们。我将粘贴所有代码，然后我们一步一步地过一遍。
- en: '`entries/views.py`'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`entries/views.py`'
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Let's start with the imports. We need the `re` module to handle regular expressions,
    then we need a few classes and functions from Django, and finally, we need the
    `Entry` model and the `EntryForm` form.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从导入开始。我们需要`re`模块来处理正则表达式，然后我们需要从Django中获取几个类和函数，最后，我们需要`Entry`模型和`EntryForm`表单。
- en: The home view
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 主页视图
- en: The first view is `HomeView`. It inherits from `TemplateView`, which means that
    the response will be created by rendering a template with the context we'll create
    in the view. All we have to do is specify the `template_name` class attribute
    to point to the correct template. Django promotes code reuse to a point that if
    we didn't need to make this view accessible only to logged-in users, the first
    two lines would have been all we needed.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个视图是`HomeView`。它继承自`TemplateView`，这意味着响应将通过渲染我们在视图中创建的上下文模板来创建。我们唯一需要做的是指定`template_name`类属性，使其指向正确的模板。Django推崇代码重用，如果我们不需要使这个视图仅对已登录用户可用，那么前两行代码就足够了。
- en: 'However, we want this view to be accessible only to logged-in users; therefore,
    we need to decorate it with `login_required`. Now, historically views in Django
    used to be functions; therefore, this decorator was designed to accept a *function*
    not a *method* like we have in this class. We''re using Django class-based views
    in this project so, in order to make things work, we need to transform `login_required`
    so that it accepts a method (the difference being in the first argument: `self`).
    We do this by passing `login_required` to `method_decorator`.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们希望这个视图只能对已登录用户可用；因此，我们需要用`login_required`装饰它。从历史上看，Django中的视图通常是函数；因此，这个装饰器被设计为接受一个*函数*而不是像我们在这个类中有的*方法*。我们在这个项目中使用Django基于类的视图，所以为了让一切正常工作，我们需要将`login_required`转换为一个接受方法（区别在于第一个参数：`self`）。我们通过将`login_required`传递给`method_decorator`来实现这一点。
- en: 'We also need to feed the `login_required` decorator with `login_url` information,
    and here comes another wonderful feature of Django. As you''ll see after we''re
    done with the views, in Django, you tie a view to a URL through a pattern, consisting
    of a regular expression and other information. You can give a name to each entry
    in the `urls.py` file so that when you want to refer to a URL, you don''t have
    to hardcode its value into your code. All you have to do is get Django to reverse-engineer
    that URL from the name we gave to the entry in `urls.py` defining the URL and
    the view that is tied to it. This mechanism will become clearer later. For now,
    just think of `reverse(''...'')` as a way of getting a URL from an identifier.
    In this way, you only write the actual URL once, in the `urls.py` file, which
    is brilliant. In the `views.py` code, we need to use `reverse_lazy`, which works
    exactly like `reverse` with one major difference: it only finds the URL when we
    actually need it (in a lazy fashion). This is needed when the `urls.py` file hasn''t
    been loaded yet when the `reverse` function is used.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要向`login_required`装饰器提供`login_url`信息，这是Django的另一个奇妙特性。在我们完成视图之后，您将看到，在Django中，您通过一个由正则表达式和其他信息组成的模式将视图绑定到URL。您可以在`urls.py`文件中为每个条目命名，这样当您想要引用一个URL时，您就不必将它的值硬编码到代码中。您只需要让Django从我们在`urls.py`中定义的URL及其关联的视图的名称中反向工程该URL。这个机制稍后会变得清晰。现在，只需将`reverse('...')`视为从标识符获取URL的一种方式。这样，您只需在`urls.py`文件中实际编写一次URL，这是非常棒的。在`views.py`代码中，我们需要使用`reverse_lazy`，它的工作方式与`reverse`完全相同，只有一个主要区别：它只在真正需要时（以懒加载的方式）找到URL。当`reverse`函数被使用时，如果`urls.py`文件尚未加载，就需要这个功能。
- en: The `get` method, which we just decorated, simply calls the `get` method of
    the parent class. Of course, the `get` method is the method that Django calls
    when a `GET` request is performed against the URL tied to this view.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚装饰的`get`方法只是简单地调用父类的`get`方法。当然，`get`方法是在对与这个视图关联的URL执行`GET`请求时Django调用的方法。
- en: The entry list view
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 条目列表视图
- en: This view is much more interesting than the previous one. First of all, we decorate
    the `get` method as we did before. Inside of it, we need to prepare a list of
    `Entry` objects and feed it to the template, which shows it to the user. In order
    to do so, we start by getting the `context` dict like we're supposed to do, by
    calling the `get_context_data` method of the `TemplateView` class. Then, we use
    the ORM to get a list of the entries. We do this by accessing the objects manager,
    and calling a filter on it. We filter the entries according to which user is logged
    in, and we ask for them to be sorted in a descending order (that `'-'` in front
    of the name specifies the descending order). The `objects` manager is the default
    **manager** every Django model is augmented with on creation, it allows us to
    interact with the database through its methods.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这个视图比之前的视图更有趣。首先，我们像之前一样装饰了`get`方法。在它里面，我们需要准备一个`Entry`对象的列表并将其传递给模板，这样用户就能看到它。为了做到这一点，我们首先像预期的那样获取`context`字典，通过调用`TemplateView`类的`get_context_data`方法。然后，我们使用ORM获取条目的列表。我们通过访问对象管理器并对其调用过滤器来完成此操作。我们根据哪个用户登录来过滤条目，并要求它们按降序排序（名称前的`'-'`指定了降序）。`objects`管理器是Django模型创建时默认增加的**管理器**，它允许我们通过其方法与数据库交互。
- en: We parse each entry to get a list of matches (actually, I coded it so that `matches`
    is a generator expression). Finally, we add to the context an `'entries'` key
    whose value is the coupling of `entries` and `matches`, so that each `Entry` instance
    is paired with the resulting match of its pattern and test string.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们解析每个条目以获取匹配项的列表（实际上，我编写了代码，使得`matches`是一个生成器表达式）。最后，我们在上下文中添加一个`'entries'`键，其值是`entries`和`matches`的耦合，这样每个`Entry`实例都与它的模式测试字符串的匹配结果配对。
- en: On the last line, we simply ask Django to render the template using the context
    we created.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一行，我们只是要求Django使用我们创建的上下文渲染模板。
- en: 'Take a look at the `_parse_entry` method. All it does is perform a search on
    the `entry.test_string` with the `entry.pattern`. If the resulting `match` object
    is not `None`, it means that we found something. If so, we return a tuple with
    three elements: the overall group, the subgroups, and the group dictionary. If
    you''re not familiar with these terms, don''t worry, you''ll see a screenshot
    soon with an example. We return `None` if there is no match.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下`_parse_entry`方法。它所做的只是使用`entry.pattern`在`entry.test_string`上执行搜索。如果结果`match`对象不是`None`，这意味着我们找到了一些东西。如果是这样，我们返回一个包含三个元素的元组：整体组、子组和组字典。如果你不熟悉这些术语，不要担心，你很快就会看到一个带有示例的截图。如果没有匹配项，我们返回`None`。
- en: The form view
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 表单视图
- en: Finally, let's examine `EntryFormView`. This is particularly interesting for
    a few reasons. Firstly, it shows us a nice example of Python's multiple inheritance.
    We want to display a message on the page, after having inserted an `Entry`, so
    we inherit from `SuccessMessageMixin`. But we want to handle a form as well, so
    we also inherit from `FormView`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们来检查`EntryFormView`。这有几个特别有趣的原因。首先，它展示了Python多重继承的一个很好的例子。我们在插入`Entry`后想在页面上显示一条消息，所以我们从`SuccessMessageMixin`继承。但我们也想处理表单，所以我们还从`FormView`继承。
- en: Note
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that, when you deal with mixins and inheritance, you may have to consider
    the order in which you specify the base classes in the class declaration.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当你处理混入和继承时，你可能需要考虑在类声明中指定基类顺序。
- en: 'In order to set up this view correctly, we need to specify a few attributes
    at the beginning: the template to be rendered, the form class to be used to handle
    the data from the `POST` request, the URL we need to redirect the user to in the
    case of success, and the success message.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确设置这个视图，我们需要在开始时指定几个属性：要渲染的模板、用于处理`POST`请求数据的表单类、在成功情况下需要重定向用户到的URL，以及成功消息。
- en: Another interesting feature is that this view needs to handle both `GET` and
    `POST` requests. When we land on the form page for the first time, the form is
    empty, and that is the `GET` request. On the other hand, when we fill in the form
    and want to submit the `Entry`, we make a `POST` request. You can see that the
    body of `get` is conceptually identical to `HomeView`. Django does everything
    for us.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的特点是，这个视图需要处理`GET`和`POST`请求。当我们第一次到达表单页面时，表单是空的，这就是`GET`请求。另一方面，当我们填写表单并想要提交`Entry`时，我们发起一个`POST`请求。你可以看到`get`请求的主体在概念上与`HomeView`相同。Django为我们做了一切。
- en: The `post` method is just like `get`. The only reason we need to code these
    two methods is so that we can decorate them to require login.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`post`方法就像`get`方法一样。我们之所以需要编写这两个方法，仅仅是为了能够装饰它们以要求登录。'
- en: Within the Django form handling process (in the `FormView` class), there are
    a few methods that we can override in order to customize the overall behavior.
    We need to do it with the `form_valid` method. This method will be called when
    the form validation is successful. Its purpose is to save the form so that an
    `Entry` object is created out of it, and then stored in the database.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在Django表单处理过程（在`FormView`类中），有一些方法我们可以覆盖以自定义整体行为。我们需要使用`form_valid`方法来完成这项工作。当表单验证成功时，将调用此方法。它的目的是保存表单，从而从其中创建一个`Entry`对象，并将其存储在数据库中。
- en: The only problem is that our form is missing the user. We need to intercept
    that moment in the chain of calls and put the user information in ourselves. This
    is done by calling the `_save_with_user` method, which is very simple.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的问题是我们的表单缺少用户信息。我们需要在调用链中拦截那个时刻，并自行添加用户信息。这是通过调用`_save_with_user`方法来完成的，这个方法非常简单。
- en: Firstly, we ask Django to save the form with the `commit` argument set to `False`.
    This creates an `Entry` instance without attempting to save it to the database.
    Saving it immediately would fail because the `user` information is not there.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们请求Django以`commit`参数设置为`False`的方式保存表单。这创建了一个`Entry`实例，而不尝试将其保存到数据库中。立即保存会失败，因为`user`信息尚未存在。
- en: The next line updates the `Entry` instance (`self.object`), adding the `user`
    information and, on the last line, we can safely save it. The reason I called
    it `object` and set it on the instance like that was to follow what the original
    `FormView` class does.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行更新了`Entry`实例（`self.object`），添加了`user`信息，而在最后一行，我们可以安全地保存它。我之所以将其命名为`object`并像那样将其设置在实例上，是为了遵循原始的`FormView`类所做的事情。
- en: We're fiddling with the Django mechanism here, so if we want the whole thing
    to work, we need to pay attention to when and how we modify its behavior, and
    make sure we don't alter it incorrectly. For this reason, it's very important
    to remember to call the `form_valid` method of the base class (we use `super`
    for that) at the end of our own customized version, to make sure that every other
    action that method usually performs is carried out correctly.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里玩弄Django机制，因此如果我们想让整个系统正常工作，我们需要注意何时以及如何修改其行为，并确保我们不会错误地修改它。因此，记住在自定义版本的末尾调用基类的`form_valid`方法（我们使用`super`来这样做）非常重要，以确保该方法通常执行的其他所有操作都能正确执行。
- en: Note how the request is tied to each view instance (`self.request`) so that
    we don't need to pass it through when we refactor our logic into methods. Note
    also that the user information has been added to the request automatically by
    Django. Finally, note that the reason why all the process is split into very small
    methods like these is so that we can only override those that we need to customize.
    All this removes the need to write a lot of code.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 注意请求是如何绑定到每个视图实例（`self.request`）的，这样我们就不需要在重构逻辑到方法时传递它。还要注意，用户信息已经被Django自动添加到请求中。最后，注意之所以将整个过程拆分成如此之小的方法，是为了我们可以仅覆盖那些需要自定义的方法。所有这些都消除了编写大量代码的需要。
- en: Now that we have the views covered, let's see how we couple them to the URLs.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经覆盖了视图，让我们看看如何将它们与URL关联起来。
- en: Tying up URLs and views
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绑定URL和视图
- en: In the `urls.py` module, we tie each view to a URL. There are many ways of doing
    this. I chose the simplest one, which works perfectly for the extent of this exercise,
    but you may want to explore this argument more deeply if you intend to work with
    Django. This is the core around which the whole website logic will revolve; therefore,
    you should try to get it down correctly. Note that the `urls.py` module belongs
    to the project folder.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在`urls.py`模块中，我们将每个视图绑定到一个URL。有多种方法可以做到这一点。我选择了最简单的一种，这对于本练习的范围来说效果很好，但如果你打算使用Django，你可能想更深入地探索这个参数。这是整个网站逻辑围绕的核心；因此，你应该努力正确地掌握它。请注意，`urls.py`模块属于项目文件夹。
- en: '`regex/urls.py`'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`regex/urls.py`'
- en: '[PRE16]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, the magic comes from the `url` function. Firstly, we pass it
    a regular expression; then the view; and finally, a name, which is what we will
    use in the `reverse` and `reverse_lazy` functions to recover the URL.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，魔法来自于`url`函数。首先，我们传递给它一个正则表达式；然后是视图；最后是一个名称，这是我们将在`reverse`和`reverse_lazy`函数中使用来恢复URL的名称。
- en: Note that, when using class-based views, we have to transform them into functions,
    which is what `url` is expecting. To do that, we call the `as_view()` method on
    them.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当使用基于类的视图时，我们必须将它们转换为函数，这正是`url`所期望的。为此，我们调用它们的`as_view()`方法。
- en: Note also that the first `url` entry, for the admin, is special. Instead of
    specifying a URL and a view, it specifies a URL prefix and another `urls.py` module
    (from the `admin.site` package). In this way, Django will complete all the URLs
    for the admin section by prepending `'admin/'` to all the URLs specified in `admin.site.urls`.
    We could have done the same for our entries app (and we should have), but I feel
    it would have been a bit too much for this simple project.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，第一个`url`条目，针对管理员，是特殊的。它不是指定一个URL和一个视图，而是指定一个URL前缀和另一个`urls.py`模块（来自`admin.site`包）。这样，Django将通过在`admin.site.urls`中指定的所有URL前添加`'admin/'`来完成管理员部分的全部URL。我们本来也可以为我们的条目应用做同样的事情（我们应该这么做），但我感觉这对这个简单的项目来说可能有点过于复杂了。
- en: In the regular expression language, the `'^'` and `'$'` symbols represent the
    *start* and *end* of a string. Note that if you use the inclusion technique, as
    for the admin, the `'$'` is missing. Of course, this is because `'admin/'` is
    just a prefix, which needs to be completed by all the definitions in the included
    `urls` module.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在正则表达式语言中，`'^'`和`'$'`符号代表字符串的*开始*和*结束*。注意，如果你使用包含技术，就像管理员一样，`'$'`是缺失的。当然，这是因为`'admin/'`只是一个前缀，需要由包含的`urls`模块中的所有定义来完成。
- en: Something else worth noticing is that we can also include the stringified version
    of a path to a view, which we do for the `login` and `logout` views. We also add
    information about which templates to use with the `kwargs` argument. These views
    come straight from the `django.contrib.auth` package, by the way, so that we don't
    need to write a single line of code to handle authentication. This is brilliant
    and saves us a lot of time.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得注意的事情是，我们还可以包含视图路径的字符串化版本，我们就是这样为`login`和`logout`视图做的。我们还通过`kwargs`参数添加了有关要使用哪些模板的信息。顺便说一下，这些视图直接来自`django.contrib.auth`包，因此我们不需要写一行代码来处理认证。这是非常棒的，节省了我们很多时间。
- en: Each `url` declaration must be done within the `urlpatterns` list and on this
    matter, it's important to consider that, when Django is trying to find a view
    for a URL that has been requested, the patterns are exercised in order, from top
    to bottom. The first one that matches is the one that will provide the view for
    it so, in general, you have to put specific patterns before generic ones, otherwise
    they will never get a chance to be caught. For example, `'^shop/categories/$'`
    needs to come before `'^shop'` (note the absence of the `'$'` in the latter),
    otherwise it would never be called. Our example for the entries works fine because
    I thoroughly specified URLs using the `'$'` at the end.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`url`声明都必须在`urlpatterns`列表内完成，关于这一点，重要的是要考虑，当Django试图为请求的URL查找视图时，模式是按顺序从上到下执行的。第一个匹配的模式将提供该URL的视图，所以通常情况下，你必须将具体的模式放在通用模式之前，否则它们将永远不会有机会被捕获。例如，`'^shop/categories/$'`需要放在`'^shop'`之前（注意后者中没有`'$'`），否则它将永远不会被调用。我们的条目示例工作得很好，因为我详细地使用了`'$'`来指定URL。
- en: So, models, forms, admin, views and URLs are all done. All that is left to do
    is take care of the templates. I'll have to be very brief on this part because
    HTML can be very verbose.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，模型、表单、管理员、视图和URL都已经完成。剩下要做的就是处理模板。关于这部分，我必须非常简略，因为HTML可能非常冗长。
- en: Writing the templates
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写模板
- en: 'All templates inherit from a base one, which provides the HTML structure for
    all others, in a very OOP type of fashion. It also specifies a few blocks, which
    are areas that can be overridden by children so that they can provide custom content
    for those areas. Let''s start with the base template:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 所有模板都继承自一个基础模板，它为所有其他模板提供了HTML结构，以一种非常面向对象的方式。它还指定了一些块，这些块是可以被子模板覆盖的区域，以便它们可以为这些区域提供自定义内容。让我们从基础模板开始：
- en: '`entries/templates/entries/base.html`'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`entries/templates/entries/base.html`'
- en: '[PRE17]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: There is a good reason to repeat the `entries` folder from the `templates` one.
    When you deploy a Django website, you collect all the template files under one
    folder. If you don't specify the paths like I did, you may get a `base.html` template
    in the entries app, and a `base.html` template in another app. The last one to
    be collected will override any other file with the same name. For this reason,
    by putting them in a `templates/entries` folder and using this technique for each
    Django app you write, you avoid the risk of name collisions (the same goes for
    any other static file).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个很好的理由需要从`templates`文件夹中重复`entries`文件夹。当你部署Django网站时，你会在一个文件夹下收集所有的模板文件。如果你没有指定路径，就像我这样做，你可能会在entries应用中找到一个`base.html`模板，在另一个应用中也有一个`base.html`模板。最后收集到的将覆盖任何具有相同名称的其他文件。因此，通过将它们放在`templates/entries`文件夹中，并使用这种技术为每个Django应用编写，你可以避免名称冲突的风险（这同样适用于任何其他静态文件）。
- en: There is not much to say about this template, really, apart from the fact that
    it loads the `static` tag so that we can get easy access to the `static` path
    without hardcoding it in the template by using `{% static ... %}`. The code in
    the special `{% ... %}` sections is code that defines logic. The code in the special
    `{{ ... }}` represents variables that will be rendered on the page.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个模板，实际上没有太多可说的，除了它加载了`static`标签，这样我们就可以通过使用`{% static ... %}`来轻松访问`static`路径，而无需在模板中硬编码它。特殊`{%
    ... %}`部分中的代码定义了逻辑。特殊`{{ ... }}`中的代码代表将在页面上渲染的变量。
- en: 'We define three blocks: `title`, `page-content,` and `footer`, whose purpose
    is to hold the title, the content of the page, and the footer. Blocks can be optionally
    overridden by child templates in order to provide different content within them.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了三个块：`title`、`page-content`和`footer`，它们的作用是包含标题、页面内容和页脚。块可以被子模板选择性地覆盖，以便在它们内部提供不同的内容。
- en: 'Here''s the footer:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这个页脚的内容：
- en: '`entries/templates/entries/footer.html`'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`entries/templates/entries/footer.html`'
- en: '[PRE18]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: It gives us a nice link to the home page.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 它为我们提供了一个链接到主页的便捷入口。
- en: 'The home page template is the following:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 主页模板如下：
- en: '`entries/templates/entries/home.html`'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`entries/templates/entries/home.html`'
- en: '[PRE19]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: It extends the `base.html` template, and overrides `title` and `page-content`.
    You can see that basically all it does is provide four links to the user. These
    are the list of entries, the insert page, the logout page, and the admin page.
    All of this is done without hardcoding a single URL, through the use of the `{%
    url ... %}` tag, which is the template equivalent of the `reverse` function.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 它扩展了`base.html`模板，并覆盖了`title`和`page-content`。你可以看到它基本上只提供了四个链接给用户。这些链接包括条目列表、插入页面、登出页面和管理员页面。所有这些操作都是通过使用`{%
    url ... %}`标签来完成的，这是模板中的`reverse`函数的等价物，而且没有硬编码任何URL。
- en: 'The template for inserting an `Entry` is as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 插入`Entry`的模板如下：
- en: '`entries/templates/entries/insert.html`'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`entries/templates/entries/insert.html`'
- en: '[PRE20]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'There is some conditional logic at the beginning to display messages, if any,
    and then we define the form. Django gives us the ability to render a form by simply
    calling `{{ form.as_p }}` (alternatively, `form.as_ul` or `form.as_table`). This
    creates all the necessary fields and labels for us. The difference between the
    three commands is in the way the form is laid out: as a paragraph, as an unordered
    list or as a table. We only need to wrap it in form tags and add a submit button.
    This behavior was designed for our convenience; we need the freedom to shape that
    `<form>` tag as we want, so Django isn''t intrusive on that. Also, note that `{%
    csrf_token %}`. It will be rendered into a token by Django and will become part
    of the data sent to the server on submission. This way Django will be able to
    verify that the request was from an allowed source, thus avoiding the aforementioned
    *cross-site request forgery* issue. Did you see how we handled the token when
    we wrote the view for the `Entry` insertion? Exactly. We didn''t write a single
    line of code for it. Django takes care of it automatically thanks to a **middleware**
    class (`CsrfViewMiddleware`). Please refer to the official Django documentation
    to explore this subject further.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始处有一些条件逻辑来显示消息（如果有），然后我们定义表单。Django通过简单地调用`{{ form.as_p }}`（或者`form.as_ul`或`form.as_table`）来为我们提供渲染表单的能力。这为我们创建了所有必要的字段和标签。这三个命令之间的区别在于表单的布局方式：作为段落、无序列表或表格。我们只需要将其包裹在表单标签中并添加一个提交按钮。这种行为是为了我们的方便而设计的；我们需要有自由来塑造我们想要的`<form>`标签，所以Django不会在这方面造成干扰。此外，请注意`{%
    csrf_token %}`。它将被Django渲染成一个令牌，并成为提交时发送到服务器的数据的一部分。这样，Django就能验证请求是否来自允许的来源，从而避免上述*跨站请求伪造*问题。你看到我们如何在编写`Entry`插入视图时处理令牌了吗？正是这样。我们没有为它写一行代码。Django通过一个**中间件**类（`CsrfViewMiddleware`）自动处理它。请参考官方Django文档以进一步探索这个主题。
- en: For this page, we also use the footer block to display a link to the home page.
    Finally, we have the list template, which is the most interesting one.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个页面，我们也使用页脚块来显示指向主页的链接。最后，我们有列表模板，这是最有趣的一个。
- en: '`entries/templates/entries/list.html`'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`entries/templates/entries/list.html`'
- en: '[PRE21]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: It may take you a while to get used to the template language, but really, all
    there is to it is the creation of a table using a `for` loop. We start by checking
    if there are any entries and, if so, we create a table. There are two columns,
    one for the `Entry`, and the other for the match.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要一段时间才能习惯模板语言，但事实上，它只是使用`for`循环创建一个表格。我们首先检查是否有条目，如果有，我们创建一个表格。有两个列，一列用于`Entry`，另一列用于匹配。
- en: In the `Entry` column, we display the `Entry` object (apart from the user) and
    in the `Matches` column, we display that 3-tuple we created in the `EntryListView`.
    Note that to access the attributes of an object, we use the same dot syntax we
    use in Python, for example `{{ entry.pattern }}` or `{{ entry.test_string }}`,
    and so on.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Entry`列中，我们显示`Entry`对象（除了用户之外）和在`Matches`列中显示我们在`EntryListView`中创建的那个3元组。请注意，为了访问对象的属性，我们使用与Python中相同的点语法，例如`{{
    entry.pattern }}`或`{{ entry.test_string }}`，等等。
- en: When dealing with lists and tuples, we cannot access items using the square
    brackets syntax, so we use the dot one as well (`{{ match.0 }}` is equivalent
    to `match[0]`, and so on.). We also use a filter, through the pipe (`|`) operator
    to display a custom value if a match is `None`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理列表和元组时，我们不能使用方括号语法来访问项，所以我们也要使用点语法（`{{ match.0 }}`等同于`match[0]`，等等）。我们还使用一个通过管道（`|`）操作符的过滤器来显示一个自定义值，如果匹配是`None`。
- en: The Django template language (which is not properly Python) is kept simple for
    a precise reason. If you find yourself limited by the language, it means you're
    probably trying to do something in the template that should actually be done in
    the view, where that logic is more relevant.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Django模板语言（它并不是真正的Python）被保持得非常简单，这是出于一个精确的原因。如果你发现自己受到语言的限制，这意味着你可能在模板中尝试做一些实际上应该在视图中完成的事情，那里的逻辑更为相关。
- en: 'Allow me to show you a couple of screenshots of the *list* and *insert* templates.
    This is what the list of entries looks like for my father:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我向您展示几个`list`和`insert`模板的截图。这是我父亲的条目列表看起来像这样：
- en: '![Writing the templates](img/4715_10_04.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![编写模板](img/4715_10_04.jpg)'
- en: Note how the use of the cycle tag alternates the background color of the rows
    from white to light gray. Those classes are defined in the `main.css` file.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用`cycle`标签如何交替行的背景颜色，从白色变为浅灰色。这些类在`main.css`文件中定义。
- en: The `Entry` insertion page is smart enough to provide a few different scenarios.
    When you land on it at first, it presents you with just an empty form. If you
    fill it in correctly, it will display a nice message for you (see the following
    picture). However, if you fail to fill in both fields, it will display an error
    message before them, alerting you that those fields are required.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`Entry` 插入页面足够智能，可以提供几种不同的场景。当你第一次访问它时，它会给你一个空表单。如果你正确填写，它会显示一个漂亮的提示信息（见下图）。然而，如果你未能填写两个字段，它会在它们之前显示一个错误信息，提醒你这些字段是必需的。'
- en: 'Note also the custom footer, which includes both a link to the entries list
    and a link to the home page:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意自定义页脚，它包括对条目列表的链接和对主页的链接：
- en: '![Writing the templates](img/4715_10_05.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![编写模板](img/4715_10_05.jpg)'
- en: And that's it! You can play around with the CSS styles if you wish. Download
    the code for the book and have fun exploring and extending this project. Add something
    else to the model, create and apply a migration, play with the templates, there's
    lots to do!
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！如果你愿意，可以随意玩转CSS样式。下载这本书的代码，尽情探索和扩展这个项目。给模型添加其他内容，创建并应用迁移，玩转模板，有很多事情可以做！
- en: Django is a very powerful framework, and offers so much more than what I've
    been able to show you in this chapter, so you definitely want to check it out.
    The beauty of it is that it's Python, so reading its source code is a very useful
    exercise.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Django是一个非常强大的框架，它提供的功能远超我在本章中向您展示的内容，所以您绝对想看看它。它的美在于它是Python，因此阅读它的源代码是一个非常有益的练习。
- en: The future of web development
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络开发的未来
- en: Computer science is a very young subject, compared to other branches of science
    that have existed alongside humankind for centuries or more. One of its main characteristics
    is that it moves extremely fast. It leaps forward with such speed that, in just
    a few years, you can see changes that are comparable to real world changes that
    took a century to happen. Therefore, as a coder, you must pay attention to what
    happens in this world, all the time.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机科学与其他伴随人类数百年甚至更长时间的学科相比，是一个非常年轻的学科。它的一大特点是发展速度极快。它以如此快的速度前进，以至于在短短几年内，你就能看到与实际世界变化相当的变化，而这些变化原本需要一百年才能发生。因此，作为一名程序员，你必须时刻关注这个世界正在发生的事情。
- en: Something that is happening now is that because powerful computers are now quite
    cheap and almost everyone has access to them, the trend is to try and avoid putting
    too much workload on the backend, and let the frontend handle part of it. Therefore,
    in the last few years, JavaScript frameworks and libraries like jQuery and Backbone
    have become very popular and web development has shifted from a paradigm where
    the backend takes care of handling data, preparing it, and serving it to the frontend
    to display it, to a paradigm where the backend is sometimes just used as an API,
    a sheer data provider. The frontend fetches the data from the backend with an
    API call, and then it takes care of the rest. This shift facilitates the existence
    of paradigms like **Single-Page Application** (**SPA**), where, ideally, the whole
    page is loaded once and then evolves, based on the content that usually comes
    from the backend. E-commerce websites that load the results of a search in a page
    that doesn't refresh the surrounding structure, are made with similar techniques.
    Browsers can perform asynchronous calls (**AJAX**) that can return data which
    can be read, manipulated and injected back into the page with JavaScript code.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在正在发生的事情是，由于强大的计算机现在非常便宜，几乎每个人都能访问它们，因此趋势是尽量避免在服务器端放置过多的工作负载，让前端处理一部分。因此，在过去的几年里，像jQuery和Backbone这样的JavaScript框架和库变得非常流行，网络开发已经从后端负责处理数据、准备数据并为其提供显示给前端的范式，转变为后端有时仅用作API、纯粹的数据提供者的范式。前端通过API调用从后端获取数据，然后处理其余部分。这种转变促进了**单页应用**（**SPA**）等范式的存在，理想情况下，整个页面只加载一次，然后根据通常来自后端的内容进行演变。使用类似技术的电子商务网站可以在不刷新周围结构的情况下在页面中加载搜索结果。浏览器可以执行异步调用（**AJAX**），这些调用可以返回数据，这些数据可以用JavaScript代码读取、操作并注入回页面。
- en: 'So, if you''re planning to work on web development, I strongly suggest you
    to get acquainted with JavaScript (if you''re not already), and also with APIs.
    In the last few pages of this chapter, I''ll give you an example of how to make
    a simple API using two different Python microframeworks: Flask and Falcon.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你打算从事Web开发，我强烈建议你熟悉JavaScript（如果你还没有的话），以及API。在本章的最后几页，我将给你一个如何使用两个不同的Python微框架（Flask和Falcon）创建简单API的例子。
- en: Writing a Flask view
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写Flask视图
- en: Flask ([http://flask.pocoo.org/](http://flask.pocoo.org/)) is a Python microframework.
    It provides fewer features than Django, but it's supposedly faster and quicker
    to get up and running. To be honest, getting Django up and running nowadays is
    also very quickly done, but Flask is so popular that it's good to see an example
    of it, nonetheless.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Flask ([http://flask.pocoo.org/](http://flask.pocoo.org/)) 是一个Python微框架。它提供的功能比Django少，但据说速度更快，启动也更快。说实话，现在启动Django也非常快，但Flask如此受欢迎，看到它的例子也很不错。
- en: 'In your `ch10` folder, create a `flask` folder with the following structure:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的`ch10`文件夹中，创建一个名为`flask`的文件夹，其结构如下：
- en: '[PRE22]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Basically, we''re going to code two simple files: a Flask application and an
    HTML template. Flask uses Jinja2 as template engine. It''s extremely popular and
    very fast, and just recently even Django has started to offer native support for
    it, which is something that Python coders have longed for, for a long time.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们将编写两个简单的文件：一个Flask应用和一个HTML模板。Flask使用Jinja2作为模板引擎。它非常流行且非常快，而且最近Django甚至开始提供对它的原生支持，这是Python程序员长期渴望的事情。
- en: '`flask/templates/main.html`'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`flask/templates/main.html`'
- en: '[PRE23]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The template is almost offensively simple; all it does is to change the greeting
    according to the presence of the `name` variable. A bit more interesting is the
    Flask application that renders it:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 模板几乎可以说是过于简单；它所做的只是根据`name`变量的存在来更改问候语。更有趣的是渲染它的Flask应用：
- en: '`flask/main.py`'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`flask/main.py`'
- en: '[PRE24]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We create an `app` object, which is a Flask application. We only feed the fully-qualified
    name of the module, which is stored in `__name__`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个`app`对象，这是一个Flask应用。我们只提供存储在`__name__`中的模块的完全限定名称。
- en: Then, we write a simple `hello` view, which takes an optional `name` argument.
    In the body of the view, we simply render the `main.html` template, passing to
    it the `name` argument, regardless of its value.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们编写一个简单的`hello`视图，它接受一个可选的`name`参数。在视图的主体中，我们简单地渲染`main.html`模板，并将`name`参数传递给它，无论其值如何。
- en: What's interesting is the routing. Differently from Django's way of tying up
    views and URLs (the `urls.py` module), in Flask you decorate your view with one
    or more `@app.route` decorators. In this case, we accept both the root URL without
    anything else, or with name information.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是路由。与Django将视图和URL（`urls.py`模块）绑定起来的方式不同，在Flask中，你使用一个或多个`@app.route`装饰器来装饰你的视图。在这种情况下，我们接受没有其他信息的根URL，或者带有名称信息。
- en: 'Change into the `flask` folder and type (make sure you have Flask installed
    with `$ pip install flask`):'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到`flask`文件夹，并输入（确保你已经通过`$ pip install flask`安装了Flask）：
- en: '[PRE25]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You can open a browser and go to `http://127.0.0.1:5000/`. This URL has no name
    information; therefore, you will see **Hello shy person!** It is written all nice
    and big. Try to add something to that URL like `http://127.0.0.1:5000/Adriano`.
    Hit *Enter* and the page will change to **Hello Adriano!**.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以打开浏览器并访问`http://127.0.0.1:5000/`。这个URL没有名称信息；因此，你会看到**Hello shy person!**它写得很大很漂亮。试着在URL中添加一些内容，比如`http://127.0.0.1:5000/Adriano`。按*Enter*键，页面将变为**Hello
    Adriano!**。
- en: Of course, Flask offers you much more than this but we don't have the room to
    see a more complex example. It's definitely worth exploring, though. Several projects
    use it successfully and it's fun and it is nice to create websites or APIs with
    it. Flask's author, Armin Ronacher, is a successful and very prolific coder. He
    also created or collaborated on several other interesting projects like Werkzeug,
    Jinja2, Click, and Sphinx.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，Flask为你提供了更多功能，但我们没有足够的空间来展示更复杂的例子。尽管如此，它绝对值得探索。几个项目已经成功地使用了它，而且用它创建网站或API很有趣。Flask的作者Armin
    Ronacher是一位成功且多产的程序员。他还创建了或参与了几个其他有趣的项目，如Werkzeug、Jinja2、Click和Sphinx。
- en: Building a JSON quote server in Falcon
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Falcon中构建JSON报价服务器
- en: Falcon ([http://falconframework.org/](http://falconframework.org/)) is another
    microframework written in Python, which was designed to be light, fast and flexible.
    I think this relatively young project will evolve to become something really popular
    due to its speed, which is impressive, so I'm happy to show you a tiny example
    using it.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Falcon ([http://falconframework.org/](http://falconframework.org/)) 是另一个用 Python
    编写的微框架，它被设计成轻量级、快速和灵活。我认为这个相对较新的项目会因其速度而发展成为一个真正受欢迎的项目，这种速度令人印象深刻，所以我很高兴能给你展示一个使用它的微小示例。
- en: We're going to build a view that returns a randomly chosen quote from the *Buddha*.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个视图，它返回一个随机选择的 *佛陀* 引语。
- en: 'In your `ch10` folder, create a new one called `falcon`. We''ll have two files:
    `quotes.py` and `main.py`. To run this example, install Falcon and Gunicorn (`$
    pip install falcon gunicorn`). Falcon is the framework, and **Gunicorn** (**Green
    Unicorn**) is a Python WSGI HTTP Server for Unix (which, in layman terms, means
    the technology that is used to run the server). When you''re all set up, start
    by creating the `quotes.py` file.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 `ch10` 文件夹中，创建一个新的名为 `falcon` 的文件夹。我们将有两个文件：`quotes.py` 和 `main.py`。要运行此示例，请安装Falcon和Gunicorn
    (`$ pip install falcon gunicorn`)。Falcon是框架，**Gunicorn**（**绿色独角兽**）是一个用于Unix的Python
    WSGI HTTP服务器（用通俗易懂的话来说，就是运行服务器所用的技术）。当你一切准备就绪时，首先创建 `quotes.py` 文件。
- en: '`falcon/quotes.py`'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`falcon/quotes.py`'
- en: '[PRE26]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You will find the complete list of quotes in the source code for this book.
    If you don't have it, you can also fill in your favorite quotes. Note that not
    every line has a comma at the end. In Python, it's possible to concatenate strings
    like that, as long as they are in brackets (or braces). It's called **implicit
    concatenation**.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在本书的源代码中找到完整的引语列表。如果你没有，你也可以填写你喜欢的引语。请注意，并非每一行都以逗号结尾。在Python中，只要它们在括号（或大括号）中，就可以像那样连接字符串。这被称为
    **隐式连接**。
- en: 'The code for the main app is not long, but it is interesting:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 主应用程序的代码并不长，但很有趣：
- en: '`falcon/main.py`'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`falcon/main.py`'
- en: '[PRE27]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Let's start with the class. In Django we had a `get` method, in Flask we defined
    a function, and here we write an `on_get` method, a naming style that reminds
    me of C# event handlers. It takes a request and a response argument, both automatically
    fed by the framework. In its body, we define a dict with a randomly chosen quote,
    and the author information. Then we dump that dict to a JSON string and set the
    response body to its value. We don't need to return anything, Falcon will take
    care of it for us.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从类开始。在Django中我们有一个 `get` 方法，在Flask中我们定义了一个函数，而在这里我们编写一个 `on_get` 方法，这种命名风格让我想起了C#的事件处理器。它接受一个请求和一个响应参数，这两个参数都由框架自动提供。在其主体中，我们定义一个包含随机选择引语和作者信息的字典，然后将该字典转换为JSON字符串，并将响应体设置为它的值。我们不需要返回任何内容，Falcon会为我们处理。
- en: At the end of the file, we create the Falcon application, and we call `add_route`
    on it to tie the handler we have just written to the URL we want.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件末尾，我们创建Falcon应用程序，并在其上调用 `add_route` 来将我们刚刚编写的处理器绑定到我们想要的URL。
- en: 'When you''re all set up, change to the `falcon` folder and type:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 当你一切准备就绪时，切换到 `falcon` 文件夹，并输入：
- en: '[PRE28]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then, make a request (or simply open the page with your browser) to `http://127.0.0.1:8000/quote`.
    When I did it, I got this JSON in response:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，向 `http://127.0.0.1:8000/quote` 发送一个请求（或者简单地用你的浏览器打开这个页面）。当我这样做的时候，我得到了这个JSON响应：
- en: '[PRE29]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Whatever the framework you end up using for your web development, try and keep
    yourself informed about other choices too. Sometimes you may be in situations
    where a different framework is the right way to go, and having a working knowledge
    of different tools will give you an advantage.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你最终选择哪个框架进行Web开发，都要努力了解其他选择。有时你可能处于需要不同框架的情况，而了解不同工具的工作原理将给你带来优势。
- en: Summary
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we caught a glimpse of web development. We talked about important
    concepts like the DRY philosophy and the concept of a framework as a tool that
    provides us with many things we need in order to write code to serve requests.
    We also talked about the MTV pattern, and how nicely these three layers play together
    to realize a request-response path.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们简要地了解了Web开发。我们讨论了像DRY哲学和框架作为一个工具的概念，它为我们提供了编写代码以处理请求所需的所有东西。我们还讨论了MTV模式，以及这三个层次如何很好地协同工作以实现请求-响应路径。
- en: Later on, we briefly introduced regular expressions, which is a subject of paramount
    importance, and it's the layer which provides the tools for URL routing.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们简要介绍了正则表达式，这是一个极其重要的主题，它是提供URL路由工具的那一层。
- en: There are many different frameworks out there, and Django is definitely one
    of the best and most widely used, so it's definitely worth exploring, especially
    its source code, which is very well written.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有许多不同的框架，Django 无疑是其中最好的和最广泛使用的之一，因此它绝对值得探索，尤其是它的源代码，写得非常好。
- en: There are other very interesting and important frameworks too, like Flask. They
    provide fewer features but, in general, they are faster, both in execution time
    and to set up. One that is extremely fast is the relatively young Falcon project,
    whose benchmarks are outstanding.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他非常有趣且重要的框架，例如 Flask。它们提供的功能较少，但总体来说，它们在执行时间和设置上都要快得多。其中有一个非常快的框架是相对较新的 Falcon
    项目，其基准测试非常出色。
- en: It's important to get a solid understanding of how the request-response mechanism
    works, and how the Web in general works, so that eventually it won't matter too
    much which framework you have to use. You will be able to pick it up quickly because
    it will only be a matter of getting familiar with a way of doing something you
    already know a lot about.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 理解请求-响应机制是如何工作的，以及互联网总体上是如何工作的，这一点非常重要，这样最终你就不必太在意你不得不使用哪个框架。你将能够快速掌握它，因为这只涉及到熟悉一种你已经了解很多的方法。
- en: Explore at least three frameworks and try to come up with different use cases
    to decide which one of them could be the ideal choice. When you are able to make
    that choice, you will know you have a good enough understanding of them.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 至少探索三个框架，并尝试想出不同的用例来决定哪一个可能是理想的选择。当你能够做出那个选择时，你就知道你对它们的理解已经足够好了。
- en: The next chapter is about debugging and troubleshooting. We'll learn how to
    deal with errors and issues so that if you get in trouble when coding (don't worry,
    normally it only happens about all the time), you will be able to quickly find
    the solution to your problem and move on.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍调试和故障排除。我们将学习如何处理错误和问题，这样当你编码时遇到麻烦（别担心，通常这种情况不会经常发生），你将能够快速找到解决问题的方法并继续前进。
