- en: Chapter 4. Data and Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will use data and OOP classes using Python 3:'
  prefs: []
  type: TYPE_NORMAL
- en: How to use StringVar()
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to get data from a widget
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using module-level global variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How coding in classes can improve the GUI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing callback functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating reusable GUI components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will save our GUI data into tkinter variables.
  prefs: []
  type: TYPE_NORMAL
- en: We will also start using **object-oriented programming** (**OOP**) to extend
    the existing tkinter classes in order to extend tkinter's built-in functionality.
    This will lead us into creating reusable OOP components.
  prefs: []
  type: TYPE_NORMAL
- en: How to use StringVar()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are built-in programming types in tkinter that differ slightly from the
    Python types we are used to programming with. StringVar() is one of those tkinter
    types.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will show you how to use the StringVar() type.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are learning how to save data from the tkinter GUI into variables so we can
    use that data. We can set and get their values, very similar to the Java getter/setter
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some of the available types of coding in tkinter:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `strVar = StringVar()` | # Holds a string; the default value is an empty
    string "" |'
  prefs: []
  type: TYPE_TB
- en: '| `intVar = IntVar()` | # Holds an integer; the default value is 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `dbVar = DoubleVar()` | # Holds a float; the default value is 0.0 |'
  prefs: []
  type: TYPE_TB
- en: '| `blVar = BooleanVar()` | # Holds a Boolean, it returns 0 for false and 1
    for true |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Different languages call numbers with decimal points, floats, or doubles. Tkinter
    calls a DoubleVar for what in Python is called a float datatype. Depending on
    the level of precision, floats and double data can be different. Here, we are
    translating the tkinter DoubleVar into what Python turns into a Python float type.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are creating a new Python module and the following screenshot shows both
    the code and the resulting output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we import the tkinter module and alias it to the name `tk`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we use this alias to create an instance of the `Tk` class by appending
    parentheses to `Tk`, which calls the constructor of the class. This is the same
    mechanism as calling a function, only here we are creating an instance of a class.
  prefs: []
  type: TYPE_NORMAL
- en: Usually we use this instance assigned to the variable `win` to start the main
    event loop later in the code. But here, we are not displaying a GUI but demonstrating
    how to use the tkinter StringVar type.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We still have to create an instance of `Tk()`. If we comment out this line,
    we will get an error from tkinter, so this call is necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Then we create an instance of the tkinter StringVar type and assign it to our
    Python `strData` variable.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we use our variable to call the `set()` method on StringVar and,
    after having it set to a value, we then get the value and save it in a new variable
    named `varData` and then print out its value.
  prefs: []
  type: TYPE_NORMAL
- en: In the Eclipse PyDev console, towards the bottom of the screenshot, we can see
    the output printed to the console, which is **Hello StringVar**.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will print the default values of tkinter's IntVar, DoubleVar, and BooleanVar
    types.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As can be seen in the preceding screenshot, the default values do not get printed
    as we would have expected.
  prefs: []
  type: TYPE_NORMAL
- en: The online literature mentions default values, but we won't see those values
    until we call the `get` method on them. Otherwise, we just get a variable name
    that automatically increments (for example PY_VAR3, as can be seen in the preceding
    screenshot).
  prefs: []
  type: TYPE_NORMAL
- en: Assigning the tkinter type to a Python variable does not change the outcome.
    We still do not get the default value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we are focusing on the simplest code (which creates PY_VAR0):'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/B04829_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The value is PY_VAR0, not the expected 0, until we call the `get` method. Now
    we can see the default value. We did not call `set`, so we see the default value
    automatically assigned to each tkinter type once we call the `get` method on each
    type.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/B04829_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Notice how the default value of 0 gets printed to the console for the `IntVar`
    instance we saved in the `intData` variable. We can also see the values in the
    Eclipse PyDev debugger window at the top of the screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: How to get data from a widget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the user enters data, we want to do something with it in our code. This
    recipe shows how to capture data in a variable. In the previous recipe, we created
    several tkinter class variables. They were standalone. Now we are connecting them
    to our GUI, using the data we get from the GUI and storing it in Python variables.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are continuing to use the Python GUI we were building in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are assigning a value from our GUI to a Python variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code towards the bottom of our module, just above the main
    event loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the code gives us the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We are retrieving the current value of the `Spinbox` control.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We placed our code above the GUI main event loop and so the printing happens
    before the GUI becomes visible. We would have to place the code in a callback
    function if we wanted to print out the current value after displaying the GUI
    and changing the value of the `Spinbox` control.
  prefs: []
  type: TYPE_NORMAL
- en: 'We created our Spinbox widget using the following code, hard-coding the available
    values into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We can also move the hard-coding of the data out of the creation of the `Spinbox`
    class instance and set it later.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: It does not matter how we create our widget and insert data into it because
    we can access this data by using the `get()` method on the instance of the widget.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to get values out of our GUI written using tkinter, we use the tkinter
    `get()` method on an instance of the widget we wish to get the value from.
  prefs: []
  type: TYPE_NORMAL
- en: In the above example we used the Spinbox control, but the principle is the same
    for all widgets that have a `get()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have gotten the data, we are in a pure Python world and tkinter did
    serve us to build our GUI. Now that we know how to get the data out of our GUI,
    we can use this data.
  prefs: []
  type: TYPE_NORMAL
- en: Using module-level global variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Encapsulation is a major strength in any programming language that enables us
    to program using OOP. Python is both OOP and procedural. We can create global
    variables that are localized to the module they reside in. They are global only
    to this module, which is one form of encapsulation. Why do we want this? Because,
    as we add more and more functionality to our GUI, we want to avoid naming conflicts,
    which could result in bugs in our code.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We do not want naming clashes creating bugs in our code! Namespaces are one
    way to avoid these bugs, and in Python, we can do this by using Python modules
    (which are unofficial namespaces).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can declare module-level globals in any module just above and outside of
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: We then have to use the `global` Python keyword to refer to them. If we forget
    to use `global` in functions, we will accidentally create new local variables.
    This would be a bug and something we really do not want to do.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python is a dynamic, strongly typed language. We will only notice bugs like
    this (forgetting to scope variables with the global keyword) at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Add the code shown on line 15 to the GUI we used in the previous recipe and
    the last chapter, which creates a module-level global variable. We use the C-style
    all uppercase convention, which is not truly "Pythonic" but I think this does
    emphasize the principle we are addressing in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Running the code results in a printout of the global. Notice **42** being printed
    to the Eclipse console.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We define a global variable at the top of our module and, later, towards the
    bottom of our module, we print out its value.
  prefs: []
  type: TYPE_NORMAL
- en: That works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this function towards the bottom of our module:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/B04829_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Above, we are using the module-level global. It is easy to make a mistake by
    shadowing the `global`, as demonstrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/B04829_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note how `42` became `777`, even though we are using the same variable name.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is no compiler in Python that warns us if we overwrite global variables
    in a local function. This can lead to difficulties in debugging at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the global qualifier (line 234) prints out the value we originally assigned
    it (42) towards the top of our module, as can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/B04829_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'But, be careful. When we uncomment the local global, we print out the value
    of the local, not the global:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/B04829_04_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Even though we are using the `global` qualifier, the local variable seems to
    override it. We are getting a warning from the Eclipse PyDev plug-in that our
    `GLOBAL_CONST = 777` is not being used, yet running the code still prints 777
    instead of the expected 42.
  prefs: []
  type: TYPE_NORMAL
- en: This might not be the behavior we expect. Using the `global` qualifier we might
    expect that we are pointing to the global variable created earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, it seems that Python creates a new global variable in a local function
    and overwrites the one we created earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Global variables can be very useful when programming small applications. They
    can help to make data available across methods and functions within the same Python
    module and sometimes the overhead of OOP is not justified.
  prefs: []
  type: TYPE_NORMAL
- en: As our programs grow in complexity, the benefit we gained from using globals
    can quickly diminish.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is best to avoid globals and accidentally shadowing variables by using the
    same name in different scopes. We can use OOP instead of using globals.
  prefs: []
  type: TYPE_NORMAL
- en: We played around with global variables within procedural code and learned how
    that can lead to hard-to-debug bugs. In the next chapter, we will move on to OOP,
    which can eliminate these kinds of bugs.
  prefs: []
  type: TYPE_NORMAL
- en: How coding in classes can improve the GUI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have been coding in a procedural style. This is a quick scripting
    method from Python. Once our code gets larger and larger, we need to advance to
    coding in OOP.
  prefs: []
  type: TYPE_NORMAL
- en: Why?
  prefs: []
  type: TYPE_NORMAL
- en: Because, among many other benefits, OOP allows us to move code around by using
    methods. Once we use classes, we no longer have to physically place code above
    the code that calls it. This gives us great flexibility in organizing our code.
  prefs: []
  type: TYPE_NORMAL
- en: We can write related code next to other code and no longer have to worry that
    the code will not run because the code does not sit above the code that calls
    it.
  prefs: []
  type: TYPE_NORMAL
- en: We can take that to some rather fancy extremes by coding up modules that refer
    to methods that are not being created within that module. They rely on the runtime
    state having created those methods during the time the code runs.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the methods we call have not been created by that time, we get a runtime
    error.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will turn our entire procedural code into OOP very simply. We just turn it
    into a class, indent all the existing code, and prepend `self` to all variables.
  prefs: []
  type: TYPE_NORMAL
- en: It is very easy.
  prefs: []
  type: TYPE_NORMAL
- en: While at first it might feel a little bit annoying having to prepend everything
    with the `self` keyword, making our code more verbose (hey, we are wasting so
    much paper…); in the end, it will be worth it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the beginning, all hell breaks loose, but we will very soon fix this apparent
    mess.
  prefs: []
  type: TYPE_NORMAL
- en: Note that, in Eclipse, the PyDev editor hints at coding problems by highlighting
    them in red on the right-side portion of the code editor.
  prefs: []
  type: TYPE_NORMAL
- en: Maybe we should not code in OOP after all, but this is what we do, and for very
    good reasons.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_04_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We just have to prepend all variables with the `self` keyword and also bind
    the functions to the class by using `self`, which officially and technically turns
    the functions into methods.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is a difference between functions and methods. Python makes this very
    clear. Methods are bound to a class while functions are not. We can even mix the
    two within the same Python module.
  prefs: []
  type: TYPE_NORMAL
- en: Let's prefix everything with `self` to get rid of the red, so we can run our
    code again.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_04_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Once we do this for all of the errors highlighted in red, we can run our Python
    code again.
  prefs: []
  type: TYPE_NORMAL
- en: The `clickMe` function is now bound to the class and has officially become a
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, starting in a procedural way and then translating it into OOP
    is not as simple as I stated above. The code became a huge mess. This is a very
    good reason to start programming in Python using the OOP paradigm.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python is good at doing things the easy way. The easy code often becomes more
    complex (because it was easy to begin with). Once we get too complex, refactoring
    our procedural code into what truly could be OOP code becomes harder with every
    single line of code.
  prefs: []
  type: TYPE_NORMAL
- en: We are translating our procedural code into object-oriented code. Looking at
    all the troubles we got ourselves into, translating only 200+ lines of Python
    code into OOP could suggest that we might as well start coding in OOP from the
    beginning.
  prefs: []
  type: TYPE_NORMAL
- en: We actually did break some of our previously working functionality. Using Tab
    2 and clicking the radio buttons no longer works. We have to refactor more.
  prefs: []
  type: TYPE_NORMAL
- en: The procedural code was easy in the sense that it was simply top to bottom coding.
    Now that we have placed our code into a class, we have to move all callback functions
    into methods. This works, but does take some work to translate our original code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our procedural code looked like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We moved the callback methods to the top of the module, inside the new OOP class.
    We moved all the widget creation code into one rather long method, which we call
    in the initializer of the class.
  prefs: []
  type: TYPE_NORMAL
- en: Technically, deep underneath the hood of low-level code, Python does have a
    constructor, yet Python frees us from any worries about this. It is taken care
    of for us.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, in addition to a "real" constructor, Python provides us with an initializer.
  prefs: []
  type: TYPE_NORMAL
- en: We are strongly encouraged to use this initializer. We can use it to pass in
    parameters to our class, initializing variables we wish to use inside of our class
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Python, several classes can exist within the same Python module.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike Java, which has a very rigid naming convention (without which it does
    not work), Python is much more flexible.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can create multiple classes within the same Python module. Unlike Java, we
    do not depend on a file name that has to match each class name.
  prefs: []
  type: TYPE_NORMAL
- en: Python truly rocks!
  prefs: []
  type: TYPE_NORMAL
- en: Once our Python GUI gets large, we will break some classes out into their own
    modules but, unlike Java, we do not have to. In this book and project, we will
    keep some classes in the same module, while at the same time, we will break out
    some other classes into their own modules, importing them into what can be considered
    as a main() function (this is not C, but we can think C-like because Python is
    very flexible).
  prefs: []
  type: TYPE_NORMAL
- en: What we have achieved so far is to add the `ToolTip` class to our Python module
    and refactor our procedural Python code into OOP Python code.
  prefs: []
  type: TYPE_NORMAL
- en: Here, in this recipe, we can see that more than one class can live in the same
    Python module.
  prefs: []
  type: TYPE_NORMAL
- en: Cool stuff, indeed!
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_04_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Both the `ToolTip` class and the `OOP` class reside within the same Python module.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_04_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we advanced our procedural code into object-oriented-programming
    (OOP) code.
  prefs: []
  type: TYPE_NORMAL
- en: Python enables us to write code in both a practical, procedural style like the
    C-programming language.
  prefs: []
  type: TYPE_NORMAL
- en: At the same time, we have the option to code in an OOP style, like Java, C#,
    and C++.
  prefs: []
  type: TYPE_NORMAL
- en: Writing callback functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At first, callback functions can seem to be a little bit intimidating. You call
    the function, passing it some arguments, and now the function tells you that it
    is really very busy and it will call you back!
  prefs: []
  type: TYPE_NORMAL
- en: 'You wonder: "Will this function *ever* call me back?" "And how long do I have
    to *wait*?"'
  prefs: []
  type: TYPE_NORMAL
- en: In Python, even callback functions are easy and, yes, they usually do call you
    back.
  prefs: []
  type: TYPE_NORMAL
- en: They just have to complete their assigned task first (hey, it was you who coded
    them in the first place…).
  prefs: []
  type: TYPE_NORMAL
- en: Let us understand a little bit more about what happens when we code callbacks
    into our GUI.
  prefs: []
  type: TYPE_NORMAL
- en: Our GUI is event-driven. After it has been created and displayed onscreen, it
    typically sits there waiting for an event to happen. It is basically waiting for
    an event to be sent to it. We can send an event to our GUI by clicking one of
    its action buttons.
  prefs: []
  type: TYPE_NORMAL
- en: This creates an event and, in a sense, we "called" our GUI by sending it a message.
  prefs: []
  type: TYPE_NORMAL
- en: Now, what is supposed to happen after we send a message to our GUI?
  prefs: []
  type: TYPE_NORMAL
- en: What happens after clicking the button depends on whether we created an event
    handler and associated it with this button. If we did not create an event handler,
    clicking the button will have no effect.
  prefs: []
  type: TYPE_NORMAL
- en: The event handler is a callback function (or method, if we use classes).
  prefs: []
  type: TYPE_NORMAL
- en: The callback method is also sitting there passively, like our GUI, waiting to
    be invoked.
  prefs: []
  type: TYPE_NORMAL
- en: Once our GUI gets its button clicked, it will invoke the callback.
  prefs: []
  type: TYPE_NORMAL
- en: The callback often does some processing and, when done, it returns the result
    to our GUI.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a sense, we can see that our callback function is calling back to our GUI.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Python interpreter runs through all the code in a project once, finding
    any syntax errors and pointing them out. You cannot run your Python code if you
    do not have the syntax right. This includes indentation (if not resulting in a
    syntax error, wrong indentation usually results in a bug).
  prefs: []
  type: TYPE_NORMAL
- en: On the next parsing round, the interpreter interprets our code and runs it.
  prefs: []
  type: TYPE_NORMAL
- en: At runtime, many GUI events can be generated and it is usually callback functions
    that add functionality to GUI widgets.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is the callback for the Spinbox widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_04_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created a callback method in the `OOP` class, which gets called when we select
    a value from the Spinbox widget because we bound the method to the widget via
    the `command` argument (`command=self._spin`). We use a leading underscore to
    hint at the fact that this method should be respected like a private Java method.
  prefs: []
  type: TYPE_NORMAL
- en: Python intentionally avoids language restrictions such as private, public, friend,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In Python, we use naming conventions instead. Leading and trailing double underscores
    surrounding a keyword are expected to be restricted to the Python language, and
    we should not use them in our own Python code.
  prefs: []
  type: TYPE_NORMAL
- en: However, we can use a leading underscore prefix to a variable name or function
    to provide a hint that this name should be respected as a private helper.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the same time, we can postfix a single underscore if we wish to use what
    otherwise would be Python built-in names. For example, if we wished to abbreviate
    the length of a list, we could do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Often, the underscore is hard to read and easy to oversee, so this might not
    be the best idea in practice.
  prefs: []
  type: TYPE_NORMAL
- en: Creating reusable GUI components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are creating reusable GUI components using Python.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will keep it simple by moving our `ToolTip` class into its
    own module. Next, we will import and use it for displaying tooltips over several
    widgets of our GUI.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are building on our previous code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will start by breaking out our `ToolTip` class into a separate Python module.
    We will slightly enhance it to pass in the control widget and the tooltip text
    we wish to display when we hover the mouse over the control.
  prefs: []
  type: TYPE_NORMAL
- en: We create a new Python module and place the `ToolTip` class code into it and
    then import this module into our primary module.
  prefs: []
  type: TYPE_NORMAL
- en: We then reuse the imported `ToolTip` class by creating several tooltips, which
    can be seen when hovering the mouse over several of our GUI widgets.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring our common `ToolTip` class code out into its own module helps us
    to reuse this code from other modules. Instead of copy/paste/modify we use the
    DRY principle and our common code is located in only one place, so when we modify
    the code, all modules that import it will automatically get the latest version
    of our module.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: DRY stands for Don't Repeat Yourself and we will look at it again in a later
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We can do similar things by turning our Tab3 image into a reusable component.
  prefs: []
  type: TYPE_NORMAL
- en: To keep this recipe's code simple, we removed Tab 3, but you can experiment
    with the code from the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_04_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This also works on the second tab.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_04_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The new code structure looks like this now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_04_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The import statement looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_04_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And the broken out (aka refactored) code in a separate module looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_04_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the preceding screenshots, we can see several tooltip messages being displayed.
    The one for the main window might appear a little bit annoying, so it is better
    not to display a tooltip for the main window because we really wish to highlight
    the functionality of the individual widgets. The main window form has a title
    that explains its purpose; no need for a tooltip.
  prefs: []
  type: TYPE_NORMAL
