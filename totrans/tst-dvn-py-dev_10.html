<html><head></head><body>
  <div id="sbo-rt-content"><div class="chapter" title="Chapter 10. Tools to Improve Test-Driven Development"><div class="titlepage"><div><div><h1 class="title"><a id="ch10"/>Chapter 10. Tools to Improve Test-Driven Development</h1></div></div></div><p>Up to this point, we have mostly been looking at how to write and run tests. In this chapter, we will turn our attention to integrating the tests with the wider development environment. Having tests integrated into the development environment is important because it allows us to set up an automated process through which tests are executed regularly. We will also look at other tools that can improve the way we do TDD—from other test runners to libraries that make asserting easier.</p><div class="section" title="TDD tools"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec69"/>TDD tools</h1></div></div></div><p>We looked at <a id="id464" class="indexterm"/>the nose2 test runner earlier in this book. Python has other popular third-party test runners. Python also has a number of libraries to make assertions more flexible and readable. These libraries can be used with both <code class="literal">unittest</code> compatible tests and the function style tests supported by third-party test runners. Let us take a look at some of these TDD tools.</p><div class="section" title="py.test"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec74"/>py.test</h2></div></div></div><p>Like<a id="id465" class="indexterm"/> nose2, py.test is another popular third-party test runner. py.test supports <a id="id466" class="indexterm"/>many features like the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Writing<a id="id467" class="indexterm"/> tests as ordinary functions.</li><li class="listitem" style="list-style-type: disc">Using Python's <code class="literal">assert</code> statement to perform asserts.</li><li class="listitem" style="list-style-type: disc">Ability to skip tests or mark tests as expected failures.</li><li class="listitem" style="list-style-type: disc">Fixtures with setup and teardown support.</li><li class="listitem" style="list-style-type: disc">Extensible plugin framework, with plugins available to do popular functionality such as XML output, coverage reporting, and running tests in parallel across multiple processors or cores.</li><li class="listitem" style="list-style-type: disc">Tag tests with attributes.</li><li class="listitem" style="list-style-type: disc">Integration<a id="id468" class="indexterm"/> with popular tools.</li></ul></div><p>One <a id="id469" class="indexterm"/>of py.test's most unique features is funcargs. Take a look at the following code:</p><div class="informalexample"><pre class="programlisting">import pytest

@pytest.fixture
def goog():
    return Stock("GOOG")

def test_stock_update(goog):
    assert goog.price is None</pre></div><p>In this <a id="id470" class="indexterm"/>code, the <code class="literal">test_stock_update</code> function takes a parameter called <code class="literal">goog</code>. Additionally, we have a function called <code class="literal">goog</code>, which is marked with the <code class="literal">pytest.fixture</code> decorator. PyTest will match these two, call the appropriate fixture, and pass in the return value as a parameter to the test.</p><p>This solves the following two problems:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It enables us to pass fixture values to function style test cases without having to resort to globals.</li><li class="listitem" style="list-style-type: disc">Instead of writing a large fixture, we can create many small ones, and the test cases only use the fixtures that they need. This makes it easier to read test cases as we don't have to look at a large fixture setup that has different lines of setup meant for different tests.</li></ul></div><p>The above example only scratches the surface of funcargs. <code class="literal">py.test</code> supports a number of other usage scenarios with funcargs. Definitely check out this popular test runner.</p><div class="section" title="py.test versus nose2"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec03"/>py.test versus nose2</h3></div></div></div><p>There isn't a<a id="id471" class="indexterm"/> lot to choose between nose2 and py.test. nose2 has a unique<a id="id472" class="indexterm"/> feature in writing tests using layers, while py.test has a unique feature in funcargs. Apart from that, both support running of <code class="literal">unittest</code> test cases, both have a robust plugin framework, and both can be integrated with all the tools we discuss in this chapter. The decision between them really comes down to a personal choice between layers versus funcargs, or if one supports a particular plugin that we <a id="id473" class="indexterm"/>really want. Definitely take a look at py.test at its homepage at <a class="ulink" href="http://pytest.org/latest/">http://pytest.org/latest/</a>.</p></div></div><div class="section" title="Trial"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec75"/>Trial</h2></div></div></div><p>Trial is a <a id="id474" class="indexterm"/>unit test runner that was originally built for testing Python's Twisted framework. Trial supports running vanilla unit tests written using the <code class="literal">unittest</code> module, as <a id="id475" class="indexterm"/>well as advanced features specifically for supporting applications based on network programming—clients, servers, and the like. The most important of these is support for asynchronous programming models, where a method might return immediately, but the actual return value is received later on. This is usually done using a concept called <code class="literal">Deferred</code>. Since this is a deep and niche topic, we won't go into a detailed discussion in this book. Just keep in mind that if you are doing anything with network programming, event-based systems, or asynchronous programming, then you should check out<a id="id476" class="indexterm"/> Trial at its homepage at <a class="ulink" href="http://twistedmatrix.com/trac/wiki/TwistedTrial">http://twistedmatrix.com/trac/wiki/TwistedTrial</a>.</p></div><div class="section" title="Sure"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec76"/>Sure</h2></div></div></div><p>Sure is a <a id="id477" class="indexterm"/>Python library to help write assertions that are easier to read. It is a <a id="id478" class="indexterm"/>Python port of the should.js JavaScript library.</p><p>With Sure, we can take the following test:</p><div class="informalexample"><pre class="programlisting">def test_stock_update(self):
    """An update should set the price on the stock object

    We will be  using the `datetime` module for the timestamp
    """
    self.goog.update(datetime(2014, 2, 12), price=10)
    self.assertEqual(10, self.goog.price)</pre></div><p>And, rewrite it to look like the following:</p><div class="informalexample"><pre class="programlisting">def test_stock_update(self):
    self.goog.update(datetime(2014, 2, 12), price=10)
    self.goog.price.should.equal(10)</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note27"/>Note</h3><p>Notice how the assert has been replaced with a statement that reads like regular English. Sure adds a bunch of attributes to all objects to allow us to write asserts like this.</p></div></div><p>The following is how our float test would look like in Sure:</p><div class="informalexample"><pre class="programlisting">def test_stock_price_should_give_the_latest_price(self):
    self.goog.update(datetime(2014, 2, 12), price=10)
    self.goog.update(datetime(2014, 2, 13), price=8.4)
    self.goog.price.should.equal(8.4, epsilon=0.0001)</pre></div><p>And, the following is how we would check for expected exceptions:</p><div class="informalexample"><pre class="programlisting">def test_negative_price_should_throw_ValueError(self):
    self.goog.update.when.called_with(datetime(2014, 2, 13), -1).\
        should.throw(ValueError)</pre></div><p>Sure also supports using Python's <code class="literal">assert</code> statement as follows:</p><div class="informalexample"><pre class="programlisting">def test_stock_update(self):
    self.goog.update(datetime(2014, 2, 12), price=10)
    assert self.goog.price.should.equal(10)</pre></div><p>Sure <a id="id479" class="indexterm"/>supports a large number of expressions like the one above to express a<a id="id480" class="indexterm"/> multitude of assertion conditions.</p><p>Sure uses some monkey patching to add these attributes to all objects. The monkey patching is done once the <code class="literal">import sure</code> statement is executed. For this reason, be careful to use Sure only on unit test files and not in any production file.</p><p>Monkey patching can be disabled by setting the <code class="literal">SURE_DISABLE_NEW_SYNTAX</code> environment variable to true before running tests. When monkey patching is disabled, Sure supports an alternate syntax using the expect function as follows:</p><div class="informalexample"><pre class="programlisting">def test_stock_price_should_give_the_latest_price(self):
    self.goog.update(datetime(2014, 2, 12), price=10)
    self.goog.update(datetime(2014, 2, 13), price=8.4)
    expect(self.goog.price).should.equal(8.4, epsilon=0.0001)</pre></div><p>Full details on all <a id="id481" class="indexterm"/>available methods and syntax are available on the Sure homepage at <a class="ulink" href="http://falcao.it/sure/intro.html">http://falcao.it/sure/intro.html</a>.</p><p>Since assertions are plain functions, we can use this library even when writing function style tests supported by nose2 and py.test.</p></div><div class="section" title="PyHamcrest"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec77"/>PyHamcrest</h2></div></div></div><p>PyHamcrest is<a id="id482" class="indexterm"/> a Python port of the Java Hamcrest library. This is <a id="id483" class="indexterm"/>another library to enable us to write cleaner and more flexible asserts.</p><p>PyHamcrest defines its own <code class="literal">assert_that</code> function and a number of matchers such as <code class="literal">equal_to</code>. Using them, we can write a test like the following:</p><div class="informalexample"><pre class="programlisting">def test_stock_update(self):
    self.goog.update(datetime(2014, 2, 12), price=10)
    assert_that(self.goog.price, equal_to(10))</pre></div><p>PyHamcrest also has a system for writing custom matchers by inheriting from the <code class="literal">BaseMatcher</code> class. The following is a custom matcher that checks whether a stock has the crossover signal returning a particular value:</p><div class="informalexample"><pre class="programlisting">class StockCrossoverMatcher(BaseMatcher):
    signal_names = {
        StockSignal.buy: "buy",
        StockSignal.sell: "sell",
        StockSignal.neutral: "neutral"
    }

    def __init__(self, signal, date_to_check):
        self.signal = signal
        self.date_to_check = date_to_check

    def _matches(self, item):
        return self.signal == \
            item.get_crossover_signal(self.date_to_check)

    def describe_to(self, description):
        signal_name = self.signal_names[self.signal]
        return description.append_text(
                "stock crossover signal is {} ".format(signal_name))</pre></div><p>The class<a id="id484" class="indexterm"/> defines two methods: <code class="literal">_matches</code> and <code class="literal">describe_to</code>.</p><p>The <code class="literal">_matches</code> method <a id="id485" class="indexterm"/>takes the first parameter for the <code class="literal">assert_that</code> function call and returns whether it matches the given condition or not. In this case, we call the <code class="literal">get_crossover_signal</code> method and check whether it matches the signal that we were expecting.</p><p>The <code class="literal">describe_to</code> method returns a text description that is used for the message displayed when the assertion fails.</p><p>We also define a convenience function <code class="literal">is_buy_on</code>, which returns a matcher to match the <code class="literal">StockSignal.buy</code> signal as follows:</p><div class="informalexample"><pre class="programlisting">def is_buy_on(date_to_check):
    return StockCrossoverMatcher(StockSignal.buy, date_to_check)</pre></div><p>With this, we can write a test like the following:</p><div class="informalexample"><pre class="programlisting">def test_with_upward_crossover_returns_buy(self):
    self.given_a_series_of_prices([
        29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 46])
    assert_that(self.goog, is_buy_on(datetime(2014, 2, 13)))</pre></div><p>Like Sure, PyHamcrest assertions are plain functions and are suitable for use in function style tests supported by<a id="id486" class="indexterm"/> nose2 and py.test. You can visit PyHamcrest's homepage at <a class="ulink" href="https://github.com/hamcrest/PyHamcrest">https://github.com/hamcrest/PyHamcrest</a>.</p></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Integrating with build tools"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec70"/>Integrating with build tools</h1></div></div></div><p>It just takes a single line to execute our test cases. Then why would we want to integrate with build tools? Build tools support pre-requisites, so by integrating with such tools, we can ensure<a id="id487" class="indexterm"/> the tests are run before performing a critical task. An example would be to run all the tests before deploying the code to production.</p><div class="section" title="Paver"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec78"/>Paver</h2></div></div></div><p>Paver is a <a id="id488" class="indexterm"/>popular Python-based build tool. It is built around the concept<a id="id489" class="indexterm"/> of tasks. Tasks are a sequence of commands that perform a particular action, such as building the application or running unit tests. Tasks are coded in regular Python and placed in a file called <code class="literal">pavement.py</code> in the project root.</p><p>We want to create a task that will run our unit tests. The following is how we can do that in Paver:</p><div class="informalexample"><pre class="programlisting">import subprocess
from paver.easy import task, consume_args, options, needs

@task
@consume_args
def test():
    args = []
    if hasattr(options, "args"):
        args = options.args
    p = subprocess.Popen(["python", "-m", "unittest"] + args)
    p.wait()
    return p.returncode</pre></div><p>The task above simply runs a command to execute the <code class="literal">unittest</code> module. We use the <code class="literal">@consume_args</code> decorator, which tells Paver to take all the command line parameters and pass it to this task.</p><p>To run this Paver task, we simply execute the following on the command line:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>paver test -t . -s stock_alerter</strong></span>
</pre></div><p>If we are using nose2, then we can modify the task as follows:</p><div class="informalexample"><pre class="programlisting">import subprocess
from paver.easy import task, consume_args, options, needs

@task
@consume_args
def test():
    args = []
    if hasattr(options, "args"):
        args = options.args
    p = subprocess.Popen(["nose2"] + args)
    p.wait()
    return p.returncode</pre></div><p>Once we have the task, then we can use it in other tasks like the following:</p><div class="informalexample"><pre class="programlisting">@needs("test")
def deploy():
    # put the deployment commands here
    pass</pre></div><p>This <a id="id490" class="indexterm"/>will <a id="id491" class="indexterm"/>run the <code class="literal">test</code> task every time the <code class="literal">deploy</code> task is executed. Only if the tests pass will the deployment of the code take place.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Integrating with packaging tools"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec71"/>Integrating with packaging tools</h1></div></div></div><p>Packaging refers to how Python packages are generally distributed to users. Unless we are writing<a id="id492" class="indexterm"/> proprietary commercial software, we will want to distribute the unit tests along with the code and allow the end user to run the tests and verify that everything is working.</p><p>Packaging tools have been one of the most confusing parts of the Python ecosystem. There have been a number of different frameworks that, at different points, have been "the right way" to do things. As this book is being written, setuptools is the recommended way to package Python modules, so let us take a look at that first.</p><div class="section" title="Setuptools"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec79"/>Setuptools</h2></div></div></div><p>Setuptools<a id="id493" class="indexterm"/> supports a test command for running the test suite. All we<a id="id494" class="indexterm"/> need to do is to configure it. We do this by specifying the <code class="literal">test_suite</code> parameter in <code class="literal">setup.py</code> as follows:</p><div class="informalexample"><pre class="programlisting">from setuptools import setup, find_packages

setup(
    name="StockAlerter",
    version="0.1",
    packages=find_packages(),
    test_suite="stock_alerter.tests",
)</pre></div><p>When we do this, setuptools will pick up and run all the tests with the following command:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>python setup.py test</strong></span>
</pre></div><p>The configuration <a id="id495" class="indexterm"/>above will only run the <code class="literal">unittest</code> compatible<a id="id496" class="indexterm"/> tests. We can't run any nose2 tests nor can we use nose2 plugins. Fortunately, nose2 also supports integration with setuptools. The <code class="literal">nose2.collector.collector</code> function returns a compatible test suite which setuptools can run. The following test suite executes all the tests found by nose2:</p><div class="informalexample"><pre class="programlisting">from setuptools import setup, find_packages

setup(
    name="StockAlerter",
    version="0.1",
    packages=find_packages(),
    tests_require=["nose2"],
    test_suite="nose2.collector.collector",</pre></div><p>The <code class="literal">tests_require</code> parameter can be set to the packages that are required for running tests. We put <code class="literal">nose2</code> here, so even if the end user doesn't have nose2 installed, setuptools will install it for us before running the tests. If we use any third-party nose2 plugins, we can add those to the list here.</p><p>We can't pass any parameters when running tests this way. All configuration needs to be done in <code class="literal">nose2.cfg</code>. If there are some special settings that we would like to use only with the <code class="literal">setuptools</code> test command, we can put those in a special <code class="literal">setup.cfg</code> file. The settings in this file are used only when the nose tests are run via setuptools.</p><p>To integrate py.test with setuptools, we need to use the <code class="literal">cmdclass</code> technique that we use in the <code class="literal">distutils</code> integration in the following.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Distutils"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec72"/>Distutils</h1></div></div></div><p>Python comes bundled <a id="id497" class="indexterm"/>with its own packaging system called <span class="strong"><strong>distutils</strong></span>. Although setuptools is the preferred way, we might sometimes want to stick with distutils because it is bundled in the standard library.</p><p>Distutils supports adding custom commands to setup.py. We're going to use that feature to add a command that will run our tests. The following is what it looks like:</p><div class="informalexample"><pre class="programlisting">import subprocess
from distutils.core import setup, Command

class TestCommand(Command):

    user_options = []

    def initialize_options(self):
        pass

    def finalize_options(self):
        pass

    def run(self):
        p = subprocess.Popen(["python", "-m", "unittest"])
        p.wait()
        raise SystemExit(p.returncode)

setup(
    name="StockAlerter",
    version="0.1",
    cmdclass={
        "test": TestCommand
    }
)</pre></div><p>The <code class="literal">cmdclass</code> option allows us to pass in a dict containing command names mapped to a command class. We <a id="id498" class="indexterm"/>configure the test command and map it to our <code class="literal">TestCommand</code> class.</p><p>The <code class="literal">TestCommand</code> class inherits from distutil's <code class="literal">Command</code> class. The <code class="literal">Command</code> class is an abstract base class; subclasses will need to create the <code class="literal">user_options</code> list as well as implement three methods: <code class="literal">initialize_options</code>, <code class="literal">finalize_options</code>, and <code class="literal">run</code>. We don't need to do anything in the first two methods, so we keep them empty.</p><p>The only method we need for our command is the <code class="literal">run</code> method. This method is called by distutils when the command is to be executed, and our implementation simply runs the shell command and returns the appropriate exit value.</p><p>The same technique can be used to run the nose2 tests or py.test tests as well.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Integrating with continuous integration tools"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec73"/>Integrating with continuous integration tools</h1></div></div></div><p>Continuous integration tools allow us to validate the integrity of our application by running the<a id="id499" class="indexterm"/> test suite on every commit. We can configure them to raise an alert if any of the tests are failing, or even if the test coverage level drops too low.</p><div class="section" title="Jenkins"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec80"/>Jenkins</h2></div></div></div><p>Jenkins is a popular Java-based continuous integration system. Integrating with Jenkins requires the <a id="id500" class="indexterm"/>nose2 runner because we will need to get<a id="id501" class="indexterm"/> output in an XML format.</p><p>The first thing we need to do is to configure Jenkins to run the unit tests as a part of the build. To do this, we add a shell step to the build and enter the command to run the tests. We need to enable the JUnit XML plugin and get coverage in XML format, as shown in the following screenshot:</p><div class="mediaobject"><img src="images/3125_10_01.jpg" alt="Jenkins"/></div><p>We then need to tell Jenkins where to find the unit test results. Select the <span class="strong"><strong>Publish JUnit test result report</strong></span> checkbox and enter the location of the nose2 unit test XML file, as shown in the following screenshot:</p><div class="mediaobject"><img src="images/3125_10_02.jpg" alt="Jenkins"/></div><p>Enable the <span class="strong"><strong>Publish Cobertura Coverage Report</strong></span> and select the location of the coverage XML output file, as shown in the following screenshot. The plugin also allows us to set alert limits for Line coverage. This will fail the build if coverage levels drop below the threshold specified here.</p><div class="mediaobject"><img src="images/3125_10_03.jpg" alt="Jenkins"/></div><p>Once the <a id="id502" class="indexterm"/>configuration is done, Jenkins will run tests on every<a id="id503" class="indexterm"/> build, and give us a nice trend report of the unit tests as well as coverage statistics, as shown in the following screenshot:</p><div class="mediaobject"><img src="images/3125_10_04.jpg" alt="Jenkins"/></div><p>We can <a id="id504" class="indexterm"/>also dig in deeper to see details about specific<a id="id505" class="indexterm"/> suites or tests from within Jenkins, as shown in the following screenshot:</p><div class="mediaobject"><img src="images/3125_10_05.jpg" alt="Jenkins"/></div></div><div class="section" title="Travis CI"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec81"/>Travis CI</h2></div></div></div><p>Travis CI is <a id="id506" class="indexterm"/>the hot new kid on the block, becoming <a id="id507" class="indexterm"/>very popular in the Python community for open source packages, as shown in the following screenshot:</p><div class="mediaobject"><img src="images/3125_10_06.jpg" alt="Travis CI"/></div><p>As a hosted service, it doesn't require any installation. Configuring Travis to run our unit tests is a<a id="id508" class="indexterm"/> breeze. All we need to do is to add the <a id="id509" class="indexterm"/>command to run the tests into the <code class="literal">script</code> section of the <code class="literal">.travis.yml</code> configuration file as follows:</p><div class="informalexample"><pre class="programlisting">script:
   - python -m unittest

or if we are using nose2:

script:
   - nose2</pre></div><p>That's it. Now Travis will execute the command with every commit and let us know if the tests fail for any reason.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Other tools"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec74"/>Other tools</h1></div></div></div><div class="section" title="tox"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec82"/>tox</h2></div></div></div><p>tox is a framework for maintaining a Python package across multiple versions of Python. For example, we<a id="id510" class="indexterm"/> can easily test that everything is working in Python 2.6 and<a id="id511" class="indexterm"/> Python 3.4. It works by creating virtual environments for each version and then running the unit tests under that environment.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note28"/>Note</h3><p>tox uses the virtualenv tool for creating virtual environments. This tool is bundled in the standard library with Python 3.4 and can be installed from PyPi for older version of Python. We don't cover this tool in this book, but if you aren't using it already, then do take a look at it.</p></div></div><p>A typical <code class="literal">tox</code> configuration file looks like the following:</p><div class="informalexample"><pre class="programlisting">[tox]
envlist = py33,py34

[testenv:py34]
deps = nose2
       sure
       pyhamcrest
commands = nose2

[testenv:py33]
deps = enum34
       sure
       pyhamcrest
commands = python -m unittest</pre></div><p>The configuration<a id="id512" class="indexterm"/> includes the list of Python versions to test against. Each environment<a id="id513" class="indexterm"/> can have its own dependencies installed that we require to run the tests as well as the command required to run the tests. This command can be the vanilla <code class="literal">unittest</code> command, or a third-party runner such as nose2 or py.test.</p><p>When tox is executed, it creates a virtual environment for each of the Python versions, installs the required dependencies, and runs our tests in that environment. tox can be integrated with continuous integration systems so that compatibility is maintained with each commit.</p></div><div class="section" title="Sphinx"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec83"/>Sphinx</h2></div></div></div><p>Sphinx is a <a id="id514" class="indexterm"/>documentation framework commonly used with Python projects. Sphinx supports embedding snippets of code examples within the documentation. Sphinx <a id="id515" class="indexterm"/>also has <code class="literal">sphinx.ext.doctest</code> plugin that can extract these code examples as doctests and run them to ensure that the documentation doesn't break.</p><p>The <code class="literal">sphinx.ext.doctest</code> plugin supports doctest fixtures for setup and teardown, and doctest options. Sphinx with the doctest plugin is a good option when our application requires a full-blown documentation system.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="IDE integration"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec75"/>IDE integration</h1></div></div></div><p>We haven't talked about IDE integration yet. This is because most of the popular Python IDEs have <a id="id516" class="indexterm"/>built-in support for running unit tests from within the IDE. It is almost a basic feature these days. In addition, there are plugins available for popular text editors such as vim, emacs, and Sublime Text 3. We won't cover each and every one of these since they are too numerous. It only takes a quick online search to get the configuration or plugins we need to run tests from within our favorite IDE or text editor.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec76"/>Summary</h1></div></div></div><p>In this chapter, you looked at some popular third-party tools to help us improve our TDD practice. Some of the tools such as <code class="literal">py.test</code> and <code class="literal">trial</code> are test runners with some unique features. Others such as <code class="literal">sure</code> and <code class="literal">pyhamcrest</code> are libraries that help us write cleaner tests. You looked at how we can integrate our unit tests into the wider development process: from putting them into the build environment and integrating with continuous integration tools, to enabling the <code class="literal">test</code> command when packaging our code. We then took a look at how we can maintain a package against multiple versions of Python and integrating tests into Sphinx so that our documentation doesn't break.</p></div></div>


  <div id="sbo-rt-content"><div class="appendix" title="Appendix A. Answers to Exercises"><div class="titlepage"><div><div><h1 class="title"><a id="appA"/>Appendix A. Answers to Exercises</h1></div></div></div><p>This Appendix contains answers to the exercises presented throughout this book. Keep in mind that there is no single correct solution for any of these exercises. There are many possible solutions, each with their own advantages and disadvantages. Wherever possible, I have mentioned why I took a certain path, so that you can see my reasoning and compare the pros and cons with the solution that you have come up with.</p><div class="section" title="Red-Green-Refactor – The TDD Cycle"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec77"/>Red-Green-Refactor – The TDD Cycle</h1></div></div></div><p>This exercise asks us to add support for updates which come out of order, that is, a newer update is followed by an older update. We need to use the timestamp to determine which update is newer and which is older.</p><p>The following is a test case for this requirement:</p><div class="informalexample"><pre class="programlisting">def test_price_is_the_latest_even_if_updates_are_made_out_of_order(self):
    self.goog.update(datetime(2014, 2, 13), price=8)
    self.goog.update(datetime(2014, 2, 12), price=10)
    self.assertEqual(8, self.goog.price)</pre></div><p>In the test above, we first give the update for February 13, followed by the update for February 12. We then assert that the price attribute returns the latest price (for February 13). The test fails of course.</p><p>In order to make this test pass, we can't simply add the latest update to the end of the <code class="literal">price_history</code> list. We need to check the timestamp and insert it accordingly into the list, keeping it sorted by timestamp.</p><p>The <code class="literal">bisect</code> module provided in the Python standard library contains the <code class="literal">insort_left</code> function that inserts into a sorted list. We can use this function as follows (remember to import bisect at the top of the file):</p><div class="informalexample"><pre class="programlisting">def update(self, timestamp, price):
    if price &lt; 0:
        raise ValueError("price should not be negative")
    bisect.insort_left(self.price_history, (timestamp, price))</pre></div><p>In order to have a sorted list, the <code class="literal">price_history</code> list needs to keep a list of tuples, with the timestamp as the first element. This will keep the list sorted by the timestamp. When we make this change, it breaks our other methods that expect the list to contain the price alone. We need to modify them as follows:</p><div class="informalexample"><pre class="programlisting">@property
def price(self):
    return self.price_history[-1][1] \
        if self.price_history else None

def is_increasing_trend(self):
    return self.price_history[-3][1] &lt; \
        self.price_history[-2][1] &lt; self.price_history[-1][1]</pre></div><p>With the above changes, all our existing tests as well as the new test start passing.</p><p>Now that we have the tests passing, we can look at refactoring the code to make it easier to read. Since the <code class="literal">price_history</code> list now contains tuples, we have to refer to the price element by tuple index, leading to statements list <code class="literal">price_history[-1][1]</code>, which are not very clear. We can make this clearer by using a named tuple that allows us to assign names to the tuple values. Our refactored Stock class now looks like the following:</p><div class="informalexample"><pre class="programlisting">PriceEvent = collections.namedtuple("PriceEvent", ["timestamp", "price"])

class Stock:
    def __init__(self, symbol):
        self.symbol = symbol
        self.price_history = []

    @property
    def price(self):
        return self.price_history[-1].price \
            if self.price_history else None

    def update(self, timestamp, price):
        if price &lt; 0:
            raise ValueError("price should not be negative")
        bisect.insort_left(self.price_history, PriceEvent(timestamp, price))

    def is_increasing_trend(self):
        return self.price_history[-3].price &lt; \
            self.price_history[-2].price &lt; \
                self.price_history[-1].price</pre></div><p>After the change, we run the tests to ensure that everything still works.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Code Smells and Refactoring"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec78"/>Code Smells and Refactoring</h1></div></div></div><p>This exercise asks us to refactor the <code class="literal">Stock</code> class and extract all the moving average related calculations into a new class.</p><p>The following is the code that we start with:</p><div class="informalexample"><pre class="programlisting">def get_crossover_signal(self, on_date):
    NUM_DAYS = self.LONG_TERM_TIMESPAN + 1
    closing_price_list = \
        self.history.get_closing_price_list(on_date, NUM_DAYS)

    if len(closing_price_list) &lt; NUM_DAYS:
        return StockSignal.neutral

    long_term_series = \
        closing_price_list[-self.LONG_TERM_TIMESPAN:]
    prev_long_term_series = \
        closing_price_list[-self.LONG_TERM_TIMESPAN-1:-1]
    short_term_series = \
        closing_price_list[-self.SHORT_TERM_TIMESPAN:]
    prev_short_term_series = \
        closing_price_list[-self.SHORT_TERM_TIMESPAN-1:-1]

    long_term_ma = sum([update.value
                        for update in long_term_series])\
                    /self.LONG_TERM_TIMESPAN
    prev_long_term_ma = sum([update.value
                             for update in prev_long_term_series])\
                         /self.LONG_TERM_TIMESPAN
    short_term_ma = sum([update.value
                         for update in short_term_series])\
                    /self.SHORT_TERM_TIMESPAN
    prev_short_term_ma = sum([update.value
                              for update in prev_short_term_series])\
                         /self.SHORT_TERM_TIMESPAN

    if self._is_crossover_below_to_above(prev_short_term_ma,
                                         prev_long_term_ma,
                                         short_term_ma,
                                         long_term_ma):
                return StockSignal.buy

    if self._is_crossover_below_to_above(prev_long_term_ma,
                                         prev_short_term_ma,
                                         long_term_ma,
                                         short_term_ma):
                return StockSignal.sell

    return StockSignal.neutral</pre></div><p>As we can see, there are a number of calculations relating to identifying the moving average window and then calculating the moving average value. These calculations really deserve to be in their own class.</p><p>To start with, we create an empty <code class="literal">MovingAverage</code> class as follows:</p><div class="informalexample"><pre class="programlisting">class MovingAverage:
    pass</pre></div><p>Now we need to make a design decision on how we want this class to be used. Let us decide that the class should take an underlying timeseries and should be able to compute the moving average at any point based on that timeseries. With this design, the class needs to take the timeseries and the duration of the moving average as parameters, as shown in the following:</p><div class="informalexample"><pre class="programlisting">def __init__(self, series, timespan):
    self.series = series
    self.timespan = timespan</pre></div><p>We can now extract the moving average calculation into this class as follows:</p><div class="informalexample"><pre class="programlisting">class MovingAverage:
    def __init__(self, series, timespan):
        self.series = series
        self.timespan = timespan

    def value_on(self, end_date):
        moving_average_range = self.series.get_closing_price_list(
                                   end_date, self.timespan)
        if len(moving_average_range) &lt; self.timespan:
            raise NotEnoughDataException("Not enough data")
        price_list = [item.value for item in moving_average_range]
        return sum(price_list)/len(price_list)</pre></div><p>This is the same moving average calculation code from <code class="literal">Stock.get_signal_crossover</code>. The only notable point is that an exception is raised if there is not enough data to perform the calculation. Let us define this exception in the <code class="literal">timeseries.py</code> file as follows:</p><div class="informalexample"><pre class="programlisting">class NotEnoughDataException(Exception):
    pass</pre></div><p>We can now use this method in <code class="literal">Stock.get_signal_crossover</code> as follows:</p><div class="informalexample"><pre class="programlisting">def get_crossover_signal(self, on_date):
    prev_date = on_date - timedelta(1)
    long_term_ma = \
        MovingAverage(self.history, self.LONG_TERM_TIMESPAN)
    short_term_ma = \
        MovingAverage(self.history, self.SHORT_TERM_TIMESPAN)

    try:
        long_term_ma_value = long_term_ma.value_on(on_date)
        prev_long_term_ma_value = long_term_ma.value_on(prev_date)
        short_term_ma_value = short_term_ma.value_on(on_date)
        prev_short_term_ma_value = short_term_ma.value_on(prev_date)
    except NotEnoughDataException:
        return StockSignal.neutral

    if self._is_crossover_below_to_above(prev_short_term_ma_value,
                                         prev_long_term_ma_value,
                                         short_term_ma_value,
                                         long_term_ma_value):
                return StockSignal.buy

    if self._is_crossover_below_to_above(prev_long_term_ma_value,
                                         prev_short_term_ma_value,
                                         long_term_ma_value,
                                         short_term_ma_value):
                return StockSignal.sell

    return StockSignal.neutral</pre></div><p>Run the tests, and all 21 tests should pass.</p><p>Once we extract the calculation to a class, we find that the temporary variables that we created during <span class="emphasis"><em>Replace Calculation with Temporary Variable</em></span> section in <a class="link" href="ch03.html" title="Chapter 3. Code Smells and Refactoring">Chapter 3</a>, <span class="emphasis"><em>Code Smells and Refactoring</em></span> are not really required. The code is equally self-explanatory without them, so we can now get rid of them, as shown in the following:</p><div class="informalexample"><pre class="programlisting">def get_crossover_signal(self, on_date):
    prev_date = on_date - timedelta(1)
    long_term_ma = \
        MovingAverage(self.history, self.LONG_TERM_TIMESPAN)
    short_term_ma = \
        MovingAverage(self.history, self.SHORT_TERM_TIMESPAN)

    try:
        if self._is_crossover_below_to_above(
                short_term_ma.value_on(prev_date),
                long_term_ma.value_on(prev_date),
                short_term_ma.value_on(on_date),
                long_term_ma.value_on(on_date)):
            return StockSignal.buy

        if self._is_crossover_below_to_above(
                long_term_ma.value_on(prev_date),
                short_term_ma.value_on(prev_date),
                long_term_ma.value_on(on_date),
                short_term_ma.value_on(on_date)):
            return StockSignal.sell
    except NotEnoughDataException:
        return StockSignal.neutral

    return StockSignal.neutral</pre></div><p>A final cleanup: now that we have moving average classes, we can replace the parameters to the <code class="literal">_is_crossover_below_to_above</code> method to take the moving average class instead of the individual values. The method now becomes as follows:</p><div class="informalexample"><pre class="programlisting">def _is_crossover_below_to_above(self, on_date, ma, reference_ma):
    prev_date = on_date - timedelta(1)
    return (ma.value_on(prev_date)
                &lt; reference_ma.value_on(prev_date)
            and ma.value_on(on_date)
                &gt; reference_ma.value_on(on_date))</pre></div><p>And we can change the <code class="literal">get_crossover_signal</code> method to call this with the new parameters as follows:</p><div class="informalexample"><pre class="programlisting">def get_crossover_signal(self, on_date):
    long_term_ma = \
        MovingAverage(self.history, self.LONG_TERM_TIMESPAN)
    short_term_ma = \
        MovingAverage(self.history, self.SHORT_TERM_TIMESPAN)

    try:
        if self._is_crossover_below_to_above(
                on_date,
                short_term_ma,
                long_term_ma):
            return StockSignal.buy

        if self._is_crossover_below_to_above(
                on_date,
                long_term_ma,
                short_term_ma):
            return StockSignal.sell
    except NotEnoughDataException:
        return StockSignal.neutral

    return StockSignal.neutral</pre></div><p>With this, our Extract Class refactoring is complete.</p><p>The <code class="literal">get_crossover_signal</code> class is now extremely easy to read and understand.</p><p>Notice how the design for the <code class="literal">MovingAverage</code> class builds on top of the <code class="literal">TimeSeries</code> class that we extracted earlier. As we refactor code and extract classes, we often find that the many classes get reused in other contexts. This is the advantage of having small classes with a single responsibility.</p><p>The refactoring into a separate class also allowed us to remove the temporary variables that we had created earlier, and made the parameters for the crossover condition much simpler. Again, these are side effects of having small classes with single responsibilities.</p></div></div>


  <div id="sbo-rt-content"><div class="appendix" title="Appendix B. Working with Older Python Versions"><div class="titlepage"><div><div><h1 class="title"><a id="appB"/>Appendix B. Working with Older Python Versions</h1></div></div></div><p>This book has been written for Python 3.4. The version of <code class="literal">unittest</code> that comes with the Python 2.x standard library is an older version that doesn't support all the features that we discussed in this book. Additionally, the <code class="literal">mock</code> library was only made a part of the standard library from Python 3.3 onward.</p><p>Fortunately, all the features present in the newer versions of Python have been backported under the <code class="literal">unittest2</code> library. We can install this version from PyPi with the following <a id="id517" class="indexterm"/>command:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>pip install unittest2</strong></span>
</pre></div><p>Once installed, we<a id="id518" class="indexterm"/> have to use the <code class="literal">unittest2</code> library in all references like the following:</p><div class="informalexample"><pre class="programlisting">import unittest2

class StockTest(unittest2.TestCase):
    ...</pre></div><p>With these changes, we will be able to use all the features that we have been discussing in this book in all versions from Python 2.5 onward.</p><p>The same<a id="id519" class="indexterm"/> goes for the mocking library as well. The <code class="literal">mock</code> library was only <a id="id520" class="indexterm"/>added to the standard library with Python 3.3. The current mock library has been backported and is also available from PyPi. We can install it with the following command:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>pip install mock</strong></span>
</pre></div><p>And we import it with the following command:</p><div class="informalexample"><pre class="programlisting">import mock</pre></div><p>We can then use all the mocking goodness discussed in this book with earlier versions of Python as well.</p><div class="section" title="Writing code that is compatible across versions"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec79"/>Writing code that is compatible across versions</h1></div></div></div><p>Many Python modules these days are designed to run under multiple Python versions, especially<a id="id521" class="indexterm"/> supporting Python 2.x as well as Python 3.x versions. We will want to run the same tests in both versions, and to do this, we will need to write our code in such a way that the tests are compatible with both the versions.</p><p>Python's import mechanism gives us the flexibility we need to do this. At the top of the file, we import <code class="literal">unittest</code> like the following:</p><div class="informalexample"><pre class="programlisting">try:
   import unittest2 as unittest
except ImportError:
   import unittest</pre></div><p>What this does is to first try and import <code class="literal">unittest2</code>. If we are running Python 2.x, then we should have installed this already. If it succeeds, then the module is imported and the module reference is renamed to <code class="literal">unittest</code>.</p><p>If we get an <code class="literal">ImportError</code>, then we are running Python 3.x, in which case we can import the <code class="literal">unittest</code> module bundled in the standard library.</p><p>Later in the code, we can just reference the <code class="literal">unittest</code> module and it will work normally.</p><p>This mechanism depends on the <code class="literal">unittest2</code> module being always installed when using Python 2.x version. This is easily achieved by putting the <code class="literal">unittest2</code> module as a dependency for only Python 2.x in our pip requirements file.</p><p>A similar approach works for mocks as follows:</p><div class="informalexample"><pre class="programlisting">try:
   from unittest import mock
except ImportError:
   import mock</pre></div><p>Here we first try to import the <code class="literal">mock</code> library provided as a part of the <code class="literal">unittest</code> standard library module. This is available in Python 3.3 onward. If the import succeeds, then the mock library is imported. If it fails, it means that we are running an older Python version, so we directly import the <code class="literal">mock</code> library that we installed from PyPi.</p><p>Note how we use the line <code class="literal">from unittest import mock</code> instead of <code class="literal">import unittest.mock</code>. This is so that we end up with the same module reference name in both the cases. Once the import is done, we can reference the <code class="literal">mock</code> module in our code and it will work across Python versions.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Running tests from the command line"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec80"/>Running tests from the command line</h1></div></div></div><p>Throughout the book, we have used the following syntax to run our tests:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>python.exe -m unittest</strong></span>
</pre></div><p>The ability<a id="id522" class="indexterm"/> to directly run a module with the <code class="literal">-m</code> flag was<a id="id523" class="indexterm"/> only introduced with Python 2.7. This syntax will not work if we are using an older version of Python. Instead, the <code class="literal">unittest2</code> module from PyPi contains a <code class="literal">unit2</code> script that mimics this behavior. The command line parameters remain the same, so we get the following the command:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>python3 -m unittest discover -s stock_alerter -t .</strong></span>
</pre></div><p>And the above command now becomes:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>unit2 discover -s stock_alerter -t .</strong></span>
</pre></div><p>If we use a build tool, it becomes fairly simple to check the version of Python and execute the appropriate command, thereby allowing the developer to run the tests in a uniform way, irrespective of the Python version being used.</p><p>With these changes in place, we will be able to use all the features described in this book, while being able to support Python 2.x and Python 3.x uniformly.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Running the examples in this book"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec81"/>Running the examples in this book</h1></div></div></div><p>The <a id="id524" class="indexterm"/>code examples in this book have been written for Python 3.4. They use some syntax that is not available in older versions of Python. Therefore, there are a few places we will need to change the code if we want to run the examples in, say, Python 2.6.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note29"/>Note</h3><p>The entire source code with all the changes below is available online at <a class="ulink" href="https://github.com/siddhi/test_driven_python">https://github.com/siddhi/test_driven_python</a>. Get this code if you would like to run the example code in this book under Python 2.6, 2.7, 3.0, 3.1, 3.2, or 3.3</p></div></div><p>The following changes are required:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Enum</code>: The <code class="literal">Enum</code> library is not in the standard library with older Python versions. It has been backported and can be installed from PyPi. Install the <code class="literal">Enum34</code> library to use this feature.</li><li class="listitem" style="list-style-type: disc"><code class="literal">set</code> syntax: Newer versions of Python support the single curly braces shorthand syntax to create <code class="literal">set</code> objects like<code class="literal">{"MSFT"}</code>. In older versions, we will need to explicitly create sets with this equivalent longhand syntax: <code class="literal">set(["MSFT"])</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">print</code> statement: <code class="literal">print</code> is defined as a statement in Python 2.x, so we cannot call it as a function, neither can we mock it out. We can get around this by<a id="id525" class="indexterm"/> adding the line <code class="literal">from __future__ import print_function</code> to the top of all the files that use <code class="literal">print</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">builtins</code>: The <code class="literal">builtins</code> module is called <code class="literal">__builtin__</code> in Python 2.x. Therefore, we need to use <code class="literal">__builtin__.print</code> or <code class="literal">__builtin__.open</code> when we want to mock the <code class="literal">print</code> or <code class="literal">open</code> functions.</li><li class="listitem" style="list-style-type: disc"><code class="literal">yield from</code> expression: This expression is not available in older Python versions. It has to be replaced with an iteration.</li><li class="listitem" style="list-style-type: disc"><code class="literal">mock_open</code>: This mock helper only mocks the <code class="literal">read</code> method in the backported version. It doesn't support mocking iteration on the file object. So, we need to change the implementation to not use iteration.</li></ul></div><p>With these changes, the examples in this book will work on Python 2.6 onward.</p></div></div>
</body></html>