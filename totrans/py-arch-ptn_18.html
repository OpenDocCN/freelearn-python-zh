<html><head></head><body><div><p>&#13;&#13;
    <h1 class="chapterNumber">14</h1>&#13;&#13;
    <h1 id="_idParaDest-259" class="chapterTitle">Profiling</h1>&#13;&#13;
    <p class="normal">It is quite common that written code doesn't behave perfectly after being tested with real data. Other than bugs, we can find the problem that the performance of the code is not adequate. Perhaps some requests are taking too much time, or perhaps the usage of memory is too high.</p>&#13;&#13;
    <p class="normal">In those cases, it's difficult to know exactly what the key elements are, that are taking the most time or memory. While it's possible to try to follow the logic, normally once the code is released, the bottlenecks will be at points that are almost impossible to know beforehand.</p>&#13;&#13;
    <p class="normal">To get information on what exactly is going on and follow the code flow, we can use profilers to dynamically analyze the code and better understand how the code is executed, in particular, where most time is spent. This can lead to adjustments and improvements affecting the most significant elements of the code, driven by data, instead of vague speculation.</p>&#13;&#13;
    <p class="normal">In this chapter, we'll cover the following topics:</p>&#13;&#13;
    <ul>&#13;&#13;
      <li class="bullet">Profiling basics</li>&#13;&#13;
      <li class="bullet">Types of profilers</li>&#13;&#13;
      <li class="bullet">Profiling code for time</li>&#13;&#13;
      <li class="bullet">Partial profiling</li>&#13;&#13;
      <li class="bullet">Memory profiling</li>&#13;&#13;
    </ul>&#13;&#13;
    <p class="normal">First, we will take a look at the basic principles of profiling.</p>&#13;&#13;
    <h1 id="_idParaDest-260" class="title">Profiling basics</h1>&#13;&#13;
    <p class="normal">Profiling is a <a id="_idIndexMarker909"/>dynamic analysis that instruments code to understand how it runs. This information is extracted and compiled in a way that can be used to get a better knowledge of a particular behavior based on a real case, as the code is running as usual. This information can be used to improve the code.</p>&#13;&#13;
    <div>&#13;&#13;
      <p class="Information-Box--PACKT-">Certain static analysis tools, as opposed to dynamic, can provide insight into aspects of the code. For example, they can be used to detect if certain code is dead code, meaning it's not called anywhere in the whole code. Or, they can detect some bugs, like the usage of variables that haven't been defined before, like when having a typo. But they don't work with the specifics of code that's actually being run. Profiling will bring specific data based on the use case instrumented and will return much more information on the flow of the code.</p>&#13;&#13;
    </p>&#13;&#13;
    <p class="normal">The <a id="_idIndexMarker910"/>normal application of profiling is to improve the performance of the code under analysis. By understanding how it executes in practice, it sheds light on the dynamics of the code modules and parts that could be causing problems. Then, actions can be taken in those specific areas.</p>&#13;&#13;
    <p class="normal">Performance can be understood in<a id="_idIndexMarker911"/> two ways: either <em class="italic">time performance</em> (how long code takes to execute) or <em class="italic">memory performance</em> (how much memory the code takes to execute). Both <a id="_idIndexMarker912"/>can be bottlenecks. Some code may take too long to execute or use a lot of memory, which may limit the hardware where it's executed.</p>&#13;&#13;
    <p>&#13;&#13;
      <p class="Tip--PACKT-">We will focus more on time performance in this chapter, as it is typically a bigger problem, but we will also explain how to use a memory profiler.</p>&#13;&#13;
    </p>&#13;&#13;
    <p class="normal">A common case in software development is that you don't really know what your code is going to do until it gets executed. Clauses to cover corner cases that appear rare may execute much more than expected, and software works differently when there are big arrays, as some algorithms may not be adequate. </p>&#13;&#13;
    <p class="normal">The problem is that doing that analysis before having the system running is incredibly difficult, and at most times, futile, as the problematic pieces of code will very likely be completely unexpected.</p>&#13;&#13;
    <blockquote class="packt_quote">Programmers waste enormous amounts of time thinking about, or worrying about, the speed of noncritical parts of their programs, and these attempts at efficiency actually have a strong negative impact when debugging and maintenance are considered. We should forget about small efficiencies, say about 97% of the time: <strong class="keyword">premature optimization is the root of all evil</strong>. Yet we should not pass up our opportunities in that critical 3%.&#13;&#13;
    <p class="normal" style="text-align: right;">Donald Knuth – Structured Programing with GOTO Statements - 1974.</p></blockquote>&#13;&#13;
    <p class="normal">Profiling gives us the ideal tool to <em class="italic">not</em> prematurely optimize, but to optimize according to real, tangible data. The<a id="_idIndexMarker913"/> idea is that you cannot optimize what you cannot measure. The profiler measures so it can be acted upon.</p>&#13;&#13;
    <p>&#13;&#13;
      <p class="Tip--PACKT-">The famous quote above is sometimes reduced to "premature optimization is the root of all evil," which is a bit reductionist and doesn't carry the nuance. Sometimes it's important to design elements with care and it's possible to plan in advance. As good as profiling (or other techniques) may be, they can only go so far. But it's important to understand, on most occasions, it's better to take the simple approach, as performance will be good enough, and it will be possible to improve it later in the few cases when it's not.</p>&#13;&#13;
    </p>&#13;&#13;
    <p class="normal">Profiling can be achieved in different ways, each with its pros and cons.</p>&#13;&#13;
    <h1 id="_idParaDest-261" class="title">Types of profilers</h1>&#13;&#13;
    <p class="normal">There are two main kinds of time profilers:</p>&#13;&#13;
    <ul>&#13;&#13;
      <li class="bullet"><strong class="keyword">Deterministic profilers</strong>, through <a id="_idIndexMarker914"/>a process of tracing. A deterministic profiler instruments the code and records each individual command. This <a id="_idIndexMarker915"/>makes deterministic profilers very detailed, as they can follow up the code on each step, but at the same time, the code is executed slower than without the instrumentation.</li>&#13;&#13;
      <li class="bullet">Deterministic profilers are not great to execute continuously. Instead, they can be activated in specific situations, like while running specific tests offline, to find out problems.</li>&#13;&#13;
      <li class="bullet"><strong class="keyword">Statistical profiles</strong>, through<a id="_idIndexMarker916"/> sampling. This kind of profiler, instead of instrumenting the code and detecting each operation, awakes at <a id="_idIndexMarker917"/>certain intervals and takes a sample of the current code execution stack. If this process is done for long enough, it captures the general execution of the program. </li>&#13;&#13;
    </ul>&#13;&#13;
    <p>&#13;&#13;
      <p class="Information-Box--PACKT-">Taking a sample of the stack is similar to taking a picture. Imagine a train or subway hall where people are moving across to go from one platform to another. Sampling is analogous to taking pictures at periodic intervals, for example, once every 5 minutes. Sure, it's not possible to get exactly who comes from one platform and goes to another, but after a whole day, it will provide good enough information on how many people have been around and what platforms are the most popular.</p>&#13;&#13;
    </p>&#13;&#13;
    <p class="bullet-para">While they don't give as detailed information as deterministic profiles, statistical profilers are <a id="_idIndexMarker918"/>much more lightweight and don't consume many resources. They can be enabled to constantly monitor live systems without interfering with their performance.</p>&#13;&#13;
    <p class="bullet-para">Statistical profilers <a id="_idIndexMarker919"/>only make sense on systems that are under relative load, as in a system that is not stressed, they'll show that most time is spent waiting.</p>&#13;&#13;
    <p class="bullet-para">Statistical profilers can be internal, if the sampling is done directly on the interpreter, or even external if it's a different program that is taking the samples. An external profiler has the advantage that, even if there's any problem with the sampling process, it won't interfere with the program being sampled.</p>&#13;&#13;
    <p class="normal">Both profilers can be seen as complementary. Statistical profilers are good tools for understanding the most-visited parts of the code and where the system, aggregated, is spending time. They live in the live system, where the real case usages determine the behavior of the system.</p>&#13;&#13;
    <p class="normal">The deterministic profilers are tools for analyzing specific use cases in the petri dish of the developer's laptop, where a specific task that is having some problem can be dissected and analyzed carefully, to be improved.</p>&#13;&#13;
    <p>&#13;&#13;
      <p class="Tip--PACKT-">In some respects, statistical profilers are analogous to metrics and deterministic profilers to logs. One displays the aggregated elements and the other the specific elements. Deterministic profilers, contrary to logs, are not ideal tools for using in live systems without care, though.</p>&#13;&#13;
    </p>&#13;&#13;
    <p class="normal">Typically, code will present <em class="italic">hotspots</em>, slow parts of it that get executed often. Finding the specific parts to focus attention on and then act on them is a great way to improve the overall speed.</p>&#13;&#13;
    <p class="normal">These hotspots can be revealed by profiling, either by<a id="_idIndexMarker920"/> checking the <em class="italic">global</em> hotspots using a statistical profiler<a id="_idIndexMarker921"/> or the <em class="italic">specific</em> hotspots for a task with a deterministic profiler. The first will display the specific parts of the code that are most used in general, which allows us to understand the pieces that get hit more often and take the most time in aggregate. The deterministic profiler can show, for a specific task, how long it takes for each line of code, and determine what are the slow elements.</p>&#13;&#13;
    <p>&#13;&#13;
      <p class="Tip--PACKT-">We won't look at statistical profilers as they require systems that are under load and they are difficult to create in a test<a id="_idIndexMarker922"/> that's fit for the scope of this book. You can <a id="_idIndexMarker923"/>check <code class="Code-In-Text--PACKT-">py-spy</code> (<a href="https://pypi.org/project/py-spy/">https://pypi.org/project/py-spy/</a>) or <code class="Code-In-Text--PACKT-">pyinstrument</code> (<a href="https://pypi.org/project/pyinstrument/">https://pypi.org/project/pyinstrument/</a>).</p>&#13;&#13;
    </p>&#13;&#13;
    <p class="normal">Another kind of profiler<a id="_idIndexMarker924"/> is the memory profiler. A memory profiler records when memory is increased and decreased, tracking the usage of memory. Profiling memory<a id="_idIndexMarker925"/> is typically used to find out memory leaks, which are rare for a Python program, but they can happen.</p>&#13;&#13;
    <p class="normal">Python has a garbage collector that releases memory automatically when an object is not referenced anymore. This happens without having to take any action, so compared with programs with manual memory assignment, like C/C++, the memory management is easier to handle. The garbage collection mechanism used for Python is called <em class="italic">reference counting</em>, and <a id="_idIndexMarker926"/>it frees memory immediately once a memory object is not used by anyone, as compared with other kinds of garbage collectors that wait.</p>&#13;&#13;
    <p class="normal">In the case of Python, memory leaks can<a id="_idIndexMarker927"/> be created by three main use cases, from more likely to least:</p>&#13;&#13;
    <ul>&#13;&#13;
      <li class="bullet">Some objects are still referenced, even if they are not used anymore. This can typically happen if there are long-lived objects that keep small elements in big elements, like lists of dictionaries when they are added and not removed.</li>&#13;&#13;
      <li class="bullet">An internal C extension is not managing the memory correctly. This may require further investigation with specific C profiling tools, which is out of scope for this book.</li>&#13;&#13;
      <li class="bullet">Complex reference cycles. A reference cycle is a group of objects that reference each other, e.g. object A references B and object B references A. While Python has algorithms to detect them and release the memory nonetheless, there's the small possibility that the garbage collector is disabled or any other bug problem. You can see more information<a id="_idIndexMarker928"/> on the Python garbage collector here: <a href="https://docs.python.org/3/library/gc.html">https://docs.python.org/3/library/gc.html</a>.</li>&#13;&#13;
    </ul>&#13;&#13;
    <p class="normal">The most likely situation for extra usage of memory is an algorithm that uses a lot of memory, and detecting when the memory is allocated can be achieved with the help of a memory profiler.</p>&#13;&#13;
    <p>&#13;&#13;
      <p class="Information-Box--PACKT-">Memory profiling<a id="_idIndexMarker929"/> is typically more complicated and takes more effort than time profiling.</p>&#13;&#13;
    </p>&#13;&#13;
    <p class="normal">Let's introduce some code and profile it.</p>&#13;&#13;
    <h1 id="_idParaDest-262" class="title">Profiling code for time</h1>&#13;&#13;
    <p class="normal">We will start <a id="_idIndexMarker930"/>by creating a short program that will calculate and display all prime numbers up to a particular number. Prime numbers are numbers that are only divisible by themselves and one.</p>&#13;&#13;
    <p class="normal">We will start by taking a naïve approach first:</p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code">def check_if_prime(number):&#13;&#13;
    result = True&#13;&#13;
    for i in range(2, number):&#13;&#13;
        if number % i == 0:&#13;&#13;
            result = False&#13;&#13;
    return result&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">This code will take every number from 2 to the number under test (without including it), and check whether the number is divisible. If at any point it is divisible, the number is not a prime number.</p>&#13;&#13;
    <p class="normal">To calculate all the way from 1 to 5,000, to verify that we are not making any mistakes, we will include the first prime numbers lower than 100 and compare them. This is on GitHub, available<a id="_idIndexMarker931"/> as <code class="Code-In-Text--PACKT-">primes_1.py</code> at <a href="https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_14_profiling/primes_1.py">https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_14_profiling/primes_1.py</a>.</p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code">PRIMES = [1, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,&#13;&#13;
          59, 61, 67, 71, 73, 79, 83, 89, 97]&#13;&#13;
NUM_PRIMES_UP_TO = 5000&#13;&#13;
def check_if_prime(number):&#13;&#13;
    result = True&#13;&#13;
    for i in range(2, number):&#13;&#13;
        if number % i == 0:&#13;&#13;
            result = False&#13;&#13;
    return result&#13;&#13;
if __name__ == '__main__':&#13;&#13;
    # Calculate primes from 1 to NUM_PRIMES_UP_TO&#13;&#13;
    primes = [number for number in range(1, NUM_PRIMES_UP_TO)&#13;&#13;
              if check_if_prime(number)]&#13;&#13;
    # Compare the first primers to verify the process is correct&#13;&#13;
    assert primes[:len(PRIMES)] == PRIMES&#13;&#13;
    print('Primes')&#13;&#13;
    print('------')&#13;&#13;
    for prime in primes:&#13;&#13;
        print(prime)&#13;&#13;
    print('------')&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">The<a id="_idIndexMarker932"/> calculation of prime numbers is performed by creating a list of all numbers (from 1 to <code class="Code-In-Text--PACKT-">NUM_PRIMES_UP_TO</code>) and verifying each of them. Only values that return <code class="Code-In-Text--PACKT-">True</code> will be kept:</p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code">    # Calculate primes from 1 to NUM_PRIMES_UP_TO&#13;&#13;
    primes = [number for number in range(1, NUM_PRIMES_UP_TO)&#13;&#13;
              if check_if_prime(number)]&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">The next line <code class="Code-In-Text--PACKT-">assert</code>s that the first prime numbers are the same as the ones defined in the <code class="Code-In-Text--PACKT-">PRIMES</code> list, which is a hardcoded list of the first primes lower than 100.</p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code">assert primes[:len(PRIMES)] == PRIMES&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">The primes are finally printed. Let's execute the program, timing its execution:</p>&#13;&#13;
    <pre class="programlisting con"><code class="hljs-con">$ time python3 primes_1.py&#13;&#13;
Primes&#13;&#13;
------&#13;&#13;
1&#13;&#13;
2&#13;&#13;
3&#13;&#13;
5&#13;&#13;
7&#13;&#13;
11&#13;&#13;
13&#13;&#13;
17&#13;&#13;
19&#13;&#13;
… &#13;&#13;
4969&#13;&#13;
4973&#13;&#13;
4987&#13;&#13;
4993&#13;&#13;
4999&#13;&#13;
------&#13;&#13;
Real      0m0.875s&#13;&#13;
User      0m0.751s&#13;&#13;
sys 0m0.035s&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">From here, we<a id="_idIndexMarker933"/> will start analyzing the code to see what is going on internally and see if we can improve it.</p>&#13;&#13;
    <h2 id="_idParaDest-263" class="title">Using the built-in cProfile module</h2>&#13;&#13;
    <p class="normal">The easiest, faster<a id="_idIndexMarker934"/> way of profiling a module is to directly use the included <code class="Code-In-Text--PACKT-">cProfile</code> module in Python. This module is<a id="_idIndexMarker935"/> part of the standard library and can be called as part of the external call, like this:</p>&#13;&#13;
    <pre class="programlisting con"><code class="hljs-con">$ time python3 -m cProfile primes_1.py&#13;&#13;
Primes&#13;&#13;
------&#13;&#13;
1&#13;&#13;
2&#13;&#13;
3&#13;&#13;
5&#13;&#13;
...&#13;&#13;
4993&#13;&#13;
4999&#13;&#13;
------&#13;&#13;
         5677 function calls in 0.760 seconds&#13;&#13;
   Ordered by: standard name&#13;&#13;
   ncalls  tottime  percall  cumtime  percall filename:lineno(function)&#13;&#13;
        1    0.002    0.002    0.757    0.757 primes_1.py:19(&lt;listcomp&gt;)&#13;&#13;
        1    0.000    0.000    0.760    0.760 primes_1.py:2(&lt;module&gt;)&#13;&#13;
     4999    0.754    0.000    0.754    0.000 primes_1.py:7(check_if_prime)&#13;&#13;
        1    0.000    0.000    0.760    0.760 {built-in method builtins.exec}&#13;&#13;
        1    0.000    0.000    0.000    0.000 {built-in method builtins.len}&#13;&#13;
      673    0.004    0.000    0.004    0.000 {built-in method builtins.print}&#13;&#13;
        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}&#13;&#13;
Real      0m0.895s&#13;&#13;
User      0m0.764s&#13;&#13;
sys 0m0.032s&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">Note this <a id="_idIndexMarker936"/>called the script normally, but also<a id="_idIndexMarker937"/> presented the profile analysis. The table shows:</p>&#13;&#13;
    <ul>&#13;&#13;
      <li class="bullet"><code class="Code-In-Text--PACKT-">ncalls</code>: Number of times each element has been called</li>&#13;&#13;
      <li class="bullet"><code class="Code-In-Text--PACKT-">tottime</code>: Total time spent on each element, not including sub calls</li>&#13;&#13;
      <li class="bullet"><code class="Code-In-Text--PACKT-">percall</code>: Time per call on each element (not including sub calls)</li>&#13;&#13;
      <li class="bullet"><code class="Code-In-Text--PACKT-">cumtime</code>: Cumulative time – the total time spent on each element, including subcalls</li>&#13;&#13;
      <li class="bullet"><code class="Code-In-Text--PACKT-">percall</code>: Time per call on an element, including subcalls</li>&#13;&#13;
      <li class="bullet"><code class="Code-In-Text--PACKT-">filename:lineno</code>: Each of the elements under analysis</li>&#13;&#13;
    </ul>&#13;&#13;
    <p class="normal">In this case, the time is clearly seen to be spent in the <code class="Code-In-Text--PACKT-">check_if_prime</code> function, which is called 4,999 times, and it takes the practical totality of the time (744 milliseconds compared with a total of 762).</p>&#13;&#13;
    <p>&#13;&#13;
      <p class="Information-Box--PACKT-">While not easy to see here due to the fact that it's a small script, <code class="Code-In-Text--PACKT-">cProfile</code> increases the time it takes to execute the code. There's an equivalent module called <code class="Code-In-Text--PACKT-">profile</code> that's a direct replacement but implemented in pure Python, as opposed to a C extension. Please generally use <code class="Code-In-Text--PACKT-">cProfile</code> as it's faster, but <code class="Code-In-Text--PACKT-">profile</code> can be useful at certain moments, like when trying to extend the functionality.</p>&#13;&#13;
    </p>&#13;&#13;
    <p class="normal">While<a id="_idIndexMarker938"/> this text table can be enough for<a id="_idIndexMarker939"/> simple scripts like this one, the output can be presented as a file and then displayed with other tools:</p>&#13;&#13;
    <pre class="programlisting con"><code class="hljs-con">$ time python3 -m cProfile -o primes1.prof  primes_1.py&#13;&#13;
$ ls primes1.prof&#13;&#13;
primes1.prof&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">Now we need to install the visualizer SnakeViz, installing it through <code class="Code-In-Text--PACKT-">pip</code>:</p>&#13;&#13;
    <pre class="programlisting con"><code class="hljs-con">$ pip3 install snakeviz&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">Finally, open the file with <code class="Code-In-Text--PACKT-">snakeviz</code>, which will open a browser with the information:</p>&#13;&#13;
    <pre class="programlisting con"><code class="hljs-con">$ snakeviz primes1.prof&#13;&#13;
snakeviz web server started on 127.0.0.1:8080; enter Ctrl-C to exit&#13;&#13;
http://127.0.0.1:8080/snakeviz/%2FUsers%2Fjaime%2FDropbox%2FPackt%2Farchitecture_book%2Fchapter_13_profiling%2Fprimes1.prof&#13;&#13;
</code></pre>&#13;&#13;
    <figure class="mediaobject"><img src="img/B17580_14_01.png" alt="Graphical user interface, application&#13;&#10;&#13;&#10;Description automatically generated" width="826" height="655"/></figure>&#13;&#13;
    <p class="packt_figref">Figure 14.1: Graphical representation of the profiling information. The full page is too big to fit here and has been cropped purposefully to show some of the info.</p>&#13;&#13;
    <p class="normal">This<a id="_idIndexMarker940"/> graph is interactive, and we can click<a id="_idIndexMarker941"/> and hover on different elements to get more information:</p>&#13;&#13;
    <figure class="mediaobject"><img src="img/B17580_14_02.png" alt="Graphical user interface, application&#13;&#10;&#13;&#10;Description automatically generated" width="826" height="650"/></figure>&#13;&#13;
    <p class="packt_figref">Figure 14.2: Checking the information about check_if_prime. The full page is too big to fit here and has been cropped purposefully to show some of the info.</p>&#13;&#13;
    <p class="normal">We can <a id="_idIndexMarker942"/>confirm here that the bulk of the<a id="_idIndexMarker943"/> time is spent on <code class="Code-In-Text--PACKT-">check_if_prime</code>, but we don't get information about what's inside it.</p>&#13;&#13;
    <p class="normal">This is because <code class="Code-In-Text--PACKT-">cProfile</code> only has function granularity. You'll see how long each function call takes, but not a lower resolution. For this specifically simple function, this may not be enough.</p>&#13;&#13;
    <p>&#13;&#13;
      <p class="Information-Box--PACKT-">Do not underestimate this tool. The code example presented is purposefully simple to avoid spending too much time explaining its use. Most of the time, localizing the function that's taking most of the time is good enough to visually inspect it and discover what's taking too long. Keep in mind that, in most practical situations, the time spent will be on external calls like DB accesses, remote requests, etc.</p>&#13;&#13;
    </p>&#13;&#13;
    <p class="normal">We will see how to use a profiler that has a higher resolution, analyzing each line of code.</p>&#13;&#13;
    <h2 id="_idParaDest-264" class="title">Line profiler</h2>&#13;&#13;
    <p class="normal">To <a id="_idIndexMarker944"/>analyze the <code class="Code-In-Text--PACKT-">check_if_prime</code> function, we<a id="_idIndexMarker945"/> need to first install the module <code class="Code-In-Text--PACKT-">line_profiler</code></p>&#13;&#13;
    <pre class="programlisting con"><code class="hljs-con">$ pip3 install line_profiler&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">After it's installed, we will make a small change in the code, and save it as <code class="Code-In-Text--PACKT-">primes_2.py</code>. We will add the decorator <code class="Code-In-Text--PACKT-">@profile</code> for the <code class="Code-In-Text--PACKT-">check_if_prime</code> function, to indicate to the line profiler to look into it.</p>&#13;&#13;
    <p>&#13;&#13;
      <p class="Tip--PACKT-">Keep in mind that you should only profile sections of the code where you want to know more in this way. If all the code was profiled in this way, it would take a lot of time to analyze.</p>&#13;&#13;
    </p>&#13;&#13;
    <p class="normal">The code will be like this (the rest will be unaffected). You can check the whole file on GitHub at <a href="https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_14_profiling/primes_2.py">https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_14_profiling/primes_2.py</a>.</p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code">@profile&#13;&#13;
def check_if_prime(number):&#13;&#13;
    result = True&#13;&#13;
    for i in range(2, number):&#13;&#13;
        if number % i == 0:&#13;&#13;
            result = False&#13;&#13;
    return result&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">Execute the code now with <code class="Code-In-Text--PACKT-">kernprof</code>, which will be installed after the installation of <code class="Code-In-Text--PACKT-">line_profiler</code>.</p>&#13;&#13;
    <pre class="programlisting con"><code class="hljs-con">$ time kernprof -l primes_2.py&#13;&#13;
Primes&#13;&#13;
------&#13;&#13;
1&#13;&#13;
2&#13;&#13;
3&#13;&#13;
5&#13;&#13;
…&#13;&#13;
4987&#13;&#13;
4993&#13;&#13;
4999&#13;&#13;
------&#13;&#13;
Wrote profile results to primes_2.py.lprof&#13;&#13;
Real      0m12.139s&#13;&#13;
User      0m11.999s&#13;&#13;
sys 0m0.098s&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">Note the<a id="_idIndexMarker946"/> execution took noticeably longer – 12 seconds<a id="_idIndexMarker947"/> compared with subsecond execution without the profiler enabled. Now we can take a look at the results with this command:</p>&#13;&#13;
    <pre class="programlisting con"><code class="hljs-con">$ python3 -m line_profiler primes_2.py.lprof&#13;&#13;
Timer unit: 1e-06 s&#13;&#13;
Total time: 6.91213 s&#13;&#13;
File: primes_2.py&#13;&#13;
Function: check_if_prime at line 7&#13;&#13;
Line #      Hits         Time  Per Hit   % Time  Line Contents&#13;&#13;
==============================================================&#13;&#13;
     7                                           @profile&#13;&#13;
     8                                           def check_if_prime(number):&#13;&#13;
     9      4999       1504.0      0.3      0.0      result = True&#13;&#13;
    10&#13;&#13;
    11  12492502    3151770.0      0.3     45.6      for i in range(2, number):&#13;&#13;
    12  12487503    3749127.0      0.3     54.2          if number % i == 0:&#13;&#13;
    13     33359       8302.0      0.2      0.1              result = False&#13;&#13;
    14&#13;&#13;
    15      4999       1428.0      0.3      0.0      return result&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">Here, we can start analyzing the specifics of the algorithm used. The main problem seems to be that we<a id="_idIndexMarker948"/> are doing a lot of comparisons. Both lines 11 and 12 are being called too many times, though the time per hit is short. We need to find a way to reduce the number of times they're being called.</p>&#13;&#13;
    <p class="normal">The first <a id="_idIndexMarker949"/>one is easy. Once we find a <code class="Code-In-Text--PACKT-">False</code> result, we don't need to wait anymore; we can return directly, instead of continuing with the loop. The code will be like this (stored in <code class="Code-In-Text--PACKT-">primes_3.py</code>, available at <a href="https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_14_profiling/primes_3.py">https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_14_profiling/primes_3.py</a>):</p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code">@profile&#13;&#13;
def check_if_prime(number):&#13;&#13;
    for i in range(2, number):&#13;&#13;
        if number % i == 0:&#13;&#13;
            return False&#13;&#13;
    return True&#13;&#13;
Let's take a look at the profiler result.&#13;&#13;
$ time kernprof -l primes_3.py&#13;&#13;
... &#13;&#13;
Real      0m2.117s&#13;&#13;
User      0m1.713s&#13;&#13;
sys       0m0.116s&#13;&#13;
$ python3 -m line_profiler primes_3.py.lprof&#13;&#13;
Timer unit: 1e-06 s&#13;&#13;
Total time: 0.863039 s&#13;&#13;
File: primes_3.py&#13;&#13;
Function: check_if_prime at line 7&#13;&#13;
Line #      Hits         Time  Per Hit   % Time  Line Contents&#13;&#13;
==============================================================&#13;&#13;
     7                                           @profile&#13;&#13;
     8                                           def check_if_prime(number):&#13;&#13;
     9&#13;&#13;
    10   1564538     388011.0      0.2     45.0      for i in range(2, number):&#13;&#13;
    11   1563868     473788.0      0.3     54.9          if number % i == 0:&#13;&#13;
    12      4329       1078.0      0.2      0.1              return False&#13;&#13;
    13&#13;&#13;
    14       670        162.0      0.2      0.0      return True&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">We see how time has gone down by a big factor (2 seconds compared with the 12 seconds before, as measured by <code class="Code-In-Text--PACKT-">time</code>) and we see the great reduction in time spent on comparisons (3,749,127 microseconds before, and then 473,788 microseconds), mainly due to the fact <a id="_idIndexMarker950"/>there are 10 times fewer comparisons, 1,563,868 compared with 12,487,503.</p>&#13;&#13;
    <p class="normal">We can <a id="_idIndexMarker951"/>also improve and further reduce the number of comparisons by limiting the size of the loop.</p>&#13;&#13;
    <p class="normal">Right now, the loop will try to divide the source number between all the numbers up to itself. For example, for 19, we try these numbers (as 19 is a prime number, it's not divisible by any except for itself).</p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code">Divide 19 between&#13;&#13;
[2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">Trying all these numbers is not necessary. At least, we can skip half of them, as no number will be divisible by a number higher than half itself. For example, 19 divided by 10 or higher is less than 2.</p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code">Divide 19 between&#13;&#13;
[2, 3, 4, 5, 6, 7, 8, 9, 10]&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">Furthermore, any factor of a number will be lower than its square root. This can be explained as follows: If a number is the factor of two or more numbers, the highest they may be is the square root of the whole number. So we check only the numbers up to the square root (rounded down):</p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code">Divide 19 between&#13;&#13;
[2, 3, 4]&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">But we can reduce it even further. We only need to check the odd numbers after 2, as any even number will be divisible by 2. So, in this case, we even reduce it further.</p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code">Divide 19 between&#13;&#13;
[2, 3]&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">To apply all of this, we<a id="_idIndexMarker952"/> need to tweak the code again and store it in <code class="Code-In-Text--PACKT-">primes_4.py</code>,<code class="Code-In-Text--PACKT-"> </code>available on GitHub at <a href="https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_14_profiling/primes_4.py">https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_14_profiling/primes_4.py</a>:</p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code">def check_if_prime(number):&#13;&#13;
    if number % 2 == 0 and number != 2:&#13;&#13;
        return False&#13;&#13;
    for i in range(3, math.floor(math.sqrt(number)) + 1, 2):&#13;&#13;
        if number % i == 0:&#13;&#13;
            return False&#13;&#13;
    return True&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">The<a id="_idIndexMarker953"/> code always checks for divisibility by 2, unless the number is 2. This is to keep returning 2 correctly as a prime.</p>&#13;&#13;
    <p class="normal">Then, we create a range of numbers that starts from 3 (we already tested 2) and continue until the square root of the number. We use the <code class="Code-In-Text--PACKT-">math</code> module to perform the action and to floor the number to the nearest lower integer. The <code class="Code-In-Text--PACKT-">range</code> function requires a <code class="Code-In-Text--PACKT-">+1</code> of this number, as it doesn't include the defined number. Finally, the range step on 2 integers at time so that all the numbers are odd, since we started with 3.</p>&#13;&#13;
    <p class="normal">For example, to test a number like 1,000, this is the equivalent code.</p>&#13;&#13;
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; import math&#13;&#13;
&gt;&gt;&gt; math.sqrt(1000)&#13;&#13;
31.622776601683793&#13;&#13;
&gt;&gt;&gt; math.floor(math.sqrt(1000))&#13;&#13;
31&#13;&#13;
&gt;&gt;&gt; list(range(3, 31 + 1, 2))&#13;&#13;
[3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31]&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">Note that 31 is returned as we added the <code class="Code-In-Text--PACKT-">+1</code>.</p>&#13;&#13;
    <p class="normal">Let's profile the code again.</p>&#13;&#13;
    <pre class="programlisting con"><code class="hljs-con">$ time kernprof -l primes_4.py&#13;&#13;
Primes&#13;&#13;
------&#13;&#13;
1&#13;&#13;
2&#13;&#13;
3&#13;&#13;
5&#13;&#13;
…&#13;&#13;
4973&#13;&#13;
4987&#13;&#13;
4993&#13;&#13;
4999&#13;&#13;
------&#13;&#13;
Wrote profile results to primes_4.py.lprof&#13;&#13;
Real      0m0.477s&#13;&#13;
User      0m0.353s&#13;&#13;
sys       0m0.094s&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">We see <a id="_idIndexMarker954"/>another big increase in performance. Let's see <a id="_idIndexMarker955"/>the line profile.</p>&#13;&#13;
    <pre class="programlisting con"><code class="hljs-con">$ python3 -m line_profiler primes_4.py.lprof&#13;&#13;
Timer unit: 1e-06 s&#13;&#13;
Total time: 0.018276 s&#13;&#13;
File: primes_4.py&#13;&#13;
Function: check_if_prime at line 8&#13;&#13;
Line #      Hits         Time  Per Hit   % Time  Line Contents&#13;&#13;
==============================================================&#13;&#13;
     8                                           @profile&#13;&#13;
     9                                           def check_if_prime(number):&#13;&#13;
    10&#13;&#13;
    11      4999       1924.0      0.4     10.5      if number % 2 == 0 and number != 2:&#13;&#13;
    12      2498        654.0      0.3      3.6          return False&#13;&#13;
    13&#13;&#13;
    14     22228       7558.0      0.3     41.4      for i in range(3, math.floor(math.sqrt(number)) + 1, 2):&#13;&#13;
    15     21558       7476.0      0.3     40.9          if number % i == 0:&#13;&#13;
    16      1831        506.0      0.3      2.8              return False&#13;&#13;
    17&#13;&#13;
    18       670        158.0      0.2      0.9      return True&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">We've reduced the number of loop iterations drastically to 22,228, from 1.5 million in <code class="Code-In-Text--PACKT-">primes_3.py</code> and over 12 million in <code class="Code-In-Text--PACKT-">primes_2.py</code>, when we started the line profiling. That's some serious improvement!</p>&#13;&#13;
    <p>&#13;&#13;
      <p class="Tip--PACKT-">You can try to do the test to increase <code class="Code-In-Text--PACKT-">NUM_PRIMES_UP_TO</code> in <code class="Code-In-Text--PACKT-">primes_2.py</code> and <code class="Code-In-Text--PACKT-">primes_4.py</code> and compare them. The change will be clearly perceptible.</p>&#13;&#13;
    </p>&#13;&#13;
    <p class="normal">The<a id="_idIndexMarker956"/> line approach should be used only for small sections. In <a id="_idIndexMarker957"/>general, we've seen how <code class="Code-In-Text--PACKT-">cProfile</code> can be more useful, as it's easier to run and gives information. </p>&#13;&#13;
    <p class="normal">Previous sections have assumed that we are able to run the whole script and then receive the results, but that may not be correct. Let's take a look at how to profile in sections of the program, for example, when a request is received.</p>&#13;&#13;
    <h1 id="_idParaDest-265" class="title">Partial profiling </h1>&#13;&#13;
    <p class="normal">In many<a id="_idIndexMarker958"/> scenarios, profilers will be useful in environments where the system is in operation and we cannot wait until the process finishes before obtaining profiling information. Typical scenarios are web requests.</p>&#13;&#13;
    <p class="normal">If we want to analyze a particular web request, we may need to start a web server, produce a single request, and stop the process to obtain the result. This doesn't work as well as you may think due to some problems that we will see.</p>&#13;&#13;
    <p class="normal">But first, let's create some code to explain this situation.</p>&#13;&#13;
    <h2 id="_idParaDest-266" class="title">Example web server returning prime numbers</h2>&#13;&#13;
    <p class="normal">We will <a id="_idIndexMarker959"/>use the final version of the function <code class="Code-In-Text--PACKT-">check_if_prime</code> and create a web service that returns all the primes up to the number specified in the path of the request. The code will be the following, and it's fully<a id="_idIndexMarker960"/> available in<a id="_idIndexMarker961"/> the <code class="Code-In-Text--PACKT-">server.py</code> file on GitHub at <a href="https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_14_profiling/server.py">https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_14_profiling/server.py</a>.</p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code">from http.server import BaseHTTPRequestHandler, HTTPServer&#13;&#13;
import math&#13;&#13;
def check_if_prime(number):&#13;&#13;
    if number % 2 == 0 and number != 2:&#13;&#13;
        return False&#13;&#13;
    for i in range(3, math.floor(math.sqrt(number)) + 1, 2):&#13;&#13;
        if number % i == 0:&#13;&#13;
            return False&#13;&#13;
    return True&#13;&#13;
def prime_numbers_up_to(up_to):&#13;&#13;
    primes = [number for number in range(1, up_to + 1)&#13;&#13;
              if check_if_prime(number)]&#13;&#13;
    return primes&#13;&#13;
def extract_param(path):&#13;&#13;
    '''&#13;&#13;
    Extract the parameter and transform into&#13;&#13;
    a positive integer. If the parameter is&#13;&#13;
    not valid, return None&#13;&#13;
    '''&#13;&#13;
    raw_param = path.replace('/', '')&#13;&#13;
    # Try to convert in number&#13;&#13;
    try:&#13;&#13;
        param = int(raw_param)&#13;&#13;
    except ValueError:&#13;&#13;
        return None&#13;&#13;
    # Check that it's positive&#13;&#13;
    if param &lt; 0:&#13;&#13;
        return None&#13;&#13;
    return param&#13;&#13;
def get_result(path):&#13;&#13;
    param = extract_param(path)&#13;&#13;
    if param is None:&#13;&#13;
        return 'Invalid parameter, please add an integer'&#13;&#13;
    return prime_numbers_up_to(param)&#13;&#13;
class MyServer(BaseHTTPRequestHandler):&#13;&#13;
    def do_GET(self):&#13;&#13;
        result = get_result(self.path)&#13;&#13;
        self.send_response(200)&#13;&#13;
        self.send_header("Content-type", "text/html")&#13;&#13;
        self.end_headers()&#13;&#13;
        return_template = '''&#13;&#13;
            &lt;html&gt;&#13;&#13;
                &lt;head&gt;&lt;title&gt;Example&lt;/title&gt;&lt;/head&gt;&#13;&#13;
                &lt;body&gt;&#13;&#13;
                    &lt;p&gt;Add a positive integer number in the path to display&#13;&#13;
                    all primes up to that number&lt;/p&gt;&#13;&#13;
                    &lt;p&gt;Result {result}&lt;/p&gt;&#13;&#13;
                &lt;/body&gt;&#13;&#13;
            &lt;/html&gt;&#13;&#13;
        '''&#13;&#13;
        body = bytes(return_template.format(result=result), 'utf-8')&#13;&#13;
        self.wfile.write(body)&#13;&#13;
if __name__ == '__main__':&#13;&#13;
    HOST = 'localhost'&#13;&#13;
    PORT = 8000&#13;&#13;
    web_server = HTTPServer((HOST, PORT), MyServer)&#13;&#13;
    print(f'Server available at http://{HOST}:{PORT}')&#13;&#13;
    print('Use CTR+C to stop it')&#13;&#13;
    # Capture gracefully the end of the server by KeyboardInterrupt&#13;&#13;
    try:&#13;&#13;
        web_server.serve_forever()&#13;&#13;
    except KeyboardInterrupt:&#13;&#13;
        pass&#13;&#13;
    web_server.server_close()&#13;&#13;
    print("Server stopped.")&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">The <a id="_idIndexMarker962"/>code is better understood if you start from the end. The final block creates a web server using the base <code class="Code-In-Text--PACKT-">HTTPServer</code> definition in the Python module <code class="Code-In-Text--PACKT-">http.server</code>. Previously, we created the class <code class="Code-In-Text--PACKT-">MyServer</code>, which defines what to do if there's a <code class="Code-In-Text--PACKT-">GET</code> request in the <code class="Code-In-Text--PACKT-">do_GET</code> method.</p>&#13;&#13;
    <p class="normal">The <code class="Code-In-Text--PACKT-">do_GET</code> method returns an HTML response with the result calculated by <code class="Code-In-Text--PACKT-">get_result</code>. It adds all the required headers and formats the body in HTML.</p>&#13;&#13;
    <p class="normal">The interesting bits of the process happen in the next functions.</p>&#13;&#13;
    <p class="normal"><code class="Code-In-Text--PACKT-">get_result</code> is the root one. It first calls <code class="Code-In-Text--PACKT-">extract_param</code> to get a number, up to which to calculate the threshold number for us to calculate primes up to. If correct, then that's passed to <code class="Code-In-Text--PACKT-">prime_numbers_up_to</code>.</p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code">def get_result(path):&#13;&#13;
    param = extract_param(path)&#13;&#13;
    if param is None:&#13;&#13;
        return 'Invalid parameter, please add an integer'&#13;&#13;
    return prime_numbers_up_to(param)&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">The function <code class="Code-In-Text--PACKT-">extract_params</code> will extract a number from the URL path. It first removes any <code class="Code-In-Text--PACKT-">/</code> character, and then tries to convert it into an integer and checks the integer is positive. For any errors, it returns <code class="Code-In-Text--PACKT-">None</code>.</p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code">def extract_param(path):&#13;&#13;
    '''&#13;&#13;
    Extract the parameter and transform into&#13;&#13;
    a positive integer. If the parameter is&#13;&#13;
    not valid, return None&#13;&#13;
    '''&#13;&#13;
    raw_param = path.replace('/', '')&#13;&#13;
    # Try to convert in number&#13;&#13;
    try:&#13;&#13;
        param = int(raw_param)&#13;&#13;
    except ValueError:&#13;&#13;
        return None&#13;&#13;
    # Check that it's positive&#13;&#13;
    if param &lt; 0:&#13;&#13;
        return None&#13;&#13;
    return param&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">The<a id="_idIndexMarker963"/> function <code class="Code-In-Text--PACKT-">prime_numbers_up_to</code>, finally, calculates the prime numbers up to the number passed. This is similar to the code that we saw earlier in the chapter. </p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code">def prime_numbers_up_to(up_to):&#13;&#13;
    primes = [number for number in range(1, up_to + 1)&#13;&#13;
              if check_if_prime(number)]&#13;&#13;
    return primes&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">Finally, <code class="Code-In-Text--PACKT-">check_if_prime</code>, which we covered extensively earlier in the chapter, is the same as it was at <code class="Code-In-Text--PACKT-">primes_4.py</code>.</p>&#13;&#13;
    <p class="normal">The process can be started with:</p>&#13;&#13;
    <pre class="programlisting con"><code class="hljs-con">$ python3 server.py&#13;&#13;
Server available at http://localhost:8000&#13;&#13;
Use CTR+C to stop it&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">And then tested by going to <code class="Code-In-Text--PACKT-">http://localhost:8000/500</code> to try to get prime numbers up to 500.</p>&#13;&#13;
    <figure class="mediaobject"> <img src="img/B17580_14_03.png" alt="Graphical user interface, text&#13;&#10;&#13;&#10;Description automatically generated" width="826" height="499"/></figure>&#13;&#13;
    <p class="packt_figref">Figure 14.3: The interface displaying all primes up to 500</p>&#13;&#13;
    <p class="normal">As you <a id="_idIndexMarker964"/>can see, we have an understandable output. Let's move on to profiling the process we used to get it.</p>&#13;&#13;
    <h2 id="_idParaDest-267" class="title">Profiling the whole process</h2>&#13;&#13;
    <p class="normal">We can<a id="_idIndexMarker965"/> profile the whole process by starting it under <code class="Code-In-Text--PACKT-">cProfile</code> and then capturing its output with. We start it like this, make a single request to <code class="Code-In-Text--PACKT-">http://localhost:8000/500</code>, and check the results.</p>&#13;&#13;
    <pre class="programlisting con"><code class="hljs-con">$ python3 -m cProfile -o server.prof server.py&#13;&#13;
Server available at http://localhost:8000&#13;&#13;
Use CTR+C to stop it&#13;&#13;
127.0.0.1 - - [10/Oct/2021 14:05:34] "GET /500 HTTP/1.1" 200 -&#13;&#13;
127.0.0.1 - - [10/Oct/2021 14:05:34] "GET /favicon.ico HTTP/1.1" 200 -&#13;&#13;
^CServer stopped.&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">We<a id="_idIndexMarker966"/> have stored the results in the file <code class="Code-In-Text--PACKT-">server.prof</code>. This file can then be analyzed as before, using <code class="Code-In-Text--PACKT-">snakeviz</code>.</p>&#13;&#13;
    <pre class="programlisting con"><code class="hljs-con">$ snakeviz server.prof&#13;&#13;
snakeviz web server started on 127.0.0.1:8080; enter Ctrl-C to exit&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">Which displays the following diagram:</p>&#13;&#13;
    <figure class="mediaobject"><img src="img/B17580_14_04.png" alt="Graphical user interface, application&#13;&#10;&#13;&#10;Description automatically generated" width="826" height="575"/></figure>&#13;&#13;
    <p class="packt_figref">Figure 14.4: Diagram of the full profile. The full page is too big to fit here and has been cropped purposefully to show some of the info.</p>&#13;&#13;
    <p class="normal">As you can see, the diagram shows that for the vast majority of the test duration, the code was waiting for a new request, and internally doing a poll action. This is part of the server code and not our code.</p>&#13;&#13;
    <p class="normal">To<a id="_idIndexMarker967"/> find the code that we care about, we can manually search in the long list below for <code class="Code-In-Text--PACKT-">get_result</code>, which is the root of the interesting bits of our code. Be sure to select <code class="Code-In-Text--PACKT-">Cutoff: None</code> to display all the functions.</p>&#13;&#13;
    <p class="normal">Once selected, the diagram will display from there onward. Be sure to scroll up to see the new diagram.</p>&#13;&#13;
    <figure class="mediaobject"><img src="img/B17580_14_05.png" alt="Chart&#13;&#10;&#13;&#10;Description automatically generated with low confidence" width="826" height="573"/></figure>&#13;&#13;
    <p class="packt_figref">Figure 14.5: The diagram showing from get_result. The full page is too big to fit here and has been cropped purposefully to show some of the info.</p>&#13;&#13;
    <p class="normal">Here, you can see more of the general structure of the code execution. You can see that most of the time is spent on the multiple <code class="Code-In-Text--PACKT-">check_if_prime</code> calls, which comprise the bulk of <code class="Code-In-Text--PACKT-">prime_numbers_up_to</code> and the list comprehension included in it, and very little time is spent on <code class="Code-In-Text--PACKT-">extract_params</code>.</p>&#13;&#13;
    <p class="normal">But this<a id="_idIndexMarker968"/> approach has some problems:</p>&#13;&#13;
    <ul>&#13;&#13;
      <li class="bullet">First of all, we need to go a full cycle between starting and stopping a process. This is cumbersome to do for requests.</li>&#13;&#13;
      <li class="bullet">Everything that happens in the cycle is included. That adds noise to the analysis. Fortunately, we knew that the interesting part was in <code class="Code-In-Text--PACKT-">get_result</code>, but that may not be evident. This case also uses a minimal structure but adding that in the case of a complex framework like Django can lead to a lot of .</li>&#13;&#13;
      <li class="bullet">If we process two different requests, they will be added into the same file, again mixing the results.</li>&#13;&#13;
    </ul>&#13;&#13;
    <p class="normal">These problems can be solved by applying the profiler to only the part that is of interest and producing a new file for each request.</p>&#13;&#13;
    <h2 id="_idParaDest-268" class="title">Generating a profile file per request</h2>&#13;&#13;
    <p class="normal">To be able<a id="_idIndexMarker969"/> to generate a different file with information per individual request, we need to create a decorator for easy access. This will profile and produce an independent file.</p>&#13;&#13;
    <p class="normal">In the file <code class="Code-In-Text--PACKT-">server_profile_by_request.py</code>, we get the same code as in <code class="Code-In-Text--PACKT-">server.py</code>, but adding the following decorator.</p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code">from functools import wraps&#13;&#13;
import cProfile&#13;&#13;
from time import time&#13;&#13;
def profile_this(func):&#13;&#13;
    @wraps(func)&#13;&#13;
    def wrapper(*args, **kwargs):&#13;&#13;
        prof = cProfile.Profile()&#13;&#13;
        retval = prof.runcall(func, *args, **kwargs)&#13;&#13;
        filename = f'profile-{time()}.prof'&#13;&#13;
        prof.dump_stats(filename)&#13;&#13;
        return retval&#13;&#13;
    return wrapper&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">The decorator defines a <code class="Code-In-Text--PACKT-">wrapper</code> function that replaces the original function. We use the <code class="Code-In-Text--PACKT-">wraps</code> decorator to keep the original name and docstring.</p>&#13;&#13;
    <p>&#13;&#13;
      <p class="Information-Box--PACKT-">This is just a standard decorator process. A decorator function in Python is one that returns a function that then replaces the original one. As you can see, the original function <code class="Code-In-Text--PACKT-">func</code> is still called inside the wrapper that replaces it, but it adds extra functionality.</p>&#13;&#13;
    </p>&#13;&#13;
    <p class="normal">Inside, we<a id="_idIndexMarker970"/> start a profiler and run the function under it using the <code class="Code-In-Text--PACKT-">runcall</code> function. This line is the core of it – using the profiler generated, we run the original function <code class="Code-In-Text--PACKT-">func</code> with its parameters and store its returned value.</p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code">retval = prof.runcall(func, *args, **kwargs)&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">After that, we generate a new file that includes the current time and dump the stats in it with the <code class="Code-In-Text--PACKT-">.dump_stats</code> call.</p>&#13;&#13;
    <p class="normal">We also decorate the <code class="Code-In-Text--PACKT-">get_result</code> function, so we start our profiling there.</p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code">@profile_this&#13;&#13;
def get_result(path):&#13;&#13;
    param = extract_param(path)&#13;&#13;
    if param is None:&#13;&#13;
        return 'Invalid parameter, please add an integer'&#13;&#13;
    return prime_numbers_up_to(param)&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">The full code is available<a id="_idIndexMarker971"/> in the file <code class="Code-In-Text--PACKT-">server_profile_by_request.py</code>, available on GitHub at <a href="https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_14_profiling/server_profile_by_request.py">https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_14_profiling/server_profile_by_request.py</a>.</p>&#13;&#13;
    <p class="normal">Let's start the server now and make some calls through the browser, one to <code class="Code-In-Text--PACKT-">http://localhost:8000/500</code> and another to <code class="Code-In-Text--PACKT-">http://localhost:8000/800</code>.</p>&#13;&#13;
    <pre class="programlisting con"><code class="hljs-con">$ python3 server_profile_by_request.py&#13;&#13;
Server available at http://localhost:8000&#13;&#13;
Use CTR+C to stop it&#13;&#13;
127.0.0.1 - - [10/Oct/2021 17:09:57] "GET /500 HTTP/1.1" 200 -&#13;&#13;
127.0.0.1 - - [10/Oct/2021 17:10:00] "GET /800 HTTP/1.1" 200 -&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">We can see how new files are created:</p>&#13;&#13;
    <pre class="programlisting con"><code class="hljs-con">$ ls profile-*&#13;&#13;
profile-1633882197.634005.prof &#13;&#13;
profile-1633882200.226291.prof&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">These <a id="_idIndexMarker972"/>files can be displayed using <code class="Code-In-Text--PACKT-">snakeviz</code>:</p>&#13;&#13;
    <pre class="programlisting con"><code class="hljs-con">$ snakeviz profile-1633882197.634005.prof&#13;&#13;
snakeviz web server started on 127.0.0.1:8080; enter Ctrl-C to exit&#13;&#13;
</code></pre>&#13;&#13;
    <figure class="mediaobject"><img src="img/B17580_14_06.png" alt="Graphical user interface, chart&#13;&#10;&#13;&#10;Description automatically generated" width="829" height="576"/></figure>&#13;&#13;
    <p class="packt_figref">Figure 14.6: The profile information of a single request. The full page is too big to fit here and has been cropped purposefully to show some of the info.</p>&#13;&#13;
    <p class="normal">Each file contains only the information from <code class="Code-In-Text--PACKT-">get_result</code> onwards, which gets information only up to a point. Even more so, each file displays information only for a specific request, so it can be profiled individually, with a high level of detail.</p>&#13;&#13;
    <p class="normal">The<a id="_idIndexMarker973"/> code can be adapted to adapt the filename more specifically to include details like call parameters, which can be useful. Another interesting possible adaptation is to create a random sample, so only 1 in X calls produces profiled code. This can help reduce the overhead of profiling and allow you to completely profile some requests.</p>&#13;&#13;
    <p>&#13;&#13;
      <p class="Tip--PACKT-">This is different from a statistical profiler, as it will still completely profile some requests, instead of detecting what's going on at a particular time. This can help follow the flow of what happens for particular requests.</p>&#13;&#13;
    </p>&#13;&#13;
    <p class="normal">Next, we'll see how to perform memory profiling.</p>&#13;&#13;
    <h1 id="_idParaDest-269" class="title">Memory profiling</h1>&#13;&#13;
    <p class="normal">Sometimes, applications <a id="_idIndexMarker974"/>use too much memory. The worst-case scenario is that they use more and more memory as time goes by, normally due to what's called a memory leak, maintaining memory that is no longer used, due to some mistake in the coding. Other problems can also include the fact that the usage of memory may be improved, as it's a limited resource.</p>&#13;&#13;
    <p class="normal">To profile memory and analyze what the objects are that use the memory, we need first to create some example code. We will generate enough Leonardo numbers.</p>&#13;&#13;
    <p class="normal">Leonardo numbers <a id="_idIndexMarker975"/>are numbers that follow a sequence defined as the following:</p>&#13;&#13;
    <ul>&#13;&#13;
      <li class="bullet">The first Leonardo number is one</li>&#13;&#13;
      <li class="bullet">The second Leonardo number is also one</li>&#13;&#13;
      <li class="bullet">Any other Leonardo number is the two previous Leonardo numbers plus one</li>&#13;&#13;
    </ul>&#13;&#13;
    <p class="normal">Leonardo numbers are similar to Fibonacci numbers. They are actually related to them. We use them instead of Fibonacci to show more variety. Numbers are fun!</p>&#13;&#13;
    <p class="normal">We present the first 35 Leonardo numbers by creating a recursive function and store it in <code class="Code-In-Text--PACKT-">leonardo_1.py</code>, available<a id="_idIndexMarker976"/> on GitHub at <a href="https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_14_profiling/leonardo_1.py">https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_14_profiling/leonardo_1.py</a>.</p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code">def leonardo(number):&#13;&#13;
    if number in (0, 1):&#13;&#13;
        return 1&#13;&#13;
    return leonardo(number - 1) + leonardo(number - 2) + 1&#13;&#13;
NUMBER = 35&#13;&#13;
for i in range(NUMBER + 1):&#13;&#13;
    print('leonardo[{}] = {}'.format(i, leonardo(i)))&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">You can<a id="_idIndexMarker977"/> run the code and see it takes progressively longer.</p>&#13;&#13;
    <pre class="programlisting con"><code class="hljs-con">$ time python3 leonardo_1.py&#13;&#13;
leonardo[0] = 1&#13;&#13;
leonardo[1] = 1&#13;&#13;
leonardo[2] = 3&#13;&#13;
leonardo[3] = 5&#13;&#13;
leonardo[4] = 9&#13;&#13;
leonardo[5] = 15&#13;&#13;
...&#13;&#13;
leonardo[30] = 2692537&#13;&#13;
leonardo[31] = 4356617&#13;&#13;
leonardo[32] = 7049155&#13;&#13;
leonardo[33] = 11405773&#13;&#13;
leonardo[34] = 18454929&#13;&#13;
leonardo[35] = 29860703&#13;&#13;
real      0m9.454s&#13;&#13;
user      0m8.844s&#13;&#13;
sys 0m0.183s&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">To speed up the process, we see that it's possible to use memorization techniques, which means to store the results and use them instead of calculating them all the time.</p>&#13;&#13;
    <p class="normal">We change the<a id="_idIndexMarker978"/> code like this, creating the <code class="Code-In-Text--PACKT-">leonardo_2.py</code> file (available on GitHub at <a href="https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_14_profiling/leonardo_2.py">https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_14_profiling/leonardo_2.py</a>).</p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code">CACHE = {}&#13;&#13;
def leonardo(number):&#13;&#13;
    if number in (0, 1):&#13;&#13;
        return 1&#13;&#13;
    if number not in CACHE:&#13;&#13;
        result = leonardo(number - 1) + leonardo(number - 2) + 1&#13;&#13;
        CACHE[number] = result&#13;&#13;
    return CACHE[number]&#13;&#13;
NUMBER = 35000&#13;&#13;
for i in range(NUMBER + 1):&#13;&#13;
    print(f'leonardo[{i}] = {leonardo(i)}')&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">This uses<a id="_idIndexMarker979"/> a global dictionary, <code class="Code-In-Text--PACKT-">CACHE</code>, to store all Leonardo numbers, speeding up the process. Note that we increased the number of numbers to calculate from <code class="Code-In-Text--PACKT-">35</code> to <code class="Code-In-Text--PACKT-">35000</code>, a thousand times more. The process runs quite quickly.</p>&#13;&#13;
    <pre class="programlisting con"><code class="hljs-con">$ time python3 leonardo_2.py&#13;&#13;
leonardo[0] = 1&#13;&#13;
leonardo[1] = 1&#13;&#13;
leonardo[2] = 3&#13;&#13;
leonardo[3] = 5&#13;&#13;
leonardo[4] = 9&#13;&#13;
leonardo[5] = 15&#13;&#13;
...&#13;&#13;
leonardo[35000] = ...&#13;&#13;
real      0m15.973s&#13;&#13;
user      0m8.309s&#13;&#13;
sys       0m1.064s&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">Let's take a look now at memory usage.</p>&#13;&#13;
    <h2 id="_idParaDest-270" class="title">Using memory_profiler</h2>&#13;&#13;
    <p class="normal">Now that we <a id="_idIndexMarker980"/>have our application storing information, let's use a profiler to show where the memory is stored.</p>&#13;&#13;
    <p class="normal">We need to install the package <code class="Code-In-Text--PACKT-">memory_profiler</code>. This package is similar to <code class="Code-In-Text--PACKT-">line_profiler</code>.</p>&#13;&#13;
    <pre class="programlisting con"><code class="hljs-con">$ pip install memory_profiler&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">We can now add a <code class="Code-In-Text--PACKT-">@profile</code> decorator in the <code class="Code-In-Text--PACKT-">leonardo</code> function (stored in <code class="Code-In-Text--PACKT-">leonardo_2p.py</code>, on GitHub at <a href="https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_14_profiling/leonardo_2p.py">https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_14_profiling/leonardo_2p.py</a>), and run it using the <code class="Code-In-Text--PACKT-">memory_profiler</code> module. You'll notice that it runs slower this time, but after the usual result, it displays a table.</p>&#13;&#13;
    <pre class="programlisting con"><code class="hljs-con">$ time python3 -m memory_profiler leonardo_2p.py&#13;&#13;
...&#13;&#13;
Filename: leonardo_2p.py&#13;&#13;
Line #    Mem usage    Increment  Occurences   Line Contents&#13;&#13;
============================================================&#13;&#13;
     5  104.277 MiB   97.082 MiB      104999   @profile&#13;&#13;
     6                                         def leonardo(number):&#13;&#13;
     7&#13;&#13;
     8  104.277 MiB    0.000 MiB      104999       if number in (0, 1):&#13;&#13;
     9   38.332 MiB    0.000 MiB           5           return 1&#13;&#13;
    10&#13;&#13;
    11  104.277 MiB    0.000 MiB      104994       if number not in CACHE:&#13;&#13;
    12  104.277 MiB    5.281 MiB       34999           result = leonardo(number - 1) + leonardo(number - 2) + 1&#13;&#13;
    13  104.277 MiB    1.914 MiB       34999           CACHE[number] = result&#13;&#13;
    14&#13;&#13;
    15  104.277 MiB    0.000 MiB      104994       return CACHE[number]&#13;&#13;
Real      0m47.725s&#13;&#13;
User      0m25.188s&#13;&#13;
sys 0m10.372s&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">This table <a id="_idIndexMarker981"/>shows first the memory usage, and the increment or decrement, as well as how many times each line appears.</p>&#13;&#13;
    <p class="normal">You can see the following:</p>&#13;&#13;
    <ul>&#13;&#13;
      <li class="bullet">Line 9 gets executed only a few times. When it does, the amount of memory is around <code class="Code-In-Text--PACKT-">38 MiB</code>, which will be the minimum memory used by the program.</li>&#13;&#13;
      <li class="bullet">The total memory used is almost <code class="Code-In-Text--PACKT-">105 MiB</code>.</li>&#13;&#13;
      <li class="bullet">The whole memory increase is localized in lines 12 and 13, when we create a new Leonardo number and when we store it in the <code class="Code-In-Text--PACKT-">CACHE</code> dictionary. Note how we are never releasing memory here.</li>&#13;&#13;
    </ul>&#13;&#13;
    <p class="normal">We don't really need to keep all the previous Leonardo numbers in memory at all times, and we can try a different approach to keep only a few.</p>&#13;&#13;
    <h2 id="_idParaDest-271" class="title">Memory optimization</h2>&#13;&#13;
    <p class="normal">We create <a id="_idIndexMarker982"/>the file <code class="Code-In-Text--PACKT-">leonardo_3.py</code> with the following code, available on GitHub at <a href="https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_14_profiling/leonardo_3.py">https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_14_profiling/leonardo_3.py</a>:</p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code">CACHE = {}&#13;&#13;
@profile&#13;&#13;
def leonardo(number):&#13;&#13;
    if number in (0, 1):&#13;&#13;
        return 1&#13;&#13;
    if number not in CACHE:&#13;&#13;
        result = leonardo(number - 1) + leonardo(number - 2) + 1&#13;&#13;
        CACHE[number] = result&#13;&#13;
    ret_value = CACHE[number]&#13;&#13;
    MAX_SIZE = 5&#13;&#13;
    while len(CACHE) &gt; MAX_SIZE:&#13;&#13;
        # Maximum size allowed,&#13;&#13;
        # delete the first value, which will be the oldest&#13;&#13;
        key = list(CACHE.keys())[0]&#13;&#13;
        del CACHE[key]&#13;&#13;
    return ret_value&#13;&#13;
NUMBER = 35000&#13;&#13;
for i in range(NUMBER + 1):&#13;&#13;
    print(f'leonardo[{i}] = {leonardo(i)}')&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">Note <a id="_idIndexMarker983"/>we keep the <code class="Code-In-Text--PACKT-">@profile</code> decorator to run the memory profiler again. Most of the code is the same, but we added the following extra block:</p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code">    MAX_SIZE = 5&#13;&#13;
    while len(CACHE) &gt; MAX_SIZE:&#13;&#13;
        # Maximum size allowed,&#13;&#13;
        # delete the first value, which will be the oldest&#13;&#13;
        key = list(CACHE.keys())[0]&#13;&#13;
        del CACHE[key]&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">This code will keep the number of elements in the <code class="Code-In-Text--PACKT-">CACHE</code> dictionary within a limit. When the limit is reached, it will remove the first element returned by <code class="Code-In-Text--PACKT-">CACHE.keys()</code>, which will be the oldest.</p>&#13;&#13;
    <p>&#13;&#13;
      <p class="Information-Box--PACKT-">Since Python 3.6, all Python dictionaries are ordered, so they'll return their keys in the order they have been input previously. We take advantage of that for this. Note we need to convert the result from <code class="Code-In-Text--PACKT-">CACHE.keys()</code> (a <code class="Code-In-Text--PACKT-">dict_keys</code> object) to a list to allow getting the first element.</p>&#13;&#13;
    </p>&#13;&#13;
    <p class="normal">The dictionary won't be able to grow. Let's now try to run it and see the results of the profiling.</p>&#13;&#13;
    <pre class="programlisting con"><code class="hljs-con">$ time python3 -m memory_profiler leonardo_3.py&#13;&#13;
...&#13;&#13;
Filename: leonardo_3.py&#13;&#13;
Line #    Mem usage    Increment  Occurences   Line Contents&#13;&#13;
============================================================&#13;&#13;
     5   38.441 MiB   38.434 MiB      104999   @profile&#13;&#13;
     6                                         def leonardo(number):&#13;&#13;
     7&#13;&#13;
     8   38.441 MiB    0.000 MiB      104999       if number in (0, 1):&#13;&#13;
     9   38.367 MiB    0.000 MiB           5           return 1&#13;&#13;
    10&#13;&#13;
    11   38.441 MiB    0.000 MiB      104994       if number not in CACHE:&#13;&#13;
    12   38.441 MiB    0.008 MiB       34999           result = leonardo(number - 1) + leonardo(number - 2) + 1&#13;&#13;
    13   38.441 MiB    0.000 MiB       34999           CACHE[number] = result&#13;&#13;
    14&#13;&#13;
    15   38.441 MiB    0.000 MiB      104994       ret_value = CACHE[number]&#13;&#13;
    16&#13;&#13;
    17   38.441 MiB    0.000 MiB      104994       MAX_SIZE = 5&#13;&#13;
    18   38.441 MiB    0.000 MiB      139988       while len(CACHE) &gt; MAX_SIZE:&#13;&#13;
    19                                                 # Maximum size allowed,&#13;&#13;
    20                                                 # delete the first value, which will be the oldest&#13;&#13;
    21   38.441 MiB    0.000 MiB       34994           key = list(CACHE.keys())[0]&#13;&#13;
    22   38.441 MiB    0.000 MiB       34994           del CACHE[key]&#13;&#13;
    23&#13;&#13;
    24   38.441 MiB    0.000 MiB      104994       return ret_value&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">In this <a id="_idIndexMarker984"/>case, we see how the memory remains stable at around the <code class="Code-In-Text--PACKT-">38 MiB</code>, that we see is the minimum. In this case, note how there are no increments or decrements. Really what happens here is that increments and decrements are too small to be noticed. Because they cancel each other, the report is close to zero.</p>&#13;&#13;
    <p class="normal">The <code class="Code-In-Text--PACKT-">memory-profiler</code> module is also able to perform more actions, including showing the usage of memory based on time and plotting it, so you can see memory increasing or decreasing over time. Take a <a id="_idIndexMarker985"/>look at its full documentation at <a href="https://pypi.org/project/memory-profiler/">https://pypi.org/project/memory-profiler/</a>.</p>&#13;&#13;
    <h1 id="_idParaDest-272" class="title">Summary</h1>&#13;&#13;
    <p class="normal">In this chapter, we described what profiling is and when it's useful to apply it. We described that profiling is a dynamic tool that allows you to understand how code runs. This information is useful in understanding the flow in a practice situation and being able to optimize the code with that information. Code can be optimized normally to execute faster, but other alternatives are open, like using fewer resources (normally memory), reducing external accesses, etc.</p>&#13;&#13;
    <p class="normal">We described the main types of profilers: deterministic profilers, statistical profilers, and memory profilers. The first two are mostly oriented toward improving the performance of code and memory profilers analyze the memory used by the code in execution. Deterministic profilers instrument the code to detail the flow of the code as it's executed. Statistical profilers sample the code at periodic times to provide a general view of the parts of the code that are executed more often.</p>&#13;&#13;
    <p class="normal">We then showed how to profile the code using deterministic profilers, presenting an example. We analyzed it first with the built-in module <code class="Code-In-Text--PACKT-">cProfile</code>, which gives a function resolution. We saw how to use graphical tools to show the results. To dig deeper, we used the third-party module <code class="Code-In-Text--PACKT-">line-profiler</code>, which goes through each of the code lines. Once the flow of the code is understood, it is optimized to greatly reduce its execution time.</p>&#13;&#13;
    <p class="normal">The next step was to see how to profile a process intended to keep running, like a web server. We showed the problems with trying to profile the whole application in these cases and described how we can profile each individual request instead for clarity.</p>&#13;&#13;
    <p>&#13;&#13;
      <p class="Tip--PACKT-">These techniques are also applicable to other situations like conditional profiling, profiling in only certain situations, like at certain times or one of each 100 requests.</p>&#13;&#13;
    </p>&#13;&#13;
    <p class="normal">Finally, we also presented an example to profile memory and see how it's used by using the module <code class="Code-In-Text--PACKT-">memory-profiler</code>.</p>&#13;&#13;
    <p class="normal">In the next chapter, we will learn more details about how to find and fix problems in code, including in complex situations, through debugging techniques.</p>&#13;&#13;
  </div>&#13;&#13;
</div></body></html>