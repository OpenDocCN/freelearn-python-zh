- en: 5\. Serving Static Files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will start by learning the difference between static and
    dynamic responses. You will then see how the Django `staticfiles` app helps manage
    static files. Continuing work on the Bookr app, you will enhance it with images
    and CSS. You'll learn the different ways you can lay out your static files for
    your project and examine how Django consolidates them for production deployment.
    Django includes tools to reference static files in templates and you'll see how
    these tools help reduce the amount of work needed when deploying an application
    to production. After this, you'll explore the `findstatic` command, which can
    be used to debug issues with your static files. Later, you'll get an overview
    of how to write code for storing static files on a remote service. Finally, you'll
    look at caching web assets and how Django can help with cache invalidation.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A web application with just plain **Hypertext Markup Language** (**HTML**) is
    quite limiting. We can enhance the look of web pages with **Cascading Style Sheets**
    (**CSS**) and images, and we can add interaction with JavaScript. We call all
    these kinds of files "static files." They are developed and then deployed as part
    of the application. We can compare these to dynamic responses, which are generated
    in real time when a request is made. All the views you have written generate a
    dynamic response by rendering a template. Note that we will not consider templates
    to be static files as they are not sent verbatim to a client; instead, they are
    rendered first and sent as part of a dynamic response.
  prefs: []
  type: TYPE_NORMAL
- en: During development, the static files are created on the developer's machine,
    and they must then be moved to the production web server. If you have to move
    to production in a short timeframe (say, a few hours), then it can be time-consuming
    to collect all the static assets, move them to the correct directory, and upload
    them to the server. When developing web applications using other frameworks or
    languages, you might need to manually put all of your static files into a specific
    directory that your web server hosts. Making changes to the URL from which static
    files are served might mean updating values throughout your code.
  prefs: []
  type: TYPE_NORMAL
- en: Django can manage static assets for us to make this process easier. It provides
    tools for serving them with its development server during development. When your
    application goes to production, it can also collect all your assets and copy them
    to a folder for a dedicated web server to host. This allows you to keep your static
    files segregated in a meaningful way during development and automatically bundle
    them for deployment.
  prefs: []
  type: TYPE_NORMAL
- en: 'This functionality is provided by Django''s built-in `staticfiles` app. It
    adds several useful features for working with and serving static files:'
  prefs: []
  type: TYPE_NORMAL
- en: The `static` template tag to automatically build the static URL for an asset
    and include it in your HTML.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A view (called `static`) that serves static files in development.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static file finders to customize where assets are found on your filesystem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `collectstatic` management command, which finds all static files and moves
    them into a single directory for deployment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `findstatic` management command, which shows which static file on disk is
    loaded for a particular request. This also helps to debug if a particular file
    is not being loaded.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the exercises and activities in this chapter, we will be adding static files
    (images and CSS) to the Bookr application. Each file will be stored inside the
    Bookr project directory during development. We need to generate a URL for each
    so that the templates can reference them, and the browser can download them. Once
    the URL is generated, Django needs to serve these files. When we deploy the Bookr
    application to production, all the static files need to be found and moved to
    a directory where they can be served by the production web server. If there are
    static files that are not loading as expected, we need some method of determining
    what the cause is.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the sake of simplicity, let''s take a single static file as an example:
    `logo.png`. We will briefly introduce the role of each feature we mentioned in
    the previous paragraph and explain them in depth throughout the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The `static` template tag is used to convert a filename to a URL or path that
    can be used in a template, for example, from `logo.png` to `/static/logo.png`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `static` view receives a request to load the static file at the path `/static/logo.png`.
    It reads the file and sends it to the browser.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A static file finder (or just `finder`) is used by the `static` view to locate
    the static file on the disk. There are different finders, but in this example,
    a finder is just converting from the URL path `/static/logo.png` to the path on
    disk `bookr/static/logo.png`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When deploying to production, the `collectstatic` management command is used.
    This will copy the `logo.png` file from the `bookr` project directory to a web
    server directory, such as `/var/www/bookr/static/logo.png`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a static file is not working (for example, a request for it returns a `404
    Not Found` response, or the wrong file is being served), then we can use the `findstatic`
    management command to try to determine the reason. This command takes the filename
    as a parameter and will output which directories were looked through and where
    it was able to locate that requested file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are the most common features that are used day to day, but there are others
    that we will also discuss.
  prefs: []
  type: TYPE_NORMAL
- en: Static File Serving
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the introduction, we mentioned that Django includes a view function called
    `static` that serves static files. The first important point to make regarding
    the serving of static files is that Django is not intended to serve them in production.
    It is not Django's role, and in production, Django will refuse to serve static
    files. This is normal and intended behavior. If Django is just reading from the
    filesystem and sending out a file, then it has no advantage over a normal web
    server, which would probably be more performant at this task. Furthermore, if
    you serve static files with Django, you will keep the Python process busy for
    the duration of the request and it will be unable to serve the dynamic requests
    to which it is more suited.
  prefs: []
  type: TYPE_NORMAL
- en: For these reasons, the Django `static` view is designed only for use during
    development and will not work if your `DEBUG` setting is `False`. Since during
    development we only usually have one person accessing the site at a time (the
    developer), Django is fine to serve static files. Soon, we will discuss more how
    the `staticfiles` app supports production deployment. The entire production deployment
    process will be covered in *Chapter 17*, *Deployment of a Django Application (Part
    1 – Server Setup)*. This chapter can be downloaded from the GitHub repository
    of this book, at [http://packt.live/2Kx6FmR](http://packt.live/2Kx6FmR).
  prefs: []
  type: TYPE_NORMAL
- en: 'A URL mapping to the `static` view is automatically set up when running the
    Django development server, provided that your `settings.py` file meets the following conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: Has `DEBUG` set to `True`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contains `'django.contrib.staticfiles'` in its `INSTALLED_APPS`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both settings exist by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'The URL mapping that is created is roughly equivalent to having the following
    map in your `urlpatterns`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Any URL starting with `settings.STATIC_URL` (which is `/static/` by default)
    gets mapped to the `static` view.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can still use the `static` view without having `staticfiles` in `INSTALLED_APPS`,
    but you must set up an equivalent URL mapping manually.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Static File Finders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are three times when Django needs to locate static files on disk, and
    for this, it uses a **static file finder**. A static file finder could be thought
    of like a plugin. It is a class that implements methods for converting URL paths
    to disks and iterates through the project directory to find static files.
  prefs: []
  type: TYPE_NORMAL
- en: The first time Django needs to locate static files on disk is when the Django
    `static` view receives a request to load a particular static file; it then needs
    to convert the path in the URL to a location on disk. For example, the URL's path
    is `/static/logo.png`, and it is converted to the path `bookr/static/logo.png`
    on the disk. As we noted in the previous section, this is only during development.
    On a production server, Django should not receive this request as it will be handled
    directly by the web server.
  prefs: []
  type: TYPE_NORMAL
- en: The second time is when using the `collectstatic` management command. This gathers
    up all the static files in the project directory and copies them to a single directory
    to be served by the production web server. `bookr/static/logo.png` will get copied
    to the web server root, for example, `/var/www/bookr/static/logo.png`. The static
    file finder contains code to locate all the static files inside your project directory.
  prefs: []
  type: TYPE_NORMAL
- en: The last time a static file finder is used is during the execution of the `findstatic`
    management command. This is similar to the first usage in that it accepts a static
    file's name (such as `logo.png`), but it outputs the full path (`bookr/static/logo.png`)
    to the terminal instead of loading the file content.
  prefs: []
  type: TYPE_NORMAL
- en: Django comes with some built-in finders, but you can also write your own if
    you want to store static files in a custom directory layout. The list of finders
    Django uses is defined by the `STATICFILES_FINDERS` setting in `settings.py`.
    In this chapter, we will cover the behavior of the default static file finders,
    `AppDirectoriesFinder` and `FileSystemFinder`, in the *AppDirectoriesFinder* and
    *FileSystemFinder* sections, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you look in `settings.py`, you won't see that `STATICFILES_FINDERS` setting
    defined by default. This is because Django will use its built-in default for the
    setting, which is defined as the list `['django.contrib.staticfiles.finders.FileSystemFinder',
    ' django.contrib.staticfiles.finders.AppDirectoriesFinder']`. If you add the `STATICFILES_FINDERS`
    setting to your `settings.py` file to include a custom finder, be sure to include
    these defaults if you're using them.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will discuss static file finders and their use in the first case –
    responding to a request. Then we will introduce some more concepts and return
    to the behavior of `collectstatic` and how it uses static file finders. Later
    in the chapter, we will work with the `findstatic` command to see how to use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Static File Finders: Use During a Request'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When Django receives a request for a static file (remember, Django will only
    serve static files during development), each static file finder that has been
    defined will be queried until a file on disk has been found. If none of the finders
    can locate a file, the `static` view will return an `HTTP 404 Not Found` response.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the URL of the request will be something like `/static/main.css`
    or `/static/reviews/ logo.png`. Each finder will be queried in turn with the path
    from the URL and will return a path such as `bookr/static/main.css` for the first
    file and `bookr/reviews/static/reviews/logo.png` for the second. Each finder will
    use its own logic to convert from a URL path to a filesystem path – we will discuss
    this logic in the upcoming *AppDirectoriesFinder* and *FileSystemFinder* sections.
  prefs: []
  type: TYPE_NORMAL
- en: AppDirectoriesFinder
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `AppDirectoriesFinder` class is used to find static files inside each app
    directory, in a directory called `static`. The application must be listed in the
    `INSTALLED_APPS` setting in your `settings.py` file (we did this in *Chapter 1*,
    *Introduction to Django*). As we also mentioned in *Chapter 1*, *Introduction
    to Django*, it is good for apps to be self-contained. By letting each application
    have its own `static` directory, we can continue the self-contained design by
    also storing app-specific static files inside the app directory too.
  prefs: []
  type: TYPE_NORMAL
- en: Before we use `AppDirectoriesFinder`, we will explain a problem that can occur
    if multiple static files have the same name, and also how to solve this problem.
  prefs: []
  type: TYPE_NORMAL
- en: Static File Namespacing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the *Static File Finders: Use during a Request* section, we discussed serving
    a file named `logo.png`. This would provide a logo for the `reviews` application.
    The filename (`logo.png`) could be quite common – you could imagine that if we
    added a `store` app (for purchasing books), it would also have a logo. Not to
    mention that third-party Django apps might also want to use a common name like
    `logo.png`. The problem we are about to describe could apply to any static file
    that has a common name, such as `styles.css` or `main.js`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the `reviews` and `store` examples. We can add a `static` directory
    in each of these apps. Then, each `static` directory would have a `logo.png` file
    (although it would be a different logo). The directory structure is as shown in
    *Figure 5.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1: Directory layout with static directories inside app directories'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_05_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.1: Directory layout with static directories inside app directories'
  prefs: []
  type: TYPE_NORMAL
- en: The URL path that we use to download a static file is relative to the static
    directory. Therefore, it is unclear which `logo.png` is being referenced if we
    make an HTTP request for `/static/logo.png`. Django will check the `static` directory
    for each application in turn (in the order they are specified in the `INSTALLED_APPS`
    setting). The first `logo.png` it locates, it will serve. There is no way, in
    this directory layout, to specify which `logo.png` you want to load.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can solve this problem by `static` directory, named the same as the app.
    The `reviews` app has a `reviews` directory inside its `static` directory, and
    the `store` app has a `store` directory inside its `static` directory. The respective
    `logo.png` files are then moved inside these subdirectories. The new directory
    layout is as shown in *Figure 5.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2: Directory layout with namespaced directories'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_05_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.2: Directory layout with namespaced directories'
  prefs: []
  type: TYPE_NORMAL
- en: 'To load a specific file, we include the namespaced directory too. For the `reviews`
    logo, the URL path is `/static/reviews/logo.png`, which maps to `bookr/reviews/static/review/logo.png`
    on disk. Similarly, for the store logo, its path is `/static/store/logo.png`,
    which maps to `bookr/store/static/store/logo.png`. You might have noticed that
    the examples path for the `logo.png` file is already namespaced in the *Static
    File Finders: Use during a Request* section.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are considering writing a Django app that might be released as its own
    standalone plugin, you could use an even more explicit sub-directory name. For
    example, choose one that contains the entire dotted project path: *bookr/reviews/static/bookr.reviews*.
    In most cases, though, it is fine for the sub-directory name to be unique to just
    your project.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have introduced `AppDirectoriesFinder` and static file namespacing,
    we can use them to serve our first static file. In the first exercise of the chapter,
    we will create a new Django project for a basic business site. We will then serve
    a logo file from an app called `landing` that we will create in this project.
    The `AppDirectoriesFinder` class is used to find static files inside each app
    directory, in a directory called `static`. The application must be listed in the
    `INSTALLED_APPS` setting in your `settings.py` file. As we have mentioned in *Chapter
    1*, *Introduction to Django*, it is good for apps to be self-contained. By letting
    each application have its own `static` directory, we can continue the self-contained
    design by also storing app-specific static files inside the app directory too.
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to serve a static file is from an app directory. This is because
    we do not need to make any settings changes. Instead, we just need to create the
    files in the correct directory, and they will be served using the default Django
    configuration.
  prefs: []
  type: TYPE_NORMAL
- en: The Business Site Project
  prefs: []
  type: TYPE_NORMAL
- en: For the exercises in this chapter, we'll create a new Django project and use
    it to demonstrate the static file concepts. The project will be a basic business
    site with a simple landing page that has a logo. The project will have one app,
    calling `landing`.
  prefs: []
  type: TYPE_NORMAL
- en: You can refer to *Exercise 1.01*, *Creating a Project and App, and Starting
    the dev server* from *Chapter 1*, *Introduction to Django*, to refresh your memory
    on creating a Django project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5.01: Serving a File from an App Directory'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will add a logo file for the `landing` app. This will
    be done by putting a `logo.png` file in a `static` directory inside the `landing`
    app directory. After this is done, you can test that the static file is being
    served correctly and confirm the URL that will serve it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating the new Django project. You can reuse the `bookr` virtual
    environment that already has Django installed. Open a new terminal and activate
    the virtual environment (refer to the *Preface* for instructions on how to create
    and activate a virtual environment). Then, run the `django-admin` command in the
    terminal (or command shell) to start a Django project named `business_site`. To
    do this, run this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There will not be any output. This command will scaffold the Django project
    in a new directory named `business_site`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a new Django app in this project by using the `startapp` management
    command. The app should be called *landing*. To do this, `cd` into the `business_site`
    directory, then run this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that there will not be any output again. The command will create the `landing`
    app directory inside the `business_site` directory.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Remember that on Windows the command is `python manage.py startapp landing`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Launch PyCharm, then open the `business_site` directory. If you already have
    a project open, you can do this by choosing `File` -> `Open`; otherwise, just
    click `Open` in the `Welcome to PyCharm` window. Navigate to the `business_site`
    directory, select it, then click `Open`. The `business_site` project window should
    be shown like *Figure 5.3*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For detailed instructions on how to set up and configure PyCharm to work with
    your Django project, refer to *Exercise 1.02*, *Project Setup in PyCharm*, in
    *Chapter 1*, *Introduction to Django*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 5.3: The business_site project'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15509_05_03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 5.3: The business_site project'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a new run configuration to execute `manage.py runserver` for the project.
    You can reuse the `bookr` virtual environment again. The `Run/Debug Configurations`
    window should look like *Figure 5.4*. when you are done:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note that if you are not sure how to configure these settings in PyCharm, refer
    to *Exercise 1.02*, *Project Setup in PyCharm*, from *Chapter 1*, *Introduction
    to Django*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 5.4: Run/Debug Configurations for Runserver'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15509_05_04.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 5.4: Run/Debug Configurations for Runserver'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can test that the configuration is set up correctly by clicking the `Run`
    button, then visiting `http://127.0.0.1:8000/` in your browser. You should see
    the Django welcome screen. If the debug server fails to start or you see the Bookr
    main page, then you probably still have the Bookr project running. Try stopping
    the Bookr `runserver` process (press *Ctrl* + *C* in the terminal that is running
    it) and then starting the new one you just set up.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Open `settings.py` in the `business_site` directory and add `'landing'` to the
    `INSTALLED_APPS` setting. Remember we learned how to do this in *step 1* of *Exercise
    1.05*, *Creating a Templates Directory and Base Template*, in *Chapter 1*, *Introduction
    to Django*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In PyCharm, right-click the `landing` directory in the `Project` pane and select
    `New` -> `Directory`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the name `static` and click `OK`:![Figure 5.5: Naming the directory static'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15509_05_05.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 5.5: Naming the directory static'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Right-click the `static` directory you just created and select `New` -> `Directory`
    again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the name `landing` and click `OK`. This is to implement namespacing of
    the static files directory as we discussed earlier:![Figure 5.6: Naming the new
    directory landing, to implement namespacing'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15509_05_06.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 5.6: Naming the new directory landing, to implement namespacing'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Download `logo.png` from [https://packt.live/2KM6kfT](https://packt.live/2KM6kfT)
    and move it into the `landing/static/landing` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start the Django dev server, if it is not already running, then navigate to
    `http://127.0.0.1:8000/static/landing/logo.png`. You should see the image being
    served in your browser:![Figure 5.7: Image served by Django'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15509_05_07.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 5.7: Image served by Django'
  prefs: []
  type: TYPE_NORMAL
- en: If you see the image as in *Figure 5.7*, you have set up static file serving
    correctly. Now let us look at how to automatically insert this URL into your HTML
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Generating Static URLs with the static Template Tag
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In *Exercise 5.01*, *Serving a File from an App Directory*, you set up an image
    file to be served by Django. You saw that the URL of the image was `http://127.0.0.1:8000/static/landing/logo.png`,
    which you could use inside an HTML template. For example, to display the image
    with an `img` tag, you could use this code in your template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, since Django is also serving the media and has the same host as the dynamic
    template response, you can simplify this by just including the path, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Both addresses (URLs and paths) have been hardcoded into the template; that
    is, we include the full path to the static file and make assumptions about where
    the file is being hosted. This works fine with the Django dev server or if you
    host your static files and Django website on the same domain. For more performance
    as your site becomes more popular, you might consider serving static files from
    their own domain or **Content Delivery Network** (**CDN**).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: A **CDN** is a service that can host parts or all of your website for you. They
    provide several web servers and can seamlessly speed up the loading of your website.
    For example, they might serve files to a user from the server that is geographically
    closest to them. There are several CDN providers, and depending on how they are
    set up, they might require you to specify a certain domain from which to serve
    your static files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take, for instance, a common separation approach: using a different domain
    for static file serving. You host your main website at `https://www.example.com`
    but want to serve static files from `https://static.example.com`. During development,
    we could use just the path to the logo file as in the example we just saw. But
    when we deploy to the production server, our URLs would need to change to include
    the domain, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Since all the links are hardcoded, this would need to be done for every URL
    throughout our templates, every time we deploy to production. Once they were changed,
    though, the URL would no longer work in the Django dev server. Luckily, Django
    provides a solution to this problem.
  prefs: []
  type: TYPE_NORMAL
- en: The `staticfiles` app provides a template tag, `static`, to dynamically generate
    the URL to a static file inside a template. Since the URLs are all being dynamically
    generated, we can change the URL for all of them by changing just one setting
    (`STATIC_URL` in `settings.py` – more on this soon). Furthermore, later we will
    introduce a method of invalidating browser caches for static files that relies
    on the use of the `static` template tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `static` tag is very simple: it takes a single argument, which is the project-relative
    path to a static asset. It will then output this path prepended with the `STATIC_URL`
    setting. It must first be loaded into the template with the `{% load static %}`
    template tag.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Django has a set of default template tags and filters (or tag sets) that it
    automatically makes available to every template. Django (and third-party libraries)
    also provides tag sets that are not automatically loaded. In these cases, we need
    to load these extra template tags and filters into a template before we can use
    them. This is done with the use of the `load` template tag, which should come
    near the start of a template (although it must be after the `extends` template
    tag, if one is used). The `load` template tag takes one or more packages/libraries
    to load, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This would load the template tag and filters set provided by the (made-up) `package_one`,
    `package_two`, and `package_three` packages.
  prefs: []
  type: TYPE_NORMAL
- en: The `load` template tag must be used in the actual template that requires the
    loaded package. In other words, if your template extends another template and
    that base template has loaded a certain package, your dependent template does
    not automatically have access to that package. Your template must still `load`
    the package to access the new tag set. The `static` template tag is not part of
    the default set, which is why we need to load it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, it can be used to interpolate anywhere inside the template file. For
    example, by default, Django uses `/static/` as `STATIC_URL`. If we wanted to generate
    the static URL for our `logo.png` file, we would use the tag in a template like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The output inside the template would be this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This would be made clearer with an example, so let's look at how the `static`
    tag could be used to generate a URL for a number of different assets.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can include the logo as an image on the page with an `img` tag, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This is rendered in the template as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Or we could use the `static` tag to generate the URL for a linked CSS file,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This will be rendered as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'It can be used in a `script` tag to include a JavaScript file, using the following
    line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This is rendered as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We can even use it to generate a link to a static file for download:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Note that this won't generate the actual PDF content; it will just create a
    link to an already-existing file.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is rendered as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Referring to these examples, we can now demonstrate the advantage of using the
    `static` tag instead of hardcoding. When we are ready to deploy to production,
    we can just change the `STATIC_URL` value in `settings.py`. None of the values
    in the templates need to be changed.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we can change `STATIC_URL` to `https://static.example.com/`, and
    then when the page next gets rendered, the examples we've seen will automatically
    update as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following line shows this for the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is for the CSS link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'For the script, it''s as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, the following is for the link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that in all these examples, a literal string is being passed as an argument
    (it is quoted). You can also use a variable as an argument. For example, say you
    were rendering a template with a context such as in this example code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We are rendering the `example.html` template with an `image_file` variable.
    This variable has the value `logo.png`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You would pass this variable to the `static` tag without quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'It would render like this (assuming we changed `STATIC_URL` back to `/static/`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The template tag can also be used with the `as [variable]` suffix to assign
    the result to a variable for use later in the template. This can be useful if
    the static file lookup takes a long time and you want to refer to the same static
    file multiple times (like when including an image in multiple places).
  prefs: []
  type: TYPE_NORMAL
- en: 'The first time you refer to the static URL, give it a variable name to assign
    to. In this case, we are creating the `logo_path` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This renders the same as the examples we''ve seen before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'However, we can then use the assigned variable (`logo_path`) again later in
    the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'That renders the same again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This variable is now just a normal context variable in the template scope and
    can be used anywhere in the template. Be careful, though, as you might override
    a variable that has already been defined – although this a general warning when
    using any of the template tags that assign variables (for example, `{% with %}`).
  prefs: []
  type: TYPE_NORMAL
- en: In the next exercise, we will put the `static` template into practice to add
    the Bookr reviews logo to the Bookr site.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5.02: Using the static Template Tag'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In *Exercise 5.01*, *Serving a File from an App Directory*, you tested serving
    the `logo.png` file from the static directory. In this exercise, you will continue
    with the business site project and create an `index.html` file as the template
    for our landing page. Then you''ll include the logo inside this page, using the
    {`% static %`} template tag:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In PyCharm (make sure you''re in the `business_site` project), right-click
    the `business_site` project directory and create a new folder called `templates`.
    Right-click this directory and select `New` -> `HTML File`. Select `HTML 5 file`
    and name it `index.html`:![Figure 5.8: new index.html'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15509_05_08.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 5.8: new index.html'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`index.html` will open. First, load the `static` tag library to make the `static`
    tag available in the template. Do this with the `load` template tag. On the second
    line of the file (just after the `<!DOCTYPE html>`), add this line to load the
    static library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can also make the template a bit nicer with some extra content. Enter the
    text `Business Site` inside the `<title>` tags:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, inside the body, add an `<h1>` element with the text `Welcome to my Business
    Site`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Underneath the heading text, use the `{% static %}` template tag to set the
    source of `<img>`. You will use it to refer to the logo from *Exercise 5.01*,
    *Serving a File from an App Directory*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, to flesh out the site a bit, add a `<p>` element under `<img>`. Give
    it some text about the business:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Although the extra text and title are not too important, they give an idea
    of how to use the `{% static %`} template tag around the rest of the content.
    Save the file. It should look like this once complete: [http://packt.live/37RUVnE](http://packt.live/37RUVnE).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, set up a URL to use to render the template. You will also use the built-in
    `TemplateView` to render the template without having to create a view. Open `urls.py`
    in the `business_site` package directory. At the start of the file, import `TemplateView`
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can also remove this Django admin import line since we''re not using it
    in this project:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a URL map from `/` to a `TemplateView`. The `as_view` method of `TemplateView`
    takes `template_name` as an argument, which is used in the same way as a path
    that you might pass to the `render` function. Your `urlpatterns` should look like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save the `urls.py` file. Once complete, it should look like this: [http://packt.live/2KLTrlY](http://packt.live/2KLTrlY).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Since we're not using the `landing` app template directory to store this template,
    you need to tell Django to use the `templates` directory you created in *step
    1*. Do this by adding the directory to the `TEMPLATES['DIRS']` list in `settings.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `settings.py` in the `business_site` directory. Scroll down until you
    find the `TEMPLATES` setting. It will look like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add `os.path.join(BASE_DIR, ''templates'')` into the `DIRS` setting, so the
    `TEMPLATES` setting looks like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: import os
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start the Django dev server, if it''s not already running. Navigate to `http://127.0.0.1:8000/`
    in your browser. You should see your new landing page as in *Figure 5.9*:![Figure
    5.9: The site with the logo'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15509_05_09.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 5.9: The site with the logo'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we added a base template for `landing` and loaded the static
    library into the template. Once the static library was loaded, we were able to
    use the `static` template tag to load an image. We then were able to see our business
    logo rendered in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: All of the static file loading has so far used `AppDirectoriesFinder`, because
    it required no extra configuration to use it. In the next section, we will look
    at `FileSystemFinder`, which is more flexible but requires a small amount of configuration
    to use it.
  prefs: []
  type: TYPE_NORMAL
- en: FileSystemFinder
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've learned about `AppDirectoriesFinder`, which loads static files inside
    Django app directories. However, well-designed apps should be self-contained and
    therefore should only contain static files that they themselves rely on. If we
    have other static files that are used throughout the website or across different
    apps, we should store them outside the app directory.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'As a general rule, your CSS is probably consistent throughout your site and
    could be kept in a global directory. Some images and JavaScript code could be
    specific to apps, so these would be stored in the static directory for that application.
    This is just general advice, though: you can store static files anywhere that
    makes the most sense for your project.'
  prefs: []
  type: TYPE_NORMAL
- en: In our business site application, we will be storing a CSS file in a site static
    directory, as it will be used not only in the `landing` app but throughout the
    site as we add more apps.
  prefs: []
  type: TYPE_NORMAL
- en: Django provides support for serving static files from arbitrary directories
    using its `FileSystemFinder` static file finder. The directories can be anywhere
    on the disk. Usually, you will have a `static` directory inside your project directory,
    but if your company has a global static directory that is used in many different
    projects (including non-Django web applications), then you could use this as well.
  prefs: []
  type: TYPE_NORMAL
- en: '`FileSystemFinder` uses the `STATICFILES_DIRS` setting in the `settings.py`
    file to determine which directories to search for static files in. This is not
    present when the project is created and must be set by the developer. We will
    add it in the next exercise. There are two options for building this list:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting a list of directories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting a list of tuples in the form `(prefix, directory)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second use case will be easier to understand once we have covered some more
    of the fundamentals, so we will return to it after explaining and demonstrating
    the first case. It is covered after *Exercise 5.04*, *Collecting Static Files
    for Production*, in the *STATICFILES_DIRS Prefixed Mode* section. For now, we
    will just explain the first use case, which is just a list of one or more directories.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `business_site`, we will add a `static` directory inside the project directory
    (that is, in the same directory that contains the `landing` app and the `manage.py`
    file). We can use the `BASE_DIR` setting when building the list to assign to `STATICFILES_DIRS`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We also mentioned earlier in this section that you might want to set multiple
    directory paths in this list, for example, if you had some company-wide static
    data shared by multiple web projects. Simply add extra directories to the `STATICFILES_DIRS`
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Each of these directories would be checked in order to find a matching file.
    If a file existed in both directories, the first one found would be served. For
    example, if the `static/main.css` (inside the `business_site` project directory)
    and `/Users/username/projects/company-static/bar/main.css` files both existed,
    a request for `/static/main.css` would serve the `business_site` project's `main.css`
    as it is first in the list. Keep this in mind when deciding the order in which
    you add directories to `STATICFILES_DIRS`; you may choose to prioritize your project
    static files over the global ones or vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: In our business site (and later with Bookr), we will only use one `static` directory
    in this list, so we won't have to worry about this problem.
  prefs: []
  type: TYPE_NORMAL
- en: In the next exercise, we will add a `static` directory with a CSS file inside.
    Then we will configure the `STATICFILES_DIRS` setting to serve from the `static`
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5.03: Serving from a Project static Directory'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have already shown an example of serving an application-specific image file
    in *Exercise 5.01*, *Serving a File from an App Directory*. Now we want to serve
    a CSS file that is to be used throughout our project to set styles, so we will
    serve this from a static directory right inside the project folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this exercise, you''ll set up your project to serve static files from a
    specific directory, and then use the `{% static %}` template tag again to include
    it in the template. This will be done using the `business_site` example project:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `business_site` project in In PyCharm, if it's not already open. Then,
    right-click the `business_site` project directory (the top-level `business_site`
    directory, not the `business_site` package directory) and select `New` -> `Directory`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `New Directory` dialog, enter `static` and then click `OK`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click the `static` directory you just created and select `New` -> `File`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Name New File` dialog, enter `main.css` and click `OK`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The blank `main.css` file should open automatically. Enter a couple of simple
    CSS rules, to center the text, and set a font and background color. Enter this
    text into the `main.css` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can now save and class `main.css`. You can take a look at the complete
    file for reference: [http://packt.live/38H8a9N](http://packt.live/38H8a9N).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open `business_site/settings.py`. Here, set a list of directories to the `STATICFILES_DIRS`
    settings. In this case, the list will have just one item. Define a new `STATICFILES_DIRS`
    variable at the bottom of `settings.py`, using this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `settings.py` file, `BASE_DIR` is a variable that contains the path
    to the project directory. You can build the full path to the `static` directory
    you created in *step 2* by joining `static` to `BASE_DIR`. You then put this inside
    a list. The complete `settings.py` file should look like this: [http://packt.live/3hnQQKW](http://packt.live/3hnQQKW).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Start the Django dev server if it is not running. You can verify that the settings
    are correct by checking whether you can load the `main.css` file. Note that this
    is not namespaced so the URL is `http://127.0.0.1:8000/static/main.css`. Open
    this URL in your browser and check that the content matches what you just entered
    and saved:![Figure 5.10: CSS served by Django'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15509_05_10.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 5.10: CSS served by Django'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If the file does not load, check your `STATICFILES_DIRS` settings. You may need
    to restart the Django dev server if it was running while you made changes to `settings.py`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You now need to include `main.css` in your index template. Open `index.html`
    in the `templates` folder. Before the closing `</head>` tag, add this `<link>`
    tag to load the CSS:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This links in the `main.css` file, using the `{% static %}` template tag. As
    mentioned earlier, since `main.css` is not namespaced, you can just include its
    name. Save the file. It should look like this: [http://packt.live/392aedP](http://packt.live/392aedP).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Load `http://127.0.0.1:8000/` in your browser and you should see the background
    color, fonts, and alignment all change:![Figure 5.11: CSS applied with custom
    fonts visible'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15509_05_11.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 5.11: CSS applied with custom fonts visible'
  prefs: []
  type: TYPE_NORMAL
- en: Your business landing page should look like *Figure 5.11*. Since you included
    the CSS in the `base.html`template, it will be available in all templates that
    extend this template (although none do at the moment, it's good planning for the
    future).
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we put some CSS rules into their own file and served them
    using Django's `FileSystemFinder`. This was accomplished by creating a `static`
    directory inside the `business_site` project directory and specifying it in the
    Django settings (the `settings.py` file) using the `STATICFILES_DIRS` setting.
    We linked in the `main.css` file using the `static` template tag into the `base.html`
    template. We loaded the main page in our browser and saw that the font and color
    changes applied.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve now covered how static file finders are used during a request (to load
    a specific static file when given a URL). We''ll now look at their other use case:
    finding and copying static files for production deployment, when running the `collectstatic`
    management command.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Static File Finders: Use During collectstatic'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once we have finished working on our static files, they need to be moved into
    a specific directory that can be served by our production web server. We can then
    deploy our website by copying our Django code and static files to our production
    web server. In the case of `business_site`, we will want to move `logo.png` and
    `main.css` (along with other static files that Django itself includes) into a
    single directory that can be copied to the production web server. This is the
    role of the `collectstatic` management command.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have already discussed how Django uses static file finders during request
    handling. Now, we will cover the other use case: collecting static files for deployment.
    Upon running the `collectstatic` management command, Django uses each finder to
    list static files on the disk. Every static file that is found is then copied
    into the `STATIC_ROOT` directory (also defined in `settings.py`). This is a little
    bit like the reverse of handling a request. Instead of getting a URL path and
    mapping to a filesystem path, the filesystem path is being copied to a location
    that is predictable by the frontend web server. This allows the frontend web server
    to handle a request for a static file independently of Django.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: A frontend web server is designed to route requests to applications (like Django)
    or read static files from disk. It can handle requests faster but is not able
    to generate dynamic content in the same way as something like Django. Frontend
    web servers include software such as Apache HTTPD, Nginx, and lighttpd.
  prefs: []
  type: TYPE_NORMAL
- en: 'For some specific examples of how `collectstatic` works, we''ll use the two
    files from *Exercise 5.01*, *Serving a File from an App Directory*, and *Exercise
    5.03*, *Serving from a Project Status Directory*, respectively: `landing/static/landing/logo.png`
    and `static/main.css`.'
  prefs: []
  type: TYPE_NORMAL
- en: Assume that `STATIC_ROOT` is set to a directory being served by a normal web
    server – this would be something like `/var/www/business_site/static`. The destination
    for these files would be `/var/www/business_site/static/reviews/logo.png` and
    `/var/www/business_site/static/main.css`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now when a request for a static file comes in, the web server will easily be
    able to serve it because the paths are mapped consistently:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/static/main.css` is served from the `/var/www/business_site/static/main.css`
    file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/static/reviews/logo.png` is served from the `/var/www/business_site/static/reviews/logo.png`
    file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This means the web server root is `/var/www/business_site/` and static paths
    are just loaded directory from disk in the usual manner that a web server would
    load files.
  prefs: []
  type: TYPE_NORMAL
- en: We have demonstrated how Django locates static files during development and
    can serve them itself. In production, we need the frontend web server to be able
    to serve static files without involving Django, for both safety and speed.
  prefs: []
  type: TYPE_NORMAL
- en: Without having run `collectstatic`, a web server would not be able to map a
    URL back to a path. For example, it would not know that `main.css` must be loaded
    from the project static directory while `logo.png` is to be loaded from the `landing`
    app directory – it has no concept of the Django directory layout.
  prefs: []
  type: TYPE_NORMAL
- en: You might be tempted to serve files directly from the Django project directory
    by setting your web server root to this directory – do not do this. There is a
    security risk in sharing your entire Django project directory as it would make
    it possible to download our `settings.py` or other sensitive files. Running `collectstatic`
    will copy the files to a directory that can be moved outside the Django project
    directory to the web server root for security.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have talked about using Django to copy static files directly to the
    web server root. You could also have Django copy them to an intermediary directory
    and have your deployment process move to a CDN or another server afterward. We
    will not go into detail on specific deployment processes; how you choose to copy
    static files to the web server will depend on yours or your company's existing
    setup (for example, a continuous delivery pipeline).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `collectstatic` command does not take into consideration the use of `static`
    template tags. It will collect all the static files inside `static` directories,
    even those that your project does not include inside a template.
  prefs: []
  type: TYPE_NORMAL
- en: In the next exercise, we will see the `collectstatic` command in action. We
    will use it to copy all the `business_site` static files that we have so far into
    a temporary directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5.04: Collecting Static Files for Production'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While we won''t be covering deployment to a web server in this chapter, we
    can still use the `collectstatic` management command and see its result. In this
    exercise, we will create a temporary holding location for the static files to
    be copied into. This directory will be called `static_production_test` and will
    be located inside the `business_site` project directory. As part of the deployment
    process, you could copy this directory to your production web server. However,
    since we won''t be setting up a web server until *Chapter 17*, *Deployment of
    a Django Application (Part 1 – Server Setup)*, we will just examine its contents
    to understand how files are copied and organized:'
  prefs: []
  type: TYPE_NORMAL
- en: In PyCharm, create a temporary directory to put the collected files in. Right-click
    the `business_site` project directory (this is the top-level folder, not the `business_site`
    module) and select `New` -> `Directory`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `New Directory` dialog, enter the name `static_production_test` and click
    `OK`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `settings.py` and at the bottom of the file, define a new setting for
    `STATIC_ROOT`. Set it to the path of the directory you just created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will join `static_dir` to `BASE_DIR` (the business site project path)
    to generate the full path. Save the `settings.py` file. It should look like this:
    [http://packt.live/2Jq59Cc](http://packt.live/2Jq59Cc).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In a terminal, run the `collectstatic` `manage` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see output similar to the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This might seem like a lot if you were expecting it to copy just two files but
    remember that it will copy all the files for all installed apps. In this case,
    as you have the Django admin app installed, most of the 132 files are to support
    that.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let us look through the `static_production_test` directory to see what has
    been created. An expanded view of this directory (from the PyCharm project page)
    is shown in *Figure 5.12*, for reference. Yours should be similar.![Figure 5.12:
    Destination directory of the collectstatic command'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15509_05_12.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 5.12: Destination directory of the collectstatic command'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should notice three items inside:'
  prefs: []
  type: TYPE_NORMAL
- en: '`css`, `fonts`, `img`, and `js`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`static` directory from your landing app. Inside is the `logo.png` file. This
    directory has been created to match the namespacing of the directory that we created.'
  prefs: []
  type: TYPE_NORMAL
- en: '`static` directory. Since you didn''t place it inside a namespacing directory,
    this has been placed directly inside `STATIC_ROOT`.'
  prefs: []
  type: TYPE_NORMAL
- en: If you want, you can open up any of these files and verify that their content
    matches the files you have just been working on – they should do, as they are
    simply copies of the original files.
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we collected all the static files from `business_site` (including
    the `admin` static files that Django includes). They were copied into the directory
    defined by the `STATIC_ROOT` setting (`static_production_test` inside the `business_site`
    project directory). We saw that `main.css` was directly inside this folder but
    other static files were namespaced inside their app directories (`admin` and `reviews`).
    This folder could have been copied to a production web server to deploy our project.
  prefs: []
  type: TYPE_NORMAL
- en: STATICFILES_DIRS Prefixed Mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned earlier, the `STATICFILES_DIRS` setting also accepts items as tuples
    in the form `(prefix, directory)`. These modes of operation are not mutually exclusive,
    `STATICFILES_DIRS` may contain both non-prefixed (string) or prefixed (tuple)
    items. Essentially, this allows you to map a certain URL prefix to a directory.
    In Bookr, we do not have enough static assets to warrant setting this up, but
    it can be useful if you want to organize your static assets differently. For example,
    you can keep all your images in a certain directory, and all your CSS in another
    directory. You might need to do this if you use a third-party CSS generation tool
    such as Node.js with **LESS**.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: LESS is a CSS pre-processor that uses Node.js. It allows you to write CSS using
    variables and other programming-like concepts that don't exist natively. Node.js
    will then compile this to CSS. A more in-depth explanation is outside the scope
    of this book – suffice to say that if you use it (or a similar tool), then you
    might want to serve directly from the directory to which it saves its compiled
    output.
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest way to explain how prefixed mode works is with a short example.
    This will expand on the `STATICFILES_DIRS` setting created in *Exercise 5.03*,
    *Serving from a Project Static Directory*. In this example, two prefixed directories
    are added to this setting, one for serving images and one for serving CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: As well as the `static` directory that was already being served with no prefix,
    we have added the serving of the `static_images` directory inside the `business_site`
    project directory. This has the prefix `images`. We have also added the serving
    of the `static_css` directory inside the Bookr project directory, with the prefix
    `css`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we can serve three files, `main.js`, `main.css`, and `main.jpg`, from
    the `static`, `static_css`, and `static_images` directories, respectively. The
    directory layout would be as shown in *Figure 5.13*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.13: Directories layout for use with prefixed URLs'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_05_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.13: Directories layout for use with prefixed URLs'
  prefs: []
  type: TYPE_NORMAL
- en: 'In terms of accessing these through URLs, the mapping is as shown in *Figure
    5.14*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.14: Mappings of URLs to files, based on the prefix'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_05_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.14: Mappings of URLs to files, based on the prefix'
  prefs: []
  type: TYPE_NORMAL
- en: Django routes any static URL with a prefix to the directory that matches that
    prefix.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using the `static` template tag, use the prefix and filename, not the
    directory name. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'When the static files are gathered using the `collectstatic` command, they
    are moved into a directory with the prefix name, inside `STATIC_ROOT`. The source
    paths and the target paths inside the `STATIC_ROOT` directory are shown in *Figure
    5.15*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.15: Mappings of paths in project directories to paths in STATIC_ROOT'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_05_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.15: Mappings of paths in project directories to paths in STATIC_ROOT'
  prefs: []
  type: TYPE_NORMAL
- en: Django creates the prefix directories inside `STATIC_ROOT`. Because of this,
    the paths can be kept consistent even when using a web server and not routing
    the URL lookup through Django.
  prefs: []
  type: TYPE_NORMAL
- en: The findstatic Command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `staticfiles` application also provides one more management command: `findstatic`.
    This command allows you to enter the relative path to a static file (the same
    as what would be used inside a `static` template tag) and Django will tell you
    where that file was located. It can also be used in a verbose mode to output the
    directories it is searching through.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You may not be familiar with the concept of verbosity or verbose mode. Having
    a higher verbosity (or simply turning on verbose mode) will cause a command to
    generate more output. Many command-line applications can be executed with more
    or less verbosity. This can be helpful when trying to debug the programs you are
    using. To see an example of the verbose mode in action, you can try running the
    Python shell in verbose mode. Enter `python -v` (instead of just `python`) and
    hit `Enter`. Python will start in verbose mode and print out the path of every
    file it imports.
  prefs: []
  type: TYPE_NORMAL
- en: This command is mostly useful for debugging/troubleshooting purposes. If the
    wrong file is loading, or a particular file cannot be found, you can use this
    command to try to find out why. The command will display which file on disk is
    being loaded for a specific path, or let you know that the file cannot be found
    and what directories were searched.
  prefs: []
  type: TYPE_NORMAL
- en: This can help solve issues where multiple files have the same name, and the
    precedence is not what you expect. See the *FileSystemFinder* section for a note
    about precedence in the `STATICFILES_DIRS` setting. You might also see that Django
    is not searching in a directory you expect for the file, in which case the static
    directory might need to be added to the `STATICFILES_DIRS` setting.
  prefs: []
  type: TYPE_NORMAL
- en: In the next exercise, you will execute the `findstatic` management command,
    so you are familiar with what some of the output is for good (file found correctly)
    and bad (file missing) scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5.05: Finding Files Using findstatic'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You will now run the `findstatic` command with a variety of options and understand
    what its output means. First, we will use it to find a file that exists and see
    that it displays the path to the file. Then, we will try to find a file that does
    not exist and check the error that is output. We will then repeat this process
    with multiple levels of verbosity and different ways of interacting with the command.
    While this exercise will not make changes to or progress the Bookr project, it
    is good to be familiar with the command in case you need to use it when working
    on your own Django applications:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a terminal and navigate to the `business_site` project directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Execute the `findstatic` command with no options. It will output some help
    explaining how it is used:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The help output is displayed:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can find one or more files at a time; let''s start with the one that we
    know exists, `main.css`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The command outputs the path at which `main.css` was found:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Your full path will be different (unless you are also called Ben), but you can
    see that when Django locates `main.css` in a request it will load the `main.css`
    file from the project `static` directory.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This can be useful if a third-party application you have installed has not namespaced
    its static files correctly and is conflicting with one of your files.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s try finding a file that does not exist, `logo.png`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Django displays an error saying that the file could not be found:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Django is unable to locate this file because we have namespaced it – we must
    include the full relative path, the same as we have used in the `static` template tag.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Try finding `logo.png` again, but this time using the full path:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Django can find the file now:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finding multiple files at once is done by adding each file as an argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The location status for each file is shown:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The command can be executed with a verbosity of `0`, `1`, or `2`. By default,
    it executes at verbosity `1`. To set the verbosity, use the `--verbosity` or `-v`
    flag. Decrease the verbosity to `0` to only output the paths it locates without
    any extra information. No errors are displayed for missing paths:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output shows only found paths – notice no error is shown for the missing
    file, `missing-file.js`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This level of verbosity can be useful if you are piping the output to another
    file or command.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To get more information about which directories Django is searching in for
    the file you have requested, increase the verbosity to `2`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output contains much more information, including the directories that have
    been searched for the requested file. You can see that as the `admin` application
    is installed, Django is also searching in the Django admin application directory
    for static files:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 5.16: findstatic executed with verbosity 2, showing exactly'
  prefs: []
  type: TYPE_NORMAL
- en: which directories were searched
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_05_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.16: findstatic executed with verbosity 2, showing exactly which directories
    were searched'
  prefs: []
  type: TYPE_NORMAL
- en: The `findstatic` command is not something that you will use day to day when
    working with Django, but it is useful to know about when trying to troubleshoot
    problems with static files. We saw the command output the full path to a file
    that existed, as well as the error messages when files did not exist. We also
    ran the command and supplied multiple files at once and saw that information about
    all the files was output. Finally, we ran the command with different levels of
    verbosity. The `-v0` flag suppressed errors about missing files. `-v1` was the
    default and displayed found paths and errors. Increasing the verbosity using the
    `-v2` flag also printed out the directories that were being searched through for
    a particular static file.
  prefs: []
  type: TYPE_NORMAL
- en: Serving the Latest Files (for Cache Invalidation)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are not familiar with caching, the basic idea is that some operations
    can take a long time to perform. We can speed up a system by storing the results
    of an operation in a place that is faster to access so that the next time we need
    them, they can be retrieved quickly. The operation that takes a long time can
    be anything – from a function that takes a long time to run or an image that takes
    a long time to render, to a large asset that takes a long time to download over
    the internet. We are most interested in this last scenario.
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed that the first time you ever visit a particular website,
    it is slow to load, but then the next time it loads much faster. This is because
    your browser has cached some (or all) of the static files the site needs to load.
  prefs: []
  type: TYPE_NORMAL
- en: To use our business site as an example, we have a page that includes the `logo.png`
    file. The first time we visit the business site, we have to download the dynamic
    HTML, which is small and quick to transfer. Our browser parses the HTML and sees
    that `logo.png` should be included. It can then download this file too, which
    is much larger and can take longer to download. Note that this scenario assumes
    that the business site is now hosted on a remote server and not on our local machine
    – which is very fast for us to access.
  prefs: []
  type: TYPE_NORMAL
- en: If the web server is set up correctly, the browser will store `logo.png` on
    the computer. The next time we visit the *landing* page (or indeed any page that
    includes `logo.png`), your browser recognizes the URL can load the file from disk
    instead of having to download it again, thus speeding up the browsing experience.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We said that the browser will cache "if the web server is set up correctly."
    What does this mean? The frontend web server should be configured to send special
    HTTP headers as part of a static file response. It can send a `Cache-Control`
    header, which can have values such as `no-cache` (the file should never be cached;
    in other words, the latest version should be requested every time) or `max-age=<seconds>`
    (the file should only be downloaded again if it was last retrieved more than `<seconds>`
    seconds ago). The response could also contain the `Expires` header, with the value
    being a date. The file is considered to be "stale" once this date is reached,
    and at that point, the new version should be requested.
  prefs: []
  type: TYPE_NORMAL
- en: One of the hardest problems in computer science is cache invalidation. For instance,
    if we change `logo.png`, how does our browser know it should download the new
    version? The only surefire way of knowing it had changed would be to download
    the file again and compare it with the version we had already saved every time.
    Of course, this defeats the purpose of caching since we would still be downloading
    every time the file changed (or not). We can cache for an arbitrary or server-specified
    amount of time, but if the static file changed before that time was up, we would
    not know. We would use the old version until we considered it expired, at which
    time we would download the new version. If we had a 1-week expiry and the static
    file changed the next day, we would still be using the old one for 6 days. Of
    course, the browser can be made to reload the page without using the cache (how
    this is done depends on the browser, for example, *Shift* + *F5* or *Cmd* + *Shift*
    + *R*) if you want to force downloading of all static assets again.
  prefs: []
  type: TYPE_NORMAL
- en: There is no need to try to cache our dynamic responses (rendered templates).
    Since they are designed to be dynamic, we would want to make sure that the user
    gets the latest version on every page load, and so they should not be cached.
    They are also quite small in size (compared to assets like images), so there is
    not much speed advantage when caching them.
  prefs: []
  type: TYPE_NORMAL
- en: Django provides a built-in solution. During the `collectstatic` phase, when
    the files are copied, Django can append a hash of their content to the filename.
    For example, the `logo.png` source file will be copied to `static_production_test/landing/logo.f30ba08c60ba.png`.
    This is only done when using the `ManifestFilesStorage` storage engine. Since
    the filename is changing only when the content changes, the browser will always
    download the new content.
  prefs: []
  type: TYPE_NORMAL
- en: Using `ManifestFilesStorage` is just one way of invalidating caches. There may
    be other options that are more suitable for your application.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: A hash is a one-way function that generates a string of a fixed length regardless
    of the length of the input. There are several different hash functions available,
    and Django uses `a` is `0cc175b9c0f1b6a831c399e269772661`. The MD5 hash of the
    string (a much longer string) is `69fc4316c18cdd594a58ec2d59462b97`. They are
    both 32 characters long.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the storage engine is done by changing the `STATICFILES_STORAGE` value
    in `settings.py`. This is a string with a dotted path to the module and class
    to use. The class that implements the hash-addition functionality is `django.contrib.staticfiles.storage.ManifestStaticFilesStorage`.
  prefs: []
  type: TYPE_NORMAL
- en: Using this storage engine doesn't require any changes to your HTML templates,
    provided you are including static assets with the `static` template tag. Django
    generates a manifest file (`staticfiles.json`, in JSON format) that contains a
    mapping between the original filename and the hashed filename. It will automatically
    insert the hashed filename when using the `static` template tag. If you are including
    your static files without using the `static` tag and instead just manually insert
    the static URL, then your browser will attempt to load the non-hashed path and
    the URL will not automatically be updated when the cache should be invalidated.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we include `logo.png` with the `static` tag here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'When the page is rendered, the latest hash will be retrieved from `staticfiles.json`
    and the output will be like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'If we had not used the `static` tag and instead hardcoded the path, it would
    always appear as written:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Since this does not contain a hash, our browser will not see the path changing
    and thus never attempt to download the new file.
  prefs: []
  type: TYPE_NORMAL
- en: Django retains the previous version of files with the old hash when running
    `collectstatic`, so older versions of your application can still refer to it if
    they need to. The latest version of the file is also copied with no hash so non-Django
    applications can refer to it without needing to look up the hash.
  prefs: []
  type: TYPE_NORMAL
- en: In the next exercise, we will change our project settings to use the `ManifestFilesStorage`
    engine, then run the `collectstatic` management command. This will copy all the
    static assets as in *Exercise 5.04*, *Collecting Static Files for Production*;
    however, they will now have their hash included in the filename.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5.06: Exploring the ManifestFilesStorage Storage Engine'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will temporarily update *settings.py* to use `ManifestFilesStorage`,
    then run `collectstatic` to see how the files are generated with a hash:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In PyCharm (still in the `business_site` project), open `settings.py`. Add
    a `STATICFILES_STORAGE` setting at the bottom of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The completed file should look like this: [http://packt.live/2Jq59Cc](http://packt.live/2Jq59Cc).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open a terminal and navigate to the `business_site` project directory. Run
    the `collectstatic` command as you have before:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If your `static_production_test` directory is not empty (which will probably
    be the case as files were moved there during *Exercise 5.04*, *Collecting Static
    Files for Production*) then you will be prompted to allow the overwrite of the
    existing files:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 5.17: Prompt to allow overwrite during collectstatic'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15509_05_17.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Since you haven't changed any files since we last ran `collectstatic`, no files
    are copied. Instead, Django is just post-processing the files (28 of them), that
    is, generating their hash and appending the filename.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The static files were copied into the `static_production_test` directory as
    they were before; however, there are now two copies of each file: one named with
    the hash and one without.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`static/main.css` has been copied to `static_production_test/main.856c74fb7029.css`
    (this filename might be different if your CSS file contents differ, for example,
    if it has extra spaces or newlines):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 5.18: Expanded static_production_test directory with hashed filenames'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15509_05_18.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 5.18: Expanded static_production_test directory with hashed filenames'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Figure 5.18* shows the expanded `static_production_test` directory layout.
    You can see two copies of each static file and the `staticfiles.json` manifest
    file. To take `logo.png` as an example, you can see that `landing/static/landing/logo.png`
    has been copied to the same directory as `static_production_test/landing/logo.ba8d3d8fe184.png`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s make a change to the `main.css` file and see how the hash changes. Add
    some blank lines at the end of the file then save it. This won''t change the effect
    of the CSS but the change in the file will affect its hash. Rerun the `collectstatic`
    command in a terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once again, you may have to enter `yes` to confirm the overwrite:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Since only one file was changed, only one static file was copied (`main.css`).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Look inside the `static_production_test` directory again. You should see the
    old file with the old hash was retained, and a new file with a new hash has been
    added:![Figure 5.19: Another main.css file with the latest hash was added'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15509_05_19.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 5.19: Another main.css file with the latest hash was added'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this case, we have `main.856c74fb7029.css` (existing), `main.df1234ac4e63.css`
    (new), and `main.css`. Your hashes may differ.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `main.css` file (no hash) always contains the newest content; that is to
    say, the contents of the `main.df1234ac4e63.css` and `main.css` files are identical.
    During the execution of `collectstatic`, Django will copy the file with a hash,
    as well as without a hash.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now examine the `staticfiles.json` file that Django generates. This is the
    mapping that allows Django to look up the hashed path from the normal path. Open
    `static_production_test/staticfiles.json`. All the content may appear in one line;
    if it does, enable text soft wrapping from the `View` menu -> `Active Editor`
    -> `Soft Wrap`. Scroll to the end of the file and you should see an entry for
    the `main.css` file, for example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This is how Django is able to populate the correct URL in a template when using
    the `static` template tag: by looking up the hashed path in this mapping file.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We're finished with `business_site`, which we were just using for testing. You
    can delete the project or keep it around for reference during the activities.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Unfortunately, we can't examine how the hashed URL is interpolated in the template,
    because when running in debug mode, Django does not look up the hashed version
    of the file. As we know, the Django dev server only runs in debug mode, so if
    we turned debug mode off to try to view the hashed interpolation, then the Django
    dev server would not start. You will need to examine this interpolation yourself
    when going to production when using a frontend web server.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this exercise, we configured Django to use `ManifestFilesStorage` for its
    static file storage, by adding the `STATICFILES_STORAGE` setting to `settings.py`.
    We then executed the `collectstatic` command to see how the hashes are generated
    and added to the filename of the copied files. We saw the manifest file called
    `staticfiles.json`, which stored a lookup from the original path to the hashed
    path. Finally, we cleaned up the settings and directories that we added in this
    exercise and *Exercise 5.04*, *Collecting Static Files for Production*. These
    were the `STATIC_ROOT` setting, the `STATICFILES_STORAGE` setting, and the `static_product_test`
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: Custom Storage Engines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we set the storage engine to `ManifestFilesStorage`.
    This class is provided by Django, but it is also possible to write a custom storage
    engine. For example, you could write a storage engine that uploads your static
    files to a CDN, Amazon S3, or a Google Cloud bucket when you run `collectstatic`.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a custom storage engine is beyond the scope of this book. There already
    exist third-party libraries that support uploading to a variety of cloud services;
    one such library is `django-storages`, which can be found at [https://django-storages.readthedocs.io/](https://django-storages.readthedocs.io/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is a short skeleton indicating which methods you should
    implement to create a custom file storage engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The class must be able to be instantiated without any arguments. The `__init__`
    function must be able to load any settings from global identifiers (in this case,
    from our Django settings):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'This method should be able to delete the file, specified by the `name` argument,
    from the remote service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'This method should query the remote service to check whether the file specified
    by name exists. It should return `True` if the file exists, or `False` if it doesn''t:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'This method should query the remote service to list the directory at `path`.
    It should then return a 2-tuple of lists. The first element should be a list of
    directories inside `path`, and the second element should be a list of files. For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'If `path` contains no directories or no files, then an empty list should be
    returned for that element. You would return two empty lists if the directory was
    empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'This method should query the remote service and get the size of the file specified
    by `name`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'This method should determine the URL to access the file specified by `name`.
    This could be built by appending `name` to a specific static hosting URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will provide a handle remote file, specified by `name`. How you
    implement this will depend on the type of remote service. You might have to download
    the file and then use a memory buffer (such as an `io.BytesIO` object) to simulate
    the opening of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: This method should save `content` to the remote file at `name`. The method of
    implementing this will depend on your remote service. It might transfer the file
    over SFTP, or upload to a CDN.
  prefs: []
  type: TYPE_NORMAL
- en: While this example does not implement any transferring to or from a remote service,
    you can refer to it to get an idea of how to implement a custom storage engine.
  prefs: []
  type: TYPE_NORMAL
- en: After implementing your custom storage engine, you can make it active by setting
    its dotted module path in the `STATICFILES_STORAGE` setting in `settings.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 5.01: Adding a reviews Logo'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Bookr app should have a logo that is specific for pages in the `reviews`
    app. This will involve adding a base template just for the `reviews` app and updating
    our current `reviews` templates to inherit from it. Then you will include the
    Bookr `reviews` logo on this base template.
  prefs: []
  type: TYPE_NORMAL
- en: 'These steps will help you complete this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a CSS rule to position the logo. Put this rule into the existing `base.html`,
    after the `.navbar-brand` rule:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add a `brand` `block` template tag that inheriting templates can override. Put
    this inside the `<a>` element with the `navbar-brand` class. The default contents
    of `block` should be left as `Book Review`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a static directory inside the `reviews` app, containing a namespaced directory.
    Download the reviews `logo.png` from [https://packt.live/2WYlGjP](https://packt.live/2WYlGjP)
    and put it inside this directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the `templates` directory for the Bookr project (inside the Bookr project
    directory). Then move the `reviews` app's current `base.html` into this directory,
    so it becomes a base template for the whole project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the new `templates` directory's path to the `TEMPLATES['DIRS']` setting
    in `settings.py` (the same as what you did in *Exercise 5.02*, *Using the static
    Template Tag*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create another `base.html` template specifically for the `reviews` app. Put
    it inside the `reviews` app's `templates` directory. The new template should extend
    the existing `base.html`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The new `base.html` should override the content of the `brand` block. This block
    should contain just an `<img>` instance whose `src` attribute is set using the
    `{% static %}` template tag. The image source should be the logo added in *step
    2*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The index view in `views.py` should render the project `base.html` instead of
    the `reviews` one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Refer to the following screenshots to see what your pages should be like after
    these changes. Note that although you are making changes to the base template,
    it will not change the layout of the main page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.20: Book list page after adding reviews logos'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_05_20.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.20: Book list page after adding reviews logos'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.21: Book Details page after adding logo'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_05_21.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.21: Book Details page after adding logo'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this activity can be found at [http://packt.live/2Nh1NTJ](http://packt.live/2Nh1NTJ).
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 5.02: CSS Enhancements'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Currently, the CSS is kept inline in the `base.html` template. For best practice,
    it should be moved into its own file so that it can be cached separately and decrease
    the size of the HTML downloads. As part of this, you'll also add some CSS enhancements,
    such as fonts and colors, and link in Google Fonts CSS to support these changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'These steps will help you complete this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a directory named `static` in the Bookr project directory. Then, create
    a new file inside it named `main.css`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Copy the contents of the `<style>` element from the main `base.html` template
    into the new `main.css` file, then remove the `<style>` element from the template.
    Add these extra rules to the end of the CSS file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Link to the new `main.css` file with a `<link rel="stylesheet" href="…">` tag.
    Use the `{% static %}` template tag to generate the URL for the `href` attribute,
    and don't forget to `load` the `static` library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Link in the Google fonts CSS, by adding this code to the base template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You will need to have an active internet connection so that your browser can
    include this remote CSS file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update your Django settings to add `STATICFILES_DIRS`, set to the `static`
    directory created in *step 1*. When you''re finished, your Bookr application should
    look like *Figure 5.22*:![Figure 5.22: Book list with the new font and background
    color'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15509_05_22.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 5.22: Book list with the new font and background color'
  prefs: []
  type: TYPE_NORMAL
- en: Notice the new font and background color. These should be displayed on all the
    Bookr pages.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this activity can be found at [http://packt.live/2Nh1NTJ](http://packt.live/2Nh1NTJ).
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 5.03: Adding a Global Logo'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You have already added a logo that is served on pages for the `reviews` app.
    We have another logo to be used globally as a default, but other apps will be
    able to override it:'
  prefs: []
  type: TYPE_NORMAL
- en: Download the Bookr logo (`logo.png`) from [https://packt.live/2Jx7Ge4](https://packt.live/2Jx7Ge4).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save it in the main `static` directory for the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit the main `base.html` file. We already have a block for the logo (`brand`),
    so an `<img>` instance can be placed inside here. Use the `static` template tag
    to refer to the logo you just downloaded.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check that your pages work. On the main URL, you should see the Bookr logo,
    but on the book list and details pages, you should see the Bookr Reviews logo.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When you''re finished, you should see the Bookr logo on the main page:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 5.23: Bookr logo on the main page'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15509_05_23.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 5.23: Bookr logo on the main page'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you visit a page that had the Bookr Reviews logo before, such as the book
    list page, it should still show the Bookr Reviews logo:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.24: Bookr Reviews logo still shows on the Reviews pages'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_05_24.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.24: Bookr Reviews logo still shows on the Reviews pages'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this activity can be found at [http://packt.live/2Nh1NTJ](http://packt.live/2Nh1NTJ).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we showed how to use Django's `staticfiles` app to find and
    serve static files. We used the built-in `static` view to serve these files with
    the Django dev server in `DEBUG` mode. We showed different places to store static
    files, using a directory that is global to the project or a specific directory
    for the application; global resources should be stored in the former while application-specific
    resources should be stored in the latter. We showed the importance of namespacing
    static file directories to prevent conflicts. After serving the assets, we used
    the `static` tag to include them in our template. We then demonstrated how the
    `collectstatic` command copies all the assets into the `STATIC_ROOT` directory,
    for production deployment. We showed how to use the `findstatic` command to debug
    the loading of static files. To invalidate caches automatically, we looked at
    using `ManifestFilesStorage` to add a hash of the file's content to the static
    file URL. Finally, we briefly talked about using a custom file storage engine.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have only fetched web pages using content that already existed. In
    the next chapter, we will start adding forms so we can interact with web pages
    by sending data to them over HTTP.
  prefs: []
  type: TYPE_NORMAL
