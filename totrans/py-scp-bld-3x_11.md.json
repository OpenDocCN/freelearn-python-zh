["```py\n>>> import bpy\n>>> mod_rna = bpy.types.ObjectModifiers.bl_rna\n>>> mod_params = mod_rna.functions[\"new\"].parameters\n>>> mod_params[\"type\"].enum_items.keys()\n['DATA_TRANSFER', 'MESH_CACHE', 'MESH_SEQUENCE_CACHE', 'NORMAL_EDIT', 'WEIGHTED_NORMAL', 'UV_PROJECT', 'UV_WARP',\n...\n```", "```py\nimport bpy\nob = bpy.context.object\nsubdiv = ob.modifiers.new('Subdivision', 'SUBSURF')\n```", "```py\nsubdiv.levels = 3\nsubdiv.subdivision_type = 'SIMPLE'\n```", "```py\ncast = ob.modifiers.new('Cast', 'CAST')\ncast.cast_type = 'CYLINDER'\ncast.factor = 1.0\n```", "```py\nbl_info = {\n    \"name\": \"Latte Express\",\n    \"author\": \"Packt Man\",\n    \"version\": (1, 0),\n    \"blender\": (3, 00, 0),\n    \"description\": \"Create a Lattice on the active object\",\n    \"category\": \"Learning\",\n}\n```", "```py\nimport bpy\nclass LatteExpress(bpy.types.Operator):\n    \"\"\"Set up Lattice Deformation\"\"\"\n    bl_idname = \"object.latte_expresso\"\n    bl_label = \"Create Lattice on active object\"\n```", "```py\n    @classmethod\n    def poll(cls, context):\n        return context.active_object\n```", "```py\n    def execute(self, context):\n        ob = context.object\n        latt_data = bpy.data.lattices.new(f\"LAT-{ob.name}\")\n        latt_obj = bpy.data.objects.new(\n                                     name=latt_data.name,\n                                     object_data=latt_data\n                                    )\n        context.collection.objects.link(latt_obj)\n```", "```py\n        latt_obj.scale = ob.dimensions\n```", "```py\n        ob_translation = ob.matrix_world.to_translation()\n```", "```py\n        btm_left = min((c for c in ob.bound_box), key=sum)\n        top_right = max((c for c in ob.bound_box), key=sum)\n```", "```py\nfrom mathutils import Vector\n```", "```py\n        btm_left = Vector(btm_left)\n        ob_center = btm_left.lerp(top_right, 0.5)\n```", "```py\n        Ob_translation += ob_center\n        latt_obj.location = ob_translation\n```", "```py\n        mod = ob.modifiers.new(\"Lattice\", 'LATTICE')\n        mod.object = latt_obj\n        return {'FINISHED'}\n```", "```py\ndef menu_func(self, context):\n    self.layout.operator(LatteExpress.bl_idname,\n                         icon=\"MOD_LATTICE\")\n```", "```py\ndef register():\n    bpy.utils.register_class(LatteExpress)\n    ob_menu = bpy.types.VIEW3D_MT_object_context_menu\n    ob_menu.append(menu_func)\ndef unregister():\n    ob_menu = bpy.types.VIEW3D_MT_object_context_menu\n    ob_menu.remove(menu_func)\n    bpy.utils.unregister_class(LatteExpress)\n```", "```py\nclass LatteExpress(bpy.types.Operator):\n    \"\"\"Set up Lattice Deformation\"\"\"\n    bl_idname = \"object.latte_expresso\"\n    bl_label = \"Create Lattice on active object\"\n    bl_options = {'REGISTER', 'UNDO'}\n    add_subsurf: bpy.props.BoolProperty(default=True)\n    subd_levels: bpy.props.IntProperty(default=2)\n```", "```py\n    def execute(self, context):\n        ob = context.object\n        if self.add_subsurf:\n            subdiv = ob.modifiers.new(\"Subdivision\",\n                                      \"SUBSURF\")\n            subdiv.levels = self.subd_levels\n            subdiv.render_levels = self.subd_levels\n            subdiv.subdivision_type = \"SIMPLE\"\n```", "```py\n    grid_levels: bpy.props.IntVectorProperty(\n                                         default=(3, 3, 3),\n                                         min=1,\n                                         subtype='XYZ'\n                                        )\n```", "```py\n        latt_data = bpy.data.lattices.new(f\"LAT-{ob.name}\")\n        latt_obj = bpy.data.objects.new(\n                                      name=latt_data.name,\n                                      object_data=latt_data\n                                     )\n        latt_data.points_u = self.grid_levels[0]\n        latt_data.points_v = self.grid_levels[1]\n        latt_data.points_w = self.grid_levels[2]\n```", "```py\n        latt_data.use_outside = False\n```", "```py\n    add_armature: bpy.props.BoolProperty(default=True)\n```", "```py\n        # …\n        ob_translation = ob.matrix_world.to_translation()\n        ob_translation += ob_center\n        if not self.add_armature:\n            latt_obj.location = ob_translation\n        else:\n            arm_data = bpy.data.armatures.new(\n                                           f\"ARM-{ob.name}\"\n                                          )\n            arm_obj = bpy.data.objects.new(\n                                       name=arm_data.name,\n                                       object_data=arm_data\n                                      )\n            context.collection.objects.link(arm_obj)\n```", "```py\n            latt_obj.parent = arm_obj\n            arm_obj.location = ob_translation\n```", "```py\n            half_height = ob.dimensions[2]/2\n            arm_obj.location[2] -= half_height\n```", "```py\n            latt_obj.location[2] += half_height\n```", "```py\n            context.view_layer.objects.active = arm_obj\n            bpy.ops.object.mode_set(mode='EDIT',\n                                    toggle=False)\n```", "```py\n            grid_levels = self.grid_levels[2]\n            height = ob.dimensions[2]\n            bone_length = height / (grid_levels – 1)\n```", "```py\n            for i in range(grid_levels):\n                eb = arm_data.edit_bones.new(f\"LAT_{i:02}\")\n```", "```py\n                eb.head = (0, 0, i * bone_length)\n```", "```py\n                eb.tail = (0, 0, eb.head[2] + bone_length)\n```", "```py\n                rel_height = i / (grid_levels–- 1)\n```", "```py\n                rel_height -= 0.5\n```", "```py\n                vert_ids = []\n```", "```py\n                for id, v in enumerate(latt_data.points):\n                    if v.co[2] == rel_height:\n                        vert_ids.append(id)\n```", "```py\n                vg = latt_obj.vertex_groups.new(\n                                               name=eb.name\n                                              )\n                vg.add(vert_ids, 1.0,'REPLACE')\n```", "```py\n            arm_mod = latt_obj.modifiers.new(\"Armature\",\n                                            \"ARMATURE\")\n            arm_mod.object = arm_obj\n```", "```py\n            bpy.ops.object.mode_set(mode='POSE',\n                                    toggle=False)\n```", "```py\n            v_cos = [\n                [-0.5, 0.0, -0.5],\n                [-0.5, 0.0, 0.5],\n                [0.5, 0.0, 0.5],\n                [0.5, 0.0, -0.5]\n            ]\n```", "```py\n            edges = [\n                [0, 1], [1, 2], [2, 3], [3, 0]\n            ]\n```", "```py\n            mesh = bpy.data.meshes.new(\"WDG-square\")\n            mesh.from_pydata(coords, edges, [])\n```", "```py\n            wdg_obj = bpy.data.objects.new(mesh.name, mesh)\n            context.collection.objects.link(wdg_obj)\n```", "```py\n            for pb in arm_obj.pose.bones:\n                pb.custom_shape = wdg_obj\n```", "```py\n                pb_scale = pb.custom_shape_scale_xyz\n                pb_scale[0] = ob.dimensions[0]\n                pb_scale[2] = ob.dimensions[1]\n```", "```py\n                pb_scale[0] /= bone_length\n                pb_scale[2] /= bone_length\n```", "```py\n            wdg.hide_set(True)\n            latt_obj.hide_set(True)\n```", "```py\n        mod = ob.modifiers.new(\"Lattice\", \"LATTICE\")\n        mod.object = latt_obj\n        ob.select_set(False)\n        return {'FINISHED'}\n```"]