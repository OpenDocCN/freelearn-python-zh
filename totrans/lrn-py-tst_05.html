<html><head></head><body>
  <div><div><div><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Structured Testing with unittest</h1></div></div></div><p>The <code class="literal">doctest</code> <a id="id217" class="indexterm"/>tool is flexible and extremely easy to use but, as we've noticed, it falls somewhat short when it comes to writing disciplined tests. That's not to say that it's impossible; we've seen that we can write well-behaved, isolated tests in <code class="literal">doctest</code>. The problem is that <code class="literal">doctest</code> doesn't do any of that work for us. Fortunately, we have another testing tool on hand, a tool that requires a bit more structure in our tests, and provides a bit more support: <code class="literal">unittest</code>.</p><p>The <code class="literal">unittest</code> module <a id="id218" class="indexterm"/>was designed based on the requirements of unit testing, but it's not actually limited to that. You can use unit test for integration and system testing, too.</p><p>Like <code class="literal">doctest</code>, <code class="literal">unittest</code> is a part of the Python standard library; thus, if you've got Python, you have unit test.</p><p>In this chapter, we're going to cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Writing tests within the <code class="literal">unittest</code> framework</li><li class="listitem" style="list-style-type: disc">Running our new tests</li><li class="listitem" style="list-style-type: disc">Looking at the features that make <code class="literal">unittest</code> a good choice for larger test suites</li></ul></div><div><div><div><div><h1 class="title"><a id="ch05lvl1sec39"/>The basics</h1></div></div></div><p>Before we start <a id="id219" class="indexterm"/>talking about new concepts and features, let's take a look at how to use <code class="literal">unittest</code> to express the ideas that we've already learned about. That way, we'll have something solid on which ground our new understanding.</p><p>We're going to revisit the <code class="literal">PID</code> class, or at least the tests for the <code class="literal">PID</code> class, from <a class="link" href="ch03.html" title="Chapter 3. Unit Testing with doctest">Chapter 3</a>, <em>Unit Testing with doctest</em>. We're going to rewrite the tests so that they operate within the <code class="literal">unittest</code> framework.</p><p>Before moving on, take a moment to refer back to the final version of the <code class="literal">pid.txt</code> file from <a class="link" href="ch03.html" title="Chapter 3. Unit Testing with doctest">Chapter 3</a>, <em>Unit Testing with doctest</em>. We'll be implementing the same tests using the <code class="literal">unittest</code> framework.</p><p>Create a new file called <code class="literal">test_pid.py</code> in the same directory as <code class="literal">pid.py</code>. Notice that this is a <code class="literal">.py</code> file: <code class="literal">unittest</code> tests are pure Python source code, rather than being plain text with source code embedded in it. This means that the tests will be less useful from a documentary point of view, but grants other benefits in exchange.</p><p>Insert the following code into your newly created <code class="literal">test_pid.py</code> file:</p><div><pre class="programlisting">from unittest import TestCase, main
from unittest.mock import Mock, patch

import pid

class test_pid_constructor(TestCase):
    def test_constructor_with_when_parameter(self):
        controller = pid.PID(P = 0.5, I = 0.5, D = 0.5,
                             setpoint = 1, initial = 12,
                             when = 43)

        self.assertEqual(controller.gains, (0.5, 0.5, 0.5))
        self.assertAlmostEqual(controller.setpoint[0], 1.0)
        self.assertEqual(len(controller.setpoint), 1)
        self.assertAlmostEqual(controller.previous_time, 43.0)
        self.assertAlmostEqual(controller.previous_error, -11.0)
        self.assertAlmostEqual(controller.integrated_error, 0)</pre></div><p>It has been argued, sometimes with good reason, that unit tests should not contain more than one assertion. The idea is that each unit test should test one thing and one thing only, to further narrow down what the problem is, when the test fails. It's a good point but not something to be <a id="id220" class="indexterm"/>overly fanatic about, in my opinion. In cases like the preceding code, splitting each assertion out into its own test function will not produce any more informative error messages than we get in this way; it would just increase our overhead.</p><p>My rule of thumb is that a test function can have any number of trivial assertions, and at most one non-trivial assertion:</p><div><pre class="programlisting">    @patch('pid.time', Mock(side_effect = [1.0]))
    def test_constructor_without_when_parameter(self):
        controller = pid.PID(P = 0.5, I = 0.5, D = 0.5,
                             setpoint = 0, initial = 12)

        self.assertEqual(controller.gains, (0.5, 0.5, 0.5))
        self.assertAlmostEqual(controller.setpoint[0], 0.0)
        self.assertEqual(len(controller.setpoint), 1)
        self.assertAlmostEqual(controller.previous_time, 1.0)
        self.assertAlmostEqual(controller.previous_error, -12.0)
        self.assertAlmostEqual(controller.integrated_error, 0)

class test_pid_calculate_response(TestCase):
    def test_with_when_parameter(self):
        mock = Mock()
        mock.gains = (0.5, 0.5, 0.5)
        mock.setpoint = [0.0]
        mock.previous_time = 1.0
        mock.previous_error = -12.0
        mock.integrated_error = 0.0

        self.assertEqual(pid.PID.calculate_response(mock, 6, 2), -3)
        self.assertEqual(pid.PID.calculate_response(mock, 3, 3), -4.5)
        self.assertEqual(pid.PID.calculate_response(mock, -1.5, 4), -0.75)
        self.assertEqual(pid.PID.calculate_response(mock, -2.25, 5), -1.125)


    @patch('pid.time', Mock(side_effect = [2.0, 3.0, 4.0, 5.0]))
    def test_without_when_parameter(self):
        mock = Mock()
        mock.gains = (0.5, 0.5, 0.5)
        mock.setpoint = [0.0]
        mock.previous_time = 1.0
        mock.previous_error = -12.0
        mock.integrated_error = 0.0

        self.assertEqual(pid.PID.calculate_response(mock, 6), -3)
        self.assertEqual(pid.PID.calculate_response(mock, 3), -4.5)
        self.assertEqual(pid.PID.calculate_response(mock, -1.5), -0.75)
        self.assertEqual(pid.PID.calculate_response(mock, -2.25), -1.125)</pre></div><p>Now, run <a id="id221" class="indexterm"/>the tests by typing the following on the command line:</p><div><pre class="programlisting"><strong>python3 -m unittest discover</strong></pre></div><p>You should see output similar to this:</p><div><img src="img/3211OS_05_01.jpg" alt="The basics"/></div><p>So, what did we do there? There are several things to notice:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">First, all of the tests are their own methods of classes that inherit from <code class="literal">unittest.TestCase</code>.</li><li class="listitem" style="list-style-type: disc">The tests are named <code class="literal">test_&lt;something&gt;</code>, where <code class="literal">&lt;something&gt;</code> is a description to help you (and others who share the code) remember what the test is actually checking. This matters because <code class="literal">unittest</code> (and several other testing tools) use the name to differentiate tests from non-test methods. As a rule of thumb, your test method names and test module filenames should start with test.</li><li class="listitem" style="list-style-type: disc">Because each test is a method, each test naturally runs in its own variable scope. Right here, we gain a big advantage from keeping the tests isolated.</li><li class="listitem" style="list-style-type: disc">We inherited a bunch of <code class="literal">assert&lt;Something&gt;</code> methods from <code class="literal">TestCase</code>. These give us more <a id="id222" class="indexterm"/>flexible ways of checking whether values match, and provide more useful error reports, than Python's basic <code class="literal">assert</code> statement.</li><li class="listitem" style="list-style-type: disc">We used <code class="literal">unittest.mock.patch</code> as a method decorator. In <a class="link" href="ch04.html" title="Chapter 4. Decoupling Units with unittest.mock">Chapter 4</a>, <em>Decoupling Units with unittest.mock</em>, we used it as a context manager. Either way, it does the same thing: it replaces an object with a mock object, and then puts the original back. When used as a decorator, the replacement happens before the method runs, and the original is put back after the method is complete. That's exactly what we need when our test is a method, so we'll be doing it in this way quite a lot.</li><li class="listitem" style="list-style-type: disc">We didn't patch over <code class="literal">time.time</code>, we patched <code class="literal">over pid.time</code>. This is because we're not reimporting the <code class="literal">pid</code> module for each test here. The <code class="literal">pid</code> module contains <code class="literal">from time import time</code>, which means that, when it is first loaded, the <code class="literal">time</code> function is referenced directly into the <code class="literal">pid</code> module's scope. From then on, changing <code class="literal">time.time</code> doesn't have any effect on <code class="literal">pid.time</code>, unless we change it and then reimport the <code class="literal">pid</code> module. Instead of going to all that trouble, we just patched <code class="literal">pid.time</code> directly.</li><li class="listitem" style="list-style-type: disc">We didn't tell <code class="literal">unittest</code> which tests to run. Instead, we told it to discover them and it found the tests on its own and ran them automatically. This often works well and saves effort. We'll be looking at a more elaborate tool for test discovery and execution in <a class="link" href="ch06.html" title="Chapter 6. Running Your Tests with Nose">Chapter 6</a>, <em>Running Your Tests with Nose</em>.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">unittest</code> module prints out one dot for each successful test. It will give you more information for tests that fail, or raise an unexpected exception.</li></ul></div><p>The actual tests we performed are the same ones that were written in <code class="literal">doctest</code>. So far, all we're seeing is a different way of expressing them.</p><p>Each test method embodies a single test of a single unit. This gives us a convenient way to structure our tests, grouping together related tests into the same class so that they're easier to find. You might have noticed that we used two test classes in the example. This was for organizational purposes in this case, although there can also be good practical reasons to separate your tests into multiple classes. We'll talk about that soon.</p><p>Putting each test into its own method means that each test executes in an isolated namespace, which makes it easier to keep <code class="literal">unittest</code>-style tests from interfering with each other, relative to <code class="literal">doctest</code>-style tests. This also means that <code class="literal">unittest</code> knows how many unit tests are in your test file, instead of simply knowing how many expressions there are (you might have noticed that <code class="literal">doctest</code> counts each <code class="literal">&gt;&gt;&gt;</code> line as a separate test). Finally, putting each test in its own method means that each test has a name, which can be a valuable feature. When you run <code class="literal">unittest</code>, it will include the names of any failing tests in the error report.</p><p>Tests in <code class="literal">unittest</code> don't directly <a id="id223" class="indexterm"/>care about anything that isn't part of a call to one of the <code class="literal">TestCase</code> <code class="literal">assert</code> methods. This means that we don't have to be bothered about the return values of any functions we call or the results of any expressions we use, unless they're important to the test. This also means that we need to remember to write an assert describing every aspect of the test that we want to have checked. We'll go through the various assertion methods of <code class="literal">TestCase</code> shortly.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch05lvl1sec40"/>Assertions</h1></div></div></div><p>Assertions are the <a id="id224" class="indexterm"/>mechanism we use to tell <code class="literal">unittest</code> what the important outcomes of the test are. By using appropriate assertions, we can tell <code class="literal">unittest</code> exactly what to expect from each test.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec46"/>The assertTrue method</h2></div></div></div><p>When we <a id="id225" class="indexterm"/>call <code class="literal">self.assertTrue(expression)</code>, we're telling <code class="literal">unittest</code> that the expression must be true in order for the test to be a success.</p><p>This is a very flexible <a id="id226" class="indexterm"/>assertion, since you can check for nearly anything by writing the appropriate Boolean expression. It's also one of the last assertions you should consider using, because it doesn't tell <code class="literal">unittest</code> anything about the kind of comparison you're making, which means that <code class="literal">unittest</code> can't tell you clearly what's gone wrong if the test fails.</p><p>For example, consider the following test code containing two tests that are guaranteed to fail:</p><div><pre class="programlisting">from unittest import TestCase

class two_failing_tests(TestCase):
    def test_one_plus_one_equals_one_is_true(self):
        self.assertTrue(1 == 1 + 1)

    def test_one_plus_one_equals_one(self):
        self.assertEqual(1, 1 + 1)</pre></div><p>It might seem that the two tests are interchangeable, since they both test the same thing. Certainly they'll both fail (or, in the unlikely event that one equals two, they'll both pass), so why prefer one over the other?</p><p>Run the tests and see what happens (and also notice that the tests were not executed in the same order as we wrote them; the tests are totally independent of each other, so that's okay, right?).</p><p>Both the tests fail, as expected, but the test that uses <code class="literal">assertEqual</code> tells us:</p><div><pre class="programlisting">AssertionError: 1 != 2</pre></div><p>The other one says:</p><div><pre class="programlisting">AssertionError: False is not true</pre></div><p>It's pretty clear which of these outputs is more useful in this situation. The <code class="literal">assertTrue</code> test was able to correctly determine that the test should fail, but it didn't know enough to report any useful information about why it failed. The <code class="literal">assertEqual</code> test, on the other hand, knew first of all that it was checking whether the two expressions were equal, and second it knew how to present the results so that they would be most useful: by evaluating each of the expressions that it was comparing and placing a <code class="literal">!=</code> symbol between the results. It <a id="id227" class="indexterm"/>tells us both which expectation failed, and <a id="id228" class="indexterm"/>what the relevant expressions evaluate to.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec47"/>The assertFalse method</h2></div></div></div><p>The <code class="literal">assertFalse</code> <a id="id229" class="indexterm"/>method will succeed when the <code class="literal">assertTrue</code> method will <a id="id230" class="indexterm"/>fail, and vice versa. It has the same limits in terms of producing useful output that <code class="literal">assertTrue</code> has, and the same flexibility in terms of being able to test nearly any condition.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec48"/>The assertEqual method</h2></div></div></div><p>As mentioned in the <code class="literal">assertTrue</code> discussion, the <code class="literal">assertEqual</code> assertion checks whether its two parameters <a id="id231" class="indexterm"/>are in fact equal, and reports a failure if they are not, along with the actual values of the parameters.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec49"/>The assertNotEqual method</h2></div></div></div><p>The <code class="literal">assertNotEqual</code> <a id="id232" class="indexterm"/>assertion fails whenever the <code class="literal">assertEqual</code> assertion would have succeeded, and vice versa. When it reports a failure, its <a id="id233" class="indexterm"/>output indicates that the values of the two expressions are equal, and provides you with those values.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec50"/>The assertAlmostEqual method</h2></div></div></div><p>As we've seen before, comparing floating point numbers can be troublesome. In particular, checking <a id="id234" class="indexterm"/>whether two floating point numbers are <a id="id235" class="indexterm"/>equal is problematic, because things that you might expect to be equal—things that, mathematically, are equal—may still end up differing down among the least significant bits. Floating point numbers only compare equal when every bit is the same.</p><p>To address this problem, <code class="literal">unittest</code> provides <code class="literal">assertAlmostEqual</code>, which checks whether the two floating point values are almost the same; a small amount of difference between them is tolerated.</p><p>Let's look at this problem in action. If you take the square root of seven, and then square it, the result should be seven. Here's a pair of tests that check this fact:</p><div><pre class="programlisting">from unittest import TestCase

class floating_point_problems(TestCase):
    def test_square_root_of_seven_squared_incorrectly(self):
        self.assertEqual((7.0 ** 0.5) ** 2.0, 7.0)

    def test_square_root_of_seven_squared(self):
        self.assertAlmostEqual((7.0 ** 0.5) ** 2.0, 7.0)</pre></div><p>The <code class="literal">test_square_root_of_seven_squared_incorrectly</code> method checks that <img src="img/3211OS_05_02.jpg" alt="The assertAlmostEqual method"/>, which is true in reality. In the more specialized number system available to computers, though, taking the square root of 7 and then squaring it doesn't quite get us back to 7, so this test <a id="id236" class="indexterm"/>will fail. We will look more <a id="id237" class="indexterm"/>closely at this in a moment.</p><p>The <code class="literal">test_square_root_of_seven_squared</code> method checks <img src="img/3211OS_05_03.jpg" alt="The assertAlmostEqual method"/>, which even the computer will find to be true, so this test should pass.</p><p>Unfortunately, floating point numbers (the representation of real numbers used by computers) are not precise, because the majority of numbers on the real number line cannot be represented with a finite, non-repeating sequence of digits, much less than a mere 64 bits. Consequently, what you get back from evaluating the mathematical expression in the previous example is not quite seven. It's good enough for government work though—or practically any other sort of work as well—so we don't want our test to quibble over that tiny difference. Because of this, we should habitually use <code class="literal">assertAlmostEqual</code> and <code class="literal">assertNotAlmostEqual</code> when we're comparing floating point numbers with equality.</p><div><div><h3 class="title"><a id="note14"/>Note</h3><p>This problem doesn't generally carry over into other comparison operators. Checking whether one floating point number is less than the other, for example, is very unlikely to produce the wrong result due to insignificant errors. It's only in cases of equality that this problem bites us.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec51"/>The assertNotAlmostEqual method</h2></div></div></div><p>The <a id="id238" class="indexterm"/>
<code class="literal">assertNotAlmostEqual</code> assertion <a id="id239" class="indexterm"/>fails whenever the <code class="literal">assertAlmostEqual</code> assertion would have succeeded, and vice versa. When it reports a failure, its <a id="id240" class="indexterm"/>output indicates that the values of the <a id="id241" class="indexterm"/>two expressions are nearly equal, and provides you with those values.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec52"/>The assertIs and assertIsNot methods</h2></div></div></div><p>The <code class="literal">assertIs</code> <a id="id242" class="indexterm"/>and <code class="literal">assertIsNot</code> methods have the same relationship with Python's <code class="literal">is</code> operator that <code class="literal">assertEqual</code> and <code class="literal">assertNotEqual</code> have to Python's <code class="literal">==</code> operator. What this means is that they check whether the <a id="id243" class="indexterm"/>two operands are (or are not) exactly the same object.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec53"/>The assertIsNone and assertIsNotNone methods</h2></div></div></div><p>The <a id="id244" class="indexterm"/>
<code class="literal">assertIsNone</code> and <code class="literal">assertIsNotNone</code> methods are like <code class="literal">assertIs</code> and <code class="literal">assertIsNot</code>, except that they accept only one parameter that they always compare to <code class="literal">None</code>, rather than accepting two <a id="id245" class="indexterm"/>parameters and comparing them to each other.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec54"/>The assertIn and assertNotIn methods</h2></div></div></div><p>The <a id="id246" class="indexterm"/>
<code class="literal">assertIn</code> method is used for checking <a id="id247" class="indexterm"/>container objects such as dictionaries, tuples, lists, and sets. If the first parameter is contained in the second, the assertion passes. If not, the assertion fails. The <code class="literal">assertNotIn</code> method performs the inverse check.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec55"/>The assertIsInstance and assertNotIsInstance methods</h2></div></div></div><p>The <a id="id248" class="indexterm"/>
<code class="literal">assertIsInstance</code> method checks whether the object passed as the first parameter is an instance of the class passed as the second parameter. The <code class="literal">assertNotIsInstance</code> method <a id="id249" class="indexterm"/>performs the opposite check, ensuring that the object is not an instance of the class.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec56"/>The assertRaises method</h2></div></div></div><p>As always, <a id="id250" class="indexterm"/>we need to make sure that our units correctly <a id="id251" class="indexterm"/>signal errors. Doing the right thing when they receive good inputs is only half the job; they need to do something reasonable when they receive bad inputs, as well.</p><p>The <code class="literal">assertRaises</code> method checks whether a callable raises a specified exception when passed a specified set of parameters.</p><div><div><h3 class="title"><a id="note15"/>Note</h3><p>A callable is a function, a method, a class, or an object of any arbitrary type that has a <code class="literal">__call__</code> method.</p></div></div><p>This assertion only works with callables, which means that you don't have a way of checking whether other sorts of expressions raise an expected exception. If that doesn't fit the needs of your test, it's possible to construct your own test using the <code class="literal">fail</code> method, described below.</p><p>To use <code class="literal">assertRaises</code>, first pass the expected exception to it, then the callable, and then the parameters that should be passed to the callable when it's invoked.</p><p>Here's an example test using <code class="literal">assertRaises</code>. This test ought to fail, because the callable won't raise the expected exception. <code class="literal">'8ca2'</code> is a perfectly acceptable input to <code class="literal">int</code>, when you're also passing <code class="literal">base = 16</code> to it. Notice that <code class="literal">assertRaises</code> will accept any number of positional or keyword arguments, and pass them on to the callable on invocation:</p><div><pre class="programlisting">from unittest import TestCase

class silly_int_test(TestCase):
    def test_int_from_string(self):
        self.assertRaises(ValueError, int, '8ca2', base = 16)</pre></div><p>When we run this test, it fails (as we knew it would) because <code class="literal">int</code> didn't raise the exception we told <code class="literal">assertRaises</code> to expect. The test fails and reports this as follows:</p><div><pre class="programlisting">AssertionError: ValueError not raised by int</pre></div><p>If an exception is <a id="id252" class="indexterm"/>raised, but it's not the one you told <code class="literal">unittest</code> to expect, then <code class="literal">unittest</code> considers that as an error. An error is different from a failure. A failure means that one of your tests has detected a problem in the unit being tested. An <a id="id253" class="indexterm"/>error means that there's a problem with the test itself.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec57"/>The fail method</h2></div></div></div><p>When all else fails, you <a id="id254" class="indexterm"/>can fall back on <code class="literal">fail</code>. When the code in <a id="id255" class="indexterm"/>your test calls fail, the test fails.</p><p>What good does that do? When none of the <code class="literal">assert</code> methods do what you need, you can instead write your checks in such a way that <code class="literal">fail</code> will be called if the test does not pass. This allows you to use the full expressiveness of Python to describe checks for your expectations.</p><p>Let's take a look at an example. This time, we're going to test on a less-than operation, which isn't one of the operations directly supported by an <code class="literal">assert</code> method. Using fail, it's easy to implement the test anyhow:</p><div><pre class="programlisting">from unittest import TestCase

class test_with_fail(TestCase):
    def test_less_than(self):
        if not (2.3 &lt; 5.6):
            self.fail('2.3 is not less than 5.6, but it should be')</pre></div><div><div><h3 class="title"><a id="tip09"/>Tip</h3><p>If a particular comparison gets used repeatedly in your tests, you can write your own <code class="literal">assert</code> function for that comparison, using <code class="literal">fail</code> to report errors just as we did in the preceding example.</p></div></div><p>A couple of things to notice here. First of all, take note of the <code class="literal">not</code> in the <code class="literal">if</code> statement. Since we want to run <code class="literal">fail</code> if the test should <em>not</em> pass, but we're used to describing the circumstances when the test should succeed, a good way to write the test is to write the success condition, and <a id="id256" class="indexterm"/>then invert it with <code class="literal">not</code>. That way we can continue thinking in the way we're used to when we use <code class="literal">fail</code>. The second thing to note is that you can <a id="id257" class="indexterm"/>pass a message to fail when you call it; it will be printed out in <code class="literal">unittest</code> report of failed tests. If you choose your message carefully, it can be a big help.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch05lvl1sec41"/>Make sure you get it</h1></div></div></div><p>Take a look at <a id="id258" class="indexterm"/>the following <code class="literal">doctest</code>. Can you work out how the equivalent <code class="literal">unittest</code> would look like?</p><div><pre class="programlisting">&gt;&gt;&gt; try:
...     int('123')
... except ValueError:
...     pass
... else:
...     print('Expected exception was not raised')</pre></div><p>That <code class="literal">doctest</code> code tries to convert a string into an integer; if this conversion does not raise a <code class="literal">ValueError</code>, it reports an error. In <code class="literal">unittest</code>, that looks like this:</p><div><pre class="programlisting">class test_exceptions(TestCase):
    def test_ValueError(self):
        self.assertRaises(ValueError, int, '123')</pre></div><p>How do you check whether two floating point numbers are equal in <code class="literal">unittest</code>? You should use the <code class="literal">assertAlmostEqual</code> method, so as not to get tripped by the floating point imprecision.</p><p>When would you choose to use <code class="literal">assertTrue</code>? How about <code class="literal">fail</code>? You would use <code class="literal">assertTrue</code> if none of the more specialized assertions suit your needs. You would use fail if you need maximum control when a test succeeds or fails.</p><p>Look back at some of the tests we wrote in the previous chapters, and translate them from <code class="literal">doctest</code> into <code class="literal">unittest</code>. Given what you already know of <code class="literal">unittest</code>, you should be able to translate any of the tests.</p><p>While you're doing this, think about the relative merits of <code class="literal">unittest</code> and <code class="literal">doctest</code> for each of the tests that you <a id="id259" class="indexterm"/>translate. The two systems have different strengths, so it makes sense that each will be the more appropriate choice for different situations. When is <code class="literal">doctest</code> the better choice, and when is <code class="literal">unittest</code>?</p></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch05lvl1sec42"/>Test fixtures</h1></div></div></div><p>The <code class="literal">unittest</code> <a id="id260" class="indexterm"/>has an important and highly useful capability that <code class="literal">doctest</code> lacks. You can tell <code class="literal">unittest</code> how to create a standardized environment for your <a id="id261" class="indexterm"/>unit tests to run inside, and how to clean up that environment when it's done. This ability to create and later destroy a standardized test environment is a test fixture. While test fixtures don't actually make any tests possible that were impossible before, they can certainly make them shorter and less repetitive.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec58"/>Example – testing database-backed units</h2></div></div></div><p>Many programs <a id="id262" class="indexterm"/>need to access a database for their operation, which means that many of the units these programs are made of also access a database. The point is that the purpose of a database is to store information and make it accessible in other, arbitrary places; in other words, databases exist to break the isolation of units. The same problem applies to other information stores as well: for example, files in permanent storage.</p><p>How do we deal with that? After all, just leaving the units that interact with the database untested is no solution. We need to create an environment where the database connection works as usual, but where any changes that are made do not last. There are a few different ways in which we can do this but, no matter what the details are, we need to set up the special database connection before each test that uses it, and we need to destroy any changes after each such test.</p><p>The <code class="literal">unittest</code> helps us do this by providing test fixtures via the <code class="literal">setUp</code> and <code class="literal">tearDown</code> methods of the <code class="literal">TestCase</code> class. These methods exist for us to override, with the default versions doing nothing.</p><p>Here's some <a id="id263" class="indexterm"/>database-using code (let's say it exists in a file called <code class="literal">employees.py</code>), for which we're going to write tests:</p><div><pre class="programlisting">class Employees:
    def __init__(self, connection):
        self.connection = connection

    def add_employee(self, first, last, date_of_employment):
        cursor = self.connection.cursor()
        cursor.execute('''insert into employees
                            (first, last, date_of_employment)
                          values
                            (:first, :last, :date_of_employment)''',
                       locals())
        self.connection.commit()

        return cursor.lastrowid

    def find_employees_by_name(self, first, last):
        cursor = self.connection.cursor()
        cursor.execute('''select * from employees
                          where
                            first like :first
                          and
                            last like :last''',
                       locals())

        for row in cursor:
            yield row

    def find_employees_by_date(self, date):
        cursor = self.connection.cursor()
        cursor.execute('''select * from employees
                          where date_of_employment = :date''',
                       locals())

        for row in cursor:
            yield row</pre></div><div><div><h3 class="title"><a id="note16"/>Note</h3><p>The preceding code uses the sqlite3 database that ships with Python. Since the <code class="literal">sqlite3</code> interface is compatible with Python's DB-API 2.0, any database backend you find yourself using will have a similar interface to what you see here.</p></div></div><p>We'll start off by importing the needed modules and introducing our <code class="literal">TestCase</code> subclass:</p><div><pre class="programlisting">from unittest import TestCase
from sqlite3 import connect, PARSE_DECLTYPES
from datetime import date
from employees import Employees

class test_employees(TestCase):</pre></div><p>We need a <code class="literal">setUp</code> <a id="id264" class="indexterm"/>method to create the environment that our tests depend on. In this case, that means creating a new database connection to an in-memory-only database, and populating that database with the needed tables and rows:</p><div><pre class="programlisting">    def setUp(self):
        connection = connect(':memory:',
                             detect_types = PARSE_DECLTYPES)
        cursor = connection.cursor()

        cursor.execute('''create table employees
                            (first text,
                             last text,
                             date_of_employment date)''')

        cursor.execute('''insert into employees
                            (first, last, date_of_employment)
                          values
                            ("Test1", "Employee", :date)''',
                       {'date': date(year = 2003,
                                     month = 7,
                                     day = 12)})

        cursor.execute('''insert into employees
                            (first, last, date_of_employment)
                          values
                            ("Test2", "Employee", :date)''',
                       {'date': date(year = 2001,
                                     month = 3,
                                     day = 18)})

        self.connection = connection</pre></div><p>We need a <code class="literal">tearDown</code> method to undo whatever the <code class="literal">setUp</code> method did, so that each test can run in an untouched version of the environment. Since the database is only in memory, all we have to do is close the connection, and it goes away. The <code class="literal">tearDown</code> method may end up being much more complicated in other scenarios:</p><div><pre class="programlisting">    def tearDown(self):
        self.connection.close()</pre></div><p>Finally, we need the <a id="id265" class="indexterm"/>tests themselves:</p><div><pre class="programlisting">    def test_add_employee(self):
        to_test = Employees(self.connection)
        to_test.add_employee('Test1', 'Employee', date.today())

        cursor = self.connection.cursor()
        cursor.execute('''select * from employees
                          order by date_of_employment''')

        self.assertEqual(tuple(cursor),
                         (('Test2', 'Employee', date(year = 2001,
                                                     month = 3,
                                                     day = 18)),
                          ('Test1', 'Employee', date(year = 2003,
                                                     month = 7,
                                                     day = 12)),
                          ('Test1', 'Employee', date.today())))

    def test_find_employees_by_name(self):
        to_test = Employees(self.connection)

        found = tuple(to_test.find_employees_by_name('Test1', 'Employee'))
        expected = (('Test1', 'Employee', date(year = 2003,
                                               month = 7,
                                               day = 12)),)

        self.assertEqual(found, expected)

    def test_find_employee_by_date(self):
        to_test = Employees(self.connection)

        target = date(year = 2001, month = 3, day = 18)
        found = tuple(to_test.find_employees_by_date(target))

        expected = (('Test2', 'Employee', target),)

        self.assertEqual(found, expected)</pre></div><p>We just used a <code class="literal">setUp</code> method in our <code class="literal">TestCase</code>, along with a matching <code class="literal">tearDown</code> method. Between them, these methods made sure that the environment in which the tests were executed was the one they needed (that was <code class="literal">setUp</code>'s job) and that the environment of each test was cleaned up after the test was run, so that the tests didn't interfere with each other (this was the job of <code class="literal">tearDown</code>). The <code class="literal">unittest</code> made sure that <code class="literal">setUp</code> was run once before each test method, and that <code class="literal">tearDown</code> was run once after each test method.</p><p>Because a test fixture—as defined by <code class="literal">setUp</code> and <code class="literal">tearDown</code>—gets wrapped around every test in a <code class="literal">TestCase</code> class, the <code class="literal">setUp</code> and <code class="literal">tearDown</code> methods for the <code class="literal">TestCase</code> classes that contain too many tests <a id="id266" class="indexterm"/>can get very complicated and waste a lot of time dealing with details that are unnecessary for some of the tests. You can avoid this problem by simply grouping together those tests that require specific aspects of the environment into their own <code class="literal">TestCase</code> classes. Give each <code class="literal">TestCase</code> an appropriate <code class="literal">setUp</code> and <code class="literal">tearDown</code>, only dealing with those aspects of the environment that are necessary for the tests it contains. You can have as many <code class="literal">TestCase</code> classes as you want, so there's no need to skimp on them when you're deciding which tests to group together.</p><p>Notice how simple the <code class="literal">tearDown</code> method we used was. That's usually a good sign: when the changes that need to be undone in the <code class="literal">tearDown</code> method are simple to describe, it often means that you can be sure of doing this perfectly. Since any imperfection of the <code class="literal">tearDown</code> method makes it possible for the tests to leave behind stray data that might alter how other tests behave, getting it right is important. In this case, all of our changes were confined inside the database, so getting rid of the database does the trick.</p><p>We could have used a mock object for the database connection, instead. There's nothing wrong with that approach, except that, in this case, it would have been more effort for us. Sometimes mock objects <a id="id267" class="indexterm"/>are the perfect tool for the job, sometimes test fixtures save effort; sometimes you need both to get the job done easily.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch05lvl1sec43"/>Summary</h1></div></div></div><p>This chapter contained a lot of information about how to use the <code class="literal">unittest</code> framework to write your tests.</p><p>Specifically, we covered how to use <code class="literal">unittest</code> to express concepts you were already familiar with from <code class="literal">doctest</code>; differences and similarities between <code class="literal">unittest</code> and doctest; how to use test fixtures to embed your tests in a controlled and temporary environment; and how to use the <code class="literal">unittest.mock</code> patch to decorate test methods to further control the environment the test executes inside.</p><p>In the next chapter, we'll look at a tool called Nose that is capable of finding and running <code class="literal">doctest</code> tests, <code class="literal">unittest</code> tests, and ad hoc tests all in the same test run and of providing you with a unified test report.</p></div></div>
</body></html>