<html><head></head><body>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch10" class="calibre1"/>Chapter 10. Heaps: Ordered Trees</h1></div></div></div><p class="calibre7"><strong class="calibre16">Heaps</strong> are a special category of the tree data structure, that are ordered with respect to the value of the tree's nodes or the keys associated with each node. This ordering is either ascending in a min heap, meaning that the root node is smaller in value or priority than it's child nodes, or descending in a max heap, meaning that the root node is larger in value or priority than it's child nodes. Note that heap data structures should not be confused with the heap memory of a computer system, which is the name typically used for system's dynamically allocated memory.</p><p class="calibre7">In this chapter we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem">Defining the heap data structure</li><li class="listitem">Array implementation</li><li class="listitem">Creating heaps</li><li class="listitem">Common operations</li></ul></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch10lvl1sec50" class="calibre1"/>Heap implementations</h1></div></div></div><p class="calibre7">Like trees, heaps are typically implemented using either linked lists or linked nodes, or an array. Since we examined the linked node approach in <a class="calibre1" title="Chapter 9. Trees: Non-Linear Structures" href="part0050_split_000.html#1FLS41-77f2b5b248f04368a6f723b0e9357ef3">Chapter 9</a>, <em class="calibre20">Trees: Nonlinear Structures</em>, in this chapter, we'll examine an array implementation of a heap called a <strong class="calibre16">binary heap</strong>.</p><p class="calibre7">
</p><div><img src="img/00015.jpeg" alt="Heap implementations" class="calibre17"/></div><p class="calibre18"> </p><p class="calibre7">
</p><p class="calibre7">A binary heap is a tree structure where all levels of the tree are filled completely, with the possible exception of the last or deepest level. In the case of the deepest level the nodes are filled from left to right until the level is full. As you can see from the preceding figure, in an array-based implementation each parent node has two child nodes that are located at <em class="calibre20">2i + 1 </em>and <em class="calibre20">2i + 2, </em>where i is the index of the parent node and the first node of the collection is found at index 0.</p><div><h3 class="title1"><a id="note36" class="calibre1"/>Note</h3><p class="calibre7">Alternate implementations skip the 0 index of the array to simplify the arithmetic of finding child and parent nodes for a given index. In this design, the child nodes for any given index i are located at <em class="calibre20">2i</em> and 2i + 1.</p></div></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec51" class="calibre1"/>Heap operations</h1></div></div></div><p class="calibre7">Not all implementations of the heap data structures expose the same operational methods. However, the more common operations should be available or made available as needed by the developer.</p><div><ul class="itemizedlist"><li class="listitem"><strong class="calibre16">Insert</strong>:<strong class="calibre16"> </strong>The Insert operation adds a new node to the heap. This operation must also re-order the heap to ensure that the newly added node maintains the heap property. This operation has an <strong class="calibre16">O</strong>(<em class="calibre20">log n</em>) operational cost.</li><li class="listitem"><strong class="calibre16">FindMax</strong>: The FindMax operation is synonymous with a max heap, and returns the largest value or highest-priority object in the collection. In an array-based implementation, this is typically the object at either index 0 or index 1, depending on the design. This is equivalent to the <em class="calibre20">peek</em> operation in a stack or queue, which is important when using a heap to implement a priority queue. This operation has an <strong class="calibre16">O</strong>(<em class="calibre20">1</em>) operational cost.</li><li class="listitem"><strong class="calibre16">FindMin</strong>: The FindMin operation is related to a min heap, and returns the smallest value or lowest-priority object in the collection. In an array-based implementation this is typically the object at either index 0 or index 1, depending on the design. This operation has an <strong class="calibre16">O</strong>(<em class="calibre20">1</em>) operational cost.</li><li class="listitem"><strong class="calibre16">ExtractMax</strong>: The ExtractMax operation is related to a max heap, and both returns the largest value or highest-priority object in the collection and removes it from the collection. This is equivalent to the <em class="calibre20">pop</em> operation in a stack or queue structure. As with FindMax, this is typically the object at either index 0 or index 1 depending on the design. This operation will also re-order the heap to maintain the heap property. This operation has an <strong class="calibre16">O</strong>(<em class="calibre20">log n</em>) operational cost.</li><li class="listitem"><strong class="calibre16">ExtractMin</strong>: The ExtractMin operation is related to a min heap, and both returns the smallest value or lowest-priority object in the collection and removes it from the collection. As with FindMin, this is typically the object at either index 0 or index 1 depending on the design. This operation will also re-order the heap to maintain the heap property. This operation has an <strong class="calibre16">O</strong>(<em class="calibre20">log n</em>) operational cost.</li><li class="listitem"><strong class="calibre16">DeleteMax</strong>: The DeleteMax operation is related to a max heap, and simply removes the largest value or highest priority object in the collection. As with FindMax, this is typically the object at either index 0 or index 1 depending on the design. This operation will also re-order the heap to maintain the heap property. This operation has an <strong class="calibre16">O</strong>(<em class="calibre20">log n</em>) operational cost.</li><li class="listitem"><strong class="calibre16">DeleteMin</strong>: The DeleteMin operation is related to a min heap, and simply removes the smallest value or lowest priority object in the collection. As with FindMin, this is typically the object at either index 0 or index 1 depending on the design. This operation will also re-order the heap to maintain the heap property. This operation has an <strong class="calibre16">O</strong>(<em class="calibre20">log n</em>) operational cost.</li><li class="listitem"><strong class="calibre16">Count</strong>: The Count operation returns the total number of nodes in the heap. This operation has an O(<em class="calibre20">1</em>) operational cost.</li><li class="listitem"><strong class="calibre16">Children</strong>:<strong class="calibre16"> </strong>The Children operation will return the two child nodes for the provided node or node index. This operation has an <strong class="calibre16">O</strong>(<em class="calibre20">2</em>) operational cost since two calculations must be performed to gather the child nodes. </li><li class="listitem"><strong class="calibre16">Parent</strong>: The Parent operation will return the parent node for any given node or node index. This operation has an <strong class="calibre16">O</strong>(<em class="calibre20">1</em>) operational cost.</li></ul></div><div><h3 class="title1"><a id="note37" class="calibre1"/>Note</h3><p class="calibre7">This list of operations may remind you somewhat of the tree data structure discussed in <a class="calibre1" title="Chapter 9. Trees: Non-Linear Structures" href="part0050_split_000.html#1FLS41-77f2b5b248f04368a6f723b0e9357ef3">Chapter 9</a>, <em class="calibre20">Trees: Non-linear Structures</em>. It is important to note that, although a binary heap is quite similar to a binary search tree, the two should not be confused. Like a binary search tree, a heap data structure organizes each node of the collection. The heap orders nodes priority based on some arbitrary property of the node or the environment, while the values of each node are not necessarily ordered at all. In a binary search tree, on the other hand, the values of the nodes themselves are ordered.</p></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec52" class="calibre1"/>Instantiating heaps</h1></div></div></div><p class="calibre7">Since heaps are a form of tree data structure, it is unsurprising that we will not find a native concrete implementation in the languages we are discussing. However, the heap data structure is actually quite simple to implement. Therefore, we are going to build our own heap structure, specifically a min heap.</p></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec53" class="calibre1"/>Min heap structure</h1></div></div></div><p class="calibre7">Before we begin, we need to detail a few characteristics our heap structure will possess. For starters, we are going to implement the heap using an array, and the first node will occupy the <code class="literal">0</code> index in this array. This decision is important because it affects the formula we use to calculate each node's parent and Children. Next, we will need an object to represent the nodes in our heap. Since this is going to be a very simple object for our demonstration, we'll define its class in-line with our heap implementation.</p><p class="calibre7">Since this is a min heap, we will only need to implement the <code class="literal">min</code> operations. Therefore, our implementation must expose methods for <code class="literal">FindMin</code> (peek), <code class="literal">ExtractMin</code> (pop), and <code class="literal">DeleteMin</code>. The heap's <em class="calibre20">Insert</em>, <em class="calibre20">Count</em>, <em class="calibre20">Children</em>, and <em class="calibre20">Parent</em> operations will each be implemented as single methods.</p><p class="calibre7">Our min heap implementation will also need two supporting methods to re-order the collection whenever a node is added or removed. We'll call these methods <code class="literal">OrderHeap</code> and <code class="literal">SwapNodes</code>, and their functions should be self-explanatory.</p><div><h3 class="title1"><a id="note38" class="calibre1"/>Note</h3><p class="calibre7">Note that an implementation of a max heap is almost identical to a <code class="literal">min</code> heap except that you switch around the variables in a few operations. We'll examine those differences in-line with our implementations.</p></div><p class="calibre7"><strong class="calibre16">C#</strong></p><p class="calibre7">C# provides enough functionality for us to create a versatile heap data structure with very little code. First we need to build the simple class that represents the nodes of the heap:</p><pre class="programlisting">    public class HeapNode 
    { 
        public int Data; 
    } 
</pre><p class="calibre7">This class is very simple, containing only a <code class="literal">public</code> property to store our integer data. Since this class' contents are consistent in each of the following language examples, we will only examine it here.</p><p class="calibre7">Next we can implement our heap functions. Here's what a concrete implementation of the <code class="literal">MinHeap</code> class might look like in C#:</p><pre class="programlisting">    List&lt;HeapNode&gt; elements; 
    public int Count 
    { 
        get 
        { 
            return elements.Count; 
        } 
    } 

    public MinHeap() 
    { 
        elements = new List&lt;HeapNode&gt;(); 
    } 
</pre><p class="calibre7">Our <code class="literal">MinHeap</code> class includes two public fields. The first is a <code class="literal">List&lt;HeapNode&gt;</code> named <code class="literal">elements</code> that represents our heap collection. The second is a <code class="literal">Count</code> field that will return the total number of elements in the collection. Finally, our constructor simply initializes the <code class="literal">elements</code> collection.</p><pre class="programlisting">    public void Insert(HeapNode item) 
    { 
        elements.Add(item); 
        OrderHeap(); 
    } 
</pre><p class="calibre7">The <code class="literal">Insert(HeapNode item)</code> method accepts a new <code class="literal">HeapNode</code> object and adds it to the collection. Once the object has been added, the method calls <code class="literal">OrderHeap()</code>to make sure the new object is placed in the correct position to maintain the heap property.</p><pre class="programlisting">    public void Delete(HeapNode item) 
    { 
        int i = elements.IndexOf(item); 
        int last = elements.Count - 1; 
 
        elements[i] = elements[last]; 
        elements.RemoveAt(last); 
        OrderHeap(); 
    } 
</pre><p class="calibre7">The <code class="literal">Delete(HeapNode item)</code> method accepts a <code class="literal">HeapNode</code> item to be removed from the collection. The method first finds the index of the item to be removed, then gets the index of the last object in the collection. Next, the method deletes the matching node by overwriting its position with a reference to the last node in the heap and then the last node is removed. Finally, the <code class="literal">OrderHeap()</code> method is called to ensure the final collection satisfies the heap property.</p><pre class="programlisting">    public HeapNode ExtractMin() 
    { 
        if (elements.Count &gt; 0) 
        { 
            HeapNode item = elements[0]; 
            Delete(item); 
            return item; 
        } 
 
        return null; 
    } 
</pre><p class="calibre7">The <code class="literal">ExtractMin()</code> method first confirms that the <code class="literal">elements</code> collection has at least one element. If not, the method returns <code class="literal">null</code>. Otherwise, the method creates a new instance of <code class="literal">HeapNode</code> called <code class="literal">item</code> and sets it to the root object in the collection, which is the smallest object or the object with the lowest priority. Next, the method calls <code class="literal">Delete(item)</code> to remove the node from the collection. Finally, since the <code class="literal">ExtractMin</code> function must return an object, the method returns <code class="literal">item</code> to the caller.</p><pre class="programlisting">    public HeapNode FindMin() 
    { 
        if (elements.Count &gt; 0) 
        { 
            return elements[0]; 
        } 
 
        return null; 
    } 
</pre><p class="calibre7">The <code class="literal">FindMin()</code> method is very similar to the <code class="literal">ExtractMin()</code> method, except that it does not remove the returned minimum value from the collection. The method first confirms that the element's collection has at least one element. If not, the method returns <code class="literal">null</code>. Otherwise the method returns the root object in the collection, which is the smallest object or the object with the lowest priority.</p><pre class="programlisting">    private void OrderHeap() 
    { 
        for (int i = elements.Count - 1; i &gt; 0; i--) 
        { 
            int parentPosition = (i - 1) / 2; 
 
            if (elements[parentPosition].Data &gt; elements[i].Data) 
            { 
                SwapElements(parentPosition, i); 
            } 
        } 
    }   
 
    private void SwapElements(int firstIndex, int secondIndex) 
    { 
        HeapNode tmp = elements[firstIndex]; 
        elements[firstIndex] = elements[secondIndex]; 
        elements[secondIndex] = tmp; 
    } 
</pre><p class="calibre7">The private <code class="literal">OrderHeap()</code> method is the heart of the <code class="literal">MinHeap</code> class. This is the method responsible for maintaining the heap property of the collection. The method first establishes a <code class="literal">for</code> loop based on the length of the elements collection, and begins iterating through the collection from the end to the beginning.</p><div><h3 class="title1"><a id="note39" class="calibre1"/>Note</h3><p class="calibre7">Since we know that the two children of any object at index i are located at indices <em class="calibre20">2i + 1</em> and <em class="calibre20">2i + 2</em>, we likewise know that the parent of any object at index i is found at <em class="calibre20">(i - 1) / 2</em>. This formula only works because the resulting value is defined as an integer, meaning that any floating-point values are truncated and only the whole number value is retained. This algorithm, implemented in the <code class="literal">OrderHeap()</code> method via the <code class="literal">int parentPosition = (i - 1) / 2;</code> code, is what ensures the heap data structure retains its binary nature.</p></div><p class="calibre7">Using the <code class="literal">min</code> heap property formula, the <code class="literal">for</code> loop first identifies the parent index for the current node. Next, the value of the current node's <code class="literal">Data</code> field is compared to that of the parent; if the parent is larger, the method calls <code class="literal">SwapElements(parentPosition, i)</code>. Once each of the nodes has been evaluated, the method is complete and the heap property is consistent throughout the collection.</p><div><h3 class="title1"><a id="note40" class="calibre1"/>Note</h3><p class="calibre7">Note that, by switching the two operands of the <code class="literal">if</code> statement, or by simply changing the comparator from <code class="literal">&gt;</code> to <code class="literal">&lt;</code>, or, our collection would effectively change from a min heap to a max heap. Using this knowledge, it would be very simple indeed to create a heap collection that could be defined as either a <code class="literal">min</code> heap or a <code class="literal">max</code> heap at <em class="calibre20">runtime</em>.</p></div><p class="calibre7">The <code class="literal">SwapElements(int firstIndex, int secondIndex)</code> method's function is self-explanatory. Each of the nodes at the given indices is swapped to enforce the heap property.</p><pre class="programlisting">    public List&lt;HeapNode&gt; GetChildren(int parentIndex) 
    { 
        if (parentIndex &gt;= 0) 
        { 
            List&lt;HeapNode&gt; children = new List&lt;HeapNode&gt;(); 
            int childIndexOne = (2 * parentIndex) + 1; 
            int childIndexTwo = (2 * parentIndex) + 2; 
            children.Add(elements[childIndexOne]); 
            children.Add(elements[childIndexTwo]); 
 
            return children; 
        } 
 
        return null; 
    } 
</pre><p class="calibre7">Using the same rule, which states that the two children of any object at index i are located at indices <em class="calibre20">2i + 1</em> and <em class="calibre20">2i + 2</em>, the <code class="literal">GetChildren(int parentIndex)</code> method gathers and returns the two child nodes for a given parent index. The method first confirms that <code class="literal">parentIndex</code> is not less than <code class="literal">0</code>, otherwise it returns <code class="literal">null</code>. If the <code class="literal">parentIndex</code> is valid, the method creates a new <code class="literal">List&lt;Heapnode&gt;</code> and populates it using the calculated child indices before returning the<code class="literal"> children</code> collection.</p><pre class="programlisting">    public HeapNode GetParent(int childIndex) 
    { 
        if (childIndex &gt; 0 &amp;&amp; elements.Count &gt; childIndex) 
        { 
            int parentIndex = (childIndex - 1) / 2; 
            return elements[parentIndex]; 
        } 
 
        return null; 
    } 
</pre><p class="calibre7">Finally, <code class="literal">GetParent(int childIndex)</code> works on the same principle as <code class="literal">GetChildren</code>. If the given <code class="literal">childIndex</code> is greater than <code class="literal">0</code> the node has a parent. The method confirms that we are not searching for the root node and also confirms that the index is not out of bounds for the collection. If either check fails, the method returns <code class="literal">null</code>. Otherwise, the method determines the node's parent index and then returns the node found at that index.</p><p class="calibre7"><strong class="calibre16">Java</strong></p><p class="calibre7">Java also provides the basic tools necessary to build a robust implementation of our <code class="literal">MinHeap</code> class with little code. Here's how that class might look in Java:</p><pre class="programlisting">    List&lt;HeapNode&gt; elements; 
 
    public int size() 
    { 
        return elements.size(); 
    } 
 
    public MinHeap() 
    { 
        elements = new ArrayList&lt;HeapNode&gt;();  
    } 
</pre><p class="calibre7">Our <code class="literal">MinHeap</code> class includes one public field of abstract type <code class="literal">List&lt;HeapNode&gt;</code> named <code class="literal">elements</code> that represents our heap collection. The class also include a method named <code class="literal">size()</code>, which will return the total number of elements in the collection. Finally, our constructor simply initializes the <code class="literal">elements</code> collection as an <code class="literal">ArrayList&lt;HeapNode&gt;</code>:</p><pre class="programlisting">    public void insert(HeapNode item) 
    { 
        elements.add(item); 
        orderHeap(); 
    } 
</pre><p class="calibre7">The <code class="literal">insert(HeapNode item)</code> method accepts a new <code class="literal">HeapNode</code> object and adds it to the collection. Once the object has been added, the method calls <code class="literal">orderHeap()</code> to make sure the new object is placed in the correct position to maintain the heap property.</p><pre class="programlisting">    public void delete(HeapNode item) 
    { 
        int i = elements.indexOf(item); 
        int last = elements.size() - 1; 
 
        elements.set(i, elements.get(last)); 
        elements.remove(last); 
        orderHeap(); 
    } 
</pre><p class="calibre7">The <code class="literal">delete(HeapNode item)</code> method accepts a <code class="literal">HeapNode</code> item to be removed from the collection. The method first finds the index of the item to be removed, then gets the index of the last object in the collection. Next, the method deletes the matching node by overwriting its position with a reference to the last node in the heap and then the last node is removed. Finally, <code class="literal">orderHeap()</code> is called to ensure the final collection satisfies the heap property.</p><pre class="programlisting">    public HeapNode extractMin() 
    { 
        if (elements.size() &gt; 0) 
        { 
            HeapNode item = elements.get(0); 
            delete(item); 
            return item; 
        } 
 
        return null; 
    } 
</pre><p class="calibre7">The <code class="literal">extractMin()</code> method first confirms that the <code class="literal">elements</code> collection has at least one element. If not, the method returns <code class="literal">null</code>. Otherwise the method creates a new instance of <code class="literal">HeapNode</code> called <code class="literal">item</code> and sets it to the root object in the collection, which is the smallest object or the object with the lowest priority. Next, the method calls <code class="literal">delete(item)</code> to remove the node from the collection. Finally, since the <code class="literal">ExtractMin</code> function must return an object, the method returns <code class="literal">item</code> to the caller.</p><pre class="programlisting">    public HeapNode findMin() 
    { 
        if (elements.size() &gt; 0) 
        { 
            return elements.get(0); 
        } 
 
        return null; 
    } 
</pre><p class="calibre7">The <code class="literal">findMin()</code> method is very similar to the <code class="literal">extractMin()</code> method, except that it does not remove the returned minimum value from the collection. The method first confirms that the elements collection has at least one element. If not, the method returns <code class="literal">null</code>. Otherwise the method returns the root object in the collection by calling <code class="literal">elements.get(0)</code>.</p><pre class="programlisting">    private void orderHeap() 
    { 
        for (int i = elements.size() - 1; i &gt; 0; i--) 
        { 
            int parentPosition = (i - 1) / 2; 
 
            if (elements.get(parentPosition).Data &gt; elements.get(i).Data) 
            { 
                swapElements(parentPosition, i); 
            } 
        } 
    } 
 
    private void swapElements(int firstIndex, int secondIndex) 
    { 
        HeapNode tmp = elements.get(firstIndex); 
        elements.set(firstIndex, elements.get(secondIndex)); 
        elements.set(secondIndex, tmp); 
    } 
</pre><p class="calibre7">The private <code class="literal">orderHeap()</code> method is responsible for maintaining the heap property of the collection. The method first establishes a <code class="literal">for</code> loop based on the length of the elements collection, and begins iterating through the collection from the end to the beginning.</p><p class="calibre7">Using the min heap property formula, the <code class="literal">for</code> loop first identifies the parent index for the current node. Next, the value of the current node's <code class="literal">Data</code> field is compared to that of the parent, and if the parent is larger, the method calls <code class="literal">swapElements(parentPosition, i)</code>. Once each of the nodes has been evaluated, the method is complete and the heap property is consistent throughout the collection.</p><p class="calibre7">The <code class="literal">swapElements(int firstIndex, int secondIndex)</code> method's function is self-explanatory. Each of the nodes at the given indices is swapped to enforce the heap property.</p><pre class="programlisting">    public List&lt;HeapNode&gt; getChildren(int parentIndex) 
    { 
        if (parentIndex &gt;= 0) 
        { 
            ArrayList&lt;HeapNode&gt; children = new ArrayList&lt;HeapNode&gt;(); 
            int childIndexOne = (2 * parentIndex) + 1; 
            int childIndexTwo = (2 * parentIndex) + 2; 
            children.add(elements.get(childIndexOne)); 
            children.add(elements.get(childIndexTwo)); 
 
            return children; 
        } 
 
        return null; 
    } 
</pre><p class="calibre7">Using the same rule, which states that the two children of any object at index i are located at indices <em class="calibre20">2i + 1</em> and <em class="calibre20">2i + 2</em>, the <code class="literal">getChildren(int parentIndex)</code> method gathers and returns the two child nodes for a given parent index. The method first confirms that <code class="literal">parentIndex</code> is not less than 0, otherwise it returns <code class="literal">null</code>. If the <code class="literal">parentIndex</code> is valid, the method creates a new <code class="literal">ArrayList&lt;Heapnode&gt;</code> and populates it using the calculated child indices before returning the <code class="literal">children</code> collection.</p><pre class="programlisting">    public HeapNode getParent(int childIndex) 
    { 
        if (childIndex &gt; 0 &amp;&amp; elements.size() &gt; childIndex) 
        { 
            int parentIndex = (childIndex - 1) / 2; 
            return elements.get(parentIndex); 
        } 
 
        return null; 
    } 
</pre><p class="calibre7">Finally, <code class="literal">getParent(int childIndex)</code> works on the same principle as <code class="literal">getChildren</code>. If the given <code class="literal">childIndex</code> is greater than 0 the node has a parent. The method confirms that we are not searching for the root node and also confirms that the index is not out of bounds for the collection. If either check fails, the method returns <code class="literal">null</code>. Otherwise, the method determines the node's parent index and then returns the node found at that index.</p><p class="calibre7"><strong class="calibre16">Objective-C</strong></p><p class="calibre7">Using an <code class="literal">NSMutableArray</code> as the core structure, Objective-C can also easily implement the min heap data structure. Here's how the <code class="literal">EDSMinHeap</code> class might look in Objective-C:</p><pre class="programlisting">    @interface EDSMinHeap() 
    { 
        NSMutableArray&lt;EDSHeapNode*&gt; *_elements; 
    } 
 
    @implementation EDSMinHeap 
 
    -(instancetype)initMinHeap{ 
     
        if (self = [super init]) 
        { 
            _elements = [NSMutableArray array]; 
        } 
     
        return self; 
    } 
</pre><p class="calibre7">Using the class cluster <code class="literal">NSMutableArray</code>, we create an ivar for our class called <code class="literal">_elements</code>. Our initializer instantiates this array, giving us the underlying data structure to build our<code class="literal"> EDSMinHeap</code> class on.</p><pre class="programlisting">    -(NSInteger)getCount 
    { 
        return [_elements count]; 
    } 
</pre><p class="calibre7">Our <code class="literal">EDSMinHeap</code> class includes one public property named <code class="literal">Count</code>, and the <code class="literal">getCount()</code> accessor returns the <code class="literal">count</code> property of the <code class="literal">_elements</code> array.</p><pre class="programlisting">    -(void)insert:(EDSHeapNode*)item 
    { 
        [_elements addObject:item]; 
        [self orderHeap]; 
    } 
</pre><p class="calibre7">The <code class="literal">insert:</code> method accepts a new <code class="literal">EDSHeapNode</code> object and adds it to the array. Once the object has been added, the method calls <code class="literal">orderHeap</code> to make sure the new object is placed in the correct position to maintain the heap property:</p><pre class="programlisting">    -(void)delete:(EDSHeapNode*)item 
    { 
        long i = [_elements indexOfObject:item]; 
     
        _elements[i] = [_elements lastObject]; 
        [_elements removeLastObject]; 
        [self orderHeap]; 
    } 
</pre><p class="calibre7">The <code class="literal">delete:</code> method accepts an <code class="literal">EDSHeapNode</code> item to be removed from the collection. The method first finds the index of the item to be removed using <code class="literal">indexOfObject:</code>, then deletes the matching node by overwriting its position with a reference to the <code class="literal">lastObject</code> in the heap. Next, the last node is removed using <code class="literal">removeLastObject</code>. Finally, <code class="literal">orderHeap:</code> is called to ensure the final collection satisfies the heap property.</p><pre class="programlisting">    -(EDSHeapNode*)extractMin 
    { 
        if ([_elements count] &gt; 0) 
        { 
            EDSHeapNode *item = _elements[0]; 
            [self delete:item]; 
            return item; 
        } 
     
        return nil; 
    } 
</pre><p class="calibre7">The <code class="literal">extractMin</code> method first confirms that the <code class="literal">_elements</code> collection has at least one element. If not, the method returns <code class="literal">nil</code>. Otherwise, the method creates a new instance of <code class="literal">EDSHeapNode</code> called <code class="literal">item</code> and sets it to the root object in the collection, which is the smallest object or the object with the lowest priority. Next, the method calls <code class="literal">delete:</code> to remove the node from the collection. Finally, since the <em class="calibre20">ExtractMin</em> function must return an object, the method returns <code class="literal">item</code> to the caller.</p><pre class="programlisting">    -(EDSHeapNode*)findMin 
    { 
        if ([_elements count] &gt; 0) 
        { 
            return _elements[0]; 
        } 
     
        return nil; 
    } 
</pre><p class="calibre7">The <code class="literal">findMin</code> method is very similar to the <code class="literal">extractMin</code> method, except that it does not remove the returned minimum value from the collection. The method first confirms that the elements collection has at least one element. If not, the method returns <code class="literal">nil</code>. Otherwise the method returns the first object in the collection, which is the root node.</p><pre class="programlisting">    -(void)orderHeap 
    { 
        for (long i = [_elements count] - 1; i &gt; 0; i--) 
        { 
            long parentPosition = (i - 1) / 2; 
         
            if (_elements[parentPosition].data &gt; _elements[i].data) 
            { 
                [self swapElement:parentPosition withElement:i]; 
            } 
        } 
    } 
 
    -(void)swapElement:(long)firstIndex withElement:(long)secondIndex 
    { 
        EDSHeapNode *tmp = _elements[firstIndex]; 
        _elements[firstIndex] = _elements[secondIndex]; 
        _elements[secondIndex] = tmp; 
    } 
</pre><p class="calibre7">The private <code class="literal">orderHeap</code> method is responsible for maintaining the heap property of the collection. The method first establishes a <code class="literal">for</code> loop based on the length of the elements collection, and begins iterating through the collection from the end to the beginning.</p><p class="calibre7">Using the min heap property formula, the <code class="literal">for</code> loop first identifies the parent index for the current node. Next, the value of the current node's <code class="literal">data</code> property is compared to that of the parent, and if the parent is larger, the method calls <code class="literal">swapElement:withElement:</code>. Once each of the nodes has been evaluated, the method is complete and the heap property is consistent throughout the collection.</p><p class="calibre7">The <code class="literal">swapElement:withElement:</code> method's function is self-explanatory. Each of the nodes at the given indices is swapped to enforce the heap property.</p><pre class="programlisting">    -(NSArray&lt;EDSHeapNode*&gt;*)childrenOfParentIndex:(NSInteger)parentIndex 
    { 
        if (parentIndex &gt;= 0) 
        { 
            NSMutableArray *children = [NSMutableArray array]; 
            long childIndexOne = (2 * parentIndex) + 1; 
            long childIndexTwo = (2 * parentIndex) + 2; 
            [children addObject:_elements[childIndexOne]]; 
            [children addObject:_elements[childIndexTwo]]; 
         
            return children; 
        } 
        return nil; 
    } 
</pre><p class="calibre7">Using the rule that states the two children of any object at index i are located at indices <em class="calibre20">2i + 1</em> and <em class="calibre20">2i + 2</em>, the <code class="literal">childrenOfParentIndex:</code> method gathers and returns the two child nodes for a given parent index. The method first confirms that <code class="literal">parentIndex</code> is not less than 0, otherwise it returns <code class="literal">nil</code>. If the <code class="literal">parentIndex</code> is valid, the method creates a new <code class="literal">NSMutableArray</code> and populates it using nodes from the calculated child indices before returning the <code class="literal">children</code> collection.</p><pre class="programlisting">    -(EDSHeapNode*)parentOfChildIndex:(NSInteger)childIndex 
    { 
        if (childIndex &gt; 0 &amp;&amp; [_elements count] &gt; childIndex) 
        { 
            long parentIndex = (childIndex - 1) / 2; 
            return _elements[parentIndex]; 
        } 
     
        return nil; 
    } 
</pre><p class="calibre7">Finally, <code class="literal">parentOfChildIndex:</code> works on the same principle as <code class="literal">childrenOfParentIndex:</code>. If the given <code class="literal">childIndex</code> is greater than 0, the node has a parent. The method confirms that we are not searching for the root node and also confirms that the index is not out of bounds for the collection. If either check fails, the method returns <code class="literal">nil</code>. Otherwise, the method determines the node's parent index and then returns the node found at that index.</p><p class="calibre7"><strong class="calibre16">Swift</strong></p><p class="calibre7">Our Swift <code class="literal">MinHeap</code> class is similar in structure and functionality to the C# and Java implementations. Here's what an example of the <code class="literal">MinHeap</code> class might look like in Swift:</p><pre class="programlisting">    public var _elements: Array = [HeapNode]() 
    public init () {} 
 
    public func getCount() -&gt; Int 
    { 
        return _elements.count 
    } 
</pre><p class="calibre7">Using the <code class="literal">Array</code> class we create a private property for our class called <code class="literal">_elements</code>. Since our property is declared and instantiated simultaneously, and there is no other custom code requiring instantiation, we can exclude the explicit public initializer and rely on the default initializer. Our class also provides a public method called <code class="literal">getCount()</code>, which returns the size of the <code class="literal">_elements</code> array.</p><pre class="programlisting">    public func insert(item: HeapNode) 
    { 
        _elements.append(item) 
        orderHeap() 
    } 
</pre><p class="calibre7">The <code class="literal">insert(HeapNode item)</code> method accepts a new <code class="literal">HeapNode</code> object and adds it to the collection. Once the object has been added the method calls <code class="literal">orderHeap()</code>to make sure the new object is placed in the correct position to maintain the heap property.</p><pre class="programlisting">    public func delete(item: HeapNode) 
    { 
        if let index = _elements.index(of: item) 
        { 
            _elements[index] = _elements.last! 
            _elements.removeLast() 
            orderHeap() 
        } 
    } 
</pre><p class="calibre7">The <code class="literal">delete(HeapNode item)</code> method accepts a <code class="literal">HeapNode</code> item to be removed from the collection. The method first finds the <code class="literal">index</code> of the item to be removed, then deletes the matching node by overwriting its position with a reference to the <code class="literal">last </code>object in the heap. Finally, the <code class="literal">orderHeap()</code> method is called to ensure the final collection satisfies the heap property.</p><pre class="programlisting">    public func extractMin() -&gt; HeapNode? 
    { 
        if (_elements.count &gt; 0) 
        { 
            let item = _elements[0] 
            delete(item: item) 
            return item 
        } 
     
        return nil 
    } 
</pre><p class="calibre7">The <code class="literal">extractMin()</code> method first confirms that the <code class="literal">elements</code> collection has at least one element. If not, the method returns <code class="literal">nil</code>. Otherwise the method creates a new variable called <code class="literal">item</code> and sets it to the root object in the collection, which is the smallest <code class="literal">HeapNode</code> or the <code class="literal">HeapNode</code> with the lowest priority. Next, the method calls <code class="literal">delete(item: Heapnode)</code> to remove the node from the collection. Finally, the method returns <code class="literal">item</code> to the caller.</p><pre class="programlisting">    public func findMin() -&gt; HeapNode? 
    { 
        if (_elements.count &gt; 0) 
        { 
            return _elements[0] 
        } 
     
        return nil 
    } 
</pre><p class="calibre7">The <code class="literal">findMin()</code> method is very similar to the <code class="literal">extractMin()</code> method, except that it does not remove the returned minimum value from the collection. The method first confirms that the elements collection has at least one element. If not, the method returns <code class="literal">nil</code>. Otherwise the method returns <code class="literal">_elements[0]</code>, which is the root object in the collection.</p><pre class="programlisting">    public func orderHeap() 
    { 
        for i in (0..&lt;(_elements.count) - 1).reversed() 
        { 
            let parentPosition = (i - 1) / 2 
 
            if (_elements[parentPosition].data! &gt; _elements[i].data!) 
            { 
                swapElements(first: parentPosition, second: i) 
            } 
        } 
    } 
 
    public func swapElements(first: Int, second: Int) 
    { 
        let tmp = _elements[first] 
        _elements[first] = _elements[second] 
        _elements[second] = tmp 
    } 
</pre><p class="calibre7">The private <code class="literal">orderHeap()</code> method is responsible for maintaining the heap property of the collection. The method first establishes a <code class="literal">for</code> loop based on the length of the elements collection, and begins iterating through the collection from the end to the beginning.</p><p class="calibre7">Using the min heap property formula, the <code class="literal">for</code> loop first identifies the parent index for the current node. Next, the value of the current node's <code class="literal">data</code> field is compared to that of the parent, and if the parent is larger, the method calls <code class="literal">swapElements(first: Int, second: Int)</code>. Once each of the nodes has been evaluated, the method is complete and the heap property is consistent throughout the collection.</p><p class="calibre7">The <code class="literal">swapElements(int firstIndex, int secondIndex)</code> method's function is self-explanatory. Each of the nodes at the given indices is swapped to enforce the heap property:</p><pre class="programlisting">    public func getChildren(parentIndex: Int) -&gt; [HeapNode]? 
    { 
        if (parentIndex &gt;= 0) 
        { 
            var children: Array = [HeapNode]() 
         
            let childIndexOne = (2 * parentIndex) + 1; 
            let childIndexTwo = (2 * parentIndex) + 2; 
            children.append(_elements[childIndexOne]) 
            children.append(_elements[childIndexTwo]) 
         
            return children; 
        } 
     
        return nil; 
    } 
</pre><p class="calibre7">Using the same rule that states the two children of any object at index <code class="literal">i</code> are located at indices <em class="calibre20">2i + 1</em> and <em class="calibre20">2i + 2</em>, the <code class="literal">getChildren(parentIndex: Int)</code> method gathers and returns the two child nodes for a given parent index. The method first confirms that <code class="literal">parentIndex</code> is not less than 0, otherwise it returns <code class="literal">nil</code>. If the <code class="literal">parentIndex</code> is valid, the method creates a new <code class="literal">Array</code> of <code class="literal">HeapNode</code> objects and populates it using the calculated child indices before returning the <code class="literal">children</code> collection:</p><pre class="programlisting">    public func getParent(childIndex: Int) -&gt; HeapNode? 
    { 
        if (childIndex &gt; 0 &amp;&amp; _elements.count &gt; childIndex) 
        { 
            let parentIndex = (childIndex - 1) / 2; 
            return _elements[parentIndex]; 
        } 
     
        return nil; 
    } 
</pre><p class="calibre7">Finally, <code class="literal">getParent(childIndex: Int)</code> works on the same principle as <code class="literal">getChildren</code>. If the given <code class="literal">childIndex</code> is greater than <code class="literal">0</code> the node has a parent. The method confirms that we are not searching for the root node and also confirms that the index is not out of bounds for the collection. If either check fails, the method returns <code class="literal">nil</code>. Otherwise, the method determines the node's parent index and then returns the node found at that index.</p></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec54" class="calibre1"/>Common applications</h1></div></div></div><p class="calibre7">Heap data structures are actually quite common, although you may not always realize you are working with one. Here are some of the most common applications for the heap data structure:</p><div><ul class="itemizedlist"><li class="listitem"><strong class="calibre16">Selection algorithms</strong>: A selection algorithm is used to determine the k<sup class="calibre21">th</sup> smallest or largest element in a collection, or the median valued object of a collection. In a typically collection, this operation costs O(n). However, in an ordered heap implemented with an array finding the k<sup class="calibre21">th</sup> element is an <strong class="calibre16">O</strong>(1) operation because we can find the element by simply examining the k index in the array.</li><li class="listitem"><strong class="calibre16">Priority queue</strong>: Priority queues are an abstract data structure similar to standard queues except that the nodes contain an additional value representing the priority of that object in relation to others in the collection. Due to the natural sorting of the heap data structure, priority queues are often implemented using the heap.</li></ul></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec55" class="calibre1"/>Summary</h1></div></div></div><p class="calibre7">In this chapter, we learned about heap data structures. We examined the most common operations when working with heaps and their complexity cost. Following this we created our own simple min heap data structure class from scratch, and discussed how the min heap property formula is used to calculate parents or children for any given node index. Finally, we examined the most common applications for heap data structures.</p></div></body></html>