<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer183">
<h1 class="chapter-number" id="_idParaDest-235"><a id="_idTextAnchor247"/>10</h1>
<h1 id="_idParaDest-236"><a id="_idTextAnchor248"/>Advanced and Modal Operators</h1>
<p>Since <a href="B18375_03.xhtml#_idTextAnchor049"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, we have resorted to operators to implement our features <span class="No-Break">in Blender.</span></p>
<p>Operators have already proved to be incredibly flexible, with custom properties and looks. They can be even more powerful once we learn how to override all <span class="No-Break">their methods.</span></p>
<p>The operators encountered in the previous chapters run as soon as they are launched and finish immediately. If we need to, we can make the execution modal and let the operator listen to <span class="No-Break">input events.</span></p>
<p>In this chapter, you will learn how to control the execution of an operator, and how you can write fully <span class="No-Break">interactive operators.</span></p>
<p>This chapter will cover the <span class="No-Break">following topics:</span></p>
<ul>
<li>Understanding the <span class="No-Break">operator flow</span></li>
<li>Setting <span class="No-Break">properties programmatically</span></li>
<li>Writing <span class="No-Break">modal operators</span></li>
</ul>
<h1 id="_idParaDest-237"><a id="_idTextAnchor249"/>Technical requirements</h1>
<p>We will use Blender and Visual Studio Code in this chapter, but any other programmer text editor can be used. The examples created in this chapter can be found <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch10"><span class="No-Break">https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch10</span></a><span class="No-Break">.</span></p>
<h1 id="_idParaDest-238"><a id="_idTextAnchor250"/>Understanding the operator flow</h1>
<p>We dealt with operators since <a href="B18375_03.xhtml#_idTextAnchor049"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, and we learned how their <strong class="source-inline">poll</strong> method <a id="_idIndexMarker662"/>checks whether the operator can be executed, while <strong class="source-inline">execute</strong> performs the operation <span class="No-Break">and exits.</span></p>
<p>Then in <a href="B18375_04.xhtml#_idTextAnchor075"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, we added editable parameters to the <em class="italic">Elevator</em> operator, thanks to the <strong class="source-inline">'REGISTER'</strong> and <strong class="source-inline">'</strong><span class="No-Break"><strong class="source-inline">UNDO'</strong></span><span class="No-Break"> options.</span></p>
<p>We also learned about the clever trick to change a result in real time when a user changes a parameter – Blender secretly undoes the last operation and performs it again with the new options, hence the need <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">'UNDO'</strong></span><span class="No-Break">.</span></p>
<p>That became more evident in <a href="B18375_07.xhtml#_idTextAnchor171"><span class="No-Break"><em class="italic">Chapter 7</em></span></a>, when we learned how using <strong class="bold">Edit</strong> | <strong class="bold">Adjust Last Operation</strong> from the menu bar changes the result of the <span class="No-Break">last operation.</span></p>
<p>While those solutions <a id="_idIndexMarker663"/>allow us to get input parameters with ease, they don’t give access to the actual input events, such as the pressure of a key or the movement of <span class="No-Break">a mouse.</span></p>
<p>That would require a <strong class="bold">listener</strong> – that is, code that waits for device inputs and is executed continuously. Normally, launching an operator runs its <strong class="source-inline">execute</strong> method instantly, so it couldn’t possibly wait for inputs; therefore, the events must be handled by <span class="No-Break">another method.</span></p>
<p>Another thing we cannot do in <strong class="source-inline">execute</strong> is set the operator’s editable parameters. Since Blender runs <strong class="source-inline">execute</strong> again when a parameter is changed, the user would find themselves unable to set a property, as it would be <span class="No-Break">overridden immediately.</span></p>
<p>Capturing events and initializing operator parameters are two tasks that cannot be performed by <strong class="source-inline">execute</strong>. Luckily, <strong class="source-inline">execute</strong> is not the only method involved when an operator is launched; we will see that an operator’s lifetime encompasses a set of methods, each of them with a <span class="No-Break">specific purpose.</span></p>
<h2 id="_idParaDest-239"><a id="_idTextAnchor251"/>Steps of execution</h2>
<p>We know from <a href="B18375_03.xhtml#_idTextAnchor049"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, that the operator <strong class="source-inline">poll</strong> and <strong class="source-inline">execute</strong> methods are <a id="_idIndexMarker664"/>required, respectively, for validation and execution. In <a href="B18375_05.xhtml#_idTextAnchor100"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, we used <strong class="source-inline">invoke</strong> to make sure that the operator properties are displayed before <span class="No-Break">it runs.</span></p>
<p>Now, we will take a closer look at how operators are displayed <span class="No-Break">and run:</span></p>
<ol>
<li>Blender checks the return value of <strong class="source-inline">poll</strong>. If the result is <strong class="source-inline">False</strong>, the operator is grayed out; otherwise, the operator can <span class="No-Break">be launched.</span></li>
<li>The operator is launched, and it runs the <strong class="source-inline">invoke</strong> method. This method is optional; if we don’t write it, its step is skipped, and Blender runs <span class="No-Break"><strong class="source-inline">execute</strong></span><span class="No-Break"> directly.</span></li>
</ol>
<p>One common use of <strong class="source-inline">invoke</strong> is the initialization of the operator’s variables or internal value; unlike conventional Python classes, operators don’t implement the traditional <strong class="source-inline">__init__</strong> method.</p>
<p>Like <strong class="source-inline">execute</strong>, <strong class="source-inline">invoke</strong> must return an exit status, which can be <strong class="source-inline">'FINISHED'</strong>, <strong class="source-inline">'CANCELLED'</strong>, or <strong class="source-inline">'RUNNING_MODAL'</strong>.</p>
<ol>
<li value="3">If our operator is <a id="_idIndexMarker665"/>meant to listen for mouse and keyboard <a id="_idIndexMarker666"/>events, in <strong class="source-inline">invoke</strong>, we add it to the application <strong class="bold">event handlers</strong>, and then return the exit status <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">'RUNNING_MODAL'</strong></span><span class="No-Break">.</span></li>
<li>If the operator is part of the handlers, its <strong class="source-inline">modal</strong> method is executed at every trigger event (when a mouse cursor moves, a key is pressed, etc.), until the modal returns <strong class="source-inline">'CANCELLED'</strong> or <strong class="source-inline">'FINISHED'</strong>. Otherwise, to continue listening, it should <span class="No-Break">return </span><span class="No-Break"><strong class="source-inline">'RUNNING_MODAL'</strong></span><span class="No-Break">.</span></li>
<li>If <strong class="source-inline">bl_options</strong> is <strong class="source-inline">{'REGISTER','UNDO'}</strong>, the operator properties are displayed in a panel at the bottom left of the screen. The panel relies on the operator’s <span class="No-Break"><strong class="source-inline">draw</strong></span><span class="No-Break"> method.</span></li>
<li>By default, all the operator properties that are not flagged with <strong class="source-inline">hidden</strong> upon declaration are displayed in the panel. Reimplementing this method allows us to implement a custom design using the techniques learned in <a href="B18375_05.xhtml#_idTextAnchor100"><span class="No-Break"><em class="italic">Chapter 5</em></span></a><span class="No-Break">.</span></li>
<li>Changing a value in the operator panel runs <strong class="source-inline">execute</strong> again, with <span class="No-Break">updated properties.</span></li>
</ol>
<p>The execution flow is summed up in <span class="No-Break"><em class="italic">Figure 10</em></span><em class="italic">.1</em>, which helps us understand how the methods in the execution flow add up when an operator <span class="No-Break">is launched.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer177">
<img alt="Figure 10.1: The operator methods from the start to the end of the evaluation" height="1134" src="image/Figure_10.01_B18375.jpg" width="587"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.1: The operator methods from the start to the end of the evaluation</p>
<p>While <strong class="source-inline">poll</strong> is run by the <a id="_idIndexMarker667"/>interface every time that the operator is displayed, <strong class="source-inline">invoke</strong> is the first step of an operator flow, so we can use it to set the operator’s parameters programmatically and, from there, move to <strong class="source-inline">execute</strong> or <strong class="source-inline">modal</strong>. In the next section, we will use <strong class="source-inline">invoke</strong> to initialize the operator parameters according <a id="_idIndexMarker668"/>to the time of <span class="No-Break">the day.</span></p>
<h1 id="_idParaDest-240"><a id="_idTextAnchor252"/>Writing the “PunchClock” add-on</h1>
<p>Some tools can require the current date and time from the operating system clock. In Python, we can <a id="_idIndexMarker669"/>use the <strong class="source-inline">datetime</strong> module to get them in our scripts, generally for versioning or logging purposes. There are no Blender properties designed specifically for time units, but an hour and a minute can be stored as two separate integer properties of <span class="No-Break">an operator.</span></p>
<p>We know how to use the <strong class="source-inline">default</strong> argument to declare the initial value of a property, but what if that value is not always the same? For example, the current hour and minute change during the day, but <strong class="source-inline">default</strong> only sets <span class="No-Break">static values.</span></p>
<p>But since <strong class="source-inline">invoke</strong> is executed before all the other methods, we can set our default values programmatically <span class="No-Break">in there.</span></p>
<p>To demonstrate that, we will create an add-on to create a time format text in the current scene. By default, the text displays the current time of the day, but the user can <span class="No-Break">change that.</span></p>
<h2 id="_idParaDest-241"><a id="_idTextAnchor253"/>Creating the add-on script</h2>
<p>Let’s create the <strong class="source-inline">ch10</strong> folder <a id="_idIndexMarker670"/>in our Python project, and then in <strong class="bold">Blender Preferences</strong>, we set it as the <strong class="bold">Scripts</strong> folder and <span class="No-Break">restart Blender:</span></p>
<ol>
<li>Select <strong class="source-inline">PythonScriptingBlender/ch10/addons</strong> in your file browser or programmer editor – for instance, <span class="No-Break"><strong class="bold">VS Code</strong></span><span class="No-Break">.</span></li>
<li>Create a new file by clicking on the <strong class="bold">New </strong><span class="No-Break"><strong class="bold">File</strong></span><span class="No-Break"> icon.</span></li>
<li>Name the new <span class="No-Break">file </span><span class="No-Break"><strong class="source-inline">punch_clock.py</strong></span><span class="No-Break">.</span></li>
<li>Open the file <span class="No-Break">for editing.</span></li>
<li>Set the <strong class="bold">Scripts</strong> path to <strong class="source-inline">PythonScriptingBlender/ch10</strong> in the Blender <strong class="bold">File Paths</strong> preferences and <span class="No-Break">restart Blender.</span></li>
</ol>
<p>We store the add-on information in the <strong class="source-inline">bl_info</strong> dictionary, <span class="No-Break">as usual:</span></p>
<pre class="source-code">
bl_info = {
    "name": "Text PunchClock",
    "author": "Packt Man",
    "version": (1, 0),
    "blender": (3, 00, 0),
    "description": "Create an Hour/Minutes text object",
    "category": "Learning",
}</pre>
<p>This add-on contains an operator, which will be available in the <strong class="bold">Add</strong> menu of the <span class="No-Break">3D Viewport.</span></p>
<p>We start with an <a id="_idIndexMarker671"/>operator that creates a text in the <em class="italic">HH:MM</em> format, like digital clocks, where <em class="italic">HH</em> stands for a 2-digit hour number and <em class="italic">MM</em> for <span class="No-Break">the minutes.</span></p>
<p>Hours and minutes are stored as <strong class="source-inline">IntProperty</strong>, ranging between <strong class="source-inline">0</strong> and <strong class="source-inline">23</strong> for the hours and <strong class="source-inline">0</strong> and <strong class="source-inline">59</strong> for the minutes. The operator’s code starts <span class="No-Break">as follows:</span></p>
<pre class="source-code">
import bpy
class PunchClock(bpy.types.Operator):
    """Create Hour/Minutes text"""
    bl_idname = "text.punch_clock"
    bl_label = "Create Hour/Minutes Text"
    bl_description = "Create Hour Minutes Text"
    bl_options = {'REGISTER', 'UNDO'}
    <strong class="source-inline">hour</strong>: bpy.props.<strong class="source-inline">IntProperty</strong>(default=0, min=0, <strong class="source-inline">max=23</strong>)
    <strong class="source-inline">mins</strong>: bpy.props.<strong class="source-inline">IntProperty</strong>(default=0, min=0, <strong class="source-inline">max=59</strong>)</pre>
<p>We can add a new object if Blender is in <strong class="bold">Object</strong> mode, so the condition for <strong class="source-inline">poll</strong> is <span class="No-Break">as follows:</span></p>
<pre class="source-code">
    @classmethod
    def poll(cls, context):
        return context.mode == 'OBJECT'</pre>
<p>In <strong class="source-inline">execute</strong>, we create new <a id="_idIndexMarker672"/>text data and set it to <strong class="source-inline">{hour}:{min}</strong>. The Blender type for text is named <strong class="source-inline">FONT</strong>, and its displayed text is stored in the <span class="No-Break"><strong class="source-inline">body</strong></span><span class="No-Break"> attribute.</span></p>
<p>We use <strong class="bold">string formatting</strong>, which we learned about in <a href="B18375_05.xhtml#_idTextAnchor100"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>. Adding <strong class="source-inline">:02</strong> after a variable specifies that we want to display a 2-digit number – for instance, <strong class="source-inline">f"{3:02}"</strong> <span class="No-Break">becomes </span><span class="No-Break"><strong class="source-inline">"03"</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
    def execute(self, context):
        <strong class="source-inline">txt_crv</strong> = bpy.data.curves.new(type=<strong class="source-inline">"FONT"</strong>,
                                      name="TXT-clock")
        <strong class="source-inline">txt_crv.body</strong> = f"<strong class="source-inline">{self.hour:02}:{self.mins:02}</strong>"</pre>
<p>We create an object to link it to the current collection and see the text in <span class="No-Break">the scene:</span></p>
<pre class="source-code">
        txt_obj = bpy.data.<strong class="source-inline">objects.new</strong>(name="Font Object",
                                       <strong class="source-inline">object_data=txt_crv</strong>)</pre>
<p>After that, we return <strong class="source-inline">FINISHED</strong> as <span class="No-Break">execution state:</span></p>
<pre class="source-code">
        context.<strong class="source-inline">collection.objects.link(txt_obj)</strong>
        return {'FINISHED'}</pre>
<p>The first draft of our operator is ready, and now we create a <strong class="source-inline">menu</strong> function to add to the interface. We can use <strong class="bold">Icon Viewer</strong>, as we did in <a href="B18375_05.xhtml#_idTextAnchor100"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, and look for an icon that suits our operator. By typing <strong class="source-inline">time</strong> in the search field, we end up with three relevant icons – <strong class="source-inline">TIME</strong>, <strong class="source-inline">MOD_TIME</strong>, and <strong class="source-inline">SORTTIME</strong>. Any of those will do; we will pick <strong class="source-inline">TIME</strong> in <span class="No-Break">this example.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer178">
<img alt="Figure 10.2: The time-related default icons in Icon Viewer" height="217" src="image/Figure_10.02_B18375.jpg" width="381"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.2: The time-related default icons in Icon Viewer</p>
<p>We start <strong class="source-inline">menu_func</strong> with a <strong class="source-inline">separator</strong> to set our operator apart, and then we add our entry for <strong class="source-inline">PunchClock</strong> <span class="No-Break">via </span><span class="No-Break"><strong class="source-inline">Layout.operator</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
def menu_func(self, context):
    self.layout.separator()
    self.layout.operator(PunchClock.<strong class="source-inline">bl_idname</strong>, icon='TIME')</pre>
<p>Finally, we add and <a id="_idIndexMarker673"/>remove our operator and menu item in the <strong class="source-inline">register</strong> and <span class="No-Break"><strong class="source-inline">unregister</strong></span><span class="No-Break"> functions:</span></p>
<pre class="source-code">
def register():
    bpy.utils.register_class(PunchClock)
    bpy.types.VIEW3D_MT_add.append(menu_func)
def unregister():
    bpy.types.VIEW3D_MT_add.remove(menu_func)
    bpy.utils.unregister_class(PunchClock)</pre>
<p>If we restart Blender or refresh the <strong class="bold">Add-ons</strong> list, we should be able to see the <span class="No-Break"><strong class="bold">PunchClock</strong></span><span class="No-Break"> add-on.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer179">
<img alt="Figure 10.3: PunchClock, as displayed in the Add-ons list" height="233" src="image/Figure_10.03_B18375.jpg" width="694"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.3: PunchClock, as displayed in the Add-ons list</p>
<p>At this stage, selecting <strong class="bold">Add</strong> | <strong class="bold">Create Hour/Minutes Text</strong> in the 3D Viewport top menu would add a text object displaying the <span class="No-Break">time </span><span class="No-Break"><em class="italic">00:00</em></span><span class="No-Break">.</span></p>
<p>We can get the <a id="_idIndexMarker674"/>current time from <strong class="source-inline">datetime</strong> and convert it to text, but we can do something even better – by setting <strong class="source-inline">self.hour</strong> and <strong class="source-inline">self.mins</strong> inside <strong class="source-inline">invoke</strong>, we will achieve the same result but also allow a user to change the <span class="No-Break">displayed time.</span></p>
<h2 id="_idParaDest-242"><a id="_idTextAnchor254"/>Using invoke to initialize properties</h2>
<p>To get the <a id="_idIndexMarker675"/>current time, we import <strong class="source-inline">datetime</strong> at the beginning of the script. The <strong class="source-inline">import</strong> section becomes <span class="No-Break">the following:</span></p>
<pre class="source-code">
import bpy
import <strong class="source-inline">datetime</strong></pre>
<p>Then, inside the operator class, we implement the <strong class="source-inline">invoke</strong> method. It can come right after <strong class="source-inline">poll</strong>, but any place under the <strong class="source-inline">PunchClock</strong> class <span class="No-Break">will do:</span></p>
<pre class="source-code">
    @classmethod
    def poll(cls, context):
        return context.mode == 'OBJECT'
    def <strong class="source-inline">invoke</strong>(self, context, event):
        <strong class="source-inline">now = datetime.datetime.now()</strong>
        self.<strong class="source-inline">hour = now.hour</strong>
        self.<strong class="source-inline">mins = now.minute</strong>
        <strong class="source-inline">return self.execute(context)</strong></pre>
<p>Now, the hour and minute of the operator are set up in <strong class="source-inline">invoke</strong>, and then <strong class="source-inline">execute</strong> is called to carry on <span class="No-Break">the operation.</span></p>
<p>Finishing <a id="_idIndexMarker676"/>with <strong class="source-inline">execute</strong> is important, as that’s what Blender expects when updating its <span class="No-Break">operations chronology.</span></p>
<p>Launching <strong class="bold">Create Hour/Minutes Text</strong> now displays the current time in a new text object and allows us to change the hour and minute using the <span class="No-Break">operator panel.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer180">
<img alt="Figure 10.4: Adding editable hour and minute fields, set to the current time" height="950" src="image/Figure_10.04_B18375.jpg" width="1377"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.4: Adding editable hour and minute fields, set to the current time</p>
<p>By using <strong class="source-inline">invoke</strong>, we have set our default values programmatically. That’s a common request in productions, since the desired defaults can change across projects, tasks, <span class="No-Break">and departments.</span></p>
<p>We have added our operator to the <strong class="bold">Add</strong> menu, which is also displayed in a popup if called with the <em class="italic">Shift</em> + <em class="italic">A</em> key combination. It’s a convenient shortcut, but pop-up menus have a different context that runs the operator’s <strong class="source-inline">execute</strong> <span class="No-Break">method directly.</span></p>
<p>To prevent the <a id="_idIndexMarker677"/>menu from skipping <strong class="source-inline">invoke</strong>, we need to override the layout’s context in our <span class="No-Break">menu function.</span></p>
<h2 id="_idParaDest-243"><a id="_idTextAnchor255"/>Ensuring default invoke in pop-up menus</h2>
<p>Layout elements <a id="_idIndexMarker678"/>can pass a custom context and force a design choice on operators. For example, buttons displayed outside the viewport avoid displaying operator properties, and pop-up menus bypass the <span class="No-Break"><strong class="source-inline">invoke</strong></span><span class="No-Break"> method.</span></p>
<p>We have encountered this behavior in the <em class="italic">Displaying buttons</em> section of <a href="B18375_05.xhtml#_idTextAnchor100"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, and in the <em class="italic">Writing the Action to Range add-on</em> section in <a href="B18375_07.xhtml#_idTextAnchor171"><span class="No-Break"><em class="italic">Chapter 7</em></span></a><span class="No-Break">.</span></p>
<p>We worked around those issues, respectively, by calling a properties dialog in <strong class="source-inline">invoke</strong>, or by using <strong class="bold">Edit</strong> | <strong class="bold">Adjust Last Operation</strong>, but none of that would work in this case, because we want <strong class="source-inline">invoke</strong> to run even when the operator is launched from the <strong class="bold">Add </strong>menu and displayed with the <em class="italic">Shift</em> + <em class="italic">A</em> combination. Being a pop-up menu, it overrides the context and <span class="No-Break">suppresses </span><span class="No-Break"><strong class="source-inline">invoke</strong></span><span class="No-Break">.</span></p>
<p>Therefore, we will change the layout’s <strong class="source-inline">operator_context</strong> to <strong class="source-inline">"INVOKE_DEFAULT"</strong>. We only need that for <strong class="source-inline">PunchClock</strong>, so, to minimize any potential impact on other menu entries, we add a new row and change only <span class="No-Break">its </span><span class="No-Break"><strong class="source-inline">operator_context</strong></span><span class="No-Break">.</span></p>
<p>Our menu function becomes <span class="No-Break">the following:</span></p>
<pre class="source-code">
def menu_func(self, context):
    self.layout.separator()
    <strong class="source-inline">row</strong> = self.layout.row()
    <strong class="source-inline">row.operator_context = "INVOKE_DEFAULT"</strong>
    row.operator(PunchClock.bl_idname, icon='TIME')</pre>
<p>By executing <strong class="source-inline">PunchClock</strong> with its default context, we make sure that <strong class="source-inline">invoke</strong> is <span class="No-Break">never skipped.</span></p>
<p>Now, the operator will always display its properties and let a user change them, but we can also implement a way to change the displayed time by just moving <span class="No-Break">the mouse.</span></p>
<p>In the next section, we <a id="_idIndexMarker679"/>will add operator response to mouse and keyboard input, making our operator a modal <span class="No-Break">application handler.</span></p>
<h1 id="_idParaDest-244"><a id="_idTextAnchor256"/>Adding modal behavior</h1>
<p>In user interfaces, the <a id="_idIndexMarker680"/>term <strong class="bold">modal</strong> designates a sub-window or widget that takes all the user interaction for itself, until the operation is <span class="No-Break">ended explicitly.</span></p>
<p>Usually, operators are designed to return to the main application immediately. If we don’t want that, they should be added to the window manager’s <span class="No-Break">modal handlers.</span></p>
<p>The operator is then considered modal and will listen to the user inputs until it’s <span class="No-Break">closed manually.</span></p>
<p>We can make <strong class="source-inline">PunchClock</strong> modal and use mouse movement to set our clock. Modal operators have <span class="No-Break">two requirements:</span></p>
<ul>
<li><strong class="source-inline">invoke</strong> adds the operator to the handlers and <span class="No-Break">returns </span><span class="No-Break"><strong class="source-inline">'RUNNING_MODAL'</strong></span><span class="No-Break">.</span></li>
<li><strong class="source-inline">modal</strong> is implemented and returns <strong class="source-inline">'RUNNING_MODAL'</strong>. It returns <strong class="source-inline">'FINISHED'</strong> when a user ends it, or <strong class="source-inline">'CANCELLED'</strong> to exit with <span class="No-Break">no changes.</span></li>
</ul>
<p>We will start to implement the modal execution by changing <strong class="source-inline">invoke</strong> and its <span class="No-Break">return value.</span></p>
<h2 id="_idParaDest-245"><a id="_idTextAnchor257"/>Adding the operator to the modal handlers</h2>
<p>Instead of <a id="_idIndexMarker681"/>passing to <strong class="source-inline">execute</strong>, <strong class="source-inline">invoke</strong> now calls the <strong class="source-inline">modal_handler_add</strong> method of the current <strong class="source-inline">window_manager</strong>, and then it returns <strong class="source-inline">{'RUNNING_MODAL'}</strong>. The return status notifies that the operator is running in Blender and listens <span class="No-Break">to events.</span></p>
<p>Since <strong class="source-inline">modal</strong> runs at every window update, we should keep it light and small. Adding objects to the scene is expensive, so we create and link the text in <strong class="source-inline">invoke</strong>, and only edit its body in <strong class="source-inline">modal</strong>. The <strong class="source-inline">invoke</strong> method stores <strong class="source-inline">txt_crv</strong> and <strong class="source-inline">txt_obj</strong> as operator <span class="No-Break">member attributes:</span></p>
<pre class="source-code">
    def invoke(self, context, event):
        now = datetime.datetime.now()
        self.hour = now.hour
        self.mins = now.minute
        self.txt_crv = bpy.data.curves.new(type="FONT",
                                           name="TXT-hhmm")
        self.txt_obj = bpy.data.objects.new(name="OB-Txt",
                                 object_data=self.txt_crv)
        context.collection.objects.link(self.txt_obj)
        context.window_manager.<strong class="source-inline">modal_handler_add(self)</strong>
        return {<strong class="source-inline">'RUNNING_MODAL'</strong>}</pre>
<p>The keywords that can be returned as status are listed in the API documentation (<a href="https://docs.blender.org/api/3.3/bpy_types_enum_items/operator_return_items.xhtml">https://docs.blender.org/api/3.3/bpy_types_enum_items/operator_return_items.xhtml</a>) and are <span class="No-Break">as follows:</span></p>
<ul>
<li><strong class="source-inline">RUNNING_MODAL</strong>: Keeps the operator running <span class="No-Break">with Blender</span></li>
<li><strong class="source-inline">CANCELLED</strong>: The operator exited without doing anything, so no undo entry should <span class="No-Break">be pushed</span></li>
<li><strong class="source-inline">FINISHED</strong>: The operator <a id="_idIndexMarker682"/>exited after completing <span class="No-Break">its action</span></li>
<li><strong class="source-inline">PASS_THROUGH</strong>: Do nothing and pass the <span class="No-Break">event on</span></li>
<li><strong class="source-inline">INTERFACE</strong>: Handled but not executed (<span class="No-Break">pop-up menus)</span></li>
</ul>
<p>We have already dealt with <strong class="source-inline">'RUNNING_MODAL'</strong>, <strong class="source-inline">'CANCELLED'</strong>, and <strong class="source-inline">'FINISHED'</strong>, while <strong class="source-inline">'PASS_THROUGH'</strong> is useful to pass an event to the rest of an application, even if our script was listening to it. <strong class="source-inline">'INTERFACE'</strong> is used in pop-up menus, but usually, we don’t need that for <span class="No-Break">our scripts.</span></p>
<p class="callout-heading">Status is not everything!</p>
<p class="callout">It’s important to know that returning a status ratifies what was done in a method, but it doesn’t <span class="No-Break">perform anything.</span></p>
<p class="callout">For instance, returning <strong class="source-inline">'CANCELLED'</strong> alone doesn’t undo what was done in a method; we should undo all the changes programmatically – for example, remove the objects that our method might have created, and then <span class="No-Break">return </span><span class="No-Break"><strong class="source-inline">'CANCELLED'</strong></span><span class="No-Break">.</span></p>
<p>Now that the <a id="_idIndexMarker683"/>application handler will look for a <strong class="source-inline">modal</strong> method and run it, we can proceed with writing one for <span class="No-Break">our operator.</span></p>
<h2 id="_idParaDest-246"><a id="_idTextAnchor258"/>Writing the modal method</h2>
<p>Once an <a id="_idIndexMarker684"/>operator is added to the handlers, the window manager will run its <strong class="source-inline">modal</strong> method at every event of the user interface. As with <strong class="source-inline">invoke</strong>, besides <strong class="source-inline">self</strong> and <strong class="source-inline">context</strong>, this method takes a third argument – <span class="No-Break"><strong class="source-inline">event</strong></span><span class="No-Break">.</span></p>
<p>The <strong class="source-inline">event</strong> argument contains information about what triggered any execution of <strong class="source-inline">modal</strong>. It can be a movement of a mouse or the press of <span class="No-Break">a key.</span></p>
<p>The most relevant information is <strong class="source-inline">type</strong>, a string whose keywords are documented <span class="No-Break">at </span><a href="https://docs.blender.org/api/3.3/bpy_types_enum_items/event_type_items.xhtml"><span class="No-Break">https://docs.blender.org/api/3.3/bpy_types_enum_items/event_type_items.xhtml</span></a><span class="No-Break">.</span></p>
<p>Looking at <strong class="source-inline">event.type</strong>, we can find out what triggered the update, such as <span class="No-Break">the following:</span></p>
<pre class="source-code">
    event.type == "MOUSEMOVE"</pre>
<p>This means that the user did just move <span class="No-Break">the mouse.</span></p>
<p>If the event was caused by the keyboard, <strong class="source-inline">event.type</strong> would be a letter, such as <strong class="source-inline">"A"</strong>, or a description of the key, such as <strong class="source-inline">"LEFT_CTRL"</strong>. The event type associated with numeric keys is the uppercase letters for that number – for <span class="No-Break">example, </span><span class="No-Break"><strong class="source-inline">"THREE"</strong></span><span class="No-Break">.</span></p>
<p>In this example, moving the mouse toward the right increases the current time, and moving it to the left <span class="No-Break">decreases it.</span></p>
<p>Like with real clocks, we can set either the hours or minutes – we add a Boolean property to distinguish between the two. The properties section becomes <span class="No-Break">the following:</span></p>
<pre class="source-code">
    hour: bpy.props.IntProperty(default=0, min=0, max=23)
    mins: bpy.props.IntProperty(default=0, min=0, max=59)
    <strong class="source-inline">set_hours</strong>: bpy.props.<strong class="source-inline">BoolProperty</strong>(default=True)</pre>
<p>Now, we can finally <span class="No-Break">write </span><span class="No-Break"><strong class="source-inline">PunchClock.modal</strong></span><span class="No-Break">.</span></p>
<p>Moving the mouse updates the attributes associated with the cursor. For instance, the cursor position on the horizontal axis is stored as <strong class="source-inline">mouse_x</strong>, while the previous position is still <a id="_idIndexMarker685"/>available as <strong class="source-inline">mouse_prev_x.</strong> The difference between the two gives the <span class="No-Break">movement direction.</span></p>
<p>We store that number as <strong class="source-inline">delta</strong> and divide it to slow the transition. A factor of 10 makes it slow enough for <span class="No-Break">our purpose:</span></p>
<pre class="source-code">
    def modal(self, context, event):
        if event.type == 'MOUSEMOVE':
            delta = event.mouse_x - event.mouse_prev_x
            delta /= 10</pre>
<p><strong class="source-inline">delta</strong> is a float number, and as such, it cannot be summed with hour and mins, which are integers. For that reason, we round it to an <span class="No-Break">integer value:</span></p>
<pre class="source-code">
            delta = <strong class="source-inline">round(delta)</strong></pre>
<p>We use <strong class="source-inline">round</strong> rather than <strong class="source-inline">int</strong> for this conversion. Since <strong class="source-inline">int</strong> approximates to the least or equal integer value, it would make the progress from one value to the next <span class="No-Break">less smooth.</span></p>
<p>The value of <strong class="source-inline">set_hours</strong> decides whether <strong class="source-inline">delta</strong> is added to the hours or <span class="No-Break">the minutes:</span></p>
<pre class="source-code">
            if self.set_hours:
                self.hour += delta
            else:
                self.mins += delta
            txt = f"{self.hour:02}:{self.mins:02}"
            self.txt_crv.body = txt</pre>
<p>To change <strong class="source-inline">set_hours</strong>, we resort to a key press. We make the user switch between hours and minutes by pressing the <span class="No-Break"><em class="italic">Tab</em></span><span class="No-Break"> key.</span></p>
<p>To get that key press, we ensure that <strong class="source-inline">event.type</strong> is <strong class="source-inline">'TAB'</strong> and <strong class="source-inline">event.value</strong> <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">'PRESS'</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
        if event.type == <strong class="source-inline">'TAB'</strong> and event.<strong class="source-inline">value == 'PRESS'</strong>:
            self.set_hours = <strong class="source-inline">not</strong> self.set_hours</pre>
<p>Boolean <a id="_idIndexMarker686"/>variables can only be <strong class="source-inline">True</strong> or <strong class="source-inline">False</strong>, which are each other’s negation. So, we have converted <strong class="source-inline">set_hours</strong> to its opposite by just <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">not</strong></span><span class="No-Break">.</span></p>
<p class="callout-heading">Type is not enough!</p>
<p class="callout">A key that is pressed will also be released, and this action will generate another event, whose value is <strong class="source-inline">'RELEASE'</strong>. Checking only <strong class="source-inline">event.type</strong> without checking <strong class="source-inline">event.value</strong> puts our code at the risk of responding to <span class="No-Break">keystrokes twice.</span></p>
<p>Lastly, when a user is happy with the displayed time, they can press <em class="italic">Return</em> and exit. Pressing <em class="italic">Return</em> triggers an event of type <strong class="source-inline">'RET'</strong>. We don’t need to bother with <strong class="source-inline">event.value</strong> for exit events. Once we return <strong class="source-inline">{'FINISHED'}</strong>, the operator stops, so there are no risks of <span class="No-Break">duplicate execution:</span></p>
<pre class="source-code">
         elif event.type == <strong class="source-inline">'RET'</strong>:
            return {'FINISHED'}</pre>
<p>However, what if the user has second thoughts and wants to exit the tool without doing anything? We can allow the operation to be aborted at the press <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">'ESC'</strong></span><span class="No-Break">.</span></p>
<p>To do that, the operator must clean after itself by deleting the text created in <strong class="source-inline">invoke</strong>, and then return <strong class="source-inline">{'CANCELLED'}</strong> to avoid being added to the <span class="No-Break">undo queue:</span></p>
<pre class="source-code">
        elif event.type == <strong class="source-inline">'ESC'</strong>:
            bpy.data.objects.<strong class="source-inline">remove(self.txt_obj)</strong>
            <strong class="source-inline">return {'CANCELLED'}</strong></pre>
<p>That was the last event covered by our operator. We ignore any other event and, by default, return <strong class="source-inline">{'RUNNING_MODAL'}</strong> as status to <span class="No-Break">keep listening.</span></p>
<p>So, the last line of <strong class="source-inline">modal</strong> is usually<a id="_idTextAnchor259"/> <span class="No-Break">as follows:</span></p>
<pre class="source-code">
        return {'RUNNING_MODAL'}</pre>
<p>Calling <strong class="bold">Reload Scripts</strong>, and then <strong class="bold">Add</strong> | <strong class="bold">Create Hour/Minutes Text</strong>, creates a text of the current hour <a id="_idIndexMarker687"/>and starts listening to mouse/keyboard events. Moving the mouse left and right increases/decreases the current value, pressing <em class="italic">Tab</em> switches between hours and minutes, and pressing <em class="italic">Return</em> or <em class="italic">Esc</em> ends <span class="No-Break">the operator.</span></p>
<p>Since all the action now takes place between <strong class="source-inline">invoke</strong> and <strong class="source-inline">modal</strong>, we could remove <strong class="source-inline">execute</strong>, but since <strong class="source-inline">bl_options</strong> is set to <strong class="source-inline">{'REGISTER', 'UNDO'}</strong>, Blender displays the operator properties. When a property is changed, the <strong class="source-inline">execute</strong> method <span class="No-Break">is run.</span></p>
<p>We can see that after <em class="italic">Return</em> is pressed, <strong class="bold">hour</strong>, <strong class="bold">min</strong>, and <strong class="bold">set_hours</strong> can be changed in the <span class="No-Break">operator panel.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer181">
<img alt="Figure 10.5: Operator properties after modal has exited" height="876" src="image/Figure_10.05_B18375.jpg" width="1456"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.5: Operator properties after modal has exited</p>
<p>That panel can be customized – operators have a <strong class="source-inline">draw</strong> method that works in the same way as <strong class="source-inline">Panel.draw</strong>, which we learned about in <a href="B18375_05.xhtml#_idTextAnchor100"><span class="No-Break"><em class="italic">Chapter 5</em></span></a><span class="No-Break">.</span></p>
<p>So, rather than displaying hours and minutes in a column, we could show them in a time format in the <a id="_idIndexMarker688"/>operator panel. In the next section, we will implement the <strong class="source-inline">draw</strong> method and change the <strong class="bold">Create Hour/Minutes </strong><span class="No-Break"><strong class="bold">Text</strong></span><span class="No-Break"> panel.</span></p>
<h1 id="_idParaDest-247"><a id="_idTextAnchor260"/>Styling the operator panel</h1>
<p>We know that the <a id="_idIndexMarker689"/>operator panel is displayed in <span class="No-Break">these circumstances:</span></p>
<ul>
<li>When <strong class="source-inline">context.window_manager.invoke_props_dialog</strong> is <span class="No-Break">called explicitly.</span></li>
<li>When <strong class="source-inline">bl_options</strong> is set to <strong class="source-inline">{'REGISTER', 'UNDO'}</strong> and the operator <span class="No-Break">has finished.</span></li>
<li>When <strong class="bold">Edit</strong> | <strong class="bold">Adjust Last Operation</strong> is called. This circumstance too requires the presence of <strong class="source-inline">bl_options = {'</strong><span class="No-Break"><strong class="source-inline">REGISTER', 'UNDO'}</strong></span><span class="No-Break">.</span></li>
</ul>
<p>By default, all properties are displayed in a column layout. Most property types can be declared with a <strong class="source-inline">hidden=True</strong> flag, but that’s not the case for <strong class="source-inline">BoolProperty</strong>, so we cannot do it <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">set_hours</strong></span><span class="No-Break">.</span></p>
<p>As a workaround, we could change <strong class="source-inline">set_hours</strong> to <strong class="source-inline">IntProperty</strong>, with a <strong class="source-inline">0</strong> to <strong class="source-inline">1</strong> range and <strong class="source-inline">hidden</strong> set to <strong class="source-inline">True</strong>, but by implementing the <strong class="source-inline">draw</strong> method for our operator, we can just omit the properties that we don’t want <span class="No-Break">to display.</span></p>
<h2 id="_idParaDest-248"><a id="_idTextAnchor261"/>Writing the draw method</h2>
<p>We want to <a id="_idIndexMarker690"/>change two things in the <strong class="bold">Create Hour/Minutes </strong><span class="No-Break"><strong class="bold">Text</strong></span><span class="No-Break"> panel:</span></p>
<ul>
<li>The hour and minutes <a id="_idIndexMarker691"/>should be in the <span class="No-Break">same row</span></li>
<li>The <strong class="source-inline">set_hours</strong> internal variable should not <span class="No-Break">be displayed</span></li>
</ul>
<p>Adding a <strong class="source-inline">draw</strong> method to an operator changes its layout. The method arguments are <strong class="source-inline">self</strong> and <strong class="source-inline">context</strong>, but we will only use the first. To display our properties on the same line, we will do <span class="No-Break">the following:</span></p>
<ol>
<li>Create a row to display hours <span class="No-Break">and minutes.</span></li>
<li>Enable <strong class="source-inline">align</strong> for the <span class="No-Break">new </span><span class="No-Break"><strong class="source-inline">row</strong></span><span class="No-Break">.</span></li>
<li>Set the alignment <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">'CENTER'</strong></span><span class="No-Break">:</span></li>
</ol>
<pre class="source-code">
    def draw(self, context):
        layout = self.layout
        row = layout.row(<strong class="source-inline">align=True</strong>)
        row.alignment = 'CENTER'</pre>
<ol>
<li value="4">Use <strong class="source-inline">row.prop</strong> to <a id="_idIndexMarker692"/>display <strong class="source-inline">self.hour</strong>, <strong class="source-inline">row.label</strong> to display a semicolon, and <strong class="source-inline">row.prop</strong> again <a id="_idIndexMarker693"/>to <span class="No-Break">display </span><span class="No-Break"><strong class="source-inline">self.mins</strong></span><span class="No-Break">:</span></li>
</ol>
<pre class="source-code">
        row.prop(self, 'hour', text=<strong class="source-inline">""</strong>)
        row.label(<strong class="source-inline">text=' :'</strong>,)
        row.prop(self, 'mins', text=<strong class="source-inline">""</strong>)</pre>
<p>We have set the text of <strong class="source-inline">hour</strong> and <strong class="source-inline">mins</strong> to <strong class="source-inline">""</strong> because no explanation is required. As intended, no checkbox is displayed for <strong class="source-inline">set_hours</strong>, since it’s not mentioned <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">draw</strong></span><span class="No-Break">.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer182">
<img alt="Figure 10.6: The custom hour/minutes operator panel" height="876" src="image/Figure_10.06_B18375.jpg" width="1454"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.6: The custom hour/minutes operator panel</p>
<p>We could add more features, <a id="_idIndexMarker694"/>such as numeric input to <a id="_idIndexMarker695"/>set the hours, but since we have implemented all the operator methods, we can consider <span class="No-Break"><strong class="bold">PunchClock</strong></span><span class="No-Break"> finished.</span></p>
<p>Although we will discuss other operators in the rest of the book, this is the last chapter that covers them specifically, as we have learned how to customize every step of <span class="No-Break">their execution.</span></p>
<h1 id="_idParaDest-249"><a id="_idTextAnchor262"/>Summary</h1>
<p>We have gained a deep understanding of how operators are integrated in different parts of Blender and how we can manipulate their appearance and behavior. We have also learned how they can capture input and how they interact with the application event handler <span class="No-Break">and interface.</span></p>
<p>This chapter marks the end of the second part of this book. The next chapter, <em class="italic">Object Modifiers</em>, is the start of <em class="italic">Part 3</em>, which deals with how the data of a scene is processed into the <span class="No-Break">finished output.</span></p>
<h1 id="_idParaDest-250"><a id="_idTextAnchor263"/>Questions</h1>
<ol>
<li>Which operator method runs before the operator <span class="No-Break">is launched?</span></li>
<li>Can a user launch an operator if its <strong class="source-inline">poll</strong> method <span class="No-Break">returns </span><span class="No-Break"><strong class="source-inline">False</strong></span><span class="No-Break">?</span></li>
<li>Can we set a default value on our operator parameters in <span class="No-Break">a function?</span></li>
<li>The <strong class="source-inline">modal</strong> method can only return the <strong class="source-inline">'RUNNING_MODAL'</strong> status – true <span class="No-Break">or false?</span></li>
<li>Does returning <strong class="source-inline">'CANCELLED'</strong> undo everything we did in <span class="No-Break">a method?</span></li>
<li>Can we override the operator context of a menu or a <span class="No-Break">panel layout?</span></li>
<li>Can we change the layout of an <span class="No-Break">operator panel?</span></li>
</ol>
</div>
</div>

<div id="sbo-rt-content"><div class="Content" id="_idContainer184">
<h1 id="_idParaDest-251"><a id="_idTextAnchor264"/>Part 3: Delivering Output</h1>
<p>This part is centered on the final stages of the 3D pipeline: generating and deforming geometries and setting up the rendering and shading system. Automation of simple rigs and the construction of shader node trees are explored. </p>
<p>This section comprises the <span class="No-Break">following chapters:</span></p>
<ul>
<li><a href="B18375_11.xhtml#_idTextAnchor265"><em class="italic">Chapter 11</em></a>, <em class="italic">Object Modifiers</em></li>
<li><a href="B18375_12.xhtml#_idTextAnchor304"><em class="italic">Chapter 12</em></a>, <em class="italic">Rendering and Shaders</em></li>
</ul>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer185">
</div>
</div>
<div>
<div id="_idContainer186">
</div>
</div>
</div></body></html>