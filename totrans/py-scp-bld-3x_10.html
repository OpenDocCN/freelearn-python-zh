<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-235"><a id="_idTextAnchor247"/>10</h1>
<h1 id="_idParaDest-236"><a id="_idTextAnchor248"/>Advanced and Modal Operators</h1>
<p>Since <a href="B18375_03.xhtml#_idTextAnchor049"><em class="italic">Chapter 3</em></a>, we have resorted to operators to implement our features in Blender.</p>
<p>Operators have already proved to be incredibly flexible, with custom properties and looks. They can be even more powerful once we learn how to override all their methods.</p>
<p>The operators encountered in the previous chapters run as soon as they are launched and finish immediately. If we need to, we can make the execution modal and let the operator listen to input events.</p>
<p>In this chapter, you will learn how to control the execution of an operator, and how you can write fully interactive operators.</p>
<p>This chapter will cover the following topics:</p>
<ul>
<li>Understanding the operator flow</li>
<li>Setting properties programmatically</li>
<li>Writing modal operators</li>
</ul>
<h1 id="_idParaDest-237"><a id="_idTextAnchor249"/>Technical requirements</h1>
<p>We will use Blender and Visual Studio Code in this chapter, but any other programmer text editor can be used. The examples created in this chapter can be found at <a href="https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch10">https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch10</a>.</p>
<h1 id="_idParaDest-238"><a id="_idTextAnchor250"/>Understanding the operator flow</h1>
<p>We dealt with operators since <a href="B18375_03.xhtml#_idTextAnchor049"><em class="italic">Chapter 3</em></a>, and we learned how their <code>poll</code> method <a id="_idIndexMarker662"/>checks whether the operator can be executed, while <code>execute</code> performs the operation and exits.</p>
<p>Then in <a href="B18375_04.xhtml#_idTextAnchor075"><em class="italic">Chapter 4</em></a>, we added editable parameters to the <em class="italic">Elevator</em> operator, thanks to the <code>'REGISTER'</code> and <code>'</code><code>UNDO'</code> options.</p>
<p>We also learned about the clever trick to change a result in real time when a user changes a parameter – Blender secretly undoes the last operation and performs it again with the new options, hence the need for <code>'UNDO'</code>.</p>
<p>That became more evident in <a href="B18375_07.xhtml#_idTextAnchor171"><em class="italic">Chapter 7</em></a>, when we learned how using <strong class="bold">Edit</strong> | <strong class="bold">Adjust Last Operation</strong> from the menu bar changes the result of the last operation.</p>
<p>While those solutions <a id="_idIndexMarker663"/>allow us to get input parameters with ease, they don’t give access to the actual input events, such as the pressure of a key or the movement of a mouse.</p>
<p>That would require a <code>execute</code> method instantly, so it couldn’t possibly wait for inputs; therefore, the events must be handled by another method.</p>
<p>Another thing we cannot do in <code>execute</code> is set the operator’s editable parameters. Since Blender runs <code>execute</code> again when a parameter is changed, the user would find themselves unable to set a property, as it would be overridden immediately.</p>
<p>Capturing events and initializing operator parameters are two tasks that cannot be performed by <code>execute</code>. Luckily, <code>execute</code> is not the only method involved when an operator is launched; we will see that an operator’s lifetime encompasses a set of methods, each of them with a specific purpose.</p>
<h2 id="_idParaDest-239"><a id="_idTextAnchor251"/>Steps of execution</h2>
<p>We know from <a href="B18375_03.xhtml#_idTextAnchor049"><em class="italic">Chapter 3</em></a>, that the operator <code>poll</code> and <code>execute</code> methods are <a id="_idIndexMarker664"/>required, respectively, for validation and execution. In <a href="B18375_05.xhtml#_idTextAnchor100"><em class="italic">Chapter 5</em></a>, we used <code>invoke</code> to make sure that the operator properties are displayed before it runs.</p>
<p>Now, we will take a closer look at how operators are displayed and run:</p>
<ol>
<li>Blender checks the return value of <code>poll</code>. If the result is <code>False</code>, the operator is grayed out; otherwise, the operator can be launched.</li>
<li>The operator is launched, and it runs the <code>invoke</code> method. This method is optional; if we don’t write it, its step is skipped, and Blender runs <code>execute</code> directly.</li>
</ol>
<p>One common use of <code>invoke</code> is the initialization of the operator’s variables or internal value; unlike conventional Python classes, operators don’t implement the traditional <code>__init__</code> method.</p>
<p>Like <code>execute</code>, <code>invoke</code> must return an exit status, which can be <code>'FINISHED'</code>, <code>'CANCELLED'</code>, or <code>'RUNNING_MODAL'</code>.</p>
<ol>
<li value="3">If our operator is <a id="_idIndexMarker665"/>meant to listen for mouse and keyboard <a id="_idIndexMarker666"/>events, in <code>invoke</code>, we add it to the application <code>'RUNNING_MODAL'</code>.</li>
<li>If the operator is part of the handlers, its <code>modal</code> method is executed at every trigger event (when a mouse cursor moves, a key is pressed, etc.), until the modal returns <code>'CANCELLED'</code> or <code>'FINISHED'</code>. Otherwise, to continue listening, it should return <code>'RUNNING_MODAL'</code>.</li>
<li>If <code>bl_options</code> is <code>{'REGISTER','UNDO'}</code>, the operator properties are displayed in a panel at the bottom left of the screen. The panel relies on the operator’s <code>draw</code> method.</li>
<li>By default, all the operator properties that are not flagged with <code>hidden</code> upon declaration are displayed in the panel. Reimplementing this method allows us to implement a custom design using the techniques learned in <a href="B18375_05.xhtml#_idTextAnchor100"><em class="italic">Chapter 5</em></a>.</li>
<li>Changing a value in the operator panel runs <code>execute</code> again, with updated properties.</li>
</ol>
<p>The execution flow is summed up in <em class="italic">Figure 10</em><em class="italic">.1</em>, which helps us understand how the methods in the execution flow add up when an operator is launched.</p>
<div><div><img alt="Figure 10.1: The operator methods from the start to the end of the evaluation" height="1134" src="img/Figure_10.01_B18375.jpg" width="587"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.1: The operator methods from the start to the end of the evaluation</p>
<p>While <code>poll</code> is run by the <a id="_idIndexMarker667"/>interface every time that the operator is displayed, <code>invoke</code> is the first step of an operator flow, so we can use it to set the operator’s parameters programmatically and, from there, move to <code>execute</code> or <code>modal</code>. In the next section, we will use <code>invoke</code> to initialize the operator parameters according <a id="_idIndexMarker668"/>to the time of the day.</p>
<h1 id="_idParaDest-240"><a id="_idTextAnchor252"/>Writing the “PunchClock” add-on</h1>
<p>Some tools can require the current date and time from the operating system clock. In Python, we can <a id="_idIndexMarker669"/>use the <code>datetime</code> module to get them in our scripts, generally for versioning or logging purposes. There are no Blender properties designed specifically for time units, but an hour and a minute can be stored as two separate integer properties of an operator.</p>
<p>We know how to use the <code>default</code> argument to declare the initial value of a property, but what if that value is not always the same? For example, the current hour and minute change during the day, but <code>default</code> only sets static values.</p>
<p>But since <code>invoke</code> is executed before all the other methods, we can set our default values programmatically in there.</p>
<p>To demonstrate that, we will create an add-on to create a time format text in the current scene. By default, the text displays the current time of the day, but the user can change that.</p>
<h2 id="_idParaDest-241"><a id="_idTextAnchor253"/>Creating the add-on script</h2>
<p>Let’s create the <code>ch10</code> folder <a id="_idIndexMarker670"/>in our Python project, and then in <strong class="bold">Blender Preferences</strong>, we set it as the <strong class="bold">Scripts</strong> folder and restart Blender:</p>
<ol>
<li>Select <code>PythonScriptingBlender/ch10/addons</code> in your file browser or programmer editor – for instance, <strong class="bold">VS Code</strong>.</li>
<li>Create a new file by clicking on the <strong class="bold">New </strong><strong class="bold">File</strong> icon.</li>
<li>Name the new file <code>punch_clock.py</code>.</li>
<li>Open the file for editing.</li>
<li>Set the <code>PythonScriptingBlender/ch10</code> in the Blender <strong class="bold">File Paths</strong> preferences and restart Blender.</li>
</ol>
<p>We store the add-on information in the <code>bl_info</code> dictionary, as usual:</p>
<pre class="source-code">
bl_info = {
    "name": "Text PunchClock",
    "author": "Packt Man",
    "version": (1, 0),
    "blender": (3, 00, 0),
    "description": "Create an Hour/Minutes text object",
    "category": "Learning",
}</pre>
<p>This add-on contains an operator, which will be available in the <strong class="bold">Add</strong> menu of the 3D Viewport.</p>
<p>We start with an <a id="_idIndexMarker671"/>operator that creates a text in the <em class="italic">HH:MM</em> format, like digital clocks, where <em class="italic">HH</em> stands for a 2-digit hour number and <em class="italic">MM</em> for the minutes.</p>
<p>Hours and minutes are stored as <code>IntProperty</code>, ranging between <code>0</code> and <code>23</code> for the hours and <code>0</code> and <code>59</code> for the minutes. The operator’s code starts as follows:</p>
<pre class="source-code">
import bpy
class PunchClock(bpy.types.Operator):
    """Create Hour/Minutes text"""
    bl_idname = "text.punch_clock"
    bl_label = "Create Hour/Minutes Text"
    bl_description = "Create Hour Minutes Text"
    bl_options = {'REGISTER', 'UNDO'}
    <code>hour</code>: bpy.props.<code>IntProperty</code>(default=0, min=0, <code>max=23</code>)
    <code>mins</code>: bpy.props.<code>IntProperty</code>(default=0, min=0, <code>max=59</code>)</pre>
<p>We can add a new object if Blender is in <code>poll</code> is as follows:</p>
<pre class="source-code">
    @classmethod
    def poll(cls, context):
        return context.mode == 'OBJECT'</pre>
<p>In <code>execute</code>, we create new <a id="_idIndexMarker672"/>text data and set it to <code>{hour}:{min}</code>. The Blender type for text is named <code>FONT</code>, and its displayed text is stored in the <code>body</code> attribute.</p>
<p>We use <code>:02</code> after a variable specifies that we want to display a 2-digit number – for instance, <code>f"{3:02}"</code> becomes <code>"03"</code>:</p>
<pre class="source-code">
    def execute(self, context):
        <code>txt_crv</code> = bpy.data.curves.new(type=<code>"FONT"</code>,
                                      name="TXT-clock")
        <code>txt_crv.body</code> = f"<code>{self.hour:02}:{self.mins:02}</code>"</pre>
<p>We create an object to link it to the current collection and see the text in the scene:</p>
<pre class="source-code">
        txt_obj = bpy.data.<code>objects.new</code>(name="Font Object",
                                       <code>object_data=txt_crv</code>)</pre>
<p>After that, we return <code>FINISHED</code> as execution state:</p>
<pre class="source-code">
        context.<code>collection.objects.link(txt_obj)</code>
        return {'FINISHED'}</pre>
<p>The first draft of our operator is ready, and now we create a <code>menu</code> function to add to the interface. We can use <code>time</code> in the search field, we end up with three relevant icons – <code>TIME</code>, <code>MOD_TIME</code>, and <code>SORTTIME</code>. Any of those will do; we will pick <code>TIME</code> in this example.</p>
<div><div><img alt="Figure 10.2: The time-related default icons in Icon Viewer" height="217" src="img/Figure_10.02_B18375.jpg" width="381"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.2: The time-related default icons in Icon Viewer</p>
<p>We start <code>menu_func</code> with a <code>separator</code> to set our operator apart, and then we add our entry for <code>PunchClock</code> via <code>Layout.operator</code>:</p>
<pre class="source-code">
def menu_func(self, context):
    self.layout.separator()
    self.layout.operator(PunchClock.<code>bl_idname</code>, icon='TIME')</pre>
<p>Finally, we add and <a id="_idIndexMarker673"/>remove our operator and menu item in the <code>register</code> and <code>unregister</code> functions:</p>
<pre class="source-code">
def register():
    bpy.utils.register_class(PunchClock)
    bpy.types.VIEW3D_MT_add.append(menu_func)
def unregister():
    bpy.types.VIEW3D_MT_add.remove(menu_func)
    bpy.utils.unregister_class(PunchClock)</pre>
<p>If we restart Blender or refresh the <strong class="bold">Add-ons</strong> list, we should be able to see the <strong class="bold">PunchClock</strong> add-on.</p>
<div><div><img alt="Figure 10.3: PunchClock, as displayed in the Add-ons list" height="233" src="img/Figure_10.03_B18375.jpg" width="694"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.3: PunchClock, as displayed in the Add-ons list</p>
<p>At this stage, selecting <strong class="bold">Add</strong> | <strong class="bold">Create Hour/Minutes Text</strong> in the 3D Viewport top menu would add a text object displaying the time <em class="italic">00:00</em>.</p>
<p>We can get the <a id="_idIndexMarker674"/>current time from <code>datetime</code> and convert it to text, but we can do something even better – by setting <code>self.hour</code> and <code>self.mins</code> inside <code>invoke</code>, we will achieve the same result but also allow a user to change the displayed time.</p>
<h2 id="_idParaDest-242"><a id="_idTextAnchor254"/>Using invoke to initialize properties</h2>
<p>To get the <a id="_idIndexMarker675"/>current time, we import <code>datetime</code> at the beginning of the script. The <code>import</code> section becomes the following:</p>
<pre class="source-code">
import bpy
import <code>datetime</code></pre>
<p>Then, inside the operator class, we implement the <code>invoke</code> method. It can come right after <code>poll</code>, but any place under the <code>PunchClock</code> class will do:</p>
<pre class="source-code">
    @classmethod
    def poll(cls, context):
        return context.mode == 'OBJECT'
    def <code>invoke</code>(self, context, event):
        <code>now = datetime.datetime.now()</code>
        self.<code>hour = now.hour</code>
        self.<code>mins = now.minute</code>
        <code>return self.execute(context)</code></pre>
<p>Now, the hour and minute of the operator are set up in <code>invoke</code>, and then <code>execute</code> is called to carry on the operation.</p>
<p>Finishing <a id="_idIndexMarker676"/>with <code>execute</code> is important, as that’s what Blender expects when updating its operations chronology.</p>
<p>Launching <strong class="bold">Create Hour/Minutes Text</strong> now displays the current time in a new text object and allows us to change the hour and minute using the operator panel.</p>
<div><div><img alt="Figure 10.4: Adding editable hour and minute fields, set to the current time" height="950" src="img/Figure_10.04_B18375.jpg" width="1377"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.4: Adding editable hour and minute fields, set to the current time</p>
<p>By using <code>invoke</code>, we have set our default values programmatically. That’s a common request in productions, since the desired defaults can change across projects, tasks, and departments.</p>
<p>We have added our operator to the <code>execute</code> method directly.</p>
<p>To prevent the <a id="_idIndexMarker677"/>menu from skipping <code>invoke</code>, we need to override the layout’s context in our menu function.</p>
<h2 id="_idParaDest-243"><a id="_idTextAnchor255"/>Ensuring default invoke in pop-up menus</h2>
<p>Layout elements <a id="_idIndexMarker678"/>can pass a custom context and force a design choice on operators. For example, buttons displayed outside the viewport avoid displaying operator properties, and pop-up menus bypass the <code>invoke</code> method.</p>
<p>We have encountered this behavior in the <em class="italic">Displaying buttons</em> section of <a href="B18375_05.xhtml#_idTextAnchor100"><em class="italic">Chapter 5</em></a>, and in the <em class="italic">Writing the Action to Range add-on</em> section in <a href="B18375_07.xhtml#_idTextAnchor171"><em class="italic">Chapter 7</em></a>.</p>
<p>We worked around those issues, respectively, by calling a properties dialog in <code>invoke</code>, or by using <code>invoke</code> to run even when the operator is launched from the <code>invoke</code>.</p>
<p>Therefore, we will change the layout’s <code>operator_context</code> to <code>"INVOKE_DEFAULT"</code>. We only need that for <code>PunchClock</code>, so, to minimize any potential impact on other menu entries, we add a new row and change only its <code>operator_context</code>.</p>
<p>Our menu function becomes the following:</p>
<pre class="source-code">
def menu_func(self, context):
    self.layout.separator()
    <code>row</code> = self.layout.row()
    <code>row.operator_context = "INVOKE_DEFAULT"</code>
    row.operator(PunchClock.bl_idname, icon='TIME')</pre>
<p>By executing <code>PunchClock</code> with its default context, we make sure that <code>invoke</code> is never skipped.</p>
<p>Now, the operator will always display its properties and let a user change them, but we can also implement a way to change the displayed time by just moving the mouse.</p>
<p>In the next section, we <a id="_idIndexMarker679"/>will add operator response to mouse and keyboard input, making our operator a modal application handler.</p>
<h1 id="_idParaDest-244"><a id="_idTextAnchor256"/>Adding modal behavior</h1>
<p>In user interfaces, the <a id="_idIndexMarker680"/>term <strong class="bold">modal</strong> designates a sub-window or widget that takes all the user interaction for itself, until the operation is ended explicitly.</p>
<p>Usually, operators are designed to return to the main application immediately. If we don’t want that, they should be added to the window manager’s modal handlers.</p>
<p>The operator is then considered modal and will listen to the user inputs until it’s closed manually.</p>
<p>We can make <code>PunchClock</code> modal and use mouse movement to set our clock. Modal operators have two requirements:</p>
<ul>
<li><code>invoke</code> adds the operator to the handlers and returns <code>'RUNNING_MODAL'</code>.</li>
<li><code>modal</code> is implemented and returns <code>'RUNNING_MODAL'</code>. It returns <code>'FINISHED'</code> when a user ends it, or <code>'CANCELLED'</code> to exit with no changes.</li>
</ul>
<p>We will start to implement the modal execution by changing <code>invoke</code> and its return value.</p>
<h2 id="_idParaDest-245"><a id="_idTextAnchor257"/>Adding the operator to the modal handlers</h2>
<p>Instead of <a id="_idIndexMarker681"/>passing to <code>execute</code>, <code>invoke</code> now calls the <code>modal_handler_add</code> method of the current <code>window_manager</code>, and then it returns <code>{'RUNNING_MODAL'}</code>. The return status notifies that the operator is running in Blender and listens to events.</p>
<p>Since <code>modal</code> runs at every window update, we should keep it light and small. Adding objects to the scene is expensive, so we create and link the text in <code>invoke</code>, and only edit its body in <code>modal</code>. The <code>invoke</code> method stores <code>txt_crv</code> and <code>txt_obj</code> as operator member attributes:</p>
<pre class="source-code">
    def invoke(self, context, event):
        now = datetime.datetime.now()
        self.hour = now.hour
        self.mins = now.minute
        self.txt_crv = bpy.data.curves.new(type="FONT",
                                           name="TXT-hhmm")
        self.txt_obj = bpy.data.objects.new(name="OB-Txt",
                                 object_data=self.txt_crv)
        context.collection.objects.link(self.txt_obj)
        context.window_manager.<code>modal_handler_add(self)</code>
        return {<code>'RUNNING_MODAL'</code>}</pre>
<p>The keywords that can be returned as status are listed in the API documentation (<a href="https://docs.blender.org/api/3.3/bpy_types_enum_items/operator_return_items.xhtml">https://docs.blender.org/api/3.3/bpy_types_enum_items/operator_return_items.xhtml</a>) and are as follows:</p>
<ul>
<li><code>RUNNING_MODAL</code>: Keeps the operator running with Blender</li>
<li><code>CANCELLED</code>: The operator exited without doing anything, so no undo entry should be pushed</li>
<li><code>FINISHED</code>: The operator <a id="_idIndexMarker682"/>exited after completing its action</li>
<li><code>PASS_THROUGH</code>: Do nothing and pass the event on</li>
<li><code>INTERFACE</code>: Handled but not executed (pop-up menus)</li>
</ul>
<p>We have already dealt with <code>'RUNNING_MODAL'</code>, <code>'CANCELLED'</code>, and <code>'FINISHED'</code>, while <code>'PASS_THROUGH'</code> is useful to pass an event to the rest of an application, even if our script was listening to it. <code>'INTERFACE'</code> is used in pop-up menus, but usually, we don’t need that for our scripts.</p>
<p class="callout-heading">Status is not everything!</p>
<p class="callout">It’s important to know that returning a status ratifies what was done in a method, but it doesn’t perform anything.</p>
<p class="callout">For instance, returning <code>'CANCELLED'</code> alone doesn’t undo what was done in a method; we should undo all the changes programmatically – for example, remove the objects that our method might have created, and then return <code>'CANCELLED'</code>.</p>
<p>Now that the <a id="_idIndexMarker683"/>application handler will look for a <code>modal</code> method and run it, we can proceed with writing one for our operator.</p>
<h2 id="_idParaDest-246"><a id="_idTextAnchor258"/>Writing the modal method</h2>
<p>Once an <a id="_idIndexMarker684"/>operator is added to the handlers, the window manager will run its <code>modal</code> method at every event of the user interface. As with <code>invoke</code>, besides <code>self</code> and <code>context</code>, this method takes a third argument – <code>event</code>.</p>
<p>The <code>event</code> argument contains information about what triggered any execution of <code>modal</code>. It can be a movement of a mouse or the press of a key.</p>
<p>The most relevant information is <code>type</code>, a string whose keywords are documented at <a href="https://docs.blender.org/api/3.3/bpy_types_enum_items/event_type_items.xhtml">https://docs.blender.org/api/3.3/bpy_types_enum_items/event_type_items.xhtml</a>.</p>
<p>Looking at <code>event.type</code>, we can find out what triggered the update, such as the following:</p>
<pre class="source-code">
    event.type == "MOUSEMOVE"</pre>
<p>This means that the user did just move the mouse.</p>
<p>If the event was caused by the keyboard, <code>event.type</code> would be a letter, such as <code>"A"</code>, or a description of the key, such as <code>"LEFT_CTRL"</code>. The event type associated with numeric keys is the uppercase letters for that number – for example, <code>"THREE"</code>.</p>
<p>In this example, moving the mouse toward the right increases the current time, and moving it to the left decreases it.</p>
<p>Like with real clocks, we can set either the hours or minutes – we add a Boolean property to distinguish between the two. The properties section becomes the following:</p>
<pre class="source-code">
    hour: bpy.props.IntProperty(default=0, min=0, max=23)
    mins: bpy.props.IntProperty(default=0, min=0, max=59)
    <code>set_hours</code>: bpy.props.<code>BoolProperty</code>(default=True)</pre>
<p>Now, we can finally write <code>PunchClock.modal</code>.</p>
<p>Moving the mouse updates the attributes associated with the cursor. For instance, the cursor position on the horizontal axis is stored as <code>mouse_x</code>, while the previous position is still <a id="_idIndexMarker685"/>available as <code>mouse_prev_x.</code> The difference between the two gives the movement direction.</p>
<p>We store that number as <code>delta</code> and divide it to slow the transition. A factor of 10 makes it slow enough for our purpose:</p>
<pre class="source-code">
    def modal(self, context, event):
        if event.type == 'MOUSEMOVE':
            delta = event.mouse_x - event.mouse_prev_x
            delta /= 10</pre>
<p><code>delta</code> is a float number, and as such, it cannot be summed with hour and mins, which are integers. For that reason, we round it to an integer value:</p>
<pre class="source-code">
            delta = <code>round(delta)</code></pre>
<p>We use <code>round</code> rather than <code>int</code> for this conversion. Since <code>int</code> approximates to the least or equal integer value, it would make the progress from one value to the next less smooth.</p>
<p>The value of <code>set_hours</code> decides whether <code>delta</code> is added to the hours or the minutes:</p>
<pre class="source-code">
            if self.set_hours:
                self.hour += delta
            else:
                self.mins += delta
            txt = f"{self.hour:02}:{self.mins:02}"
            self.txt_crv.body = txt</pre>
<p>To change <code>set_hours</code>, we resort to a key press. We make the user switch between hours and minutes by pressing the <em class="italic">Tab</em> key.</p>
<p>To get that key press, we ensure that <code>event.type</code> is <code>'TAB'</code> and <code>event.value</code> is <code>'PRESS'</code>:</p>
<pre class="source-code">
        if event.type == <code>'TAB'</code> and event.<code>value == 'PRESS'</code>:
            self.set_hours = <code>not</code> self.set_hours</pre>
<p>Boolean <a id="_idIndexMarker686"/>variables can only be <code>True</code> or <code>False</code>, which are each other’s negation. So, we have converted <code>set_hours</code> to its opposite by just using <code>not</code>.</p>
<p class="callout-heading">Type is not enough!</p>
<p class="callout">A key that is pressed will also be released, and this action will generate another event, whose value is <code>'RELEASE'</code>. Checking only <code>event.type</code> without checking <code>event.value</code> puts our code at the risk of responding to keystrokes twice.</p>
<p>Lastly, when a user is happy with the displayed time, they can press <em class="italic">Return</em> and exit. Pressing <em class="italic">Return</em> triggers an event of type <code>'RET'</code>. We don’t need to bother with <code>event.value</code> for exit events. Once we return <code>{'FINISHED'}</code>, the operator stops, so there are no risks of duplicate execution:</p>
<pre class="source-code">
         elif event.type == <code>'RET'</code>:
            return {'FINISHED'}</pre>
<p>However, what if the user has second thoughts and wants to exit the tool without doing anything? We can allow the operation to be aborted at the press of <code>'ESC'</code>.</p>
<p>To do that, the operator must clean after itself by deleting the text created in <code>invoke</code>, and then return <code>{'CANCELLED'}</code> to avoid being added to the undo queue:</p>
<pre class="source-code">
        elif event.type == <code>'ESC'</code>:
            bpy.data.objects.<code>remove(self.txt_obj)</code>
            <code>return {'CANCELLED'}</code></pre>
<p>That was the last event covered by our operator. We ignore any other event and, by default, return <code>{'RUNNING_MODAL'}</code> as status to keep listening.</p>
<p>So, the last line of <code>modal</code> is usually<a id="_idTextAnchor259"/> as follows:</p>
<pre class="source-code">
        return {'RUNNING_MODAL'}</pre>
<p>Calling <strong class="bold">Reload Scripts</strong>, and then <strong class="bold">Add</strong> | <strong class="bold">Create Hour/Minutes Text</strong>, creates a text of the current hour <a id="_idIndexMarker687"/>and starts listening to mouse/keyboard events. Moving the mouse left and right increases/decreases the current value, pressing <em class="italic">Tab</em> switches between hours and minutes, and pressing <em class="italic">Return</em> or <em class="italic">Esc</em> ends the operator.</p>
<p>Since all the action now takes place between <code>invoke</code> and <code>modal</code>, we could remove <code>execute</code>, but since <code>bl_options</code> is set to <code>{'REGISTER', 'UNDO'}</code>, Blender displays the operator properties. When a property is changed, the <code>execute</code> method is run.</p>
<p>We can see that after <em class="italic">Return</em> is pressed, <strong class="bold">hour</strong>, <strong class="bold">min</strong>, and <strong class="bold">set_hours</strong> can be changed in the operator panel.</p>
<div><div><img alt="Figure 10.5: Operator properties after modal has exited" height="876" src="img/Figure_10.05_B18375.jpg" width="1456"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.5: Operator properties after modal has exited</p>
<p>That panel can be customized – operators have a <code>draw</code> method that works in the same way as <code>Panel.draw</code>, which we learned about in <a href="B18375_05.xhtml#_idTextAnchor100"><em class="italic">Chapter 5</em></a>.</p>
<p>So, rather than displaying hours and minutes in a column, we could show them in a time format in the <a id="_idIndexMarker688"/>operator panel. In the next section, we will implement the <code>draw</code> method and change the <strong class="bold">Create Hour/Minutes </strong><strong class="bold">Text</strong> panel.</p>
<h1 id="_idParaDest-247"><a id="_idTextAnchor260"/>Styling the operator panel</h1>
<p>We know that the <a id="_idIndexMarker689"/>operator panel is displayed in these circumstances:</p>
<ul>
<li>When <code>context.window_manager.invoke_props_dialog</code> is called explicitly.</li>
<li>When <code>bl_options</code> is set to <code>{'REGISTER', 'UNDO'}</code> and the operator has finished.</li>
<li>When <code>bl_options = {'</code><code>REGISTER', 'UNDO'}</code>.</li>
</ul>
<p>By default, all properties are displayed in a column layout. Most property types can be declared with a <code>hidden=True</code> flag, but that’s not the case for <code>BoolProperty</code>, so we cannot do it with <code>set_hours</code>.</p>
<p>As a workaround, we could change <code>set_hours</code> to <code>IntProperty</code>, with a <code>0</code> to <code>1</code> range and <code>hidden</code> set to <code>True</code>, but by implementing the <code>draw</code> method for our operator, we can just omit the properties that we don’t want to display.</p>
<h2 id="_idParaDest-248"><a id="_idTextAnchor261"/>Writing the draw method</h2>
<p>We want to <a id="_idIndexMarker690"/>change two things in the <strong class="bold">Create Hour/Minutes </strong><strong class="bold">Text</strong> panel:</p>
<ul>
<li>The hour and minutes <a id="_idIndexMarker691"/>should be in the same row</li>
<li>The <code>set_hours</code> internal variable should not be displayed</li>
</ul>
<p>Adding a <code>draw</code> method to an operator changes its layout. The method arguments are <code>self</code> and <code>context</code>, but we will only use the first. To display our properties on the same line, we will do the following:</p>
<ol>
<li>Create a row to display hours and minutes.</li>
<li>Enable <code>align</code> for the new <code>row</code>.</li>
<li>Set the alignment to <code>'CENTER'</code>:</li>
</ol>
<pre class="source-code">
    def draw(self, context):
        layout = self.layout
        row = layout.row(<code>align=True</code>)
        row.alignment = 'CENTER'</pre>
<ol>
<li value="4">Use <code>row.prop</code> to <a id="_idIndexMarker692"/>display <code>self.hour</code>, <code>row.label</code> to display a semicolon, and <code>row.prop</code> again <a id="_idIndexMarker693"/>to display <code>self.mins</code>:</li>
</ol>
<pre class="source-code">
        row.prop(self, 'hour', text=<code>""</code>)
        row.label(<code>text=' :'</code>,)
        row.prop(self, 'mins', text=<code>""</code>)</pre>
<p>We have set the text of <code>hour</code> and <code>mins</code> to <code>""</code> because no explanation is required. As intended, no checkbox is displayed for <code>set_hours</code>, since it’s not mentioned in <code>draw</code>.</p>
<div><div><img alt="Figure 10.6: The custom hour/minutes operator panel" height="876" src="img/Figure_10.06_B18375.jpg" width="1454"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.6: The custom hour/minutes operator panel</p>
<p>We could add more features, <a id="_idIndexMarker694"/>such as numeric input to <a id="_idIndexMarker695"/>set the hours, but since we have implemented all the operator methods, we can consider <strong class="bold">PunchClock</strong> finished.</p>
<p>Although we will discuss other operators in the rest of the book, this is the last chapter that covers them specifically, as we have learned how to customize every step of their execution.</p>
<h1 id="_idParaDest-249"><a id="_idTextAnchor262"/>Summary</h1>
<p>We have gained a deep understanding of how operators are integrated in different parts of Blender and how we can manipulate their appearance and behavior. We have also learned how they can capture input and how they interact with the application event handler and interface.</p>
<p>This chapter marks the end of the second part of this book. The next chapter, <em class="italic">Object Modifiers</em>, is the start of <em class="italic">Part 3</em>, which deals with how the data of a scene is processed into the finished output.</p>
<h1 id="_idParaDest-250"><a id="_idTextAnchor263"/>Questions</h1>
<ol>
<li>Which operator method runs before the operator is launched?</li>
<li>Can a user launch an operator if its <code>poll</code> method returns <code>False</code>?</li>
<li>Can we set a default value on our operator parameters in a function?</li>
<li>The <code>modal</code> method can only return the <code>'RUNNING_MODAL'</code> status – true or false?</li>
<li>Does returning <code>'CANCELLED'</code> undo everything we did in a method?</li>
<li>Can we override the operator context of a menu or a panel layout?</li>
<li>Can we change the layout of an operator panel?</li>
</ol>
</div>
</div>

<div><div><h1 id="_idParaDest-251"><a id="_idTextAnchor264"/>Part 3: Delivering Output</h1>
<p>This part is centered on the final stages of the 3D pipeline: generating and deforming geometries and setting up the rendering and shading system. Automation of simple rigs and the construction of shader node trees are explored. </p>
<p>This section comprises the following chapters:</p>
<ul>
<li><a href="B18375_11.xhtml#_idTextAnchor265"><em class="italic">Chapter 11</em></a>, <em class="italic">Object Modifiers</em></li>
<li><a href="B18375_12.xhtml#_idTextAnchor304"><em class="italic">Chapter 12</em></a>, <em class="italic">Rendering and Shaders</em></li>
</ul>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
</div></body></html>