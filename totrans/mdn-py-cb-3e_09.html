<html><head></head><body>
<section data-number="0.12" id="chapter-9-functional-programming-features">
<h2 class="likechapterhead" data-number="0.12"><span><span class="kobospan" id="kobo.1.1">9</span></span><br class="tipbox1"/> <span id="x1-5020009"/><span class="kobospan" id="kobo.2.1">Functional Programming Features</span></h2>
<p class="normal"><span class="kobospan" id="kobo.3.1">The idea of </span><span class="cmbx-10x-x"><span class="kobospan" id="kobo.4.1">functional programming </span></span><span class="kobospan" id="kobo.5.1">is to focus on writing</span><span id="dx1-502001"/><span class="kobospan" id="kobo.6.1"> small, expressive functions that perform the required data transformations. </span><span class="kobospan" id="kobo.6.2">Combinations of functions can often create code that is more succinct and expressive than long strings of procedural statements or the methods of complex, stateful objects. </span><span class="kobospan" id="kobo.6.3">This chapter focuses on functional programming features of Python more than procedural or object-oriented programming.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.7.1">This provides an avenue for software design distinct from the strictly object-oriented approach used elsewhere in this book. </span><span class="kobospan" id="kobo.7.2">The combination of objects with functions permits flexibility in assembling an optimal collection of components.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.8.1">Conventional mathematics defines many things as functions. </span><span class="kobospan" id="kobo.8.2">Multiple functions can be combined to build up a complex result from previous transformations. </span><span class="kobospan" id="kobo.8.3">When we think of mathematical operators as functions, an expression like </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.9.1">p </span></span><span class="kobospan" id="kobo.10.1">= </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.11.1">f</span></span><span class="kobospan" id="kobo.12.1">(</span><span class="cmti-10x-x"><span class="kobospan" id="kobo.13.1">n,g</span></span><span class="kobospan" id="kobo.14.1">(</span><span class="cmti-10x-x"><span class="kobospan" id="kobo.15.1">n</span></span><span class="kobospan" id="kobo.16.1">)) can also be written as two separate functions. </span><span class="kobospan" id="kobo.16.2">We might think of this as </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.17.1">p </span></span><span class="kobospan" id="kobo.18.1">= </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.19.1">f</span></span><span class="kobospan" id="kobo.20.1">(</span><span class="cmti-10x-x"><span class="kobospan" id="kobo.21.1">n,b</span></span><span class="kobospan" id="kobo.22.1">), where </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.23.1">b </span></span><span class="kobospan" id="kobo.24.1">= </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.25.1">g</span></span><span class="kobospan" id="kobo.26.1">(</span><span class="cmti-10x-x"><span class="kobospan" id="kobo.27.1">n</span></span><span class="kobospan" id="kobo.28.1">).</span></p>
<p class="normal1"><span class="kobospan" id="kobo.29.1">Ideally, we can also create a composite function from these two functions:</span></p>
<div class="math-display">
<span class="kobospan" id="kobo.30.1"><img alt="p = f(n,g(n)) = g ∘f (n ) " class="calibre9" src="../media/file58.png"/></span>
</div>
<p class="normal1"><span class="kobospan" id="kobo.31.1">Defining a new composite function, </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.32.1">g </span></span><span><span class="kobospan" id="kobo.33.1">∘ </span></span><span class="cmti-10x-x"><span class="kobospan" id="kobo.34.1">f</span></span><span class="kobospan" id="kobo.35.1">, instead of nested functions can help to clarify the intent behind a design. </span><span class="kobospan" id="kobo.35.2">This re-framing of the components can allow us to take a number of small details and combine them into a larger chunk of knowledge that embodies the concept behind the design.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.36.1">Since programming often works with collections of data, we’ll often be applying a function to all the items of a collection. </span><span class="kobospan" id="kobo.36.2">This happens when doing database extraction and transformation to align data from diverse source applications. </span><span class="kobospan" id="kobo.36.3">It also happens when summarizing data. </span><span class="kobospan" id="kobo.36.4">Something as commonplace as transforming a CSV file into a statistical summary is a composition of transformation functions from rows of text to rows of data, and from rows of data to a mean and standard deviation. </span><span class="kobospan" id="kobo.36.5">This fits nicely</span><span id="dx1-502002"/><span class="kobospan" id="kobo.37.1"> with the mathematical</span><span id="dx1-502003"/><span class="kobospan" id="kobo.38.1"> idea of a </span><span class="cmbx-10x-x"><span class="kobospan" id="kobo.39.1">set builder </span></span><span class="kobospan" id="kobo.40.1">or </span><span class="cmbx-10x-x"><span class="kobospan" id="kobo.41.1">set comprehension</span></span><span class="kobospan" id="kobo.42.1">.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.43.1">There are three common patterns for applying one function to a set of data:</span></p>
<ul class="calibre11">
<li class="calibre12"><p class="normal2"><span class="cmbx-10x-x"><span class="kobospan" id="kobo.44.1">Mapping</span></span><span class="kobospan" id="kobo.45.1">: This applies a function</span><span id="dx1-502004"/><span class="kobospan" id="kobo.46.1"> to all the elements of a collection, </span><span><span class="kobospan" id="kobo.47.1">{</span></span><span class="cmti-10x-x"><span class="kobospan" id="kobo.48.1">m</span></span><span class="kobospan" id="kobo.49.1">(</span><span class="cmti-10x-x"><span class="kobospan" id="kobo.50.1">x</span></span><span class="kobospan" id="kobo.51.1">)</span><span><span class="kobospan" id="kobo.52.1">|</span></span><span class="cmti-10x-x"><span class="kobospan" id="kobo.53.1">x </span></span><span><span class="kobospan" id="kobo.54.1">∈ </span></span><span class="cmti-10x-x"><span class="kobospan" id="kobo.55.1">S</span></span><span><span class="kobospan" id="kobo.56.1">}</span></span><span class="kobospan" id="kobo.57.1">. </span><span class="kobospan" id="kobo.57.2">We apply some function, </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.58.1">m</span></span><span class="kobospan" id="kobo.59.1">(</span><span class="cmti-10x-x"><span class="kobospan" id="kobo.60.1">x</span></span><span class="kobospan" id="kobo.61.1">), to each item, </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.62.1">x</span></span><span class="kobospan" id="kobo.63.1">, of a larger collection, </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.64.1">S</span></span><span class="kobospan" id="kobo.65.1">.</span></p></li>
<li class="calibre7"><p class="normal2"><span class="cmbx-10x-x"><span class="kobospan" id="kobo.66.1">Filtering</span></span><span class="kobospan" id="kobo.67.1">: This uses a function</span><span id="dx1-502005"/><span class="kobospan" id="kobo.68.1"> to select elements from a collection, </span><span><span class="kobospan" id="kobo.69.1">{</span></span><span class="cmti-10x-x"><span class="kobospan" id="kobo.70.1">x</span></span><span><span class="kobospan" id="kobo.71.1">|</span></span><span class="cmti-10x-x"><span class="kobospan" id="kobo.72.1">x </span></span><span><span class="kobospan" id="kobo.73.1">∈ </span></span><span class="cmti-10x-x"><span class="kobospan" id="kobo.74.1">S</span></span> <span class="cmbx-10x-x"><span class="kobospan" id="kobo.75.1">if</span></span> <span class="cmti-10x-x"><span class="kobospan" id="kobo.76.1">f</span></span><span class="kobospan" id="kobo.77.1">(</span><span class="cmti-10x-x"><span class="kobospan" id="kobo.78.1">x</span></span><span class="kobospan" id="kobo.79.1">)</span><span><span class="kobospan" id="kobo.80.1">}</span></span><span class="kobospan" id="kobo.81.1">. </span><span class="kobospan" id="kobo.81.2">We use a function, </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.82.1">f</span></span><span class="kobospan" id="kobo.83.1">(</span><span class="cmti-10x-x"><span class="kobospan" id="kobo.84.1">x</span></span><span class="kobospan" id="kobo.85.1">), to determine whether to pass or reject each item, </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.86.1">x</span></span><span class="kobospan" id="kobo.87.1">, from the larger collection, </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.88.1">S</span></span><span class="kobospan" id="kobo.89.1">.</span></p></li>
<li class="calibre7"><p class="normal2"><span class="cmbx-10x-x"><span class="kobospan" id="kobo.90.1">Reducing</span></span><span class="kobospan" id="kobo.91.1">: This summarizes the items</span><span id="dx1-502006"/><span class="kobospan" id="kobo.92.1"> of a collection. </span><span class="kobospan" id="kobo.92.2">One of the most common reductions is creating a sum of all items in a collection, </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.93.1">S</span></span><span class="kobospan" id="kobo.94.1">, written as </span><span><span class="kobospan" id="kobo.95.1">∑</span></span> <sub class="calibre24"><span class="cmmi"><span class="kobospan" id="kobo.96.1">x</span></span><span class="cmr1"><span class="kobospan" id="kobo.97.1">∈</span></span><span class="cmmi"><span class="kobospan" id="kobo.98.1">S</span></span></sub><span class="cmti-10x-x"><span class="kobospan" id="kobo.99.1">x</span></span><span class="kobospan" id="kobo.100.1">. </span><span class="kobospan" id="kobo.100.2">Other common reductions include finding the smallest item, the largest one, and the product of all items.</span></p></li>
</ul>
<p class="normal1"><span class="kobospan" id="kobo.101.1">We’ll often combine these patterns to create more complex composite applications. </span><span class="kobospan" id="kobo.101.2">What’s important here is that small functions, such as </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.102.1">m</span></span><span class="kobospan" id="kobo.103.1">(</span><span class="cmti-10x-x"><span class="kobospan" id="kobo.104.1">x</span></span><span class="kobospan" id="kobo.105.1">) and </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.106.1">f</span></span><span class="kobospan" id="kobo.107.1">(</span><span class="cmti-10x-x"><span class="kobospan" id="kobo.108.1">x</span></span><span class="kobospan" id="kobo.109.1">), can be combined via the built-in higher-order functions such as </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.110.1">map()</span></span></span></span><span class="kobospan" id="kobo.111.1">, </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.112.1">filter()</span></span></span></span><span class="kobospan" id="kobo.113.1">, and </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.114.1">reduce()</span></span></span></span><span class="kobospan" id="kobo.115.1">. </span><span class="kobospan" id="kobo.115.2">The </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.116.1">itertools</span></span></span></span><span class="kobospan" id="kobo.117.1"> module contains many additional higher-order functions that we can use to build an application. </span><span class="kobospan" id="kobo.117.2">And, of course, we can define our own higher-order functions to combine smaller functions.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.118.1">Some of these recipes will show computations that could also be defined as properties of a class definition created using the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.119.1">@property</span></span></span></span><span class="kobospan" id="kobo.120.1"> decorator. </span><span class="kobospan" id="kobo.120.2">This is yet another design alternative that can limit the complexity of stateful objects. </span><span class="kobospan" id="kobo.120.3">In this chapter, however, we’ll try to stick to a functional approach, that is, transformation to create new objects rather than using properties.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.121.1">In this chapter, we’ll look at the following recipes:</span></p>
<ul class="calibre11">
<li class="calibre12"><p class="normal2"><a href="ch013_split_000.xhtml#x1-5030001" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.122.1">Writing generator functions with the yield statement</span></span></a></p></li>
<li class="calibre7"><p class="normal2"><a href="ch013_split_000.xhtml#x1-5090002" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.123.1">Applying transformations to a collection</span></span></a></p></li>
<li class="calibre7"><p class="normal2"><a href="ch013_split_000.xhtml#x1-5180003" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.124.1">Using stacked generator expressions</span></span></a></p></li>
<li class="calibre7"><p class="normal2"><a href="ch013_split_000.xhtml#x1-5270004" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.125.1">Picking a subset – three ways to filter</span></span></a></p></li>
<li class="calibre7"><p class="normal2"><a href="ch013_split_000.xhtml#x1-5350005" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.126.1">Summarizing a collection – how to reduce</span></span></a></p></li>
<li class="calibre7"><p class="normal2"><a href="ch013_split_001.xhtml#x1-5440006" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.127.1">Combining the map and reduce transformations</span></span></a></p></li>
<li class="calibre7"><p class="normal2"><a href="ch013_split_001.xhtml#x1-5500007" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.128.1">Implementing “there exists” processing</span></span></a></p></li>
<li class="calibre7"><p class="normal2"><a href="ch013_split_001.xhtml#x1-5560008" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.129.1">Creating a partial function</span></span></a></p></li>
<li class="calibre7"><p class="normal2"><a href="ch013_split_001.xhtml#x1-5640009" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.130.1">Writing recursive generator functions with the yield from statement</span></span></a></p></li>
</ul>
<p class="normal1"><span class="kobospan" id="kobo.131.1">We’ll start with a recipe where we will create functions that yield an iterable sequence of values. </span><span class="kobospan" id="kobo.131.2">Rather than creating an entire list (or set, or some other collection), a generator function yields the individual items of a collection as demanded by a client operation. </span><span class="kobospan" id="kobo.131.3">This saves memory and may save time. </span><span id="x1-502007r1051"/></p>
<section data-number="0.12.1" id="writing-generator-functions-with-the-yield-statement">
<h1 class="unnumbered" data-number="0.12.1"><span><span class="kobospan" id="kobo.132.1">9.1 </span></span> <span id="x1-5030001"/><span class="kobospan" id="kobo.133.1">Writing generator functions with the yield statement</span></h1>
<p class="normal"><span class="kobospan" id="kobo.134.1">A generator function is often designed</span><span id="dx1-503001"/><span class="kobospan" id="kobo.135.1"> to apply some kind</span><span id="dx1-503002"/><span class="kobospan" id="kobo.136.1"> of transformation to each item of a collection. </span><span class="kobospan" id="kobo.136.2">Generators can create data, too. </span><span class="kobospan" id="kobo.136.3">A generator</span><span id="dx1-503003"/><span class="kobospan" id="kobo.137.1"> is called </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.138.1">lazy </span></span><span class="kobospan" id="kobo.139.1">because the values it yields must be consumed by a client; values are not computed until a client attempts to consume them. </span><span class="kobospan" id="kobo.139.2">Client operations like the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.140.1">list()</span></span></span></span><span class="kobospan" id="kobo.141.1"> function or a </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.142.1">for</span></span></span></span><span class="kobospan" id="kobo.143.1"> statement are common examples of consumers. </span><span class="kobospan" id="kobo.143.2">Each time a function like </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.144.1">list()</span></span></span></span><span class="kobospan" id="kobo.145.1"> demands a value, the generator function must yield a value using the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.146.1">yield</span></span></span></span><span class="kobospan" id="kobo.147.1"> statement.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.148.1">In contrast, an ordinary function</span><span id="dx1-503004"/><span class="kobospan" id="kobo.149.1"> can be called </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.150.1">eager</span></span><span class="kobospan" id="kobo.151.1">. </span><span class="kobospan" id="kobo.151.2">Without the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.152.1">yield</span></span></span></span><span class="kobospan" id="kobo.153.1"> statement, a function will compute the entire result and return it via the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.154.1">return</span></span></span></span><span class="kobospan" id="kobo.155.1"> statement.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.156.1">A lazy approach is very helpful in cases where we can’t fit an entire collection in memory. </span><span class="kobospan" id="kobo.156.2">For example, analyzing gigantic web log files can be done in small doses rather than by creating a vast in-memory collection.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.157.1">In the language of Python’s type hints, we’ll often use the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.158.1">Iterator</span></span></span></span><span class="kobospan" id="kobo.159.1"> generic to describe generators. </span><span class="kobospan" id="kobo.159.2">We’ll need to clarify this generic with a type, like </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.160.1">Iterator[str]</span></span></span></span><span class="kobospan" id="kobo.161.1">, to show that the function yields string objects.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.162.1">The items that are being consumed</span><span id="dx1-503005"/><span class="kobospan" id="kobo.163.1"> by a generator</span><span id="dx1-503006"/><span class="kobospan" id="kobo.164.1"> will often be from a collection described by the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.165.1">Iterable</span></span></span></span><span class="kobospan" id="kobo.166.1"> generic type. </span><span class="kobospan" id="kobo.166.2">All of Python’s built-in collections are </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.167.1">Iterable</span></span></span></span><span class="kobospan" id="kobo.168.1">, as are files. </span><span class="kobospan" id="kobo.168.2">A list of string values, for example, can be viewed as an </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.169.1">Iterable[str]</span></span></span></span><span class="kobospan" id="kobo.170.1">.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.171.1">Both the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.172.1">Iterable</span></span></span></span><span class="kobospan" id="kobo.173.1"> and </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.174.1">Iterator</span></span></span></span><span class="kobospan" id="kobo.175.1"> types are available from the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.176.1">collections.abc</span></span></span></span><span class="kobospan" id="kobo.177.1"> module. </span><span class="kobospan" id="kobo.177.2">They can also be imported from the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.178.1">typing</span></span></span></span><span class="kobospan" id="kobo.179.1"> module.</span></p>
<div class="tipbox" id="tcolobox-17">
<div class="note">
<p class="normal1"><span class="kobospan" id="kobo.180.1">The </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.181.1">yield</span></span></span></span><span class="kobospan" id="kobo.182.1"> statement is what changes an ordinary function into a generator. </span><span class="kobospan" id="kobo.182.2">It will compute and yield results iteratively.</span></p>
</div>
</div>
<p class="normal1"><span id="x1-503007r1049"/></p>
<section data-number="0.12.1.1" id="getting-ready-70">
<h2 class="likechapterhead" data-number="0.12.1.1"><span><span class="kobospan" id="kobo.183.1">9.1.1 </span></span> <span id="x1-5040001"/><span class="kobospan" id="kobo.184.1">Getting ready</span></h2>
<p class="normal"><span class="kobospan" id="kobo.185.1">We’ll apply a generator to some web log data. </span><span class="kobospan" id="kobo.185.2">We’ll design a generator that will transform raw text into more useful structured objects. </span><span class="kobospan" id="kobo.185.3">The generator function serves to isolate transformation processing. </span><span class="kobospan" id="kobo.185.4">This permits flexibility in applying filter or summary operations after the initial transformation.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.186.1">The entries start out as lines of text that look like this:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.187.1">[2016-06-15 17:57:54,715] INFO in ch10_r10: Sample Message One 
 
[2016-06-15 17:57:54,716] DEBUG in ch10_r10: Debugging 
 
[2016-06-15 17:57:54,720] WARNING in ch10_r10: Something might have gone wrong</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.188.1">We’ve seen other examples of working with this kind of log in the </span><a href="ch012.xhtml#x1-4810005" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.189.1">Using more</span></span> <span class="cmti-10x-x"><span class="kobospan" id="kobo.190.1">complex structures – maps of lists</span></span></a><span class="kobospan" id="kobo.191.1"> recipe in </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.192.1">Chapter</span></span><span class="cmti-10x-x"><span class="kobospan" id="kobo.193.1"> </span></span><a href="ch012.xhtml#x1-4520008" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.194.1">8</span></span></a><span class="kobospan" id="kobo.195.1">. </span><span class="kobospan" id="kobo.195.2">Using REs from the </span><a href="ch005_split_000.xhtml#x1-350003" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.196.1">String</span></span> <span class="cmti-10x-x"><span class="kobospan" id="kobo.197.1">parsing with regular expressions</span></span></a><span class="kobospan" id="kobo.198.1"> recipe in </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.199.1">Chapter</span></span><span class="cmti-10x-x"><span class="kobospan" id="kobo.200.1"> </span></span><a href="ch005_split_000.xhtml#x1-170001" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.201.1">1</span></span></a><span class="kobospan" id="kobo.202.1">, we can decompose each line into a more useful structure.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.203.1">It’s often helpful to capture the details</span><span id="dx1-504005"/><span class="kobospan" id="kobo.204.1"> of each line of the log</span><span id="dx1-504006"/><span class="kobospan" id="kobo.205.1"> in an object of a distinct type. </span><span class="kobospan" id="kobo.205.2">This helps make the code more focused, and it helps us use the </span><span class="cmbx-10x-x"><span class="kobospan" id="kobo.206.1">mypy </span></span><span class="kobospan" id="kobo.207.1">tool to confirm that types are used properly. </span><span class="kobospan" id="kobo.207.2">Here’s a </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.208.1">NamedTuple</span></span></span></span><span class="kobospan" id="kobo.209.1"> class definition:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.210.1">from typing import NamedTuple 
 
 
 
class RawLog(NamedTuple): 
 
    date: str 
 
    level: str 
 
    module: str 
 
    message: str</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.211.1">We’ll start with the transformation of an iterable source of strings string into an iterator over tuple of fields. </span><span class="kobospan" id="kobo.211.2">After that, we’ll apply the recipe again to transform the date attribute from a string into a useful </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.212.1">datetime</span></span></span></span><span class="kobospan" id="kobo.213.1"> object. </span><span id="x1-504015r1055"/></p>
</section>
<section data-number="0.12.1.2" id="how-to-do-it...-71">
<h2 class="likechapterhead" data-number="0.12.1.2"><span><span class="kobospan" id="kobo.214.1">9.1.2 </span></span> <span id="x1-5050002"/><span class="kobospan" id="kobo.215.1">How to do it...</span></h2>
<p class="normal"><span class="kobospan" id="kobo.216.1">A generator function is a function, so the recipe is similar to those shown in </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.217.1">Chapter</span></span><span class="cmti-10x-x"><span class="kobospan" id="kobo.218.1"> </span></span><a href="ch007_split_000.xhtml#x1-1610003" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.219.1">3</span></span></a><span class="kobospan" id="kobo.220.1">. </span><span class="kobospan" id="kobo.220.2">We’ll start by defining the function, as follows:</span></p>
<ol class="calibre4">
<li class="calibre7"><div id="x1-505002x1" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.221.1">Import the needed type hints from the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.222.1">collections.abc</span></span></span></span><span class="kobospan" id="kobo.223.1"> module. </span><span class="kobospan" id="kobo.223.2">Import the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.224.1">re</span></span></span></span><span class="kobospan" id="kobo.225.1"> module to parse the line of the log file:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.226.1">import re 
 
from collections.abc import Iterable, Iterator</span></code></pre>
</div></li>
<li class="calibre7"><div id="x1-505007x2" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.227.1">Define a function that iterates over </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.228.1">RawLog</span></span></span></span><span class="kobospan" id="kobo.229.1"> objects. </span><span class="kobospan" id="kobo.229.2">It seems helpful to include </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.230.1">_iter</span></span></span></span><span class="kobospan" id="kobo.231.1"> in the function name to emphasize that the result is an iterator, not a single value. </span><span class="kobospan" id="kobo.231.2">The parameter is an iterable source of log lines:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.232.1">def parse_line_iter( 
 
    source: Iterable[str] 
 
) -&gt; Iterator[RawLog]:</span></code></pre>
</div></li>
<li class="calibre7"><div id="x1-505013x3" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.233.1">The </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.234.1">parse_line_iter()</span></span></span></span><span class="kobospan" id="kobo.235.1"> transformation function relies on a regular expression to decompose each line. </span><span class="kobospan" id="kobo.235.2">We can define this inside the function to keep it tightly bound with the rest of the processing:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.236.1">
    pattern = re.compile( 
 
        r"\[(?P&lt;date&gt;.*?)\]\s+" 
 
        r"(?P&lt;level&gt;\w+)\s+" 
 
        r"in\s+(?P&lt;module&gt;.+?)" 
 
        r":\s+(?P&lt;message&gt;.+)", 
 
        re.X 
 
    )</span></code></pre>
</div></li>
<li class="calibre7"><div id="x1-505023x4" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.237.1">A </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.238.1">for</span></span></span></span><span class="kobospan" id="kobo.239.1"> statement will consume</span><span id="dx1-505024"/><span class="kobospan" id="kobo.240.1"> each line of the iterable</span><span id="dx1-505025"/><span class="kobospan" id="kobo.241.1"> source, allowing us to create and then yield each </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.242.1">RawLog</span></span></span></span><span class="kobospan" id="kobo.243.1"> object in isolation:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.244.1">    for line in source:</span></code></pre>
</div></li>
<li class="calibre7"><div id="x1-505029x5" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.245.1">The body of the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.246.1">for</span></span></span></span><span class="kobospan" id="kobo.247.1"> statement can map each string instance that matches the pattern to a new </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.248.1">RawLog</span></span></span></span><span class="kobospan" id="kobo.249.1"> object using the match groups:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.250.1">        if match := pattern.match(line): 
 
            yield RawLog(*match.groups())</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.251.1">Non-matching lines will be silently dropped. </span><span class="kobospan" id="kobo.251.2">For the most part, this seems sensible because a log can be filled with messages from a variety of sources.</span></p>
<div class="tipbox2" id="tcolobox-18">
<div class="note1">
<p class="normal2"><span class="kobospan" id="kobo.252.1">Without a </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.253.1">yield</span></span></span></span><span class="kobospan" id="kobo.254.1"> statement, a function is “ordinary” and computes a single result.</span></p>
</div>
</div>
</div></li>
</ol>
<p class="normal1"><span class="kobospan" id="kobo.255.1">Here’s how we use this function to emit a sequence of </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.256.1">RawLog</span></span></span></span><span class="kobospan" id="kobo.257.1"> instances from the sample data shown above:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.258.1">&gt;&gt;&gt; from pprint import pprint 
 
 
 
&gt;&gt;&gt; for item in parse_line_iter(log_lines): 
 
... </span><span class="kobospan" id="kobo.258.2">    pprint(item) 
 
RawLog(date=’2016-04-24 11:05:01,462’, level=’INFO’, module=’module1’, message=’Sample Message One’) 
 
RawLog(date=’2016-04-24 11:06:02,624’, level=’DEBUG’, module=’module2’, message=’Debugging’) 
 
RawLog(date=’2016-04-24 11:07:03,246’, level=’WARNING’, module=’module1’, message=’Something might have gone wrong’)</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.259.1">We could also collect items into a list object using something like this:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.260.1">&gt;&gt;&gt; details = list(parse_line_iter(log_lines))</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.261.1">In this example, the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.262.1">list()</span></span></span></span><span class="kobospan" id="kobo.263.1"> function consumes</span><span id="dx1-505043"/><span class="kobospan" id="kobo.264.1"> all of the items produced by the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.265.1">parse_line_iter()</span></span></span></span><span class="kobospan" id="kobo.266.1"> function. </span><span class="kobospan" id="kobo.266.2">A generator is a relatively</span><span id="dx1-505044"/><span class="kobospan" id="kobo.267.1"> passive construct: until data is demanded, it doesn’t do any work. </span><span id="x1-505045r1058"/></p>
</section>
<section data-number="0.12.1.3" id="how-it-works...-71">
<h2 class="likechapterhead" data-number="0.12.1.3"><span><span class="kobospan" id="kobo.268.1">9.1.3 </span></span> <span id="x1-5060003"/><span class="kobospan" id="kobo.269.1">How it works...</span></h2>
<p class="normal"><span class="kobospan" id="kobo.270.1">Each of Python’s built-in collection types implements a special method, </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.271.1">__iter__()</span></span></span></span><span class="kobospan" id="kobo.272.1">, to produce an iterator object. </span><span class="kobospan" id="kobo.272.2">An iterator object implements the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.273.1">__next__()</span></span></span></span><span class="kobospan" id="kobo.274.1"> special method to both return an item and advance the state of the iterator to return the next item. </span><span class="kobospan" id="kobo.274.2">This is the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.275.1">Iterator</span></span></span></span><span class="kobospan" id="kobo.276.1"> protocol. </span><span class="kobospan" id="kobo.276.2">The built-in </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.277.1">next()</span></span></span></span><span class="kobospan" id="kobo.278.1"> function evaluates this method of an iterator object.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.279.1">While the Python built-in collections can create </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.280.1">Iterator</span></span></span></span><span class="kobospan" id="kobo.281.1"> objects, a generator function also implements this protocol. </span><span class="kobospan" id="kobo.281.2">A generator will return itself in response to the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.282.1">iter()</span></span></span></span><span class="kobospan" id="kobo.283.1"> function. </span><span class="kobospan" id="kobo.283.2">In response to the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.284.1">next()</span></span></span></span><span class="kobospan" id="kobo.285.1"> function, a generator suspends execution at a </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.286.1">yield</span></span></span></span><span class="kobospan" id="kobo.287.1"> statement, and provides a value that becomes the result of the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.288.1">next()</span></span></span></span><span class="kobospan" id="kobo.289.1"> function. </span><span class="kobospan" id="kobo.289.2">Since the function is suspended, it can be resumed when another </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.290.1">next()</span></span></span></span><span class="kobospan" id="kobo.291.1"> function is evaluated.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.292.1">To see how the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.293.1">yield</span></span></span></span><span class="kobospan" id="kobo.294.1"> statement works, look at this small function, which yields two objects:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.295.1">test_example_4_3 = """ 
 
&gt;&gt;&gt; def gen_func(): 
 
... </span><span class="kobospan" id="kobo.295.2">    print("pre-yield") 
 
... </span><span class="kobospan" id="kobo.295.3">    yield 1 
 
... </span><span class="kobospan" id="kobo.295.4">    print("post-yield")</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.296.1">Here’s what happens when we evaluate the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.297.1">next()</span></span></span></span><span class="kobospan" id="kobo.298.1"> function on this generator:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.299.1">&gt;&gt;&gt; y = gen_func() 
 
&gt;&gt;&gt; next(y) 
 
pre-yield 
 
1 
 
 
 
&gt;&gt;&gt; next(y) 
 
post-yield</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.300.1">The first time we evaluated the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.301.1">next()</span></span></span></span><span class="kobospan" id="kobo.302.1"> function, the first </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.303.1">print()</span></span></span></span><span class="kobospan" id="kobo.304.1"> function was evaluated, and then the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.305.1">yield</span></span></span></span><span class="kobospan" id="kobo.306.1"> statement produced a value.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.307.1">The use of the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.308.1">next()</span></span></span></span><span class="kobospan" id="kobo.309.1"> function resumed</span><span id="dx1-506016"/><span class="kobospan" id="kobo.310.1"> processing, and the statements</span><span id="dx1-506017"/><span class="kobospan" id="kobo.311.1"> between the two </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.312.1">yield</span></span></span></span><span class="kobospan" id="kobo.313.1"> statements were evaluated.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.314.1">What happens next? </span><span class="kobospan" id="kobo.314.2">Since there are no more </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.315.1">yield</span></span></span></span><span class="kobospan" id="kobo.316.1"> statements in the function’s body, so we observe the following:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.317.1">&gt;&gt;&gt; next(y) 
 
Traceback (most recent call last): 
 
...</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.318.1">The </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.319.1">StopIteration</span></span></span></span><span class="kobospan" id="kobo.320.1"> exception is raised at the end of a generator function. </span><span class="kobospan" id="kobo.320.2">This is expected by the processing of a </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.321.1">for</span></span></span></span><span class="kobospan" id="kobo.322.1"> statement. </span><span class="kobospan" id="kobo.322.2">It is quietly absorbed to break from processing.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.323.1">If we don’t use a function like </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.324.1">list()</span></span></span></span><span class="kobospan" id="kobo.325.1"> or a </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.326.1">for</span></span></span></span><span class="kobospan" id="kobo.327.1"> statement to consume the data, we’ll see something like this:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.328.1">&gt;&gt;&gt; parse_line_iter(data) 
 
&lt;generator object parse_line_iter at ...&gt;</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.329.1">The value returned by evaluating the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.330.1">parse_line_iter()</span></span></span></span><span class="kobospan" id="kobo.331.1"> function is a generator. </span><span class="kobospan" id="kobo.331.2">It’s not a collection of items, but an object</span><span id="dx1-506026"/><span class="kobospan" id="kobo.332.1"> that will produce</span><span id="dx1-506027"/><span class="kobospan" id="kobo.333.1"> items, one at a time, on demand from a consumer. </span><span id="x1-506028r1066"/></p>
</section>
<section data-number="0.12.1.4" id="theres-more...-62">
<h2 class="likechapterhead" data-number="0.12.1.4"><span><span class="kobospan" id="kobo.334.1">9.1.4 </span></span> <span id="x1-5070004"/><span class="kobospan" id="kobo.335.1">There’s more...</span></h2>
<p class="normal"><span class="kobospan" id="kobo.336.1">We can apply this recipe to convert the date attributes in each </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.337.1">RawLog</span></span></span></span><span class="kobospan" id="kobo.338.1"> object. </span><span class="kobospan" id="kobo.338.2">The more refined kind of data from each line will follow this class definition:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.339.1">import datetime 
 
from typing import NamedTuple 
 
 
 
class DatedLog(NamedTuple): 
 
    date: datetime.datetime 
 
    level: str 
 
    module: str 
 
    message: str</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.340.1">This has a more useful </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.341.1">datetime.datetime</span></span></span></span><span class="kobospan" id="kobo.342.1"> object for the timestamp. </span><span class="kobospan" id="kobo.342.2">The other fields remain as strings.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.343.1">Here’s a generator function – using a </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.344.1">for</span></span></span></span><span class="kobospan" id="kobo.345.1"> statement and </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.346.1">yield</span></span></span></span><span class="kobospan" id="kobo.347.1"> so that it’s an iterator – that’s used to refine each </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.348.1">RawLog</span></span></span></span><span class="kobospan" id="kobo.349.1"> object into a </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.350.1">DatedLog</span></span></span></span><span class="kobospan" id="kobo.351.1"> object:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.352.1">def parse_date_iter( 
 
    source: Iterable[RawLog] 
 
) -&gt; Iterator[DatedLog]: 
 
    for item in source: 
 
        date = datetime.datetime.strptime( 
 
            item.date, "%Y-%m-%d %H:%M:%S,%f" 
 
        ) 
 
        yield DatedLog( 
 
            date, item.level, item.module, item.message 
 
        )</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.353.1">Breaking overall processing into small generator functions confers several significant advantages. </span><span class="kobospan" id="kobo.353.2">First, the decomposition makes each function more succinct because it is focused on a specific task. </span><span class="kobospan" id="kobo.353.3">This makes these functions easier to design, test, and maintain. </span><span class="kobospan" id="kobo.353.4">Second, it makes the overall composition somewhat more expressive of the work being done.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.354.1">We can combine these two generators in the following kind of composition:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.355.1">&gt;&gt;&gt; for item in parse_date_iter(parse_line_iter(log_lines)): 
 
... </span><span class="kobospan" id="kobo.355.2">    print(item) 
 
DatedLog(date=datetime.datetime(2016, 4, 24, 11, 5, 1, 462000), level=’INFO’, module=’module1’, message=’Sample Message One’) 
 
DatedLog(date=datetime.datetime(2016, 4, 24, 11, 6, 2, 624000), level=’DEBUG’, module=’module2’, message=’Debugging’) 
 
DatedLog(date=datetime.datetime(2016, 4, 24, 11, 7, 3, 246000), level=’WARNING’, module=’module1’, message=’Something might have gone wrong’)</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.356.1">The </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.357.1">parse_line_iter()</span></span></span></span><span class="kobospan" id="kobo.358.1"> function will consume lines from the source data, creating </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.359.1">RawLog</span></span></span></span><span class="kobospan" id="kobo.360.1"> objects when they are demanded by a consumer. </span><span class="kobospan" id="kobo.360.2">The </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.361.1">parse_date_iter()</span></span></span></span><span class="kobospan" id="kobo.362.1"> function is a consumer of </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.363.1">RawLog</span></span></span></span><span class="kobospan" id="kobo.364.1"> objects; from these, it creates </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.365.1">DatedLog</span></span></span></span><span class="kobospan" id="kobo.366.1"> objects when demanded by a consumer. </span><span class="kobospan" id="kobo.366.2">The outer </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.367.1">for</span></span></span></span><span class="kobospan" id="kobo.368.1"> statement is the ultimate consumer, demanding </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.369.1">DatedLog</span></span></span></span><span class="kobospan" id="kobo.370.1"> objects.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.371.1">At no time will there be a large collection of intermediate objects in memory. </span><span class="kobospan" id="kobo.371.2">Each of these functions works with a single object, limiting the amount of memory used. </span><span id="x1-507027r1071"/></p>
</section>
<section data-number="0.12.1.5" id="see-also-69">
<h2 class="likechapterhead" data-number="0.12.1.5"><span><span class="kobospan" id="kobo.372.1">9.1.5 </span></span> <span id="x1-5080005"/><span class="kobospan" id="kobo.373.1">See also</span></h2>
<ul class="calibre16">
<li class="calibre12"><p class="normal2"><span class="kobospan" id="kobo.374.1">In the </span><a href="ch013_split_000.xhtml#x1-5180003" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.375.1">Using stacked generator expressions</span></span></a><span class="kobospan" id="kobo.376.1"> recipe, we’ll combine generator functions to build complex processing stacks from simple components.</span></p></li>
<li class="calibre7"><p class="normal2"><span class="kobospan" id="kobo.377.1">In the </span><a href="ch013_split_000.xhtml#x1-5090002" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.378.1">Applying transformations to a collection</span></span></a><span class="kobospan" id="kobo.379.1"> recipe, we’ll see how the built-in </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.380.1">map()</span></span></span></span><span class="kobospan" id="kobo.381.1"> function can be used to create complex processing from a simple function and an iterable source of data.</span></p></li>
<li class="calibre7"><p class="normal2"><span class="kobospan" id="kobo.382.1">In the </span><a href="ch013_split_000.xhtml#x1-5270004" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.383.1">Picking a subset – three ways to filter</span></span></a><span class="kobospan" id="kobo.384.1"> recipe, we’ll see how the built-in </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.385.1">filter()</span></span></span></span><span class="kobospan" id="kobo.386.1"> function can also be used to build complex processing from a simple function and an iterable source of data.</span></p></li>
</ul>
<p class="normal1"><span id="x1-508001r1054"/></p>
</section>
</section>
<section data-number="0.12.2" id="applying-transformations-to-a-collection">
<h1 class="unnumbered" data-number="0.12.2"><span><span class="kobospan" id="kobo.387.1">9.2 </span></span> <span id="x1-5090002"/><span class="kobospan" id="kobo.388.1">Applying transformations to a collection</span></h1>
<p class="normal"><span class="kobospan" id="kobo.389.1">We often define generator</span><span id="dx1-509001"/><span class="kobospan" id="kobo.390.1"> functions with the intention</span><span id="dx1-509002"/><span class="kobospan" id="kobo.391.1"> apply the function to a collection of data items. </span><span class="kobospan" id="kobo.391.2">There are a number of ways that generators can be used with collections.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.392.1">In the </span><a href="ch013_split_000.xhtml#x1-5030001" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.393.1">Writing generator functions with the yield statement</span></span></a><span class="kobospan" id="kobo.394.1"> recipe in this chapter, we created a generator function to transform data from a string into a more complex object.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.395.1">Generator functions have a common structure, and generally look like this:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.396.1">def new_item_iter(source: Iterable[X]) -&gt; Iterator[Y]: 
 
    for item in source: 
 
        new_item: Y = some_transformation(item) 
 
        yield new_item</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.397.1">The </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.398.1">yield</span></span></span></span><span class="kobospan" id="kobo.399.1"> statement means the results will be generated iteratively. </span><span class="kobospan" id="kobo.399.2">The function’s type hints emphasize that it consumes items from the source collection. </span><span class="kobospan" id="kobo.399.3">This template for writing a generator function exposes a common design pattern.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.400.1">Mathematically, we can summarize this as follows:</span></p>
<div class="math-display">
<span class="kobospan" id="kobo.401.1"><img alt="N = {m (x ) | x ∈ S} " class="calibre9" src="../media/file59.png"/></span>
</div>
<p class="normal1"><span class="kobospan" id="kobo.402.1">The new collection, </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.403.1">N</span></span><span class="kobospan" id="kobo.404.1">, is a transformation, </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.405.1">m</span></span><span class="kobospan" id="kobo.406.1">(</span><span class="cmti-10x-x"><span class="kobospan" id="kobo.407.1">x</span></span><span class="kobospan" id="kobo.408.1">), applied to each item, </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.409.1">x</span></span><span class="kobospan" id="kobo.410.1">, of the source, </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.411.1">S</span></span><span class="kobospan" id="kobo.412.1">. </span><span class="kobospan" id="kobo.412.2">This emphasizes the transformation function, </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.413.1">m</span></span><span class="kobospan" id="kobo.414.1">(</span><span class="cmti-10x-x"><span class="kobospan" id="kobo.415.1">x</span></span><span class="kobospan" id="kobo.416.1">), separating it from the details of consuming the source and producing the result. </span><span class="kobospan" id="kobo.416.2">In the Python example previously shown, this function was called </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.417.1">some_transformation()</span></span></span></span><span class="kobospan" id="kobo.418.1">.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.419.1">This mathematical summary suggests that the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.420.1">for</span></span></span></span><span class="kobospan" id="kobo.421.1"> statement can be understood as a kind of scaffold around the transformation function. </span><span class="kobospan" id="kobo.421.2">There are two additional forms this scaffolding can take. </span><span class="kobospan" id="kobo.421.3">We can write a generator expression or we can use the built-in </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.422.1">map()</span></span></span></span><span class="kobospan" id="kobo.423.1"> function. </span><span class="kobospan" id="kobo.423.2">This recipe will examine all three techniques. </span><span id="x1-509008r1075"/></p>
<section data-number="0.12.2.1" id="getting-ready-71">
<h2 class="likechapterhead" data-number="0.12.2.1"><span><span class="kobospan" id="kobo.424.1">9.2.1 </span></span> <span id="x1-5100001"/><span class="kobospan" id="kobo.425.1">Getting ready</span></h2>
<p class="normal"><span class="kobospan" id="kobo.426.1">We’ll look at the web log</span><span id="dx1-510001"/><span class="kobospan" id="kobo.427.1"> data from the </span><a href="ch013_split_000.xhtml#x1-5030001" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.428.1">Writing generator functions</span></span> <span class="cmti-10x-x"><span class="kobospan" id="kobo.429.1">with the yield statement</span></span></a><span class="kobospan" id="kobo.430.1"> recipe. </span><span class="kobospan" id="kobo.430.2">This had dates</span><span id="dx1-510002"/><span class="kobospan" id="kobo.431.1"> as strings that we would like to transform into a proper datetime object to be used for further computations. </span><span class="kobospan" id="kobo.431.2">We’ll make use of the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.432.1">DatedLog</span></span></span></span><span class="kobospan" id="kobo.433.1"> class definition from that earlier recipe.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.434.1">The </span><a href="ch013_split_000.xhtml#x1-5030001" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.435.1">Writing generator functions with the yield statement</span></span></a><span class="kobospan" id="kobo.436.1"> recipe used a generator function like the following example to transform a sequence of </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.437.1">RawLog</span></span></span></span><span class="kobospan" id="kobo.438.1"> objects into an iterator of more useful </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.439.1">DatedLog</span></span></span></span><span class="kobospan" id="kobo.440.1"> instances:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.441.1">import datetime 
 
from recipe_01 import RawLog, DatedLog 
 
 
 
def parse_date_iter( 
 
    source: Iterable[RawLog] 
 
) -&gt; Iterator[DatedLog]: 
 
    for item in source: 
 
        date = datetime.datetime.strptime( 
 
            item.date, "%Y-%m-%d %H:%M:%S,%f" 
 
        ) 
 
        yield DatedLog( 
 
            date, item.level, item.module, item.message 
 
        )</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.442.1">This </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.443.1">parse_date_iter()</span></span></span></span><span class="kobospan" id="kobo.444.1"> function has a significant amount of scaffolding code around an interesting function. </span><span class="kobospan" id="kobo.444.2">The </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.445.1">for</span></span></span></span><span class="kobospan" id="kobo.446.1"> and </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.447.1">yield</span></span></span></span><span class="kobospan" id="kobo.448.1"> statements are examples of scaffolding. </span><span class="kobospan" id="kobo.448.2">The date parsing, on the other hand, is the distinctive, interesting part of the function. </span><span class="kobospan" id="kobo.448.3">We need to extract this distinct processing to permit use of more flexible scaffolding. </span><span id="x1-510017r1078"/></p>
</section>
<section data-number="0.12.2.2" id="how-to-do-it...-72">
<h2 class="likechapterhead" data-number="0.12.2.2"><span><span class="kobospan" id="kobo.449.1">9.2.2 </span></span> <span id="x1-5110002"/><span class="kobospan" id="kobo.450.1">How to do it...</span></h2>
<p class="normal"><span class="kobospan" id="kobo.451.1">To make use of different approaches to applying a generator function, we’ll need to start by refactoring the original </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.452.1">parse_date_iter()</span></span></span></span><span class="kobospan" id="kobo.453.1"> function. </span><span class="kobospan" id="kobo.453.2">This will extract a </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.454.1">parse_date()</span></span></span></span><span class="kobospan" id="kobo.455.1"> function that can be used in a variety of ways. </span><span class="kobospan" id="kobo.455.2">After this initial step, we’ll show three separate mini-recipes for using the refactored code.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.456.1">Refactor the iterator to define</span><span id="dx1-511001"/><span class="kobospan" id="kobo.457.1"> a function that can be applied</span><span id="dx1-511002"/><span class="kobospan" id="kobo.458.1"> to a single row of the data. </span><span class="kobospan" id="kobo.458.2">It should produce an item of the result type from an item of the source type:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.459.1">def parse_date(item: RawLog) -&gt; DatedLog: 
 
    date = datetime.datetime.strptime( 
 
        item.date, "%Y-%m-%d %H:%M:%S,%f") 
 
    return DatedLog( 
 
        date, item.level, item.module, item.message)</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.460.1">This transformation can be applied to a collection of data in three ways: a generator function, a generator expression, and via the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.461.1">map()</span></span></span></span><span class="kobospan" id="kobo.462.1"> function. </span><span class="kobospan" id="kobo.462.2">We’ll start by rebuilding the original generator.</span></p>
<section data-number="0.12.2.2.1" id="using-the-for-and-yield-statements">
<h3 class="likesubsubsectionhead" data-number="0.12.2.2.1"><span id="x1-5120002"/><span class="kobospan" id="kobo.463.1">Using the for and yield statements</span></h3>
<p class="normal"><span class="kobospan" id="kobo.464.1">We can apply</span><span id="dx1-512001"/><span class="kobospan" id="kobo.465.1"> a single-row </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.466.1">parse_date()</span></span></span></span><span class="kobospan" id="kobo.467.1"> transformation function</span><span id="dx1-512002"/><span class="kobospan" id="kobo.468.1"> to each item of a collection using the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.469.1">for</span></span></span></span><span class="kobospan" id="kobo.470.1"> and </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.471.1">yield</span></span></span></span><span class="kobospan" id="kobo.472.1"> statements. </span><span class="kobospan" id="kobo.472.2">This was shown in the </span><a href="ch013_split_000.xhtml#x1-5030001" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.473.1">Writing</span></span> <span class="cmti-10x-x"><span class="kobospan" id="kobo.474.1">generator functions with the yield statement</span></span></a><span class="kobospan" id="kobo.475.1"> recipe earlier in this chapter. </span><span class="kobospan" id="kobo.475.2">Here’s what it looks like:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.476.1">def parse_date_iter_y( 
 
    source: Iterable[RawLog] 
 
) -&gt; Iterator[DatedLog]: 
 
    for item in source: 
 
        yield parse_date(item)</span></code></pre>
</section>
<section data-number="0.12.2.2.2" id="using-a-generator-expression">
<h3 class="likesubsubsectionhead" data-number="0.12.2.2.2"><span id="x1-5130002"/><span class="kobospan" id="kobo.477.1">Using a generator expression</span></h3>
<p class="normal"><span class="kobospan" id="kobo.478.1">We can apply the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.479.1">parse_date()</span></span></span></span><span class="kobospan" id="kobo.480.1"> function to each item</span><span id="dx1-513001"/><span class="kobospan" id="kobo.481.1"> of a collection using a generator expression. </span><span class="kobospan" id="kobo.481.2">A generator expression includes two parts – the mapping function, and a </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.482.1">for</span></span></span></span><span class="kobospan" id="kobo.483.1"> clause – enclosed by </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.484.1">()</span></span></span></span><span class="kobospan" id="kobo.485.1">. </span><span class="kobospan" id="kobo.485.2">This follows the pattern of the </span><a href="ch008_split_000.xhtml#x1-2310002" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.486.1">Building lists – literals, appending, and comprehensions</span></span></a><span class="kobospan" id="kobo.487.1"> recipe in </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.488.1">Chapter</span></span><span class="cmti-10x-x"><span class="kobospan" id="kobo.489.1"> </span></span><a href="ch008_split_000.xhtml#x1-2240004" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.490.1">4</span></span></a><span class="kobospan" id="kobo.491.1">:</span></p>
<ol class="calibre4">
<li class="calibre7"><div id="x1-513003x1" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.492.1">Write the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.493.1">()</span></span></span></span><span class="kobospan" id="kobo.494.1"> brackets that surround the generator.</span></p>
</div></li>
<li class="calibre7"><div id="x1-513005x2" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.495.1">Write a </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.496.1">for</span></span></span></span><span class="kobospan" id="kobo.497.1"> clause for the source of the data, assigning each item to a variable, in this case, </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.498.1">item</span></span></span></span><span class="kobospan" id="kobo.499.1">:</span></p>
<pre class="programlisting" id="listing-41"><code class="calibre13"><span class="kobospan" id="kobo.500.1">(... </span><span class="kobospan" id="kobo.500.2">for item in source)</span></code></pre>
</div></li>
<li class="calibre7"><div id="x1-513008x3" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.501.1">Prefix the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.502.1">for</span></span></span></span><span class="kobospan" id="kobo.503.1"> clause with</span><span id="dx1-513009"/><span class="kobospan" id="kobo.504.1"> the mapping</span><span id="dx1-513010"/><span class="kobospan" id="kobo.505.1"> function, applied to the variable:</span></p>
<pre class="programlisting" id="listing-42"><code class="calibre13"><span class="kobospan" id="kobo.506.1">(parse_date(item) for item in source)</span></code></pre>
</div></li>
<li class="calibre7"><div id="x1-513013x4" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.507.1">The expression can be the return value from a function that provides suitable type hints for the source and the resulting expression. </span><span class="kobospan" id="kobo.507.2">Here’s the entire function, since it’s so small:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.508.1">def parse_date_iter_g( 
 
    source: Iterable[RawLog] 
 
) -&gt; Iterator[DatedLog]: 
 
  return (parse_date(item) for item in source)</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.509.1">The function returns the generator expression that applies the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.510.1">parse_date()</span></span></span></span><span class="kobospan" id="kobo.511.1"> function to each item in the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.512.1">source</span></span></span></span><span class="kobospan" id="kobo.513.1"> iterable.</span></p>
</div></li>
</ol>
<p class="normal1"><span class="kobospan" id="kobo.514.1">Yes, this function is so small, it doesn’t seem to require the overhead</span><span id="dx1-513019"/><span class="kobospan" id="kobo.515.1"> of a </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.516.1">def</span></span></span></span><span class="kobospan" id="kobo.517.1"> statement and a name. </span><span class="kobospan" id="kobo.517.2">The type hints can be helpful in some contexts, making this a sensible choice.</span></p>
</section>
<section data-number="0.12.2.2.3" id="using-the-map-function">
<h3 class="likesubsubsectionhead" data-number="0.12.2.2.3"><span id="x1-5140002"/><span class="kobospan" id="kobo.518.1">Using the map() function</span></h3>
<p class="normal"><span class="kobospan" id="kobo.519.1">We can apply the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.520.1">parse_date()</span></span></span></span><span class="kobospan" id="kobo.521.1"> function</span><span id="dx1-514001"/><span class="kobospan" id="kobo.522.1"> to each item of a collection using the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.523.1">map()</span></span></span></span><span class="kobospan" id="kobo.524.1"> built-in function:</span></p>
<ol class="calibre4">
<li class="calibre7"><div id="x1-514003x1" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.525.1">Use the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.526.1">map()</span></span></span></span><span class="kobospan" id="kobo.527.1"> function to apply the transformation to the source data:</span></p>
<pre class="programlisting" id="listing-43"><code class="calibre13"><span class="kobospan" id="kobo.528.1">map(parse_date, source)</span></code></pre>
</div></li>
<li class="calibre7"><div id="x1-514006x2" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.529.1">The expression can be the return value from a function that provides suitable type hints for the source and the resulting expression. </span><span class="kobospan" id="kobo.529.2">Here’s the entire function, since it’s so small:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.530.1">def parse_date_iter_m( 
 
    source: Iterable[RawLog] 
 
) -&gt; Iterator[DatedLog]: 
 
    return map(parse_date, source)</span></code></pre>
</div></li>
</ol>
<p class="normal1"><span class="kobospan" id="kobo.531.1">The </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.532.1">map()</span></span></span></span><span class="kobospan" id="kobo.533.1"> function is an iterator</span><span id="dx1-514012"/><span class="kobospan" id="kobo.534.1"> that applies the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.535.1">parse_date()</span></span></span></span><span class="kobospan" id="kobo.536.1"> function to each item from the source iterable. </span><span class="kobospan" id="kobo.536.2">It yields the objects created by the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.537.1">parse_date()</span></span></span></span><span class="kobospan" id="kobo.538.1"> function.</span></p>
<div class="tipbox" id="tcolobox-19">
<div class="note">
<p class="normal1"><span class="kobospan" id="kobo.539.1">It’s important to note that the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.540.1">parse_date</span></span></span></span><span class="kobospan" id="kobo.541.1"> name without </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.542.1">()</span></span></span></span><span class="kobospan" id="kobo.543.1"> is a reference to a function object.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.544.1">It’s a common error to think the function must be evaluated, and include extra, unnecessary uses of </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.545.1">()</span></span></span></span><span class="kobospan" id="kobo.546.1">.</span></p>
</div>
</div>
<p class="normal1"><span class="kobospan" id="kobo.547.1">All three techniques are equivalent. </span><span id="x1-514013r1080"/></p>
</section>
</section>
<section data-number="0.12.2.3" id="how-it-works...-72">
<h2 class="likechapterhead" data-number="0.12.2.3"><span><span class="kobospan" id="kobo.548.1">9.2.3 </span></span> <span id="x1-5150003"/><span class="kobospan" id="kobo.549.1">How it works...</span></h2>
<p class="normal"><span class="kobospan" id="kobo.550.1">The </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.551.1">map()</span></span></span></span><span class="kobospan" id="kobo.552.1"> function replaces</span><span id="dx1-515001"/><span class="kobospan" id="kobo.553.1"> some common code</span><span id="dx1-515002"/><span class="kobospan" id="kobo.554.1"> that acts as a scaffold around the processing. </span><span class="kobospan" id="kobo.554.2">It does the work of a </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.555.1">for</span></span></span></span><span class="kobospan" id="kobo.556.1"> statement. </span><span class="kobospan" id="kobo.556.2">It applies the given function to each item in the source iterable.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.557.1">We can define our own version of </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.558.1">map()</span></span></span></span><span class="kobospan" id="kobo.559.1"> as follows:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.560.1">def my_map2(f: Callable[[P], Q], source: Iterable[P]) -&gt; Iterator[Q]: 
 
    return (f(item) for item in source)
                                                                     

                                                                     </span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.561.1">As we’ve seen, these are identical in their behavior. </span><span class="kobospan" id="kobo.561.2">Different audiences for the code may have distinct preferences. </span><span class="kobospan" id="kobo.561.3">The guidance we offer is to choose the style that makes the meaning and intention the most clear to the audience reading the code. </span><span id="x1-515006r1088"/></p>
</section>
<section data-number="0.12.2.4" id="theres-more...-63">
<h2 class="likechapterhead" data-number="0.12.2.4"><span><span class="kobospan" id="kobo.562.1">9.2.4 </span></span> <span id="x1-5160004"/><span class="kobospan" id="kobo.563.1">There’s more...</span></h2>
<p class="normal"><span class="kobospan" id="kobo.564.1">In this example, we’ve used the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.565.1">map()</span></span></span></span><span class="kobospan" id="kobo.566.1"> function</span><span id="dx1-516001"/><span class="kobospan" id="kobo.567.1"> to apply a function that takes a single parameter to each item of a single iterable collection. </span><span class="kobospan" id="kobo.567.2">It turns out that the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.568.1">map()</span></span></span></span><span class="kobospan" id="kobo.569.1"> function can do a bit more than this. </span><span class="kobospan" id="kobo.569.2">The </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.570.1">map()</span></span></span></span><span class="kobospan" id="kobo.571.1"> function can process several sequences.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.572.1">Consider this function and these two sources of data:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.573.1">&gt;&gt;&gt; def mul(a, b): 
 
... </span><span class="kobospan" id="kobo.573.2">    return a * b 
 
 
 
&gt;&gt;&gt; list_1 = [2, 3, 5, 7] 
 
&gt;&gt;&gt; list_2 = [11, 13, 17, 23]</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.574.1">We can apply the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.575.1">mul()</span></span></span></span><span class="kobospan" id="kobo.576.1"> function to the sequence of pairs drawn from each source of data:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.577.1">&gt;&gt;&gt; list(map(mul, list_1, list_2)) 
 
[22, 39, 85, 161]</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.578.1">This allows us to merge several sequences of values using different kinds of operations on argument values pulled from the sequences. </span><span id="x1-516011r1090"/></p>
</section>
<section data-number="0.12.2.5" id="see-also-70">
<h2 class="likechapterhead" data-number="0.12.2.5"><span><span class="kobospan" id="kobo.579.1">9.2.5 </span></span> <span id="x1-5170005"/><span class="kobospan" id="kobo.580.1">See also</span></h2>
<ul class="calibre16">
<li class="calibre12"><p class="normal2"><span class="kobospan" id="kobo.581.1">In the </span><a href="ch013_split_000.xhtml#x1-5180003" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.582.1">Using stacked generator expressions</span></span></a><span class="kobospan" id="kobo.583.1"> recipe later in this chapter, we will look at stacked generators. </span><span class="kobospan" id="kobo.583.2">We will build a composite function from a number of individual mapping operations, written as various kinds of generator functions.</span></p></li>
</ul>
<p class="normal1"><span id="x1-517001r1076"/></p>
</section>
</section>
<section data-number="0.12.3" id="using-stacked-generator-expressions">
<h1 class="unnumbered" data-number="0.12.3"><span><span class="kobospan" id="kobo.584.1">9.3 </span></span> <span id="x1-5180003"/><span class="kobospan" id="kobo.585.1">Using stacked generator expressions</span></h1>
<p class="normal"><span class="kobospan" id="kobo.586.1">In the </span><a href="ch013_split_000.xhtml#x1-5030001" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.587.1">Writing generator functions with the yield statement</span></span></a><span class="kobospan" id="kobo.588.1"> recipe earlier</span><span id="dx1-518001"/><span class="kobospan" id="kobo.589.1"> in this chapter, we created a simple generator function that performed a single transformation on a piece of data. </span><span class="kobospan" id="kobo.589.2">As a practical matter, we often have several functions that we’d like to apply to incoming data.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.590.1">How can we stack or combine multiple generator functions to create a composite function? </span><span id="x1-518002r1093"/></p>
<section data-number="0.12.3.1" id="getting-ready-72">
<h2 class="likechapterhead" data-number="0.12.3.1"><span><span class="kobospan" id="kobo.591.1">9.3.1 </span></span> <span id="x1-5190001"/><span class="kobospan" id="kobo.592.1">Getting ready</span></h2>
<p class="normal"><span class="kobospan" id="kobo.593.1">This recipe will apply several different kinds of transformations</span><span id="dx1-519001"/><span class="kobospan" id="kobo.594.1"> to source data. </span><span class="kobospan" id="kobo.594.2">There will be restructuring of the rows to combine three rows into a single row, data conversions to convert the source strings into useful numbers or datetime stamps, and filtering to reject rows that aren’t useful.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.595.1">We have a spreadsheet that is used to record fuel consumption on a large sailboat.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.596.1">For details of this data, see the </span><a href="ch008_split_000.xhtml#x1-2400003" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.597.1">Slicing and dicing a list</span></span></a><span class="kobospan" id="kobo.598.1"> recipe in </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.599.1">Chapter</span></span><span class="cmti-10x-x"><span class="kobospan" id="kobo.600.1"> </span></span><a href="ch008_split_000.xhtml#x1-2240004" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.601.1">4</span></span></a><span class="kobospan" id="kobo.602.1">. </span><span class="kobospan" id="kobo.602.2">We’ll look at parsing this in more detail in the </span><a href="ch015_split_000.xhtml#x1-6320003" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.603.1">Reading delimited files with the</span></span> <span class="cmti-10x-x"><span class="kobospan" id="kobo.604.1">CSV module</span></span></a><span class="kobospan" id="kobo.605.1"> recipe in </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.606.1">Chapter</span></span><span class="cmti-10x-x"><span class="kobospan" id="kobo.607.1"> </span></span><a href="ch015_split_000.xhtml#x1-61500011" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.608.1">11</span></span></a><span class="kobospan" id="kobo.609.1">.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.610.1">We’d like to apply a number of transformations to each row-level list of this list-of-lists-of-strings object:</span></p>
<ul class="calibre11">
<li class="calibre12"><p class="normal2"><span class="kobospan" id="kobo.611.1">Exclude the three lines of headers (and any blank lines) that are present in the data.</span></p></li>
<li class="calibre7"><p class="normal2"><span class="kobospan" id="kobo.612.1">Merge three physical lines of text strings into one logical row of data.</span></p></li>
<li class="calibre7"><p class="normal2"><span class="kobospan" id="kobo.613.1">Convert the separated date and time strings into datetime objects.</span></p></li>
<li class="calibre7"><p class="normal2"><span class="kobospan" id="kobo.614.1">Convert the fuel height from a string to a float, ideally in gallons (or liters) instead of inches.</span></p></li>
</ul>
<p class="normal1"><span class="kobospan" id="kobo.615.1">Our goal is to create a group of generator functions. </span><span class="kobospan" id="kobo.615.2">Assuming we have assigned the results of a generator function to a variable, </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.616.1">datetime_gen</span></span></span></span><span class="kobospan" id="kobo.617.1">, the transformations allow us to have software that looks like this:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.618.1">&gt;&gt;&gt; total_time = datetime.timedelta(0) 
 
&gt;&gt;&gt; total_fuel = 0 
 
&gt;&gt;&gt; for row in datetime_gen: 
 
... </span><span class="kobospan" id="kobo.618.2">    total_time += row.engine_off - row.engine_on 
 
... </span><span class="kobospan" id="kobo.618.3">    total_fuel += ( 
 
... </span><span class="kobospan" id="kobo.618.4">        float(row.engine_on_fuel_height) - 
 
... </span><span class="kobospan" id="kobo.618.5">        float(row.engine_off_fuel_height) 
 
... </span><span class="kobospan" id="kobo.618.6">) 
 
 
 
&gt;&gt;&gt; print( 
 
... </span><span class="kobospan" id="kobo.618.7">f"{total_time.total_seconds()/60/60 = :.2f}, " 
 
... </span><span class="kobospan" id="kobo.618.8">f"{total_fuel = :.2f}")</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.619.1">We need to design a composite function that can create this </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.620.1">datetime_gen</span></span></span></span><span class="kobospan" id="kobo.621.1"> generator. </span><span id="x1-519015r1095"/></p>
</section>
<section data-number="0.12.3.2" id="how-to-do-it...-73">
<h2 class="likechapterhead" data-number="0.12.3.2"><span><span class="kobospan" id="kobo.622.1">9.3.2 </span></span> <span id="x1-5200002"/><span class="kobospan" id="kobo.623.1">How to do it...</span></h2>
<p class="normal"><span class="kobospan" id="kobo.624.1">We’ll decompose this into three separate mini-recipes:</span></p>
<ul class="calibre11">
<li class="calibre12"><p class="normal2"><span class="kobospan" id="kobo.625.1">Restructuring the rows.</span></p></li>
<li class="calibre7"><p class="normal2"><span class="kobospan" id="kobo.626.1">Excluding the header row.</span></p></li>
<li class="calibre7"><p class="normal2"><span class="kobospan" id="kobo.627.1">Creating more useful row objects.</span></p></li>
</ul>
<p class="normal1"><span class="kobospan" id="kobo.628.1">We’ll start with restructuring</span><span id="dx1-520001"/><span class="kobospan" id="kobo.629.1"> three physical lines into a logical row.</span></p>
<section data-number="0.12.3.2.1" id="restructuring-the-rows">
<h3 class="likesubsubsectionhead" data-number="0.12.3.2.1"><span id="x1-5210002"/><span class="kobospan" id="kobo.630.1">Restructuring the rows</span></h3>
<p class="normal"><span class="kobospan" id="kobo.631.1">We’ll start by creating a </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.632.1">row_merge()</span></span></span></span><span class="kobospan" id="kobo.633.1"> function to restructure</span><span id="dx1-521001"/><span class="kobospan" id="kobo.634.1"> the data:</span></p>
<ol class="calibre4">
<li class="calibre7"><div id="x1-521003x1" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.635.1">We’ll use a named tuple to define a type for the combined logical rows:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.636.1">from typing import NamedTuple 
 
 
 
class CombinedRow(NamedTuple): 
 
    # Line 1 
 
    date: str 
 
    engine_on_time: str 
 
    engine_on_fuel_height: str 
 
    # Line 2 
 
    filler_1: str 
 
    engine_off_time: str 
 
    engine_off_fuel_height: str 
 
    # Line 3 
 
    filler_2: str 
 
    other_notes: str 
 
    filler_3: str</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.637.1">The raw data has empty cells; we’ve called them </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.638.1">filler_1</span></span></span></span><span class="kobospan" id="kobo.639.1">, </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.640.1">filler_2</span></span></span></span><span class="kobospan" id="kobo.641.1">, and </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.642.1">filler_3</span></span></span></span><span class="kobospan" id="kobo.643.1">. </span><span class="kobospan" id="kobo.643.2">Preserving these junk columns can make it easier to debug problems.</span></p>
</div></li>
<li class="calibre7"><div id="x1-521021x2" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.644.1">The source rows created by a CSV reader will have a </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.645.1">list[str]</span></span></span></span><span class="kobospan" id="kobo.646.1"> type; we’ll provide an alias for this type, </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.647.1">RawRow.</span></span></span></span><span class="kobospan" id="kobo.648.1"> The function’s definition will accept an iterable of </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.649.1">RawRow</span></span></span></span><span class="kobospan" id="kobo.650.1"> instances. </span><span class="kobospan" id="kobo.650.2">It is an iterator over </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.651.1">CombinedRow</span></span></span></span><span class="kobospan" id="kobo.652.1"> objects:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.653.1">from typing import TypeAlias 
 
from collections.abc import Iterable, Iterator 
 
 
 
RawRow: TypeAlias = list[str] 
 
 
 
def row_merge( 
 
    source: Iterable[RawRow] 
 
) -&gt; Iterator[CombinedRow]:                                                                

                                                                     
     </span></code></pre>
</div></li>
<li class="calibre7"><div id="x1-521032x3" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.654.1">The body of the function will consume</span><span id="dx1-521033"/><span class="kobospan" id="kobo.655.1"> rows from the source</span><span id="dx1-521034"/><span class="kobospan" id="kobo.656.1"> iterator, skipping empty lines, building a cluster that defines a </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.657.1">CombinedRow</span></span></span></span><span class="kobospan" id="kobo.658.1"> object. </span><span class="kobospan" id="kobo.658.2">When the first column is non-empty, any previous cluster is complete, it is yielded, and a new cluster is started. </span><span class="kobospan" id="kobo.658.3">The very last cluster also needs to be yielded:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.659.1">
    cluster: RawRow = [] 
 
    for row in source: 
 
        if all(len(col) == 0 for col in row): 
 
            continue 
 
        elif len(row[0]) != 0: 
 
            # Non-empty column 1: line 1 
 
            if len(cluster) == 9: 
 
                yield CombinedRow(*cluster) 
 
            cluster = row.copy() 
 
        else: 
 
            # Empty column 1: line 2 or line 3 
 
            cluster.extend(row) 
 
    if len(cluster) == 9: 
 
        yield CombinedRow(*cluster)</span></code></pre>
</div></li>
</ol>
<p class="normal1"><span class="kobospan" id="kobo.660.1">This initial transformation can be used to convert a sequence of lines of CSV cell values into </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.661.1">CombinedRow</span></span></span></span><span class="kobospan" id="kobo.662.1"> objects where each of the field values from three separate rows have their own unique attributes.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.663.1">The first row output from this transformation will be a header row. </span><span class="kobospan" id="kobo.663.2">The next part is a function to drop this row.</span></p>
</section>
<section data-number="0.12.3.2.2" id="excluding-the-header-row">
<h3 class="likesubsubsectionhead" data-number="0.12.3.2.2"><span id="x1-5220002"/><span class="kobospan" id="kobo.664.1">Excluding the header row</span></h3>
<p class="normal"><span class="kobospan" id="kobo.665.1">The first three lines of text</span><span id="dx1-522001"/><span class="kobospan" id="kobo.666.1"> from the source CSV file will create a </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.667.1">CombinedRow</span></span></span></span><span class="kobospan" id="kobo.668.1"> object that’s not very useful. </span><span class="kobospan" id="kobo.668.2">We’ll exclude a row with labels instead of data:</span></p>
<ol class="calibre4">
<li class="calibre7"><div id="x1-522003x1" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.669.1">Define a function to work with an iterable collection of </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.670.1">CombinedRow</span></span></span></span><span class="kobospan" id="kobo.671.1"> objects, creating an iterator of </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.672.1">CombinedRow</span></span></span></span><span class="kobospan" id="kobo.673.1"> objects:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.674.1">def skip_header_date( 
 
    source: Iterable[CombinedRow] 
 
) -&gt; Iterator[CombinedRow]:</span></code></pre>
</div></li>
<li class="calibre7"><div id="x1-522009x2" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.675.1">The function’s body consumes</span><span id="dx1-522010"/><span class="kobospan" id="kobo.676.1"> each row of the source and yields the good rows. </span><span class="kobospan" id="kobo.676.2">It uses a </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.677.1">continue</span></span></span></span><span class="kobospan" id="kobo.678.1"> statement to reject the undesirable rows:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.679.1">  for row in source: 
 
    if row.date == "date": 
 
        continue 
 
    yield row</span></code></pre>
</div></li>
</ol>
<p class="normal1"><span class="kobospan" id="kobo.680.1">This can be combined with the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.681.1">row_merge()</span></span></span></span><span class="kobospan" id="kobo.682.1"> function shown in the previous recipe to provide an iterator over good data.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.683.1">There are several transformation steps required to make the merged data truly useful. </span><span class="kobospan" id="kobo.683.2">Next, we’ll look at one of these, creating proper </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.684.1">datetime.datetime</span></span></span></span><span class="kobospan" id="kobo.685.1"> objects.</span></p>
</section>
<section data-number="0.12.3.2.3" id="creating-more-useful-row-objects">
<h3 class="likesubsubsectionhead" data-number="0.12.3.2.3"><span id="x1-5230002"/><span class="kobospan" id="kobo.686.1">Creating more useful row objects</span></h3>
<p class="normal"><span class="kobospan" id="kobo.687.1">The dates and times in each row</span><span id="dx1-523001"/><span class="kobospan" id="kobo.688.1"> aren’t very useful as separate strings. </span><span class="kobospan" id="kobo.688.2">The function we’ll write can have a slightly different form than the previous two steps in this recipe because it applies to each row in isolation. </span><span class="kobospan" id="kobo.688.3">The single-row transformation looks like this:</span></p>
<ol class="calibre4">
<li class="calibre7"><div id="x1-523003x1" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.689.1">Define a new </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.690.1">NamedTuple</span></span></span></span><span class="kobospan" id="kobo.691.1"> class that specifies a more useful type for the time values:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.692.1">import datetime 
 
from typing import NamedTuple 
 
 
 
class DatetimeRow(NamedTuple): 
 
    date: datetime.date 
 
    engine_on: datetime.datetime 
 
    engine_on_fuel_height: str 
 
    engine_off: datetime.datetime 
 
    engine_off_fuel_height: str 
 
    other_notes: str</span></code></pre>
</div></li>
<li class="calibre7"><div id="x1-523016x2" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.693.1">Define a mapping function</span><span id="dx1-523017"/><span class="kobospan" id="kobo.694.1"> to convert one </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.695.1">CombinedRow</span></span></span></span><span class="kobospan" id="kobo.696.1"> instance</span><span id="dx1-523018"/><span class="kobospan" id="kobo.697.1"> into a single </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.698.1">DatetimeRow</span></span></span></span><span class="kobospan" id="kobo.699.1"> instance:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.700.1">def convert_datetime(row: CombinedRow) -&gt; DatetimeRow:</span></code></pre>
</div></li>
<li class="calibre7"><div id="x1-523022x3" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.701.1">The body of this function will perform a number of date-time computations and create a new </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.702.1">DatetimeRow</span></span></span></span><span class="kobospan" id="kobo.703.1"> instance:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.704.1">    travel_date = datetime.datetime.strptime( 
 
        row.date, "%m/%d/%y").date() 
 
    start_time = datetime.datetime.strptime( 
 
        row.engine_on_time, "%I:%M:%S %p").time() 
 
    start_datetime = datetime.datetime.combine( 
 
        travel_date, start_time) 
 
    end_time = datetime.datetime.strptime( 
 
        row.engine_off_time, "%I:%M:%S %p").time() 
 
    end_datetime = datetime.datetime.combine( 
 
        travel_date, end_time) 
 
 
 
    return DatetimeRow( 
 
        date=travel_date, 
 
        engine_on=start_datetime, 
 
        engine_off=end_datetime, 
 
        engine_on_fuel_height=row.engine_on_fuel_height, 
 
        engine_off_fuel_height=row.engine_off_fuel_height, 
 
        other_notes=row.other_notes 
 
    )</span></code></pre>
</div></li>
</ol>
<p class="normal1"><span class="kobospan" id="kobo.705.1">We can now stack the transformation functions to merge rows, exclude the header, and perform date time conversions. </span><span class="kobospan" id="kobo.705.2">The processing looks like this:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.706.1">&gt;&gt;&gt; row_gen = row_merge(log_rows) 
 
&gt;&gt;&gt; tail_gen = skip_header_date(row_gen) 
 
&gt;&gt;&gt; datetime_gen = (convert_datetime(row) for row in tail_gen)</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.707.1">We’ve decomposed the reformatting, filtering, and transformation problems into three separate functions. </span><span class="kobospan" id="kobo.707.2">Each of these three steps does a small part of the overall job. </span><span class="kobospan" id="kobo.707.3">We can test each of the three functions separately. </span><span class="kobospan" id="kobo.707.4">More important than being able to test is being able to fix or revise one step without completely</span><span id="dx1-523047"/><span class="kobospan" id="kobo.708.1"> breaking the entire stack of transformations. </span><span id="x1-523048r1097"/></p>
</section>
</section>
<section data-number="0.12.3.3" id="how-it-works...-73">
<h2 class="likechapterhead" data-number="0.12.3.3"><span><span class="kobospan" id="kobo.709.1">9.3.3 </span></span> <span id="x1-5240003"/><span class="kobospan" id="kobo.710.1">How it works...</span></h2>
<p class="normal"><span class="kobospan" id="kobo.711.1">When we write a generator function, the argument</span><span id="dx1-524001"/><span class="kobospan" id="kobo.712.1"> value can be a collection of items, or it can be any other kind of iterable source of items. </span><span class="kobospan" id="kobo.712.2">Since generator functions are iterators, it becomes possible to create a </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.713.1">pipeline </span></span><span class="kobospan" id="kobo.714.1">of generator functions by stacking them. </span><span class="kobospan" id="kobo.714.2">The results of one generator are the input to the next one in the stack.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.715.1">The </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.716.1">datetime_gen</span></span></span></span><span class="kobospan" id="kobo.717.1"> object created by this recipe is a composition of three separate generators. </span><span class="kobospan" id="kobo.717.2">A </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.718.1">for</span></span></span></span><span class="kobospan" id="kobo.719.1"> statement can gather values from the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.720.1">datetime_gen</span></span></span></span><span class="kobospan" id="kobo.721.1"> generator expression. </span><span class="kobospan" id="kobo.721.2">The body of that statement can print details and compute summaries of the objects being generated.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.722.1">This design emphasizes small, incremental operations at each stage. </span><span class="kobospan" id="kobo.722.2">Some stages of the pipeline will consume multiple source rows for a single result row, restructuring the data as it is processed. </span><span class="kobospan" id="kobo.722.3">Other stages consume and transform a single row, making them amenable to being described by generator expressions.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.723.1">The entire pipeline is driven by demand from the client. </span><span class="kobospan" id="kobo.723.2">Note that there’s no concurrency in this processing. </span><span class="kobospan" id="kobo.723.3">Each function is “suspended” at the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.724.1">yield</span></span></span></span><span class="kobospan" id="kobo.725.1"> statement until a client demands more data from it via the built-in </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.726.1">next()</span></span></span></span><span class="kobospan" id="kobo.727.1"> function.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.728.1">Most importantly, the individual transformation steps can be debugged and tested separately. </span><span class="kobospan" id="kobo.728.2">This decomposition can help to create more robust and reliable software. </span><span id="x1-524002r1110"/></p>
</section>
<section data-number="0.12.3.4" id="theres-more...-64">
<h2 class="likechapterhead" data-number="0.12.3.4"><span><span class="kobospan" id="kobo.729.1">9.3.4 </span></span> <span id="x1-5250004"/><span class="kobospan" id="kobo.730.1">There’s more...</span></h2>
<p class="normal"><span class="kobospan" id="kobo.731.1">There are a number of other conversions required to make this data useful. </span><span class="kobospan" id="kobo.731.2">We’ll want to transform the start and end timestamps into a duration. </span><span class="kobospan" id="kobo.731.3">We also need to transform the fuel height values into floating-point numbers instead of strings.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.732.1">We have a number of ways to handle these derived data computations:</span></p>
<ol class="calibre4">
<li class="calibre7"><div id="x1-525002x1" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.733.1">We can create additional transformation steps in our stack of generator functions. </span><span class="kobospan" id="kobo.733.2">This reflects an eager computation approach.</span></p>
</div></li>
<li class="calibre7"><div id="x1-525004x2" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.734.1">We can also add </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.735.1">@property</span></span></span></span><span class="kobospan" id="kobo.736.1"> methods to the class definition. </span><span class="kobospan" id="kobo.736.2">This is lazy computation; it’s only performed when the property value is required.</span></p>
</div></li>
</ol>
<p class="normal1"><span class="kobospan" id="kobo.737.1">To compute additional fuel height and volume values eagerly, we can apply the design pattern again. </span><span class="kobospan" id="kobo.737.2">First, define additional named tuple classes with the required fields. </span><span class="kobospan" id="kobo.737.3">Then, define a transformation function to convert height from a string to a float. </span><span class="kobospan" id="kobo.737.4">Also, define a transformation to convert height from inches to gallons. </span><span class="kobospan" id="kobo.737.5">These additional functions will be small and easy to test.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.738.1">We now have a sophisticated computation that’s defined in a number of small and (almost) completely independent chunks. </span><span class="kobospan" id="kobo.738.2">Each function does the work required to create only one row, keeping the overheads to a minimum. </span><span class="kobospan" id="kobo.738.3">We can modify one piece without having to think deeply about how the other pieces work. </span><span id="x1-525005r1111"/></p>
</section>
<section data-number="0.12.3.5" id="see-also-71">
<h2 class="likechapterhead" data-number="0.12.3.5"><span><span class="kobospan" id="kobo.739.1">9.3.5 </span></span> <span id="x1-5260005"/><span class="kobospan" id="kobo.740.1">See also</span></h2>
<ul class="calibre16">
<li class="calibre12"><p class="normal2"><span class="kobospan" id="kobo.741.1">See the </span><a href="ch013_split_000.xhtml#x1-5030001" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.742.1">Writing generator functions with the yield statement</span></span></a><span class="kobospan" id="kobo.743.1"> recipe for an introduction to generator functions.</span></p></li>
<li class="calibre7"><p class="normal2"><span class="kobospan" id="kobo.744.1">See the </span><a href="ch008_split_000.xhtml#x1-2400003" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.745.1">Slicing and dicing a list</span></span></a><span class="kobospan" id="kobo.746.1"> recipe in </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.747.1">Chapter</span></span><span class="cmti-10x-x"><span class="kobospan" id="kobo.748.1"> </span></span><a href="ch008_split_000.xhtml#x1-2240004" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.749.1">4</span></span></a><span class="kobospan" id="kobo.750.1">, for more information on the fuel consumption dataset.</span></p></li>
<li class="calibre7"><p class="normal2"><span class="kobospan" id="kobo.751.1">See the </span><a href="ch013_split_001.xhtml#x1-5440006" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.752.1">Combining the map and reduce transformations</span></span></a><span class="kobospan" id="kobo.753.1"> recipe for another way to combine operations.</span></p></li>
<li class="calibre7"><p class="normal2"><span class="kobospan" id="kobo.754.1">The </span><a href="ch013_split_000.xhtml#x1-5270004" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.755.1">Picking a subset – three ways to filter</span></span></a><span class="kobospan" id="kobo.756.1"> recipe covers the filter function in more detail.</span></p></li>
</ul>
<p class="normal1"><span id="x1-526001r1094"/></p>
</section>
</section>
<section data-number="0.12.4" id="picking-a-subset-three-ways-to-filter">
<h1 class="unnumbered" data-number="0.12.4"><span><span class="kobospan" id="kobo.757.1">9.4 </span></span> <span id="x1-5270004"/><span class="kobospan" id="kobo.758.1">Picking a subset – three ways to filter</span></h1>
<p class="normal"><span class="kobospan" id="kobo.759.1">Choosing a subset</span><span id="dx1-527001"/><span class="kobospan" id="kobo.760.1"> of relevant rows can be termed filtering a collection of data. </span><span class="kobospan" id="kobo.760.2">We can view a filter as rejecting bad rows or including the desirable rows. </span><span class="kobospan" id="kobo.760.3">There are several ways to apply a filtering function</span><span id="dx1-527002"/><span class="kobospan" id="kobo.761.1"> to a collection of data items.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.762.1">In the </span><a href="ch013_split_000.xhtml#x1-5180003" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.763.1">Using stacked generator expressions</span></span></a><span class="kobospan" id="kobo.764.1"> recipe, we wrote the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.765.1">skip_header_date()</span></span></span></span><span class="kobospan" id="kobo.766.1"> generator function to exclude some rows from a set of data. </span><span class="kobospan" id="kobo.766.2">The </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.767.1">skip_header_date()</span></span></span></span><span class="kobospan" id="kobo.768.1"> function combined two elements: a rule to pass or reject items, and a source of data. </span><span class="kobospan" id="kobo.768.2">This generator function had a general pattern that looks like this:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.769.1">from collections.abc import Iterable, Iterator 
 
from typing import TypeVar 
 
 
 
T = TypeVar("T")</span></code></pre>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.770.1">
 
 
def data_filter_iter( 
 
    source: Iterable[T] 
 
) -&gt; Iterator[T]: 
 
    for item in source: 
 
        if should_be_passed(item): 
 
            yield item</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.771.1">This </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.772.1">data_filter_iter()</span></span></span></span><span class="kobospan" id="kobo.773.1"> function’s type hints emphasize that it is an iterable that consumes items of a type, </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.774.1">T</span></span></span></span><span class="kobospan" id="kobo.775.1">, from an iterable source collection. </span><span class="kobospan" id="kobo.775.2">Some expression is applied to each item to determine if it’s valid. </span><span class="kobospan" id="kobo.775.3">This expression can be defined as a separate function. </span><span class="kobospan" id="kobo.775.4">We can define filters of considerable sophistication.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.776.1">The design pattern can be summarized as follows:</span></p>
<div class="math-display">
<span class="kobospan" id="kobo.777.1"><img alt="N = {x | x ∈ S if f(x)} " class="calibre9" src="../media/file60.png"/></span>
</div>
<p class="normal1"><span class="kobospan" id="kobo.778.1">The new collection, </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.779.1">N</span></span><span class="kobospan" id="kobo.780.1">, is each item, </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.781.1">x</span></span><span class="kobospan" id="kobo.782.1">, in the source, </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.783.1">S</span></span><span class="kobospan" id="kobo.784.1">, where a filter function, </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.785.1">f</span></span><span class="kobospan" id="kobo.786.1">(</span><span class="cmti-10x-x"><span class="kobospan" id="kobo.787.1">x</span></span><span class="kobospan" id="kobo.788.1">), is true. </span><span class="kobospan" id="kobo.788.2">This summary emphasizes the filter function, </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.789.1">f</span></span><span class="kobospan" id="kobo.790.1">(</span><span class="cmti-10x-x"><span class="kobospan" id="kobo.791.1">x</span></span><span class="kobospan" id="kobo.792.1">), separating it from minor technical details of consuming the source and producing the result.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.793.1">This mathematical summary suggests the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.794.1">for</span></span></span></span><span class="kobospan" id="kobo.795.1"> statement is little more than scaffolding code. </span><span class="kobospan" id="kobo.795.2">Because it’s less important than the filter rule, it can help to refactor a generator function and extract the filter from the other processing.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.796.1">Considering the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.797.1">for</span></span></span></span><span class="kobospan" id="kobo.798.1"> statement as scaffolding, how else can we apply a filter to each item of a collection? </span><span class="kobospan" id="kobo.798.2">There are two additional techniques we can use:</span></p>
<ul class="calibre11">
<li class="calibre12"><p class="normal2"><span class="kobospan" id="kobo.799.1">We can write a generator expression.</span></p></li>
<li class="calibre7"><p class="normal2"><span class="kobospan" id="kobo.800.1">We can use the built-in </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.801.1">filter()</span></span></span></span><span class="kobospan" id="kobo.802.1"> function.</span></p></li>
</ul>
<p class="normal1"><span class="kobospan" id="kobo.803.1">Both of these require refactoring</span><span id="dx1-527015"/><span class="kobospan" id="kobo.804.1"> the generator</span><span id="dx1-527016"/><span class="kobospan" id="kobo.805.1"> function — </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.806.1">skip_header_date()</span></span></span></span><span class="kobospan" id="kobo.807.1">, shown earlier in the </span><a href="ch013_split_000.xhtml#x1-5180003" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.808.1">Using stacked generator expressions</span></span></a><span class="kobospan" id="kobo.809.1"> recipe — to extract the decision-making expression, separate from the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.810.1">for</span></span></span></span><span class="kobospan" id="kobo.811.1"> and </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.812.1">if</span></span></span></span><span class="kobospan" id="kobo.813.1"> scaffolding around it. </span><span class="kobospan" id="kobo.813.2">From this function, we can then move to creating a generator expression, and using the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.814.1">filter()</span></span></span></span><span class="kobospan" id="kobo.815.1"> function. </span><span id="x1-527017r1112"/></p>
<section data-number="0.12.4.1" id="getting-ready-73">
<h2 class="likechapterhead" data-number="0.12.4.1"><span><span class="kobospan" id="kobo.816.1">9.4.1 </span></span> <span id="x1-5280001"/><span class="kobospan" id="kobo.817.1">Getting ready</span></h2>
<p class="normal"><span class="kobospan" id="kobo.818.1">In this recipe, we’ll look at the fuel consumption data from the </span><a href="ch013_split_000.xhtml#x1-5180003" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.819.1">Using stacked</span></span> <span class="cmti-10x-x"><span class="kobospan" id="kobo.820.1">generator expressions</span></span></a><span class="kobospan" id="kobo.821.1"> recipe in this chapter. </span><span class="kobospan" id="kobo.821.2">For details of this data, see the </span><a href="ch008_split_000.xhtml#x1-2400003" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.822.1">Slicing and dicing a list</span></span></a><span class="kobospan" id="kobo.823.1"> recipe in </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.824.1">Chapter</span></span><span class="cmti-10x-x"><span class="kobospan" id="kobo.825.1"> </span></span><a href="ch008_split_000.xhtml#x1-2240004" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.826.1">4</span></span></a><span class="kobospan" id="kobo.827.1">.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.828.1">We used two generator functions. </span><span class="kobospan" id="kobo.828.2">The first, </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.829.1">row_merge()</span></span></span></span><span class="kobospan" id="kobo.830.1">, restructured the physical lines into logical rows. </span><span class="kobospan" id="kobo.830.2">A named tuple, </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.831.1">CombinedRow</span></span></span></span><span class="kobospan" id="kobo.832.1">, was used to provide a more useful structure to the row data. </span><span class="kobospan" id="kobo.832.2">The second generator function, </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.833.1">skip_header_date()</span></span></span></span><span class="kobospan" id="kobo.834.1">, rejected the heading rows of the data, passing the useful data rows.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.835.1">We’ll rewrite the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.836.1">skip_header_date()</span></span></span></span><span class="kobospan" id="kobo.837.1"> function to demonstrate three distinct approaches to extracting useful data. </span><span id="x1-528001r1116"/></p>
</section>
<section data-number="0.12.4.2" id="how-to-do-it...-74">
<h2 class="likechapterhead" data-number="0.12.4.2"><span><span class="kobospan" id="kobo.838.1">9.4.2 </span></span> <span id="x1-5290002"/><span class="kobospan" id="kobo.839.1">How to do it...</span></h2>
<p class="normal"><span class="kobospan" id="kobo.840.1">The first part of this recipe will refactor the “good data” rule out of the generator function to make it more widely useful.</span></p>
<ol class="calibre4">
<li class="calibre7"><div id="x1-529002x1" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.841.1">Start with a draft version of a generator function with the following outline:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.842.1">def skip_header_date( 
 
    source: Iterable[CombinedRow] 
 
) -&gt; Iterator[CombinedRow]: 
 
  for row in source: 
 
    if row.date == "date": 
 
        continue 
 
    yield row</span></code></pre>
</div></li>
<li class="calibre7"><div id="x1-529012x2" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.843.1">The expression in the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.844.1">if</span></span></span></span><span class="kobospan" id="kobo.845.1"> statement</span><span id="dx1-529013"/><span class="kobospan" id="kobo.846.1"> can be refactored</span><span id="dx1-529014"/><span class="kobospan" id="kobo.847.1"> into a function that can be applied to a single row of the data, producing a bool value:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.848.1">def pass_non_date(row: CombinedRow) -&gt; bool: 
 
    return row.date != "date"</span></code></pre>
</div></li>
<li class="calibre7"><div id="x1-529019x3" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.849.1">The original generator function can now be simplified:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.850.1">def skip_header_date_iter( 
 
    source: Iterable[CombinedRow] 
 
) -&gt; Iterator[CombinedRow]: 
 
    for item in source: 
 
        if pass_non_date(item): 
 
            yield item</span></code></pre>
</div></li>
</ol>
<p class="normal1"><span class="kobospan" id="kobo.851.1">The </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.852.1">pass_non_date()</span></span></span></span><span class="kobospan" id="kobo.853.1"> function can be used in three ways. </span><span class="kobospan" id="kobo.853.2">As shown here, it can be used by a generator function. </span><span class="kobospan" id="kobo.853.3">It can also be used in a generator expression, and with the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.854.1">filter()</span></span></span></span><span class="kobospan" id="kobo.855.1"> function. </span><span class="kobospan" id="kobo.855.2">Next, we’ll look at writing an expression.</span></p>
<section data-number="0.12.4.2.1" id="using-a-filter-in-a-generator-expression">
<h3 class="likesubsubsectionhead" data-number="0.12.4.2.1"><span id="x1-5300002"/><span class="kobospan" id="kobo.856.1">Using a filter in a generator expression</span></h3>
<p class="normal"><span class="kobospan" id="kobo.857.1">A generator expression includes</span><span id="dx1-530001"/><span class="kobospan" id="kobo.858.1"> three parts – the item, a </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.859.1">for</span></span></span></span><span class="kobospan" id="kobo.860.1"> clause, and an</span><span id="dx1-530002"/> <span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.861.1">if</span></span></span></span><span class="kobospan" id="kobo.862.1"> clause – all enclosed by </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.863.1">()</span></span></span></span><span class="kobospan" id="kobo.864.1">:</span></p>
<ol class="calibre4">
<li class="calibre7"><div id="x1-530004x1" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.865.1">Start with a </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.866.1">for</span></span></span></span><span class="kobospan" id="kobo.867.1"> clause that assigns objects to a variable. </span><span class="kobospan" id="kobo.867.2">This source comes from some iterable collection, which is called </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.868.1">source</span></span></span></span><span class="kobospan" id="kobo.869.1"> in this example:</span></p>
<pre class="programlisting" id="listing-44"><code class="calibre13"><span class="kobospan" id="kobo.870.1">(... </span><span class="kobospan" id="kobo.870.2">for item in source)</span></code></pre>
</div></li>
<li class="calibre7"><div id="x1-530007x2" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.871.1">Because this is a filter, the result expression should be the variable from the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.872.1">for</span></span></span></span><span class="kobospan" id="kobo.873.1"> clause:</span></p>
<pre class="programlisting" id="listing-45"><code class="calibre13"><span class="kobospan" id="kobo.874.1">(item for item in source)</span></code></pre>
</div></li>
<li class="calibre7"><div id="x1-530010x3" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.875.1">Write an </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.876.1">if</span></span></span></span><span class="kobospan" id="kobo.877.1"> clause using the filter rule function, </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.878.1">pass_non_date()</span></span></span></span><span class="kobospan" id="kobo.879.1">:</span></p>
<pre class="programlisting" id="listing-46"><code class="calibre13"><span class="kobospan" id="kobo.880.1">(item for item in source if pass_non_date(source))</span></code></pre>
</div></li>
<li class="calibre7"><div id="x1-530013x4" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.881.1">This generator expression</span><span id="dx1-530014"/><span class="kobospan" id="kobo.882.1"> can be the return</span><span id="dx1-530015"/><span class="kobospan" id="kobo.883.1"> value from a function</span><span id="dx1-530016"/><span class="kobospan" id="kobo.884.1"> that provides suitable type hints for the source</span><span id="dx1-530017"/><span class="kobospan" id="kobo.885.1"> and the resulting expression. </span><span class="kobospan" id="kobo.885.2">Here’s the entire function, since it’s so small:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.886.1">def skip_header_gen( 
 
    source: Iterable[CombinedRow] 
 
) -&gt; Iterator[CombinedRow]: 
 
    return ( 
 
        item 
 
        for item in source 
 
        if pass_non_date(item) 
 
    )</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.887.1">This function returns the result of the generator expression. </span><span class="kobospan" id="kobo.887.2">The function doesn’t do very much, but it does applying a name and a set of type hints to the expression.</span></p>
</div></li>
</ol>
<p class="normal1"><span class="kobospan" id="kobo.888.1">The </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.889.1">skip_header_gen()</span></span></span></span><span class="kobospan" id="kobo.890.1"> function uses a generator expression that applies the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.891.1">pass_non_date()</span></span></span></span><span class="kobospan" id="kobo.892.1"> function to each item in the source collection to determine whether it passes and is kept, or whether it is rejected.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.893.1">The results are identical to the original </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.894.1">skip_header_date()</span></span></span></span><span class="kobospan" id="kobo.895.1"> function, shown above.</span></p>
</section>
<section data-number="0.12.4.2.2" id="using-the-filter-function">
<h3 class="likesubsubsectionhead" data-number="0.12.4.2.2"><span id="x1-5310002"/><span class="kobospan" id="kobo.896.1">Using the filter() function</span></h3>
<p class="normal"><span class="kobospan" id="kobo.897.1">Using the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.898.1">filter()</span></span></span></span><span class="kobospan" id="kobo.899.1"> function</span><span id="dx1-531001"/><span class="kobospan" id="kobo.900.1"> includes two parts – the decision function and the source of data – as arguments:</span></p>
<ol class="calibre4">
<li class="calibre7"><div id="x1-531003x1" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.901.1">Use the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.902.1">filter()</span></span></span></span><span class="kobospan" id="kobo.903.1"> function to apply the function to the source data:</span></p>
<pre class="programlisting" id="listing-47"><code class="calibre13"><span class="kobospan" id="kobo.904.1">filter(pass_non_date, source)</span></code></pre>
</div></li>
</ol>
<p class="normal1"><span class="kobospan" id="kobo.905.1">The </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.906.1">filter()</span></span></span></span><span class="kobospan" id="kobo.907.1"> function is an iterator that applies the given function, </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.908.1">pass_non_date()</span></span></span></span><span class="kobospan" id="kobo.909.1"> as a rule to pass or reject each item</span><span id="dx1-531005"/><span class="kobospan" id="kobo.910.1"> from the given iterable, </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.911.1">data</span></span></span></span><span class="kobospan" id="kobo.912.1">. </span><span class="kobospan" id="kobo.912.2">It yields the rows for which the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.913.1">pass_non_date()</span></span></span></span><span class="kobospan" id="kobo.914.1"> function returns </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.915.1">True</span></span></span></span><span class="kobospan" id="kobo.916.1">.</span></p>
<div class="tipbox" id="tcolobox-20">
<div class="note">
<p class="normal1"><span class="kobospan" id="kobo.917.1">It’s important to note that the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.918.1">pass_non_date</span></span></span></span><span class="kobospan" id="kobo.919.1"> name without </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.920.1">()</span></span></span></span><span class="kobospan" id="kobo.921.1"> is a reference to a function object.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.922.1">It’s a common error to think the function must be evaluated, and include extra, unnecessary uses of </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.923.1">()</span></span></span></span><span class="kobospan" id="kobo.924.1">.</span></p>
</div>
</div>
<p class="normal1"><span id="x1-531006r1117"/></p>
</section>
</section>
<section data-number="0.12.4.3" id="how-it-works...-74">
<h2 class="likechapterhead" data-number="0.12.4.3"><span><span class="kobospan" id="kobo.925.1">9.4.3 </span></span> <span id="x1-5320003"/><span class="kobospan" id="kobo.926.1">How it works...</span></h2>
<p class="normal"><span class="kobospan" id="kobo.927.1">A generator expression must include</span><span id="dx1-532001"/><span class="kobospan" id="kobo.928.1"> a </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.929.1">for</span></span></span></span><span class="kobospan" id="kobo.930.1"> clause to provide</span><span id="dx1-532002"/><span class="kobospan" id="kobo.931.1"> a source of data items. </span><span class="kobospan" id="kobo.931.2">The optional </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.932.1">if</span></span></span></span><span class="kobospan" id="kobo.933.1"> clause can apply a condition that preserves some items while rejecting others. </span><span class="kobospan" id="kobo.933.2">Placing a filter condition in an </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.934.1">if</span></span></span></span><span class="kobospan" id="kobo.935.1"> clause can make the expression clear and expressive of the algorithm.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.936.1">Generator expressions have an important limitation. </span><span class="kobospan" id="kobo.936.2">As expressions, they cannot use statement-oriented features of Python. </span><span class="kobospan" id="kobo.936.3">The </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.937.1">try-except</span></span></span></span><span class="kobospan" id="kobo.938.1"> statement, used to handle exceptional data conditions, is often helpful. </span><span id="x1-532003r1124"/></p>
</section>
<section data-number="0.12.4.4" id="theres-more...-65">
<h2 class="likechapterhead" data-number="0.12.4.4"><span><span class="kobospan" id="kobo.939.1">9.4.4 </span></span> <span id="x1-5330004"/><span class="kobospan" id="kobo.940.1">There’s more...</span></h2>
<p class="normal"><span class="kobospan" id="kobo.941.1">Sometimes, it’s difficult to write a simple rule to define the valid data or reject the invalid data. </span><span class="kobospan" id="kobo.941.2">In many cases, it may be impossible to use a simple string comparison to identify rows to reject. </span><span class="kobospan" id="kobo.941.3">This happens when a file is filled with extraneous information; manually prepared spreadsheets suffer from this. </span><span class="kobospan" id="kobo.941.4">It some cases, there’s no trivial regular expression that helps to characterize valid data.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.942.1">We can often encounter data where the easiest way to establish validity is to attempt a conversion, and transform the presence or absence of an exception into a Boolean condition.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.943.1">Consider the following function to ascertain if a row of data has a valid date:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.944.1">import datetime 
 
 
 
def row_has_date(row: CombinedRow) -&gt; bool: 
 
    try: 
 
        datetime.datetime.strptime(row.date, "%m/%d/%y") 
 
        return True 
 
    except ValueError as ex: 
 
        return False</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.945.1">This will attempt a conversion of a date. </span><span class="kobospan" id="kobo.945.2">It will reject invalid strings of characters that fail to follow the essential format rule. </span><span class="kobospan" id="kobo.945.3">It will also reject </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.946.1">2/31/24</span></span></span></span><span class="kobospan" id="kobo.947.1">; while the string of digits is valid, this is not a real date. </span><span id="x1-533010r1125"/></p>
</section>
<section data-number="0.12.4.5" id="see-also-72">
<h2 class="likechapterhead" data-number="0.12.4.5"><span><span class="kobospan" id="kobo.948.1">9.4.5 </span></span> <span id="x1-5340005"/><span class="kobospan" id="kobo.949.1">See also</span></h2>
<ul class="calibre16">
<li class="calibre12"><p class="normal2"><span class="kobospan" id="kobo.950.1">In the </span><a href="ch013_split_000.xhtml#x1-5180003" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.951.1">Using stacked generator expressions</span></span></a><span class="kobospan" id="kobo.952.1"> recipe earlier in this chapter, we placed a function like this in a stack of generators. </span><span class="kobospan" id="kobo.952.2">We built a composite function from a number of individual mapping and filtering operations written as generator functions.</span></p></li>
</ul>
<p class="normal1"><span id="x1-534001r1113"/></p>
</section>
</section>
<section data-number="0.12.5" id="summarizing-a-collection-how-to-reduce">
<h1 class="unnumbered" data-number="0.12.5"><span><span class="kobospan" id="kobo.953.1">9.5 </span></span> <span id="x1-5350005"/><span class="kobospan" id="kobo.954.1">Summarizing a collection – how to reduce</span></h1>
<p class="normal"><span class="kobospan" id="kobo.955.1">A reduction is the generalized</span><span id="dx1-535001"/><span class="kobospan" id="kobo.956.1"> concept behind computing a summmary like the total or the maximum of a collection of numbers. </span><span class="kobospan" id="kobo.956.2">Computing statistical measures like mean or variance are also reductions. </span><span class="kobospan" id="kobo.956.3">In this recipe, we’ll look at several summarization or reduction techniques.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.957.1">In the introduction to this chapter, we noted that there are three processing patterns that Python supports elegantly: map, filter, and reduce. </span><span class="kobospan" id="kobo.957.2">We saw examples of mapping in the </span><a href="ch013_split_000.xhtml#x1-5090002" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.958.1">Applying transformations to a collection</span></span></a><span class="kobospan" id="kobo.959.1"> recipe and examples of filtering in the </span><a href="ch013_split_000.xhtml#x1-5270004" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.960.1">Picking a subset – three ways to filter</span></span></a><span class="kobospan" id="kobo.961.1"> recipe.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.962.1">The third common pattern is reduction. </span><span class="kobospan" id="kobo.962.2">In the </span><a href="ch011_split_000.xhtml#x1-3890003" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.963.1">Designing classes with lots</span></span> <span class="cmti-10x-x"><span class="kobospan" id="kobo.964.1">of processing</span></span></a><span class="kobospan" id="kobo.965.1"> and the </span><a href="ch011_split_001.xhtml#x1-4250009" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.966.1">Extending a built-in collection – a list that does</span></span> <span class="cmti-10x-x"><span class="kobospan" id="kobo.967.1">statistics</span></span></a><span class="kobospan" id="kobo.968.1"> recipes, we looked at class definitions that computed a number of statistical values. </span><span class="kobospan" id="kobo.968.2">These definitions relied — almost exclusively — on the built-in </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.969.1">sum()</span></span></span></span><span class="kobospan" id="kobo.970.1"> function. </span><span class="kobospan" id="kobo.970.2">This is one of the more common reduce operations.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.971.1">In this recipe, we’ll look at a way to generalize summation, leading to ways to write a number of different kinds of reductions that are similar. </span><span class="kobospan" id="kobo.971.2">Generalizing the concept of reduction will let us build on a reliable foundation to create more sophisticated algorithms. </span><span id="x1-535002r1127"/></p>
</section>
</section>


<section data-number="0.12" id="chapter-9-functional-programming-features">
<section data-number="0.12.5" id="summarizing-a-collection-how-to-reduce">
<section data-number="0.12.5.1" id="getting-ready-74">
<h2 class="likechapterhead" data-number="0.12.5.1"><span><span class="kobospan" id="kobo.972.1">9.5.1 </span></span> <span id="x1-5360001"/><span class="kobospan" id="kobo.973.1">Getting ready</span></h2>
<p class="normal"><span class="kobospan" id="kobo.974.1">Some of the most common reduce operations</span><span id="dx1-536001"/><span class="kobospan" id="kobo.975.1"> are the sum, minimum, maximum. </span><span class="kobospan" id="kobo.975.2">These reductions are so common, they’re built in. </span><span class="kobospan" id="kobo.975.3">The average and variance, on the other hand, are reductions defined in the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.976.1">statistics</span></span></span></span><span class="kobospan" id="kobo.977.1"> module. </span><span class="kobospan" id="kobo.977.2">The </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.978.1">math</span></span></span></span><span class="kobospan" id="kobo.979.1"> module has a variant on sum, </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.980.1">fsum(),</span></span></span></span><span class="kobospan" id="kobo.981.1"> that works particularly well for collections of floating-point values.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.982.1">Summations are the backbone of financial reporting. </span><span class="kobospan" id="kobo.982.2">It is the essence of what a spreadsheet has been used for since the days of doing financial reports using pen and paper.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.983.1">The mathematics of summation help us to see how an operator is used to convert a collection of values into a single value. </span><span class="kobospan" id="kobo.983.2">Here’s a way to think of the mathematical definition of the sum function using an operator, +, applied to the values in a collection, </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.984.1">C </span></span><span class="kobospan" id="kobo.985.1">= </span><span><span class="kobospan" id="kobo.986.1">{</span></span><span class="cmti-10x-x"><span class="kobospan" id="kobo.987.1">c</span></span><sub class="calibre24"><span class="cmr1"><span class="kobospan" id="kobo.988.1">0</span></span></sub><span class="cmti-10x-x"><span class="kobospan" id="kobo.989.1">,c</span></span><sub class="calibre24"><span class="cmr1"><span class="kobospan" id="kobo.990.1">1</span></span></sub><span class="cmti-10x-x"><span class="kobospan" id="kobo.991.1">,c</span></span><sub class="calibre24"><span class="cmr1"><span class="kobospan" id="kobo.992.1">2</span></span></sub><span class="cmti-10x-x"><span class="kobospan" id="kobo.993.1">,</span></span><span class="cmti-10x-x"><span class="kobospan" id="kobo.994.1">…</span></span><span class="cmti-10x-x"><span class="kobospan" id="kobo.995.1">,c</span></span><sub class="calibre24"><span class="cmmi"><span class="kobospan" id="kobo.996.1">n</span></span></sub><span><span class="kobospan" id="kobo.997.1">}</span></span><span class="kobospan" id="kobo.998.1">:</span></p>
<div class="math-display">
<span class="kobospan" id="kobo.999.1"><img alt="∑ ci = c0 + c1 + c2 + ⋅⋅⋅+ cn + 0 ci∈C " class="calibre9" src="../media/file61.png"/></span>
</div>
<p class="normal1"><span class="kobospan" id="kobo.1000.1">We’ve expanded the definition of sum by </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.1001.1">folding </span></span><span class="kobospan" id="kobo.1002.1">the + operator into the sequence of values in </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.1003.1">C</span></span><span class="kobospan" id="kobo.1004.1">.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.1005.1">Folding involves two items: a binary operator and a base value. </span><span class="kobospan" id="kobo.1005.2">For sum, the operator was + and the base value was zero. </span><span class="kobospan" id="kobo.1005.3">For product, the operator is </span><span><span class="kobospan" id="kobo.1006.1">× </span></span><span class="kobospan" id="kobo.1007.1">and the base value is one. </span><span class="kobospan" id="kobo.1007.2">The base value needs to be the identity element for the given operator.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.1008.1">We can apply this concept to many algorithms, potentially simplifying the definition. </span><span class="kobospan" id="kobo.1008.2">In this recipe, we’ll define a product function. </span><span class="kobospan" id="kobo.1008.3">This is the </span><span class="kobospan" id="kobo.1009.1"><img alt="∏ " class="math" src="../media/file62.png"/></span><span class="kobospan" id="kobo.1010.1"> operator, similar to the </span><span class="kobospan" id="kobo.1011.1"><img alt="∑ " class="math" src="../media/file63.png"/></span><span class="kobospan" id="kobo.1012.1"> operator. </span><span id="x1-536002r1129"/></p>
</section>
<section data-number="0.12.5.2" id="how-to-do-it...-75">
<h2 class="likechapterhead" data-number="0.12.5.2"><span><span class="kobospan" id="kobo.1013.1">9.5.2 </span></span> <span id="x1-5370002"/><span class="kobospan" id="kobo.1014.1">How to do it...</span></h2>
<p class="normal"><span class="kobospan" id="kobo.1015.1">Here’s how we define a reduction</span><span id="dx1-537001"/><span class="kobospan" id="kobo.1016.1"> that implements product of a collection of numbers:</span></p>
<ol class="calibre4">
<li class="calibre7"><div id="x1-537003x1" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.1017.1">Import the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1018.1">reduce()</span></span></span></span><span class="kobospan" id="kobo.1019.1">) function from the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1020.1">functools</span></span></span></span><span class="kobospan" id="kobo.1021.1"> module:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.1022.1">from functools import reduce</span></code></pre>
</div></li>
<li class="calibre7"><div id="x1-537007x2" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.1023.1">Pick the operator. </span><span class="kobospan" id="kobo.1023.2">For sum, it’s +. </span><span class="kobospan" id="kobo.1023.3">For product, it will be </span><span><span class="kobospan" id="kobo.1024.1">×</span></span><span class="kobospan" id="kobo.1025.1">. </span><span class="kobospan" id="kobo.1025.2">These can be defined in a variety of ways. </span><span class="kobospan" id="kobo.1025.3">Here’s the long version. </span><span class="kobospan" id="kobo.1025.4">Other ways to define the necessary binary operators will be shown later:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.1026.1">def mul(a: int, b: int) -&gt; int: 
 
    return a * b</span></code></pre>
</div></li>
<li class="calibre7"><div id="x1-537012x3" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.1027.1">Pick the base value required. </span><span class="kobospan" id="kobo.1027.2">The additive identity value for sum is zero. </span><span class="kobospan" id="kobo.1027.3">The multiplicative identity for a product is one:</span></p>
<pre class="programlisting" id="listing-48"><code class="calibre13"><span class="kobospan" id="kobo.1028.1">def prod(values: Iterable[float]) -&gt; float: 
 
    return reduce(mul, values, 1)</span></code></pre>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.1029.1">
def prod(values: Iterable[int]) -&gt; int: 
 
    return reduce(mul, values, 1)</span></code></pre>
</div></li>
</ol>
<p class="normal1"><span class="kobospan" id="kobo.1030.1">We can use this </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1031.1">prod()</span></span></span></span><span class="kobospan" id="kobo.1032.1"> function to define other functions. </span><span class="kobospan" id="kobo.1032.2">One example is the factorial function. </span><span class="kobospan" id="kobo.1032.3">It looks like this:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.1033.1">def factorial(n: int) -&gt; int: 
 
    return prod(range(1, n+1))</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.1034.1">How many six-card cribbage hands are possible? </span><span class="kobospan" id="kobo.1034.2">The binomial calculation uses the factorial function to compute the number of ways 6 cards can be extracted from a 52 card deck:</span></p>
<div class="math-display">
<span class="kobospan" id="kobo.1035.1"><img alt="( ) 52 = ----52!--- 6 6!(52− 6)! " class="calibre9" src="../media/file64.png"/></span>
</div>
<p class="normal1"><span class="kobospan" id="kobo.1036.1">Here’s a Python implementation:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.1037.1">&gt;&gt;&gt; factorial(52) // (factorial(6) * factorial(52 - 6)) 
 
20358520</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.1038.1">For any given shuffle, there are about 20 million different possible cribbage hands we might see. </span><span id="x1-537024r1130"/></p>
</section>
<section data-number="0.12.5.3" id="how-it-works...-75">
<h2 class="likechapterhead" data-number="0.12.5.3"><span><span class="kobospan" id="kobo.1039.1">9.5.3 </span></span> <span id="x1-5380003"/><span class="kobospan" id="kobo.1040.1">How it works...</span></h2>
<p class="normal"><span class="kobospan" id="kobo.1041.1">The </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1042.1">reduce()</span></span></span></span><span class="kobospan" id="kobo.1043.1"> function behaves</span><span id="dx1-538001"/><span class="kobospan" id="kobo.1044.1"> as though it has this definition:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.1045.1">T = TypeVar("T") 
 
 
 
def my_reduce( 
 
    fn: Callable[[T, T], T], 
 
    source: Iterable[T], 
 
    initial: T | None = None 
 
) -&gt; T:</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.1046.1">The type hints shows how there has to be a unifying type, </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1047.1">T</span></span></span></span><span class="kobospan" id="kobo.1048.1">, that applies to the operator being folded, and the initial value for the folding. </span><span class="kobospan" id="kobo.1048.2">The given function, </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1049.1">fn()</span></span></span></span><span class="kobospan" id="kobo.1050.1">, must combine two values of type </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1051.1">T</span></span></span></span><span class="kobospan" id="kobo.1052.1"> and return another value of the same type </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1053.1">T</span></span></span></span><span class="kobospan" id="kobo.1054.1">. </span><span class="kobospan" id="kobo.1054.2">The result of the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1055.1">reduce()</span></span></span></span><span class="kobospan" id="kobo.1056.1"> function will be a value of this type also.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.1057.1">Furthermore, in Python, the reduce operation will iterate through the values from left to right. </span><span class="kobospan" id="kobo.1057.2">It will apply the given binary function, </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1058.1">fn()</span></span></span></span><span class="kobospan" id="kobo.1059.1">, between the previous result and the next item from the source collection. </span><span class="kobospan" id="kobo.1059.2">This additional detail is important when thinking about non-commutative operators like subtraction or division. </span><span id="x1-538010r1136"/></p>
</section>
<section data-number="0.12.5.4" id="theres-more...-66">
<h2 class="likechapterhead" data-number="0.12.5.4"><span><span class="kobospan" id="kobo.1060.1">9.5.4 </span></span> <span id="x1-5390004"/><span class="kobospan" id="kobo.1061.1">There’s more...</span></h2>
<p class="normal"><span class="kobospan" id="kobo.1062.1">We’ll look at three additional topics. </span><span class="kobospan" id="kobo.1062.2">First, ways to define the operation. </span><span class="kobospan" id="kobo.1062.3">After that, we’ll look at applying reduce to Boolean values in </span><a href="ch013_split_001.xhtml#x1-5410004" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.1063.1">Logical reductions: any</span></span> <span class="cmti-10x-x"><span class="kobospan" id="kobo.1064.1">and all</span></span></a><span class="kobospan" id="kobo.1065.1">. </span><span class="kobospan" id="kobo.1065.2">Finally, in </span><a href="ch013_split_001.xhtml#x1-5420004" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.1066.1">Identity elements</span></span></a><span class="kobospan" id="kobo.1067.1">, we’ll look at the identity elements used by various operators.</span></p>
<section data-number="0.12.5.4.1" id="operation-definition">
<h3 class="likesubsubsectionhead" data-number="0.12.5.4.1"><span id="x1-5400004"/><span class="kobospan" id="kobo.1068.1">Operation definition</span></h3>
<p class="normal"><span class="kobospan" id="kobo.1069.1">When designing a new application</span><span id="dx1-540001"/><span class="kobospan" id="kobo.1070.1"> for the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1071.1">reduce()</span></span></span></span><span class="kobospan" id="kobo.1072.1"> function, we need to provide a binary operator. </span><span class="kobospan" id="kobo.1072.2">There are three ways to define the necessary binary operator. </span><span class="kobospan" id="kobo.1072.3">First, we can use a complete function definition, as shown above in the recipe. </span><span class="kobospan" id="kobo.1072.4">There are two other choices. </span><span class="kobospan" id="kobo.1072.5">We can use a lambda object instead of a complete function:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.1073.1">from collections.abc import Callable</span></code></pre>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.1074.1">lmul: Callable[[int, int], int] = lambda a, b: a * b</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.1075.1">A lambda object is an anonymous function boiled down to just two essential elements: the parameters and the return expression. </span><span class="kobospan" id="kobo.1075.2">There are no statements inside a lambda, only a single expression.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.1076.1">We assigned the lambda object to a variable, </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1077.1">lmul</span></span></span></span><span class="kobospan" id="kobo.1078.1">, so that we can use the expression </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1079.1">lmul(2,</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1080.1"> 3)</span></span></span></span><span class="kobospan" id="kobo.1081.1"> to apply the lambda object to argument values.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.1082.1">When the operation is one of Python’s built-in operators, we have another choice – import the definition from the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1083.1">operator</span></span></span></span><span class="kobospan" id="kobo.1084.1"> module:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.1085.1">from itertools import takewhile</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.1086.1">This works nicely for all the built-in arithmetic operators.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.1087.1">It’s essential to consider the complexity of the operator being used to reduce. </span><span class="kobospan" id="kobo.1087.2">Performing a reduce operation increases an operation’s complexity by a factor of </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.1088.1">n</span></span><span class="kobospan" id="kobo.1089.1">. </span><span class="kobospan" id="kobo.1089.2">An operation that’s </span><span class="cmbx-10x-x"><span class="kobospan" id="kobo.1090.1">O(1)</span></span><span class="kobospan" id="kobo.1091.1"> becomes </span><span class="cmbx-10x-x"><span class="kobospan" id="kobo.1092.1">O(n)</span></span><span class="kobospan" id="kobo.1093.1"> when applied to </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.1094.1">n </span></span><span class="kobospan" id="kobo.1095.1">items in a collection. </span><span class="kobospan" id="kobo.1095.2">For the operators we’ve shown, like </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1096.1">add</span></span></span></span><span class="kobospan" id="kobo.1097.1"> and </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1098.1">mul</span></span></span></span><span class="kobospan" id="kobo.1099.1">, this fits our expectations. </span><span class="kobospan" id="kobo.1099.2">An operator with more complexity than </span><span class="cmbx-10x-x"><span class="kobospan" id="kobo.1100.1">O(1)</span></span><span class="kobospan" id="kobo.1101.1"> can turn into a performance nightmare.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.1102.1">In the next section, we’ll look at the logical reduction functions.</span></p>
</section>
<section data-number="0.12.5.4.2" id="logical-reductions-any-and-all">
<h3 class="likesubsubsectionhead" data-number="0.12.5.4.2"><span id="x1-5410004"/><span class="kobospan" id="kobo.1103.1">Logical reductions: any and all</span></h3>
<p class="normal"><span class="kobospan" id="kobo.1104.1">Conceptually, it seems like we should</span><span id="dx1-541001"/><span class="kobospan" id="kobo.1105.1"> be able to do </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1106.1">reduce()</span></span></span></span><span class="kobospan" id="kobo.1107.1"> operations using the Boolean operators </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1108.1">and</span></span></span></span><span class="kobospan" id="kobo.1109.1"> and </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1110.1">or</span></span></span></span><span class="kobospan" id="kobo.1111.1">. </span><span class="kobospan" id="kobo.1111.2">It turns out this involves some additional consideration.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.1112.1">Python’s Boolean operators have a </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.1113.1">short-circuit </span></span><span class="kobospan" id="kobo.1114.1">feature: when we evaluate the expression </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1115.1">False</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1116.1"> and</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1117.1"> 3</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1118.1"> /</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1119.1"> 0</span></span></span></span><span class="kobospan" id="kobo.1120.1">, the result is only </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1121.1">False</span></span></span></span><span class="kobospan" id="kobo.1122.1">. </span><span class="kobospan" id="kobo.1122.2">The expression on the right-hand side of the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1123.1">and</span></span></span></span><span class="kobospan" id="kobo.1124.1"> operator, </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1125.1">3</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1126.1"> /</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1127.1"> 0</span></span></span></span><span class="kobospan" id="kobo.1128.1">, is never evaluated. </span><span class="kobospan" id="kobo.1128.2">The </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1129.1">or</span></span></span></span><span class="kobospan" id="kobo.1130.1"> operator is similar: when the left side is </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1131.1">True</span></span></span></span><span class="kobospan" id="kobo.1132.1">, the right-hand side is never evaluated.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.1133.1">If we want to be sure that a sequence of </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1134.1">bool</span></span></span></span><span class="kobospan" id="kobo.1135.1"> values is all true, building our own </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1136.1">reduce()</span></span></span></span><span class="kobospan" id="kobo.1137.1"> will do far too much work. </span><span class="kobospan" id="kobo.1137.2">Once the initial </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1138.1">False</span></span></span></span><span class="kobospan" id="kobo.1139.1"> is seen, there’s no reason to process the remaining items. </span><span class="kobospan" id="kobo.1139.2">The </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.1140.1">short-circuit </span></span><span class="kobospan" id="kobo.1141.1">feature of </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1142.1">and</span></span></span></span><span class="kobospan" id="kobo.1143.1"> and </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1144.1">or</span></span></span></span><span class="kobospan" id="kobo.1145.1"> does not </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.1146.1">not </span></span><span class="kobospan" id="kobo.1147.1">fit with the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1148.1">reduce()</span></span></span></span><span class="kobospan" id="kobo.1149.1"> function.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.1150.1">The built-in functions </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1151.1">any()</span></span></span></span><span class="kobospan" id="kobo.1152.1"> and </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1153.1">all()</span></span></span></span><span class="kobospan" id="kobo.1154.1">, on the other hand, are reductions using logic operators. </span><span class="kobospan" id="kobo.1154.2">The </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1155.1">any()</span></span></span></span><span class="kobospan" id="kobo.1156.1"> function is, effectively, a kind of </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1157.1">reduce()</span></span></span></span><span class="kobospan" id="kobo.1158.1"> using the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1159.1">or</span></span></span></span><span class="kobospan" id="kobo.1160.1"> operator. </span><span class="kobospan" id="kobo.1160.2">Similarly, the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1161.1">all()</span></span></span></span><span class="kobospan" id="kobo.1162.1"> function behaves as if it’s a </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1163.1">reduce()</span></span></span></span><span class="kobospan" id="kobo.1164.1"> with the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1165.1">and</span></span></span></span><span class="kobospan" id="kobo.1166.1"> operator.</span></p>
</section>
<section data-number="0.12.5.4.3" id="identity-elements">
<h3 class="likesubsubsectionhead" data-number="0.12.5.4.3"><span id="x1-5420004"/><span class="kobospan" id="kobo.1167.1">Identity elements</span></h3>
<p class="normal"><span class="kobospan" id="kobo.1168.1">Generally, an operator used for a reduction</span><span id="dx1-542001"/><span class="kobospan" id="kobo.1169.1"> must have an identity element. </span><span class="kobospan" id="kobo.1169.2">This is provided to the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1170.1">reduce()</span></span></span></span><span class="kobospan" id="kobo.1171.1"> function as the initial value. </span><span class="kobospan" id="kobo.1171.2">The identity element will also be the result when they’re applied against an empty sequence. </span><span class="kobospan" id="kobo.1171.3">Here are some common examples:</span></p>
<ul class="calibre11">
<li class="calibre12"><p class="normal2"><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1172.1">sum([])</span></span></span></span><span class="kobospan" id="kobo.1173.1"> is zero.</span></p></li>
<li class="calibre7"><p class="normal2"><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1174.1">math.prod([])</span></span></span></span><span class="kobospan" id="kobo.1175.1"> is one.</span></p></li>
<li class="calibre7"><p class="normal2"><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1176.1">any([])</span></span></span></span><span class="kobospan" id="kobo.1177.1"> is </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1178.1">False</span></span></span></span><span class="kobospan" id="kobo.1179.1">.</span></p></li>
<li class="calibre7"><p class="normal2"><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1180.1">all([])</span></span></span></span><span class="kobospan" id="kobo.1181.1"> is </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1182.1">True</span></span></span></span><span class="kobospan" id="kobo.1183.1">.</span></p></li>
</ul>
<p class="normal1"><span class="kobospan" id="kobo.1184.1">The identity value for the given operation is a matter of definition.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.1185.1">In the case of </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1186.1">any()</span></span></span></span><span class="kobospan" id="kobo.1187.1"> and </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1188.1">all()</span></span></span></span><span class="kobospan" id="kobo.1189.1"> specifically, it can help to think of the fundamental </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.1190.1">fold </span></span><span class="kobospan" id="kobo.1191.1">operation. </span><span class="kobospan" id="kobo.1191.2">The identity element can always be folded in without changing the result. </span><span class="kobospan" id="kobo.1191.3">Here’s how </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1192.1">all()</span></span></span></span><span class="kobospan" id="kobo.1193.1"> would look with explicitly folded </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1194.1">and</span></span></span></span><span class="kobospan" id="kobo.1195.1"> operators:</span></p>
<div class="math-display">
<span class="kobospan" id="kobo.1196.1"><img alt="b0 and b1 and b2 and ... and bn and True " class="calibre9" src="../media/file65.png"/></span>
</div>
<p class="normal1"><span class="kobospan" id="kobo.1197.1">If all of the values </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.1198.1">b</span></span><sub class="calibre24"><span class="cmr1"><span class="kobospan" id="kobo.1199.1">0</span></span></sub><span class="cmti-10x-x"><span class="kobospan" id="kobo.1200.1">,b</span></span><sub class="calibre24"><span class="cmr1"><span class="kobospan" id="kobo.1201.1">1</span></span></sub><span class="cmti-10x-x"><span class="kobospan" id="kobo.1202.1">,b</span></span><sub class="calibre24"><span class="cmr1"><span class="kobospan" id="kobo.1203.1">2</span></span></sub><span class="cmti-10x-x"><span class="kobospan" id="kobo.1204.1">,...,b</span></span><sub class="calibre24"><span class="cmmi"><span class="kobospan" id="kobo.1205.1">n</span></span></sub><span class="kobospan" id="kobo.1206.1"> are True, then the additional </span><span class="cmbx-10x-x"><span class="kobospan" id="kobo.1207.1">and</span></span> <span class="cmtt-10x-x"><span class="kobospan" id="kobo.1208.1">True</span></span><span class="kobospan" id="kobo.1209.1"> doesn’t change the value. </span><span class="kobospan" id="kobo.1209.2">If any</span><span id="dx1-542002"/><span class="kobospan" id="kobo.1210.1"> of the values </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.1211.1">b</span></span><sub class="calibre24"><span class="cmr1"><span class="kobospan" id="kobo.1212.1">0</span></span></sub><span class="cmti-10x-x"><span class="kobospan" id="kobo.1213.1">,b</span></span><sub class="calibre24"><span class="cmr1"><span class="kobospan" id="kobo.1214.1">1</span></span></sub><span class="cmti-10x-x"><span class="kobospan" id="kobo.1215.1">,b</span></span><sub class="calibre24"><span class="cmr1"><span class="kobospan" id="kobo.1216.1">2</span></span></sub><span class="cmti-10x-x"><span class="kobospan" id="kobo.1217.1">,...,b</span></span><sub class="calibre24"><span class="cmmi"><span class="kobospan" id="kobo.1218.1">n</span></span></sub><span class="kobospan" id="kobo.1219.1"> are are False, similarly, the additional </span><span class="cmbx-10x-x"><span class="kobospan" id="kobo.1220.1">and</span></span> <span class="cmtt-10x-x"><span class="kobospan" id="kobo.1221.1">True</span></span><span class="kobospan" id="kobo.1222.1"> has no impact.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.1223.1">When there are no values in a collection, the value for </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1224.1">all()</span></span></span></span><span class="kobospan" id="kobo.1225.1"> is the identity element, </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1226.1">True</span></span></span></span><span class="kobospan" id="kobo.1227.1">. </span><span id="x1-542003r1138"/></p>
</section>
</section>
<section data-number="0.12.5.5" id="see-also-73">
<h2 class="likechapterhead" data-number="0.12.5.5"><span><span class="kobospan" id="kobo.1228.1">9.5.5 </span></span> <span id="x1-5430005"/><span class="kobospan" id="kobo.1229.1">See also</span></h2>
<ul class="calibre16">
<li class="calibre12"><p class="normal2"><span class="kobospan" id="kobo.1230.1">See the </span><a href="ch013_split_000.xhtml#x1-5180003" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.1231.1">Using stacked generator expressions</span></span></a><span class="kobospan" id="kobo.1232.1"> recipe in this chapter for a context in which sum can be applied to compute total hours and total fuel.</span></p></li>
</ul>
<p class="normal1"><span id="x1-543001r1128"/></p>
</section>
</section>
<section data-number="0.12.6" id="combining-the-map-and-reduce-transformations">
<h1 class="unnumbered" data-number="0.12.6"><span><span class="kobospan" id="kobo.1233.1">9.6 </span></span> <span id="x1-5440006"/><span class="kobospan" id="kobo.1234.1">Combining the map and reduce transformations</span></h1>
<p class="normal"><span class="kobospan" id="kobo.1235.1">In the other recipes in this chapter, we’ve been looking at map, filter, and reduce</span><span id="dx1-544001"/><span class="kobospan" id="kobo.1236.1"> operations. </span><span class="kobospan" id="kobo.1236.2">We’ve looked at each of these functions in isolation:</span></p>
<ul class="calibre11">
<li class="calibre12"><p class="normal2"><span class="kobospan" id="kobo.1237.1">The </span><a href="ch013_split_000.xhtml#x1-5090002" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.1238.1">Applying transformations to a collection</span></span></a><span class="kobospan" id="kobo.1239.1"> recipe shows the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1240.1">map()</span></span></span></span><span class="kobospan" id="kobo.1241.1"> function.</span></p></li>
<li class="calibre7"><p class="normal2"><span class="kobospan" id="kobo.1242.1">The </span><a href="ch013_split_000.xhtml#x1-5270004" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.1243.1">Picking a subset – three ways to filter</span></span></a><span class="kobospan" id="kobo.1244.1"> recipe shows the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1245.1">filter()</span></span></span></span><span class="kobospan" id="kobo.1246.1"> function.</span></p></li>
<li class="calibre7"><p class="normal2"><span class="kobospan" id="kobo.1247.1">The </span><a href="ch013_split_000.xhtml#x1-5350005" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.1248.1">Summarizing a collection – how to reduce</span></span></a><span class="kobospan" id="kobo.1249.1"> recipe shows the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1250.1">reduce()</span></span></span></span><span class="kobospan" id="kobo.1251.1"> function.</span></p></li>
</ul>
<p class="normal1"><span class="kobospan" id="kobo.1252.1">Many algorithms will involve creating composite functions that combine these more basic operations. </span><span class="kobospan" id="kobo.1252.2">Additionally, we’ll need to look at a profound limitation of working with iterators and generator functions.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.1253.1">Here’s an example of this limitation:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.1254.1">&gt;&gt;&gt; typical_iterator = iter([0, 1, 2, 3, 4]) 
 
&gt;&gt;&gt; sum(typical_iterator) 
 
10 
 
 
 
&gt;&gt;&gt; sum(typical_iterator) 
 
0</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.1255.1">We created an iterator over a sequence of values by manually applying the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1256.1">iter()</span></span></span></span><span class="kobospan" id="kobo.1257.1"> function to a literal list object. </span><span class="kobospan" id="kobo.1257.2">The first time that the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1258.1">sum()</span></span></span></span><span class="kobospan" id="kobo.1259.1"> function consumed the values from </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1260.1">typical_iterator</span></span></span></span><span class="kobospan" id="kobo.1261.1">, it consumed all five values. </span><span class="kobospan" id="kobo.1261.2">The next time we try to apply any function to </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1262.1">typical_iterator</span></span></span></span><span class="kobospan" id="kobo.1263.1">, there will be no more values to be consumed; the iterator will appear empty. </span><span class="kobospan" id="kobo.1263.2">By definition, the identity value — 0 for summation — is the result.</span></p>
<div class="tipbox" id="tcolobox-21">
<div class="note">
<p class="normal1"><span class="kobospan" id="kobo.1264.1">An iterator can only produce values once.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.1265.1">After the values have been consumed, an iterator appears to be an empty collection.</span></p>
</div>
</div>
<p class="normal1"><span class="kobospan" id="kobo.1266.1">This one-time-only constraint</span><span id="dx1-544009"/><span class="kobospan" id="kobo.1267.1"> will force us to cache intermediate results when we need to perform multiple reductions on the data. </span><span class="kobospan" id="kobo.1267.2">Creating intermediate collection objects will consume memory, leading to the need for a careful design when working with very large collections of data. </span><span class="kobospan" id="kobo.1267.3">(Processing large collections of data is difficult. </span><span class="kobospan" id="kobo.1267.4">Python offers some ways to create workable solutions; it does not magically make the problem evaporate.)</span></p>
<p class="normal1"><span class="kobospan" id="kobo.1268.1">To apply a complex transformation of a collection, we often find instances of map, filter, and reduce operations that can be implemented separately. </span><span class="kobospan" id="kobo.1268.2">These can then be combined into sophisticated composite operations. </span><span id="x1-544010r1145"/></p>
<section data-number="0.12.6.1" id="getting-ready-75">
<h2 class="likechapterhead" data-number="0.12.6.1"><span><span class="kobospan" id="kobo.1269.1">9.6.1 </span></span> <span id="x1-5450001"/><span class="kobospan" id="kobo.1270.1">Getting ready</span></h2>
<p class="normal"><span class="kobospan" id="kobo.1271.1">In the </span><a href="ch013_split_000.xhtml#x1-5180003" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.1272.1">Using stacked generator expressions</span></span></a><span class="kobospan" id="kobo.1273.1"> recipe earlier in this chapter, we looked at some sailboat data. </span><span class="kobospan" id="kobo.1273.2">The spreadsheet was badly organized, and a number of steps were required to impose a more useful structure on the data.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.1274.1">In that recipe, we looked at a spreadsheet that is used to record fuel consumption on a large sailboat. </span><span class="kobospan" id="kobo.1274.2">For details of this data, see the </span><a href="ch008_split_000.xhtml#x1-2400003" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.1275.1">Slicing and dicing a list</span></span></a><span class="kobospan" id="kobo.1276.1"> recipe in </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.1277.1">Chapter</span></span><span class="cmti-10x-x"><span class="kobospan" id="kobo.1278.1"> </span></span><a href="ch008_split_000.xhtml#x1-2240004" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.1279.1">4</span></span></a><span class="kobospan" id="kobo.1280.1">. </span><span class="kobospan" id="kobo.1280.2">We’ll look at parsing this in more detail in the </span><a href="ch015_split_000.xhtml#x1-6320003" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.1281.1">Reading delimited</span></span> <span class="cmti-10x-x"><span class="kobospan" id="kobo.1282.1">files with the CSV module</span></span></a><span class="kobospan" id="kobo.1283.1"> recipe in </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.1284.1">Chapter</span></span><span class="cmti-10x-x"><span class="kobospan" id="kobo.1285.1"> </span></span><a href="ch015_split_000.xhtml#x1-61500011" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.1286.1">11</span></span></a><span class="kobospan" id="kobo.1287.1">.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.1288.1">The initial processing in the </span><a href="ch013_split_000.xhtml#x1-5180003" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.1289.1">Using stacked generator expressions</span></span></a><span class="kobospan" id="kobo.1290.1"> recipe created a sequence of operations to change the organization of the data, filter out the headings, and compute some useful values. </span><span class="kobospan" id="kobo.1290.2">We’d need to supplement this with two more reductions to get some average and variance information. </span><span class="kobospan" id="kobo.1290.3">These statistics will help us understand the data more fully. </span><span class="kobospan" id="kobo.1290.4">We’ll build on that earlier processing with some additional steps. </span><span id="x1-545001r1148"/></p>
</section>
<section data-number="0.12.6.2" id="how-to-do-it...-76">
<h2 class="likechapterhead" data-number="0.12.6.2"><span><span class="kobospan" id="kobo.1291.1">9.6.2 </span></span> <span id="x1-5460002"/><span class="kobospan" id="kobo.1292.1">How to do it...</span></h2>
<p class="normal"><span class="kobospan" id="kobo.1293.1">We’ll start with a target line of code</span><span id="dx1-546001"/><span class="kobospan" id="kobo.1294.1"> as the design goal. </span><span class="kobospan" id="kobo.1294.2">In this case, we’d like a function to sum the fuel use per hour. </span><span class="kobospan" id="kobo.1294.3">This follows a common three-step processing pattern. </span><span class="kobospan" id="kobo.1294.4">First, we normalize the data with </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1295.1">row_merge()</span></span></span></span><span class="kobospan" id="kobo.1296.1">. </span><span class="kobospan" id="kobo.1296.2">Second, we use mapping and filtering to create more useful objects with </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1297.1">clean_data_iter()</span></span></span></span><span class="kobospan" id="kobo.1298.1">.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.1299.1">The third step should look like the following:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.1300.1">&gt;&gt;&gt; round( 
 
... </span><span class="kobospan" id="kobo.1300.2">    total_fuel(clean_data_iter(row_merge(log_rows))), 
 
... </span><span class="kobospan" id="kobo.1300.3">    3 
 
... </span><span class="kobospan" id="kobo.1300.4">) 
 
7.0</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.1301.1">Our target function, </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1302.1">total_fuel()</span></span></span></span><span class="kobospan" id="kobo.1303.1">, is designed to work with a few other functions that clean and organize the raw data. </span><span class="kobospan" id="kobo.1303.2">We’ll start with the normalization and proceed to defining the final summary function as follows:</span></p>
<ol class="calibre4">
<li class="calibre7"><div id="x1-546009x1" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.1304.1">Import the functions from earlier recipes to reuse the initial preparation:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.1305.1">from recipe_03 import row_merge, CombinedRow</span></code></pre>
</div></li>
<li class="calibre7"><div id="x1-546013x2" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.1306.1">Define the target data structure created by the cleaning and enrichment step. </span><span class="kobospan" id="kobo.1306.2">We’ll use a mutable dataclass in this example. </span><span class="kobospan" id="kobo.1306.3">The fields coming from the normalized </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1307.1">CombinedRow</span></span></span></span><span class="kobospan" id="kobo.1308.1"> object can be initialized directly. </span><span class="kobospan" id="kobo.1308.2">The other five fields will be computed eagerly by several separate functions. </span><span class="kobospan" id="kobo.1308.3">Fields not computed in the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1309.1">__init__()</span></span></span></span><span class="kobospan" id="kobo.1310.1"> method must be given an initial value of </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1311.1">field(init=False)</span></span></span></span><span class="kobospan" id="kobo.1312.1">:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.1313.1">import datetime 
 
from dataclasses import dataclass, field 
 
 
 
@dataclass 
 
class Leg: 
 
    date: str 
 
    start_time: str 
 
    start_fuel_height: str 
 
    end_time: str 
 
    end_fuel_height: str 
 
    other_notes: str 
 
    start_timestamp: datetime.datetime = field(init=False) 
 
    end_timestamp: datetime.datetime = field(init=False) 
 
    travel_hours: float = field(init=False) 
 
    fuel_change: float = field(init=False) 
 
    fuel_per_hour: float = field(init=False)</span></code></pre>
</div></li>
<li class="calibre7"><div id="x1-546032x3" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.1314.1">Define the overall data</span><span id="dx1-546033"/><span class="kobospan" id="kobo.1315.1"> cleansing and enrichment data function. </span><span class="kobospan" id="kobo.1315.2">This will build the enriched </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1316.1">Leg</span></span></span></span><span class="kobospan" id="kobo.1317.1"> objects from the source </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1318.1">CombinedRow</span></span></span></span><span class="kobospan" id="kobo.1319.1"> objects. </span><span class="kobospan" id="kobo.1319.2">We’ll build this from seven simpler functions. </span><span class="kobospan" id="kobo.1319.3">The implementation is a stack of </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1320.1">map()</span></span></span></span><span class="kobospan" id="kobo.1321.1"> and </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1322.1">filter()</span></span></span></span><span class="kobospan" id="kobo.1323.1"> operations that will derive data from the source fields:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.1324.1">from collections.abc import Iterable, Iterator 
 
 
 
def clean_data_iter( 
 
    source: Iterable[CombinedRow] 
 
) -&gt; Iterator[Leg]: 
 
    leg_iter = map(make_Leg, source) 
 
    fitered_source = filter(reject_date_header, leg_iter) 
 
    start_iter = map(start_datetime, fitered_source) 
 
    end_iter = map(end_datetime, start_iter) 
 
    delta_iter = map(duration, end_iter) 
 
    fuel_iter = map(fuel_use, delta_iter) 
 
    per_hour_iter = map(fuel_per_hour, fuel_iter) 
 
    return per_hour_iter</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.1325.1">Each statement makes use of the iterator produced by the preceding statement.</span></p>
</div></li>
<li class="calibre7"><div id="x1-546049x4" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.1326.1">Write the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1327.1">make_Leg()</span></span></span></span><span class="kobospan" id="kobo.1328.1"> function to create </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1329.1">Leg</span></span></span></span><span class="kobospan" id="kobo.1330.1"> instances from </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1331.1">CombinedRow</span></span></span></span><span class="kobospan" id="kobo.1332.1"> instances:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.1333.1">def make_Leg(row: CombinedRow) -&gt; Leg: 
 
    return Leg( 
 
        date=row.date, 
 
        start_time=row.engine_on_time, 
 
        start_fuel_height=row.engine_on_fuel_height, 
 
        end_time=row.engine_off_time, 
 
        end_fuel_height=row.engine_off_fuel_height, 
 
        other_notes=row.other_notes, 
 
    )</span></code></pre>
</div></li>
<li class="calibre7"><div id="x1-546061x5" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.1334.1">Write the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1335.1">reject_date_header()</span></span></span></span><span class="kobospan" id="kobo.1336.1"> function used by </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1337.1">filter()</span></span></span></span><span class="kobospan" id="kobo.1338.1"> to remove the heading rows:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.1339.1">def reject_date_header(row: Leg) -&gt; bool: 
 
    return not (row.date == "date")</span></code></pre>
</div></li>
<li class="calibre7"><div id="x1-546066x6" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.1340.1">Write the data conversion</span><span id="dx1-546067"/><span class="kobospan" id="kobo.1341.1"> functions. </span><span class="kobospan" id="kobo.1341.2">We’ll start with the two date and time strings, which need to become a single </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1342.1">datetime</span></span></span></span><span class="kobospan" id="kobo.1343.1"> object:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.1344.1">def timestamp( 
 
    date_text: str, time_text: str 
 
) -&gt; datetime.datetime: 
 
    date = datetime.datetime.strptime( 
 
        date_text, "%m/%d/%y").date() 
 
    time = datetime.datetime.strptime( 
 
        time_text, "%I:%M:%S %p").time() 
 
    timestamp = datetime.datetime.combine( 
 
        date, time) 
 
    return timestamp</span></code></pre>
</div></li>
<li class="calibre7"><div id="x1-546080x7" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.1345.1">Mutate the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1346.1">Leg</span></span></span></span><span class="kobospan" id="kobo.1347.1"> instances with additional values:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.1348.1">def start_datetime(row: Leg) -&gt; Leg: 
 
      row.start_timestamp = timestamp( 
 
        row.date, row.start_time) 
 
      return row 
 
 
 
def end_datetime(row: Leg) -&gt; Leg: 
 
      row.end_timestamp = timestamp( 
 
        row.date, row.end_time) 
 
      return row</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.1349.1">This update-in-place approach is an optimization to avoid creating intermediate objects.</span></p>
</div></li>
<li class="calibre7"><div id="x1-546092x8" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.1350.1">Compute the derived duration from the timestamps:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.1351.1">def duration(row: Leg) -&gt; Leg: 
 
    travel_time = row.end_timestamp - row.start_timestamp 
 
    row.travel_hours = round( 
 
        travel_time.total_seconds() / 60 / 60, 
 
        1 
 
    ) 
 
    return row</span></code></pre>
</div></li>
<li class="calibre7"><div id="x1-546102x9" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.1352.1">Compute any other metrics</span><span id="dx1-546103"/><span class="kobospan" id="kobo.1353.1"> that are needed for the analysis:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.1354.1">def fuel_use(row: Leg) -&gt; Leg: 
 
    end_height = float(row.end_fuel_height) 
 
    start_height = float(row.start_fuel_height) 
 
    row.fuel_change = start_height - end_height 
 
    return row 
 
 
 
def fuel_per_hour(row: Leg) -&gt; Leg: 
 
    row.fuel_per_hour = row.fuel_change / row.travel_hours 
 
    return row</span></code></pre>
</div></li>
</ol>
<p class="normal1"><span class="kobospan" id="kobo.1355.1">The final </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1356.1">fuel_per_hour()</span></span></span></span><span class="kobospan" id="kobo.1357.1"> function’s calculation depends on the entire preceding stack of calculations. </span><span class="kobospan" id="kobo.1357.2">Each of these computations is done separately to clarify and isolate the computation details. </span><span class="kobospan" id="kobo.1357.3">This approach permits changes to the isolated computations. </span><span class="kobospan" id="kobo.1357.4">Most importantly, it permits testing each computation as a separate unit. </span><span id="x1-546114r1149"/></p>
</section>
<section data-number="0.12.6.3" id="how-it-works...-76">
<h2 class="likechapterhead" data-number="0.12.6.3"><span><span class="kobospan" id="kobo.1358.1">9.6.3 </span></span> <span id="x1-5470003"/><span class="kobospan" id="kobo.1359.1">How it works...</span></h2>
<p class="normal"><span class="kobospan" id="kobo.1360.1">The core concept is to build a composite transformation from a sequence of small steps. </span><span class="kobospan" id="kobo.1360.2">Since each step is conceptually distinct, it makes it somewhat easier to understand the composition.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.1361.1">In this recipe, we’ve used three kinds of transformations:</span></p>
<ul class="calibre11">
<li class="calibre12"><p class="normal2"><span class="cmbx-10x-x"><span class="kobospan" id="kobo.1362.1">Structural changes</span></span><span class="kobospan" id="kobo.1363.1">. </span><span class="kobospan" id="kobo.1363.2">An initial generator function grouped physical lines into logical rows.</span></p></li>
<li class="calibre7"><p class="normal2"><span class="cmbx-10x-x"><span class="kobospan" id="kobo.1364.1">Filters</span></span><span class="kobospan" id="kobo.1365.1">. </span><span class="kobospan" id="kobo.1365.2">A generator function rejected rows that were invalid.</span></p></li>
<li class="calibre7"><p class="normal2"><span class="cmbx-10x-x"><span class="kobospan" id="kobo.1366.1">Enrichment</span></span><span class="kobospan" id="kobo.1367.1">. </span><span class="kobospan" id="kobo.1367.2">As we’ve seen, there are two design approaches to enriching data: lazy and eager. </span><span class="kobospan" id="kobo.1367.3">The lazy approach may involve methods or properties, computed only as needed. </span><span class="kobospan" id="kobo.1367.4">This design shows eager computation, where a number of fields had values built by the processing pipeline.</span></p></li>
</ul>
<p class="normal1"><span class="kobospan" id="kobo.1368.1">The various enrichment methods worked by updating stateful </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1369.1">Leg</span></span></span></span><span class="kobospan" id="kobo.1370.1"> objects, setting computed column values. </span><span class="kobospan" id="kobo.1370.2">Using stateful objects like this requires the various enrichment transformations be performed in a strict order because some (like </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1371.1">duration()</span></span></span></span><span class="kobospan" id="kobo.1372.1">) depend on others having been performed first.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.1373.1">We can now design the target</span><span id="dx1-547001"/><span class="kobospan" id="kobo.1374.1"> computation functions:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.1375.1">from statistics import * 
 
 
 
def avg_fuel_per_hour(source: Iterable[Leg]) -&gt; float: 
 
    return mean(row.fuel_per_hour for row in source) 
 
 
 
def stdev_fuel_per_hour(source: Iterable[Leg]) -&gt; float: 
 
    return stdev(row.fuel_per_hour for row in source)</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.1376.1">This meets our design goal of being able to perform meaningful computations on the raw data. </span><span id="x1-547010r1160"/></p>
</section>
<section data-number="0.12.6.4" id="theres-more...-67">
<h2 class="likechapterhead" data-number="0.12.6.4"><span><span class="kobospan" id="kobo.1377.1">9.6.4 </span></span> <span id="x1-5480004"/><span class="kobospan" id="kobo.1378.1">There’s more...</span></h2>
<p class="normal"><span class="kobospan" id="kobo.1379.1">As we noted, we can only perform one iteration of consuming the items from an iterable source of data. </span><span class="kobospan" id="kobo.1379.2">If we want to compute several averages, or the average as well as the variance, we’ll need to use a slightly different design pattern.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.1380.1">In order to compute multiple summaries of the data, it’s often best to create a concrete object of some kind that can be summarized repeatedly:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.1381.1">def summary(raw_data: Iterable[list[str]]) -&gt; None: 
 
    data = tuple(clean_data_iter(row_merge(raw_data))) 
 
    m = avg_fuel_per_hour(data) 
 
    s = 2 * stdev_fuel_per_hour(data) 
 
    print(f"Fuel use {m:.2f} {s:.2f}")</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.1382.1">Here, we’ve created a very large tuple from the cleaned and enriched data. </span><span class="kobospan" id="kobo.1382.2">From this tuple, we can can produce any number of iterators. </span><span class="kobospan" id="kobo.1382.3">This lets us compute any number of distinct summaries.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.1383.1">We can also use the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1384.1">tee()</span></span></span></span><span class="kobospan" id="kobo.1385.1"> function in the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1386.1">itertools</span></span></span></span><span class="kobospan" id="kobo.1387.1"> module for this kind of processing. </span><span class="kobospan" id="kobo.1387.2">This can devolve to inefficient processing because of the way the cloned instances of the iterator maintain their internal state. </span><span class="kobospan" id="kobo.1387.3">It’s often better to create an intermediate structure like a list or tuple than to use </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1388.1">itertools.tee()</span></span></span></span><span class="kobospan" id="kobo.1389.1">.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.1390.1">The design pattern applies a number of transformations to the source data. </span><span class="kobospan" id="kobo.1390.2">We’ve built it using a stack of separate map, filter, and reduce operations. </span><span id="x1-548007r1162"/></p>
</section>
<section data-number="0.12.6.5" id="see-also-74">
<h2 class="likechapterhead" data-number="0.12.6.5"><span><span class="kobospan" id="kobo.1391.1">9.6.5 </span></span> <span id="x1-5490005"/><span class="kobospan" id="kobo.1392.1">See also</span></h2>
<ul class="calibre16">
<li class="calibre12"><p class="normal2"><span class="kobospan" id="kobo.1393.1">See the </span><a href="ch013_split_000.xhtml#x1-5180003" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.1394.1">Using stacked generator expressions</span></span></a><span class="kobospan" id="kobo.1395.1"> recipe in this chapter for a context in which sum can be applied to compute total hours and total fuel.</span></p></li>
<li class="calibre7"><p class="normal2"><span class="kobospan" id="kobo.1396.1">See the </span><a href="ch013_split_000.xhtml#x1-5350005" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.1397.1">Summarizing a collection – how to reduce</span></span></a><span class="kobospan" id="kobo.1398.1"> recipe in this chapter for some background on the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1399.1">reduce()</span></span></span></span><span class="kobospan" id="kobo.1400.1"> function.</span></p></li>
<li class="calibre7"><p class="normal2"><span class="kobospan" id="kobo.1401.1">See </span><a href="https://www.packtpub.com/product/python-high-performance-second-edition-second-edition/9781787282896" class="url"><span class="kobospan" id="kobo.1402.1">Python High Performance</span></a><span class="kobospan" id="kobo.1403.1"> for more on distributed map-reduce processing.</span></p></li>
<li class="calibre7"><p class="normal2"><span class="kobospan" id="kobo.1404.1">We look at lazy properties in the </span><a href="ch011_split_001.xhtml#x1-43100010" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.1405.1">Using properties for lazy attributes</span></span></a><span class="kobospan" id="kobo.1406.1"> recipe in </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.1407.1">Chapter</span></span><span class="cmti-10x-x"><span class="kobospan" id="kobo.1408.1"> </span></span><a href="ch011_split_000.xhtml#x1-3760007" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.1409.1">7</span></span></a><span class="kobospan" id="kobo.1410.1">. </span><span class="kobospan" id="kobo.1410.2">Also, this recipe looks at some important variations of map-reduce processing.</span></p></li>
</ul>
<p class="normal1"><span id="x1-549001r1146"/></p>
</section>
</section>
<section data-number="0.12.7" id="implementing-there-exists-processing">
<h1 class="unnumbered" data-number="0.12.7"><span><span class="kobospan" id="kobo.1411.1">9.7 </span></span> <span id="x1-5500007"/><span class="kobospan" id="kobo.1412.1">Implementing “there exists” processing</span></h1>
<p class="normal"><span class="kobospan" id="kobo.1413.1">The processing patterns</span><span id="dx1-550001"/><span class="kobospan" id="kobo.1414.1"> we’ve been looking at can all be summarized with the universal quantifier, </span><span><span class="kobospan" id="kobo.1415.1">∀</span></span><span class="kobospan" id="kobo.1416.1">, meaning </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.1417.1">for all</span></span><span class="kobospan" id="kobo.1418.1">. </span><span class="kobospan" id="kobo.1418.2">It’s been an implicit part of all of the processing definitions:</span></p>
<ul class="calibre11">
<li class="calibre12"><p class="normal2"><span class="cmbx-10x-x"><span class="kobospan" id="kobo.1419.1">Map</span></span><span class="kobospan" id="kobo.1420.1">: For </span><span class="cmbx-10x-x"><span class="kobospan" id="kobo.1421.1">all </span></span><span class="kobospan" id="kobo.1422.1">items in the source, </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.1423.1">S</span></span><span class="kobospan" id="kobo.1424.1">, apply the map function, </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.1425.1">m</span></span><span class="kobospan" id="kobo.1426.1">(</span><span class="cmti-10x-x"><span class="kobospan" id="kobo.1427.1">x</span></span><span class="kobospan" id="kobo.1428.1">). </span><span class="kobospan" id="kobo.1428.2">We can use the universal quantifier: </span><span><span class="kobospan" id="kobo.1429.1">∀</span></span><sub class="calibre24"><span class="cmmi"><span class="kobospan" id="kobo.1430.1">x</span></span><span class="cmr1"><span class="kobospan" id="kobo.1431.1">∈</span></span><span class="cmmi"><span class="kobospan" id="kobo.1432.1">S</span></span></sub><span class="cmti-10x-x"><span class="kobospan" id="kobo.1433.1">m</span></span><span class="kobospan" id="kobo.1434.1">(</span><span class="cmti-10x-x"><span class="kobospan" id="kobo.1435.1">x</span></span><span class="kobospan" id="kobo.1436.1">).</span></p></li>
<li class="calibre7"><p class="normal2"><span class="cmbx-10x-x"><span class="kobospan" id="kobo.1437.1">Filter</span></span><span class="kobospan" id="kobo.1438.1">: This, also, means for </span><span class="cmbx-10x-x"><span class="kobospan" id="kobo.1439.1">all </span></span><span class="kobospan" id="kobo.1440.1">items in the source, </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.1441.1">S</span></span><span class="kobospan" id="kobo.1442.1">, pass those for which the filter function, </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.1443.1">f</span></span><span class="kobospan" id="kobo.1444.1">(</span><span class="cmti-10x-x"><span class="kobospan" id="kobo.1445.1">x</span></span><span class="kobospan" id="kobo.1446.1">), is true. </span><span class="kobospan" id="kobo.1446.2">Here, also, we can use the universal quantifier: </span><span><span class="kobospan" id="kobo.1447.1">∀</span></span><sub class="calibre24"><span class="cmmi"><span class="kobospan" id="kobo.1448.1">x</span></span><span class="cmr1"><span class="kobospan" id="kobo.1449.1">∈</span></span><span class="cmmi"><span class="kobospan" id="kobo.1450.1">S</span></span></sub><span class="cmti-10x-x"><span class="kobospan" id="kobo.1451.1">x</span></span> <span class="cmbx-10x-x"><span class="kobospan" id="kobo.1452.1">if</span></span> <span class="cmti-10x-x"><span class="kobospan" id="kobo.1453.1">f</span></span><span class="kobospan" id="kobo.1454.1">(</span><span class="cmti-10x-x"><span class="kobospan" id="kobo.1455.1">x</span></span><span class="kobospan" id="kobo.1456.1">).</span></p></li>
<li class="calibre7"><p class="normal2"><span class="cmbx-10x-x"><span class="kobospan" id="kobo.1457.1">Reduce</span></span><span class="kobospan" id="kobo.1458.1">: For all items in the source, use the given operator and base value to compute a summary. </span><span class="kobospan" id="kobo.1458.2">The universal quantification is implicit in the definition of operators </span><span><span class="kobospan" id="kobo.1459.1">∑</span></span> <sub class="calibre24"><span class="cmmi"><span class="kobospan" id="kobo.1460.1">x</span></span><span class="cmr1"><span class="kobospan" id="kobo.1461.1">∈</span></span><span class="cmmi"><span class="kobospan" id="kobo.1462.1">S</span></span></sub><span class="cmti-10x-x"><span class="kobospan" id="kobo.1463.1">x </span></span><span class="kobospan" id="kobo.1464.1">and </span><span><span class="kobospan" id="kobo.1465.1">∏</span></span> <sub class="calibre24"><span class="cmmi"><span class="kobospan" id="kobo.1466.1">x</span></span><span class="cmr1"><span class="kobospan" id="kobo.1467.1">∈</span></span><span class="cmmi"><span class="kobospan" id="kobo.1468.1">S</span></span></sub><span class="cmti-10x-x"><span class="kobospan" id="kobo.1469.1">x</span></span><span class="kobospan" id="kobo.1470.1">.</span></p></li>
</ul>
<p class="normal1"><span class="kobospan" id="kobo.1471.1">Contrast these universal functions with the cases where we are only interested in locating a single item. </span><span class="kobospan" id="kobo.1471.2">We often describe these cases as a </span><span class="cmbx-10x-x"><span class="kobospan" id="kobo.1472.1">search </span></span><span class="kobospan" id="kobo.1473.1">to show there exists at least one item where a condition is true. </span><span class="kobospan" id="kobo.1473.2">This can be described with the existential quantifier, </span><span><span class="kobospan" id="kobo.1474.1">∃</span></span><span class="kobospan" id="kobo.1475.1">, meaning </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.1476.1">there exists</span></span><span class="kobospan" id="kobo.1477.1">.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.1478.1">We’ll need to use some additional features of Python to create generator functions that stop when the first value matches some predicate. </span><span class="kobospan" id="kobo.1478.2">We’d like to emulate the short-circuit capabilities of the built-in </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1479.1">any()</span></span></span></span><span class="kobospan" id="kobo.1480.1"> and </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1481.1">all()</span></span></span></span><span class="kobospan" id="kobo.1482.1"> functions. </span><span id="x1-550002r1164"/></p>
<section data-number="0.12.7.1" id="getting-ready-76">
<h2 class="likechapterhead" data-number="0.12.7.1"><span><span class="kobospan" id="kobo.1483.1">9.7.1 </span></span> <span id="x1-5510001"/><span class="kobospan" id="kobo.1484.1">Getting ready</span></h2>
<p class="normal"><span class="kobospan" id="kobo.1485.1">For an example of an existence</span><span id="dx1-551001"/><span class="kobospan" id="kobo.1486.1"> test, consider a function to determine if a number is prime or composite. </span><span class="kobospan" id="kobo.1486.2">A prime number has no factors other than 1 and itself. </span><span class="kobospan" id="kobo.1486.3">Numbers with multiple factors</span><span id="dx1-551002"/><span class="kobospan" id="kobo.1487.1"> are called composite. </span><span class="kobospan" id="kobo.1487.2">The number 42 is composite because it has the numbers 2, 3, and 7 as prime factors.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.1488.1">Finding if a number is prime number is the same as showing it is not composite. </span><span class="kobospan" id="kobo.1488.2">For any composite (or non-prime) number, </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.1489.1">n</span></span><span class="kobospan" id="kobo.1490.1">, the rule is this:</span></p>
<div class="math-display">
<span class="kobospan" id="kobo.1491.1"><img alt="¬P (n ) = ∃2≤i&lt;n(n ≡ 0 mod i) " class="calibre9" src="../media/file66.png"/></span>
</div>
<p class="normal1"><span class="kobospan" id="kobo.1492.1">A number, </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.1493.1">n</span></span><span class="kobospan" id="kobo.1494.1">, is not prime if there exists a value, </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.1495.1">i</span></span><span class="kobospan" id="kobo.1496.1">, between 2 and the number itself, that divides the number evenly. </span><span class="kobospan" id="kobo.1496.2">For a test to see if a number is prime, we don’t need to know </span><span class="cmbx-10x-x"><span class="kobospan" id="kobo.1497.1">all </span></span><span class="kobospan" id="kobo.1498.1">the factors. </span><span class="kobospan" id="kobo.1498.2">The existence of a single factor shows the number is composite.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.1499.1">The overall idea is to iterate over the range of candidate numbers, breaking from the iteration when a factor is found. </span><span class="kobospan" id="kobo.1499.2">In Python, this early exit from a </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1500.1">for</span></span></span></span><span class="kobospan" id="kobo.1501.1"> statement is done with the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1502.1">break</span></span></span></span><span class="kobospan" id="kobo.1503.1"> statement, shifting the semantics from “for all” to “there exists.” </span><span class="kobospan" id="kobo.1503.2">Because </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1504.1">break</span></span></span></span><span class="kobospan" id="kobo.1505.1"> is a statement, we can’t easily use a generator expression; we’re constrained to writing a generator function.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.1506.1">(The Fermat test is generally more efficient than what we’re using for these examples, but it doesn’t involve a simple search for the existence of a factor. </span><span class="kobospan" id="kobo.1506.2">We’re using this as an illustration of search, not as an illustration of good primality tests.) </span><span id="x1-551003r1166"/></p>
</section>
<section data-number="0.12.7.2" id="how-to-do-it...-77">
<h2 class="likechapterhead" data-number="0.12.7.2"><span><span class="kobospan" id="kobo.1507.1">9.7.2 </span></span> <span id="x1-5520002"/><span class="kobospan" id="kobo.1508.1">How to do it...</span></h2>
<p class="normal"><span class="kobospan" id="kobo.1509.1">In order to build this kind of search</span><span id="dx1-552001"/><span class="kobospan" id="kobo.1510.1"> function, we’ll need to create a generator function that will complete processing when it finds the first match. </span><span class="kobospan" id="kobo.1510.2">One way to do this is with the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1511.1">break</span></span></span></span><span class="kobospan" id="kobo.1512.1"> statement, as follows:</span></p>
<ol class="calibre4">
<li class="calibre7"><div id="x1-552003x1" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.1513.1">Define a generator function to skip items until a test is passed. </span><span class="kobospan" id="kobo.1513.2">The generator can yield the first value that passes the predicate test. </span><span class="kobospan" id="kobo.1513.3">The generator works by applying a predicate function, </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1514.1">fn(),</span></span></span></span><span class="kobospan" id="kobo.1515.1"> to the items in a sequence of items of some type, </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1516.1">T</span></span></span></span><span class="kobospan" id="kobo.1517.1">:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.1518.1">from collections.abc import Callable, Iterable, Iterator 
 
from typing import TypeVar 
 
 
 
T = TypeVar("T") 
 
 
 
def find_first( 
 
    fn:  Callable[[T], bool], source: Iterable[T] 
 
) -&gt; Iterator[T]: 
 
    for item in source: 
 
        if fn(item): 
 
            yield item 
 
            break                                                                

                                                                     
     </span></code></pre>
</div></li>
<li class="calibre7"><div id="x1-552018x2" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.1519.1">Define the specific predicate function for this application. </span><span class="kobospan" id="kobo.1519.2">Since we’re testing for being prime, we’re looking for any value that divides the target number, </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1520.1">n</span></span></span></span><span class="kobospan" id="kobo.1521.1">, evenly. </span><span class="kobospan" id="kobo.1521.2">Here’s the kind of expression that’s needed:</span></p>
<pre class="programlisting" id="listing-49"><code class="calibre13"><span class="kobospan" id="kobo.1522.1">lambda i: n % i == 0</span></code></pre>
</div></li>
<li class="calibre7"><div id="x1-552021x3" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.1523.1">Apply the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1524.1">find_first()</span></span></span></span><span class="kobospan" id="kobo.1525.1"> search function with the given range of values and predicate. </span><span class="kobospan" id="kobo.1525.2">If the factors iterable has an item, then </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1526.1">n</span></span></span></span><span class="kobospan" id="kobo.1527.1"> is composite. </span><span class="kobospan" id="kobo.1527.2">Otherwise, there are no values in the factors iterable, which means </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1528.1">n</span></span></span></span><span class="kobospan" id="kobo.1529.1"> is a prime number:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.1530.1">import math 
 
 
 
def prime(n: int) -&gt; bool: 
 
    factors = find_first( 
 
        lambda i: n % i == 0, 
 
        range(2, int(math.sqrt(n) + 1)) ) 
 
    return len(list(factors)) == 0</span></code></pre>
</div></li>
</ol>
<p class="normal1"><span class="kobospan" id="kobo.1531.1">As a practical matter, we don’t need to test every number</span><span id="dx1-552030"/><span class="kobospan" id="kobo.1532.1"> between two and </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1533.1">n</span></span></span></span><span class="kobospan" id="kobo.1534.1"> to see whether </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1535.1">n</span></span></span></span><span class="kobospan" id="kobo.1536.1"> is prime. </span><span class="kobospan" id="kobo.1536.2">It’s only necessary to test values, </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.1537.1">i</span></span><span class="kobospan" id="kobo.1538.1">, such that 2 </span><span><span class="kobospan" id="kobo.1539.1">≤ </span></span><span class="cmti-10x-x"><span class="kobospan" id="kobo.1540.1">i &lt; </span></span><span><span class="kobospan" id="kobo.1541.1">⌊</span></span><span class="kobospan" id="kobo.1542.1"><img alt="√n-" class="calibre9" src="../media/file67.png"/></span><span><span class="kobospan" id="kobo.1543.1">⌋</span></span><span class="kobospan" id="kobo.1544.1">. </span><span id="x1-552031r1167"/></p>
</section>
<section data-number="0.12.7.3" id="how-it-works...-77">
<h2 class="likechapterhead" data-number="0.12.7.3"><span><span class="kobospan" id="kobo.1545.1">9.7.3 </span></span> <span id="x1-5530003"/><span class="kobospan" id="kobo.1546.1">How it works...</span></h2>
<p class="normal"><span class="kobospan" id="kobo.1547.1">In the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1548.1">find_first()</span></span></span></span><span class="kobospan" id="kobo.1549.1"> function, we introduce a </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1550.1">break</span></span></span></span><span class="kobospan" id="kobo.1551.1"> statement to stop processing the source iterable. </span><span class="kobospan" id="kobo.1551.2">When the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1552.1">for</span></span></span></span><span class="kobospan" id="kobo.1553.1"> statement stops, the generator will reach the end of the function and return normally.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.1554.1">A client function consuming values from this generator will be given the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1555.1">StopIteration</span></span></span></span><span class="kobospan" id="kobo.1556.1"> exception. </span><span class="kobospan" id="kobo.1556.2">The </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1557.1">find_first()</span></span></span></span><span class="kobospan" id="kobo.1558.1"> function can raise an exception, but it’s not an error; it’s the signal that an iterable has finished processing the input values.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.1559.1">In this case, the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1560.1">StopIteration</span></span></span></span><span class="kobospan" id="kobo.1561.1"> exception means one of two things:</span></p>
<ul class="calibre11">
<li class="calibre12"><p class="normal2"><span class="kobospan" id="kobo.1562.1">If a value had been yielded previously, the value is a factor of </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1563.1">n</span></span></span></span><span class="kobospan" id="kobo.1564.1">.</span></p></li>
<li class="calibre7"><p class="normal2"><span class="kobospan" id="kobo.1565.1">If no value was yielded, then </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1566.1">n</span></span></span></span><span class="kobospan" id="kobo.1567.1"> is prime.</span></p></li>
</ul>
<p class="normal1"><span class="kobospan" id="kobo.1568.1">This small change of breaking early from the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1569.1">for</span></span></span></span><span class="kobospan" id="kobo.1570.1"> statement makes a dramatic difference in the meaning of the generator function. </span><span class="kobospan" id="kobo.1570.2">Instead of processing </span><span class="cmbx-10x-x"><span class="kobospan" id="kobo.1571.1">all</span></span><span class="kobospan" id="kobo.1572.1"> values from the source, the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1573.1">find_first()</span></span></span></span><span class="kobospan" id="kobo.1574.1"> generator will stop processing as soon as the predicate is true. </span><span id="x1-553001r1170"/></p>
</section>
<section data-number="0.12.7.4" id="theres-more...-68">
<h2 class="likechapterhead" data-number="0.12.7.4"><span><span class="kobospan" id="kobo.1575.1">9.7.4 </span></span> <span id="x1-5540004"/><span class="kobospan" id="kobo.1576.1">There’s more...</span></h2>
<p class="normal"><span class="kobospan" id="kobo.1577.1">In the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1578.1">itertools</span></span></span></span><span class="kobospan" id="kobo.1579.1"> module, there is an alternative to the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1580.1">find_first()</span></span></span></span><span class="kobospan" id="kobo.1581.1"> function. </span><span class="kobospan" id="kobo.1581.2">The </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1582.1">takewhile()</span></span></span></span><span class="kobospan" id="kobo.1583.1"> function uses a predicate function to take values from the input while the predicate function is true. </span><span class="kobospan" id="kobo.1583.2">When the predicate becomes false, then the function stops consuming and producing values.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.1584.1">To use the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1585.1">takewhile()</span></span></span></span><span class="kobospan" id="kobo.1586.1"> function, we need to invert our factor test. </span><span class="kobospan" id="kobo.1586.2">We need to consume values that are non-factors until we find the first factor. </span><span class="kobospan" id="kobo.1586.3">This leads to a change in the lambda from </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1587.1">lambda</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1588.1"> i:</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1589.1"> n</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1590.1"> %</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1591.1"> i</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1592.1"> ==</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1593.1"> 0</span></span></span></span><span class="kobospan" id="kobo.1594.1"> to </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1595.1">lambda</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1596.1"> i:</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1597.1"> n</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1598.1"> %</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1599.1"> i</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1600.1"> !=</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1601.1"> 0</span></span></span></span><span class="kobospan" id="kobo.1602.1">.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.1603.1">Let’s look at a test to see if 47 is prime. </span><span class="kobospan" id="kobo.1603.2">We need to check numbers in the range 2 to </span><span class="kobospan" id="kobo.1604.1"><img alt="√ --- 49" class="calibre9" src="../media/file68.png"/></span><span class="kobospan" id="kobo.1605.1"> = 7:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.1606.1">&gt;&gt;&gt; from itertools import takewhile 
 
 
 
&gt;&gt;&gt; n = 47 
 
&gt;&gt;&gt; list(takewhile(lambda i: n % i != 0, range(2, 8))) 
 
[2, 3, 4, 5, 6, 7]</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.1607.1">For a prime number, like 47, none of the test values are factors. </span><span class="kobospan" id="kobo.1607.2">All these non-factor test values pass the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1608.1">takewhile()</span></span></span></span><span class="kobospan" id="kobo.1609.1"> predicate because it’s always true. </span><span class="kobospan" id="kobo.1609.2">The resulting list is the same as the original set of test values.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.1610.1">For a composite number, the non-factor test values will be a subset of the test values. </span><span class="kobospan" id="kobo.1610.2">Some values will have been excluded because a factor was found.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.1611.1">There are a number of additional functions in the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1612.1">itertools</span></span></span></span><span class="kobospan" id="kobo.1613.1"> module that can be used to simplify complex map-reduce applications. </span><span class="kobospan" id="kobo.1613.2">We encourage you to look closely at this module. </span><span id="x1-554007r1171"/></p>
</section>
<section data-number="0.12.7.5" id="see-also-75">
<h2 class="likechapterhead" data-number="0.12.7.5"><span><span class="kobospan" id="kobo.1614.1">9.7.5 </span></span> <span id="x1-5550005"/><span class="kobospan" id="kobo.1615.1">See also</span></h2>
<ul class="calibre16">
<li class="calibre12"><p class="normal2"><span class="kobospan" id="kobo.1616.1">In the </span><a href="ch013_split_000.xhtml#x1-5180003" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.1617.1">Using stacked generator expressions</span></span></a><span class="kobospan" id="kobo.1618.1"> recipe earlier in this chapter, we made extensive use of immutable class definitions.</span></p></li>
<li class="calibre7"><p class="normal2"><span class="kobospan" id="kobo.1619.1">See </span><a class="url" href="https://projecteuler.net/problem=10"><span class="url1"><span class="kobospan" id="kobo.1620.1">https://projecteuler.net/problem=10</span></span></a><span class="kobospan" id="kobo.1621.1"> for a challenging problem related</span><span id="dx1-555001"/><span class="kobospan" id="kobo.1622.1"> to prime numbers less than 2 million. </span><span class="kobospan" id="kobo.1622.2">Parts of the problem seem obvious. </span><span class="kobospan" id="kobo.1622.3">It can be difficult, however, to test all those numbers for being prime.</span></p></li>
<li class="calibre7"><p class="normal2"><span class="kobospan" id="kobo.1623.1">The </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1624.1">itertools</span></span></span></span><span class="kobospan" id="kobo.1625.1"> module provides numerous functions that can simplify functional design.</span></p></li>
<li class="calibre7"><p class="normal2"><span class="kobospan" id="kobo.1626.1">Outside the standard library, packages like </span><a href="https://pypi.org/project/pyrsistent/" class="url"><span class="kobospan" id="kobo.1627.1">Pyrsistent</span></a><span class="kobospan" id="kobo.1628.1"> offer functional programming components.</span></p></li>
</ul>
<p class="normal1"><span id="x1-555002r1165"/></p>
</section>
</section>
<section data-number="0.12.8" id="creating-a-partial-function">
<h1 class="unnumbered" data-number="0.12.8"><span><span class="kobospan" id="kobo.1629.1">9.8 </span></span> <span id="x1-5560008"/><span class="kobospan" id="kobo.1630.1">Creating a partial function</span></h1>
<p class="normal"><span class="kobospan" id="kobo.1631.1">When we look at functions</span><span id="dx1-556001"/><span class="kobospan" id="kobo.1632.1"> such as </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1633.1">reduce()</span></span></span></span><span class="kobospan" id="kobo.1634.1">, </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1635.1">sorted()</span></span></span></span><span class="kobospan" id="kobo.1636.1">, </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1637.1">min()</span></span></span></span><span class="kobospan" id="kobo.1638.1">, and </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1639.1">max()</span></span></span></span><span class="kobospan" id="kobo.1640.1">, we see that we’ll often have some argument values that change very rarely, if at all. </span><span class="kobospan" id="kobo.1640.2">In a particular context, they’re essentially fixed. </span><span class="kobospan" id="kobo.1640.3">For example, we might find a need to write something like this in several places:</span></p>
<pre class="programlisting" id="listing-50"><code class="calibre13"><span class="kobospan" id="kobo.1641.1">reduce(operator.mul, ..., 1)</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.1642.1">Of the three argument values for </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1643.1">reduce()</span></span></span></span><span class="kobospan" id="kobo.1644.1">, only one – the iterable to process – actually changes. </span><span class="kobospan" id="kobo.1644.2">The operator and the initial value argument values are essentially fixed at </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1645.1">operator.mul</span></span></span></span><span class="kobospan" id="kobo.1646.1"> and </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1647.1">1</span></span></span></span><span class="kobospan" id="kobo.1648.1">.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.1649.1">Clearly, we can define a whole new function for this:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.1650.1">from collections.abc import Iterable 
 
from functools import reduce 
 
import operator 
 
 
 
def prod(iterable: Iterable[float]) -&gt; float: 
 
    return reduce(operator.mul, iterable, 1)</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.1651.1">Python has a few ways to simplify this pattern so we don’t have to repeat the boilerplate </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1652.1">def</span></span></span></span><span class="kobospan" id="kobo.1653.1"> and </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1654.1">return</span></span></span></span><span class="kobospan" id="kobo.1655.1"> statements.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.1656.1">The goal of this recipe is different from providing general default values. </span><span class="kobospan" id="kobo.1656.2">A partial function doesn’t provide a way for us to override the defaults. </span><span class="kobospan" id="kobo.1656.3">A partial function has specific values bound when it is defined. </span><span class="kobospan" id="kobo.1656.4">The idea is to be able to create many partial functions, each with specific argument values bound in advance. </span><span class="kobospan" id="kobo.1656.5">This is also sometimes</span><span id="dx1-556010"/><span class="kobospan" id="kobo.1657.1"> called a </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.1658.1">closure</span></span><span class="kobospan" id="kobo.1659.1">, but applied to some of the parameters. </span><span class="kobospan" id="kobo.1659.2">See </span><a href="ch007_split_001.xhtml#x1-1940006" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.1660.1">Picking an order for parameters based</span></span> <span class="cmti-10x-x"><span class="kobospan" id="kobo.1661.1">on partial functions</span></span></a><span class="kobospan" id="kobo.1662.1"> in </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.1663.1">Chapter</span></span><span class="cmti-10x-x"><span class="kobospan" id="kobo.1664.1"> </span></span><a href="ch007_split_000.xhtml#x1-1610003" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.1665.1">3</span></span></a><span class="kobospan" id="kobo.1666.1"> for more examples of partial function definition. </span><span id="x1-556011r1173"/></p>
<section data-number="0.12.8.1" id="getting-ready-77">
<h2 class="likechapterhead" data-number="0.12.8.1"><span><span class="kobospan" id="kobo.1667.1">9.8.1 </span></span> <span id="x1-5570001"/><span class="kobospan" id="kobo.1668.1">Getting ready</span></h2>
<p class="normal"><span class="kobospan" id="kobo.1669.1">Some statistical modeling</span><span id="dx1-557001"/><span class="kobospan" id="kobo.1670.1"> is done with standardized</span><span id="dx1-557002"/><span class="kobospan" id="kobo.1671.1"> values, sometimes called </span><span class="cmbx-10x-x"><span class="kobospan" id="kobo.1672.1">z-scores</span></span><span class="kobospan" id="kobo.1673.1">. </span><span class="kobospan" id="kobo.1673.2">The idea is to standardize a raw measurement onto a value that can be easily compared to a normal distribution, and easily compared to related numbers that may be measured in different units.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.1674.1">The calculation is this:</span></p>
<div class="math-display">
<span class="kobospan" id="kobo.1675.1"><img alt="z = x−-μ- σ " class="calibre9" src="../media/file69.png"/></span>
</div>
<p class="normal1"><span class="kobospan" id="kobo.1676.1">Here, </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.1677.1">x </span></span><span class="kobospan" id="kobo.1678.1">is a raw value, </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.1679.1">μ </span></span><span class="kobospan" id="kobo.1680.1">is the population mean, and </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.1681.1">σ </span></span><span class="kobospan" id="kobo.1682.1">is the population standard deviation. </span><span class="kobospan" id="kobo.1682.2">The value </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.1683.1">z </span></span><span class="kobospan" id="kobo.1684.1">will have a mean of 0 and a standard deviation of 1, providing a standardized value. </span><span class="kobospan" id="kobo.1684.2">We can use this value to spot </span><span class="cmbx-10x-x"><span class="kobospan" id="kobo.1685.1">outliers </span></span><span class="kobospan" id="kobo.1686.1">– values that are suspiciously far from the mean. </span><span class="kobospan" id="kobo.1686.2">We expect that (approximately) 99.7% of our </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.1687.1">z </span></span><span class="kobospan" id="kobo.1688.1">values will be between -3 and +3.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.1689.1">We could define a function to compute standard scores, like this:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.1690.1">def standardize(mean: float, stdev: float, x: float) -&gt; float: 
 
    return (x - mean) / stdev</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.1691.1">This </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1692.1">standardize()</span></span></span></span><span class="kobospan" id="kobo.1693.1"> function will compute a z-score from a raw score, </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.1694.1">x</span></span><span class="kobospan" id="kobo.1695.1">. </span><span class="kobospan" id="kobo.1695.2">When we use this function in a practical context, we’ll see that there are two kinds of argument values for the parameters:</span></p>
<ul class="calibre11">
<li class="calibre12"><p class="normal2"><span class="kobospan" id="kobo.1696.1">The argument values for the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1697.1">mean</span></span></span></span><span class="kobospan" id="kobo.1698.1"> and </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1699.1">stdev</span></span></span></span><span class="kobospan" id="kobo.1700.1"> parameters are essentially fixed. </span><span class="kobospan" id="kobo.1700.2">Once we’ve computed the population values, we’ll have to provide the same two values to the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1701.1">standardize()</span></span></span></span><span class="kobospan" id="kobo.1702.1"> function over and over again.</span></p></li>
<li class="calibre7"><p class="normal2"><span class="kobospan" id="kobo.1703.1">The value for the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1704.1">x</span></span></span></span><span class="kobospan" id="kobo.1705.1"> parameter will vary each time we evaluate the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1706.1">standardize()</span></span></span></span><span class="kobospan" id="kobo.1707.1"> function.</span></p></li>
</ul>
<p class="normal1"><span class="kobospan" id="kobo.1708.1">Let’s work with a collection of data samples with two variables, </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1709.1">x</span></span></span></span><span class="kobospan" id="kobo.1710.1"> and </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1711.1">y</span></span></span></span><span class="kobospan" id="kobo.1712.1">. </span><span class="kobospan" id="kobo.1712.2">These pairs are defined by the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1713.1">DataPair</span></span></span></span><span class="kobospan" id="kobo.1714.1"> class:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.1715.1">from dataclasses import dataclass 
 
 
 
@dataclass 
 
class DataPair: 
 
    x: float 
 
    y: float
                                                                     

                                                                     </span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.1716.1">As an example, we’ll compute</span><span id="dx1-557013"/><span class="kobospan" id="kobo.1717.1"> a standardized value for the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1718.1">x</span></span></span></span><span class="kobospan" id="kobo.1719.1"> attribute. </span><span class="kobospan" id="kobo.1719.2">This means computing the mean and standard deviation for the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1720.1">x</span></span></span></span><span class="kobospan" id="kobo.1721.1"> values. </span><span class="kobospan" id="kobo.1721.2">Then, we’ll need to apply the mean and standard deviation values to standardize the data in our collection. </span><span class="kobospan" id="kobo.1721.3">The computation looks like this:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.1722.1">&gt;&gt;&gt; import statistics 
 
&gt;&gt;&gt; mean_x = statistics.mean(item.x for item in data_1) 
 
&gt;&gt;&gt; stdev_x = statistics.stdev(item.x for item in data_1) 
 
&gt;&gt;&gt; for DataPair in data_1: 
 
... </span><span class="kobospan" id="kobo.1722.2">    z_x = standardize(mean_x, stdev_x, DataPair.x) 
 
... </span><span class="kobospan" id="kobo.1722.3">    print(DataPair, z_x)</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.1723.1">Providing the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1724.1">mean_x</span></span></span></span><span class="kobospan" id="kobo.1725.1">, and </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1726.1">stdev_x</span></span></span></span><span class="kobospan" id="kobo.1727.1"> values each time we evaluate the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1728.1">standardize()</span></span></span></span><span class="kobospan" id="kobo.1729.1"> function can clutter an algorithm with details that aren’t deeply important.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.1730.1">We can use a partial function to simplify this use of </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1731.1">standardize()</span></span></span></span><span class="kobospan" id="kobo.1732.1"> with two fixed argument values and one that is left to vary. </span><span id="x1-557021r1176"/></p>
</section>
<section data-number="0.12.8.2" id="how-to-do-it...-78">
<h2 class="likechapterhead" data-number="0.12.8.2"><span><span class="kobospan" id="kobo.1733.1">9.8.2 </span></span> <span id="x1-5580002"/><span class="kobospan" id="kobo.1734.1">How to do it...</span></h2>
<p class="normal"><span class="kobospan" id="kobo.1735.1">To simplify using a function with a number of fixed argument values, we can create a partial function. </span><span class="kobospan" id="kobo.1735.2">This recipe will show two ways to create a partial functions as separate mini-recipes:</span></p>
<ul class="calibre11">
<li class="calibre12"><p class="normal2"><span class="kobospan" id="kobo.1736.1">Using the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1737.1">partial()</span></span></span></span><span class="kobospan" id="kobo.1738.1"> function from the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1739.1">functools</span></span></span></span><span class="kobospan" id="kobo.1740.1"> module to build a new function from the full </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1741.1">standardize()</span></span></span></span><span class="kobospan" id="kobo.1742.1"> function</span></p></li>
<li class="calibre7"><p class="normal2"><span class="kobospan" id="kobo.1743.1">Creating a lambda object to supply argument</span><span id="dx1-558001"/><span class="kobospan" id="kobo.1744.1"> values that don’t change</span></p></li>
</ul>
<section data-number="0.12.8.2.1" id="using-functools.partial">
<h3 class="likesubsubsectionhead" data-number="0.12.8.2.1"><span id="x1-5590002"/><span class="kobospan" id="kobo.1745.1">Using functools.partial()</span></h3>
<ol class="calibre2">
<li class="calibre7"><div id="x1-559002x1" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.1746.1">Import the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1747.1">partial()</span></span></span></span><span class="kobospan" id="kobo.1748.1"> function from</span><span id="dx1-559003"/><span class="kobospan" id="kobo.1749.1"> the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1750.1">functools</span></span></span></span><span class="kobospan" id="kobo.1751.1"> module:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.1752.1">from functools import partial</span></code></pre>
</div></li>
<li class="calibre7"><div id="x1-559007x2" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.1753.1">Create a new function using </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1754.1">partial()</span></span></span></span><span class="kobospan" id="kobo.1755.1">. </span><span class="kobospan" id="kobo.1755.2">We provide the base function, plus the positional arguments that need to be included. </span><span class="kobospan" id="kobo.1755.3">Any parameters that are not supplied when the partial is defined must be supplied when the partial is evaluated: [firstline=79,lastline=79,gobble=4][python]src/ch09/recipe˙08.py</span></p>
</div></li>
</ol>
<p class="normal1"><span class="kobospan" id="kobo.1756.1">We’ve provided fixed values for the first two parameters, </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1757.1">mean</span></span></span></span><span class="kobospan" id="kobo.1758.1"> and </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1759.1">stdev</span></span></span></span><span class="kobospan" id="kobo.1760.1">, of the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1761.1">standardize()</span></span></span></span><span class="kobospan" id="kobo.1762.1"> function. </span><span class="kobospan" id="kobo.1762.2">We can now use the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1763.1">z()</span></span></span></span><span class="kobospan" id="kobo.1764.1"> function with a single value, </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1765.1">z(a)</span></span></span></span><span class="kobospan" id="kobo.1766.1">, and it will evaluate the expression </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1767.1">standardize(mean_x,</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1768.1"> stdev_x,</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1769.1"> a)</span></span></span></span><span class="kobospan" id="kobo.1770.1">.</span></p>
</section>
<section data-number="0.12.8.2.2" id="creating-a-lambda-object">
<h3 class="likesubsubsectionhead" data-number="0.12.8.2.2"><span id="x1-5600002"/><span class="kobospan" id="kobo.1771.1">Creating a lambda object</span></h3>
<ol class="calibre2">
<li class="calibre7"><div id="x1-560002x1" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.1772.1">Define a lambda object</span><span id="dx1-560003"/><span class="kobospan" id="kobo.1773.1"> that binds the fixed parameters: [firstline=105,lastline=105,gobble=8][python]src/ch09/recipe˙08.py</span></p>
</div></li>
<li class="calibre7"><div id="x1-560005x2" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.1774.1">Assign this lambda to a variable to create a callable object, </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1775.1">z()</span></span></span></span><span class="kobospan" id="kobo.1776.1">: [firstline=105,lastline=105,gobble=4][python]src/ch09/recipe˙08.py</span></p>
</div></li>
</ol>
<p class="normal1"><span class="kobospan" id="kobo.1777.1">This provides fixed values for the first two parameters, </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1778.1">mean</span></span></span></span><span class="kobospan" id="kobo.1779.1"> and </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1780.1">stdev</span></span></span></span><span class="kobospan" id="kobo.1781.1">, of the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1782.1">standardize()</span></span></span></span><span class="kobospan" id="kobo.1783.1"> function. </span><span class="kobospan" id="kobo.1783.2">We can now use the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1784.1">z()</span></span></span></span><span class="kobospan" id="kobo.1785.1"> lambda object with a single value, </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1786.1">z(a)</span></span></span></span><span class="kobospan" id="kobo.1787.1">, and it will evaluate the expression </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1788.1">standardize(mean_x,</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1789.1"> stdev_x,</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1790.1"> a)</span></span></span></span><span class="kobospan" id="kobo.1791.1">. </span><span id="x1-560006r1180"/></p>
</section>
</section>
<section data-number="0.12.8.3" id="how-it-works...-78">
<h2 class="likechapterhead" data-number="0.12.8.3"><span><span class="kobospan" id="kobo.1792.1">9.8.3 </span></span> <span id="x1-5610003"/><span class="kobospan" id="kobo.1793.1">How it works...</span></h2>
<p class="normal"><span class="kobospan" id="kobo.1794.1">Both techniques create a callable object – a function – named </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1795.1">z()</span></span></span></span><span class="kobospan" id="kobo.1796.1"> that has the values for </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1797.1">mean_x</span></span></span></span><span class="kobospan" id="kobo.1798.1"> and </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1799.1">stdev_x</span></span></span></span><span class="kobospan" id="kobo.1800.1"> already bound to the first two positional parameters. </span><span class="kobospan" id="kobo.1800.2">With either approach, we can now have processing that can look like this:</span></p>
<p class="normal1"><span class="kobospan" id="kobo.1801.1">[firstline=107,lastline=108,gobble=4][python]src/ch09/recipe˙08.py</span></p>
<p class="normal1"><span class="kobospan" id="kobo.1802.1">We’ve applied the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1803.1">z()</span></span></span></span><span class="kobospan" id="kobo.1804.1"> function</span><span id="dx1-561001"/><span class="kobospan" id="kobo.1805.1"> to each set of data. </span><span class="kobospan" id="kobo.1805.2">Because </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1806.1">z()</span></span></span></span><span class="kobospan" id="kobo.1807.1"> is a partial function and has some parameters already applied, its use is simplified.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.1808.1">There’s one significant difference between the two techniques for creating the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1809.1">z()</span></span></span></span><span class="kobospan" id="kobo.1810.1"> function:</span></p>
<ul class="calibre11">
<li class="calibre12"><p class="normal2"><span class="kobospan" id="kobo.1811.1">The </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1812.1">partial()</span></span></span></span><span class="kobospan" id="kobo.1813.1"> function binds the actual values of the parameters. </span><span class="kobospan" id="kobo.1813.2">Any subsequent change to the variables that were used </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.1814.1">will not </span></span><span class="kobospan" id="kobo.1815.1">change the definition of the partial function that’s created.</span></p></li>
<li class="calibre7"><p class="normal2"><span class="kobospan" id="kobo.1816.1">The lambda object binds the variable name, not the value. </span><span class="kobospan" id="kobo.1816.2">Any subsequent change to the variable’s value </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.1817.1">will </span></span><span class="kobospan" id="kobo.1818.1">change the way the lambda behaves.</span></p></li>
</ul>
<p class="normal1"><span class="kobospan" id="kobo.1819.1">We can modify the lambda slightly to bind specific values instead of names:</span></p>
<p class="normal1"><span class="kobospan" id="kobo.1820.1">[firstline=131,lastline=131,gobble=4][python]src/ch09/recipe˙08.py</span></p>
<p class="normal1"><span class="kobospan" id="kobo.1821.1">This extracts the current values of </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1822.1">mean_x</span></span></span></span><span class="kobospan" id="kobo.1823.1"> and </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1824.1">stdev_x</span></span></span></span><span class="kobospan" id="kobo.1825.1"> to create default values for the lambda object’s parameters. </span><span class="kobospan" id="kobo.1825.2">The values of </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1826.1">mean_x</span></span></span></span><span class="kobospan" id="kobo.1827.1"> and </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1828.1">stdev_x</span></span></span></span><span class="kobospan" id="kobo.1829.1"> are now irrelevant to the proper operation of the lambda object, </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1830.1">z()</span></span></span></span><span class="kobospan" id="kobo.1831.1">. </span><span id="x1-561002r1184"/></p>
</section>
<section data-number="0.12.8.4" id="theres-more...-69">
<h2 class="likechapterhead" data-number="0.12.8.4"><span><span class="kobospan" id="kobo.1832.1">9.8.4 </span></span> <span id="x1-5620004"/><span class="kobospan" id="kobo.1833.1">There’s more...</span></h2>
<p class="normal"><span class="kobospan" id="kobo.1834.1">We can provide keyword argument values as well as positional argument values when creating a partial function. </span><span class="kobospan" id="kobo.1834.2">While this works nicely in general, there are a few cases where it doesn’t work.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.1835.1">We started this recipe looking at the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1836.1">reduce()</span></span></span></span><span class="kobospan" id="kobo.1837.1"> function. </span><span class="kobospan" id="kobo.1837.2">Interestingly, this function is one example of functions that can’t be trivially turned into a partial function. </span><span class="kobospan" id="kobo.1837.3">The parameters aren’t in the ideal order for creating a partial and it doesn’t permit providing argument values by name.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.1838.1">It appears as though the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1839.1">reduce()</span></span></span></span><span class="kobospan" id="kobo.1840.1"> function is defined like this:</span></p>
<pre class="programlisting" id="listing-51"><code class="calibre13"><span class="kobospan" id="kobo.1841.1">def reduce(function, iterable, initializer=None)</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.1842.1">If this were the actual definition, we could do this:</span></p>
<pre class="programlisting" id="listing-52"><code class="calibre13"><span class="kobospan" id="kobo.1843.1">prod = partial(reduce(mul, initializer=1))</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.1844.1">Practically, the preceding example raises a </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1845.1">TypeError</span></span></span></span><span class="kobospan" id="kobo.1846.1">. </span><span class="kobospan" id="kobo.1846.2">It doesn’t work because the definition of </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1847.1">reduce()</span></span></span></span><span class="kobospan" id="kobo.1848.1"> does not take keyword argument values. </span><span class="kobospan" id="kobo.1848.2">Consequently, we can’t easily create partial functions that use it.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.1849.1">This means that we’re forced to use the following lambda technique:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.1850.1">&gt;&gt;&gt; from operator import mul 
 
&gt;&gt;&gt; from functools import reduce 
 
&gt;&gt;&gt; prod = lambda x: reduce(mul, x, 1)</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.1851.1">In Python, a function is an object. </span><span class="kobospan" id="kobo.1851.2">We’ve seen numerous ways that functions can be arguments to other functions. </span><span class="kobospan" id="kobo.1851.3">A function that accepts or returns another function as an argument</span><span id="dx1-562007"/><span class="kobospan" id="kobo.1852.1"> is sometimes called a </span><span class="cmbx-10x-x"><span class="kobospan" id="kobo.1853.1">higher-order</span></span> <span class="cmbx-10x-x"><span class="kobospan" id="kobo.1854.1">function</span></span><span class="kobospan" id="kobo.1855.1">.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.1856.1">Similarly, functions can also return a function object as a result. </span><span class="kobospan" id="kobo.1856.2">This means that we can create a function like this:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.1857.1">from collections.abc import Sequence, Callable 
 
import statistics 
 
 
 
def prepare_z(data: Sequence[DataPair]) -&gt; Callable[[float], float]: 
 
    mean_x = statistics.mean(item.x for item in data_1) 
 
    stdev_x = statistics.stdev(item.x for item in data_1) 
 
    return partial(standardize, mean_x, stdev_x)</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.1858.1">Here, we’ve defined a function over a sequence of type </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1859.1">DataPair</span></span></span></span><span class="kobospan" id="kobo.1860.1">, which are (</span><span class="cmti-10x-x"><span class="kobospan" id="kobo.1861.1">x,y</span></span><span class="kobospan" id="kobo.1862.1">) samples. </span><span class="kobospan" id="kobo.1862.2">We’ve computed the mean and standard deviation of the </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.1863.1">x </span></span><span class="kobospan" id="kobo.1864.1">attribute of each sample. </span><span class="kobospan" id="kobo.1864.2">We then created a partial function that can standardize scores based on the computed statistics. </span><span class="kobospan" id="kobo.1864.3">The result of this function is a function we can use for data analysis.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.1865.1">The following example shows how this newly created function is used:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.1866.1">&gt;&gt;&gt; z = prepare_z(data_1) 
 
&gt;&gt;&gt; for DataPair in data_1: 
 
... </span><span class="kobospan" id="kobo.1866.2">    print(DataPair, z(DataPair.x))</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.1867.1">The result of the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1868.1">prepare_z()</span></span></span></span><span class="kobospan" id="kobo.1869.1"> function is a callable object that will standardize a score based on the computed mean and standard deviation. </span><span id="x1-562020r1185"/></p>
</section>
<section data-number="0.12.8.5" id="see-also-76">
<h2 class="likechapterhead" data-number="0.12.8.5"><span><span class="kobospan" id="kobo.1870.1">9.8.5 </span></span> <span id="x1-5630005"/><span class="kobospan" id="kobo.1871.1">See also</span></h2>
<ul class="calibre16">
<li class="calibre12"><p class="normal2"><span class="kobospan" id="kobo.1872.1">See </span><a href="ch007_split_001.xhtml#x1-1940006" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.1873.1">Picking an order for parameters based on partial functions</span></span></a><span class="kobospan" id="kobo.1874.1"> in </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.1875.1">Chapter</span></span><span class="cmti-10x-x"><span class="kobospan" id="kobo.1876.1"> </span></span><a href="ch007_split_000.xhtml#x1-1610003" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.1877.1">3</span></span></a><span class="kobospan" id="kobo.1878.1"> for more examples of partial function definition.</span></p></li>
</ul>
<p class="normal1"><span id="x1-563001r1174"/></p>
</section>
</section>
<section data-number="0.12.9" id="writing-recursive-generator-functions-with-the-yield-from-statement">
<h1 class="unnumbered" data-number="0.12.9"><span><span class="kobospan" id="kobo.1879.1">9.9 </span></span> <span id="x1-5640009"/><span class="kobospan" id="kobo.1880.1">Writing recursive generator functions with the yield from statement</span></h1>
<p class="normal"><span class="kobospan" id="kobo.1881.1">Many algorithms can be expressed</span><span id="dx1-564001"/><span class="kobospan" id="kobo.1882.1"> neatly as</span><span id="dx1-564002"/><span class="kobospan" id="kobo.1883.1"> recursions. </span><span class="kobospan" id="kobo.1883.2">In the </span><a href="ch007_split_001.xhtml#x1-2090008" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.1884.1">Designing</span></span> <span class="cmti-10x-x"><span class="kobospan" id="kobo.1885.1">recursive functions around Python’s stack limits</span></span></a><span class="kobospan" id="kobo.1886.1"> recipe, we looked at some recursive functions that could be optimized to reduce the number of function calls.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.1887.1">When we look at some data structures, we see that they involve recursion. </span><span class="kobospan" id="kobo.1887.2">In particular, JSON documents (as well as XML and HTML documents) can have a recursive structure. </span><span class="kobospan" id="kobo.1887.3">A JSON document is a complex object that can contain other complex objects within it.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.1888.1">In many cases, there are advantages to using generators for processing these kinds of structures. </span><span class="kobospan" id="kobo.1888.2">In this recipe, we’ll look at ways to handle recursive data structures with generator functions. </span><span id="x1-564003r1189"/></p>
<section data-number="0.12.9.1" id="getting-ready-78">
<h2 class="likechapterhead" data-number="0.12.9.1"><span><span class="kobospan" id="kobo.1889.1">9.9.1 </span></span> <span id="x1-5650001"/><span class="kobospan" id="kobo.1890.1">Getting ready</span></h2>
<p class="normal"><span class="kobospan" id="kobo.1891.1">In this recipe, we’ll look at a way to search</span><span id="dx1-565001"/><span class="kobospan" id="kobo.1892.1"> for all matching values</span><span id="dx1-565002"/><span class="kobospan" id="kobo.1893.1"> in a complex, recursive data structure. </span><span class="kobospan" id="kobo.1893.2">When working with complex JSON documents, they often contain dict-of-dict, dict-of-list, list-of-dict, and list-of-list structures. </span><span class="kobospan" id="kobo.1893.3">Of course, a JSON document is not limited to two levels; dict-of-dict can really mean dict-of-dict-of.... </span><span class="kobospan" id="kobo.1893.4">Similarly, dict-of-list could mean dict-of-list-of.... </span><span class="kobospan" id="kobo.1893.5">The search algorithm must descend through the entire structure looking for a particular key or value.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.1894.1">A document with a complex structure might look like this:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.1895.1">document = { 
 
    "field": "value1", 
 
    "field2": "value", 
 
    "array": [ 
 
        {"array_item_key1": "value"}, 
 
        {"array_item_key2": "array_item_value2"} 
 
    ], 
 
    "object": { 
 
        "attribute1": "value", 
 
        "attribute2": "value2" 
 
    }, 
 
}</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.1896.1">The value </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1897.1">"value"</span></span></span></span><span class="kobospan" id="kobo.1898.1"> can be found in three places:</span></p>
<ul class="calibre11">
<li class="calibre12"><p class="normal2"><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1899.1">["array",</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1900.1"> 0,</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1901.1"> "array_item_key1"]</span></span></span></span><span class="kobospan" id="kobo.1902.1">: This path starts with the top-level field named array, then visits item zero of a list, then a field named </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1903.1">array_item_key1</span></span></span></span><span class="kobospan" id="kobo.1904.1">.</span></p></li>
<li class="calibre7"><p class="normal2"><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1905.1">["field2"]</span></span></span></span><span class="kobospan" id="kobo.1906.1">: This path has just a single field name where the value is found.</span></p></li>
<li class="calibre7"><p class="normal2"><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1907.1">["object",</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1908.1"> "attribute1"]</span></span></span></span><span class="kobospan" id="kobo.1909.1">: This path starts with the top-level field named object, then the child, attribute1, of that field.</span></p></li>
</ul>
<p class="normal1"><span class="kobospan" id="kobo.1910.1">A </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1911.1">find_value()</span></span></span></span><span class="kobospan" id="kobo.1912.1"> function should yield all these paths when it searches the overall document for the target value. </span><span class="kobospan" id="kobo.1912.2">The core algorithm for this is a depth-first search. </span><span class="kobospan" id="kobo.1912.3">The output from this function must be a list of paths that identify the target value. </span><span class="kobospan" id="kobo.1912.4">Each path will be a sequence of field names or field names mixed with index positions. </span><span id="x1-565016r1191"/></p>
</section>
<section data-number="0.12.9.2" id="how-to-do-it...-79">
<h2 class="likechapterhead" data-number="0.12.9.2"><span><span class="kobospan" id="kobo.1913.1">9.9.2 </span></span> <span id="x1-5660002"/><span class="kobospan" id="kobo.1914.1">How to do it...</span></h2>
<p class="normal"><span class="kobospan" id="kobo.1915.1">We’ll start with an overview</span><span id="dx1-566001"/><span class="kobospan" id="kobo.1916.1"> of the depth-first algorithm</span><span id="dx1-566002"/><span class="kobospan" id="kobo.1917.1"> to visit all of the nodes in a JSON document:</span></p>
<ol class="calibre4">
<li class="calibre7"><div id="x1-566004x1" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.1918.1">Start with a sketch of the function to process each of the alternative structures in the overall data structure. </span><span class="kobospan" id="kobo.1918.2">Here are the imports and some type hints:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.1919.1">from collections.abc import Iterator 
 
from typing import Any, TypeAlias 
 
 
 
JSON_DOC: TypeAlias = ( 
 
    None | str | int | float | bool | dict[str, Any] | list[Any] 
 
) 
 
Node_Id: TypeAlias = Any</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.1920.1">Here is the sketch of the function:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.1921.1">def find_value_sketch( 
 
    value: Any, 
 
    node: JSON_DOC, 
 
    path: list[Node_Id] | None = None 
 
) -&gt; Iterator[list[Node_Id]]: 
 
    if path is None: 
 
        path = [] 
 
    match node: 
 
        case dict() as dnode: 
 
            pass  # apply find_value to each key in dnode 
 
        case list() as lnode: 
 
            pass  # apply find_value to each item in lnode 
 
        case _ as pnode: # str, int, float, bool, None 
 
            if pnode == value: 
 
                yield path</span></code></pre>
</div></li>
<li class="calibre7"><div id="x1-566030x2" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.1922.1">Here’s a starting version to look at each key of a dictionary. </span><span class="kobospan" id="kobo.1922.2">This replaces the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1923.1">#</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1924.1"> apply</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1925.1"> find_value</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1926.1"> to</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1927.1"> each</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1928.1"> key</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1929.1"> in</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1930.1"> dnode</span></span></span></span><span class="kobospan" id="kobo.1931.1"> line in the preceding code. </span><span class="kobospan" id="kobo.1931.2">Test this to be sure the recursion works properly: [firstline=58,lastline=60,gobble=8][python]src/ch09/recipe˙10.py</span></p>
</div></li>
<li class="calibre7"><div id="x1-566032x3" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.1932.1">Replace the inner </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1933.1">for</span></span></span></span><span class="kobospan" id="kobo.1934.1"> with a </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1935.1">yield</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1936.1"> from</span></span></span></span><span class="kobospan" id="kobo.1937.1"> statement: [firstline=98,lastline=100,gobble=8][python]src/ch09/recipe˙10.py</span></p>
</div></li>
<li class="calibre7"><div id="x1-566034x4" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.1938.1">This has to be done for the list</span><span id="dx1-566035"/><span class="kobospan" id="kobo.1939.1"> case as well. </span><span class="kobospan" id="kobo.1939.2">Start an examination</span><span id="dx1-566036"/><span class="kobospan" id="kobo.1940.1"> of each item in the list: [firstline=62,lastline=64,gobble=8][python]src/ch09/recipe˙10.py</span></p>
</div></li>
<li class="calibre7"><div id="x1-566038x5" class="calibre14">
<p class="normal2"><span class="kobospan" id="kobo.1941.1">Replace the inner </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1942.1">for</span></span></span></span><span class="kobospan" id="kobo.1943.1"> with a </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1944.1">yield</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1945.1"> from</span></span></span></span><span class="kobospan" id="kobo.1946.1"> statement: [firstline=102,lastline=104,gobble=8][python]src/ch09/recipe˙10.py</span></p>
</div></li>
</ol>
<p class="normal1"><span class="kobospan" id="kobo.1947.1">The complete depth-first </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1948.1">find_value()</span></span></span></span><span class="kobospan" id="kobo.1949.1"> search function, when complete, will look like this:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.1950.1">def find_value( 
 
    value: Any, 
 
    node: JSON_DOC, 
 
    path: list[Node_Id] | None = None 
 
) -&gt; Iterator[list[Node_Id]]: 
 
    if path is None: 
 
        path = [] 
 
    match node: 
 
        case dict() as dnode: 
 
            for key in sorted(dnode.keys()): 
 
                yield from find_value( 
 
                    value, node[key], path + [key]) 
 
        case list() as lnode: 
 
            for index, item in enumerate(lnode): 
 
                yield from find_value( 
 
                    value, item, path + [index]) 
 
        case _ as pnode: 
 
            # str, int, float, bool, None 
 
            if pnode == value: 
 
                yield path</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.1951.1">When we use the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1952.1">find_value()</span></span></span></span><span class="kobospan" id="kobo.1953.1"> function, it looks like this:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.1954.1">&gt;&gt;&gt; places = list(find_value(’value’, document)) 
 
&gt;&gt;&gt; places 
 
[[’array’, 0, ’array_item_key1’], [’field2’], [’object’, ’attribute1’]]</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.1955.1">The resulting list has three items. </span><span class="kobospan" id="kobo.1955.2">Each of these</span><span id="dx1-566064"/><span class="kobospan" id="kobo.1956.1"> is a list of keys</span><span id="dx1-566065"/><span class="kobospan" id="kobo.1957.1"> that form a path to an item with the target value of </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1958.1">"value"</span></span></span></span><span class="kobospan" id="kobo.1959.1">. </span><span id="x1-566066r1193"/></p>
</section>
<section data-number="0.12.9.3" id="how-it-works...-79">
<h2 class="likechapterhead" data-number="0.12.9.3"><span><span class="kobospan" id="kobo.1960.1">9.9.3 </span></span> <span id="x1-5670003"/><span class="kobospan" id="kobo.1961.1">How it works...</span></h2>
<p class="normal"><span class="kobospan" id="kobo.1962.1">For background, see the </span><a href="ch013_split_000.xhtml#x1-5030001" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.1963.1">Writing generator functions with the yield statement</span></span></a><span class="kobospan" id="kobo.1964.1"> recipe in this chapter.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.1965.1">The </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1966.1">yield</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1967.1"> from</span></span></span></span><span class="kobospan" id="kobo.1968.1"> statement is shorthand for:</span></p>
<p class="normal1"><span class="kobospan" id="kobo.1969.1">[firstline=135,lastline=136,gobble=8][python]src/ch09/recipe˙10.py</span></p>
<p class="normal1"><span class="kobospan" id="kobo.1970.1">The </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1971.1">yield</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1972.1"> from</span></span></span></span><span class="kobospan" id="kobo.1973.1"> statement lets us write a succinct recursive algorithm that will behave as an iterator and properly yield multiple values. </span><span class="kobospan" id="kobo.1973.2">It saves the overhead of a boilerplate </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1974.1">for</span></span></span></span><span class="kobospan" id="kobo.1975.1"> statement.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.1976.1">This can also be used in contexts that don’t involve a recursive function. </span><span class="kobospan" id="kobo.1976.2">It’s entirely sensible to use a </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1977.1">yield</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.1978.1"> from</span></span></span></span><span class="kobospan" id="kobo.1979.1"> statement anywhere that an iterable result is involved. </span><span class="kobospan" id="kobo.1979.2">It’s a handy simplification for recursive functions because it preserves a clearly recursive structure. </span><span id="x1-567001r1198"/></p>
</section>
<section data-number="0.12.9.4" id="theres-more...-70">
<h2 class="likechapterhead" data-number="0.12.9.4"><span><span class="kobospan" id="kobo.1980.1">9.9.4 </span></span> <span id="x1-5680004"/><span class="kobospan" id="kobo.1981.1">There’s more...</span></h2>
<p class="normal"><span class="kobospan" id="kobo.1982.1">Another common style of definition assembles a list of items using</span><span id="dx1-568001"/><span class="kobospan" id="kobo.1983.1"> append operations. </span><span class="kobospan" id="kobo.1983.2">We can rewrite this into an iterator and avoid the overhead of building and mutating a list object.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.1984.1">When factoring a number, we can define the set of prime factors of a number, </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.1985.1">x</span></span><span class="kobospan" id="kobo.1986.1">, like this:</span></p>
<div class="math-display">
<span class="kobospan" id="kobo.1987.1"><img alt=" ( |{ F(x) = x if x is prime |( x √-- n∪ F (n) if x ≡ 0 mod n and 2 ≤ n ≤ x " class="calibre9" src="../media/file70.png"/></span>
</div>
<p class="normal1"><span class="kobospan" id="kobo.1988.1">If the value, </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.1989.1">x</span></span><span class="kobospan" id="kobo.1990.1">, is prime, it has only itself in the set of prime factors. </span><span class="kobospan" id="kobo.1990.2">Otherwise, there must be some prime number, </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.1991.1">n</span></span><span class="kobospan" id="kobo.1992.1">, which is the least factor of </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.1993.1">x</span></span><span class="kobospan" id="kobo.1994.1">. </span><span class="kobospan" id="kobo.1994.2">We can assemble a set of factors starting with this number </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.1995.1">n </span></span><span class="kobospan" id="kobo.1996.1">and then append all factors of </span><span class="kobospan" id="kobo.1997.1"><img alt="xn" src="../media/file71.png" class="calibre9"/></span><span class="kobospan" id="kobo.1998.1">. </span><span class="kobospan" id="kobo.1998.2">To be sure that only prime factors are found, </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.1999.1">n </span></span><span class="kobospan" id="kobo.2000.1">must be prime. </span><span class="kobospan" id="kobo.2000.2">If we search ascending values of </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.2001.1">n</span></span><span class="kobospan" id="kobo.2002.1">, starting from 2, we’ll find prime factors before finding composite factors.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.2003.1">An eager approach builds a complete list of factors. </span><span class="kobospan" id="kobo.2003.2">A lazy approach be be a generator of factors for a consumer. </span><span class="kobospan" id="kobo.2003.3">Here’s an eager list-building function:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.2004.1">import math 
 
 
 
def factor_list(x: int) -&gt; list[int]: 
 
    limit = int(math.sqrt(x) + 1) 
 
    for n in range(2, limit): 
 
        q, r = divmod(x, n) 
 
        if r == 0: 
 
            return [n] + factor_list(q) 
 
    return [x]</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.2005.1">This </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.2006.1">factor_list()</span></span></span></span><span class="kobospan" id="kobo.2007.1"> function will build a list object. </span><span class="kobospan" id="kobo.2007.2">If a factor, </span><span class="cmti-10x-x"><span class="kobospan" id="kobo.2008.1">n</span></span><span class="kobospan" id="kobo.2009.1">, is found, it will start a list with that factor. </span><span class="kobospan" id="kobo.2009.2">It will then extend the list with the factors built from the value of </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.2010.1">x</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.2011.1"> //</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.2012.1"> n</span></span></span></span><span class="kobospan" id="kobo.2013.1">. </span><span class="kobospan" id="kobo.2013.2">If there are no factors of </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.2014.1">x</span></span></span></span><span class="kobospan" id="kobo.2015.1">, then the value is prime, and this returns a list with only the value of </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.2016.1">x</span></span></span></span><span class="kobospan" id="kobo.2017.1">.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.2018.1">(This has an inefficiency stemming from the way this searches for composite numbers as well as prime numbers. </span><span class="kobospan" id="kobo.2018.2">For example, after testing 2 and 3, this will also test 4 and 6, even though they’re composite and all of their factors have already been tested. </span><span class="kobospan" id="kobo.2018.3">The example is centered on list-building, not efficient factoring of numbers.)</span></p>
<p class="normal1"><span class="kobospan" id="kobo.2019.1">We can rewrite this as an iterator by replacing the recursive calls with </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.2020.1">yield</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.2021.1"> from</span></span></span></span><span class="kobospan" id="kobo.2022.1"> statements. </span><span class="kobospan" id="kobo.2022.2">The function will look like this:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.2023.1">def factor_iter(x: int) -&gt; Iterator[int]: 
 
    limit = int(math.sqrt(x) + 1) 
 
    for n in range(2, limit): 
 
        q, r = divmod(x, n) 
 
        if r == 0: 
 
            yield n 
 
            yield from factor_iter(q) 
 
            return 
 
    yield x</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.2024.1">When a factor is found, the function will yield the factor, </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.2025.1">n</span></span></span></span><span class="kobospan" id="kobo.2026.1">, followed by all other factors found via a recursive call to </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.2027.1">factor_iter()</span></span></span></span><span class="kobospan" id="kobo.2028.1">. </span><span class="kobospan" id="kobo.2028.2">If no factors are found, the function will yield the prime number, </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.2029.1">x</span></span></span></span><span class="kobospan" id="kobo.2030.1">, and nothing more.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.2031.1">Using an iterator allows the client of this function to build any kind of collection from the factors. </span><span class="kobospan" id="kobo.2031.2">Instead of being limited to always creating a </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.2032.1">list</span></span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.2033.1"> object</span></span></span></span><span class="kobospan" id="kobo.2034.1">, we can create a multiset using the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.2035.1">collections.Counter</span></span></span></span><span class="kobospan" id="kobo.2036.1"> class. </span><span class="kobospan" id="kobo.2036.2">It would look like this:</span></p>
<pre class="programlisting"><code class="calibre13"><span class="kobospan" id="kobo.2037.1">&gt;&gt;&gt; from collections import Counter 
 
 
 
&gt;&gt;&gt; Counter(factor_iter(384)) 
 
Counter({2: 7, 3: 1})</span></code></pre>
<p class="normal1"><span class="kobospan" id="kobo.2038.1">This shows us that:</span></p>
<div class="math-display">
<span class="kobospan" id="kobo.2039.1"><img alt="384 = 27 × 3 " class="calibre9" src="../media/file72.png"/></span>
</div>
<p class="normal1"><span class="kobospan" id="kobo.2040.1">In some cases, this kind of multiset can be easier to work with than a simple list of factors.</span></p>
<p class="normal1"><span class="kobospan" id="kobo.2041.1">What’s important is that the multiset was created directly from the </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.2042.1">factor_iter()</span></span></span></span><span class="kobospan" id="kobo.2043.1"> iterator without creating any intermediate </span><span class="obeylines-h"><span><span class="cmtt-10x-x"><span class="kobospan" id="kobo.2044.1">list</span></span></span></span><span class="kobospan" id="kobo.2045.1"> objects. </span><span class="kobospan" id="kobo.2045.2">This kind of optimization lets us build complex algorithms that aren’t forced to consume large volumes of memory. </span><span id="x1-568027r1199"/></p>
</section>
<section data-number="0.12.9.5" id="see-also-77">
<h2 class="likechapterhead" data-number="0.12.9.5"><span><span class="kobospan" id="kobo.2046.1">9.9.5 </span></span> <span id="x1-5690005"/><span class="kobospan" id="kobo.2047.1">See also</span></h2>
<ul class="calibre16">
<li class="calibre12"><p class="normal2"><span class="kobospan" id="kobo.2048.1">In the </span><a href="ch007_split_001.xhtml#x1-2090008" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.2049.1">Designing recursive functions around Python’s stack limits</span></span></a><span class="kobospan" id="kobo.2050.1"> recipe, earlier in this chapter, we covered the core design patterns for recursive functions. </span><span class="kobospan" id="kobo.2050.2">This recipe provides an alternative way to create the results.</span></p></li>
<li class="calibre7"><p class="normal2"><span class="kobospan" id="kobo.2051.1">For background, see the </span><a href="ch013_split_000.xhtml#x1-5030001" class="url"><span class="cmti-10x-x"><span class="kobospan" id="kobo.2052.1">Writing generator functions with the yield</span></span> <span class="cmti-10x-x"><span class="kobospan" id="kobo.2053.1">statement</span></span></a><span class="kobospan" id="kobo.2054.1"> recipe in this chapter.</span></p></li>
</ul>
<p class="normal1"><span id="x1-569001r1190"/></p>
</section>
</section>
<section data-number="0.12.12" id="join-our-community-discord-space-9">
<h1 class="unnumbered" data-number="0.12.12"><span id="x1-57200011"/><span class="kobospan" id="kobo.2055.1">Join our community Discord space</span></h1>
<p class="normal"><span class="kobospan" id="kobo.2056.1">Join our Python Discord workspace to discuss and find out more about the book: </span><a class="url" href="https://packt.link/dHrHU"><span class="url1"><span class="kobospan" id="kobo.2057.1">https://packt.link/dHrHU</span></span></a></p>
<p class="normal1"><span class="kobospan" id="kobo.2058.1"><img alt="PIC" src="../media/file1.png" class="calibre9"/></span> <span id="x1-572001r1053"/></p>
</section>
</section>
</body></html>