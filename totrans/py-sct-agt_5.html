<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch05"/>Chapter 5. A Spymaster's More Sensitive Analyses</h1></div></div></div><p>Most of our previous espionage missions focused on bulk data collection and processing. HQ doesn't always want details. Sometimes it needs summaries and assessments. This means calculating central tendencies, summaries, trends, and correlations, which means we need to write more sophisticated algorithms.</p><p>We will skirt the borders of some very heavy-duty statistical algorithms. Once we cross the frontier, we will need more powerful tools. For additional tools to support sophisticated numeric <a id="id592" class="indexterm"/>processing, check <a class="ulink" href="http://www.numpy.org">http://www.numpy.org</a>. For some analyses, we may be more successful using the <a id="id593" class="indexterm"/>SciPy package (<a class="ulink" href="http://www.scipy.org">http://www.scipy.org</a>). A good book to refer is <em>Learning SciPy for Numerical and Scientific Computing</em>, <em>Francisco J. Blanco-Silva</em>, <em>Packt Publishing</em> (<a class="ulink" href="http://www.packtpub.com/learning-scipy-for-numerical-and-scientific-computing/book">http://www.packtpub.com/learning-scipy-for-numerical-and-scientific-computing/book</a>).</p><p>Another direction we could be pulled in includes the analysis of natural language documents. Reports, speeches, books, and articles are sometimes as important as basic facts and figures. If we want to work with words and language, we need to use the <strong>Natural Language Toolkit</strong> (<strong>NLTK</strong>). More<a id="id594" class="indexterm"/> information on this can be found at <a class="ulink" href="http://www.nltk.org">http://www.nltk.org</a>.</p><p>In this chapter, we'll look at several more advanced topics that secret agents need to master, such as:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Computing <em>central tendency</em>—mean, median, and mode—of the data we've gathered.</li><li class="listitem" style="list-style-type: disc">Interrogating CSV files to extract information.</li><li class="listitem" style="list-style-type: disc">More tips and techniques to use Python generator functions.</li><li class="listitem" style="list-style-type: disc">Designing higher-level constructs such as Python modules, libraries, and applications.</li><li class="listitem" style="list-style-type: disc">A quick introduction to class definitions.</li><li class="listitem" style="list-style-type: disc">Computations of standard deviation, standardized scores, and the coefficient of correlation. This kind of analysis adds value to intelligence assets. Any secret agent can ferret out the raw data. It takes real skill to provide useful summaries.</li><li class="listitem" style="list-style-type: disc">How to use doctest to assure that these more sophisticated algorithms really work. Presence of a software bug raises serious questions about the overall quality of the data being reported.</li></ul></div><p>Being a secret agent isn't all car chases and confusing cocktail recipes in posh restaurants. <em>Shaken? Stirred? Who can remember?</em>
</p><p>Sometimes, we need to tackle some rather complex analysis questions that HQ has assigned us. How can we work with per capita cheese consumption, accidental suffocation and strangulation in bed, and the number of doctorates in civil engineering? What Python components should we apply to this problem?</p><div><div><div><div><h1 class="title"><a id="ch05lvl1sec36"/>Creating statistical summaries</h1></div></div></div><p>One essential <a id="id595" class="indexterm"/>kind of statistical summary is the <em>measure of central tendency</em>. There are several variations on this theme; mean, mode, and median, which are explained as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The mean, also known as the average, combines all of the values into a single value</li><li class="listitem" style="list-style-type: disc">The median is the middlemost value—the data must be sorted to locate the one in the middle</li><li class="listitem" style="list-style-type: disc">The mode is the most common value</li></ul></div><p>None of these is perfect to describe a set of data. Data that is truly random can often be summarized by the mean. Data that isn't random, however, can be better summarized by the median. With continuous data, each value might differ slightly from another. Every measurement in a small set of samples may be unique, making a mode meaningless.</p><p>As a consequence, we'll need algorithms to compute all three of these essential summaries. First, we need some data to work with.</p><p>In <a class="link" href="ch02.html" title="Chapter 2. Acquiring Intelligence Data">Chapter 2</a>, <em>Acquiring Intelligence Data</em>, HQ asked us to gather cheese consumption data. We used the URL <a class="ulink" href="http://www.ers.usda.gov/datafiles/Dairy_Data/chezcon_1_.xls">http://www.ers.usda.gov/datafiles/Dairy_Data/chezcon_1_.xls</a>.</p><p>Sadly, the data was in a format that we can't easily automate, forcing us to copy and paste the annual cheese consumption data. This is what we got. Hopefully, there aren't many errors introduced by copying and pasting. The following is the data that we gathered:</p><div><pre class="programlisting">year_cheese = [(2000, 29.87), (2001, 30.12), (2002, 30.6), (2003, 30.66),
    (2004, 31.33), (2005, 32.62), (2006, 32.73), (2007, 33.5),
    (2008, 32.84), (2009, 33.02), (2010, 32.92), (2011, 33.27),
    (2012, 33.51)]</pre></div><p>This will serve as a handy dataset that we can use.</p><p>Note that we<a id="id596" class="indexterm"/> can type this on multiple lines at the <code class="literal">&gt;&gt;&gt;</code> prompt. Python needs to see a matching pair of <code class="literal">[</code> and <code class="literal">]</code> to consider the statement complete. The matching <code class="literal">[]</code> rule allows the users to enter long statements comfortably.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec90"/>Parsing the raw data file</h2></div></div></div><p>We've been given <a id="id597" class="indexterm"/>the cause of death using ICD code W75 as <em>accidental suffocation and strangulation in bed</em>. It's not perfectly clear what HQ thinks this data means. However, it has somehow become important. We went to the <a class="ulink" href="http://wonder.cdc.gov">http://wonder.cdc.gov</a> website to get the summary of cause of death by year.</p><p>We wound up with a file that starts out like this:</p><div><pre class="programlisting">"Notes"  "Cause of death"  "Cause of death Code"  "Year"  "Year Code"  Deaths  Population  Crude Rate 
  "Accidental suffocation and strangulation in bed"  "W75"  "2000"  "2000"  327  281421906	0.1 
  "Accidental suffocation and strangulation in bed"  "W75"  "2001"  "2001"  456  284968955  0.2 
 … etc. … </pre></div><p>This is a bit painful to process. It's almost—but not quite—in CSV notation. It's true that there aren't many commas, but there are tab characters encoded as <code class="literal">\t</code> in Python. These characters are sufficient to make a CSV file, where the tab takes the role of a comma.</p><p>We can read this file using Python's <code class="literal">csv</code> module with a <code class="literal">\t</code> delimiter:</p><div><pre class="programlisting">import csv
with open( "Cause of Death by Year.txt" ) as source:
    rdr= csv.DictReader( source, delimiter="\t" )
    for row in rdr:
        if row['Notes'] == "---": break
        print(row)</pre></div><p>This snippet will create a <code class="literal">csv.DictReader</code> object using the <code class="literal">\t</code> delimiter instead of the default value of <code class="literal">,</code>. Once we have a reader that uses <code class="literal">\t</code> characters, we can iterate through the rows in the document. Each row will appear as a dictionary. The column title, found in the first row, will be the key for the items in the dictionary.</p><p>We used the expression <code class="literal">row['Notes']</code> to get the value from the <code class="literal">Notes</code> column of each row. If the notes are equal to <code class="literal">---</code>, this is the beginning of the footnotes for the data. What follows is a great deal of metadata.</p><p>The resulting dataset can be summarized easily. First, we'll create a generator function to parse our data:</p><div><pre class="programlisting">def deaths():
    with open( "Cause of Death by Year.txt" ) as source:
        rdr= csv.DictReader( source, delimiter="\t" )
        for row in rdr:
            if row['Notes'] == "Total": break
            yield int(row['Year']), int(row['Deaths'])</pre></div><p>We replaced <a id="id598" class="indexterm"/>the <code class="literal">print()</code> function with the <code class="literal">yield</code> statement. We also replaced <code class="literal">---</code> with <code class="literal">Total</code> to prune the totals off the data. We can compute our own totals. Finally, we converted the year and deaths to integer values so that we can calculate with them.</p><p>This function will iterate through the various rows of data producing two-tuples of the year and the number of deaths.</p><p>Once we have this generator function, we can collect the summary like this:</p><div><pre class="programlisting">year_deaths = list( deaths() )</pre></div><p>We get this as a result:</p><div><pre class="programlisting">[(2000, 327), (2001, 456), (2002, 509), (2003, 497), 
(2004, 596), (2005, 573), (2006, 661), (2007, 741), 
(2008, 809), (2009, 717), (2010, 684)]</pre></div><p>This seems to be the data they're looking for. It gives us more data to work with.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec91"/>Finding an average value</h2></div></div></div><p>The mean is <a id="id599" class="indexterm"/>defined using a daunting formula which looks like <img src="img/0420OS_05_01.jpg" alt="Finding an average value"/>. While the formula looks complex, the various parts are first-class built-in functions of Python.</p><p>The big sigma <img src="img/0420OS_05_03.jpg" alt="Finding an average value"/> is math-speak for the Python <code class="literal">sum()</code> function.</p><p>Given a list of values, the mean is this:</p><div><pre class="programlisting">def mean( values ):
    return sum(values)/len(values)</pre></div><p>Our two sets of data are provided as two-tuples with year and amount. We need to reel in the years, stowing away the time for later use. We can use a simple generator function for this. We can use<a id="id600" class="indexterm"/> the expression <code class="literal">cheese for year, cheese in year_cheese</code> to separate the cheese portion of each two-tuple.</p><p>Here's what happens when we use a generator with our <code class="literal">mean()</code> function:</p><div><pre class="programlisting">&gt;&gt;&gt; mean( cheese for year, cheese in year_cheese )
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 2, in mean
TypeError: object of type 'generator' has no len()</pre></div><p>Wait. What?</p><p>How can the simple generator not work?</p><p>Actually, it does work. It just doesn't do what we assume.</p><div><div><div><div><h3 class="title"><a id="ch05lvl3sec20"/>Understanding generator expressions</h3></div></div></div><p>There are three<a id="id601" class="indexterm"/> important rules that apply to <a id="id602" class="indexterm"/>Python generators:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Many—but not all—functions will work with generator objects. Some functions, however, will not work well with generators; they require a sequence object.</li><li class="listitem" style="list-style-type: disc">The objects yielded by a generator aren't created until absolutely necessary. We can describe a generator as being lazy. A list, for example, actually contains objects. A generator expression can operate similarly to a list, but the objects aren't really created until needed.</li><li class="listitem" style="list-style-type: disc">Generator functions can only be used once. A list can be reused indefinitely.</li></ul></div><p>The first restriction applies in particular to the <code class="literal">len()</code> function. This<a id="id603" class="indexterm"/> function works for lists, tuples, and sets. However, it doesn't work for generators. There's no way to know how many items will eventually be created by a generator, so <code class="literal">len()</code> can't return the size.</p><p>The second restriction is mostly relevant when we try to print the results of a generator. We'll see something such as <code class="literal">&lt;generator object &lt;genexpr&gt; at 0x1007b4460&gt;</code>, until we actually evaluate the generator and create the objects.</p><p>The third restriction is less obvious. We will to need an example. Let's try to work around the <code class="literal">len()</code> problem by defining a <code class="literal">count()</code> function that counts items yielded by a generator function:</p><div><pre class="programlisting">def count( values ):
    return sum( 1 for x in values )</pre></div><p>This will add up a sequence of 1s instead of the sequence of actual values.</p><p>We can test it like this:</p><div><pre class="programlisting">&gt;&gt;&gt; count( cheese for year, cheese in year_cheese )
13</pre></div><p>This seems to work, right? Based on this one experiment, we can try to rewrite the <code class="literal">mean()</code> function like this:</p><div><pre class="programlisting">def mean2( values ):
    return sum(values)/count(values)</pre></div><p>We used <code class="literal">count()</code>, which works with a generator expression, instead of <code class="literal">len()</code>.</p><p>When we use it, we get a <code class="literal">ZeroDivisionError: float division by zero</code> error. Why didn't <code class="literal">count()</code> work in the context of <code class="literal">mean()</code>?</p><p>This reveals the one-use-only rule. The <code class="literal">sum()</code> function consumed the generator expression. When<a id="id604" class="indexterm"/> the time to evaluate the <code class="literal">count()</code> function came, there was no data left. The generator was empty, <code class="literal">sum( 1 for x in [] )</code> was zero.</p><p>What can we do?</p><p>We have three choices, as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We can write our own more sophisticated <code class="literal">sum()</code> that produces both sum and count from one pass through the generator.</li><li class="listitem" style="list-style-type: disc">Alternatively, we can use the <code class="literal">itertools</code> library to put a <em>tee</em> fitting into the generator pipeline so that we have two copies of the iterable. This is actually a very efficient solution, but it's also a bit advanced for field agents.</li><li class="listitem" style="list-style-type: disc">More simply, we can create an actual list object from the generator. We can use the <code class="literal">list()</code> function or wrap the generator expression in <code class="literal">[]</code>.</li></ul></div><p>The first two choices are too complex for our purposes. The third is really simple. We can use this:</p><div><pre class="programlisting">&gt;&gt;&gt; mean( [cheese for year, cheese in year_cheese] )
32.076153846153844
&gt;&gt;&gt; mean( [death for year, death in year_deaths] )
597.2727272727273</pre></div><p>By including <code class="literal">[]</code>, we created a list object from the generator. We can get both <code class="literal">sum()</code> and <code class="literal">len()</code> from the list object. This approach works very nicely.</p><p>It points out the importance of writing docstrings in our functions. We really need to do this:</p><div><pre class="programlisting">def mean(values):
    """Mean of a sequence (doesn't work with an iterable)"""
    return sum(values)/len(values)</pre></div><p>We put a reminder here that the function works with an object that is a sequence, but it doesn't work with a generator expression<a id="id605" class="indexterm"/> or other objects that are merely iterable. When we use <code class="literal">help(mean)</code>, we'll see the reminder we left in the docstring.</p><p>There's a hierarchy of concepts here. Being iterable is a very general feature of many kinds of Python objects. A sequence is one of many kinds of iterable Python objects. </p></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec92"/>Finding the value in the middle</h2></div></div></div><p>The <a id="id606" class="indexterm"/>median value<a id="id607" class="indexterm"/> is in the middle of a sorted collection of values. In order to find the median, we need to sort the data.</p><p>Here's an easy function to <a id="id608" class="indexterm"/>compute the median of a sequence:</p><div><pre class="programlisting">def median(values):
    s = sorted(values)
    if len(s) % 2 == 1: # Odd
        return s[len(s)//2]
    else:
        mid= len(s)//2
        return (s[mid-1]+s[mid])/2</pre></div><p>This includes the common technique of averaging the two middlemost values when there's an even number of samples.</p><p>We used <code class="literal">len(s)%2</code> to determine if the sequence length is odd. In two separate places, we compute <code class="literal">len(s)//2</code>; seems like we might be able to simplify things using the <code class="literal">divmod()</code> function.</p><p>We can use this:</p><div><pre class="programlisting">mid, odd = divmod(len(s), 2)</pre></div><p>This change removes a little bit of the duplicated code that computes <code class="literal">len(s)//2</code>, but is it really more clear?</p><p>Two potential issues here are the overheads associated with sorting:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">First, sorting means a lot of comparisons between items. As the size of the list grows, the number of items compared grows more quickly. Also, the <code class="literal">sorted()</code> function produces a copy of the sequence, potentially wasting memory when processing a very large list.</li><li class="listitem" style="list-style-type: disc">The alternative is a clever variation on the quickselect algorithm. For field agents, this level of<a id="id609" class="indexterm"/> sophistication isn't necessary. More information is available at <a class="ulink" href="http://en.wikipedia.org/wiki/Quickselect">http://en.wikipedia.org/wiki/Quickselect</a>.</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec93"/>Finding the most popular value</h2></div></div></div><p>The <a id="id610" class="indexterm"/>modal value<a id="id611" class="indexterm"/> is the single most popular value in the collection. We <a id="id612" class="indexterm"/>can compute this using the <code class="literal">Counter</code> class in the <code class="literal">collections</code> module.</p><p>Here's a <code class="literal">mode</code> function:</p><div><pre class="programlisting">from collections import Counter
def mode(values):
    c = Counter( values )
    mode_value, count = c.most_common(1)[0]
    return mode_value</pre></div><p>The <code class="literal">most_common()</code> method of a <code class="literal">Counter</code> class returns a sequence of two-tuples. Each tuple has the value and the number of times it occurred. For our purposes, we only wanted the value, so we had to take the first element from the sequence of two-tuples. Then, we had to break the pair down into the value and the counter.</p><p>The problem with a demonstration is that our datasets are really small and don't have a proper mode. Here's a contrived example:</p><div><pre class="programlisting">&gt;&gt;&gt; mode( [1, 2, 3, 3, 4] )
3</pre></div><p>This demonstrates that the <a id="id613" class="indexterm"/>
<code class="literal">mode</code> function works, even though it doesn't make sense for our cheese consumption and death rate data.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec37"/>Creating Python modules and applications</h1></div></div></div><p>We relied heavily on modules in the Python library. Additionally, we added several packages, including Pillow and BeautifulSoup. The question should arise, <em>can we create our own module?</em>
</p><p>The answer is, of course, <em>yes</em>. A Python module<a id="id614" class="indexterm"/> is simply a file. It turns out that each example script has been a module. We can look a little more deeply at how we can make our own modules of reusable programming. When we look at Python programs, we observe three kinds of files:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Library modules that are purely definitional</li><li class="listitem" style="list-style-type: disc">Application modules that do the real work of our applications</li><li class="listitem" style="list-style-type: disc">Hybrid modules that are both applications and can be used as libraries</li></ul></div><p>The essential ingredient of creating a Python module<a id="id615" class="indexterm"/> is separating the <em>real work</em> of the top-level script from the various definitions that support this real work. All our examples of definitions have been functions created with the <code class="literal">def</code> statement. The other import examples of definitions are <code class="literal">class</code> definitions, which we'll discuss in the following sections.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec94"/>Creating and using a module</h2></div></div></div><p>To create a module of only definitions, we simply put all the function and class definitions into a file. We have to give the file a name that is an acceptable Python variable name. This means that filenames should look <a id="id616" class="indexterm"/>like Python variables; letters, digits, and <code class="literal">_</code> are perfectly legal. Characters that Python uses as an operator (<code class="literal">+</code>, <code class="literal">-</code>, <code class="literal">/</code>, and so on) may be allowed by our OS for a filename, but these characters cannot be used to name a module file.</p><p>The file name must end in <code class="literal">.py</code>. This is not part of the module name; it's for the benefit of the operating system.</p><p>We might collect our statistics functions into a file named <code class="literal">stats.py</code>. This file defines a module named <code class="literal">stats</code>.</p><p>We can import the entire suite of functions or individual functions, or we can import the module as a whole. Use the following code:</p><div><pre class="programlisting">&gt;&gt;&gt; from stats import *</pre></div><p>By using this, we import all the functions (and classes) defined in the stats module. We can simply use names such as <code class="literal">mean( some_list )</code>.</p><p>Consider we use this:</p><div><pre class="programlisting">&gt;&gt;&gt; from stats import mean, median</pre></div><p>We imported two specific functions from the stats module. We ignored any other definition that might be available in that module.</p><p>We can also use this:</p><div><pre class="programlisting">&gt;&gt;&gt; import stats</pre></div><p>This will import the module, but it won't put any of the names into the global namespace that we usually work with. All the names in the <code class="literal">stats</code> module must be accessed with a qualified name, such as <code class="literal">stats.mean( some_list )</code>. In very complex scripts, the use of qualified names helps clarify where a particular function or class was defined.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec95"/>Creating an application module</h2></div></div></div><p>The <a id="id617" class="indexterm"/>simplest<a id="id618" class="indexterm"/> way to create an application with a <a id="id619" class="indexterm"/>
<strong>command-line interface</strong> (<strong>CLI</strong>) is to write a file and run it from the command line. Consider the following example:</p><div><pre class="programlisting">python3 basic_stats.py</pre></div><p>When we enter this in the terminal window or command window, we use the OS <code class="literal">python3</code> command and provide a filename. In Windows, the name <code class="literal">python.exe</code> is sometimes used for Python 3, so the command may be <code class="literal">python basic_stats.py</code>. In most other OSes, there will often be both the <code class="literal">python3</code> and <code class="literal">python3.3</code> commands. On Mac OS X, the <code class="literal">python</code> command may refer to the old <code class="literal">Python2.7</code> that is part of Mac OS X.</p><p>We can determine the difference by using the <code class="literal">python -V</code> command to see what version is bound to the name <code class="literal">python</code>.</p><p>As noted previously, we want to separate our definitions into one file, and then put the real work in another file. When we look inside <code class="literal">basic_stats.py</code>, we might find this:</p><div><pre class="programlisting">"""Chapter 5 example 2.

Import stats library functions from ch_5_ex_1 module.
Import data acquisition from ch_5_ex_1 module.
Compute some simple descriptive statistics.
"""
from ch_5_ex_1 import mean, mode, median
from ch_5_ex_1 import get_deaths, get_cheese

year_deaths = list( get_deaths() )
years = list( year for year, death in year_deaths )
deaths= list( death for year, death in year_deaths )
print( "Year Range", min(years), "to", max(years) )
print( "Average Deaths {:.2f}".format( mean( deaths ) ) )

year_cheese= get_cheese()

print( "Average Cheese Consumption", 
    mean( [cheese for year, cheese in year_cheese] ) )</pre></div><p>The file starts with a triple-quoted string that—like the docstring for a function—is the docstring for a module. We imported some functions from another module.</p><p>Then, we completed some processing using the functions that we imported. This is a common structure for a simple command-line module.</p><p>We can also run this via the command <code class="literal">python3 -m basic_stats</code>. This will use Python's internal <a id="id620" class="indexterm"/>search path to locate the module, and then run that module. Running a module is subtly different from running a file, but the<a id="id621" class="indexterm"/> net effect is the same; the file produces the output we designed via the <code class="literal">print()</code> statements. For details on how the <code class="literal">-m</code> option works, consult the documentation for the <code class="literal">runpy</code> module.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec96"/>Creating a hybrid module</h2></div></div></div><p>There <a id="id622" class="indexterm"/>are<a id="id623" class="indexterm"/> two significant improvements we can make to the <code class="literal">basic_stats.py</code> module shown previously:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">First, we put all the processing into a function definition. We call it <code class="literal">analyze_cheese_deaths</code>.</li><li class="listitem" style="list-style-type: disc">The second is the addition of an <code class="literal">if</code> statement to determine the context in which the module is being used.</li></ul></div><p>Here's the more sophisticated version of <code class="literal">basic_stats.py</code>:</p><div><pre class="programlisting">"""Chapter 5 example 3.

Import stats library functions from ch_5_ex_1 module.
Import data acquisition from ch_5_ex_1 module.
Compute some simple descriptive statistics.
"""
from ch_5_ex_1 import mean, mode, median
from ch_5_ex_1 import get_deaths, get_cheese

def analyze_cheese_deaths():

    year_deaths = list( get_deaths() )
    years = list( year for year, death in year_deaths )
    deaths= list( death for year, death in year_deaths )
    print( "Year Range", min(years), "to", max(years) )
    print( "Average Deaths {:.2f}".format( mean( deaths ) ) )

    year_cheese= get_cheese()
    print( "Average Cheese Consumption", 
        mean( [cheese for year, cheese in year_cheese] ) )

if __name__ == "__main__":
    analyze_cheese_deaths()</pre></div><p>Creating a function definition to encapsulate the real work gives us a way to extend or reuse this script. We<a id="id624" class="indexterm"/> can reuse a function definition (via <code class="literal">import</code>) more easily than we can reuse a top-level script.</p><p>The<a id="id625" class="indexterm"/> <code class="literal">__name__</code> variable is <a id="id626" class="indexterm"/>a global that Python sets to show the processing context. The top-level module—the one named on the command line—has the <code class="literal">__name__</code> variable set to <code class="literal">__main__</code>. All other module imports have the <code class="literal">__name__</code> variable set to the module name.</p><p>Yes, the global variable, <code class="literal">__name__</code>, has double-underscores before and after. This marks it as part of the machinery of Python. Similarly, the string value for the main module name, <code class="literal">__main__</code>, involves double underscores.</p><p>This technique allows us to create a module that can be run as a command and also be imported to provide definitions. The idea is to promote reusable programming. Each time we set out to solve a problem, we don't need to reinvent the wheel and other related technology. We should import prior work and build on that.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec38"/>Creating our own classes of objects</h1></div></div></div><p>The two lists of data values that HQ asked us to get—cheese consumption and W75 deaths—form two objects that are very similar. They seem to be two instances of the same class of things.</p><p>In this case, the class of things seems to have <em>annual statistics</em>. They're collections with a consistent structure of a year and a measurement. Both these annual statistics objects have a common set of operations. Indeed, the operations are pretty tightly bound to the measurement, and they are not at all bound to the year number.</p><p>Our collection of statistical functions is not very tightly bound to our data at all.</p><p>We can improve the binding <a id="id627" class="indexterm"/>between data structure and processing through a class definition. If we define the general features of a class of objects that we can call <em>annual statistics</em>, we can create two instances of this class and use the defined methods on the unique data of each instance. We can easily reuse our method functions by having multiple objects of the same class.</p><p>A class definition<a id="id628" class="indexterm"/> in Python is a collection of method functions. Each method function definition has an additional parameter variable, usually named <code class="literal">self</code>, which must be the first parameter to each function. The self variable is how we can access the attribute values that are unique to each instance of the class of objects.</p><p>Here's how we might define a class for the simple statistics HQ is asking us to get:</p><div><pre class="programlisting">from collections import Counter
class AnnualStats:
    def __init__(self, year_measure):
        self.year_measure = list(year_measure)
        self.data = list(v for yr, v in self.year_measure)
        self.counter= Counter(self.data)
    def __repr__(self):
        return repr(self.year_measure)
    def min_year(self):
        return min( yr for yr, v in self.year_measure )
    def max_year(self):
        return max( yr for yr, v in self.year_measure )
    def mean(self):
        return sum(self.data)/len(self.data)
    def median(self):
        mid, odd = divmod( len(self.data), 2 )
        if odd:
            return sorted(self.data)[mid]
        else:
            pair= sorted(self.data)[mid-1:mid+1]
            return sum(pair)/2
    def mode(self):
        value, count = self.counter.most_common1)[0]
        return value</pre></div><p>The <code class="literal">class</code> statement <a id="id629" class="indexterm"/>provides a name for our definition. Within the indented body of the class statement, we provide <code class="literal">def</code> statements for each method function within this class. Each <code class="literal">def</code> statement contains the instance variable, <code class="literal">self</code>.</p><p>We've defined two methods with special names, as shown in the following list. These names have double underscores, they're fixed by Python, and we must use exactly these names in order to have objects initialized or printed properly:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">__init__()</code> method<a id="id630" class="indexterm"/> is used implicitly to initialize the instance when it's created. We'll show an example of instance creation in the following section. When we create an <code class="literal">AnnualStats</code> object, three internal attributes are created, as shown in the following list:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">self.year_measure</code> instance variable contains the data provided as an argument value</li><li class="listitem" style="list-style-type: disc">The <code class="literal">self.data</code> instance variable contains just the data values extracted from the year-data two-tuples</li><li class="listitem" style="list-style-type: disc">The <code class="literal">self.counter</code> instance variable contains a <code class="literal">Counter</code> object built from the data values</li></ul></div></li><li class="listitem" style="list-style-type: disc">The <code class="literal">__repr__()</code> method<a id="id631" class="indexterm"/> is used implicitly when we attempt to print the object. We returned the representation of the internal <code class="literal">self.year_measure</code> instance variable as the representation for the instance as a whole.</li></ul></div><p>The other method functions look similar to the standalone function definitions shown previously. Each of these method functions depend on having the instance variables properly initialized by the <code class="literal">__init__()</code> method. These names are entirely part of our software design; we can call them anything that's syntactically legal and meaningful.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec97"/>Using a class definition</h2></div></div></div><p>Here's how<a id="id632" class="indexterm"/> we can use our <a id="id633" class="indexterm"/>
<code class="literal">AnnualStats</code> class definition:</p><div><pre class="programlisting">   from ch_5_ex_1 import get_deaths, get_cheese

deaths = AnnualStats( get_deaths() )
cheese = AnnualStats( get_cheese() )

print("Year Range", deaths.min_year(), deaths.max_year())
print("Average W75 Deaths", deaths.mean())

print("Median Cheese Consumption", cheese.median())
print("Mean Cheese Consumption", cheese.mean())

print(deaths )</pre></div><p>We built two instances of the <code class="literal">AnnualStats</code> class. The <code class="literal">deaths</code> object is an <code class="literal">AnnualStats</code> object built from the year-death set of data. Similarly, the cheese object is an <code class="literal">AnnualStats</code> object built from the cheese consumption set of data.</p><p>In both cases, the <code class="literal">AnnualStats.__init__()</code> method is evaluated with the given argument value. When we evaluate <code class="literal">AnnualStats( get_deaths() )</code>, the result of <code class="literal">get_deaths()</code> is provided to <code class="literal">AnnualStats.__init__()</code> as the value of the <code class="literal">year_measure</code> parameter. The statements of the <code class="literal">__init__()</code> method will then set the values of the three instance variables.</p><p>When we evaluate <code class="literal">deaths.min_year()</code>, this will evaluate the <code class="literal">AnnualStats.min_year()</code> method function. The <code class="literal">self</code> variable will be <code class="literal">deaths</code>. This means that <code class="literal">self.year_measure</code> denotes the object originally created by <code class="literal">get_deaths()</code>.</p><p>When we evaluate <code class="literal">deaths.mean()</code>, this will evaluate the <code class="literal">AnnualStats.min_year()</code> method function with the <code class="literal">self</code> variable referring to deaths. This means <code class="literal">deaths.data</code> is the sorted sequence we derived from the object originally created by <code class="literal">get_deaths()</code>.</p><p>Each instance (<code class="literal">deaths</code>, <code class="literal">cheese</code>) refers to the instance variables created by the <code class="literal">__init__()</code> method. A class encapsulates the processing of the method functions with the various instance variables. The encapsulation idea can help us design software that is more tightly focused and less likely to have confusing bugs or inconsistencies.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec39"/>Comparisons and correlations</h1></div></div></div><p>An important statistical question <a id="id634" class="indexterm"/>centers around correlation between variables. We often wonder if two sequences of values correlate with each other. If we have variables <a id="id635" class="indexterm"/>that correlate, perhaps we've found an interesting causal relationship. We might be able to use one variable to predict the values of another variable. We might also be able to prove that they're independent and have nothing to do with each other.</p><p>The essential statistical tool for this is the<a id="id636" class="indexterm"/> <em>coefficient of correlation</em>. We have several ways to compute this. One solution is to download NumPy or SciPy from the following links:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.pearsonr.html">http://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.pearsonr.html</a></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.corrcoef.html">http://docs.scipy.org/doc/numpy/reference/generated/numpy.corrcoef.html</a></li></ul></div><p>The correlation algorithms, however, aren't too complex. Implementing these two calculations will build up our basic data gathering espionage skills. We'll build some more basic statistical functions. Then, we'll build the correlation calculation, which will depend on other statistical functions.</p><p>The essential numerical depends on computing means and standard deviations. We looked at the mean calculation previously. We'll add the standard deviation to our bag of tricks. Given the standard deviation, we can standardize each value. We'll compute the distance from the mean using the standard deviation as the measurement of distance. We can then compare standardized scores to see if two sets of data correlate.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec98"/>Computing the standard deviation</h2></div></div></div><p>To compute<a id="id637" class="indexterm"/> the correlation coefficient, we need another descriptive statistic for a set of data: the standard deviation. This is a measure of how widely dispersed the data is. When we compute the mean, we find a center for the data. The next question is, <em>how tightly do the values huddle around the center?</em>
</p><p>If the standard deviation is small, the data is tightly clustered. If the standard deviation is large, the data is spread all over the place. The standard deviation calculation gives us a numeric range that brackets about two-third of the data values.</p><p>Having the standard deviation lets us spot unusual data. For example, the mean cheese consumption is 31.8 pounds per person. The standard deviation is 1.27 pounds. We expect to see much of the data huddled within the range of 31.8 ± 1.27, that is, between 30.53 and 33.07. If our informant tries to tell as the per capita cheese consumption is 36 pounds in 2012, we have a good reason to be suspicious of the report.</p><p>There are a few variations to the theme of computing a standard deviation. There are some statistical subtleties, also, that relate to whether or not we have the entire population or just a sample. Here's one of the standard formulae <img src="img/0420OS_05_04.jpg" alt="Computing the standard deviation"/>. The symbol <img src="img/0420OS_05_05.jpg" alt="Computing the standard deviation"/> represents the standard deviation of some variable, <img src="img/0420OS_05_06.jpg" alt="Computing the standard deviation"/>. The symbol <img src="img/0420OS_05_07.jpg" alt="Computing the standard deviation"/> represents the mean of a variable.</p><p>We have a <a id="id638" class="indexterm"/>method function, <code class="literal">mean()</code>, which computes the <img src="img/0420OS_05_07.jpg" alt="Computing the standard deviation"/> value. We need to implement the standard deviation formula.</p><p>The standard deviation formula uses the <code class="literal">math.sqrt()</code> and <code class="literal">sum()</code> functions. We'll rely on using <code class="literal">import math</code> in our script.</p><p>We can directly translate the equation into Python. Here's a method function we can add to our <code class="literal">AnnualStat</code> class:</p><div><pre class="programlisting">    def stddev(self):
        μ_x = self.mean()
        n = len(self.data)
        σ_x= math.sqrt( sum( (x-μ_x)**2 for x in self.data )/n )
        return σ_x</pre></div><p>We evaluated the <code class="literal">mean()</code> method function to get the mean, shown as <img src="img/0420OS_05_07.jpg" alt="Computing the standard deviation"/>, and assigned this to <code class="literal">μ_x</code> (yes, Greek letters are legal for Python variable names; if your OS doesn't offer ready access to extended Unicode characters, you might want to use <code class="literal">mu</code> instead). We also evaluated <code class="literal">len(data)</code> to get the value of <code class="literal">n</code>, the number of elements in the collection.</p><p>We can then do a very literal translation from math-speak to Python. For example, the <img src="img/0420OS_05_08.jpg" alt="Computing the standard deviation"/> becomes <code class="literal">sum((x-μ_x)**2 for x in self.data)</code>. This kind of literal match between mathematical notation and Python makes it easy to vet Python programming to be sure it matches the mathematical abstraction.</p><p>Here's another version of standard deviation, based on a slightly different formula:</p><div><pre class="programlisting">    def stddev2(self):
        s_0 = sum(1 for x in self.data) # x**0
        s_1 = sum(x for x in self.data) # x**1
        s_2 = sum(x**2 for x in self.data)
        return math.sqrt( s_2/s_0 - (s_1/s_0)**2 )</pre></div><p>This has an <a id="id639" class="indexterm"/>elegant symmetry to it. The formula looks like <img src="img/0420OS_05_09.jpg" alt="Computing the standard deviation"/>. It's not efficient or accurate any more. It's just sort of cool because of the symmetry between <img src="img/0420OS_05_10.jpg" alt="Computing the standard deviation"/>, <img src="img/0420OS_05_11.jpg" alt="Computing the standard deviation"/>, and <img src="img/0420OS_05_12.jpg" alt="Computing the standard deviation"/>.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec99"/>Computing a standardized score</h2></div></div></div><p>Once <a id="id640" class="indexterm"/>we have the standard deviation, we can standardize each measurement in the sequence. This standardized score is sometimes called a Z score. It's the number of standard deviations a particular value lies from the mean. </p><p>In <img src="img/0420OS_05_13.jpg" alt="Computing a standardized score"/>, the standardized score, <img src="img/0420OS_05_14.jpg" alt="Computing a standardized score"/>, is the difference between the score, <img src="img/0420OS_05_15.jpg" alt="Computing a standardized score"/>, and the mean, <img src="img/0420OS_05_07.jpg" alt="Computing a standardized score"/>, divided by the standard deviation, <img src="img/0420OS_05_05.jpg" alt="Computing a standardized score"/>.</p><p>If we have a mean, <img src="img/0420OS_05_16.jpg" alt="Computing a standardized score"/>, of 31.8 and a standard deviation, <img src="img/0420OS_05_17.jpg" alt="Computing a standardized score"/>, of 1.27, then a measured value of 29.87 will have a Z score of -1.519. About 30 percent of the data will be outside 1 standard deviation from the mean. When our informant tries to tell us that consumption jumped to 36 pounds of cheese per capita, we can compute the Z score for this, 3.307, and suggest that it's unlikely to be valid data.</p><p>Standardizing our values to produce scores is a great use of a generator expression. We'll add this to our class definition too:</p><div><pre class="programlisting">    def stdscore(self):
        μ_x= self.mean()
        σ_x= self.stddev()
        return [ (x-μ_x)/σ_x for x in self.data ]</pre></div><p>We computed<a id="id641" class="indexterm"/> the mean of our data and assigned it to <code class="literal">μ_x</code>. We computed the standard deviation and assigned it to <code class="literal">σ_x</code>. We used a generator expression to evaluate <code class="literal">(x-μ_x)/σ_x</code> for each value, <code class="literal">x</code>, in our data. Since the generator was in <code class="literal">[]</code>, we will create a new list object with the standardized scores.</p><p>We can show how this works with this:</p><div><pre class="programlisting">print( cheese.stdscore() )</pre></div><p>We'll get a sequence like the following:</p><div><pre class="programlisting">[-1.548932453971435, -1.3520949193863403, ... 0.8524854679667219]</pre></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec21"/>Comparing a sequence and an iterable</h3></div></div></div><p>When <a id="id642" class="indexterm"/>we look at the result of the <a id="id643" class="indexterm"/>
<code class="literal">stdscore()</code> method, we have a choice of what to return. In the previous example, we returned a new list object. We don't really need to do this.</p><p>We can use this in the function to return a generator instead of a list:</p><div><pre class="programlisting">return ((x-μ_x)/σ_x for x in self.data)</pre></div><p>The rest of the function is the same. It's good to give this version a different name. Call the old one <code class="literal">stdscore2()</code> so that you can compare list and generator versions.</p><p>The generator <code class="literal">stdscore()</code> function now returns an expression that can be used to generate the values. For most of our calculations, there's no practical difference between an actual list object and an iterable sequence of values.</p><p>There are three differences that we'll notice:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Firstly, we can't use <code class="literal">len()</code> on the generator results</li><li class="listitem" style="list-style-type: disc">Secondly, a generator doesn't generate any data until we use it in a <code class="literal">for</code> loop or to create a list</li><li class="listitem" style="list-style-type: disc">Thirdly, an iterable can only be used once</li></ul></div><p>Try to see how this works with something simple like this:</p><div><pre class="programlisting">print(cheese.stdscore())</pre></div><p>We'll see the generator expression, not the values that are generated. Here's the output:</p><div><pre class="programlisting">&lt;generator object &lt;genexpr&gt; at 0x1007b4460&gt;</pre></div><p>We need to<a id="id644" class="indexterm"/> do this to collect the generated values into an object. The <code class="literal">list()</code> function does this nicely. Here's what we can do to evaluate the generator and actually generate the values:</p><div><pre class="programlisting">print(list(cheese.stdscore()))</pre></div><p>This will evaluate the generator, producing a list object that we can print.</p></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec100"/>Computing a coefficient of correlation</h2></div></div></div><p>One important <a id="id645" class="indexterm"/>question that arises when comparing two sequences of data is how well they correlate with each other. When one sequence trends up, does the other? Do they trend at the same rate? We can measure this correlation by computing a coefficient based on the products of the standardized scores:</p><div><img src="img/0420OS_05_18.jpg" alt="Computing a coefficient of correlation"/></div><p>In this case, <img src="img/0420OS_05_19.jpg" alt="Computing a coefficient of correlation"/> is the standardized score for each individual value, <img src="img/0420OS_05_20.jpg" alt="Computing a coefficient of correlation"/>. We do the same calculation for the other sequences and compute the product of each pair. The average of the product of the various standardized scores will be a value between +1 and -1. A value near +1 means the two sequences correlate nicely. A value near -1 means the sequences oppose each other. One trends up when the other trends down. A value near 0 means the sequences don't correlate.</p><p>Here's a function that computes the correlation between two instances of <code class="literal">AnnualStat</code> data collections:</p><div><pre class="programlisting">def correlation1( d1, d2 ):
    n= len(d1.data)
    std_score_pairs = zip( d1.stdscore(), d2.stdscore() )
    r = sum( x*y for x,y in std_score_pairs )/n
    return r</pre></div><p>We used the <code class="literal">stdscore()</code> method of each <code class="literal">AnnualStat</code> object to create a sequence of standardized score values.</p><p>We created a generator using the <code class="literal">zip()</code> function that will yield two-tuples from two separate<a id="id646" class="indexterm"/> sequences of scores. The mean of this sequence of products is the coefficient correlation between the two sequences. We computed the mean by summing and dividing by the length, <code class="literal">n</code>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec40"/>Writing high-quality software</h1></div></div></div><p>How do we know<a id="id647" class="indexterm"/> these various statistical functions work? This is potentially very tricky programming, with lots of opportunities to have things go wrong.</p><p>The best tool to make sure that software works is<a id="id648" class="indexterm"/> unit testing. The idea behind unit testing is to break a module down into separate units—usually functions or classes—and test each unit in isolation. Python <a id="id649" class="indexterm"/>gives us two ways to perform unit testing:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Putting examples into docstrings for modules, functions, and classes</li><li class="listitem" style="list-style-type: disc">Writing separate <code class="literal">unittest.TestCase</code> classes</li></ul></div><p>Most secret agents will be very happy with<a id="id650" class="indexterm"/> docstring test cases. They're easy to write. We put them in the docstring right in front of the rest of the code. They're visible when we use the <code class="literal">help()</code> function.</p><p>We create these docstring test cases by copying and pasting known correct results from interactive Python. The copy and paste will include the <code class="literal">&gt;&gt;&gt;</code> prompt to make it easy to find the examples. Of course, we also include the output that's expected. Once we include this in the docstring, the <code class="literal">doctest</code> module will find and use the example.</p><p>In some cases, we need to fake the expected results. It's actually common to have worked out what the answer is supposed to be before having written any working Python code. If we're sure the docstring example has the expected right answer, we can leverage this and use it to help debug the code.</p><p>Let's look at a simple function we wrote earlier:</p><div><pre class="programlisting">def mean(values):
    """Mean of a sequence (doesn't work with an iterable)

    &gt;&gt;&gt; from ch_5_ex_1 import mean
    &gt;&gt;&gt; mean( [2, 4, 4, 4, 5, 5, 7, 9])
    5.0
    """
    return sum(values)/len(values)</pre></div><p>We added the example interaction to the function's docstring. We included what looks like a copy and paste <a id="id651" class="indexterm"/>of the sequence of interactions that will exercise this function. In some cases, we make the sequence up based on what we plan to write, not what we've written.</p><p>We can exercise the several different ways. The easiest is this:</p><div><pre class="programlisting">python3 -m doctest ch_5_ex_1.py</pre></div><p>We run the <code class="literal">doctest</code> module as a top-level main application. The single argument to this application is the name of a Python application that has doctest examples pasted into docstrings.</p><p>There's no output if everything works. If we're curious, we can ask for more verbose output:</p><div><pre class="programlisting">python3 -m doctest -v ch_5_ex_1.py</pre></div><p>This will produce voluminous output that shows each test that was found in the docstrings in the module.</p><p>The other techniques include building a self-testing module and writing a separate script that just runs tests.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec101"/>Building a self-testing module and a test module</h2></div></div></div><p>One of<a id="id652" class="indexterm"/> the <a id="id653" class="indexterm"/>techniques that works out nicely is using the <code class="literal">__name__ == "__main__"</code> technique to add a test script to a library module. We'll<a id="id654" class="indexterm"/> evaluate the <code class="literal">doctest.testmod()</code> function to test the functions and classes defined in a module.</p><p>It looks like this:</p><div><pre class="programlisting">if __name__ == "__main__":
    import doctest
    doctest.testmod()</pre></div><p>If this module is being run from the command line, it's the main module, and global <code class="literal">__name__</code> will be set to <code class="literal">"__main__"</code>. When this is true, we can import the doctest module and evaluate <code class="literal">doctest.testmod()</code> to confirm that everything else in the module works.</p><p>We can also write a separate test script. We might call it "<code class="literal">test.py</code>"; it might be as short as this:</p><div><pre class="programlisting">import doctest
import ch_5_ex_1
doctest.testmod( ch_5_ex_1 )</pre></div><p>This short script imported the doctest module. It also imported the module we're going to test.</p><p>We used the <code class="literal">doctest.testmod()</code> function to locate doctest examples in the given module. The output looks like this:</p><div><pre class="programlisting">TestResults(failed=0, attempted=2)</pre></div><p>This is a <a id="id655" class="indexterm"/>confirmation that there were two lines of <code class="literal">&gt;&gt;&gt;</code> examples, and everything worked perfectly.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec102"/>Creating more sophisticated tests</h2></div></div></div><p>There are times <a id="id656" class="indexterm"/>when we have to be a little cautious of the doctest example output. These are situations where Python's behavior is not specified to the level of detail where we can copy and paste interactive results without thinking about what we're doing.</p><p>When working with dict and set collections, the order of the items is not guaranteed.</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">For a dict, a doctest string needs to include <code class="literal">sorted()</code> to force a specific order. It's essential to use <code class="literal">sorted(some_dict.items())</code> instead of simply using <code class="literal">some_dict</code>.</li><li class="listitem" style="list-style-type: disc">The same consideration applies to sets. We must use something like <code class="literal">sorted(some_set)</code> instead of <code class="literal">some_set</code>.</li></ul></div><p>Some internal functions such as <code class="literal">id()</code> and <code class="literal">repr()</code> can display a physical memory address that's unlikely to be the same each time we run the tests. There's a special comment we can include that will alert doctest to skip the details. We'll include <code class="literal">#doctest: +ELLIPSIS</code> and replace the ID or address with <code class="literal">...</code> (three dots).</p><p>Another place we might use ellipsis is to shorten up a very long bit of output.</p><p>For example, we might have a module docstring like this:</p><div><pre class="programlisting">"""Chapter 5, example 1

Some simple statistical functions.

&gt;&gt;&gt; from ch_5_ex_1 import mean, median
&gt;&gt;&gt; data = [2, 4, 4, 4, 5, 5, 7, 9]
&gt;&gt;&gt; data # doctest: +ELLIPSIS
[2, 4..., 9]
&gt;&gt;&gt; mean( data )
5.0
&gt;&gt;&gt; median( data )
4.5

"""</pre></div><p>A module docstring must be (almost) the first lines in a module file. The only line that might come before the module docstring is a one-line <code class="literal">#!</code> comment. A <code class="literal">#!</code> comment line, if present, is aimed at the OS shell and identifies the rest of the file as being a Python script, not a shell script.</p><p>We used the <code class="literal"># doctest: +ELLIPSIS</code> directive on one of our tests. The result wasn't complete, it had "<code class="literal">...</code>" in the expected results to show the parts doctest should ignore.</p><p>Floating-point values <a id="id657" class="indexterm"/>may not be identical for different processors and OSes. We have to be careful to show floating-point numbers with formatting or rounding. We might use <code class="literal">"{:.4f}".format(value)</code> or <code class="literal">round(value,4)</code> to assure that the insignificant digits are ignored.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec103"/>Adding doctest cases to a class definition</h2></div></div></div><p>We looked at doctests<a id="id658" class="indexterm"/> in modules and functions. We can put doctests in several places in a class definition. This is because we have several places to put docstrings.</p><p>The class as a whole can have a docstring right at the top. It's the first line after the <code class="literal">class</code> statement. Also, each individual method within a class can have its own private docstring.</p><p>We might, for example, include a comprehensive docstring at the beginning of our class definition:</p><div><pre class="programlisting">class AnnualStats:
    """Collect (year, measurement) data for statistical analysis.

    &gt;&gt;&gt; from ch_5_ex_4 import AnnualStats
    &gt;&gt;&gt; test = AnnualStats( [(2000, 2),
    ...    (2001, 4),
    ...    (2002, 4),
    ...    (2003, 4),
    ...    (2004, 5),
    ...    (2005, 5),
    ...    (2006, 7),
    ...    (2007, 9),] )
    ...
    &gt;&gt;&gt; test.min_year()
    2000
    &gt;&gt;&gt; test.max_year()
    2007
    &gt;&gt;&gt; test.mean()
    5.0
    &gt;&gt;&gt; test.median()
    4.5
    &gt;&gt;&gt; test.mode()
    4
    &gt;&gt;&gt; test.stddev()
    2.0
    &gt;&gt;&gt; list(test.stdscore())
    [-1.5, -0.5, -0.5, -0.5, 0.0, 0.0, 1.0, 2.0]
    """</pre></div><p>This provides<a id="id659" class="indexterm"/> a complete rundown of all of the features of this class in one tidy summary.</p><div><div><h3 class="title"><a id="tip05"/>Tip</h3><p>Our sample data leads to a standard deviation of exactly 2.0. This trick shows that with clever test data, we can circumvent some of the doctest float-point output limitations.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec41"/>Solving problems – analyzing some interesting datasets</h1></div></div></div><p>What is the <a id="id660" class="indexterm"/>correlation coefficient between per-capita cheese consumption and death code W75 (accidental suffocation and strangulation in bed) for the years 2000 to 2009?</p><p>Recall that<a id="id661" class="indexterm"/> the cheese data came from <a class="ulink" href="http://www.ers.usda.gov/datafiles/Dairy_Data/chezcon_1_.xls">http://www.ers.usda.gov/datafiles/Dairy_Data/chezcon_1_.xls</a>.</p><p>This is a pesky bit of data because it's in a proprietary spreadsheet format. As much as we dislike copying and pasting, there's no other easy way to get this data.</p><p>The strangulation in bed data comes from cause of death W75 grouped by year. The data request process starts at <a class="ulink" href="http://wonder.cdc.gov/controller/datarequest/D76">http://wonder.cdc.gov/controller/datarequest/D76</a>. There will be some further espionage work required to enter a request for data. For some additional help, check <a class="ulink" href="http://wonder.cdc.gov/wonder/help/ucd.html">http://wonder.cdc.gov/wonder/help/ucd.html</a>.</p><p>How the correlation possibly be so high?</p><p>What is it about cheese consumption and death by strangulation in bed that leads to this amazing correlation?</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec104"/>Getting some more data</h2></div></div></div><p>HQ appears to be working on a theory about dairy products. The cheese spreadsheet also has mozzarella cheese consumption over the same period of time—2000 to 2009.</p><p>We've been ordered to get details on civil engineering doctorates awarded during this period.</p><p>Some initial espionage turned up this set of data:</p><p>
<a class="ulink" href="http://www.nsf.gov/statistics/infbrief/nsf12303/">http://www.nsf.gov/statistics/infbrief/nsf12303/</a>
</p><p>This is a tricky <a id="id662" class="indexterm"/>table to parse. It's a bit more complex because the years are in columns and the data we're looking for is in a particular row, a row with <code class="literal">th.text == "Civil engineering"</code>. The heading for the table as a whole is in a row with <code class="literal">th.text == "Field"</code>. This means that the navigation will be rather complex to locate the <code class="literal">Field</code> row and the <code class="literal">Civil engineering</code> rows of the proper table on this page.</p><p>How does annual per-capita mozzarella cheese consumption correlate with civil engineering doctorates?</p><p>How can the correlation possibly be so high?</p><p>What is it about cheese, death, and doctorates?</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec105"/>Further research</h2></div></div></div><p>Is this just a spurious correlation?</p><p>Are there other correlations like this?</p><p>What else can we learn from <a class="ulink" href="http://www.tylervigen.com/">http://www.tylervigen.com/</a>?</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec42"/>Summary</h1></div></div></div><p>We saw how we can easily implement sophisticated statistical analyses as short pieces of Python programming. We applied basic statistical insights to all our intelligence gathering.</p><p>We learned to design Python modules. This allows us to extend the Python standard library with our own more specialized modules. We can now easily package reusable software in modules for our own purposes as well as for distribution to our network of agents.</p><p>In addition to designing modules, we also saw how to write tests to confirm that our software really works. Software can't be trusted unless there are formal unit tests to confirm that things are behaving correctly. We saw the essential ingredients of the Python language, the standard library, and the ecosystem of related projects and tools. The Python language is quite simple: it only has about 22 statements, and we saw examples of almost all of them.</p><p>At this point, each secret agent's areas of interest and expertise will start to diverge. There are numerous packages, libraries, and application areas that are open for exploration.</p><p>Since our focus is on getting field agents to be productive, we were studiously avoiding more serious software development issues. In particular, we avoided the subject of object-oriented design. An agent that needs to do more sophisticated processing will need to write more sophisticated software. A book like <em>Python 3 Object Oriented Programming</em>, <em>Dusty Phillips</em>, <em>Packt Publishing</em>, is essential to learn this important technique. Check <a class="ulink" href="http://www.packtpub.com/python-3-object-oriented-programming/book">http://www.packtpub.com/python-3-object-oriented-programming/book</a>.</p><p>An agent's interests and abilities will often lead in different directions. Some agents will want to build websites. A book like <em>Python 3 Web Development Beginner's Guide</em>, <em>Michel Anders</em>, <em>Packt Publishing</em>, can help. Some agents will want to build interactive applications; a book like <em>Instant Pygame for Python Game Development How-to</em>, <em>Ivan Idris</em>, <em>Packt Publishing</em>, can help master the Pygame framework. This framework is for more than just games.</p><p>Some agents will pursue natural language processing. A book like <em>Python 3 Text Processing with NLTK 3 Cookbook</em>, <em>Jacob Perkins</em>, <em>Packt Publishing</em>, can help. Other agents will pursue more complex media using <em>Python Multimedia</em>, <em>Ninad Sathaye</em>, <em>Packt Publishing</em> or perhaps <em>Practical Maya Programming with Python</em>, <em>Robert Galanakis</em>, <em>Packt Publishing</em>. Agents interested in geospatial analysis might pursue <em>Programming ArcGIS 10.1 with Python Cookbook</em>, <em>Eric Pimpler</em>, <em>Packt Publishing</em>.</p><p>Skilled agents will find that Python can be used for a wide variety of missions.</p></div></body></html>