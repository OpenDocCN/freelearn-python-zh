<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02" class="calibre1"/>Chapter 2. Writing Execution Modules</h1></div></div></div><p class="calibre8">Execution modules<a id="id38" class="calibre1"/> form the backbone of the workload that Salt performs. They're also easy to write, and the techniques used in writing them form the foundation for writing every other type of Salt module. With a solid understanding of how execution modules work, the functionality of other module types will also be opened up.</p><p class="calibre8">In this chapter, we'll talk about:</p><div><ul class="itemizedlist"><li class="listitem">The basics of writing Salt modules</li><li class="listitem">Making use of Salt built-ins</li><li class="listitem">Using good practices</li><li class="listitem">Troubleshooting execution modules</li></ul></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch02lvl1sec12" class="calibre1"/>Writing Salt modules</h1></div></div></div><p class="calibre8">There are <a id="id39" class="calibre1"/>a few items that are consistent across all Salt modules. These pieces generally work the same way across all module types, though there are a handful of places where you can expect at least a little deviation. We'll cover those in other chapters as we get to them. For now, let's talk about the things that are generally the same.</p></div></div>

<div><div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec13" class="calibre1"/>Hidden objects</h2></div></div></div><p class="calibre8">It has<a id="id40" class="calibre1"/> long been common for programmers to preface functions, variables, and the like with an underscore, if they are only intended to be used<a id="id41" class="calibre1"/> internally in the same module. In many languages, objects that are used like this are said to be <strong class="calibre2">private objects</strong>.</p><p class="calibre8">Some environments enforce private behavior by not allowing external code to reference those things directly. Other environments allow it, but its use is discouraged. Salt modules fall into the list of environments that enforce private function behavior; if a function inside a Salt module begins with an underscore, it will not even be exposed to other modules that try to call it.</p><p class="calibre8">In Python, there is<a id="id42" class="calibre1"/> a special type of object whose name begins and ends with two underscores. These "magic methods" are nicknamed <strong class="calibre2">dunder</strong> (meaning double underscore). How Python normally treats them is beyond the scope <a id="id43" class="calibre1"/>of this book, but it is important to know that Salt adds some of its own. Some are built-ins, which are generally available in (almost) all module types, whereas others are user-defined objects that Salt will apply special treatment to.</p></div></div></div>

<div><div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch02lvl2sec14" class="calibre1"/>The __virtual__() function</h2></div></div></div><p class="calibre8">This is a <a id="id44" class="calibre1"/>function that can appear in any module. If there is no <code class="email">__virtual__()</code> function, then the module will always be available on every system. If that module is present, then its job is to determine whether the requirements for that module are met. These requirements could be any number of things from configuration settings to package dependencies.</p><p class="calibre8">If the requirements are not met, then the <code class="email">__virtual__()</code> function will return <code class="email">False</code>. In more recent versions of Salt, it is possible to instead return a tuple containing both the <code class="email">False</code> value and a reason why the module cannot be loaded. If they are met, then there are two types of value that it can return. This is where things get just a tad tricky.</p><p class="calibre8">Let's say that the module that we are working on is located at <code class="email">salt/modules/mymodule.py</code>. If the requirements are met, and the module is to be referred to as <code class="email">mymodule</code>, then the <code class="email">__virtual__()</code> function will return <code class="email">True</code>. Assuming there is also a function in that module called <code class="email">test()</code>, it would be called using the following command:</p><div><pre class="programlisting">
<strong class="calibre2">#salt-call mymodule.test</strong>
</pre></div><p class="calibre8">If the requirements are met, but this module is to be referred to as <code class="email">testmodule</code>, then the <code class="email">__virtual__()</code> function will return the string <code class="email">testmodule</code> instead. However, instead of returning that string directly, you should define it before all of the functions using the <code class="email">__virtualname__</code> variable.</p><p class="calibre8">Let's go ahead and start writing a module, using the <code class="email">__virtual__()</code> function and <code class="email">__virtualname__</code> variable. We won't check for any requirements yet:</p><div><pre class="programlisting">'''
This module should be saved as salt/modules/mysqltest.py
'''
__virtualname__ = 'mysqltest'


def __virtual__():
    '''
    For now, just return the __virtualname__
    '''
    return __virtualname__


def ping():
    '''
    Returns True

    CLI Example:
        salt '*' mysqltest.ping
    '''
    return True</pre></div></div></div></div>

<div><div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch02lvl2sec15" class="calibre1"/>Formatting your code</h2></div></div></div><p class="calibre8">Before <a id="id45" class="calibre1"/>we get any further, I want to point out some important things that you should be aware of now, so that you don't get into any bad habits that need to be fixed later.</p><p class="calibre8">The module starts off with a special kind of comment called a <code class="email">docstring</code>. In Salt, this begins and ends with three single quotes, all on one line, by themselves. Do not use double quotes. Do not put text on the same line as the quotes. All public functions must also include a <code class="email">docstring</code>, with the same rules. These <code class="email">docstrings</code> are used internally by Salt, to provide help text to functions such as <code class="email">sys.doc</code>. </p><div><h3 class="title2"><a id="note02" class="calibre1"/>Note</h3><p class="calibre8">Keep in mind that these guidelines are specific to Salt; Python itself follows a different style. Check <em class="calibre9">Understanding the Salt style guide</em> in <em class="calibre9">Appendix B</em> for more information.</p></div><p class="calibre8">Take note that the <code class="email">docstring</code> for the <code class="email">ping()</code> function includes a <code class="email">CLI Example</code>. You should always include just enough information to make it clear what the function is meant to do, and at least one (or more, as warranted) command-line examples that demonstrate how to use that function. Private functions do not include a <code class="email">CLI Example</code>.</p><p class="calibre8">You should always include two blank lines between any imports and variable declarations at the top and the functions below, and between all functions. There should be no whitespace at the end of the file.</p></div></div></div>

<div><div><div><div><div><div><h2 class="title1" id="calibre_pb_5"><a id="ch02lvl2sec16" class="calibre1"/>Virtual modules</h2></div></div></div><p class="calibre8">The <a id="id46" class="calibre1"/>primary motivation behind the <code class="email">__virtual__()</code> function is not just to rename modules. Using this function allows Salt to not only detect certain pieces of information about the system but also use them to appropriately load specific modules to make certain tasks more generic.</p><p class="calibre8">
<a class="calibre1" title="Chapter 1. Starting with the Basics" href="part0015_split_000.html#E9OE1-d9976ffc65994572ad672a3ef48f1135">Chapter 1</a>, <em class="calibre9">Starting with the Basics</em>, mentioned some of these examples. <code class="email">salt/modules/aptpkg.py</code> contains a number of tests to determine whether it is running on a Debian-like operating system that uses the <code class="email">apt</code> suite of tools to perform package management. There are similar tests in <code class="email">salt/modules/yumpkg.py</code>, <code class="email">salt/modules/pacman.py</code>, <code class="email">salt/modules/solarispkg.py</code>, and a number of others. If all of the tests pass for any of those modules, then it will be loaded as the <code class="email">pkg</code> module.</p><p class="calibre8">If you <a id="id47" class="calibre1"/>are building a set of modules like this, it is important to remember that they should all perform as similarly as possible. For instance, all of the <code class="email">pkg</code> modules contain a function called <code class="email">install()</code>. Every single <code class="email">install()</code> function accepts the same arguments, performs the same task (as appropriate for that platform), and then returns data in exactly the same format.</p><p class="calibre8">There may be situations where one function is appropriate for one platform, but not another. For example, <code class="email">salt/modules/aptpkg.py</code> contains a function called <code class="email">autoremove()</code>, which calls out to <code class="email">apt-get autoremove</code>. There is no such functionality in <code class="email">yum</code>, so that function does not exist in <code class="email">salt/modules/yumpkg.py</code>. If there were, then that function would be expected to behave the same way between both files.</p></div></div></div>

<div><div><div><div><div><div><h2 class="title1" id="calibre_pb_6"><a id="ch02lvl2sec17" class="calibre1"/>Using the salt.utils library</h2></div></div></div><p class="calibre8">The <a id="id48" class="calibre1"/>preceding module will always run, because it doesn't check for requirements on the system. Let's go ahead and add some checking now.</p><p class="calibre8">There is an extensive set of tools available to import inside the <code class="email">salt/utils/</code> directory. A large number of them live directly under the <code class="email">salt.utils</code> namespace, including a very commonly used function called <code class="email">salt.utils.which()</code>. When given the name of a command, this function will report the location of that command, if it exists on the system. If it does not exist, then it will return <code class="email">False</code>.</p><p class="calibre8">Let's go ahead and rework the <code class="email">__virtual__()</code> function to look for a command called <code class="email">mysql</code>:</p><div><pre class="programlisting">'''
This module should be saved as salt/modules/mysqltest.py
'''
import salt.utils

__virtualname__ = 'mysqltest'


def __virtual__():
    '''
    Check for MySQL
    '''
    if not salt.utils.which('mysql'):
        return False
    return __virtualname__


def ping():
    '''
    Returns True

    CLI Example:
        salt '*' mysqltest.ping
    '''
    return True</pre></div><p class="calibre8">The <code class="email">salt.utils</code> libraries<a id="id49" class="calibre1"/> ship with Salt, but you need to explicitly import them. It is common for Python coders to import only parts of functions. You may find it tempting to use the following import line instead:</p><div><pre class="programlisting">from salt.utils import which</pre></div><p class="calibre8">And then use the following line:</p><div><pre class="programlisting">if which('myprogram'):</pre></div><p class="calibre8">Although not expressly forbidden in Salt, this is discouraged except when necessary. Although it may require more typing, especially if you use a particular function several times in a particular module, doing so makes it easier to tell at a glance which module a particular function came from.</p></div></div></div>

<div><div><div><div><div><div><h2 class="title1" id="calibre_pb_7"><a id="ch02lvl2sec18" class="calibre1"/>Cross-calling with the __salt__ dictionary</h2></div></div></div><p class="calibre8">There<a id="id50" class="calibre1"/> are times when it is helpful to be able to call out to another function in another module. For instance, calling external shell commands is a pretty important part of Salt. It's so important in fact that it was standardized in the <code class="email">cmd</code> module. The most common command for issuing shell commands is <code class="email">cmd.run</code>. The following Salt command demonstrates using <code class="email">cmd.run</code> on a Windows Minion:</p><div><pre class="programlisting">
<strong class="calibre2">#salt winminon cmd.run 'dir C:\'</strong>
</pre></div><p class="calibre8">If you had a need for your execution module to obtain the output from such a command, you would use the following Python:</p><div><pre class="programlisting">__salt__['cmd.run']('dir C:\')</pre></div><p class="calibre8">The <code class="email">__salt__</code> object is a dictionary, which contains references to all of the available functions on that Minion. If a module exists, but its <code class="email">__virtual__()</code> function returns <code class="email">False</code>, then<a id="id51" class="calibre1"/> it will not appear in this list. As a function reference, it requires parentheses at the end, with any arguments inside.</p><p class="calibre8">Let's go ahead and create a function that tells us whether or not the <code class="email">sshd</code> daemon is running on a Linux system, and listening to a port:</p><div><pre class="programlisting">def check_mysqld():
    '''
    Check to see if sshd is running and listening

    CLI Example:
        salt '*' testmodule.check_mysqld
    '''
    output = __salt__['cmd.run']('netstat -tulpn | grep mysqld', python_shell=True)
    if 'tcp' not in output:
        return False
    return True</pre></div><p class="calibre8">If <code class="email">sshd</code> is running and listening on a port, the output of the <code class="email">netstat -tulpn | grep sshd</code> command should look like this:</p><div><pre class="programlisting">tcp        0      0 0.0.0.0:3306              0.0.0.0:*               LISTEN      426/mysqld
tcp6       0      0 :::3306                   :::*                    LISTEN      426/mysqld</pre></div><p class="calibre8">If <code class="email">mysqld</code> is running, and listening either on IPv4 or IPv6 (or both), then this function will return <code class="email">True</code>.</p><p class="calibre8">This function is far from perfect. There are a number of factors that may cause this command to return a false positive. For instance, let's say you were looking for <code class="email">sshd</code> instead of <code class="email">mysqld</code>. And say you were a fan of American football, and had written your own high-definition football video-streaming service that you called <code class="email">passhd</code>. This may be unlikely, but it's certainly not impossible. And it brings up an important point: when dealing with data received either from users or from computers, <strong class="calibre2">trust but verify</strong>. In fact, you should always assume that somebody is going to try to do something bad, and you should watch for ways to keep them from doing so.</p></div></div></div>

<div><div><div><div><div><div><h2 class="title1" id="calibre_pb_8"><a id="ch02lvl2sec19" class="calibre1"/>Getting configuration parameters</h2></div></div></div><p class="calibre8">Whereas<a id="id52" class="calibre1"/> some software can be accessed without any special configuration, there is plenty that does require some information to be set up. There are four places that an execution module can get its configuration from: the Minion configuration file, grain data, pillar data, and the master configuration file.</p><div><h3 class="title2"><a id="note03" class="calibre1"/>Note</h3><p class="calibre8">This is one of those places where Salt built-ins behave differently. Grain and pillar data are available to execution and state modules, but not to other types of module. This is because grain and pillar data is specific to the Minion running the module. Runners, for instance, cannot access this data, because runners are used on the Master; not directly on Minions.</p></div><p class="calibre8">The first <a id="id53" class="calibre1"/>place we can look for configuration is from the <code class="email">__opts__</code> dictionary. When working in modules that execute on a Minion, this dictionary will contain a copy of the data from the Minion configuration file. It may also contain some information that Salt generates on its own during runtime. When accessed from modules that execute on the Master, this data will come from the master configuration file.</p><p class="calibre8">It is also possible to set configuration values inside grain or pillar data. This information is accessed using the <code class="email">__grains__</code> and <code class="email">__pillar__</code> dictionaries, respectively. The following example shows different configuration values being pulled from each of these locations:</p><div><pre class="programlisting">username = __opts__['username']
hostname = __grains__['host']
password = __pillar__['password']</pre></div><p class="calibre8">Since those values may not actually exist, it is better to use Python's <code class="email">dict.get()</code> method, and supply a default:</p><div><pre class="programlisting">username = __opts__.get('username', 'salt')
hostname = __grains__.get('host', 'localhost')
password = __pillar__.get('password', None)</pre></div><p class="calibre8">The last place we can store configuration data is inside the master configuration file. All of the Master's configuration can be stored inside a pillar dictionary called <code class="email">master</code>. By default, this is not made available to Minions. However, it can be turned on by setting <code class="email">pillar_opts</code> to <code class="email">True</code> in the <code class="email">master</code> configuration file.</p><p class="calibre8">Once <code class="email">pillar_opts</code> is turned on, you can use commands like this to access a value in the <code class="email">master</code> configuration:</p><div><pre class="programlisting">master_interface = __pillar__['master']['interface']
master_sock_dir = __pillar__.get('master', {}).get('sock_dir', None)</pre></div><p class="calibre8">Finally, it is possible to ask Salt to search each of these locations, in turn, for a specific variable. This can be very valuable when you don't care which component carries the information that you need, so long as you can get it from somewhere.</p><p class="calibre8">In order to search each of these areas, cross-call to the <code class="email">config.get()</code> function:</p><div><pre class="programlisting">username = __salt__['config.get']('username')</pre></div><p class="calibre8">This will search for the configuration parameter in the following order:</p><div><ol class="orderedlist"><li class="listitem" value="1"><code class="email">__opts__</code> (on the Minion).</li><li class="listitem" value="2"><code class="email">__grains__</code>.</li><li class="listitem" value="3"><code class="email">__pillar__</code>.</li><li class="listitem" value="4"><code class="email">__opts__</code> (on the Master).</li></ol><div></div><p class="calibre8">Keep in <a id="id54" class="calibre1"/>mind that when using <code class="email">config.get()</code>, the first value found will be used. If the value that you are looking for is defined in both <code class="email">__grains__</code> and <code class="email">__pillar__</code>, then the value in <code class="email">__grains__</code> will be used.</p><p class="calibre8">Another advantage of using <code class="email">config.get()</code> is that this function will automatically resolve data that is referred to using <code class="email">sdb://</code> URIs. When accessing those dictionaries directly, any <code class="email">sdb://</code> URIs will need to be handled manually. Writing and using SDB modules will be covered in <a class="calibre1" title="Chapter 3. Extending Salt Configuration" href="part0023_split_000.html#LTSU2-d9976ffc65994572ad672a3ef48f1135">Chapter 3</a>, <em class="calibre9">Extending Salt Configuration</em>.</p><p class="calibre8">Let's go ahead and set up a module that obtains configuration data and uses it to make a connection to a service:</p><div><pre class="programlisting">'''
This module should be saved as salt/modules/mysqltest.py
'''
import MySQLdb


def version():
    '''
    Returns MySQL Version

    CLI Example:
        salt '*' mysqltest.version
    '''
    user = __salt__['config.get']('mysql_user', 'root')
    passwd = __salt__['config.get']('mysql_pass', '')
    host = __salt__['config.get']('mysql_host', 'localhost')
    port = __salt__['config.get']('mysql_port', 3306)
    db_ = __salt__['config.get']('mysql_db', 'mysql')
    dbc = MySQLdb.connect(
        connection_user=user,
        connection_pass=passwd,
        connection_host=host,
        connection_port=port,
        connection_db=db_,
    )
    cur = dbc.cursor()
    return cur.execute('SELECT VERSION()')</pre></div><p class="calibre8">This<a id="id55" class="calibre1"/> execution module will run on the Minion, but it can connect to any MySQL database using configuration defined in any of the four configuration areas. However, this function is pretty limited. If the <code class="email">MySQLdb</code> driver is not installed, then errors will appear in the Minion's log files when it starts up. If you need to perform other types of query, you will need to grab the configuration values each time. Let's solve each of these problems in turn.</p><div><h3 class="title2"><a id="tip02" class="calibre1"/>Tip</h3><p class="calibre8">Did you notice that we used a variable called <code class="email">db_</code> instead of <code class="email">db</code>? In Python, it is considered better practice to use variable names that are at least three characters long. Salt also considers this to be a requirement. A very common means of accomplishing this for variables that would normally be shorter is to append one or two underscores to the end of the variable name.</p></div></div></div></div>

<div><div><div><div><div><div><h2 class="title1" id="calibre_pb_9"><a id="ch02lvl2sec20" class="calibre1"/>Handling imports</h2></div></div></div><p class="calibre8">A <a id="id56" class="calibre1"/>number of Salt modules require third-party Python libraries to be installed. If any of those libraries aren't installed, then the <code class="email">__virtual__()</code> function should return <code class="email">False</code>. But how do you know beforehand whether or not the libraries can be imported?</p><p class="calibre8">A very common trick in a Salt module involves attempting to import libraries, and then recording whether or not the import succeeded. This is often accomplished using a variable with a name like <code class="email">HAS_LIBS</code>:</p><div><pre class="programlisting">try:
    import MySQLdb
    HAS_LIBS = True
except ImportError:
    HAS_LIBS = False


def __virtual__():
    '''
    Check dependencies
    '''
    return HAS_LIBS</pre></div><p class="calibre8">In this case, Python will attempt to import <code class="email">MySQLdb</code>. If it succeeds, then it will set <code class="email">HAS_LIBS</code> to <code class="email">True</code>. Otherwise, it will set it to <code class="email">False</code>. And because this directly correlates to the value that needs to be returned from the <code class="email">__virtual__()</code> function, we can just return it as it is, so long as we're not changing <code class="email">__virtualname__</code>. If we were, then the function <a id="id57" class="calibre1"/>would look like this:</p><div><pre class="programlisting">def __virtual__():
    '''
    Check dependencies
    '''
    if HAS_LIBS:
        return __virtualname__
    return False</pre></div></div></div></div>

<div><div><div><div><div><div><h2 class="title1" id="calibre_pb_10"><a id="ch02lvl2sec21" class="calibre1"/>Reusing code</h2></div></div></div><p class="calibre8">There's still<a id="id58" class="calibre1"/> the matter of eliminating redundant code between different functions in the same module. In the case of modules that use connection objects (such as a database cursor, or a cloud provider authentication) throughout the code, specific functions are often set aside to gather configuration, and establish a connection.</p><p class="calibre8">A very common name for these in-cloud modules is <code class="email">_get_conn()</code>, so let's go with that in our example:</p><div><pre class="programlisting">def _get_conn():
    '''
    Get a database connection object
    '''
    user = __salt__['config.get']('mysql_user', 'root')
    passwd = __salt__['config.get']('mysql_pass', '')
    host = __salt__['config.get']('mysql_host', 'localhost')
    port = __salt__['config.get']('mysql_port', 3306)
    db_ = __salt__['config.get']('mysql_db', 'mysql')
    return MySQLdb.connect(
        connection_user=user,
        connection_pass=passwd,
        connection_host=host,
        connection_port=port,
        connection_db=db_,
    )


def version():
    '''
    Returns MySQL Version

    CLI Example:
        salt '*' mysqltest.version
    '''
    dbc = _get_conn()
    cur = dbc.cursor()
    return cur.execute('SELECT VERSION()')</pre></div><p class="calibre8">This<a id="id59" class="calibre1"/> greatly simplifies our code, by turning a large chunk of lines in every function into a single line. Of course, this can be taken quite a bit further. The actual <code class="email">salt/modules/mysql.py</code> module that ships with Salt uses a function called <code class="email">_connect()</code> instead of <code class="email">_get_conn()</code>, and it also has <code class="email">cur.execute()</code> abstracted out into its own <code class="email">_execute()</code> function. You <a id="id60" class="calibre1"/>can see these at Salt's GitHub page:</p><p class="calibre8">
<a class="calibre1" href="https://github.com/saltstack/salt">https://github.com/saltstack/salt</a>
</p></div></div></div>

<div><div><div><div><div><div><h2 class="title1" id="calibre_pb_11"><a id="ch02lvl2sec22" class="calibre1"/>Logging messages</h2></div></div></div><p class="calibre8">Very <a id="id61" class="calibre1"/>often, you will perform an operation that requires some kind of message to be logged somewhere. This is especially common when writing new code; it's nice to be able to log debugging information.</p><p class="calibre8">Salt has a logging system built in, based on Python's own <code class="email">logging</code> library. To turn it on, there are two lines that you'll need to add toward the top of your module:</p><div><pre class="programlisting">import logging
log = logging.getLogger(__name__)</pre></div><p class="calibre8">With these in place, you can log messages using a command like this:</p><div><pre class="programlisting">log.debug('This is a log message')</pre></div><p class="calibre8">There are <a id="id62" class="calibre1"/>five levels of logging that are typically used in Salt:</p><div><ol class="orderedlist"><li class="listitem" value="1"><code class="email">log.info()</code>: Information at this level is something that is considered to be important to all users. It doesn't mean anything is wrong, but like all log messages, its output will be sent to <code class="email">STDERR</code> instead of <code class="email">STDOUT</code> (so long as Salt is running in the foreground, and not configured to log elsewhere).</li><li class="listitem" value="2"><code class="email">log.warn()</code>: A message logged from here should indicate to the user that something is not happening as it should be. However, it is not so broken as to stop the code from running.</li><li class="listitem" value="3"><code class="email">log.error()</code>: This denotes that something has gone wrong, and Salt is unable to continue until it is fixed. </li><li class="listitem" value="4"><code class="email">log.debug()</code>: This is not only information that is useful for determining what the program is thinking but is also intended to be useful to regular users of the program for things like troubleshooting.</li><li class="listitem" value="5"><code class="email">log.trace()</code>: This is similar to a debug message, but the information here is more likely to be useful only to developers.</li></ol><div></div><p class="calibre8">For now, we'll add a <code class="email">log.trace()</code> to our <code class="email">_get_conn()</code> function, which lets us know when we <a id="id63" class="calibre1"/>successfully connect to the database:</p><div><pre class="programlisting">def _get_conn():
    '''
    Get a database connection object
    '''
    user = __salt__['config.get']('mysql_user', 'root')
    passwd = __salt__['config.get']('mysql_pass', '')
    host = __salt__['config.get']('mysql_host', 'localhost')
    port = __salt__['config.get']('mysql_port', 3306)
    db_ = __salt__['config.get']('mysql_db', 'mysql')
    dbc = MySQLdb.connect(
        connection_user=user,
        connection_pass=passwd,
        connection_host=host,
        connection_port=port,
        connection_db=db_,
    )
    log.trace('Connected to the database')
    return dbc</pre></div><div><h3 class="title2"><a id="tip03" class="calibre1"/>Tip</h3><p class="calibre8">There are certain places where it is tempting to use log messages, but they should be avoided. Specifically, log messages may be used in any function, except for <code class="email">__virtual__()</code>. Log messages used outside of functions, and in the <code class="email">__virtual__()</code> function, make for messy log files that are a pain to read and navigate.</p></div></div></div></div>

<div><div><div><div><div><div><h2 class="title1" id="calibre_pb_12"><a id="ch02lvl2sec23" class="calibre1"/>Using the __func_alias__ dictionary</h2></div></div></div><p class="calibre8">There <a id="id64" class="calibre1"/>are a handful of words that are reserved in Python. Unfortunately, some of these words are also very useful for things like function names. For instance, many modules have a function whose job is to list data relevant to that module, and it seems natural to call such a function <code class="email">list()</code>. But that would conflict with Python's <code class="email">list</code> built-in. This poses a problem, since function names are directly exposed to the Salt command.</p><p class="calibre8">A workaround is available for this. A <code class="email">__func_alias__</code> dictionary may be declared at the top of a module, which creates a map between aliases used from the command line and the actual name of the function. For instance:</p><div><pre class="programlisting">__func_alias__ = {
    'list_': 'list'
}

def list_(type_):
    '''
    List different resources in MySQL
    CLI Examples:
        salt '*' mysqltest.list tables
        salt '*' mysqltest.list databases
    '''
    dbc = _get_conn()
    cur = dbc.cursor()
    return cur.execute('SHOW {0}()'.format(type_))</pre></div><p class="calibre8">With<a id="id65" class="calibre1"/> this in place, the <code class="email">list_</code> function will be called as <code class="email">mysqltest.list</code> (as in the <code class="email">CLI Example</code>) instead of <code class="email">mysqltest.list_</code>.</p><div><h3 class="title2"><a id="tip04" class="calibre1"/>Tip</h3><p class="calibre8">Why did we call the variable <code class="email">type_</code> instead of <code class="email">type</code>? Because <code class="email">type</code> is a Python built-in. But since this function only has one argument, it's not expected that users will need to use <code class="email">type_=&lt;something&gt;</code> as part of their Salt command.</p></div></div></div></div>

<div><div><div><div><div><div><h2 class="title1" id="calibre_pb_13"><a id="ch02lvl2sec24" class="calibre1"/>Validating data</h2></div></div></div><p class="calibre8">From<a id="id66" class="calibre1"/> that last piece of code, a number of readers at this point probably have warning bells going off in their heads. It allows for a very common type of security vulnerability called an injection attack. Because the function does not perform any sort of validation on the <code class="email">type_</code> variable, it is possible for users to pass in code that can cause destruction, or obtain data that they shouldn't have.</p><p class="calibre8">One might think that this isn't necessarily a problem in Salt, because in a number of environments, only trusted users should have access. However, because Salt can be used by a wide range of user types, who may be intended to only have limited access, there are a number of scenarios where an injection attack can be devastating. Imagine a user running the following Salt command:</p><div><pre class="programlisting">
<strong class="calibre2">#salt myminion mysqltest.list 'tables; drop table users;'</strong>
</pre></div><p class="calibre8">This is often easy to fix, by adding some simple checking to any user input (remember: <strong class="calibre2">trust but verify</strong>):</p><div><pre class="programlisting">from salt.exceptions import CommandExecutionError


def list_(type_):
    '''
    List different resources in MySQL
    CLI Examples:
        salt '*' mysqltest.list tables
        salt '*' mysqltest.list databases
    '''
    dbc = _get_conn()
    cur = dbc.cursor()
    valid_types = ['tables', 'databases']
    if type_ not in valid_types:
        err_msg = 'A valid type was not specified'
        log.error(err_msg)
        raise CommandExecutionError(err_msg)
    return cur.execute('SHOW {0}()'.format(type_))</pre></div><p class="calibre8">In this <a id="id67" class="calibre1"/>case, we've declared which types are valid before allowing them to be passed in to the SQL query. Even a single bad character will cause Salt to refuse to complete the command. This kind of data validation is often better, because it doesn't try to modify the input data to make it safe to run. Doing so is referred to as <em class="calibre9">validating user input</em>.</p><p class="calibre8">We've added in another piece of code as well: a Salt exception. There are a number of these available in the <code class="email">salt.exceptions</code> library, but <code class="email">CommandExecutionError</code> is one that you may find yourself using quite a bit when validating data.</p></div></div></div>

<div><div><div><div><div><div><h2 class="title1" id="calibre_pb_14"><a id="ch02lvl2sec25" class="calibre1"/>Formatting strings</h2></div></div></div><p class="calibre8">A <a id="id68" class="calibre1"/>quick note on string formatting: Older Python developers may have noticed that we opted to use <code class="email">str.format()</code> instead of the older <code class="email">printf</code>-style string handling. The following two lines of code do the same thing in Python:</p><div><pre class="programlisting">'The variable's value is {0}'.format(myvar)
'The variable's value is %s' % myvar</pre></div><p class="calibre8">String formatting using <code class="email">str.format()</code> is just a little faster in Python, and is required in Salt except for in places where it doesn't make sense.</p><p class="calibre8">Don't be tempted to use the following shortcut available in Python 2.7.x:</p><div><pre class="programlisting">'The variable's value is {}'.format(myvar)</pre></div><p class="calibre8">Because Salt still needs to run on Python 2.6, which doesn't support using <code class="email">{}</code> instead of <code class="email">{0}</code>, this will cause problems for users on older platforms.</p></div></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec13" class="calibre1"/>The final module</h1></div></div></div><p class="calibre8">When <a id="id69" class="calibre1"/>we put all of the preceding code together, we end up with the following module:</p><div><pre class="programlisting">'''
This module should be saved as salt/modules/mysqltest.py
'''
import salt.utils

try:
    import MySQLdb
    HAS_LIBS = True
except ImportError:
    HAS_LIBS = False

import logging
log = logging.getLogger(__name__)

__func_alias__ = {
    'list_': 'list'
}


__virtualname__ = 'mysqltest'


def __virtual__():
    '''
    Check dependencies, using both methods from the chapter
    '''
    if not salt.utils.which('mysql'):
        return False

    if HAS_LIBS:
        return __virtualname__

    return False


def ping():
    '''
    Returns True

    CLI Example:
        salt '*' mysqltest.ping
    '''
    return True


def check_mysqld():
    '''
    Check to see if sshd is running and listening

    CLI Example:
        salt '*' testmodule.check_mysqld
    '''
    output = __salt__['cmd.run']('netstat -tulpn | grep mysqld', python_shell=True)
    if 'tcp' not in output:
        return False
    return True


def _get_conn():
    '''
    Get a database connection object
    '''
    user = __salt__['config.get']('mysql_user', 'root')
    passwd = __salt__['config.get']('mysql_pass', '')
    host = __salt__['config.get']('mysql_host', 'localhost')
    port = __salt__['config.get']('mysql_port', 3306)
    db_ = __salt__['config.get']('mysql_db', 'mysql')
    dbc = MySQLdb.connect(
        connection_user=user,
        connection_pass=passwd,
        connection_host=host,
        connection_port=port,
        connection_db=db_,
    )
    log.trace('Connected to the database')
    return dbc


def version():
    '''
    Returns MySQL Version

    CLI Example:
        salt '*' mysqltest.version
    '''
    dbc = _get_conn()
    cur = dbc.cursor()
    return cur.execute('SELECT VERSION()')


def list_(type_):
    '''
    List different resources in MySQL
    CLI Examples:
        salt '*' mysqltest.list tables
        salt '*' mysqltest.list databases
    '''
    dbc = _get_conn()
    cur = dbc.cursor()
    valid_types = ['tables', 'databases']
    if type_ not in valid_types:
        err_msg = 'A valid type was not specified'
        log.error(err_msg)
        raise CommandExecutionError(err_msg)
    return cur.execute('SHOW {0}()'.format(type_))</pre></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec14" class="calibre1"/>Troubleshooting execution modules</h1></div></div></div><p class="calibre8">As with <a id="id70" class="calibre1"/>any programming, the more time you spend writing execution modules, the more likely you are to encounter issues. Let's take a moment to talk about how to troubleshoot and debug your code.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec26" class="calibre1"/>Using salt-call</h2></div></div></div><p class="calibre8">The <code class="email">salt-call</code> command has always been a valuable tool for testing and troubleshooting <a id="id71" class="calibre1"/>code. Without it, you would need to restart the <code class="email">salt-minion</code> service each time you wanted to test new code; believe me, that gets old fast.</p><p class="calibre8">Because <code class="email">salt-call</code> doesn't start up a service, it will always run the latest copy of the Salt code. It does do most of the things that the <code class="email">salt-minion</code> service does: it loads grains, connects to the Master (unless told not to) to obtain pillar data, goes through the loader process to decide which modules to load, and then performs the requested command. Pretty much the only thing it doesn't do is keep running.</p><p class="calibre8">Using <code class="email">salt-call</code> to issue a command is also the same as using the <code class="email">salt</code> command, except that a target is not required (because the target is the Minion that <code class="email">salt-call</code> is running on):</p><div><pre class="programlisting">
<strong class="calibre2">#salt '*' mysqltest.ping</strong>
<strong class="calibre2">#salt-call mysqltest.ping</strong>
</pre></div><p class="calibre8">You may notice that even though you're issuing <code class="email">salt-call</code> commands on the same machine that will be performing the execution, it tends to run a little slower. There are two reasons for this. First of all, you are still basically starting up the <code class="email">salt-minion</code> service each time, without actually keeping it running. That means that detecting grains, loading modules, and so on will have to happen each time.</p><p class="calibre8">To get a<a id="id72" class="calibre1"/> feel for how much time this really takes, try comparing execution times both with and without grain detection:</p><div><pre class="programlisting">
<strong class="calibre2"># time salt-call test.ping</strong>
<strong class="calibre2">local:</strong>
<strong class="calibre2">    True</strong>
<strong class="calibre2">real	0m3.257s</strong>
<strong class="calibre2">user	0m0.863s</strong>
<strong class="calibre2">sys	0m0.197s</strong>
<strong class="calibre2"># time salt-call --skip-grains test.ping</strong>
<strong class="calibre2">local:</strong>
<strong class="calibre2">    True</strong>
<strong class="calibre2">real	0m0.675s</strong>
<strong class="calibre2">user	0m0.507s</strong>
<strong class="calibre2">sys	0m0.080s</strong>
</pre></div><p class="calibre8">Of course, if you're testing a module that makes use of grains, this is not an acceptable strategy. The second thing that slows down commands is having to connect to the Master. This doesn't take nearly as much time as grain detection, but it does take a hit:</p><div><pre class="programlisting">
<strong class="calibre2"># time salt-call --local test.ping</strong>
<strong class="calibre2">local:</strong>
<strong class="calibre2">    True</strong>
<strong class="calibre2">real	0m2.820s</strong>
<strong class="calibre2">user	0m0.797s</strong>
<strong class="calibre2">sys	0m0.120s</strong>
</pre></div><p class="calibre8">The <code class="email">--local</code> flag doesn't just tell <code class="email">salt-call</code> not to talk to the Master. It actually tells <code class="email">salt-call</code> to use itself as the Master (meaning, operate in local mode). If your module makes use of pillars or other resources on the Master, then you can just serve them locally instead.</p><p class="calibre8">Any configuration in the master configuration file that you need can be copied directly to the <code class="email">Minion</code> file. If you're just using the defaults, you don't even need to do that: just copy the necessary files from the Master to the Minion:</p><div><pre class="programlisting">
<strong class="calibre2"># scp -r saltmaster:/srv/salt /srv</strong>
<strong class="calibre2"># scp -r saltmaster:/srv/pillar /srv</strong>
</pre></div><p class="calibre8">Once everything is in place, go ahead and fire up <code class="email">salt-call</code> with the <code class="email">--local</code> flag and get to troubleshooting.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec27" class="calibre1"/>&lt;function&gt; is not available</h2></div></div></div><p class="calibre8">When I'm <a id="id73" class="calibre1"/>writing a new module, one of the first problems I have is getting the module to show up. Quite often this is because of obviously bad code, such as a typo. For instance, if we were to change our import from <code class="email">salt.utils</code> to <code class="email">salt.util</code>, our module would fail to load:</p><div><pre class="programlisting">
<strong class="calibre2">$ grep 'import salt' salt/modules/mysqltest.py</strong>
<strong class="calibre2">import salt.util</strong>
<strong class="calibre2"># salt-call --local mysqltest.ping</strong>
<strong class="calibre2">'mysqltest.ping' is not available.</strong>
</pre></div><p class="calibre8">In cases like this, we can find the problem by running <code class="email">salt-call</code> in <code class="email">debug</code> mode:</p><div><pre class="programlisting">
<strong class="calibre2"># salt-call --local -l debug mysqltest.ping</strong>
<strong class="calibre2">...</strong>
<strong class="calibre2">[DEBUG   ] Failed to import module mysqltest:</strong>
<strong class="calibre2">Traceback (most recent call last):</strong>
<strong class="calibre2">  File "/usr/lib/python2.7/site-packages/salt/loader.py", line 1217, in _load_module</strong>
<strong class="calibre2">    ), fn_, fpath, desc)</strong>
<strong class="calibre2">  File "/usr/lib/python2.7/site-packages/salt/modules/mysqltest.py", line 4, in &lt;module&gt;</strong>
<strong class="calibre2">    import salt.util</strong>
<strong class="calibre2">ImportError: No module named util</strong>
<strong class="calibre2">...</strong>
<strong class="calibre2">'mysqltest.ping' is not available.</strong>
</pre></div><p class="calibre8">Another possibility is that there is a problem with the <code class="email">__virtual__()</code> function. This is the one time I would recommend adding log messages to that function:</p><div><pre class="programlisting">def __virtual__():
    '''
    Check dependencies, using both methods from the chapter
    '''
    log.debug('Checking for mysql command')
    if not salt.utils.which('mysql'):
        return False

    log.debug('Checking for libs')
    if HAS_LIBS:
        return __virtualname__

    return False</pre></div><p class="calibre8">However, make sure you pull them out before you ever get into production, or you're going to have some very unhappy users sooner or later.</p><div><h3 class="title2"><a id="tip05" class="calibre1"/>Tip</h3><p class="calibre8">
<strong class="calibre2">Downloading the example code</strong>
</p><p class="calibre8">You can download the example code files for this book from your account at <a class="calibre1" href="http://www.packtpub.com">http://www.packtpub.com</a>. If you purchased this book elsewhere, you can visit <a class="calibre1" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p><p class="calibre8">You can download the code files by following these steps:</p><div><ul class="itemizedlist"><li class="listitem">Log in or register to our website using your e-mail address and password.</li><li class="listitem">Hover the mouse pointer on the SUPPORT tab at the top.</li><li class="listitem">Click on Code Downloads &amp; Errata.</li><li class="listitem">Enter the name of the book in the Search box.</li><li class="listitem">Select the book for which you're looking to download the code files.</li><li class="listitem">Choose from the drop-down menu where you purchased this book from.</li><li class="listitem">Click on Code Download.</li></ul></div><p class="calibre8">Once the file is downloaded, please make sure that you unzip or extract the folder using the latest version of:</p><div><ul class="itemizedlist"><li class="listitem">WinRAR/7-Zip for Windows</li><li class="listitem">Zipeg/iZip/UnRarX for Mac</li><li class="listitem">7-Zip/PeaZip for Linux</li></ul></div></div></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec15" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">Learning how to write execution modules creates an excellent foundation for writing other Salt modules. Salt contains a number of built-ins, many of which are available across all module types. A number of libraries also ship with Salt inside the <code class="email">salt/utils/</code> directory. And troubleshooting Salt modules is easiest when using the <code class="email">salt-call</code> command, particularly in local mode.</p><p class="calibre8">Next up, we'll talk about various types of Salt module that can be used to handle configuration.</p></div></body></html>