- en: Chapter 7. Retrieving Data from the Real World with Sensors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will work with a variety of sensors to retrieve data from
    the real world. We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding sensors and their connection types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn the most important things we must consider when choosing sensors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Take advantage of the `upm` library with many different sensors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Measure the magnitude and direction of proper acceleration or g-force with an
    accelerometer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Work with a three axis analog accelerometer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a digital accelerometer that works with the I²C bus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Work with the `mraa` library and the I²C bus to control a digital accelerometer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Measure ambient temperature with an analog sensor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a digital temperature and humidity sensor that works with the I²C bus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding sensors and their connection types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 6](ch06.html "Chapter 6. Working with Analog Inputs and Local Storage"),
    *Working with Analog Inputs and Local Storage*, we used a photoresistor that is
    included in a voltage divider and we connected it to an analog input pin. We were
    able to measure the ambient light and we determined different darkness levels
    and change the brightness levels of an RGB LED. The photoresistor, also known
    as **LDR** (short for **Light-Dependent Resistor**) or photocell, is a sensor.
    We just needed to include it in a voltage divider to make the changes in the resistance
    value of the photoresistor via the ambient light. These variations in the resistance
    value will generate changes in the voltage value in our analog pin. Thus, we worked
    with a configuration of electronic components that generated an analog sensor,
    capable of transforming changes in the environment light into voltage values.
  prefs: []
  type: TYPE_NORMAL
- en: There are a huge number of sensors that allow us to retrieve data from the real
    world and convert it into analog or digital values that we can collect with the
    different communications ports included in the Intel Galileo Gen 2 board and process
    with Python and different libraries. When we worked with the photoresistor to
    measure the environment light, we wired the configuration to an analog pin and
    we worked with the `mraa` library and then the `wiring-x86` library to take advantage
    of the analog to digital converter to retrieve the values.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 2](ch02.html "Chapter 2. Working with Python on Intel Galileo Gen
    2"), *Working with Python on Intel Galileo Gen 2*, we installed the latest available
    version of the `upm` library. This library provides high level interfaces for
    sensors and actuators. Whenever we work with a sensor, it is usually convenient
    to check whether the `upm` library includes support for it because the high level
    interface can save us a lot of time and make it easier for us to start retrieving
    the values from the sensor and perform the necessary conversions to the different
    measuring units.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will take advantage of the `upm` library with many different
    sensors. However, we must take into account that sometimes the features included
    in the `upm` library for a specific sensor might not be enough and we might need
    to write our own low level code to interact with the sensor with either the `mraa`
    or the `wiring-x86` library. As we will analyze later, depending on the connection
    type, only the `mraa` will provide us with all the necessary features when the
    sensor is not supported in the `upm` library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Obviously, the first thing that we must consider when selecting a sensor is
    what we want to measure, for example, temperature. However, that is not the only
    thing we have to consider to select a specific sensor. When we select sensors,
    we must take into account their features, their measurement range, their precision
    and their connection types, among other things. The following list enumerates
    the most important things we must consider and their explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Compatibility with Intel Galileo Gen 2 board and the voltage supply that
    we are using (5V or 3.3V)**: Sometimes, we have to wire more than one sensor to
    the board, and therefore, it is important to check whether all the sensors we
    are selecting can work with the voltage configuration we have for the board. Some
    sensors are only capable to work with the board if we have a specific setting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Power consumption**: We must take into account that some sensors have different
    working modes. For example, some sensors have a high performance mode that requires
    more power than a normal mode. As we might work with more than one sensor wired
    to the board, it is also important to consider the overall power consumption with
    all the sensors connected to the board and in the modes in which we will use them.
    In addition, some sensors switch to power saving modes when we don''t use them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Connection type**: We need to answer a few questions in order to decide the
    most convenient connection type. Do we have the necessary connections, communications
    or interface ports? Are they available? Do the connection type and the distance
    we need have any impact on the accuracy for the measured values? In addition,
    when we select the first sensor for our board, all the connections might be available,
    but the situation changes as we add more sensors and it can force the decision
    to select a sensor with a different connection type. Let''s consider the following
    situation, we are already measuring ambient light in 6 different positions. We
    have 6 photoresistors connected with 6 voltage divider configurations and wired
    to the 6 available analog input pins, and therefore, we don''t have additional
    analog pins available. If we have to add a temperature sensor, we cannot add an
    analog sensor that requires an analog input pin because all of them are wired
    to the light sensors. In this case, we have to use a digital temperature sensor
    that we can wire to either the I²C or the SPI buses. Another option is to use
    a digital temperature sensor that we can wire to the UART port. We will dive deep
    on the different connection types for the sensors later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Measurement ranges**: The specifications for the sensors indicate their measurement
    ranges. For example, a temperature sensor measuring ambient temperature can have
    a measurement range of -40ºF to 185ºF (equivalent to -40ºC to 85ºC). In case we
    need to measure ambient temperatures that can reach 90ºC, we have to select a
    temperature sensor with a higher upper range. For example, another sensor that
    measuring ambient temperature provides a measurement range of -40ºF to 257ºF (equivalent
    to -40ºC to 125ºC) will be suitable for this job.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sensitivity and precision**: Each sensor is sensitive and might offer different
    configurable precision levels. We have to make sure the accuracy provided by the
    sensor is compatible with our needs. As the measured value changes, it is important
    to consider the sensitivity, also known as measurement resolution. For example,
    if we have to measure temperature and we must be able to determine changes of
    at least 2ºF or 1ºC based on the unit of measure we are using, we have to make
    sure that the sensor is capable providing the required sensitivity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: When we start the process of selecting the appropriate sensor, it is very important
    to pay attention to the units of measure when we analyze measurement ranges, sensitivity
    and precision. A typical example is a temperature sensor that can express the
    values in either degrees Celsius (ºC) or degrees Fahrenheit (ºF).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Latency**: It is very important to determine how much can we wait for the
    sensor to gather a new value and whether it is capable of providing us with a
    real new value in this amount of time. When the measure value changes in the real
    environment or object that we are measuring, the sensor takes some time to be
    able to provide us with the new measured value. Sometimes, they are microseconds
    but in other cases, they can be milliseconds or even seconds. It depends on the
    sensor and we have to take it into account when selecting the appropriate sensor
    for our project. For example, we might need a temperature sensor to allow us to
    measure 2 temperature values per second, and therefore, we must work with a sensor
    with a latency lower than 500 milliseconds (0.5 seconds) to achieve our goal.
    Specifically, we can select a temperature sensor with a latency of 200 milliseconds.
    Unluckily, sometimes we have to dive deep on the datasheets to check the latency
    value for some sensors and the electronic components that it uses.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Operating range and special environment requirements**: It is very important
    to consider the operating range for the sensor. Sometimes, the sensors have to
    work in specific environment conditions that might not be suitable for all of
    the available sensors. The following are some examples of rough environment requirements:
    high shock survivability, water resistance, extremely high temperatures, and very
    high humidity levels.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dimensions**: Sensors come with different dimensions. Sometimes only specific
    dimensions are suitable for our project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Protocol, support in the upm library and Python bindings**: We will end up
    processing the data retrieved from the sensor with Python code, and therefore,
    it is very important to make sure that we can work with the sensor in Python.
    In some cases, we don''t want to write low-level code and we want to make sure
    that the sensor is supported in the `upm` library. In other cases, we have to
    make sure that we have the necessary Python libraries to work with the protocols
    that some digital sensors use. For example, many temperature sensors that work
    with the UART port use the MODBUS serial communications protocol. If they aren''t
    supported in the `upm` library, we have to work with specific Python libraries
    to establish communications using the MODBUS serial communications protocol and
    it might require additional work on our side in case we don''t have previous experience
    with this protocol.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cost**: Obviously, we have to take into account the sensor''s cost. Perhaps
    the best sensor that complies with all our requirements is extremely expensive
    and we might decide to use another sensor with less features or less precision
    but with a lower cost. We have a huge number of cheap sensors with impressive
    features that are compatible with the Intel Galileo Gen 2 board. However, we always
    have to take into account how much each sensor costs to select it according to
    our needs and our budget.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The sensors or modules that include sensors that we can wire to an Intel Galileo
    Gen 2 board can use the following connection types. The list enumerates the acronym
    that manufacturers usually use to describe the connection type for the modules
    and their explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**AIO**: The module requires one or more analog input pins. The sensors that
    require analog input pins are known as analog sensors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GPIO**: The module requires one or more GPIO pins.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**I²C**: The module requires two wires to connect to the two I²C bus lines:
    **SCL** (short for **S**erial **CL**ock) and **SDA** (short for **S**erial **DA**ta).
    We can connect many devices to this bus as long as each of them have a different
    I²C address.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SPI**: The module requires three wires to connect to the three SPI bus lines:
    **MISO** (short for **Master In Slave Out**), **MOSI** (short for **Master Out
    Slave In**) and **SCK** (short for **Serial Clock**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**UART**: The module works with a serial connection (RX/TX), and therefore,
    requires two wires to connect to the two pins for the UART port: **TX->1** and
    **RX<-0**. An **UART** port stands for **Universal Asynchronous Receiver/Transmitter**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The modules that work with the I²C bus, the SPI bus or an UART port are known
    as **digital sensors** because they use a digital interface. Some modules combine
    one of the buses or an UART port with GPIO pins.
  prefs: []
  type: TYPE_NORMAL
- en: We already worked with analog inputs and the analog to digital converter with
    both the `mraa` and `wiring-x86` libraries. We also worked with GPIO pins configured
    as input pins with these libraries. However, we still didn't work with the I²C
    bus, the SPI bus or the UART ports.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `mraa` library provides the following classes that allow us to work with
    the previously mentioned serial buses and the UART ports:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mraa.I2c`: The class represents an I²C bus master device (the board) that
    can talk to multiple I²C bus slave devices by selecting their address. It is possible
    to create many instances of this class to interact with many slave devices. The
    class allows us to write data to and read data from slave devices connected to
    the I²C bus.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Mraa.Spi`: The class represents an SPI bus and its chip select. The class
    allows us to write data to and read data from devices connected to the SPI bus.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mraa.UART`: The class represents an UART port and allow us to configure, send
    data to and receive data from an UART port.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can use the previously explained classes provided by the `mraa` library to
    interact with any of the digital modules. However, this would require us to spend
    some time reading the datasheets for the modules, understanding their working
    modes, writing code that writes data to and reads data from the appropriate bus
    or UART port. Each module has its own API and we have to compose requests and
    process responses through the serial buses or the UART port.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will take advantage of the `upm` library for each of the modules.
    In a few cases, we will also use the appropriate classes in the `mraa` library
    to understand how to interact with the sensors with a lower level interface. This
    way, in case we have to work with a module that isn't supported in the `upm` library,
    we can analyze the information provided in the datasheets and write code to interact
    with the module.
  prefs: []
  type: TYPE_NORMAL
- en: Working with accelerometers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An accelerometer allows us to measure the magnitude and direction of proper
    acceleration or g-force. Tablets and smartphones use accelerometers to automatically
    switch between portrait and landscape modes depending on the direction in which
    we hold the device. In addition, the built-in accelerometer allows us to control
    apps by making small movements of different intensity with the device in the different
    directions.
  prefs: []
  type: TYPE_NORMAL
- en: An accelerometer allows us to detect how an object is oriented with respect
    to the Earth's surface by measuring acceleration due to gravity. In addition,
    an accelerometer is extremely useful when we want to detect when an object starts
    or stops moving. Accelerometers are also capable of detecting vibration and when
    an object is falling down.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Accelerometers usually measure proper acceleration in g-force, abbreviated with
    a `g`. It is important to avoid the confusion generated by the force word included
    in the name of the unit of measure because we are measuring proper acceleration
    and not a force. Some accelerometers use meters per second squared (m/s2) as their
    unit of measure instead of g-force.
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, most accelerometers are capable of measuring acceleration in three
    axes and are known as 3-axis accelerometers or triple axis accelerometers. A 3-axis
    accelerometer can measure acceleration for the *x*, *y* and *z* axis. If we want
    to measure small accelerations or vibrations, it will be more convenient to work
    with a small range 3-axis accelerometer because they provide the necessary sensitivity.
  prefs: []
  type: TYPE_NORMAL
- en: Wiring an analog accelerometer to the analog input pins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The easiest way to understand how an accelerometer works is to use it in a simple
    example. Now, we will work with an analog 3-axis accelerometer with a full sensing
    range from -3g to +3g. This kind of accelerometer requires three analog input
    pins, one for each measured axes. The accelerometer supplies voltage levels based
    on the measured acceleration for each axes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the three analog pins labeled **A0**, **A1** and **A2** to connect
    the positive voltage outputs of an analog accelerometer breakout board. After
    we finish the necessary wirings, we will write Python code to measure and display
    the acceleration for the three axis: x, y and z. This way, we will read the result
    of converting an analog value to its digital representation and we will map it
    to the acceleration value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need a SparkFun triple axis accelerometer breakout ADXL335 to work with
    this example. The following URL provides detailed information about this breakout
    board: [https://www.sparkfun.com/products/9269](https://www.sparkfun.com/products/9269).
    The breakout board incorporates the ADXL335 accelerometer sensor from Analog Devices.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The power supplied to the breakout board should be between 1.8VDC and 3.6VDC,
    and therefore, we will use the power pin labeled **3V3** as the power supply to
    make sure we supply 3.3V and we never supply **5V** to the breakout board.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to use a Seeedstudio Grove 3-axis analog accelerometer
    to work with this example. The following URL provides detailed information about
    this module: [http://www.seeedstudio.com/depot/Grove-3Axis-Analog-Accelerometer-p-1086.html](http://www.seeedstudio.com/depot/Grove-3Axis-Analog-Accelerometer-p-1086.html).
    If you use this module, you can use either the power pin labeled **3V3** or **5V**
    as the power supply because the breakout board is capable of working with voltage
    supplies from 3V to 5V. The full sensing range is the same than the SparkFun breakout
    board and both use the same accelerometer sensor. The wirings are compatible for
    both modules.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows a SparkFun triple axis accelerometer breakout ADXL335,
    the necessary wirings and the wirings from the Intel Galileo Gen 2 board to the
    breadboard. The Fritzing file for the sample is `iot_fritzing_chapter_07_01.fzz`
    and the following picture is the breadboard view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Wiring an analog accelerometer to the analog input pins](img/B05042_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following picture shows the schematic with the electronic components represented
    as symbols:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Wiring an analog accelerometer to the analog input pins](img/B05042_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As seen in the previous schematic, we have the following connections:'
  prefs: []
  type: TYPE_NORMAL
- en: The analog input pin labeled **A0** is connected to the accelerometer output
    pin labeled **X** (**XOUT** in the breakout board's symbol)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The analog input pin labeled **A1** is connected to the accelerometer output
    pin labeled **Y** (**YOUT** in the breakout board's symbol)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The analog input pin labeled **A2** is connected to the accelerometer output
    pin labeled **Z** (**ZOUT** in the breakout board's symbol)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The power pin labeled **3V3** is connected to the accelerometer power pin labeled
    **VCC**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ground pin labeled **GND** is connected to the accelerometer ground pin
    labeled **GND**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, it is time make all the necessary wirings. Don't forget to shutdown the
    Yocto Linux, wait for all the onboard LEDs to turn off, and unplug the power supply
    from the Intel Galileo Gen 2 board before adding or removing any wire from the
    board's pins. Make sure you use large wires to allow you to move the accelerometer
    breakout board in different directions without accidentally unplugging cables.
  prefs: []
  type: TYPE_NORMAL
- en: Measuring three axis acceleration with an analog accelerometer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `upm` library includes support for the three axis analog accelerometer breakout
    board in the `pyupm_adxl335` module. The `ADXL335` class declared in this module
    represents a three axis analog accelerometer connected to our board. The class
    makes it easy to calibrate the accelerometer and convert the raw values read from
    the analog inputs into values expressed in the `g` unit.
  prefs: []
  type: TYPE_NORMAL
- en: We will create a new `Accelerometer` class to represent the accelerometer and
    make it easier for us to retrieve the acceleration values without worrying about
    type conversion that are necessary when working with an instance of the `ADXL335`
    class. We will use the `ADXL335` class to interact with the accelerometer. The
    following lines show the code for the new `Accelerometer` class that works with
    the `upm` library, specifically with the `pyupm_adxl335` module. The code file
    for the sample is `iot_python_chapter_07_01.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We have to specify the analog pin numbers to which each axes pin is connected
    when we create an instance of the `Accelerometer` class in the `pinX`, `pinY`,
    and `pinZ` required arguments. The constructor, that is, the `__init__` method,
    creates a new `upmAdxl335.ADXL335` instance with the received `pinX`, `pinY`,
    and `pinZ` arguments and saves its reference in the `accelerometer` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: The `upmAdxl335.ADXL335` instance requires working with floating point pointers
    to retrieve the acceleration values for the three axis. Thus, the constructor
    saves the three objects of type `float *` (float pointers) in the following three
    attributes by calling `upmAdxl335.new_floatPointer()`.
  prefs: []
  type: TYPE_NORMAL
- en: '`x_acceleration_fp`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`y_acceleration_fp`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`z_acceleration_fp`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, the constructor creates and initializes three attributes with `0.0`:
    `x_acceleration`, `y_acceleration` and `z_acceleration`. After the constructor
    is executed, we must calibrate the accelerometer and then, we will be ready to
    retrieve acceleration values for the three axis: *x*, *y* and *z*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The class defines the following two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`calibrate`: Calls the calibrate method for `self.accelerometer` to calibrate
    the analog accelerometer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`measure_acceleration`: Retrieves the acceleration values for the three axis
    and saves them in the following three attributes: `x_acceleration`, `y_acceleration`
    and `z_acceleration`. The acceleration values are expressed in g-force (`g`).
    First, the code calls the `acceleration` method for `self.accelerometer` with
    the three objects of type `float *` as arguments. The method reads the raw values
    retrieved from the three analog pins, converts them to the appropriate values
    in g-force (g) and changes the floating point values for the objects of type `float*`
    received as arguments with the updated values. Then, the code calls the `upmAdxl335.floatPointer_value`
    method to retrieve the floating point values from the objects of type `float*`
    and update the three attributes: `x_acceleration`, `y_acceleration` and `z_acceleration`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, we will write a loop that will run a calibration, retrieve and display
    the acceleration values for the three axis expressed in g-force (`g`) every 500
    milliseconds, that is, twice per second. The code file for the sample is `iot_python_chapter_07_01.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The first line creates an instance of the previously coded `Accelerometer` class
    with `0`, `1` and `2` as the values of the `pinX`, `pinY` and `pinZ` arguments.
    This way, the instance will read the analog values from the pins labeled **A0**,
    **A1** and **A2**. Then, the code calls the `calibrate` method for the `Accelerometer`
    instance to calibrate the analog accelerometer.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The calibration measures the *x*, *y* and *z* axis values while the sensor is
    still, and then, the sensor uses these values as the zero values, that is, as
    a baseline. The default sensitivity for this analog sensor is 0.25V/g.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the code runs a loop forever, that is, until you interrupt the execution
    by pressing *Ctrl* + *C* or the button to stop the process, in case you are using
    a Python IDE with remote development features to run the code in your board. The
    loop calls the `measure_acceleration` method to update the acceleration values
    and then prints them, expressed in g-force (g).
  prefs: []
  type: TYPE_NORMAL
- en: The following line will start the example. Don't forget that you need to transfer
    the Python source code file to the Yocto Linux with an SFTP client. Before you
    start the example, make sure that the accelerometer breakout board is located
    on stable surface that doesn't vibrate. This way, the calibration will work OK.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'After you run the example, perform the following actions:'
  prefs: []
  type: TYPE_NORMAL
- en: Make small movements to the accelerometer breakout board in different directions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make large movements to the accelerometer breakout board in specific directions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leave the accelerometer breakout board on a stable surface that doesn't vibrate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As a result of the previous actions, you will see the different acceleration
    values measured for the three axis. The following lines show some sample output
    lines generated when we make large movements with the breakout board:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Wiring a digital accelerometer to the I²C bus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Digital accelerometers usually provide a better precision, higher resolution
    and more sensitivity than analog accelerometers. Now, we will work with a digital
    3-axis accelerometer with a full sensing range from -16g to +16g. We will use
    a breakout board that uses the I²C bus to allow the board to communicate with
    the accelerometer.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the two pins labeled **SDA** and **SCL** to connect the data and
    clock lines of the I²C bus to the corresponding pins in the digital accelerometer
    breakout board. After we finish the necessary wirings, we will write Python code
    to measure and display the acceleration for the three axis: *x*, *y* and *z*.
    This way, we will read the result of sending commands to the accelerometer through
    the I²C bus, reading the responses and decoding them into the appropriate acceleration
    values expressed in g-force (`g`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need a SparkFun triple axis accelerometer breakout ADXL345 to work with
    this example. The following URL provides detailed information about this breakout
    board: [https://www.sparkfun.com/products/9836](https://www.sparkfun.com/products/9836).
    The breakout board incorporates the ADXL345 digital accelerometer sensor from
    Analog Devices and provides support for both the SPI and I²C buses. In this case,
    we will only use the I²C bus.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The power supplied to the breakout board should be between 2.0VDC and 3.6VDC,
    and therefore, we must use the power pin labeled **3V3** as the power supply to
    make sure we supply 3.3V and we never supply **5V** to the breakout board.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to use a Seeedstudio Grove 3-axis digital accelerometer
    to work with this example. The following URL provides detailed information about
    this module: [http://www.seeedstudio.com/depot/Grove-3Axis-Digital-Accelerometer16g-p-1156.html](http://www.seeedstudio.com/depot/Grove-3Axis-Digital-Accelerometer16g-p-1156.html).
    If you use this module, you can use either the power pin labeled **3V3** or **5V**
    as the power supply because the breakout board is capable of working with voltage
    supplies from 3V to 5V. The full sensing range is the same than the SparkFun breakout
    board and both use the same accelerometer sensor. The wirings are compatible for
    both modules.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Seeedstudio Grove 3-axis digital accelerometer is prepared to use cables
    to plug it into a Grove base shield. The Grove base shield is a board that you
    can plug in your Intel Galileo Gen 2 board and provides digital, analog and I²C
    ports that you can use with the appropriate cables to easily wire Grove sensors
    to the underlying Intel Galileo Gen 2 board. In our examples, we won''t be using
    the Grove base shield and we will continue to use wirings to connect each different
    sensor. However, you will achieve the same results if you decide to use the Grove
    base shield in combination with Grove sensors. Other Grove sensors that we will
    use in the next examples will also be prepared to work with the Grove base shield.
    The latest version of the Grove base shield is V2 and you can gather more information
    about it in the following URL: [http://www.seeedstudio.com/depot/Base-Shield-V2-p-1378.html](http://www.seeedstudio.com/depot/Base-Shield-V2-p-1378.html)'
  prefs: []
  type: TYPE_NORMAL
- en: The following diagram shows a Seeedstudio Grove 3-axis digital accelerometer
    breakout ADXL345, the necessary wirings and the wirings from the Intel Galileo
    Gen 2 board to the breadboard. The Fritzing file for the sample is `iot_fritzing_chapter_07_02.fzz`
    and the following picture is the breadboard view.
  prefs: []
  type: TYPE_NORMAL
- en: '![Wiring a digital accelerometer to the I2C bus](img/B05042_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The following picture shows the schematic with the electronic components represented
    as symbols.
  prefs: []
  type: TYPE_NORMAL
- en: '![Wiring a digital accelerometer to the I2C bus](img/B05042_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As seen in the previous schematic, we have the following connections:'
  prefs: []
  type: TYPE_NORMAL
- en: The **SDA** pin is connected to the accelerometer pin labeled **SDA**. This
    way, we connect the digital accelerometer to the serial data line for the I²C
    bus. The **SDA** pin in the Intel Galileo Gen 2 board is connected to the analog
    input pin labeled **A4**, and therefore, the board's symbol uses the **A4/SDA**
    label. The pin labeled **SDA** is in a different location than the pin labeled
    **A4**, but they are internally connected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **SCL** pin is connected to the accelerometer pin labeled **SCL**. This
    way, we connect the digital accelerometer to the serial clock line for the I²C
    bus. The **SCL** pin in the Intel Galileo Gen 2 board is connected to the analog
    input pin labeled **A5**, and therefore, the board's symbol uses the **A5/SCL**
    label. The pin labeled **SCL** is in a different location than the pin labeled
    **A5**, but they are internally connected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The power pin labeled **5V** is connected to the accelerometer power pin labeled
    **VCC**. In case you work with the SparkFun triple axis accelerometer breakout
    ADXL345, the power pin labeled **3V3** is connected to the accelerometer power
    pin labeled **VCC**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ground pin labeled **GND** is connected to the accelerometer ground pin
    labeled **GND**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, it is time make all the necessary wirings. Don't forget to shutdown the
    Yocto Linux, wait for all the onboard LEDs to turn off, and unplug the power supply
    from the Intel Galileo Gen 2 board before adding or removing any wire from the
    board's pins. As you did with the analog accelerometer, make sure you use large
    wires to allow you to move the accelerometer breakout board in different directions
    without accidentally unplugging cables.
  prefs: []
  type: TYPE_NORMAL
- en: Measuring three axis acceleration with a digital accelerometer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `upm` library includes support for the three axis digital accelerometer
    breakout board ADXL345 in the `pyupm_adxl345` module. The `Adxl345` class declared
    in this module represents a three axis digital accelerometer based on the ADXL345
    sensor, connected to our board. The class makes it easy to initialize the sensor,
    update and retrieve the acceleration values for the three axis through the I²C
    bus. The class works with the `mraa.I²C` class under the hoods to talk with the
    sensor, that is, to write data to and read data from the ADXL345 sensor that acts
    as a slave device connected to the I²C bus.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unluckily, each module in the `upm` library doesn't follow the same naming conventions
    we should expect for Python code. For example, in our previous example, that class
    name was `ADXL335`, with capital letters, while in this example the class name
    is `Adxl345`.
  prefs: []
  type: TYPE_NORMAL
- en: We will create a new version of the `Accelerometer` class to represent the accelerometer
    and make it easier for us to retrieve the acceleration values without worrying
    about specific methods and arrays when working with an instance of the `Adxl345`
    class. We will use the `Adxl345` class to interact with the accelerometer. The
    following lines show the code for the new `Accelerometer` class that works with
    the `upm` library, specifically with the `pyupm_adxl345` module. The code file
    for the sample is `iot_python_chapter_07_02.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We have to specify the I²C bus number to which the digital accelerometer is
    wired when we create an instance of the `Accelerometer` class in the `bus` required
    argument. The constructor, that is, the `__init__` method, creates a new `upmAdxl345.Adxl345`
    instance with the received `bus` argument and saves its reference in the `accelerometer`
    attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `upmAdxl345.Adxl345` instance requires working with an array of floating
    point pointers to retrieve the acceleration values for the three axis. We want
    to work with easy to understand attributes, and therefore, the constructor creates
    and initializes three attributes with `0.0`: `x_acceleration`, `y_acceleration`,
    and `z_acceleration`. After the constructor is executed, we have an initialized
    digital accelerometer ready to retrieve acceleration values for the three axis:
    *x*, *y* and *z*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The class defines a `measure_acceleration` method that updates the acceleration
    values for the three axes in the sensor, retrieves these acceleration values from
    the sensor, and finally saves them in the following three attributes: `x_acceleration`,
    `y_acceleration` and `z_acceleration`. The acceleration values are expressed in
    g-force (`g`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the code within the `measure_acceleration` method calls the `update`
    method for `self.accelerometer` to request the sensor to update the read values.
    Then, the code calls the `getAcceleration` method for `self.accelerometer` to
    retrieve the acceleration values for the three axis and saves the returned array
    in the `acceleration_array` local variable. The first element in the array has
    the acceleration value for x, the second for y and the third for z. Thus, the
    code updates the following three attributes with the values in the `acceleration_array`
    array: `x_acceleration`, `y_acceleration`, and `z_acceleration`. This way, we
    can easily access each acceleration value by accessing the appropriate attribute
    instead of working with elements of an array that might lead to confusion.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will write a loop that will run a calibration, retrieve and display
    the acceleration values for the three axis expressed in g-force (`g`) every 500
    milliseconds, that is, twice per second. The code file for the sample is `iot_python_chapter_07_02.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The first line creates an instance of the previously coded `Accelerometer` class
    with `0` as the values of the `bus` argument. The `mraa.I2c` class identifies
    the I²C bus to which we wired the accelerometer with number `0`. This way, the
    instance will establish a communication with the digital accelerometer through
    the I²C bus. The Intel Galileo Gen 2 board is the master in the bus and the digital
    accelerometer, as any other device connected to this bus, acts as a slave.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the code runs a loop forever that calls `measure_acceleration` method
    to update the acceleration values and then prints them, expressed in g-force (g).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following line will start the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'After you run the example, perform the same actions done with the previous
    example. As a result of these actions, you will see the different acceleration
    values measured for the three axis. The following lines show some sample output
    lines generated when we make small movements with the breakout board:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Using the I²C bus to control a digital accelerometer with the mraa library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, the features included in the `upm` library for a specific sensor
    do not include all of its possible usages and configurations. An example of this
    situation is the `upmAdxl345.Adxl345` class that we used in our previous example.
    This class doesn''t allow us to configure the desired scale for the accelerometer
    while the sensor supports the following four selectable measurement ranges: ±2g,
    ±4g, ±8g and ±16g. If we want to use specific features that aren''t included in
    the `upm` module, we can use the appropriate `mraa` class to interact with the
    sensor, in this case, we can use `mraa.I2c` to control the digital accelerometer
    through the I²C bus.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the C++ source code for the upm module as a baseline to write our
    own Python code that controls the accelerometer through the I²C bus using the
    `mraa.I2c` class. The C++ source code file is `adxl1345.cxx` and it can be found
    in the following GitHub URL: [http://github.com/intel-iot-devkit/upm/blob/master/src/adxl345/adxl345.cxx](http://github.com/intel-iot-devkit/upm/blob/master/src/adxl345/adxl345.cxx).
    As we use the C++ source code as a baseline, we will use the same naming convention
    (capital letters) for the constants declared with `#define`, but we will convert
    them into class attributes.'
  prefs: []
  type: TYPE_NORMAL
- en: The following lines show the code for the new `Adxl1345` class that works with
    an instance of the `mraa.I2c` class to communicate with the digital accelerometer.
    The code file for the sample is `iot_python_chapter_07_03.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: First, the class declares many constants that make it easier for us to understand
    the code that interacts with the accelerometer through the I²C bus. For example,
    the `ADXL345_I2C_ADDR` constant specifies the address for the ADXL345 accelerometer
    in the I²C bus, which is 53 in hexadecimal (`0x53`). If we just see a `0x53` within
    the code, we don't understand that it is an I²C bus address for the sensor. We
    imported all the constants defined in the C++ version so that we have all the
    necessary values in case we want to add additional features not included in the
    initial version. The datasheet provided by the manufacturer provides the necessary
    details to know the addresses for each register and the way in which the commands
    work in the I²C bus.
  prefs: []
  type: TYPE_NORMAL
- en: We have to specify the I²C bus number to which the digital accelerometer is
    wired when we create an instance of the `Adxl345` class in the `bus` required
    argument. The constructor, that is, the `__init__` method, creates a new `mraa.I2c`
    instance with the received `bus` argument and saves its reference in the `i2c`
    attribute.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Before performing any read or write operation in the I²C bus, it is a good practice
    to call the `address` method for the `mraa.I2c` instance to indicate the slave
    device to which we want to talk to. In this case, the address for the slave device
    is specified in the `ADXL345_I2C_ADDR` constant.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the code builds a message by creating a `bytearray` with the two hexadecimal
    values that we want to write to the slave: `ADXL345_POWER_CTL` and `ADXL345_POWER_ON`.
    We can read the message as `write turn on to the power control register`. The
    call to the `write` method for the `mraa.I2c` instance with this message will
    turn on the accelerometer.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We declared the following constants related to resolutions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ADXL345_FULL_RES`: Work with full resolution, where resolution increases with
    the g range up to 13-bit resolution'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ADXL345_10BIT`: Work with a fixed 10-bit resolution'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We declared the following constants related to scales:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ADXL345_2G`: Sets the g range to ±2g'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ADXL345_4G`: Sets the g range to ±4g'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ADXL345_8G`: Sets the g range to ±8g'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ADXL345_16G`: Sets the g range to ±16g'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code makes another call to the `address` method for the `mraa.I2c` instance
    before it makes another write to configure the desired resolution and scale for
    the sensor. The code builds another message by creating a `bytearray` with the
    two hexadecimal values that we want to write to the slave: `ADXL345_DATA_FORMAT`
    and the result of applying a bitwise or operator (`|`) for `ADXL345_16G` and `ADXL345_FULL_RES`.
    We can read the message as `write ±16g + full resolution to the data format register`.
    It is necessary to combine the desired resolution and the range in a single byte
    value, and therefore, we have to use the bitwise or operator (`|`).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The call to the write method for the `mraa.I2c` instance with this message
    will configure the accelerometer to work with a ±16g range for g and with the
    full resolution. As we have access to this call, we can make changes to the code
    to change the desired resolution or the scale for our acceleration measures. For
    example, the following lines that compose the message will change the configuration
    to make the accelerometer work with a g range of ±4g:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the code declares offset attributes for x, y, and z that is necessary
    to convert the raw acceleration values retrieved from the accelerometer into the
    appropriate values expressed in g. We want to work with easy to understand attributes
    instead, and therefore, the constructor creates and initializes three attributes
    with `0.0`: `x_acceleration`, `y_acceleration`, and `z_acceleration`. Finally,
    the constructor calls the `update` method to retrieve the first values from the
    accelerometer.'
  prefs: []
  type: TYPE_NORMAL
- en: The `update` method makes a call to the `address` method for the `mraa.I2c`
    instance and then calls its `writeByte` method with `ADXL345_XOUT_L` as its argument,
    that is, the first data register that we want to read.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The accelerometer values are stored in six data registers. There are two bytes
    per axis: the low byte (eight least significant bits) and the high byte (eight
    most significant bits), and therefore, we can read the six bytes with a single
    I²C read operation, starting with the address of the first byte for the x axis.
    Then, we have to compose each pair of bytes into a single value. The call to the
    `read` method for the `mraa.I2c` instance passes the `DATA_REG_SIZE` constant
    as an argument to indicate that we want to read six bytes and the code saves the
    resulting `bytearray` in the `xyz_raw_acceleration` local variable.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the code combines the low bytes and the high bytes to compose a single
    value for each raw acceleration pair of bytes retrieved from the accelerometer
    and saves them in three local variables: `x_raw_acceleration`, `y_raw_acceleration`,
    and `z_raw_acceleration`. The code uses the binary left shift (`<<`) bitwise operator
    to move the high byte (the eight most significant bits) to the left by 8 places
    and make the new bits on the right-hand side zeros. Then, it applies a binary
    or (`|`) to build the entire word (two bytes). The `x_raw_acceleration` value
    is the result of joining the high byte and the low byte to compose a word of two
    bytes.'
  prefs: []
  type: TYPE_NORMAL
- en: The first element in the `xyz_raw_acceleration` array (`xyz_raw_acceleration[0]`)
    includes the low byte for the x raw acceleration and the second element in the
    `xyz_raw_acceleration` array (`xyz_raw_acceleration[1]`) includes the high byte
    for the x raw acceleration. Thus, it is necessary to add 8 binary zeros to the
    high byte (`xyz_raw_acceleration[1]`) and replace those eight zeros with the low
    byte (`xyz_raw_acceleration[0]`). The same has to be done for the y and z raw
    acceleration bytes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, it is necessary to multiply each value by the offsets defined in the
    constructor to obtain the appropriate values for x, y, and z expressed in g and
    save them in the three attributes: `x_acceleration`, `y_acceleration`, and `z_acceleration`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have a class that represents the ADXL345 accelerometer entirely written
    in Python and we can make any necessary changes to make different configurations
    for the accelerometer.
  prefs: []
  type: TYPE_NORMAL
- en: We just need to create a new version of the `Accelerometer` class to use the
    recently created `Adxl345` class instead of the `pyupm_adxl345.Adxl345` class.
    The following lines show the code for the new `Accelerometer` class. The code
    file for the sample is `iot_python_chapter_07_03.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can use the same code that we have in the previous example for the `__main__`
    method and perform the same operations to check the values retrieved from the
    accelerometer.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Writing code that interacts with the I²C bus and a specific sensor requires
    a big effort because we have to read the detailed specifications from the manufacturer's
    datasheet. Sometimes, we won't be able to use all the features included in a sensor
    if we don't write our own code. In other cases, the features included in the `upm`
    library will be enough for our projects.
  prefs: []
  type: TYPE_NORMAL
- en: Wiring an analog temperature sensor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 6](ch06.html "Chapter 6. Working with Analog Inputs and Local Storage"),
    *Working with Analog Inputs and Local Storage*, we used a photoresistor included
    in a voltage divider and we connected it to an analog input pin. We can use a
    similar configuration and replace the photoresistor with a thermistor to measure
    ambient temperature. A thermistor changes its resistance value with temperature,
    and therefore, we can convert resistance changes into voltage value changes.
  prefs: []
  type: TYPE_NORMAL
- en: We can also work with an analog sensor breakout board that includes a thermistor
    in the necessary configuration to provide us with voltage levels to an analog
    pin that represent temperature values. In this case, we will work with an analog
    temperature sensor supported in the `upm` library to measure ambient temperature.
  prefs: []
  type: TYPE_NORMAL
- en: We will use the the analog pin labeled **A0** to connect the voltage output
    of an analog accelerometer breakout board. After we finish the necessary wirings,
    we will write Python code to measure and display the ambient temperature in both
    degrees Celsius (ºC) and degrees Fahrenheit (ºF). This way, we will read the result
    of converting an analog value to its digital representation and we will map it
    to the temperature value in the appropriate measurement unit.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need a Seeedstudio Grove temperature sensor to work with this example. The
    following URL provides detailed information about this module: [http://www.seeedstudio.com/depot/Grove-Temperature-Sensor-p-774.html](http://www.seeedstudio.com/depot/Grove-Temperature-Sensor-p-774.html).
    The following diagram shows the sensor breakout board, the necessary wirings,
    and the wirings from the Intel Galileo Gen 2 board to the breadboard. The Fritzing
    file for the sample is `iot_fritzing_chapter_07_04.fzz` and the following picture
    is the breadboard view. Don''t forget that you can also decide to use the Grove
    base shield to plug this sensor to the Intel Galileo Gen 2 board.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Wiring an analog temperature sensor](img/B05042_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following picture shows the schematic with the electronic components represented
    as symbols:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Wiring an analog temperature sensor](img/B05042_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As seen in the previous schematic, we have the following connections:'
  prefs: []
  type: TYPE_NORMAL
- en: The analog input pin labeled **A0** is connected to the temperature output pin
    labeled **SIG** (**0** in the breakout board's symbol)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The power pin labeled **3V3** is connected to the temperature sensor power pin
    labeled **VCC**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ground pin labeled **GND** is connected to the temperature sensor ground
    pin labeled **GND**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, it is time make all the necessary wirings. Don't forget to shutdown the
    Yocto Linux, wait for all the onboard LEDs to turn off, and unplug the power supply
    from the Intel Galileo Gen 2 board before adding or removing any wire from the
    board's pins.
  prefs: []
  type: TYPE_NORMAL
- en: Measuring ambient temperature with an analog sensor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `upm` library includes support for the Grove analog temperature sensor breakout
    board in the `pyupm_grove` module. The `GroveTemp` class declared in this module
    represents the analog temperature sensor connected to our board. The class makes
    it easy to retrieve the raw values read from the analog input into values expressed
    in degrees Celsius (ºC).
  prefs: []
  type: TYPE_NORMAL
- en: We will create a new `TemperatureSensor` class to represent the temperature
    sensor and make it easier for us to retrieve the ambient temperature values without
    worrying about unit conversions that are necessary when working with an instance
    of the `GroveTemp` class. We will use the `GroveTemp` class to interact with the
    analog temperature sensor. The following lines show the code for the new `TemperatureSensor`
    class that works with the `upm` library, specifically with the `pyupm_grove` module.
    The code file for the sample is `iot_python_chapter_07_04.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We have to specify the analog pin to which the sensor is connected when we
    create an instance of the `TemperatureSensor` class in the `analog_pin` required
    arguments. The constructor, that is, the `__init__` method, creates a new `upmGrove.GroveTemp`
    instance with the received `analog_pin` argument and saves its reference in the
    `temperature_sensor` attribute. Finally, the constructor instance creates and
    initializes two attributes with `0.0`: `temperature_celsius`, and `temperature_fahrenheit`.'
  prefs: []
  type: TYPE_NORMAL
- en: The class defines the `measure_temperature` method that retrieves the current
    ambient temperature measured in degrees Celsius (ºC) by calling the value method
    for `self.temperature_sensor` and saves the value in the `temperature_celsius`
    local variable. The next line assigns the value to the `temperature_celsius` attribute.
    Finally, the code assigns the result of converting the the temperature measured
    in degrees Celsius (ºC) to the equivalent value in degrees Fahrenheit (ºF). The
    formula is easy to read because it is just necessary to multiply the temperature
    measured in degrees Celsius (ºC) by 9, divide the result by 5 and sum 32\. This
    way the `TemperatureSensor` class updates two attributes with the ambient temperature
    measured by the sensor in degrees Celsius (ºC) and degrees Fahrenheit (ºF).
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will write a loop that will retrieve and display the ambient temperature
    in degrees Celsius (ºC) and degrees Fahrenheit (ºF), every 10 seconds. The code
    file for the sample is `iot_python_chapter_07_04.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The first line creates an instance of the previously coded `TemperatureSensor`
    class with `0` as the values of the `analog_pin` argument. This way, the instance
    will read the analog values from the pin labeled **A0**. Then, the code runs a
    loop forever that calls the `measure_temperature` method to update the ambient
    temperature values and then prints them, expressed in degrees Celsius (ºC) and
    degrees Fahrenheit (ºF).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following line will start the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'After you run the example, turn on an air conditioner or a heating system to
    generate a change in the ambient temperature and you will see how the measured
    temperature changes after a few minutes. The following lines show some a sample
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Wiring a digital temperature and humidity sensor to the I²C bus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we will use a multifunctional digital sensor that will provide us with
    temperature and relative humidity information. We will use a breakout board that
    uses the I²C bus to allow the Intel Galileo Gen 2 board to communicate with the
    sensor. The sensor is useful when we don't need to measure temperature and humidity
    in extreme conditions. We cannot use this sensor at the top of Mount Etna, just
    in case we work in a research project related to volcanoes.
  prefs: []
  type: TYPE_NORMAL
- en: We will use the two pins labeled **SDA** and **SCL** to connect the data and
    clock lines of the I²C bus to the corresponding pins in the digital temperature
    and humidity breakout board. After we finish the necessary wirings, we will write
    a Python code to measure, display the ambient temperature, and the relative humidity.
    This way, we will read the result of sending commands to the sensor through the
    I²C bus, reading the responses, and decoding them into the ambient temperature
    and the relative humidity expressed in the appropriate units.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need a SeeedStudio Grove temperature & humidity sensor (high-accuracy &
    mini) breakout to work with this example. The following URL provides detailed
    information about this breakout board: [http://www.seeedstudio.com/depot/Grove-TemperatureHumidity-Sensor-HighAccuracy-Mini-p-1921.html](http://www.seeedstudio.com/depot/Grove-TemperatureHumidity-Sensor-HighAccuracy-Mini-p-1921.html).
    The breakout board incorporates the TH02 digital humidity and temperature sensor
    and provides support for both the I²C bus.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the digital temperature, humidity breakout, the
    necessary wirings, and the wirings from the Intel Galileo Gen 2 board to the breadboard.
    The Fritzing file for the sample is `iot_fritzing_chapter_07_05.fzz` and the following
    picture is the breadboard view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Wiring a digital temperature and humidity sensor to the I2C bus](img/B05042_07_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following picture shows the schematic with the electronic components represented
    as symbols:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Wiring a digital temperature and humidity sensor to the I2C bus](img/B05042_07_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As seen in the previous schematic, we have the following connections:'
  prefs: []
  type: TYPE_NORMAL
- en: The **SDA** pin is connected to the breakout board pin labeled **SDA**. This
    way, we connect the digital temperature and humidity sensor to the serial data
    line for the I²C bus.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **SCL** pin is connected to the breakout board pin labeled **SCL**. This
    way, we connect the digital temperature and humidity sensor to the serial clock
    line for the I²C bus.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The power pin labeled **3V3** is connected to the breakout board power pin labeled
    **VCC**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ground pin labeled **GND** is connected to the breakout board ground pin
    labeled **GND**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, it is time make all the necessary wirings. Don't forget to shutdown the
    Yocto Linux, wait for all the onboard LEDs to turn off, and unplug the power supply
    from the Intel Galileo Gen 2 board before adding or removing any wire from the
    board's pins.
  prefs: []
  type: TYPE_NORMAL
- en: Measuring temperature and humidity with a digital sensor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `upm` library includes support for the digital temperature and humidity
    breakout board that uses the TH02 sensor in the `pyupm_th02` module. The `TH02`
    class declared in this module represents a digital temperature and humidity sensor
    that uses the TH02 sensor, connected to our board. The class makes it easy to
    initialize the sensor and retrieve the temperature and humidity values through
    the I²C bus. The class works with the `mraa.I2c` class under the hoods to talk
    with the sensor, that is, to write data to and read data from the TH02 sensor
    that acts as a slave device connected to the I²C bus.
  prefs: []
  type: TYPE_NORMAL
- en: We will create a new `TemperatureAndHumiditySensor` class to represent the temperature
    and humidity sensor and make it easier for us to retrieve the temperature and
    humidity values in the appropriate units working with an instance of the `TH02`
    class. We will use the `TH02` class to interact with the sensor. The following
    lines show the code for the new `TemperatureSensor` class that works with the
    `upm` library, specifically with the `pyupm_th02` module. The code file for the
    sample is `iot_python_chapter_07_05.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We have to specify the I²C bus number to which the digital temperature and humidity
    sensor is wired when we create an instance of the `TemperatureAndHumiditySensor`
    class in the `bus` required argument. The constructor, that is, the `__init__`
    method, creates a new `upmTh02.TH02` instance with the received `bus` argument
    and saves its reference in the `th02_sensor` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The datasheet for the TH02 sensor specifies a formula to convert the raw read
    temperature to degrees Celsius (ºC), and therefore, by reading the datasheet we
    might think the `upmTh02.TH02` instance will provide us a value in degrees Fahrenheit
    (ºF). However, this is not what happens. The `upmTh02.TH02` instance performs
    the conversion from degrees Fahrenheit (ºF) to degrees Celsius (ºC) and provides
    us a value in the latter unit of measure. Thus, if we want to display the value
    in degrees Fahrenheit (ºF), we must perform the conversion from degrees Celsius
    (ºC) to degrees Fahrenheit (ºF). Unluckily, the only way of realizing about this
    situation is by looking at the C++ source code for the `upm` module because there
    is no documentation about the unit of measure that the code uses to return the
    temperature value.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to work with easy to understand attributes, and therefore, the constructor
    creates and initializes three attributes with `0.0`: `temperature_celsius`, `temperature_fahrenheit`,
    and `humidity`. After the constructor is executed, we have an initialized digital
    temperature and humidity sensor ready to retrieve values.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The class defines a `measure_temperature_and_humidity` method that updates
    the ambient temperature and humidity values in the sensor, retrieves these values,
    and finally saves them in the following three attributes: `temperature_celsius`,
    `temperature_fahrenheit`, and `humidity`.'
  prefs: []
  type: TYPE_NORMAL
- en: First, the code within the `measure_temperature_and_humidity` method calls the
    `getTemperature` method for `self.th02_sensor` to request the sensor to retrieve
    the temperature value. The method returns the read value converted to degrees
    Celsius (ºC) and the code saves it in the `temperature_celsius` local variable.
    The code saves the value in the attribute with the same name and saves the value
    converted to degrees Fahrenheit (ºF) in the `temperature_fahrenheit` attribute.
    Finally, the code calls the `getHumidity` method for `self.th02_sensor` to request
    the sensor to retrieve the humidity value and saves it in the `humidity` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will write a loop that will retrieve and display the temperature values
    expressed in degrees Celsius (ºC) and degrees Fahrenheit, and the humidity value,
    every 10 seconds. The code file for the sample is `iot_python_chapter_07_05.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The first line creates an instance of the previously coded `TemperatureAndHumiditySensor`
    class with `0` as the value of the `bus` argument. This way, the instance will
    establish a communication with the digital accelerometer through the I²C bus.
    As happened in our previous example with a sensor connected to the I²C bus, the
    Intel Galileo Gen 2 board is the master in the bus and the digital temperature
    and humidity sensor, acts as a slave.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the code runs a loop forever that calls the `measure_temperature_and_humidity`
    method to update the temperature values expressed in two units and the humidity.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following line will start the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: After you run the example, turn on an air conditioner or a heating system, to
    generate a change in the ambient temperature and humidity.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which of the following sensors allows us to measure the magnitude and direction
    of proper acceleration?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A temperature sensor.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: An accelerometer.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A light sensor.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Which of the following acronym that defines a connection type for a module
    with a sensor is analog:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: AIO.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: I2C.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: UART.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'How many wires do we need to connect a device to the I²C bus:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 1`.`
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 2`.`
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 3`.`
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'How many wires do we need to connect a device to the SPI bus:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 1`.`
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 2`.`
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 3`.`
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Which of the following is not a connection of the I²C bus:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: MISO.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: SDA.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: SCL.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about sensors and their connection types. We understood
    that it is necessary to consider many important things when choosing sensors and
    that they make it easy for us to measure different variables from the real world.
    We learned the importance of considering the units of measure because sensors
    always provide values measured in a specific unit that we must consider.
  prefs: []
  type: TYPE_NORMAL
- en: We wrote code that took advantage of the modules and classes included in the
    `upm` library that made it easier for us to start working with analog and digital
    sensors. In addition, we wrote code that interacted with a digital accelerometer
    through the I²C bus because we wanted to be able to take advantage of additional
    features provided by the sensor but not included in the `upm` library module.
  prefs: []
  type: TYPE_NORMAL
- en: We measured the magnitude and direction of proper acceleration or g-force, ambient
    temperature and humidity. As in the previous chapters, we continued taking advantage
    of Python's object-oriented features and we created classes to encapsulate sensors
    and the necessary configurations with the `upm` and `mraa` libraries. Our code
    is easy to read and understand and we can easily hide the low-level details.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are able to retrieve data from the real world with sensors, we will
    make our IoT device perform actions with different actuators and shields, which
    is the topic of the next chapter.
  prefs: []
  type: TYPE_NORMAL
