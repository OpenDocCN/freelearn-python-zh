- en: Chapter 7. Retrieving Data from the Real World with Sensors
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章. 使用传感器从现实世界获取数据
- en: 'In this chapter, we will work with a variety of sensors to retrieve data from
    the real world. We will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将与各种传感器一起工作，以从现实世界获取数据。我们将涵盖以下主题：
- en: Understanding sensors and their connection types
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解传感器及其连接类型
- en: Learn the most important things we must consider when choosing sensors
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习在选择传感器时必须考虑的最重要事项
- en: Take advantage of the `upm` library with many different sensors
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用`upm`库与多种不同的传感器一起工作
- en: Measure the magnitude and direction of proper acceleration or g-force with an
    accelerometer
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用加速度计测量适当的加速度或g力的幅度和方向
- en: Work with a three axis analog accelerometer
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用三轴模拟加速度计
- en: Use a digital accelerometer that works with the I²C bus
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用与I²C总线兼容的数字加速度计
- en: Work with the `mraa` library and the I²C bus to control a digital accelerometer
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`mraa`库和I²C总线控制数字加速度计
- en: Measure ambient temperature with an analog sensor
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模拟传感器测量环境温度
- en: Use a digital temperature and humidity sensor that works with the I²C bus
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用与I²C总线兼容的数字温度和湿度传感器
- en: Understanding sensors and their connection types
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解传感器及其连接类型
- en: In [Chapter 6](ch06.html "Chapter 6. Working with Analog Inputs and Local Storage"),
    *Working with Analog Inputs and Local Storage*, we used a photoresistor that is
    included in a voltage divider and we connected it to an analog input pin. We were
    able to measure the ambient light and we determined different darkness levels
    and change the brightness levels of an RGB LED. The photoresistor, also known
    as **LDR** (short for **Light-Dependent Resistor**) or photocell, is a sensor.
    We just needed to include it in a voltage divider to make the changes in the resistance
    value of the photoresistor via the ambient light. These variations in the resistance
    value will generate changes in the voltage value in our analog pin. Thus, we worked
    with a configuration of electronic components that generated an analog sensor,
    capable of transforming changes in the environment light into voltage values.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](ch06.html "第6章. 使用模拟输入和本地存储")，*使用模拟输入和本地存储*，我们使用了一个包含在分压器中的光敏电阻，并将其连接到模拟输入引脚。我们能够测量环境光，并确定不同的暗度级别，并改变RGB
    LED的亮度级别。光敏电阻，也称为**LDR**（**Light-Dependent Resistor**的缩写）或光电池，是一种传感器。我们只需要将其包含在分压器中，就可以通过环境光改变光敏电阻的电阻值。这些电阻值的变动将在我们的模拟引脚中产生电压值的变动。因此，我们与一个电子组件配置一起工作，该配置生成一个模拟传感器，能够将环境光的变动转换为电压值。
- en: There are a huge number of sensors that allow us to retrieve data from the real
    world and convert it into analog or digital values that we can collect with the
    different communications ports included in the Intel Galileo Gen 2 board and process
    with Python and different libraries. When we worked with the photoresistor to
    measure the environment light, we wired the configuration to an analog pin and
    we worked with the `mraa` library and then the `wiring-x86` library to take advantage
    of the analog to digital converter to retrieve the values.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 有大量的传感器使我们能够从现实世界获取数据并将其转换为我们可以通过Intel Galileo Gen 2板上的不同通信端口收集的模拟或数字值，并用Python和不同的库进行处理。当我们使用光敏电阻来测量环境光时，我们将配置连接到模拟引脚，并使用`mraa`库然后是`wiring-x86`库来利用模数转换器来获取值。
- en: In [Chapter 2](ch02.html "Chapter 2. Working with Python on Intel Galileo Gen
    2"), *Working with Python on Intel Galileo Gen 2*, we installed the latest available
    version of the `upm` library. This library provides high level interfaces for
    sensors and actuators. Whenever we work with a sensor, it is usually convenient
    to check whether the `upm` library includes support for it because the high level
    interface can save us a lot of time and make it easier for us to start retrieving
    the values from the sensor and perform the necessary conversions to the different
    measuring units.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html "第2章. 在Intel Galileo Gen 2上使用Python")，*在Intel Galileo Gen 2上使用Python*，我们安装了最新可用的`upm`库。这个库为传感器和执行器提供了高级接口。每次我们与传感器一起工作时，通常都方便检查`upm`库是否支持它，因为高级接口可以为我们节省大量时间，并使我们从传感器获取值以及进行必要的单位转换变得更加容易。
- en: In this chapter, we will take advantage of the `upm` library with many different
    sensors. However, we must take into account that sometimes the features included
    in the `upm` library for a specific sensor might not be enough and we might need
    to write our own low level code to interact with the sensor with either the `mraa`
    or the `wiring-x86` library. As we will analyze later, depending on the connection
    type, only the `mraa` will provide us with all the necessary features when the
    sensor is not supported in the `upm` library.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将利用具有许多不同传感器的`upm`库。然而，我们必须考虑到，有时`upm`库中为特定传感器提供的功能可能不足以满足需求，我们可能需要编写自己的底层代码，使用`mraa`或`wiring-x86`库与传感器进行交互。正如我们稍后将要分析的，根据连接类型，当传感器在`upm`库中不受支持时，只有`mraa`会为我们提供所有必要的功能。
- en: 'Obviously, the first thing that we must consider when selecting a sensor is
    what we want to measure, for example, temperature. However, that is not the only
    thing we have to consider to select a specific sensor. When we select sensors,
    we must take into account their features, their measurement range, their precision
    and their connection types, among other things. The following list enumerates
    the most important things we must consider and their explanation:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，在选择传感器时，我们必须首先考虑我们想要测量的内容，例如温度。然而，这并不是我们选择特定传感器时唯一需要考虑的因素。当我们选择传感器时，我们必须考虑它们的功能、测量范围、精度以及连接类型等众多因素。以下列表列举了我们必须考虑的最重要的因素及其解释：
- en: '**Compatibility with Intel Galileo Gen 2 board and the voltage supply that
    we are using (5V or 3.3V)**: Sometimes, we have to wire more than one sensor to
    the board, and therefore, it is important to check whether all the sensors we
    are selecting can work with the voltage configuration we have for the board. Some
    sensors are only capable to work with the board if we have a specific setting.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与英特尔Galileo Gen 2板和我们所使用的电压供应（5V或3.3V）的兼容性**：有时，我们必须将多个传感器连接到板上，因此检查我们选择的传感器是否都能与板上的电压配置兼容是很重要的。一些传感器只有在我们有特定设置的情况下才能与板一起工作。'
- en: '**Power consumption**: We must take into account that some sensors have different
    working modes. For example, some sensors have a high performance mode that requires
    more power than a normal mode. As we might work with more than one sensor wired
    to the board, it is also important to consider the overall power consumption with
    all the sensors connected to the board and in the modes in which we will use them.
    In addition, some sensors switch to power saving modes when we don''t use them.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**功耗**：我们必须考虑到一些传感器具有不同的工作模式。例如，一些传感器具有高性能模式，需要比正常模式更多的电力。由于我们可能会将多个传感器连接到板上，因此考虑所有传感器连接到板上并使用我们将在其中使用的模式时的整体功耗也很重要。此外，一些传感器在我们不使用它们时，会切换到省电模式。'
- en: '**Connection type**: We need to answer a few questions in order to decide the
    most convenient connection type. Do we have the necessary connections, communications
    or interface ports? Are they available? Do the connection type and the distance
    we need have any impact on the accuracy for the measured values? In addition,
    when we select the first sensor for our board, all the connections might be available,
    but the situation changes as we add more sensors and it can force the decision
    to select a sensor with a different connection type. Let''s consider the following
    situation, we are already measuring ambient light in 6 different positions. We
    have 6 photoresistors connected with 6 voltage divider configurations and wired
    to the 6 available analog input pins, and therefore, we don''t have additional
    analog pins available. If we have to add a temperature sensor, we cannot add an
    analog sensor that requires an analog input pin because all of them are wired
    to the light sensors. In this case, we have to use a digital temperature sensor
    that we can wire to either the I²C or the SPI buses. Another option is to use
    a digital temperature sensor that we can wire to the UART port. We will dive deep
    on the different connection types for the sensors later.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**连接类型**：为了决定最方便的连接类型，我们需要回答几个问题。我们是否有必要的连接、通信或接口端口？它们是否可用？连接类型和我们需要的距离是否会影响测量值的准确性？此外，当我们为我们的板选择第一个传感器时，所有连接可能都是可用的，但随着我们添加更多传感器，情况会发生变化，这可能会迫使选择具有不同连接类型的传感器。让我们考虑以下情况，我们已经在6个不同的位置测量环境光线。我们有6个光电电阻，通过6个分压器配置连接，并连接到6个可用的模拟输入引脚，因此我们没有额外的模拟引脚可用。如果我们必须添加温度传感器，我们不能添加需要模拟输入引脚的模拟传感器，因为它们都已经连接到光线传感器。在这种情况下，我们必须使用可以连接到I²C或SPI总线的数字温度传感器。另一个选择是使用可以连接到UART端口的数字温度传感器。我们将在稍后深入探讨传感器的不同连接类型。'
- en: '**Measurement ranges**: The specifications for the sensors indicate their measurement
    ranges. For example, a temperature sensor measuring ambient temperature can have
    a measurement range of -40ºF to 185ºF (equivalent to -40ºC to 85ºC). In case we
    need to measure ambient temperatures that can reach 90ºC, we have to select a
    temperature sensor with a higher upper range. For example, another sensor that
    measuring ambient temperature provides a measurement range of -40ºF to 257ºF (equivalent
    to -40ºC to 125ºC) will be suitable for this job.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测量范围**：传感器的规格表明了它们的测量范围。例如，测量环境温度的温度传感器可以有一个测量范围从-40ºF到185ºF（相当于-40ºC到85ºC）。如果我们需要测量可以达到90ºC的环境温度，我们必须选择一个具有更高上限范围的温度传感器。例如，另一个测量环境温度的传感器提供的测量范围是-40ºF到257ºF（相当于-40ºC到125ºC），将适合这项工作。'
- en: '**Sensitivity and precision**: Each sensor is sensitive and might offer different
    configurable precision levels. We have to make sure the accuracy provided by the
    sensor is compatible with our needs. As the measured value changes, it is important
    to consider the sensitivity, also known as measurement resolution. For example,
    if we have to measure temperature and we must be able to determine changes of
    at least 2ºF or 1ºC based on the unit of measure we are using, we have to make
    sure that the sensor is capable providing the required sensitivity.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灵敏度和精度**：每个传感器都是灵敏的，可能提供不同的可配置精度级别。我们必须确保传感器提供的精度符合我们的需求。随着测量值的改变，考虑灵敏度，也称为测量分辨率，是很重要的。例如，如果我们必须测量温度，并且必须能够根据我们使用的单位确定至少2ºF或1ºC的变化，我们必须确保传感器能够提供所需灵敏度。'
- en: Tip
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: When we start the process of selecting the appropriate sensor, it is very important
    to pay attention to the units of measure when we analyze measurement ranges, sensitivity
    and precision. A typical example is a temperature sensor that can express the
    values in either degrees Celsius (ºC) or degrees Fahrenheit (ºF).
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们开始选择合适的传感器时，分析测量范围、灵敏度和精度时注意单位非常重要。一个典型的例子是温度传感器，它可以以摄氏度（ºC）或华氏度（ºF）来表示数值。
- en: '**Latency**: It is very important to determine how much can we wait for the
    sensor to gather a new value and whether it is capable of providing us with a
    real new value in this amount of time. When the measure value changes in the real
    environment or object that we are measuring, the sensor takes some time to be
    able to provide us with the new measured value. Sometimes, they are microseconds
    but in other cases, they can be milliseconds or even seconds. It depends on the
    sensor and we have to take it into account when selecting the appropriate sensor
    for our project. For example, we might need a temperature sensor to allow us to
    measure 2 temperature values per second, and therefore, we must work with a sensor
    with a latency lower than 500 milliseconds (0.5 seconds) to achieve our goal.
    Specifically, we can select a temperature sensor with a latency of 200 milliseconds.
    Unluckily, sometimes we have to dive deep on the datasheets to check the latency
    value for some sensors and the electronic components that it uses.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**延迟**: 确定我们能够等待传感器收集新值的时间以及它是否能够在这么短的时间内提供真实的新值非常重要。当我们在真实环境或测量对象中测量的测量值发生变化时，传感器需要一些时间才能提供新的测量值。有时，这些可能是微秒，但在其他情况下，它们可以是毫秒甚至秒。这取决于传感器，我们在选择适合我们项目的传感器时必须考虑这一点。例如，我们可能需要一个温度传感器，每秒允许我们测量2个温度值，因此，我们必须与延迟低于500毫秒（0.5秒）的传感器合作以达到我们的目标。具体来说，我们可以选择延迟为200毫秒的温度传感器。不幸的是，有时我们必须深入研究数据表来检查某些传感器及其使用的电子组件的延迟值。'
- en: '**Operating range and special environment requirements**: It is very important
    to consider the operating range for the sensor. Sometimes, the sensors have to
    work in specific environment conditions that might not be suitable for all of
    the available sensors. The following are some examples of rough environment requirements:
    high shock survivability, water resistance, extremely high temperatures, and very
    high humidity levels.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工作范围和特殊环境要求**: 考虑传感器的工作范围非常重要。有时，传感器必须在工作于特定环境条件下，而这些条件可能不适合所有可用的传感器。以下是一些粗略的环境要求示例：高抗冲击性、防水、极高温度和非常高的湿度水平。'
- en: '**Dimensions**: Sensors come with different dimensions. Sometimes only specific
    dimensions are suitable for our project.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**尺寸**: 传感器具有不同的尺寸。有时只有特定的尺寸适合我们的项目。'
- en: '**Protocol, support in the upm library and Python bindings**: We will end up
    processing the data retrieved from the sensor with Python code, and therefore,
    it is very important to make sure that we can work with the sensor in Python.
    In some cases, we don''t want to write low-level code and we want to make sure
    that the sensor is supported in the `upm` library. In other cases, we have to
    make sure that we have the necessary Python libraries to work with the protocols
    that some digital sensors use. For example, many temperature sensors that work
    with the UART port use the MODBUS serial communications protocol. If they aren''t
    supported in the `upm` library, we have to work with specific Python libraries
    to establish communications using the MODBUS serial communications protocol and
    it might require additional work on our side in case we don''t have previous experience
    with this protocol.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**协议、upm库的支持和Python绑定**: 我们最终将使用Python代码处理从传感器获取的数据，因此，确保我们可以在Python中使用传感器非常重要。在某些情况下，我们不希望编写底层代码，并确保传感器在`upm`库中得到支持。在其他情况下，我们必须确保我们有必要的Python库来处理某些数字传感器使用的协议。例如，许多使用UART端口的温度传感器使用MODBUS串行通信协议。如果它们在`upm`库中没有得到支持，我们必须使用特定的Python库来通过MODBUS串行通信协议建立通信，这可能需要我们在没有先前使用此协议的经验的情况下进行额外的工作。'
- en: '**Cost**: Obviously, we have to take into account the sensor''s cost. Perhaps
    the best sensor that complies with all our requirements is extremely expensive
    and we might decide to use another sensor with less features or less precision
    but with a lower cost. We have a huge number of cheap sensors with impressive
    features that are compatible with the Intel Galileo Gen 2 board. However, we always
    have to take into account how much each sensor costs to select it according to
    our needs and our budget.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**成本**: 显然，我们必须考虑传感器的成本。可能符合我们所有要求的最佳传感器非常昂贵，我们可能决定使用功能较少或精度较低但成本较低的另一种传感器。我们有大量具有令人印象深刻的功能且与英特尔Galileo
    Gen 2板兼容的廉价传感器。然而，我们始终必须考虑每个传感器的成本，以便根据我们的需求和预算进行选择。'
- en: 'The sensors or modules that include sensors that we can wire to an Intel Galileo
    Gen 2 board can use the following connection types. The list enumerates the acronym
    that manufacturers usually use to describe the connection type for the modules
    and their explanation:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将传感器或模块连接到英特尔 Galileo Gen 2 板上，可以使用以下连接类型。列表列出了制造商通常用来描述模块连接类型的缩写及其解释：
- en: '**AIO**: The module requires one or more analog input pins. The sensors that
    require analog input pins are known as analog sensors.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AIO**：该模块需要一个或多个模拟输入引脚。需要模拟输入引脚的传感器被称为模拟传感器。'
- en: '**GPIO**: The module requires one or more GPIO pins.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GPIO**：该模块需要一个或多个 GPIO 引脚。'
- en: '**I²C**: The module requires two wires to connect to the two I²C bus lines:
    **SCL** (short for **S**erial **CL**ock) and **SDA** (short for **S**erial **DA**ta).
    We can connect many devices to this bus as long as each of them have a different
    I²C address.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**I²C**：该模块需要两根线连接到两个 I²C 总线线：**SCL**（代表 **S**erial **CL**ock）和 **SDA**（代表
    **S**erial **DA**ta）。只要每个设备都有一个不同的 I²C 地址，我们就可以将许多设备连接到这个总线。'
- en: '**SPI**: The module requires three wires to connect to the three SPI bus lines:
    **MISO** (short for **Master In Slave Out**), **MOSI** (short for **Master Out
    Slave In**) and **SCK** (short for **Serial Clock**).'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SPI**：该模块需要三根线连接到三个 SPI 总线线：**MISO**（代表 **Master In Slave Out**）、**MOSI**（代表
    **Master Out Slave In**）和 **SCK**（代表 **Serial Clock**）。'
- en: '**UART**: The module works with a serial connection (RX/TX), and therefore,
    requires two wires to connect to the two pins for the UART port: **TX->1** and
    **RX<-0**. An **UART** port stands for **Universal Asynchronous Receiver/Transmitter**.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UART**：该模块使用串行连接（RX/TX），因此需要两根线连接到 UART 端口的两个引脚：**TX->1** 和 **RX<-0**。**UART**
    端口代表 **通用异步接收/发送器**。'
- en: The modules that work with the I²C bus, the SPI bus or an UART port are known
    as **digital sensors** because they use a digital interface. Some modules combine
    one of the buses or an UART port with GPIO pins.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 与 I²C 总线、SPI 总线或 UART 端口一起工作的模块被称为 **数字传感器**，因为它们使用数字接口。一些模块将其中一个总线或 UART 端口与
    GPIO 引脚结合使用。
- en: We already worked with analog inputs and the analog to digital converter with
    both the `mraa` and `wiring-x86` libraries. We also worked with GPIO pins configured
    as input pins with these libraries. However, we still didn't work with the I²C
    bus, the SPI bus or the UART ports.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用 `mraa` 和 `wiring-x86` 库处理了模拟输入和模拟数字转换器。我们还使用这些库处理了配置为输入引脚的 GPIO 引脚。然而，我们还没有处理
    I²C 总线、SPI 总线或 UART 端口。
- en: 'The `mraa` library provides the following classes that allow us to work with
    the previously mentioned serial buses and the UART ports:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`mraa` 库提供了以下类，允许我们与之前提到的串行总线和 UART 端口一起工作：'
- en: '`mraa.I2c`: The class represents an I²C bus master device (the board) that
    can talk to multiple I²C bus slave devices by selecting their address. It is possible
    to create many instances of this class to interact with many slave devices. The
    class allows us to write data to and read data from slave devices connected to
    the I²C bus.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mraa.I2c`：该类表示一个 I²C 总线主设备（板），可以通过选择它们的地址与多个 I²C 总线从设备进行通信。我们可以创建许多此类实例来与多个从设备进行交互。该类允许我们将数据写入和从连接到
    I²C 总线的从设备读取数据。'
- en: '`Mraa.Spi`: The class represents an SPI bus and its chip select. The class
    allows us to write data to and read data from devices connected to the SPI bus.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Mraa.Spi`：该类表示 SPI 总线和其芯片选择。该类允许我们将数据写入和从连接到 SPI 总线的设备读取数据。'
- en: '`mraa.UART`: The class represents an UART port and allow us to configure, send
    data to and receive data from an UART port.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mraa.UART`：该类表示 UART 端口，并允许我们配置、向 UART 端口发送数据并从 UART 端口接收数据。'
- en: Tip
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: We can use the previously explained classes provided by the `mraa` library to
    interact with any of the digital modules. However, this would require us to spend
    some time reading the datasheets for the modules, understanding their working
    modes, writing code that writes data to and reads data from the appropriate bus
    or UART port. Each module has its own API and we have to compose requests and
    process responses through the serial buses or the UART port.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用之前解释过的由 `mraa` 库提供的类来与任何数字模块进行交互。然而，这需要我们花一些时间阅读模块的数据表，了解它们的工作模式，编写代码将数据写入和从适当的总线或
    UART 端口读取。每个模块都有自己的 API，我们必须通过串行总线或 UART 端口来组合请求和处理响应。
- en: First, we will take advantage of the `upm` library for each of the modules.
    In a few cases, we will also use the appropriate classes in the `mraa` library
    to understand how to interact with the sensors with a lower level interface. This
    way, in case we have to work with a module that isn't supported in the `upm` library,
    we can analyze the information provided in the datasheets and write code to interact
    with the module.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将利用每个模块的`upm`库。在少数情况下，我们还将使用`mraa`库中的适当类来了解如何使用低级接口与传感器交互。这样，如果我们必须与`upm`库不支持模块一起工作，我们可以分析数据表提供的信息，并编写代码与模块交互。
- en: Working with accelerometers
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与加速度计一起工作
- en: An accelerometer allows us to measure the magnitude and direction of proper
    acceleration or g-force. Tablets and smartphones use accelerometers to automatically
    switch between portrait and landscape modes depending on the direction in which
    we hold the device. In addition, the built-in accelerometer allows us to control
    apps by making small movements of different intensity with the device in the different
    directions.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 加速度计使我们能够测量加速度或g力的幅度和方向。平板电脑和智能手机使用加速度计根据我们握持设备的方向自动在纵向和横向模式之间切换。此外，内置的加速度计允许我们通过在设备的不同方向上用不同强度的微小动作来控制应用程序。
- en: An accelerometer allows us to detect how an object is oriented with respect
    to the Earth's surface by measuring acceleration due to gravity. In addition,
    an accelerometer is extremely useful when we want to detect when an object starts
    or stops moving. Accelerometers are also capable of detecting vibration and when
    an object is falling down.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 加速度计使我们能够通过测量由于重力产生的加速度来检测物体相对于地球表面的方向。此外，当我们想要检测物体开始或停止移动时，加速度计非常有用。加速度计还能够检测振动和物体下落。
- en: Tip
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Accelerometers usually measure proper acceleration in g-force, abbreviated with
    a `g`. It is important to avoid the confusion generated by the force word included
    in the name of the unit of measure because we are measuring proper acceleration
    and not a force. Some accelerometers use meters per second squared (m/s2) as their
    unit of measure instead of g-force.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 加速度计通常以g力为单位测量加速度，缩写为`g`。重要的是要避免由单位名称中包含的力这个词引起的混淆，因为我们测量的是加速度而不是力。一些加速度计使用每秒平方米（m/s²）作为它们的测量单位而不是g力。
- en: Nowadays, most accelerometers are capable of measuring acceleration in three
    axes and are known as 3-axis accelerometers or triple axis accelerometers. A 3-axis
    accelerometer can measure acceleration for the *x*, *y* and *z* axis. If we want
    to measure small accelerations or vibrations, it will be more convenient to work
    with a small range 3-axis accelerometer because they provide the necessary sensitivity.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，大多数加速度计能够测量三个轴的加速度，被称为三轴加速度计或三轴加速度计。一个三轴加速度计可以测量*x*、*y*和*z*轴的加速度。如果我们想测量小的加速度或振动，使用小范围的三轴加速度计会更方便，因为它们提供了必要的灵敏度。
- en: Wiring an analog accelerometer to the analog input pins
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将模拟加速度计连接到模拟输入引脚
- en: The easiest way to understand how an accelerometer works is to use it in a simple
    example. Now, we will work with an analog 3-axis accelerometer with a full sensing
    range from -3g to +3g. This kind of accelerometer requires three analog input
    pins, one for each measured axes. The accelerometer supplies voltage levels based
    on the measured acceleration for each axes.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 理解加速度计工作原理的最简单方法是在一个简单的例子中使用它。现在，我们将使用一个具有从-3g到+3g的全量程传感范围的模拟三轴加速度计。这种加速度计需要三个模拟输入引脚，每个测量轴一个。加速度计根据每个轴测量的加速度提供电压级别。
- en: 'We will use the three analog pins labeled **A0**, **A1** and **A2** to connect
    the positive voltage outputs of an analog accelerometer breakout board. After
    we finish the necessary wirings, we will write Python code to measure and display
    the acceleration for the three axis: x, y and z. This way, we will read the result
    of converting an analog value to its digital representation and we will map it
    to the acceleration value.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用标记为**A0**、**A1**和**A2**的三个模拟引脚来连接模拟加速度计断开板的正电压输出。完成必要的布线后，我们将编写Python代码来测量和显示三个轴（x、y和z）的加速度。这样，我们将读取将模拟值转换为其数字表示的结果，并将其映射到加速度值。
- en: 'We need a SparkFun triple axis accelerometer breakout ADXL335 to work with
    this example. The following URL provides detailed information about this breakout
    board: [https://www.sparkfun.com/products/9269](https://www.sparkfun.com/products/9269).
    The breakout board incorporates the ADXL335 accelerometer sensor from Analog Devices.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个SparkFun三轴加速度计扩展板ADXL335来与这个示例一起使用。以下URL提供了有关此扩展板的详细信息：[https://www.sparkfun.com/products/9269](https://www.sparkfun.com/products/9269)。该扩展板集成了来自Analog
    Devices的ADXL335加速度计传感器。
- en: Tip
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The power supplied to the breakout board should be between 1.8VDC and 3.6VDC,
    and therefore, we will use the power pin labeled **3V3** as the power supply to
    make sure we supply 3.3V and we never supply **5V** to the breakout board.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 供应给扩展板的电源应在1.8VDC至3.6VDC之间，因此我们将使用标记为**3V3**的电源引脚作为电源，以确保我们提供3.3V，并且我们永远不会向扩展板提供**5V**。
- en: 'It is also possible to use a Seeedstudio Grove 3-axis analog accelerometer
    to work with this example. The following URL provides detailed information about
    this module: [http://www.seeedstudio.com/depot/Grove-3Axis-Analog-Accelerometer-p-1086.html](http://www.seeedstudio.com/depot/Grove-3Axis-Analog-Accelerometer-p-1086.html).
    If you use this module, you can use either the power pin labeled **3V3** or **5V**
    as the power supply because the breakout board is capable of working with voltage
    supplies from 3V to 5V. The full sensing range is the same than the SparkFun breakout
    board and both use the same accelerometer sensor. The wirings are compatible for
    both modules.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用Seeedstudio Grove 3轴模拟加速度计与这个示例一起工作。以下URL提供了有关此模块的详细信息：[http://www.seeedstudio.com/depot/Grove-3Axis-Analog-Accelerometer-p-1086.html](http://www.seeedstudio.com/depot/Grove-3Axis-Analog-Accelerometer-p-1086.html)。如果您使用此模块，您可以使用标记为**3V3**或**5V**的电源引脚作为电源，因为扩展板能够与3V至5V的电压供应一起工作。全量程与SparkFun扩展板相同，并且两者使用相同的加速度计传感器。布线对两个模块都是兼容的。
- en: 'The following diagram shows a SparkFun triple axis accelerometer breakout ADXL335,
    the necessary wirings and the wirings from the Intel Galileo Gen 2 board to the
    breadboard. The Fritzing file for the sample is `iot_fritzing_chapter_07_01.fzz`
    and the following picture is the breadboard view:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示显示了SparkFun三轴加速度计扩展板ADXL335、必要的布线以及从Intel Galileo Gen 2板到面包板的布线。示例的Fritzing文件为`iot_fritzing_chapter_07_01.fzz`，以下图片是面包板视图：
- en: '![Wiring an analog accelerometer to the analog input pins](img/B05042_07_01.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![将模拟加速度计布线到模拟输入引脚](img/B05042_07_01.jpg)'
- en: 'The following picture shows the schematic with the electronic components represented
    as symbols:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图片显示了用电子元件表示的符号的原理图：
- en: '![Wiring an analog accelerometer to the analog input pins](img/B05042_07_02.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![将模拟加速度计布线到模拟输入引脚](img/B05042_07_02.jpg)'
- en: 'As seen in the previous schematic, we have the following connections:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，我们有以下连接：
- en: The analog input pin labeled **A0** is connected to the accelerometer output
    pin labeled **X** (**XOUT** in the breakout board's symbol)
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记为**A0**的模拟输入引脚连接到标记为**X**（在扩展板符号中为**XOUT**）的加速度计输出引脚
- en: The analog input pin labeled **A1** is connected to the accelerometer output
    pin labeled **Y** (**YOUT** in the breakout board's symbol)
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记为**A1**的模拟输入引脚连接到标记为**Y**（在扩展板符号中为**YOUT**）的加速度计输出引脚
- en: The analog input pin labeled **A2** is connected to the accelerometer output
    pin labeled **Z** (**ZOUT** in the breakout board's symbol)
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记为**A2**的模拟输入引脚连接到标记为**Z**（在扩展板符号中为**ZOUT**）的加速度计输出引脚
- en: The power pin labeled **3V3** is connected to the accelerometer power pin labeled
    **VCC**
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记为**3V3**的电源引脚连接到标记为**VCC**的加速度计电源引脚
- en: The ground pin labeled **GND** is connected to the accelerometer ground pin
    labeled **GND**
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记为**GND**的接地引脚连接到标记为**GND**的加速度计接地引脚
- en: Now, it is time make all the necessary wirings. Don't forget to shutdown the
    Yocto Linux, wait for all the onboard LEDs to turn off, and unplug the power supply
    from the Intel Galileo Gen 2 board before adding or removing any wire from the
    board's pins. Make sure you use large wires to allow you to move the accelerometer
    breakout board in different directions without accidentally unplugging cables.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候进行所有必要的布线了。在添加或移除任何线从板上的引脚之前，不要忘记关闭Yocto Linux，等待所有板载LED熄灭，并从Intel Galileo
    Gen 2板上拔掉电源供应。确保你使用粗线，这样你就可以在不意外拔掉电缆的情况下将加速度计扩展板移动到不同的方向。
- en: Measuring three axis acceleration with an analog accelerometer
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模拟加速度计测量三轴加速度
- en: The `upm` library includes support for the three axis analog accelerometer breakout
    board in the `pyupm_adxl335` module. The `ADXL335` class declared in this module
    represents a three axis analog accelerometer connected to our board. The class
    makes it easy to calibrate the accelerometer and convert the raw values read from
    the analog inputs into values expressed in the `g` unit.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`upm` 库在 `pyupm_adxl335` 模块中包括对三个轴模拟加速度计扩展板的支撑。在此模块中声明的 `ADXL335` 类代表连接到我们板上的三个轴模拟加速度计。该类使得校准加速度计并将从模拟输入读取的原始值转换为以
    `g` 单位表示的值变得容易。'
- en: We will create a new `Accelerometer` class to represent the accelerometer and
    make it easier for us to retrieve the acceleration values without worrying about
    type conversion that are necessary when working with an instance of the `ADXL335`
    class. We will use the `ADXL335` class to interact with the accelerometer. The
    following lines show the code for the new `Accelerometer` class that works with
    the `upm` library, specifically with the `pyupm_adxl335` module. The code file
    for the sample is `iot_python_chapter_07_01.py`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个新的 `Accelerometer` 类来表示加速度计，并使我们能够更容易地检索加速度值，而无需担心与 `ADXL335` 类的实例一起工作时必要的类型转换。我们将使用
    `ADXL335` 类与加速度计交互。以下行显示了与 `upm` 库（特别是 `pyupm_adxl335` 模块）一起工作的新 `Accelerometer`
    类的代码。示例代码文件为 `iot_python_chapter_07_01.py`。
- en: '[PRE0]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We have to specify the analog pin numbers to which each axes pin is connected
    when we create an instance of the `Accelerometer` class in the `pinX`, `pinY`,
    and `pinZ` required arguments. The constructor, that is, the `__init__` method,
    creates a new `upmAdxl335.ADXL335` instance with the received `pinX`, `pinY`,
    and `pinZ` arguments and saves its reference in the `accelerometer` attribute.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建 `Accelerometer` 类的实例时，我们必须指定每个轴引脚连接到的模拟引脚编号，所需的 `pinX`、`pinY` 和 `pinZ` 参数。构造函数，即
    `__init__` 方法，使用接收到的 `pinX`、`pinY` 和 `pinZ` 参数创建一个新的 `upmAdxl335.ADXL335` 实例，并将其引用保存到
    `accelerometer` 属性中。
- en: The `upmAdxl335.ADXL335` instance requires working with floating point pointers
    to retrieve the acceleration values for the three axis. Thus, the constructor
    saves the three objects of type `float *` (float pointers) in the following three
    attributes by calling `upmAdxl335.new_floatPointer()`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`upmAdxl335.ADXL335` 实例需要使用浮点指针来检索三个轴的加速度值。因此，构造函数通过调用 `upmAdxl335.new_floatPointer()`
    将三个 `float *` 类型（浮点指针）的对象保存到以下三个属性中。'
- en: '`x_acceleration_fp`'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x_acceleration_fp`'
- en: '`y_acceleration_fp`'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`y_acceleration_fp`'
- en: '`z_acceleration_fp`'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`z_acceleration_fp`'
- en: 'Finally, the constructor creates and initializes three attributes with `0.0`:
    `x_acceleration`, `y_acceleration` and `z_acceleration`. After the constructor
    is executed, we must calibrate the accelerometer and then, we will be ready to
    retrieve acceleration values for the three axis: *x*, *y* and *z*.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，构造函数创建并初始化三个属性为 `0.0`：`x_acceleration`、`y_acceleration` 和 `z_acceleration`。构造函数执行后，我们必须校准加速度计，然后，我们将准备好检索三个轴的加速度值：*x*、*y*
    和 *z*。
- en: 'The class defines the following two methods:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 该类定义了以下两个方法：
- en: '`calibrate`: Calls the calibrate method for `self.accelerometer` to calibrate
    the analog accelerometer.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`calibrate`：调用 `self.accelerometer` 的校准方法来校准模拟加速度计。'
- en: '`measure_acceleration`: Retrieves the acceleration values for the three axis
    and saves them in the following three attributes: `x_acceleration`, `y_acceleration`
    and `z_acceleration`. The acceleration values are expressed in g-force (`g`).
    First, the code calls the `acceleration` method for `self.accelerometer` with
    the three objects of type `float *` as arguments. The method reads the raw values
    retrieved from the three analog pins, converts them to the appropriate values
    in g-force (g) and changes the floating point values for the objects of type `float*`
    received as arguments with the updated values. Then, the code calls the `upmAdxl335.floatPointer_value`
    method to retrieve the floating point values from the objects of type `float*`
    and update the three attributes: `x_acceleration`, `y_acceleration` and `z_acceleration`.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`measure_acceleration`：检索三个轴的加速度值并将它们保存到以下三个属性中：`x_acceleration`、`y_acceleration`
    和 `z_acceleration`。加速度值以重力加速度（g）表示。首先，代码调用 `self.accelerometer` 的 `acceleration`
    方法，并将三个 `float *` 类型的对象作为参数。该方法读取从三个模拟引脚获取的原始值，将它们转换为适当的重力加速度（g）值，并使用更新后的值更改接收到的
    `float*` 类型对象的浮点值。然后，代码调用 `upmAdxl335.floatPointer_value` 方法从 `float*` 类型的对象中检索浮点值，并更新三个属性：`x_acceleration`、`y_acceleration`
    和 `z_acceleration`。'
- en: Now, we will write a loop that will run a calibration, retrieve and display
    the acceleration values for the three axis expressed in g-force (`g`) every 500
    milliseconds, that is, twice per second. The code file for the sample is `iot_python_chapter_07_01.py`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写一个循环，该循环将运行校准，每500毫秒检索并显示三个轴的加速度值（以g力表示），即每秒两次。示例的代码文件为`iot_python_chapter_07_01.py`。
- en: '[PRE1]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first line creates an instance of the previously coded `Accelerometer` class
    with `0`, `1` and `2` as the values of the `pinX`, `pinY` and `pinZ` arguments.
    This way, the instance will read the analog values from the pins labeled **A0**,
    **A1** and **A2**. Then, the code calls the `calibrate` method for the `Accelerometer`
    instance to calibrate the analog accelerometer.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行创建了一个之前编写的`Accelerometer`类的实例，其中`pinX`、`pinY`和`pinZ`的值分别为`0`、`1`和`2`。这样，实例将从标有**A0**、**A1**和**A2**的引脚读取模拟值。然后，代码调用`Accelerometer`实例的`calibrate`方法来校准模拟加速度计。
- en: Tip
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The calibration measures the *x*, *y* and *z* axis values while the sensor is
    still, and then, the sensor uses these values as the zero values, that is, as
    a baseline. The default sensitivity for this analog sensor is 0.25V/g.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 校准测量传感器静止时的*x*、*y*和*z*轴值，然后，传感器使用这些值作为零值，即作为基线。此模拟传感器的默认灵敏度是0.25V/g。
- en: Then, the code runs a loop forever, that is, until you interrupt the execution
    by pressing *Ctrl* + *C* or the button to stop the process, in case you are using
    a Python IDE with remote development features to run the code in your board. The
    loop calls the `measure_acceleration` method to update the acceleration values
    and then prints them, expressed in g-force (g).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，代码将无限循环运行，即直到你通过按*Ctrl* + *C*或停止按钮中断执行，如果你使用具有远程开发功能的Python IDE来在板上运行代码。循环调用`measure_acceleration`方法来更新加速度值，然后以g力（g）的形式打印它们。
- en: The following line will start the example. Don't forget that you need to transfer
    the Python source code file to the Yocto Linux with an SFTP client. Before you
    start the example, make sure that the accelerometer breakout board is located
    on stable surface that doesn't vibrate. This way, the calibration will work OK.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行将启动示例。别忘了你需要使用SFTP客户端将Python源代码文件传输到Yocto Linux。在开始示例之前，请确保加速度计扩展板位于稳定且不震动的表面上。这样，校准才能正常工作。
- en: '[PRE2]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After you run the example, perform the following actions:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 运行示例后，执行以下操作：
- en: Make small movements to the accelerometer breakout board in different directions
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以不同的方向对加速度计扩展板进行小幅度移动
- en: Make large movements to the accelerometer breakout board in specific directions
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在特定方向上对加速度计扩展板进行大幅度移动
- en: Leave the accelerometer breakout board on a stable surface that doesn't vibrate
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将加速度计扩展板放置在稳定且不震动的表面上
- en: 'As a result of the previous actions, you will see the different acceleration
    values measured for the three axis. The following lines show some sample output
    lines generated when we make large movements with the breakout board:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 由于之前的操作，你将看到三个轴测量的不同加速度值。以下行显示了当我们对扩展板进行大幅度移动时生成的某些示例输出行：
- en: '[PRE3]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Wiring a digital accelerometer to the I²C bus
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数字加速度计连接到I²C总线
- en: Digital accelerometers usually provide a better precision, higher resolution
    and more sensitivity than analog accelerometers. Now, we will work with a digital
    3-axis accelerometer with a full sensing range from -16g to +16g. We will use
    a breakout board that uses the I²C bus to allow the board to communicate with
    the accelerometer.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 数字加速度计通常比模拟加速度计提供更好的精度、更高的分辨率和更高的灵敏度。现在，我们将使用一个从-16g到+16g的全量程数字3轴加速度计。我们将使用一个使用I²C总线来允许板与加速度计通信的扩展板。
- en: 'We will use the two pins labeled **SDA** and **SCL** to connect the data and
    clock lines of the I²C bus to the corresponding pins in the digital accelerometer
    breakout board. After we finish the necessary wirings, we will write Python code
    to measure and display the acceleration for the three axis: *x*, *y* and *z*.
    This way, we will read the result of sending commands to the accelerometer through
    the I²C bus, reading the responses and decoding them into the appropriate acceleration
    values expressed in g-force (`g`).'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用标有**SDA**和**SCL**的两个引脚将I²C总线的数据线和时钟线连接到数字加速度计扩展板上的相应引脚。完成必要的布线后，我们将编写Python代码来测量和显示三个轴（*x*、*y*和*z*）的加速度。这样，我们将读取通过I²C总线发送到加速度计的命令的结果，读取响应并将它们解码为以g力（`g`）表示的适当的加速度值。
- en: 'We need a SparkFun triple axis accelerometer breakout ADXL345 to work with
    this example. The following URL provides detailed information about this breakout
    board: [https://www.sparkfun.com/products/9836](https://www.sparkfun.com/products/9836).
    The breakout board incorporates the ADXL345 digital accelerometer sensor from
    Analog Devices and provides support for both the SPI and I²C buses. In this case,
    we will only use the I²C bus.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要SparkFun三轴加速度计扩展板ADXL345来与这个示例一起工作。以下网址提供了关于此扩展板的详细信息：[https://www.sparkfun.com/products/9836](https://www.sparkfun.com/products/9836)。该扩展板集成了来自Analog
    Devices的ADXL345数字加速度计传感器，并为SPI和I²C总线提供支持。在这种情况下，我们将仅使用I²C总线。
- en: Tip
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The power supplied to the breakout board should be between 2.0VDC and 3.6VDC,
    and therefore, we must use the power pin labeled **3V3** as the power supply to
    make sure we supply 3.3V and we never supply **5V** to the breakout board.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 供应给扩展板的电源应在2.0VDC至3.6VDC之间，因此，我们必须使用标有**3V3**的电源引脚作为电源，以确保我们提供3.3V，并且我们永远不会向扩展板提供**5V**。
- en: 'It is also possible to use a Seeedstudio Grove 3-axis digital accelerometer
    to work with this example. The following URL provides detailed information about
    this module: [http://www.seeedstudio.com/depot/Grove-3Axis-Digital-Accelerometer16g-p-1156.html](http://www.seeedstudio.com/depot/Grove-3Axis-Digital-Accelerometer16g-p-1156.html).
    If you use this module, you can use either the power pin labeled **3V3** or **5V**
    as the power supply because the breakout board is capable of working with voltage
    supplies from 3V to 5V. The full sensing range is the same than the SparkFun breakout
    board and both use the same accelerometer sensor. The wirings are compatible for
    both modules.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用Seeedstudio Grove 3轴数字加速度计与这个示例一起工作。以下网址提供了关于此模块的详细信息：[http://www.seeedstudio.com/depot/Grove-3Axis-Digital-Accelerometer16g-p-1156.html](http://www.seeedstudio.com/depot/Grove-3Axis-Digital-Accelerometer16g-p-1156.html)。如果您使用此模块，可以使用标有**3V3**或**5V**的电源引脚作为电源，因为扩展板能够与3V至5V的电压供应一起工作。全量程与SparkFun扩展板相同，并且两者都使用相同的加速度计传感器。这两款模块的布线是兼容的。
- en: Tip
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'The Seeedstudio Grove 3-axis digital accelerometer is prepared to use cables
    to plug it into a Grove base shield. The Grove base shield is a board that you
    can plug in your Intel Galileo Gen 2 board and provides digital, analog and I²C
    ports that you can use with the appropriate cables to easily wire Grove sensors
    to the underlying Intel Galileo Gen 2 board. In our examples, we won''t be using
    the Grove base shield and we will continue to use wirings to connect each different
    sensor. However, you will achieve the same results if you decide to use the Grove
    base shield in combination with Grove sensors. Other Grove sensors that we will
    use in the next examples will also be prepared to work with the Grove base shield.
    The latest version of the Grove base shield is V2 and you can gather more information
    about it in the following URL: [http://www.seeedstudio.com/depot/Base-Shield-V2-p-1378.html](http://www.seeedstudio.com/depot/Base-Shield-V2-p-1378.html)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Seeedstudio Grove 3轴数字加速度计已准备好使用电缆插入Grove底板。Grove底板是一块可以插入您的Intel Galileo Gen
    2板的板子，它提供了数字、模拟和I²C端口，您可以使用适当的电缆轻松地将Grove传感器连接到底层的Intel Galileo Gen 2板。在我们的示例中，我们不会使用Grove底板，我们将继续使用布线连接每个不同的传感器。但是，如果您决定使用Grove底板与Grove传感器结合使用，您将获得相同的结果。我们将在下一个示例中使用的其他Grove传感器也将准备好与Grove底板一起工作。Grove底板的最新版本是V2，您可以在以下网址中获取更多关于它的信息：[http://www.seeedstudio.com/depot/Base-Shield-V2-p-1378.html](http://www.seeedstudio.com/depot/Base-Shield-V2-p-1378.html)
- en: The following diagram shows a Seeedstudio Grove 3-axis digital accelerometer
    breakout ADXL345, the necessary wirings and the wirings from the Intel Galileo
    Gen 2 board to the breadboard. The Fritzing file for the sample is `iot_fritzing_chapter_07_02.fzz`
    and the following picture is the breadboard view.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示展示了Seeedstudio Grove 3轴数字加速度计扩展板ADXL345，必要的布线以及从Intel Galileo Gen 2板到面包板的布线。示例的Fritzing文件为`iot_fritzing_chapter_07_02.fzz`，以下图片是面包板视图。
- en: '![Wiring a digital accelerometer to the I2C bus](img/B05042_07_03.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![将数字加速度计连接到I2C总线](img/B05042_07_03.jpg)'
- en: The following picture shows the schematic with the electronic components represented
    as symbols.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图片显示了用符号表示电子组件的原理图。
- en: '![Wiring a digital accelerometer to the I2C bus](img/B05042_07_04.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![将数字加速度计连接到I2C总线](img/B05042_07_04.jpg)'
- en: 'As seen in the previous schematic, we have the following connections:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，我们有以下连接：
- en: The **SDA** pin is connected to the accelerometer pin labeled **SDA**. This
    way, we connect the digital accelerometer to the serial data line for the I²C
    bus. The **SDA** pin in the Intel Galileo Gen 2 board is connected to the analog
    input pin labeled **A4**, and therefore, the board's symbol uses the **A4/SDA**
    label. The pin labeled **SDA** is in a different location than the pin labeled
    **A4**, but they are internally connected.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SDA**引脚连接到标有**SDA**的加速度计引脚。这样，我们将数字加速度计连接到I²C总线的串行数据线。Intel Galileo Gen 2板上的**SDA**引脚连接到标有**A4**的模拟输入引脚，因此，板上的符号使用**A4/SDA**标签。标有**SDA**的引脚与标有**A4**的引脚位于不同的位置，但它们在内部是连接的。'
- en: The **SCL** pin is connected to the accelerometer pin labeled **SCL**. This
    way, we connect the digital accelerometer to the serial clock line for the I²C
    bus. The **SCL** pin in the Intel Galileo Gen 2 board is connected to the analog
    input pin labeled **A5**, and therefore, the board's symbol uses the **A5/SCL**
    label. The pin labeled **SCL** is in a different location than the pin labeled
    **A5**, but they are internally connected.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SCL**引脚连接到标有**SCL**的加速度计引脚。这样，我们将数字加速度计连接到I²C总线的串行时钟线。Intel Galileo Gen 2板上的**SCL**引脚连接到标有**A5**的模拟输入引脚，因此，板上的符号使用**A5/SCL**标签。标有**SCL**的引脚与标有**A5**的引脚位于不同的位置，但它们在内部是连接的。'
- en: The power pin labeled **5V** is connected to the accelerometer power pin labeled
    **VCC**. In case you work with the SparkFun triple axis accelerometer breakout
    ADXL345, the power pin labeled **3V3** is connected to the accelerometer power
    pin labeled **VCC**.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标有**5V**的电源引脚连接到标有**VCC**的加速度计电源引脚。如果你使用SparkFun三轴加速度计扩展板ADXL345，标有**3V3**的电源引脚连接到加速度计的电源引脚**VCC**。
- en: The ground pin labeled **GND** is connected to the accelerometer ground pin
    labeled **GND**.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标有**GND**的接地引脚连接到标有**GND**的加速度计接地引脚。
- en: Now, it is time make all the necessary wirings. Don't forget to shutdown the
    Yocto Linux, wait for all the onboard LEDs to turn off, and unplug the power supply
    from the Intel Galileo Gen 2 board before adding or removing any wire from the
    board's pins. As you did with the analog accelerometer, make sure you use large
    wires to allow you to move the accelerometer breakout board in different directions
    without accidentally unplugging cables.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候进行所有必要的接线了。不要忘记关闭Yocto Linux，等待所有板载LED熄灭，并在从板上的引脚添加或移除任何电线之前，从Intel Galileo
    Gen 2板上拔掉电源。就像你使用模拟加速度计时做的那样，确保你使用粗线，这样你就可以在不意外拔掉电缆的情况下将加速度计扩展板移动到不同的方向。
- en: Measuring three axis acceleration with a digital accelerometer
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用数字加速度计测量三个轴的加速度
- en: The `upm` library includes support for the three axis digital accelerometer
    breakout board ADXL345 in the `pyupm_adxl345` module. The `Adxl345` class declared
    in this module represents a three axis digital accelerometer based on the ADXL345
    sensor, connected to our board. The class makes it easy to initialize the sensor,
    update and retrieve the acceleration values for the three axis through the I²C
    bus. The class works with the `mraa.I²C` class under the hoods to talk with the
    sensor, that is, to write data to and read data from the ADXL345 sensor that acts
    as a slave device connected to the I²C bus.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`upm`库在`pyupm_adxl345`模块中包括了对三个轴数字加速度计扩展板ADXL345的支持。在此模块中声明的`Adxl345`类代表基于ADXL345传感器的三个轴数字加速度计，连接到我们的板上。该类使得初始化传感器、通过I²C总线更新和检索三个轴的加速度值变得容易。该类在幕后与`mraa.I²C`类一起工作，与传感器通信，即向ADXL345传感器写入数据并从中读取数据，该传感器作为连接到I²C总线的从设备。'
- en: Tip
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Unluckily, each module in the `upm` library doesn't follow the same naming conventions
    we should expect for Python code. For example, in our previous example, that class
    name was `ADXL335`, with capital letters, while in this example the class name
    is `Adxl345`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，`upm`库中的每个模块都不遵循我们应期望的Python代码的相同命名约定。例如，在我们之前的例子中，那个类名是`ADXL335`，使用大写字母，而在这个例子中，类名是`Adxl345`。
- en: We will create a new version of the `Accelerometer` class to represent the accelerometer
    and make it easier for us to retrieve the acceleration values without worrying
    about specific methods and arrays when working with an instance of the `Adxl345`
    class. We will use the `Adxl345` class to interact with the accelerometer. The
    following lines show the code for the new `Accelerometer` class that works with
    the `upm` library, specifically with the `pyupm_adxl345` module. The code file
    for the sample is `iot_python_chapter_07_02.py`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建`Accelerometer`类的新版本来表示加速度计，并使我们能够更容易地检索加速度值，而无需在处理`Adxl345`类的实例时担心特定的方法和数组。我们将使用`Adxl345`类与加速度计交互。以下行显示了与`upm`库一起工作的新`Accelerometer`类的代码，特别是与`pyupm_adxl345`模块一起工作。示例代码文件为`iot_python_chapter_07_02.py`。
- en: '[PRE4]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We have to specify the I²C bus number to which the digital accelerometer is
    wired when we create an instance of the `Accelerometer` class in the `bus` required
    argument. The constructor, that is, the `__init__` method, creates a new `upmAdxl345.Adxl345`
    instance with the received `bus` argument and saves its reference in the `accelerometer`
    attribute.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建`Accelerometer`类的实例时，我们需要指定数字加速度计连接的I²C总线编号，这需要在`bus`必需参数中指定。构造函数，即`__init__`方法，使用接收到的`bus`参数创建一个新的`upmAdxl345.Adxl345`实例，并将其引用保存在`accelerometer`属性中。
- en: 'The `upmAdxl345.Adxl345` instance requires working with an array of floating
    point pointers to retrieve the acceleration values for the three axis. We want
    to work with easy to understand attributes, and therefore, the constructor creates
    and initializes three attributes with `0.0`: `x_acceleration`, `y_acceleration`,
    and `z_acceleration`. After the constructor is executed, we have an initialized
    digital accelerometer ready to retrieve acceleration values for the three axis:
    *x*, *y* and *z*.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`upmAdxl345.Adxl345`实例需要与三个轴的加速度值检索的浮点指针数组一起工作。我们希望使用易于理解的属性，因此构造函数创建并初始化了三个属性，其值为`0.0`：`x_acceleration`、`y_acceleration`和`z_acceleration`。构造函数执行后，我们有一个初始化的数字加速度计，可以检索三个轴的加速度值：*x*、*y*和*z*。'
- en: 'The class defines a `measure_acceleration` method that updates the acceleration
    values for the three axes in the sensor, retrieves these acceleration values from
    the sensor, and finally saves them in the following three attributes: `x_acceleration`,
    `y_acceleration` and `z_acceleration`. The acceleration values are expressed in
    g-force (`g`).'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 该类定义了一个`measure_acceleration`方法，该方法更新传感器中三个轴的加速度值，从传感器检索这些加速度值，并将其最终保存在以下三个属性中：`x_acceleration`、`y_acceleration`和`z_acceleration`。加速度值以g力(`g`)表示。
- en: 'First, the code within the `measure_acceleration` method calls the `update`
    method for `self.accelerometer` to request the sensor to update the read values.
    Then, the code calls the `getAcceleration` method for `self.accelerometer` to
    retrieve the acceleration values for the three axis and saves the returned array
    in the `acceleration_array` local variable. The first element in the array has
    the acceleration value for x, the second for y and the third for z. Thus, the
    code updates the following three attributes with the values in the `acceleration_array`
    array: `x_acceleration`, `y_acceleration`, and `z_acceleration`. This way, we
    can easily access each acceleration value by accessing the appropriate attribute
    instead of working with elements of an array that might lead to confusion.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`measure_acceleration`方法内的代码调用`self.accelerometer`的`update`方法，请求传感器更新读取值。然后，代码调用`self.accelerometer`的`getAcceleration`方法，检索三个轴的加速度值，并将返回的数组保存在局部变量`acceleration_array`中。数组中的第一个元素包含x轴的加速度值，第二个为y轴，第三个为z轴。因此，代码使用`acceleration_array`数组中的值更新以下三个属性：`x_acceleration`、`y_acceleration`和`z_acceleration`。这样，我们可以通过访问适当的属性而不是处理可能导致混淆的数组元素来轻松访问每个加速度值。
- en: Now, we will write a loop that will run a calibration, retrieve and display
    the acceleration values for the three axis expressed in g-force (`g`) every 500
    milliseconds, that is, twice per second. The code file for the sample is `iot_python_chapter_07_02.py`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写一个循环，该循环将每500毫秒运行一次校准，检索并显示三个轴的加速度值（以g力`g`表示），即每秒两次。示例代码文件为`iot_python_chapter_07_02.py`。
- en: '[PRE5]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The first line creates an instance of the previously coded `Accelerometer` class
    with `0` as the values of the `bus` argument. The `mraa.I2c` class identifies
    the I²C bus to which we wired the accelerometer with number `0`. This way, the
    instance will establish a communication with the digital accelerometer through
    the I²C bus. The Intel Galileo Gen 2 board is the master in the bus and the digital
    accelerometer, as any other device connected to this bus, acts as a slave.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行创建了一个之前编写的`Accelerometer`类的实例，其中`bus`参数的值为`0`。`mraa.I2c`类识别出我们用编号`0`连接加速度计的I²C总线。这样，该实例将通过I²C总线与数字加速度计建立通信。英特尔Galileo
    Gen 2板是总线上的主设备，而数字加速度计，以及连接到该总线的任何其他设备，都充当从设备。
- en: Then, the code runs a loop forever that calls `measure_acceleration` method
    to update the acceleration values and then prints them, expressed in g-force (g).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，代码运行一个无限循环，调用`measure_acceleration`方法来更新加速度值，然后以g力（g）为单位打印它们。
- en: 'The following line will start the example:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行将开始示例：
- en: '[PRE6]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'After you run the example, perform the same actions done with the previous
    example. As a result of these actions, you will see the different acceleration
    values measured for the three axis. The following lines show some sample output
    lines generated when we make small movements with the breakout board:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行示例之后，执行与上一个示例中相同的操作。这些操作的结果，您将看到三个轴测量的不同加速度值。以下行展示了当我们用分线板进行小幅度移动时生成的某些示例输出行：
- en: '[PRE7]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Using the I²C bus to control a digital accelerometer with the mraa library
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用mraa库通过I²C总线控制数字加速度计
- en: 'Sometimes, the features included in the `upm` library for a specific sensor
    do not include all of its possible usages and configurations. An example of this
    situation is the `upmAdxl345.Adxl345` class that we used in our previous example.
    This class doesn''t allow us to configure the desired scale for the accelerometer
    while the sensor supports the following four selectable measurement ranges: ±2g,
    ±4g, ±8g and ±16g. If we want to use specific features that aren''t included in
    the `upm` module, we can use the appropriate `mraa` class to interact with the
    sensor, in this case, we can use `mraa.I2c` to control the digital accelerometer
    through the I²C bus.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，`upm`库中针对特定传感器的功能可能不包括其所有可能的用法和配置。我们之前示例中使用的`upmAdxl345.Adxl345`类就是这种情况的一个例子。此类不允许我们配置加速度计所需的比例，而传感器支持以下四个可选测量范围：±2g、±4g、±8g和±16g。如果我们想使用`upm`模块中未包含的特定功能，我们可以使用适当的`mraa`类与传感器交互，在这种情况下，我们可以使用`mraa.I2c`通过I²C总线控制数字加速度计。
- en: 'We will use the C++ source code for the upm module as a baseline to write our
    own Python code that controls the accelerometer through the I²C bus using the
    `mraa.I2c` class. The C++ source code file is `adxl1345.cxx` and it can be found
    in the following GitHub URL: [http://github.com/intel-iot-devkit/upm/blob/master/src/adxl345/adxl345.cxx](http://github.com/intel-iot-devkit/upm/blob/master/src/adxl345/adxl345.cxx).
    As we use the C++ source code as a baseline, we will use the same naming convention
    (capital letters) for the constants declared with `#define`, but we will convert
    them into class attributes.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用upm模块的C++源代码作为基准来编写我们自己的Python代码，该代码通过`mraa.I2c`类通过I²C总线控制加速度计。C++源代码文件是`adxl1345.cxx`，可以在以下GitHub
    URL中找到：[http://github.com/intel-iot-devkit/upm/blob/master/src/adxl345/adxl345.cxx](http://github.com/intel-iot-devkit/upm/blob/master/src/adxl345/adxl345.cxx)。由于我们使用C++源代码作为基准，我们将使用相同的命名约定（大写字母）来声明`#define`中的常量，但我们将它们转换为类属性。
- en: The following lines show the code for the new `Adxl1345` class that works with
    an instance of the `mraa.I2c` class to communicate with the digital accelerometer.
    The code file for the sample is `iot_python_chapter_07_03.py`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行展示了用于与`mraa.I2c`类实例通信以与数字加速度计交互的新`Adxl1345`类的代码。示例的代码文件为`iot_python_chapter_07_03.py`。
- en: '[PRE8]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: First, the class declares many constants that make it easier for us to understand
    the code that interacts with the accelerometer through the I²C bus. For example,
    the `ADXL345_I2C_ADDR` constant specifies the address for the ADXL345 accelerometer
    in the I²C bus, which is 53 in hexadecimal (`0x53`). If we just see a `0x53` within
    the code, we don't understand that it is an I²C bus address for the sensor. We
    imported all the constants defined in the C++ version so that we have all the
    necessary values in case we want to add additional features not included in the
    initial version. The datasheet provided by the manufacturer provides the necessary
    details to know the addresses for each register and the way in which the commands
    work in the I²C bus.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，该类声明了许多常量，这使得我们更容易理解通过I²C总线与加速度计交互的代码。例如，`ADXL345_I2C_ADDR`常量指定了I²C总线中ADXL345加速度计的地址，十六进制为53（`0x53`）。如果我们只是在代码中看到`0x53`，我们不会理解它是传感器的I²C总线地址。我们导入了C++版本中定义的所有常量，以便在需要添加初始版本中未包含的额外功能时，我们拥有所有必要的值。制造商提供的数据表提供了必要的细节，以了解每个寄存器的地址以及命令在I²C总线中的工作方式。
- en: We have to specify the I²C bus number to which the digital accelerometer is
    wired when we create an instance of the `Adxl345` class in the `bus` required
    argument. The constructor, that is, the `__init__` method, creates a new `mraa.I2c`
    instance with the received `bus` argument and saves its reference in the `i2c`
    attribute.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建`Adxl345`类的实例时，我们必须指定数字加速度计连接的I²C总线编号，该编号作为`bus`必需参数。构造函数，即`__init__`方法，使用接收到的`bus`参数创建一个新的`mraa.I2c`实例，并将其引用保存在`i2c`属性中。
- en: '[PRE9]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Before performing any read or write operation in the I²C bus, it is a good practice
    to call the `address` method for the `mraa.I2c` instance to indicate the slave
    device to which we want to talk to. In this case, the address for the slave device
    is specified in the `ADXL345_I2C_ADDR` constant.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在I²C总线中执行任何读取或写入操作之前，调用`mraa.I2c`实例的`address`方法以指示我们想要与之通信的从设备是一个好习惯。在这种情况下，从设备的地址由`ADXL345_I2C_ADDR`常量指定。
- en: '[PRE10]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then, the code builds a message by creating a `bytearray` with the two hexadecimal
    values that we want to write to the slave: `ADXL345_POWER_CTL` and `ADXL345_POWER_ON`.
    We can read the message as `write turn on to the power control register`. The
    call to the `write` method for the `mraa.I2c` instance with this message will
    turn on the accelerometer.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，代码通过创建一个包含我们想要写入从设备的两个十六进制值的`bytearray`来构建一条消息：`ADXL345_POWER_CTL`和`ADXL345_POWER_ON`。我们可以将这条消息解读为“将开启写入电源控制寄存器”。使用此消息调用`mraa.I2c`实例的`write`方法将开启加速度计。
- en: '[PRE11]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We declared the following constants related to resolutions:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了以下与分辨率相关的常量：
- en: '`ADXL345_FULL_RES`: Work with full resolution, where resolution increases with
    the g range up to 13-bit resolution'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ADXL345_FULL_RES`：以全分辨率工作，其中分辨率随着g范围的增加而增加到13位分辨率'
- en: '`ADXL345_10BIT`: Work with a fixed 10-bit resolution'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ADXL345_10BIT`：以固定的10位分辨率工作'
- en: 'We declared the following constants related to scales:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了以下与量纲相关的常量：
- en: '`ADXL345_2G`: Sets the g range to ±2g'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ADXL345_2G`：将g范围设置为±2g'
- en: '`ADXL345_4G`: Sets the g range to ±4g'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ADXL345_4G`：将g范围设置为±4g'
- en: '`ADXL345_8G`: Sets the g range to ±8g'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ADXL345_8G`：将g范围设置为±8g'
- en: '`ADXL345_16G`: Sets the g range to ±16g'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ADXL345_16G`：将g范围设置为±16g'
- en: 'The code makes another call to the `address` method for the `mraa.I2c` instance
    before it makes another write to configure the desired resolution and scale for
    the sensor. The code builds another message by creating a `bytearray` with the
    two hexadecimal values that we want to write to the slave: `ADXL345_DATA_FORMAT`
    and the result of applying a bitwise or operator (`|`) for `ADXL345_16G` and `ADXL345_FULL_RES`.
    We can read the message as `write ±16g + full resolution to the data format register`.
    It is necessary to combine the desired resolution and the range in a single byte
    value, and therefore, we have to use the bitwise or operator (`|`).'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在对传感器配置所需的分辨率和量纲进行另一次写入之前，代码对`mraa.I2c`实例的`address`方法进行了另一次调用。代码通过创建一个包含我们想要写入从设备的两个十六进制值的`bytearray`来构建另一条消息：`ADXL345_DATA_FORMAT`以及应用位或运算符(`|`)后的`ADXL345_16G`和`ADXL345_FULL_RES`的结果。我们可以将这条消息解读为“将±16g和全分辨率写入数据格式寄存器”。有必要将所需的分辨率和范围组合成一个单字节值，因此我们必须使用位或运算符(`|`)。
- en: '[PRE12]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The call to the write method for the `mraa.I2c` instance with this message
    will configure the accelerometer to work with a ±16g range for g and with the
    full resolution. As we have access to this call, we can make changes to the code
    to change the desired resolution or the scale for our acceleration measures. For
    example, the following lines that compose the message will change the configuration
    to make the accelerometer work with a g range of ±4g:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`mraa.I2c`实例的`write`方法并传递此消息将配置加速度计以±16g的范围工作，并具有完整的分辨率。由于我们有权访问此调用，我们可以修改代码以更改所需的分辨率或加速度测量的比例。例如，以下组成消息的行将配置更改，使加速度计能够以±4g的范围工作：
- en: '[PRE13]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, the code declares offset attributes for x, y, and z that is necessary
    to convert the raw acceleration values retrieved from the accelerometer into the
    appropriate values expressed in g. We want to work with easy to understand attributes
    instead, and therefore, the constructor creates and initializes three attributes
    with `0.0`: `x_acceleration`, `y_acceleration`, and `z_acceleration`. Finally,
    the constructor calls the `update` method to retrieve the first values from the
    accelerometer.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，代码声明了x、y和z的偏移量属性，这是将来自加速度计的原始加速度值转换为以g表示的适当值所必需的。我们希望使用易于理解的属性，因此构造函数创建并初始化了三个属性，其值为`0.0`：`x_acceleration`、`y_acceleration`和`z_acceleration`。最后，构造函数调用`update`方法以从加速度计检索第一个值。
- en: The `update` method makes a call to the `address` method for the `mraa.I2c`
    instance and then calls its `writeByte` method with `ADXL345_XOUT_L` as its argument,
    that is, the first data register that we want to read.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`update`方法对`mraa.I2c`实例的`address`方法进行调用，然后调用其`writeByte`方法，将`ADXL345_XOUT_L`作为其参数，即我们想要读取的第一个数据寄存器。'
- en: '[PRE14]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The accelerometer values are stored in six data registers. There are two bytes
    per axis: the low byte (eight least significant bits) and the high byte (eight
    most significant bits), and therefore, we can read the six bytes with a single
    I²C read operation, starting with the address of the first byte for the x axis.
    Then, we have to compose each pair of bytes into a single value. The call to the
    `read` method for the `mraa.I2c` instance passes the `DATA_REG_SIZE` constant
    as an argument to indicate that we want to read six bytes and the code saves the
    resulting `bytearray` in the `xyz_raw_acceleration` local variable.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 加速度计的值存储在六个数据寄存器中。每个轴有两个字节：低字节（八个最低有效位）和高字节（八个最高有效位），因此我们可以通过单个I²C读取操作读取六个字节，从x轴的第一个字节地址开始。然后，我们必须将每对字节组合成一个单一值。对`mraa.I2c`实例的`read`方法的调用将`DATA_REG_SIZE`常量作为参数传递，以指示我们想要读取六个字节，并且代码将结果`bytearray`保存到`xyz_raw_acceleration`局部变量中。
- en: '[PRE15]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, the code combines the low bytes and the high bytes to compose a single
    value for each raw acceleration pair of bytes retrieved from the accelerometer
    and saves them in three local variables: `x_raw_acceleration`, `y_raw_acceleration`,
    and `z_raw_acceleration`. The code uses the binary left shift (`<<`) bitwise operator
    to move the high byte (the eight most significant bits) to the left by 8 places
    and make the new bits on the right-hand side zeros. Then, it applies a binary
    or (`|`) to build the entire word (two bytes). The `x_raw_acceleration` value
    is the result of joining the high byte and the low byte to compose a word of two
    bytes.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，代码将低字节和高字节组合成一个单一值，为从加速度计检索的每个原始加速度字节对保存到三个局部变量中：`x_raw_acceleration`、`y_raw_acceleration`和`z_raw_acceleration`。代码使用二进制左移（`<<`）位运算符将高字节（八个最高有效位）向左移动8位，并将右侧的新位设置为0。然后，它应用二进制或（`|`）来构建整个字（两个字节）。`x_raw_acceleration`值是将高字节和低字节组合起来构成一个双字节字的結果。
- en: The first element in the `xyz_raw_acceleration` array (`xyz_raw_acceleration[0]`)
    includes the low byte for the x raw acceleration and the second element in the
    `xyz_raw_acceleration` array (`xyz_raw_acceleration[1]`) includes the high byte
    for the x raw acceleration. Thus, it is necessary to add 8 binary zeros to the
    high byte (`xyz_raw_acceleration[1]`) and replace those eight zeros with the low
    byte (`xyz_raw_acceleration[0]`). The same has to be done for the y and z raw
    acceleration bytes.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`xyz_raw_acceleration`数组中的第一个元素（`xyz_raw_acceleration[0]`）包括x原始加速度的低字节，而`xyz_raw_acceleration`数组中的第二个元素（`xyz_raw_acceleration[1]`）包括x原始加速度的高字节。因此，有必要向高字节（`xyz_raw_acceleration[1]`）添加8个二进制零，并用低字节（`xyz_raw_acceleration[0]`）替换这些零。对于y和z原始加速度字节也要做同样的事情。'
- en: '[PRE16]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, it is necessary to multiply each value by the offsets defined in the
    constructor to obtain the appropriate values for x, y, and z expressed in g and
    save them in the three attributes: `x_acceleration`, `y_acceleration`, and `z_acceleration`.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要将每个值乘以构造函数中定义的偏移量，以获得以g为单位的x、y和z的适当值，并将它们保存到三个属性中：`x_acceleration`、`y_acceleration`
    和 `z_acceleration`。
- en: '[PRE17]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now, we have a class that represents the ADXL345 accelerometer entirely written
    in Python and we can make any necessary changes to make different configurations
    for the accelerometer.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个完全用Python编写的表示ADXL345加速度计的类，我们可以进行任何必要的更改，以对加速度计进行不同的配置。
- en: We just need to create a new version of the `Accelerometer` class to use the
    recently created `Adxl345` class instead of the `pyupm_adxl345.Adxl345` class.
    The following lines show the code for the new `Accelerometer` class. The code
    file for the sample is `iot_python_chapter_07_03.py`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要创建 `Accelerometer` 类的新版本，使用最近创建的 `Adxl345` 类而不是 `pyupm_adxl345.Adxl345`
    类。以下行显示了新 `Accelerometer` 类的代码。示例的代码文件为 `iot_python_chapter_07_03.py`。
- en: '[PRE18]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now, we can use the same code that we have in the previous example for the `__main__`
    method and perform the same operations to check the values retrieved from the
    accelerometer.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用之前示例中用于 `__main__` 方法的相同代码，并执行相同的操作来检查从加速度计获取的值。
- en: Tip
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Writing code that interacts with the I²C bus and a specific sensor requires
    a big effort because we have to read the detailed specifications from the manufacturer's
    datasheet. Sometimes, we won't be able to use all the features included in a sensor
    if we don't write our own code. In other cases, the features included in the `upm`
    library will be enough for our projects.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 编写与I²C总线和特定传感器交互的代码需要很大的努力，因为我们必须从制造商的数据表中读取详细的规格。有时，如果我们不编写自己的代码，可能无法使用传感器中包含的所有功能。在其他情况下，`upm`
    库中包含的功能可能足以满足我们的项目需求。
- en: Wiring an analog temperature sensor
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接模拟温度传感器
- en: In [Chapter 6](ch06.html "Chapter 6. Working with Analog Inputs and Local Storage"),
    *Working with Analog Inputs and Local Storage*, we used a photoresistor included
    in a voltage divider and we connected it to an analog input pin. We can use a
    similar configuration and replace the photoresistor with a thermistor to measure
    ambient temperature. A thermistor changes its resistance value with temperature,
    and therefore, we can convert resistance changes into voltage value changes.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](ch06.html "第6章. 使用模拟输入和本地存储") *使用模拟输入和本地存储* 中，我们使用了一个包含在分压器中的光敏电阻，并将其连接到模拟输入引脚。我们可以使用类似的配置，并用热敏电阻替换光敏电阻来测量环境温度。热敏电阻会随着温度变化而改变其电阻值，因此，我们可以将电阻变化转换为电压值变化。
- en: We can also work with an analog sensor breakout board that includes a thermistor
    in the necessary configuration to provide us with voltage levels to an analog
    pin that represent temperature values. In this case, we will work with an analog
    temperature sensor supported in the `upm` library to measure ambient temperature.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用一个包含热敏电阻的模拟传感器扩展板，该热敏电阻配置为为我们提供一个模拟引脚的电压级别，这些电压级别代表温度值。在这种情况下，我们将使用 `upm`
    库支持的模拟温度传感器来测量环境温度。
- en: We will use the the analog pin labeled **A0** to connect the voltage output
    of an analog accelerometer breakout board. After we finish the necessary wirings,
    we will write Python code to measure and display the ambient temperature in both
    degrees Celsius (ºC) and degrees Fahrenheit (ºF). This way, we will read the result
    of converting an analog value to its digital representation and we will map it
    to the temperature value in the appropriate measurement unit.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用标有 **A0** 的模拟引脚来连接模拟加速度计扩展板的电压输出。完成必要的接线后，我们将编写Python代码来测量并显示环境温度，单位为摄氏度
    (ºC) 和华氏度 (ºF)。这样，我们将读取将模拟值转换为其数字表示的结果，并将其映射到适当的测量单位中的温度值。
- en: 'We need a Seeedstudio Grove temperature sensor to work with this example. The
    following URL provides detailed information about this module: [http://www.seeedstudio.com/depot/Grove-Temperature-Sensor-p-774.html](http://www.seeedstudio.com/depot/Grove-Temperature-Sensor-p-774.html).
    The following diagram shows the sensor breakout board, the necessary wirings,
    and the wirings from the Intel Galileo Gen 2 board to the breadboard. The Fritzing
    file for the sample is `iot_fritzing_chapter_07_04.fzz` and the following picture
    is the breadboard view. Don''t forget that you can also decide to use the Grove
    base shield to plug this sensor to the Intel Galileo Gen 2 board.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个 Seeedstudio Grove 温度传感器来配合这个示例。以下网址提供了关于此模块的详细信息：[http://www.seeedstudio.com/depot/Grove-Temperature-Sensor-p-774.html](http://www.seeedstudio.com/depot/Grove-Temperature-Sensor-p-774.html)。以下图显示了传感器扩展板、必要的布线以及从
    Intel Galileo Gen 2 板到面包板的布线。示例的 Fritzing 文件为 `iot_fritzing_chapter_07_04.fzz`，以下图片是面包板视图。不要忘记，您也可以选择使用
    Grove 基础板将此传感器连接到 Intel Galileo Gen 2 板。
- en: '![Wiring an analog temperature sensor](img/B05042_07_05.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![连接模拟温度传感器](img/B05042_07_05.jpg)'
- en: 'The following picture shows the schematic with the electronic components represented
    as symbols:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图片显示了用符号表示的电子元件的电路图：
- en: '![Wiring an analog temperature sensor](img/B05042_07_06.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![连接模拟温度传感器](img/B05042_07_06.jpg)'
- en: 'As seen in the previous schematic, we have the following connections:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，我们有以下连接：
- en: The analog input pin labeled **A0** is connected to the temperature output pin
    labeled **SIG** (**0** in the breakout board's symbol)
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记为**A0**的模拟输入引脚连接到标记为**SIG**的温度输出引脚（在扩展板符号中为**0**）
- en: The power pin labeled **3V3** is connected to the temperature sensor power pin
    labeled **VCC**
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记为**3V3**的电源引脚连接到温度传感器电源引脚标记为**VCC**
- en: The ground pin labeled **GND** is connected to the temperature sensor ground
    pin labeled **GND**
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记为**GND**的接地引脚连接到温度传感器接地引脚标记为**GND**
- en: Now, it is time make all the necessary wirings. Don't forget to shutdown the
    Yocto Linux, wait for all the onboard LEDs to turn off, and unplug the power supply
    from the Intel Galileo Gen 2 board before adding or removing any wire from the
    board's pins.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候进行所有必要的布线了。在添加或移除任何线缆之前，不要忘记关闭 Yocto Linux，等待所有板载 LED 灯熄灭，并从 Intel Galileo
    Gen 2 板上拔掉电源。
- en: Measuring ambient temperature with an analog sensor
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模拟传感器测量环境温度
- en: The `upm` library includes support for the Grove analog temperature sensor breakout
    board in the `pyupm_grove` module. The `GroveTemp` class declared in this module
    represents the analog temperature sensor connected to our board. The class makes
    it easy to retrieve the raw values read from the analog input into values expressed
    in degrees Celsius (ºC).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`upm` 库在 `pyupm_grove` 模块中包括对 Grove 模拟温度传感器扩展板的支持。在此模块中声明的 `GroveTemp` 类代表连接到我们板上的模拟温度传感器。该类使得从模拟输入读取的原始值转换为以摄氏度（ºC）表示的值变得简单。'
- en: We will create a new `TemperatureSensor` class to represent the temperature
    sensor and make it easier for us to retrieve the ambient temperature values without
    worrying about unit conversions that are necessary when working with an instance
    of the `GroveTemp` class. We will use the `GroveTemp` class to interact with the
    analog temperature sensor. The following lines show the code for the new `TemperatureSensor`
    class that works with the `upm` library, specifically with the `pyupm_grove` module.
    The code file for the sample is `iot_python_chapter_07_04.py`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个新的 `TemperatureSensor` 类来表示温度传感器，并使我们更容易检索环境温度值，而无需担心与 `GroveTemp` 类实例一起工作时必要的单位转换。我们将使用
    `GroveTemp` 类与模拟温度传感器交互。以下行显示了与 `upm` 库一起工作的新 `TemperatureSensor` 类的代码，特别是与 `pyupm_grove`
    模块一起。示例的代码文件为 `iot_python_chapter_07_04.py`。
- en: '[PRE19]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We have to specify the analog pin to which the sensor is connected when we
    create an instance of the `TemperatureSensor` class in the `analog_pin` required
    arguments. The constructor, that is, the `__init__` method, creates a new `upmGrove.GroveTemp`
    instance with the received `analog_pin` argument and saves its reference in the
    `temperature_sensor` attribute. Finally, the constructor instance creates and
    initializes two attributes with `0.0`: `temperature_celsius`, and `temperature_fahrenheit`.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建 `TemperatureSensor` 类的实例并在 `analog_pin` 必需参数中指定传感器连接的模拟引脚时，我们必须指定该引脚。构造函数，即
    `__init__` 方法，创建一个新的 `upmGrove.GroveTemp` 实例，并使用接收到的 `analog_pin` 参数，将其引用保存在 `temperature_sensor`
    属性中。最后，构造函数实例创建并初始化两个属性，值为 `0.0`：`temperature_celsius` 和 `temperature_fahrenheit`。
- en: The class defines the `measure_temperature` method that retrieves the current
    ambient temperature measured in degrees Celsius (ºC) by calling the value method
    for `self.temperature_sensor` and saves the value in the `temperature_celsius`
    local variable. The next line assigns the value to the `temperature_celsius` attribute.
    Finally, the code assigns the result of converting the the temperature measured
    in degrees Celsius (ºC) to the equivalent value in degrees Fahrenheit (ºF). The
    formula is easy to read because it is just necessary to multiply the temperature
    measured in degrees Celsius (ºC) by 9, divide the result by 5 and sum 32\. This
    way the `TemperatureSensor` class updates two attributes with the ambient temperature
    measured by the sensor in degrees Celsius (ºC) and degrees Fahrenheit (ºF).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 该类定义了一个 `measure_temperature` 方法，通过调用 `self.temperature_sensor` 的值方法来获取当前环境温度（单位为摄氏度，ºC），并将该值保存在局部变量
    `temperature_celsius` 中。下一行将值赋给 `temperature_celsius` 属性。最后，代码将摄氏度（ºC）测量的温度转换为等效的华氏度（ºF）值。该公式易于阅读，因为它只需要将摄氏度（ºC）测量的温度乘以9，然后将结果除以5并加上32。这样，`TemperatureSensor`
    类就更新了两个属性，即传感器测量的环境温度（单位为摄氏度，ºC）和华氏度（ºF）。
- en: Now, we will write a loop that will retrieve and display the ambient temperature
    in degrees Celsius (ºC) and degrees Fahrenheit (ºF), every 10 seconds. The code
    file for the sample is `iot_python_chapter_07_04.py`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写一个循环，每10秒检索并显示环境温度，单位为摄氏度（ºC）和华氏度（ºF）。该示例的代码文件为 `iot_python_chapter_07_04.py`。
- en: '[PRE20]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The first line creates an instance of the previously coded `TemperatureSensor`
    class with `0` as the values of the `analog_pin` argument. This way, the instance
    will read the analog values from the pin labeled **A0**. Then, the code runs a
    loop forever that calls the `measure_temperature` method to update the ambient
    temperature values and then prints them, expressed in degrees Celsius (ºC) and
    degrees Fahrenheit (ºF).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行创建了一个之前编写的 `TemperatureSensor` 类的实例，`analog_pin` 参数的值为 `0`。这样，该实例将从标有 **A0**
    的引脚读取模拟值。然后，代码运行一个无限循环，调用 `measure_temperature` 方法来更新环境温度值，然后打印它们，单位为摄氏度（ºC）和华氏度（ºF）。
- en: 'The following line will start the example:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行将启动示例：
- en: '[PRE21]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'After you run the example, turn on an air conditioner or a heating system to
    generate a change in the ambient temperature and you will see how the measured
    temperature changes after a few minutes. The following lines show some a sample
    output:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 运行示例后，打开空调或加热系统以产生环境温度的变化，你将看到测量温度在几分钟后的变化。以下行显示了部分示例输出：
- en: '[PRE22]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Wiring a digital temperature and humidity sensor to the I²C bus
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数字温度和湿度传感器连接到 I²C 总线
- en: Now, we will use a multifunctional digital sensor that will provide us with
    temperature and relative humidity information. We will use a breakout board that
    uses the I²C bus to allow the Intel Galileo Gen 2 board to communicate with the
    sensor. The sensor is useful when we don't need to measure temperature and humidity
    in extreme conditions. We cannot use this sensor at the top of Mount Etna, just
    in case we work in a research project related to volcanoes.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用一个多功能数字传感器，它将为我们提供温度和相对湿度信息。我们将使用一个使用 I²C 总线进行通信的电路板，以便英特尔 Galileo Gen
    2 板与传感器通信。当不需要在极端条件下测量温度和湿度时，该传感器很有用。我们不能在厄特纳火山顶部使用此传感器，以防我们在与火山相关的科研项目中工作。
- en: We will use the two pins labeled **SDA** and **SCL** to connect the data and
    clock lines of the I²C bus to the corresponding pins in the digital temperature
    and humidity breakout board. After we finish the necessary wirings, we will write
    a Python code to measure, display the ambient temperature, and the relative humidity.
    This way, we will read the result of sending commands to the sensor through the
    I²C bus, reading the responses, and decoding them into the ambient temperature
    and the relative humidity expressed in the appropriate units.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用标有**SDA**和**SCL**的两个引脚将I²C总线的数据线和时钟线连接到数字温度和湿度引脚扩展板上的相应引脚。完成必要的布线后，我们将编写Python代码来测量、显示环境温度和相对湿度。这样，我们将通过I²C总线发送命令到传感器，读取响应，并将它们解码为以适当单位表示的环境温度和相对湿度。
- en: 'We need a SeeedStudio Grove temperature & humidity sensor (high-accuracy &
    mini) breakout to work with this example. The following URL provides detailed
    information about this breakout board: [http://www.seeedstudio.com/depot/Grove-TemperatureHumidity-Sensor-HighAccuracy-Mini-p-1921.html](http://www.seeedstudio.com/depot/Grove-TemperatureHumidity-Sensor-HighAccuracy-Mini-p-1921.html).
    The breakout board incorporates the TH02 digital humidity and temperature sensor
    and provides support for both the I²C bus.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一款SeeedStudio Grove温度与湿度传感器（高精度且迷你）的引脚扩展板来与这个示例一起使用。以下网址提供了关于这款引脚扩展板的详细信息：[http://www.seeedstudio.com/depot/Grove-TemperatureHumidity-Sensor-HighAccuracy-Mini-p-1921.html](http://www.seeedstudio.com/depot/Grove-TemperatureHumidity-Sensor-HighAccuracy-Mini-p-1921.html)。该引脚扩展板集成了TH02数字湿度温度传感器，并支持I²C总线。
- en: 'The following diagram shows the digital temperature, humidity breakout, the
    necessary wirings, and the wirings from the Intel Galileo Gen 2 board to the breadboard.
    The Fritzing file for the sample is `iot_fritzing_chapter_07_05.fzz` and the following
    picture is the breadboard view:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了数字温度、湿度引脚扩展板、必要的布线以及从Intel Galileo Gen 2板到面包板的布线。该示例的Fritzing文件为`iot_fritzing_chapter_07_05.fzz`，以下图片是面包板视图：
- en: '![Wiring a digital temperature and humidity sensor to the I2C bus](img/B05042_07_07.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![将数字温度和湿度传感器连接到I2C总线](img/B05042_07_07.jpg)'
- en: 'The following picture shows the schematic with the electronic components represented
    as symbols:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图片显示了带有电子元件符号的电路图：
- en: '![Wiring a digital temperature and humidity sensor to the I2C bus](img/B05042_07_08.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![将数字温度和湿度传感器连接到I2C总线](img/B05042_07_08.jpg)'
- en: 'As seen in the previous schematic, we have the following connections:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，我们有以下连接：
- en: The **SDA** pin is connected to the breakout board pin labeled **SDA**. This
    way, we connect the digital temperature and humidity sensor to the serial data
    line for the I²C bus.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SDA**引脚连接到标有**SDA**的引脚扩展板。这样，我们将数字温度和湿度传感器连接到I²C总线的串行数据线。'
- en: The **SCL** pin is connected to the breakout board pin labeled **SCL**. This
    way, we connect the digital temperature and humidity sensor to the serial clock
    line for the I²C bus.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SCL**引脚连接到标有**SCL**的引脚扩展板。这样，我们将数字温度和湿度传感器连接到I²C总线的串行时钟线。'
- en: The power pin labeled **3V3** is connected to the breakout board power pin labeled
    **VCC**.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标有**3V3**的电源引脚连接到标有**VCC**的引脚扩展板电源引脚。
- en: The ground pin labeled **GND** is connected to the breakout board ground pin
    labeled **GND**.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标有**GND**的接地引脚连接到标有**GND**的引脚扩展板接地引脚。
- en: Now, it is time make all the necessary wirings. Don't forget to shutdown the
    Yocto Linux, wait for all the onboard LEDs to turn off, and unplug the power supply
    from the Intel Galileo Gen 2 board before adding or removing any wire from the
    board's pins.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候进行所有必要的布线了。在添加或移除任何线从板上的引脚之前，不要忘记关闭Yocto Linux，等待所有板载LED熄灭，并从Intel Galileo
    Gen 2板上拔掉电源。
- en: Measuring temperature and humidity with a digital sensor
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用数字传感器测量温度和湿度
- en: The `upm` library includes support for the digital temperature and humidity
    breakout board that uses the TH02 sensor in the `pyupm_th02` module. The `TH02`
    class declared in this module represents a digital temperature and humidity sensor
    that uses the TH02 sensor, connected to our board. The class makes it easy to
    initialize the sensor and retrieve the temperature and humidity values through
    the I²C bus. The class works with the `mraa.I2c` class under the hoods to talk
    with the sensor, that is, to write data to and read data from the TH02 sensor
    that acts as a slave device connected to the I²C bus.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`upm` 库在 `pyupm_th02` 模块中包含了支持使用 TH02 传感器的数字温度和湿度扩展板。在此模块中声明的 `TH02` 类代表一个使用
    TH02 传感器的数字温度和湿度传感器，该传感器连接到我们的板上。该类使得初始化传感器并通过 I²C 总线检索温度和湿度值变得简单。该类在幕后与 `mraa.I2c`
    类协同工作，与传感器通信，即向 TH02 传感器写入数据并从该传感器读取数据，该传感器作为连接到 I²C 总线的从设备。'
- en: We will create a new `TemperatureAndHumiditySensor` class to represent the temperature
    and humidity sensor and make it easier for us to retrieve the temperature and
    humidity values in the appropriate units working with an instance of the `TH02`
    class. We will use the `TH02` class to interact with the sensor. The following
    lines show the code for the new `TemperatureSensor` class that works with the
    `upm` library, specifically with the `pyupm_th02` module. The code file for the
    sample is `iot_python_chapter_07_05.py`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个新的 `TemperatureAndHumiditySensor` 类来表示温度和湿度传感器，并使我们在使用 `TH02` 类的实例时更容易检索温度和湿度值。我们将使用
    `TH02` 类与传感器交互。以下行显示了与 `upm` 库（特别是 `pyupm_th02` 模块）一起工作的新 `TemperatureSensor`
    类的代码。示例的代码文件为 `iot_python_chapter_07_05.py`。
- en: '[PRE23]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We have to specify the I²C bus number to which the digital temperature and humidity
    sensor is wired when we create an instance of the `TemperatureAndHumiditySensor`
    class in the `bus` required argument. The constructor, that is, the `__init__`
    method, creates a new `upmTh02.TH02` instance with the received `bus` argument
    and saves its reference in the `th02_sensor` attribute.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在 `TemperatureAndHumiditySensor` 类的 `bus` 必需参数中创建实例时，我们必须指定数字温度和湿度传感器连接到的
    I²C 总线编号。构造函数，即 `__init__` 方法，使用接收到的 `bus` 参数创建一个新的 `upmTh02.TH02` 实例，并将它的引用保存在
    `th02_sensor` 属性中。
- en: Tip
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The datasheet for the TH02 sensor specifies a formula to convert the raw read
    temperature to degrees Celsius (ºC), and therefore, by reading the datasheet we
    might think the `upmTh02.TH02` instance will provide us a value in degrees Fahrenheit
    (ºF). However, this is not what happens. The `upmTh02.TH02` instance performs
    the conversion from degrees Fahrenheit (ºF) to degrees Celsius (ºC) and provides
    us a value in the latter unit of measure. Thus, if we want to display the value
    in degrees Fahrenheit (ºF), we must perform the conversion from degrees Celsius
    (ºC) to degrees Fahrenheit (ºF). Unluckily, the only way of realizing about this
    situation is by looking at the C++ source code for the `upm` module because there
    is no documentation about the unit of measure that the code uses to return the
    temperature value.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: TH02 传感器的数据表指定了一个将原始读取温度转换为摄氏度（ºC）的公式，因此，通过阅读数据表，我们可能会认为 `upmTh02.TH02` 实例将提供一个华氏度（ºF）的值。然而，事实并非如此。`upmTh02.TH02`
    实例将华氏度（ºF）转换为摄氏度（ºC），并为我们提供一个后者的测量单位值。因此，如果我们想以华氏度（ºF）显示值，我们必须将摄氏度（ºC）转换为华氏度（ºF）。不幸的是，了解这种情况的唯一方法是通过查看
    `upm` 模块的 C++ 源代码，因为关于代码使用的测量单位没有文档说明。
- en: 'We want to work with easy to understand attributes, and therefore, the constructor
    creates and initializes three attributes with `0.0`: `temperature_celsius`, `temperature_fahrenheit`,
    and `humidity`. After the constructor is executed, we have an initialized digital
    temperature and humidity sensor ready to retrieve values.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望使用易于理解的属性，因此构造函数创建了三个属性并初始化为 `0.0`：`temperature_celsius`、`temperature_fahrenheit`
    和 `humidity`。构造函数执行后，我们有一个初始化的数字温度和湿度传感器，可以检索值。
- en: 'The class defines a `measure_temperature_and_humidity` method that updates
    the ambient temperature and humidity values in the sensor, retrieves these values,
    and finally saves them in the following three attributes: `temperature_celsius`,
    `temperature_fahrenheit`, and `humidity`.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 该类定义了一个 `measure_temperature_and_humidity` 方法，该方法更新传感器中的环境温度和湿度值，检索这些值，并将它们最终保存到以下三个属性中：`temperature_celsius`、`temperature_fahrenheit`
    和 `humidity`。
- en: First, the code within the `measure_temperature_and_humidity` method calls the
    `getTemperature` method for `self.th02_sensor` to request the sensor to retrieve
    the temperature value. The method returns the read value converted to degrees
    Celsius (ºC) and the code saves it in the `temperature_celsius` local variable.
    The code saves the value in the attribute with the same name and saves the value
    converted to degrees Fahrenheit (ºF) in the `temperature_fahrenheit` attribute.
    Finally, the code calls the `getHumidity` method for `self.th02_sensor` to request
    the sensor to retrieve the humidity value and saves it in the `humidity` attribute.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`measure_temperature_and_humidity`方法中的代码调用`self.th02_sensor`的`getTemperature`方法，请求传感器检索温度值。该方法返回转换为摄氏度（ºC）的读取值，代码将其保存到`temperature_celsius`局部变量中。代码将值保存在具有相同名称的属性中，并将转换为华氏度（ºF）的值保存在`temperature_fahrenheit`属性中。最后，代码调用`self.th02_sensor`的`getHumidity`方法，请求传感器检索湿度值并将其保存在`humidity`属性中。
- en: Now, we will write a loop that will retrieve and display the temperature values
    expressed in degrees Celsius (ºC) and degrees Fahrenheit, and the humidity value,
    every 10 seconds. The code file for the sample is `iot_python_chapter_07_05.py`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写一个循环，每10秒检索并显示以摄氏度（ºC）和华氏度表示的温度值，以及湿度值。示例的代码文件是`iot_python_chapter_07_05.py`。
- en: '[PRE24]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The first line creates an instance of the previously coded `TemperatureAndHumiditySensor`
    class with `0` as the value of the `bus` argument. This way, the instance will
    establish a communication with the digital accelerometer through the I²C bus.
    As happened in our previous example with a sensor connected to the I²C bus, the
    Intel Galileo Gen 2 board is the master in the bus and the digital temperature
    and humidity sensor, acts as a slave.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行创建了一个之前编写的`TemperatureAndHumiditySensor`类的实例，`bus`参数的值为`0`。这样，该实例将通过I²C总线与数字加速度计建立通信。正如我们在之前与I²C总线连接的传感器示例中发生的那样，英特尔Galileo
    Gen 2板是总线上的主设备，而数字温度和湿度传感器则作为从设备。
- en: Then, the code runs a loop forever that calls the `measure_temperature_and_humidity`
    method to update the temperature values expressed in two units and the humidity.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，代码运行一个无限循环，调用`measure_temperature_and_humidity`方法来更新以两种单位和湿度表示的温度值。
- en: 'The following line will start the example:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行将开始示例：
- en: '[PRE25]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: After you run the example, turn on an air conditioner or a heating system, to
    generate a change in the ambient temperature and humidity.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行示例后，打开空调或供暖系统，以产生环境温度和湿度的变化。
- en: '[PRE26]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Test your knowledge
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你的知识
- en: Which of the following sensors allows us to measure the magnitude and direction
    of proper acceleration?
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个传感器允许我们测量正加速度的大小和方向？
- en: A temperature sensor.
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个温度传感器。
- en: An accelerometer.
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个加速度计。
- en: A light sensor.
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个光传感器。
- en: 'Which of the following acronym that defines a connection type for a module
    with a sensor is analog:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个缩写定义了一个具有传感器的模块的连接类型是模拟的：
- en: AIO.
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: AIO。
- en: I2C.
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: I2C。
- en: UART.
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: UART。
- en: 'How many wires do we need to connect a device to the I²C bus:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要多少根线来将设备连接到I²C总线：
- en: 1`.`
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1`。
- en: 2`.`
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2`。
- en: 3`.`
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3`。
- en: 'How many wires do we need to connect a device to the SPI bus:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要多少根线来将设备连接到SPI总线：
- en: 1`.`
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1`。
- en: 2`.`
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2`。
- en: 3`.`
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3`。
- en: 'Which of the following is not a connection of the I²C bus:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个不是I²C总线的连接：
- en: MISO.
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: MISO。
- en: SDA.
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: SDA。
- en: SCL.
  id: totrans-250
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: SCL。
- en: Summary
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about sensors and their connection types. We understood
    that it is necessary to consider many important things when choosing sensors and
    that they make it easy for us to measure different variables from the real world.
    We learned the importance of considering the units of measure because sensors
    always provide values measured in a specific unit that we must consider.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了传感器及其连接类型。我们了解到在选择传感器时需要考虑许多重要事项，并且它们使我们能够轻松地从现实世界测量不同的变量。我们学习了考虑测量单位的重要性，因为传感器总是以特定的单位提供测量值，我们必须考虑这些单位。
- en: We wrote code that took advantage of the modules and classes included in the
    `upm` library that made it easier for us to start working with analog and digital
    sensors. In addition, we wrote code that interacted with a digital accelerometer
    through the I²C bus because we wanted to be able to take advantage of additional
    features provided by the sensor but not included in the `upm` library module.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写了利用`upm`库中包含的模块和类来简化我们开始使用模拟和数字传感器的代码。此外，我们还编写了通过I²C总线与数字加速度计交互的代码，因为我们想利用传感器提供的额外功能，但这些功能并未包含在`upm`库模块中。
- en: We measured the magnitude and direction of proper acceleration or g-force, ambient
    temperature and humidity. As in the previous chapters, we continued taking advantage
    of Python's object-oriented features and we created classes to encapsulate sensors
    and the necessary configurations with the `upm` and `mraa` libraries. Our code
    is easy to read and understand and we can easily hide the low-level details.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们测量了合加速度或g力的幅度和方向、环境温度和湿度。与前面的章节一样，我们继续利用Python的面向对象特性，并创建了类来封装`upm`和`mraa`库中的传感器和必要的配置。我们的代码易于阅读和理解，并且我们可以轻松地隐藏底层细节。
- en: Now that we are able to retrieve data from the real world with sensors, we will
    make our IoT device perform actions with different actuators and shields, which
    is the topic of the next chapter.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够通过传感器从现实世界获取数据，我们将使我们的物联网设备通过不同的执行器和屏蔽器执行动作，这是下一章的主题。
