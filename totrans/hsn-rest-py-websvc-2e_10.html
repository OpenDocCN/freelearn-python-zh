<html><head></head><body><div><h1 class="header-title">Developing RESTful APIs with Tornado 5.1.1</h1>
                
            
            
                
<p>In this chapter, we will work with Tornado 5.1.1 to create a RESTful Web API. We will start working with this lightweight web framework. We will look at the following:</p>
<ul>
<li>Design a RESTful API to interact with slow sensors and actuators</li>
<li>Understand the tasks performed by each HTTP method</li>
<li>Set up a virtual environment with Tornado 5.1.1</li>
<li>Create classes that represent a drone</li>
<li>Write request handlers</li>
<li>Map URL patterns to request handlers</li>
<li>Make HTTP requests to the Tornado API</li>
<li>Work with command-line tools—<kbd>curl</kbd> and <kbd>httpie</kbd></li>
<li>Work with GUI tools—Postman and others</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Designing a RESTful API to interact with slow sensors and actuators</h1>
                
            
            
                
<p>Imagine that we have to create a RESTful API to control a drone, also known as a <strong>UAV</strong> (short for <strong>Unmanned Aerial Vehicle</strong>). The drone is an IoT device that interacts with many sensors and actuators, including digital electronic speed controllers linked to engines, propellers, and servomotors.</p>


<p>The IoT device has limited resources, and therefore we have to use a lightweight web framework. Our API doesn't need to interact with a database. We don't need a heavyweight web framework such as Django, with all its features and its integrated ORM. We want to be able to process many requests without blocking the web server. We need the web server to provide us with nice scalability ...</p></div>



  
<div><h1 class="header-title">Understanding the tasks performed by each HTTP method</h1>
                
            
            
                
<p>Let's consider that <kbd>http://localhost:8888/hexacopters/1</kbd> is the URL that identifies the hexacopter for our drone.</p>
<pre>PATCH http://localhost:8888/hexacopters/1 </pre>
<p>We have to compose and send an HTTP request with the HTTP verb (<kbd>PATCH</kbd>) and request URL (<kbd>http://localhost:8888/hexacopters/1</kbd>) to set the hexacopter's status and motor speed in RPMs. In addition, we have to provide the JSON key-value pairs with the necessary field name and the value to specify the desired speed. As a result of the request, the server will validate the provided values for the field, make sure that it is a valid speed, and make the necessary calls to adjust the speed with an asynchronous execution. After the speed for the hexacopter is set, the server will return an HTTP <kbd>200 OK</kbd> status code and a JSON body with the recently updated hexacopter values serialized to JSON:</p>
<pre>GET http://localhost:8888/hexacopters/1</pre>
<p>We have to compose and send an HTTP request with the HTTP verb (<kbd>GET</kbd>) and request URL (<kbd>http://localhost:8888/hexacopter/1</kbd>) to retrieve the current values for the hexacopter. The server will make the necessary calls to retrieve the status and the speed for the hexacopter with an asynchronous execution. As a result of the request, the server will return an HTTP <kbd>200 OK</kbd> status code and a JSON body with the serialized key-value pairs that specify the status and speed for the hexacopter. If a number different than <kbd>1</kbd> is specified, the server will return just an HTTP <kbd>404 Not Found</kbd> status:</p>
<pre>PATCH http://localhost:8888/led/{id} </pre>
<p>We have to compose and send an HTTP request with the HTTP verb (<kbd>PATCH</kbd>) and request URL (<kbd>http://localhost:8888/led/{id}</kbd>) to set the brightness level for a specific LED whose <kbd>id</kbd> matches the specified numeric value in the place where <kbd>{id}</kbd> is written. For example, if we use the request URL <kbd>http://localhost:8888/led/1</kbd>, the server will set the brightness level for the LED whose <kbd>id</kbd> matches <kbd>1</kbd>. In addition, we have to provide the JSON key-value pairs with the necessary field name and the value to specify the desired brightness level. As a result of the request, the server will validate the provided values for the field, making sure that it is a valid brightness level and making the necessary calls to adjust the brightness level with an asynchronous execution. After the brightness level for the LED is set, the server will return a <kbd>200 OK</kbd> status code and a JSON body with the recently updated LED values serialized to JSON:</p>
<pre>GET http://localhost:8888/led/{id} </pre>
<p>We have to compose and send an HTTP request with the HTTP verb (<kbd>GET</kbd>) and request URL (<kbd>http://localhost:8888/led/{id}</kbd>) to retrieve the current values for the LED whose <kbd>id</kbd> matches the specified numeric value in the place where <kbd>{id}</kbd> is written. For example, if we use the request URL <kbd>http://localhost:8888/led/1</kbd>, the server will retrieve the LED whose <kbd>id</kbd> matches <kbd>1</kbd>, that is, the green LED. The server will make the necessary calls to retrieve the values for the LED with an asynchronous execution. As a result of the request, the server will return an HTTP <kbd>200 OK</kbd> status code and a JSON body with the serialized key-value pairs that specify the values for the LED. If no LED matches the specified <kbd>id</kbd>, the server will just return an HTTP <kbd>404 Not Found</kbd> status:</p>
<pre>GET http://localhost:8888/altimeter/1?unit=feet</pre>
<p>We have to compose and send an HTTP request with the HTTP verb (<kbd>GET</kbd>) and request URL (<kbd>http://localhost:8888/altimeter/1?unit=feet</kbd>) to retrieve the current value for the altimeter in feet. The server will make the necessary calls to retrieve the value for the altimeter with an asynchronous execution. As a result of the request, the server will return an HTTP <kbd>200 OK</kbd> status code and a JSON body with the serialized key-value pairs that specify the value for the altimeter. If a number different than <kbd>1</kbd> is specified, the server will return just an HTTP <kbd>404 Not Found</kbd> status:</p>
<pre>GET http://localhost:8888/altimeter/1?unit=meters</pre>
<p>If we want to retrieve the value for the altimeter in meters, we have to compose and send an HTTP request with the HTTP verb (<kbd>GET</kbd>) and request URL (<kbd>http://localhost:8888/altimeter/1?unit=meters</kbd>).</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Setting up a virtual environment with Tornado 5.1.1</h1>
                
            
            
                
<p>In <a href="dbf75cef-4962-4e40-8192-03873b774c48.xhtml" target="_blank">Chapter 1</a>, <em>Developing RESTful APIs and Microservices with Flask 1.0.2</em>, we learned that throughout this book we are going to work with the lightweight virtual environments introduced and improved in Python 3.4. Now, we will follow many steps to create a new lightweight virtual environment to work with Tornado 5.1.1. It is highly recommended to read the section named <em>Working with lightweight virtual environments</em> in <a href="dbf75cef-4962-4e40-8192-03873b774c48.xhtml" target="_blank">Chapter 1</a>, <em>Developing RESTful APIs and Microservices with Flask 1.0.2</em>, if you don't have experience with lightweight virtual environments in modern Python. The chapter includes all the detailed explanations about the effects of the steps we are going to follow.</p>
<p>The following ...</p></div>



  
<div><h1 class="header-title">Creating classes that represent a drone</h1>
                
            
            
                
<p>We will create the following classes that we will use to represent the different components of a drone:</p>
<table style="border-collapse: collapse" border="1">
<tbody>
<tr>
<td>
<p>Class name</p>
</td>
<td>
<p>Description</p>
</td>
</tr>
<tr>
<td>
<p><kbd>HexacopterStatus</kbd></p>
</td>
<td>
<p>This class stores status data for the hexacopter</p>
</td>
</tr>
<tr>
<td>
<p><kbd>Hexacopter</kbd></p>
</td>
<td>
<p>This class represents a hexacopter</p>
</td>
</tr>
<tr>
<td>
<p><kbd>LightEmittingDiode</kbd></p>
</td>
<td>
<p>This class represents an LED connected to the drone</p>
</td>
</tr>
<tr>
<td>
<p><kbd>Altimeter</kbd></p>
</td>
<td>
<p>This class represents the altimeter that measures the current altitude for the drone</p>
</td>
</tr>
<tr>
<td>
<p><kbd>Drone</kbd></p>
</td>
<td>
<p>This class represents the drone with its different sensors and actuators</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>In a real-life example, these classes would interact with a library that interacts with sensors and actuators. In order to keep our example simple, we will make calls to <kbd>time.sleep</kbd> to simulate interactions that take some time to write values to interfaces with sensors and actuators. We will use the same procedure to simulate interactions that take some time to retrieve values from interfaces with sensors.</p>
<p>First, we will create the <kbd>Hexacopter</kbd> class, which we will use to represent the hexacopter, and a <kbd>HexacopterStatus</kbd> class, which we will use to store status data for the hexacopter.</p>
<p>Create a new Python file named <kbd>drone.py</kbd> in the root folder of the virtual environment (<kbd>Tornado01</kbd>). The following lines show all the necessary imports for the classes that we will create and the code that declares the <kbd>Hexacopter</kbd> and <kbd>HexacopterStatus</kbd> classes in this file. The code file for the sample is included in the <kbd>restful_python_2_10_01</kbd> folder, in the <kbd>Django01/drone.py</kbd> file:</p>
<pre>from time import sleep 
from random import randint 
 
 
class HexacopterStatus: 
    def __init__(self, motor_speed, is_turned_on): 
        self.motor_speed = motor_speed 
        self.is_turned_on = is_turned_on 
 
 
class Hexacopter: 
    MIN_MOTOR_SPEED = 0 
    MAX_MOTOR_SPEED = 500 
 
    def __init__(self): 
        self._motor_speed = self.__class__.MIN_MOTOR_SPEED 
        self._is_turned_on = False 
 
    @property 
    def motor_speed(self): 
        return self._motor_speed 
 
    @motor_speed.setter     
    def motor_speed(self, value): 
        if value &lt; self.__class__.MIN_MOTOR_SPEED: 
            raise ValueError('The minimum speed is {0}'.format(self.__class__.MIN_MOTOR_SPEED)) 
        if value &gt; self.__class__.MAX_MOTOR_SPEED: 
            raise ValueError('The maximum speed is {0}'.format(self.__class__.MAX_MOTOR_SPEED)) 
        sleep(2) 
        self._motor_speed = value 
        self._is_turned_on = (self.motor_speed is not 0) 
 
    @property 
    def is_turned_on(self): 
        return self._is_turned_on 
 
    @property 
    def status(self): 
        sleep(3) 
        return HexacopterStatus(self.motor_speed, self.is_turned_on) </pre>
<p>The <kbd>HexacopterStatus</kbd> class just declares a constructor, the <kbd>__init__</kbd> method. This method receives many arguments and uses them to initialize the attributes with the same names: <kbd>motor_speed</kbd> and <kbd>is_turned_on</kbd>.</p>
<p>The <kbd>Hexacopter</kbd> class declares two class attributes that specify the minimum and maximum speed values for its motor: <kbd>MIN_MOTOR_SPEED</kbd> and <kbd>MAX_MOTOR_SPEED</kbd>. The constructor, the <kbd>__init__</kbd> method, initializes the <kbd>_motor_speed</kbd> attribute with the <kbd>MIN_MOTOR_SPEED</kbd> value and sets the <kbd>_is_turned_on</kbd> attribute to <kbd>False</kbd>.</p>
<p class="mce-root"/>
<p>The <kbd>motor_speed</kbd> property getter, the <kbd>motor_speed</kbd> method that has the <kbd>@property</kbd> decorator, returns the value of the <kbd>_motor_speed</kbd> attribute. The <kbd>motor_speed</kbd> property setter, which is the <kbd>motor_speed</kbd> method that has the <kbd>@motor_speed.setter</kbd> decorator, checks whether the value for the <kbd>value</kbd> argument is in the valid range. If the validation fails, the method raises a <kbd>ValueError</kbd> exception. Otherwise, the method sets the value of the <kbd>_motor_speed</kbd> attribute with the received value and sets the value for the <kbd>_is_turned_on</kbd> attribute to <kbd>True</kbd> if the <kbd>motor_speed</kbd> property is greater than <kbd>0</kbd>. Finally, the method calls <kbd>sleep</kbd> to simulate that it takes two seconds to complete these operations.</p>
<p>The <kbd>is_turned_on</kbd> property getter, the <kbd>is_turned_on</kbd> method that has the <kbd>@property</kbd> decorator, returns the value of the <kbd>_is_turned_on</kbd> attribute. The <kbd>status</kbd> property getter calls <kbd>sleep</kbd> to simulate that it takes three seconds to retrieve the hexacopter status and then returns a <kbd>HexacopterStatus</kbd> instance initialized with the <kbd>motor_speed</kbd> and <kbd>turned_on</kbd> property values.</p>
<p>Stay in the <kbd>drones.py</kbd> file in the root folder for the virtual environment (<kbd>Tornado01</kbd>). Add the following lines to declare a <kbd>LightEmittingDiode</kbd> class that we will use to represent each LED. The code file for the sample is included in the <kbd>restful_python_2_10_01</kbd> folder, in the <kbd>Django01/drone.py</kbd> file:</p>
<pre>class LightEmittingDiode: 
    MIN_BRIGHTNESS_LEVEL = 0 
    MAX_BRIGHTNESS_LEVEL = 255 
 
    def __init__(self, id, description): 
        self.id = id 
        self.description = description 
        self._brightness_level = self.__class__.MIN_BRIGHTNESS_LEVEL 
 
    @property 
    def brightness_level(self): 
        sleep(1) 
        return self._brightness_level 
 
    @brightness_level.setter 
    def brightness_level(self, value): 
        if value &lt; self.__class__.MIN_BRIGHTNESS_LEVEL: 
            raise ValueError('The minimum brightness level is {0}'.format(self.__class__.MIN_BRIGHTNESS_LEVEL)) 
        if value &gt; self.__class__.MAX_BRIGHTNESS_LEVEL: 
            raise ValueError('The maximum brightness level is {0}'.format(self.__class__.MAX_BRIGHTNESS_LEVEL)) 
        sleep(2) 
        self._brightness_level = value</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>The <kbd>LightEmittingDiode</kbd> class declares two class attributes that specify the minimum and maximum brightness level values for an LED: <kbd>MIN_BRIGHTNESS_LEVEL</kbd> and <kbd>MAX_BRIGHTNESS_LEVEL</kbd>. The constructor, the <kbd>__init__</kbd> method, initializes the <kbd>_brightness_level</kbd> attribute with the <kbd>MIN_BRIGHTNESS_LEVEL</kbd> and the <kbd>id</kbd> and <kbd>description</kbd> attributes with the values received in the arguments with the same names.</p>
<p>The <kbd>brightness_level</kbd> property getter, the <kbd>brightness_level</kbd> method that has the <kbd>@property</kbd> decorator, calls <kbd>sleep</kbd> to simulate it taking <kbd>1</kbd> second to retrieve the brightness level for the wired LED, and then returns the value of the <kbd>_brightness_level</kbd> attribute.</p>
<p>The <kbd>brightness_level</kbd> property setter, the <kbd>brightness_level</kbd> method that has the <kbd>@brightness_level.setter</kbd> decorator, checks whether the value for the <kbd>value</kbd> argument is in the valid range. If the validation fails, the method raises a <kbd>ValueError</kbd> exception. Otherwise, the method calls <kbd>sleep</kbd> to simulate it taking two seconds to set the new brightness level and finally sets the value of the <kbd>_brightness_level</kbd> attribute with the received value.</p>
<p>Stay in the <kbd>drones.py</kbd> file in the root folder for the virtual environment (<kbd>Tornado01</kbd>). Add the following lines to declare an <kbd>Altimeter</kbd> class that we will use to represent the altimeter. The code file for the sample is included in the <kbd>restful_python_2_10_01</kbd> folder, in the <kbd>Django01/drone.py</kbd> file:</p>
<pre>class Altimeter: 
    @property 
    def altitude(self): 
        sleep(1) 
        return randint(0, 3000) </pre>
<p>The <kbd>Altimeter</kbd> class declares an <kbd>altitude</kbd> property setter that calls <kbd>sleep</kbd> to simulate it taking one second to retrieve the altitude from the altimeter, and finally generates a random integer from <kbd>0</kbd> to <kbd>3000</kbd> (inclusive) and returns it.</p>
<p>Stay in the <kbd>drones.py</kbd> file in the root folder for the virtual environment (<kbd>Tornado01</kbd>). Add the following lines to declare a <kbd>Drone</kbd> class, which we will use to represent the drone with its sensors and actuators. The code file for the sample is included in the <kbd>restful_python_2_10_01</kbd> folder, in the <kbd>Django01/drone.py</kbd> file:</p>
<pre>class Drone: 
    def __init__(self): 
        self.hexacopter = Hexacopter() 
        self.altimeter = Altimeter() 
        self.red_led = LightEmittingDiode(1, 'Red LED') 
        self.green_led = LightEmittingDiode(2, 'Green LED') 
        self.blue_led = LightEmittingDiode(3, 'Blue LED') 
        self.leds = { 
            self.red_led.id: self.red_led, 
            self.green_led.id: self.green_led, 
            self.blue_led.id: self.blue_led} </pre>
<p>The <kbd>Drone</kbd> class just declares a constructor, the <kbd>__init__</kbd> method, which creates instances of the previously declared classes that represent the different components for the drone. The <kbd>leds</kbd> attribute saves a dictionary that has a key-value pair for each <kbd>LightEmittingDiode</kbd> instance with its <kbd>id</kbd> and its instance.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Writing request handlers</h1>
                
            
            
                
<p>The main building blocks for a RESTful API in Tornado are subclasses of the <kbd>tornado.web.RequestHandler</kbd> class, that is, the base class for HTTP request handlers in Tornado. We just need to perform the following tasks to build our RESTful API that interacts with a drone:</p>
<ol>
<li>Create a subclass of the <kbd>RequestHandler</kbd> class and declare the methods for each supported HTTP verb</li>
<li>Override the methods to handle HTTP requests</li>
<li>Map the URL patterns to each subclass of the <kbd>RequestHandler</kbd> superclass in the <kbd>tornado.web.Application</kbd> instance that represents the Tornado web application</li>
</ol>
<p>We will create the following subclasses of the <kbd>RequestHandler</kbd> class:</p>
<table style="border-collapse: collapse" border="1">
<tbody>
<tr>
<td>
<p>Class name</p>
</td>
<td>
<p>Description</p>
</td>
</tr>
<tr>
<td>
<p><kbd>HexacopterHandler</kbd></p>
</td>
<td>
<p>This class processes the HTTP ...</p></td></tr></tbody></table></div>



  
<div><h1 class="header-title">Mapping URL patterns to request handlers</h1>
                
            
            
                
<p>The following table shows the method of our previously created HTTP handler classes that we want to be executed for each combination of HTTP verb and scope:</p>
<table style="border-collapse: collapse" border="1">
<tbody>
<tr>
<td>
<p>HTTP verb</p>
</td>
<td>
<p>Scope</p>
</td>
<td>
<p>Class and method</p>
</td>
</tr>
<tr>
<td>
<p><kbd>GET</kbd></p>
</td>
<td>
<p>Altimeter</p>
</td>
<td>
<p><kbd>AltimeterHandler.get</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>GET</kbd></p>
</td>
<td>
<p>Hexacopter</p>
</td>
<td>
<p><kbd>HexacopterHandler.get</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>PATCH</kbd></p>
</td>
<td>
<p>Hexacopter</p>
</td>
<td>
<p><kbd>HexacopterHandler.patch</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>GET</kbd></p>
</td>
<td>
<p>LED</p>
</td>
<td>
<p><kbd>LedHandler.get</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>PATCH</kbd></p>
</td>
<td>
<p>LED</p>
</td>
<td>
<p><kbd>LedHandler.patch</kbd></p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>If the request results in the invocation of an HTTP handler class with an unsupported HTTP method, Tornado will return a response with the HTTP <kbd>405 Method Not Allowed</kbd> status code.</p>
<p>Now, we must map URL patterns to our previously coded subclasses of the <kbd>RequestHandler</kbd> superclass. Stay in the <kbd>drone_service.py</kbd> file in the root folder for the virtual environment (<kbd>Tornado01</kbd>). Add the following lines to declare the <kbd>Application</kbd> class and the <kbd>__main__</kbd> method. The code file for the sample is included in the <kbd>restful_python_2_10_01</kbd> folder, in the <kbd>Django01/drone_service.py</kbd> file:</p>
<pre>class Application(web.Application): 
    def __init__(self, **kwargs): 
        handlers = [ 
            (r"/hexacopters/([0-9]+)", HexacopterHandler), 
            (r"/leds/([0-9]+)", LedHandler), 
            (r"/altimeters/([0-9]+)", AltimeterHandler), 
        ] 
        super(Application, self).__init__(handlers, **kwargs) 
 
 
if __name__ == "__main__": 
    application = Application() 
    port = 8888 
    print("Listening at port {0}".format(port)) 
    application.listen(port) 
    tornado_ioloop = ioloop.IOLoop.instance() 
    periodic_callback = ioloop.PeriodicCallback(lambda: None, 500) 
    periodic_callback.start() 
    tornado_ioloop.start()</pre>
<p>The code declares an <kbd>Application</kbd> class as a subclass of the <kbd>tornado.web.Application</kbd> superclass. This class overrides the inherited constructor, that is, the <kbd>__init__</kbd> method. The constructor declares the <kbd>handlers</kbd> list that maps URL patterns to synchronous request handlers and then calls the inherited constructor with the list as one of its arguments. The <kbd>handlers</kbd> list is composed of a regular expression (<kbd>regexp</kbd>) and a <kbd>tornado.web.RequestHandler</kbd> subclass (<kbd>request_class</kbd>).</p>
<p>Then, the <kbd>main</kbd> method creates an instance of the <kbd>Application</kbd> class and calls the <kbd>application.listen</kbd> method to build an HTTP server for the application with the defined rules on the specified port. In this case, the code specifies <kbd>8888</kbd> as the port, saved in the <kbd>port</kbd> variable, which is the default port for Tornado HTTP servers.</p>
<p>Then, the code registers and starts a periodic callback, named <kbd>periodic_callback</kbd>, that will be executed every 500 milliseconds by the <kbd>IOLoop</kbd> to make it possible to use <em>Ctrl</em> + <em>C</em> to stop the HTTP server. This code will be useful for the second version of our API. However, we write it now to avoid editing the code later.</p>
<p>Finally, the code calls the <kbd>tornado_ioloop.start</kbd> method to start the server. This server was created with the previous call to the <kbd>application.listen</kbd> method. </p>


            

            
        
    </div>



  
<div><h1 class="header-title">Making HTTP requests to the Tornado API</h1>
                
            
            
                
<p>Now, we can run the <kbd>drone_service.py</kbd> script, which launches the development server for Tornado 5.1.1 to compose and send HTTP requests to our unsecured and simple web API. Execute the following command:</p>
<pre>    <strong>python drone_service.py</strong></pre>
<p>The following lines show the output after we execute the previous command. The Tornado HTTP development server is listening on port <kbd>8888</kbd>:</p>
<pre>    <strong>Listening at port 8888</strong></pre>
<p>With the previous command, we will start the Tornado HTTP server and it will listen on every interface on port <kbd>8888</kbd>. Thus, if we want to make HTTP requests to our API from other computers or devices connected to our LAN, we don't need any additional configurations.</p>

<p>If you decide to compose and send HTTP requests from ...</p></div>



  
<div><h1 class="header-title">Working with command-line tools - curl and httpie</h1>
                
            
            
                
<p>We will start composing and sending HTTP requests with the <kbd>curl</kbd> and HTTPie command-line tools, which we introduced in <a href="dbf75cef-4962-4e40-8192-03873b774c48.xhtml" target="_blank">Chapter 1</a>, <em>Developing RESTful APIs and Microservices with Flask 1.0.2</em>, in the section named <em>Working with command-line tools - curl and httpie</em>. Make sure you read this section before executing the next examples.</p>
<p>Whenever we compose HTTP requests with the command line, we will use two versions of the same command: the first one with HTTPie and the second one with <kbd>curl</kbd>. This way, you will be able to use the most convenient for you.</p>
<p>Make sure you leave the Tornado 5.1.1 development server running. Don't close the Terminal or Command Prompt that is running this development server. Open a new Terminal in macOS or Linux, or a Command Prompt in Windows, activate the virtual environment we have been using, and run the following command. We will compose and send an HTTP <kbd>PATCH</kbd> request to turn on the hexacopter and set its motor speed to <kbd>50</kbd> RPMs. The code file for the sample is included in the <kbd>restful_python_2_10_01</kbd> folder, in the <kbd>Tornado01/cmd/cmd1101.txt</kbd> file:</p>
<pre>    <strong>http PATCH ":8888/hexacopters/1" motor_speed_in_rpm=50</strong></pre>
<p>The following is the equivalent <kbd>curl</kbd> command. The code file for the sample is included in the <kbd>restful_python_2_10_01</kbd> folder, in the <kbd>Tornado01/cmd/cmd1102.txt</kbd> file:</p>
<pre> <strong>curl -iX PATCH -H "Content-Type: application/json" -d '{"motor_speed_in_rpm":50}' "localhost:8888/hexacopters/1"</strong>
  </pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>The previous commands will compose and send the HTTP request <kbd>PATCH http://localhost:8888/hexacopters/1</kbd> with the following JSON key-value pair:</p>
<pre>{  
   "motor_speed_in_rpm": 50 
} </pre>
<p>The request specifies <kbd>/hexacopters/1</kbd>, and therefore Tornado will iterate over the list of tuples with regular expressions and request classes, and will match the <kbd>'/hexacopters/([0-9]+)'</kbd> regular expression. Tornado will create an instance of the <kbd>HexacopterHandler</kbd> class and run the <kbd>HexacopterHandler.patch</kbd> method with <kbd>1</kbd> as the value for the <kbd>id</kbd> argument.</p>
<p>As the HTTP verb for the request is <kbd>PATCH</kbd>, Tornado calls the <kbd>patch</kbd> method. If the hexacopter's speed is successfully set, the method returns an HTTP <kbd>200 OK</kbd> status code and the key-value pairs with the speed and status for the recently updated hexacopter serialized to JSON in the response body. The following lines show an example response for the HTTP request:</p>
<pre>    <strong>HTTP/1.1 200 OK</strong>
    <strong>Content-Length: 48</strong>
    <strong>Content-Type: application/json; charset=UTF-8</strong>
    <strong>Date: Tue, 30 Oct 2018 17:01:06 GMT</strong>
    <strong>Server: TornadoServer/5.1.1</strong>
    
    <strong>{</strong>
    <strong>    "is_turned_on": true, </strong>
    <strong>    "motor_speed_in_rpm": 50</strong>
    <strong>}</strong>
  </pre>
<p>Now, we will write a command to compose and send an HTTP <kbd>GET</kbd> request to retrieve the status and the motor speed for the hexacopter. Run the following command. The code file for the sample is included in the <kbd>restful_python_2_10_01</kbd> folder, in the <kbd>Tornado01/cmd/cmd1103.txt</kbd> file:</p>
<pre>    <strong>http ":8888/hexacopters/1"</strong></pre>
<p>The following is the equivalent <kbd>curl</kbd> command. The code file for the sample is included in the <kbd>restful_python_2_10_01</kbd> folder, in the <kbd>Tornado01/cmd/cmd1104.txt</kbd> file:</p>
<pre>    <strong>curl -iX GET -H "localhost:8888/hexacopters/1"</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The previous commands will compose and send the following HTTP request: <kbd>GET http://localhost:8888/hexacopters/1</kbd>. The request specifies <kbd>/hexacopters/1</kbd>, and therefore it will match the <kbd>'/hexacopters/([0-9]+)'</kbd> regular expression and run the <kbd>HexacopterHandler.get</kbd> method with <kbd>1</kbd> as the value for the <kbd>id</kbd> argument. As the HTTP verb for the request is <kbd>GET</kbd>, Tornado calls the <kbd>get</kbd> method. The method retrieves the hexacopter's status and generates a JSON response with the key-value pairs.</p>
<p>The following lines show an example response for the HTTP request. The first lines show the HTTP response headers, including the status (<kbd>200 OK</kbd>) and the content type (<kbd>application/json</kbd>). After the HTTP response headers, we can see the details for the hexacopter's status in the JSON response:</p>
<pre>    <strong>HTTP/1.1 200 OK</strong>
    <strong>Content-Length: 48</strong>
    <strong>Content-Type: application/json; charset=UTF-8</strong>
    <strong>Date: Tue, 30 Oct 2018 17:06:10 GMT</strong>
    <strong>Etag: "172316bfc38ea5a04857465b888cff65c72a228c"</strong>
    <strong>Server: TornadoServer/5.1.1</strong>
    
    <strong>{</strong>
    <strong>    "is_turned_on": true, </strong>
    <strong>    "motor_speed_in_rpm": 50</strong>
    <strong>}</strong>
  </pre>
<p>After we run the two requests, we will see the following lines in the window that is running the Tornado HTTP server. The output shows the results of executing the print statements that describe when the code started setting or retrieving information, and when it finished:</p>
<pre>    <strong>I've started setting the hexacopter's motor speed</strong>
    <strong>I've finished setting the hexacopter's motor speed</strong>
    <strong>I've started retrieving the hexacopter's status</strong>
    <strong>I've finished retrieving the hexacopter's status</strong></pre>
<p>The different methods we coded in the request handler classes end up calling <kbd>time.sleep</kbd> to simulate the operations taking some time with the hexacopter. In this case, our code is running with a synchronous execution, and therefore each time we compose and send a request, the Tornado server is blocked until the operation with the hexacopter finishes and the method sends the response. We will create a new version of this API that will use an asynchronous execution later, and will understand the advantages of Tornado's non-blocking features. However, first, we will understand how the synchronous version of the API works.</p>
<p class="mce-root"/>
<p>The following screenshot shows two Terminal windows side by side on macOS. The Terminal window on the left-hand side is running the Tornado HTTP server and displays the messages printed in the methods that process the HTTP requests. The Terminal window on the right-hand side is running <kbd>http</kbd> commands to generate the HTTP requests. It is a good idea to use a similar configuration to check the output while we compose and send the HTTP requests:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/f0848a1c-faa5-48a8-b90e-5fcb8a853cff.png" width="1219" height="486"/></p>
<p>Now, we will write a command to compose and send an HTTP request to retrieve a hexacopter that doesn't exist. Remember that we just have one hexacopter in our drone. Run the following command to try to retrieve the status for a hexacopter with an invalid <kbd>id</kbd>. We must make sure that the utilities display the headers as part of the response to see the returned status code. The code file for the sample is included in the <kbd>restful_python_2_10_01</kbd> folder, in the <kbd>Tornado01/cmd/cmd1105.txt</kbd> file:</p>
<pre>    <strong>http ":8888/hexacopters/5"</strong></pre>
<p>The following is the equivalent <kbd>curl</kbd> command. The code file for the sample is included in the <kbd>restful_python_2_10_01</kbd> folder, in the <kbd>Tornado01/cmd/cmd1106.txt</kbd> file:</p>
<pre>    <strong>curl -iX GET "localhost:8888/hexacopters/5"</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>The previous commands will compose and send the following HTTP request: <kbd>GET http://localhost:8888/hexacopters/5</kbd>. The request is the same as the previous one we have analyzed, with a different number for the <kbd>id</kbd> parameter. The server will run the <kbd>HexacopterHandler.get</kbd> method with <kbd>5</kbd> as the value for the <kbd>id</kbd> argument. The <kbd>id</kbd> is not equal to <kbd>1</kbd>, and therefore the code will return an HTTP <kbd>404 Not Found</kbd> status code. The following lines show an example header response for the HTTP request:</p>
<pre>    <strong>HTTP/1.1 404 Not Found</strong>
    <strong>Content-Length: 0</strong>
    <strong>Content-Type: text/html; charset=UTF-8</strong>
    <strong>Date: Tue, 30 Oct 2018 17:22:13 GMT</strong>
    <strong>Server: TornadoServer/5.1.1</strong></pre>
<p>Now, we will write a command to compose and send an HTTP <kbd>GET</kbd> request to retrieve the altitude from the altimeter included in the drone, expressed in meters. Run the following command. The code file for the sample is included in the <kbd>restful_python_2_10_01</kbd> folder, in the <kbd>Tornado01/cmd/cmd1107.txt</kbd> file:</p>
<pre>    <strong>http ":8888/altimeters/1?unit=meters"</strong></pre>
<p>The following is the equivalent <kbd>curl</kbd> command. The code file for the sample is included in the <kbd>restful_python_2_10_01</kbd> folder, in the <kbd>Tornado01/cmd/cmd1108.txt</kbd> file:</p>
<pre>    <strong>curl -iX GET -H "localhost:8888/altimeters/1?unit=meters"</strong></pre>
<p>The previous commands will compose and send the following HTTP request: <kbd>GET http://localhost:8888/altimeters/1?unit=meters</kbd>. The request specifies <kbd>/altimeters/1</kbd>, and therefore it will match the <kbd>'/altimeters/([0-9]+)'</kbd> regular expression and run the <kbd>AltimeterHandler.get</kbd> method with <kbd>1</kbd> as the value for the <kbd>id</kbd> argument. As the HTTP verb for the request is <kbd>GET</kbd>, Tornado calls the <kbd>get</kbd> method. The method will retrieve the value for the unit query parameter, retrieve the altimeter's altitude in feet, convert it to meters, and generate a JSON response with the key-value pairs.</p>
<p>The following lines show an example response for the HTTP request:</p>
<pre>    <strong>HTTP/1.1 200 OK</strong>
    <strong>Content-Length: 49</strong>
    <strong>Content-Type: application/json; charset=UTF-8</strong>
    <strong>Date: Tue, 30 Oct 2018 17:35:59 GMT</strong>
    <strong>Etag: "e6bef0812295935473bbef8883a144a7740d4838"</strong>
    <strong>Server: TornadoServer/5.1.1</strong>
    
    <strong>{</strong>
    <strong>    "altitude": 126.7968, </strong>
    <strong>    "unit": "meters"</strong>
    <strong>}</strong>
  </pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Now, we will write a command to compose and send an HTTP <kbd>GET</kbd> request to retrieve the altitude from the altimeter included in the drone, expressed in the default unit: feet. Run the following command. The code file for the sample is included in the <kbd>restful_python_2_10_01</kbd> folder, in the <kbd>Tornado01/cmd/cmd1109.txt</kbd> file:</p>
<pre>    <strong>http ":8888/altimeters/1"</strong> </pre>
<p>The following is the equivalent <kbd>curl</kbd> command. The code file for the sample is included in the <kbd>restful_python_2_10_01</kbd> folder, in the <kbd>Tornado01/cmd/cmd1110.txt</kbd> file:</p>
<pre>    <strong>curl -iX GET -H "localhost:8888/altimeters/1"</strong></pre>
<p>The previous commands will compose and send the following HTTP request: <kbd>GET http://localhost:8888/altimeters/1</kbd>. The request specifies <kbd>/altimeters/1</kbd>, and therefore it will match the <kbd>'/altimeters/([0-9]+)'</kbd> regular expression and run the <kbd>AltimeterHandler.get</kbd> method with <kbd>1</kbd> as the value for the <kbd>id</kbd> argument. As the HTTP verb for the request is <kbd>GET</kbd>, Tornado calls the <kbd>get</kbd> method. In this case, there is no unit query parameter, and therefore the method will retrieve the altimeter's altitude in feet and generate a JSON response with the key-value pairs.</p>
<p>The following lines show an example response for the HTTP request:</p>
<pre>    <strong>HTTP/1.1 200 OK</strong>
    <strong>Content-Length: 33</strong>
    <strong>Content-Type: application/json; charset=UTF-8</strong>
    <strong>Date: Tue, 30 Oct 2018 17:38:58 GMT</strong>
    <strong>Etag: "985cc8ce1bddf8a96b2a06a76d14faaa5bc03c9b"</strong>
    <strong>Server: TornadoServer/5.1.1</strong>
    
    <strong>{</strong>
    <strong>    "altitude": 263, </strong>
    <strong>    "unit": "feet"</strong>
    <strong>}</strong>
  </pre>
<p>Notice that the altitude value is a random number generated each time we require it.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>


            

            
        
    </div>



  
<div><h1 class="header-title">Working with GUI tools - Postman and others</h1>
                
            
            
                
<p>So far, we have been working with two terminal-based or command-line tools to compose and send HTTP requests to our Django development server: cURL and HTTPie. Now, we will work with one of the GUI tools we used when composing and sending HTTP requests to the Flask development server in <a href="dbf75cef-4962-4e40-8192-03873b774c48.xhtml" target="_blank">Chapter 1</a>, <em>Developing RESTful APIs and Microservices with Flask 1.0.2</em>. In case you skipped this chapter, make sure you check the installation instructions in the section named <em>Working with GUI tools - Postman and others</em>.</p>
<p>Once you launch Postman, make sure you close the modal that provides shortcuts to common tasks. Select the GET request in the + new drop-down menu in the upper-left corner of the Postman main window. ...</p></div>



  
<div><h1 class="header-title">Running unit tests with pytest and checking testing coverage</h1>
                
            
            
                
<p>Now, we will use the <kbd>pytest</kbd> command to run tests and measure their code coverage. Make sure you run the command in the Terminal or Command Prompt window in which you have activated the virtual environment, and that you are located within its root folder (<kbd>Tornado01</kbd>). Run the following command:</p>
<pre>    <strong>pytest --cov -v</strong>  </pre>
<p>The test runner will execute all the functions defined in <kbd>tests.py</kbd> that start with the <kbd>test_</kbd> prefix, and will display the results. We use the <kbd>-v</kbd> option to instruct <kbd>pytest</kbd> to print the test function names and statuses in verbose mode. The <kbd>--cov</kbd> option turns on test coverage report generation with the use of the <kbd>pytest-cov</kbd> plugin.</p>
<p>The following lines show the sample output:</p>
<pre><strong>================================================ test session starts =================================================</strong>
<strong>platform darwin -- Python 3.7.1, pytest-4.0.2, py-1.7.0, pluggy-0.8.0 -- /Users/gaston/HillarPythonREST2/Tornado01/bin/python3</strong>
<strong>cachedir: .pytest_cache</strong>
<strong>rootdir: /Users/gaston/HillarPythonREST2/Tornado01, inifile: <br/>setup.cfg</strong>
<strong>plugins: tornasync-0.5.0, cov-2.6.0</strong>
<strong>collected 1 item                                                                                                     </strong>
    
<strong>tests.py::test_set_and_get_leds_brightness_levels PASSED                                                       [100%]</strong>
    
 <strong>---------- coverage: platform darwin, python 3.6.6-final-0 -----------<br/></strong> <strong>-</strong>
    <strong>Name                     Stmts   Miss Branch BrPart  Cover</strong>
    <strong>----------------------------------------------------------</strong>
    <strong>async_drone_service.py     141     81     20      4    40%</strong>
    <strong>drone.py                    63     23     10      3    59%</strong>
    <strong>----------------------------------------------------------</strong>
    <strong>TOTAL                      204    104     30      7    46%</strong>
  </pre>
<p>The output provides details that the test runner discovered and executed one test, which passed. The output displays the module and function names for each method in the <kbd>test_views</kbd> module that started with the <kbd>test_</kbd> prefix and represented a test to be executed.</p>
<p>The test code coverage measurement report provided by the <kbd>coverage</kbd> package, in combination with the <kbd>pytest-cov</kbd> plugin, uses the code analysis tools and the tracing hooks included in the Python standard library to determine which lines of code are executable and which of these lines have been executed. The report provides a table with the columns we examined in <a href="59ca9314-9d32-4507-b260-7f38c82798f2.xhtml" target="_blank">Chapter 4</a>, <em>Testing and Deploying an API in a Microservice with Flask</em>, in the section named <em>Running unit tests with pytest and checking testing coverage</em>.</p>
<p>We definitely have a very low coverage for the <kbd>async_drone_service.py</kbd> and <kbd>drone.py</kbd> modules, based on the measurements shown in the report. In fact, we just wrote one test related to LEDs, and therefore it makes sense that the coverage has to be improved. We didn't create tests related to other hexacopter resources.</p>
<p>Now, run the <kbd>coverage</kbd> command with the <kbd>-m</kbd> command-line option to display the line numbers of the missing statements in a new <kbd>Missing</kbd> column:</p>
<pre>    <strong>coverage report -m</strong></pre>
<p>The command will use the information from the last execution and will display the missing statements and the missing branches. The next lines show a sample output that corresponds to the previous execution of the unit tests. A dash (<kbd>-</kbd>) is used to indicate a range of lines that were missed. For example, <kbd>107-109</kbd> means that lines <kbd>107</kbd> and <kbd>109</kbd> were missing statements. A dash followed by a greater than sign (<kbd>-&gt;</kbd>) indicates that the branch from the line before <kbd>-&gt;</kbd> to the line after it was missed. For example, <kbd>61-&gt;62</kbd> means that the branch from line <kbd>61</kbd> to line <kbd>62</kbd> was missed:</p>
<pre><strong>Name                     Stmts   Miss Branch BrPart  Cover   Missing</strong>
<strong>---------------------------------------------------------------------</strong>
<strong>async_drone_service.py     141     81     20      4    40%   20-32, 36, <br/>40-67, 71-73, 84-86, 107-109, 114-116, 129-135, 148-168, 172, 186-193, 83-&gt;84, 106-&gt;107, 112-&gt;114, 185-&gt;186</strong>
<strong>drone.py                    63     23     10      3    59%   7-8, 21, 25-31, 35, 39-40, 60, 62, 70-71, 88-93, 59-&gt;60, 61-&gt;62, 87-&gt;88</strong>
<strong>----------------------------------------------------------------------</strong>
<strong>TOTAL                      204    104     30      7    46%</strong>
  </pre>
<p>Now, run the following command to get annotated HTML listings detailing missed lines. The command won't produce any output:</p>
<pre>    <strong>coverage html</strong></pre>
<p>Open the <kbd>index.html</kbd> HTML file generated in the <kbd>htmlcov</kbd> folder with your web browser. The following screenshot shows an example report coverage generated in HTML format:</p>
<div><img src="img/958a3197-7bfd-4bf5-aa07-81806eb54aa0.png" width="1211" height="322"/></div>
<p>Click or tap <kbd>async_drone_service.py</kbd> and the web browser will render a web page that displays the statements that were run, the missing ones, the excluded, and the partially executed with different colors. We can click or tap on the run, missing, excluded, and partial buttons to show or hide the background color that represents the status for each line of code. By default, the missing lines of code will be displayed with a pink background, and those partially executed will be displayed with a yellow background­­<sub>­­</sub>. Thus, we must write unit tests that target these lines of code to improve our test coverage.</p>
<p class="mce-root"/>
<p>The following screenshot shows the buttons with the summary:</p>
<div><img src="img/63db9824-4440-4190-8a3a-011e7013235d.png" style="width:32.92em;height:48.67em;" width="992" height="1466"/></div>
<p>The next screenshot shows the highlighted missing lines and the partially evaluated branches for some lines of code in the <kbd>async_drone_service.py</kbd> module:</p>
<div><img src="img/bb9ce674-14ed-4293-9059-b352ddf91fb0.png" width="1209" height="888"/></div>


            

            
        
    </div>



  
<div><h1 class="header-title">Test your knowledge</h1>
                
            
            
                
<p>Let's see whether you can answer the following questions correctly:</p>
<ol>
<li>Which of the following methods allows us to set the HTTP status code for a response in a subclass of <kbd>tornado.web.RequestHandler</kbd>?
<ol>
<li><kbd>self.write_status</kbd></li>
<li><kbd>self.__cls__.write_status_code</kbd></li>
<li><kbd>self.set_satus</kbd></li>
</ol>
</li>
</ol>
<ol start="2">
<li>Which of the following methods allows us to write the response in a subclass of <kbd>tornado.web.RequestHandler</kbd>?
<ol>
<li><kbd>self.write_response</kbd></li>
<li><kbd>self.write</kbd></li>
<li><kbd>self.set_response</kbd></li>
</ol>
</li>
</ol>
<ol start="3">
<li>The main building blocks for a RESTful API in Tornado are subclasses of which of the following classes?
<ol>
<li><kbd>tornado.web.GenericHandler</kbd></li>
<li><kbd>tornado.web.RequestHandler</kbd></li>
<li><kbd>tornado.web.IncomingHTTPRequestHandler</kbd></li>
</ol>
</li>
</ol>
<ol start="4">
<li>If we just want to support the <kbd>GET</kbd> and <kbd>PATCH</kbd> methods, we can override the <kbd>SUPPORTED_METHODS</kbd> class ...</li></ol></div>



  
<div><h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we designed a RESTful API to interact with slow sensors and actuators. We defined the requirements for our API and understood the tasks performed by each HTTP method. We set up a virtual environment with Tornado.</p>
<p>We created the classes that represent a drone and wrote code to simulate the slow I/O operations that are called for each HTTP request method. We wrote classes that represent request handlers and process the different HTTP requests, and we configured the URL patterns to route URLs to request handlers and their methods.</p>
<p>Finally, we started the Tornado development server and we used command-line tools to compose and send HTTP requests to our RESTful API, and analyzed how each HTTP request was processed in our code. We also worked with GUI tools to compose and send HTTP requests. We realized that each HTTP request takes some time to provide a response due to the simulation of slow I/O operations.</p>
<p>Now that we understand the basics of Tornado to create RESTful APIs, we will take advantage of the non-blocking features, combined with asynchronous operations in Tornado, in a new version of the API for which we will write units tests, which are the topic of the next chapter.</p>


            

            
        
    </div>



  </body></html>