- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Authentication and Authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter of our *FastAPI Cookbook*, we will delve into the critical realms
    of authentication and authorization, laying the foundation to secure your web
    applications against unauthorized access.
  prefs: []
  type: TYPE_NORMAL
- en: As we navigate through this chapter, you’ll embark on a practical journey to
    implement a comprehensive security model in your FastAPI applications. From the
    basics of user registration and authentication to the integration of sophisticated
    **OAuth2** protocols with **JSON Web Token** (**JWT**) for enhanced security,
    this chapter covers it all.
  prefs: []
  type: TYPE_NORMAL
- en: We will create the essential components of **software as a service** (**SaaS**)
    to help you learn practically how to establish user registration systems, verify
    users, and handle sessions efficiently. We’ll also show you how to apply **role-based
    access control** (**RBAC**) to adjust user permissions and protect API endpoints
    with API key authentication. The incorporation of third-party authentication using
    external login services, such as GitHub, will demonstrate how to leverage existing
    platforms for user authentication, simplifying the login process for your users.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, you’ll add an extra layer of security by implementing **multi-factor
    authentication** (**MFA**), ensuring that your application’s security is robust
    against various attack vectors.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up user registration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with OAuth2 and JWT for authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up RBAC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using third-party authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing MFA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling API key authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling session cookies and logout functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To dive into the chapter and follow along with recipes on authentication and
    authorization, ensure your setup includes the following essentials:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**: Install a Python version higher than 3.9 in your environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**FastAPI**: This should be installed with all required dependencies. If you
    didn’t do so during the previous chapters, you can simply do it from your terminal:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The code used in the chapter is hosted on GitHub at [https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter04](https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter04).
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting up a virtual environment for the project within the project root folder
    is also recommended to manage dependencies efficiently and maintain project isolation.
    Within your virtual environment, you can install all the dependencies at once
    by using the `requirements.txt` file, provided in the GitHub repository in the
    project folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Since the interactive Swagger documentation is limited at the time of writing,
    a basic mastering of **Postman** or any other testing API is beneficial to test
    our API.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have this ready, we can begin preparing our recipes.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up user registration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: User registration is the first step in securing your FastAPI application. It
    involves collecting user details and storing them securely. Here’s how you can
    set up a basic user registration system. The recipe will show you how to set up
    a FastAPI application’s registration system.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will start by storing users in an SQL database. Let’s create a project root
    folder called `saas_app`, containing the code base.
  prefs: []
  type: TYPE_NORMAL
- en: To store user passwords, we will use an external package to hash plain text
    with the **bcrypt** algorithm. The hashing function transforms a text string into
    a unique and irreversible output, allowing for secure storage of sensitive data
    such as passwords. You can find more details at [https://en.wikipedia.org/wiki/Hash_function](https://en.wikipedia.org/wiki/Hash_function).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you haven’t installed packages from `requirements.txt` from the GitHub repository
    of the chapter under the `saas_app` project folder,, you can install the `passlib`
    package with `bycrypt` by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You will also need to install a version of `sqlalchemy` higher than 2.0.0 to
    follow along with the code in the GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Our environment is now ready to implement the user registration in our SaaS.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before starting the implementation, we need to set up the database to store
    our users.
  prefs: []
  type: TYPE_NORMAL
- en: We need to set up a `sqlalchemy` for the application to store user credentials.
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Set up a `User` class to map the users table in the SQL database. The table
    should contain the `id`, `username`, `email`, and `hashed_password` fields.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Establish the connection between the application and the database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First let's create our project root folder called `saas_app`. Then you can refer
    to the *Setting up SQL databases* recipe in [*Chapter 2*](B21025_02.xhtml#_idTextAnchor052),
    *Working with Data*, or copy the `database.py` and `db_connection.py` modules
    from the GitHub repository under your root folder.
  prefs: []
  type: TYPE_NORMAL
- en: With the database session set up, let’s define the function that adds a user.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s make it into a dedicated module called `operations.py`, in which we will
    define all the support functions used by the API endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function will use a password context object from the `bcrypt` package to
    hash plain text passwords. We can define it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then define the `add_user` function, which inserts a new user into the
    database with the hashed password, according to most of data compliance regulations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`InegrityError` will take into account the attempt to add a username or email
    that already exists.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have to define our endpoint, but first, we need to set up our server
    and initialize the database connection. We can do it in the `main.py` module,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We use the `lifespan` parameter of the `FastAPI` object to instruct the server
    to sync our database class, `User`, with the database when it starts up.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, we can create a separate module, `responses.py`, to keep the response
    classes used for different endpoints. Feel free to create your own or copy the
    one provided in the GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now write the suitable endpoint to sign up a user in the same `main.py`
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We have just implemented a basic mechanism to register and store users in our
    SaaS database.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The endpoint will accept a JSON body containing a username, email, and password.
  prefs: []
  type: TYPE_NORMAL
- en: If the username or email already exists, a `409` response will be returned,
    and user creation will be disallowed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test this, at the project root level, spin up the server by running the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Then, connect with your browser at `localhost:8000/docs` and check the endpoint
    we just created in the Swagger documentation. Feel free to play around with it.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs: []
  type: TYPE_NORMAL
- en: 'Create proper tests for both the `add_user` function and the `/register/user`
    endpoint, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`def test_add_user_into_the_database(session):`'
  prefs: []
  type: TYPE_NORMAL
- en: '`user =` `add_user(…`'
  prefs: []
  type: TYPE_NORMAL
- en: '`# fill in` `the test`'
  prefs: []
  type: TYPE_NORMAL
- en: '`def test_endpoint_add_basic_user(client):`'
  prefs: []
  type: TYPE_NORMAL
- en: '`response =` `client.post(`'
  prefs: []
  type: TYPE_NORMAL
- en: '`"/``register/user",`'
  prefs: []
  type: TYPE_NORMAL
- en: '`json=`'
  prefs: []
  type: TYPE_NORMAL
- en: '`# continue` `the test`'
  prefs: []
  type: TYPE_NORMAL
- en: You can arrange the test in any way that works best for you.
  prefs: []
  type: TYPE_NORMAL
- en: You can find a possible way of testing in the `Chapter04/saas_app` folder of
    the book’s GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **bcrypt** library allows you to add several layers of security to your
    hashing functions, such as salt and additional keys. Feel free to have a look
    at the source code on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Bcrypt GitHub* *Repository*: [https://github.com/pyca/bcrypt/](https://github.com/pyca/bcrypt/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Also, you can find some interesting examples of how to use it at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Hashing Passwords in Python with* *Bcrypt*: [https://www.geeksforgeeks.org/hashing-passwords-in-python-with-bcrypt/](https://www.geeksforgeeks.org/hashing-passwords-in-python-with-bcrypt/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with OAuth2 and JWT for authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we’ll integrate OAuth2 with JWTs for secure user authentication
    in your application. This approach improves security by utilizing tokens instead
    of credentials, aligning with modern authentication standards.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since we will use a specific library to manage JWT, ensure you have the necessary
    dependencies installed. If you haven’t installed the packages from `requirements.txt`,
    run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Also, we will use the users table used in the previous recipe, *Setting up user
    registration*. Make sure to have set it up before starting the recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can set up the JWT token integration through the following steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a new module called `security.py`, let’s define the authentication function
    for the user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The function can validate the input based on either the username or email.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Let’s define the functions to create and decode the access token in the same
    module (`create_access_token` and `decode_access_token`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To create the access token, we will need to specify a secret key, the algorithm
    used to generate it, and the expiration time, as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, the `create_access_token_function` is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To decode the access token, we can use a support function, `get_user`, that
    returns the `User` object by the username. You can do it on your own in the `operations.py`
    module or take it from the GitHub repository.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The function to decode the token will be as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now proceed to create the endpoint to retrieve the token in the same
    module, `security.py`, with the `APIRouter` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we can now create an `OAuth2PasswordBearer` object for the `POST /token`
    endpoint to obtain the access token:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we can create the `/users/me` endpoint that returns the credentials
    based on the token:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s import those endpoints into the FastAPI server in `main.py`. Right
    after defining the FastAPI object, let’s add the router, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have just defined the authentication mechanism for our SaaS.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, spin up the server by running the following code from the terminal at
    the project root folder level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Go to the Swagger documentation address in your browser (`localhost:8000/docs`)
    and you will see the new endpoints, `POST /token` and `GET /users/me`.
  prefs: []
  type: TYPE_NORMAL
- en: You need the token to call the second endpoint, which you can store in your
    browser automatically by clicking on the lock icon and filling out the form with
    your credentials.
  prefs: []
  type: TYPE_NORMAL
- en: You’ve made your SaaS application more secure by using OAuth2 with JWT, which
    help you guard your sensitive endpoints and make sure that only users who are
    logged in can use them. This arrangement gives you a reliable and safe way to
    verify users that works well for modern web applications.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can gain a better understanding of the OAuth2 framework by reading this
    article:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Introduction to* *OAuth2*: [https://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2](https://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Also, you can have a look at the protocol definition for JWTs at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*JWT IETF* *Document*: [https://datatracker.ietf.org/doc/html/rfc7519](https://datatracker.ietf.org/doc/html/rfc7519)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up RBAC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: RBAC is a method of regulating access to resources based on the roles of individual
    users within an organization. In this recipe, we’ll implement RBAC in a FastAPI
    application to manage user permissions effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we will expand our database to accommodate role definitions, make sure
    you have completed the *Setting up user registration* recipe before diving into
    this.
  prefs: []
  type: TYPE_NORMAL
- en: To set up access control, we first need to define a variety of roles that we
    can allocate to. Let’s follow these steps to do it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `module.py` module, we can define a new class called `Role` and add
    it as a new field of the `User` model that will be stored in the users table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, in the `operations.py` module, we will modify the `add_user` function
    in `operations.py` to accept a parameter to define the user role; the default
    value will be the basic role:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s create a new module called `premium_access.py` and define the endpoint
    through a new router to sign up a premium user, which will look a lot like the
    endpoint to sign up a basic user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s add the router to our `app` class in the `main.py` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have now all the elements to implement RBAC in our SaaS application.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s create two endpoints, one accessible for all the users and one reserved
    only for premium user. Let's make the endpoints through the following steps.
  prefs: []
  type: TYPE_NORMAL
- en: First, let’s create two helper functions, `get_current_user` and `get_premium_user`,
    to retrieve each case and to be used as dependencies for the endpoints, respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can define a separate module, called the `rbac.py` module. Let’s start with
    the imports:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we create the request model that we will use with the endpoints:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we define a support function to retrieve the user based on the token:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can then leverage this function to shortlist premium users only:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can use the functions to create the respective endpoints with the router
    in the same module. First, we define a welcome page for all the users:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we define the endpoint, allowing only premium users:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s add the router we create in `main.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have just implemented two endpoints with permissions based on the use role.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test our endpoints, start the server from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Then, from your browser, go to the Swagger page at `http://localhost:8000/docs`,
    and you can see the new endpoints just created.
  prefs: []
  type: TYPE_NORMAL
- en: A way to experiment is to create a basic and a premium user and use the corresponding
    endpoints. After you have made the users, you can try using the `GET welcome/all-users`
    and `GET /welcome/premium-user` endpoints with both roles and see that the response
    matches the role’s expectations.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you just made simple endpoints that are available based on the
    user role. You can also play around with making more roles and endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another way to apply RBAC is to assign a scope to a token. This scope can be
    a string that represents certain permissions. As a result, the role is controlled
    by the token generation system. In FastAPI, you can define scopes within the token.
    You can check out the dedicated documentation page for more information: [https://fastapi.tiangolo.com/advanced/security/oauth2-scopes/](https://fastapi.tiangolo.com/advanced/security/oauth2-scopes/).'
  prefs: []
  type: TYPE_NORMAL
- en: Using third-party authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Incorporating third-party authentication into your FastAPI application allows
    users to log in using their existing social media accounts, such as Google or
    Facebook. This recipe guides you through the process of integrating GitHub third-party
    login, enhancing user experience by simplifying the sign-in process.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll focus on integrating GitHub OAuth2 for authentication. GitHub provides
    comprehensive documentation and a well-supported client library that simplifies
    the integration process.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will need the `httpx` package in your environment, so if you haven’t installed
    it with the `requirements.txt`, you can do it by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: You will need also a GitHub account set up. If you don’t have one, create one;
    you can find a comprehensive guide on the official documentation at [https://docs.github.com/en/get-started/start-your-journey/creating-an-account-on-github](https://docs.github.com/en/get-started/start-your-journey/creating-an-account-on-github).
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, you need to create an application in your account by following the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: From your personal page, click on the profile icon on the top right of the screen,
    the navigate to `SaasFastAPIapp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`http://localhost:8000/home`, which we will create later.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`http://localhost:8000/github/auth/token`, which we will define later as well.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Register application** and the app will be created, and you will
    be redirected to a page listing essential data about your OAuth2 app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take note of the client ID and click on the **Generate a new** **client secret**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Store the client secret you just created. With the client ID and the client
    secret, we can proceed to implement the third-party authentication by GitHub.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we have all we need to integrate the GitHub third-party login with our
    application.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s start by creating a new module called `third_party_login.py` to store
    helper data and functions for the GitHub authentication. Then let's continue as
    follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the `third_party_login.py` module, you can define the variables used
    for the authentication:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For `GITHUB_CLIENT_ID` and `GITHUB_CLIENT_SECRET`, use the values of your OAuth
    app.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: In a production environment, make sure to not hardcode any username or client
    ID in your code base.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, still in the `third_party_login.py` module, let’s define a helper function,
    `resolve_github_token`, that resolves the GitHub token and returns information
    about the user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In a new module called `github_login.py`, we can start creating the endpoints
    used for the GitHub authentication. Let’s create a new router and the `github_login`
    endpoint that will return the URL used by the frontend to redirect the user to
    the GitHub login page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s add the router to the server in the `main.py` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Spin up the server with the same command, `uvicorn main:app`, and call the
    endpoint `GET` `/auth/url` we have just created. You will have a similar link
    in the response: [https://github.com/login/oauth/authorize?client_id=your_github_client_id](https://github.com/login/oauth/authorize?client_id=your_github_client_id).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This link is used by GitHub for the authentication. The redirection is managed
    by the frontend and is out of the scope of this book.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'After validating the login, you will be redirected to a `404` page. This is
    because we still haven’t created the callback endpoint in our application. Let’s
    do so in the `github_login.py` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The endpoint we just created returns the actual access token.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If you restart the server and try to validate the GitHub login again with the
    link provded by the `GET` `/auth/url` endpoint, you will receive a response containing
    the token similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last piece of the puzzle is to create the home page endpoint that can be
    accessed with the GitHub token and will recognize the user by resolving the token.
    We can define it in the `main.py` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You’ve just implemented an endpoint that authenticates with the GitHub third-party
    authenticator.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, by using the register endpoint `POST /register/user`, add a user that
    has the same username or email as the GitHub account you are going to test.
  prefs: []
  type: TYPE_NORMAL
- en: Then, retrieve the token from the GitHub URL provided by the `GET /``auth/url`
    endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: You will use a token with your favorite tool to query the `GET /home` endpoint,
    which uses the GitHub token to validate permission.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, we cannot test endpoints requiring external bearer tokens
    with the interactive documentation, so feel free to use your favorite tool to
    query the endpoint by providing the bearer token in the headers authorization.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can do it with `curl` request from your shell as well, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything is correctly set up, you will receive the response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: You just implemented and tested authentication by using a third-party application
    such as GitHub. Other providers such as Google or Twitter follow similar procedures,
    with small differences. Feel free to implement them as well.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Take a look at the GitHub documentation that provides a guide on how to set
    up OAuth2 authentication:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GitHub OAuth2* *integration*: [https://docs.github.com/en/apps/oauth-apps/building-oauth-apps/authorizing-oauth-apps](https://docs.github.com/en/apps/oauth-apps/building-oauth-apps/authorizing-oauth-apps)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can use third-party authorization login with other providers that allow
    a similar configuration. You can check, for example, Google and Twitter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Google OAuth2* *integration*: [https://developers.google.com/identity/protocols/oauth2](https://developers.google.com/identity/protocols/oauth2)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Twitter OAuth2* *integration*: [https://developer.twitter.com/en/docs/authentication/oauth-2-0](https://developer.twitter.com/en/docs/authentication/oauth-2-0)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing MFA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MFA adds a layer of security by requiring users to provide two or more verification
    factors to gain access to a resource. The recipe guides you through adding MFA
    to your FastAPI application, enhancing security by combining something the user
    knows (their password) with something they have (a device).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For our FastAPI application, we’ll use a **time-based one-time password** (**TOTP**)
    as our MFA method. TOTP provides a six to eight-digit number that’s valid for
    a short period, typically 30 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, ensure you have the necessary packages installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '**Pyotp** is a Python library that implements one-time password algorithms,
    including TOTP.'
  prefs: []
  type: TYPE_NORMAL
- en: To use the TOTP authentication, we need to modify the user table in our database
    to take into account the TOTP secret used to validate the secret number.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s modify the `User` class in the `models.py` module by adding the `totp_secret`
    field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We are now ready to implement MFA.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s start by creating two helper functions to generate a TOTP secret and TOTP
    URI used by the authenticatorthrough the following steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'We define the functions in a new module called `mfa.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The TOTP URI can be a QR code as well in the form of a link.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We will use the `generate_totp_secret` and `generate_totp_uri` functions to
    create the endpoint to request MFA.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The endpoint will return a **TOTP URI** for use by the authenticator. To show
    the mechanism, we will also return the secret number, which in a real-life scenario
    is the number generated by the authenticator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can create the endpoint to validate the secret number:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As before, you need to include the router in the `FastAPI` object class in `main.py`
    for all the previous endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test it, as usual spin up the server from the terminal by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure you have a user in your database, go to the interactive documentation,
    and call the `/user/enable-mfa` endpoint by authenticating with the user credentials.
    You will get a response with the TOTP URI and a temporary secret number, like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Take note of the secret number to use as a parameter of the `/verify-totp`
    endpoint with the username, and you will get this response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: You’ve just implemented MFA in your FastAPI application and enhanced security
    by ensuring that even if a user’s password is compromised, an attacker still needs
    access to the user’s second factor (the device running the MFA app) to gain access.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Take a look at the Python One-Time Password library in the official documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Python One-Time Password* *library*: [https://pyauth.github.io/pyotp/](https://pyauth.github.io/pyotp/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling API key authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: API key authentication is a simple yet effective way to control access to an
    application. This method involves generating a unique key for each user or service
    that needs access to your API and requiring that key to be included in the request
    headers.
  prefs: []
  type: TYPE_NORMAL
- en: API keys can be generated in various ways, depending on the level of security
    needed.
  prefs: []
  type: TYPE_NORMAL
- en: FastAPI doesn’t have built-in support for API key authentication, but you can
    easily implement it using dependencies or middleware. A dependency is more flexible
    for most use cases, so we’ll use that approach.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will show you a basic, yet not secure, way to implement it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will keep working on our application. However, you can apply this recipe
    to a simple application from scratch as well.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s create an `api_key.py` module to store the logic to handle API keys.
    The package will contain the API list and verification method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: In the example, the keys are hardcoded into the `VALID_API_KEYS` list. However,
    in real-life production scenarios, the management and validation of the keys are
    usually done by dedicated libraries or even services.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create an endpoint that makes use of the API key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Now, add the router to the `FastAPI` object class in `main.py`, and then the
    endpoint is ready to be tested.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spin up the server from the command by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Go to the interactive documentation at `http://localhost:8000/docs` and test
    the endpoint you just created by providing an API key.
  prefs: []
  type: TYPE_NORMAL
- en: As you see, by adding a simple dependency to the endpoint, you can secure any
    endpoint of your app with an API key.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have developed a simple module for managing the API of our application.
    In production environment this can be handled by external services often provided
    by the hosting platform. However, If you are going to implement your API management
    system, keep in mind the best practices for API key authentication:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Transmission security**: Always use HTTPS to prevent API keys from being
    intercepted during transmission'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Key rotation**: Regularly rotate API keys to minimize the risk of compromise'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Limit permissions**: Assign minimal permissions required for each API key
    based on the principle of least privilege'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Monitoring and revocation**: Monitor the usage of API keys and have mechanisms
    in place to revoke them if suspicious activity is detected'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling session cookies and logout functionality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Managing user sessions and implementing logout functionality is crucial for
    maintaining security and user experience in web applications. This recipe shows
    how to handle session cookies in FastAPI, from creating cookies upon user login
    to securely terminating sessions upon logout.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sessions provide a way to persist user data across requests. When a user logs
    in, the application creates a session on the server side and sends a session identifier
    to the client, usually in a **cookie**. The client sends this identifier back
    with each request, allowing the server to retrieve the user’s session data.
  prefs: []
  type: TYPE_NORMAL
- en: The recipe will show how to manage cookies for sessions with login and logout
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cookies in FastAPI are easily managed by the `Request` and `Response` object
    classes. Let’s create a login and a logout endpoints to attaches a session cookie
    to the response and ignore it from the request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a dedicated module called `user_session.py` and add the `/``login`
    endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Testing the login endpoint won’t be possible with the Swagger documentation
    because we need to verify that the `fakesession` cookie has been created.
  prefs: []
  type: TYPE_NORMAL
- en: Spin up the server with `uvicorn main:app` and use Postman to create a `Post`
    request to the `/login` endpoint by providing the authentication token for the
    user you want to log in.
  prefs: []
  type: TYPE_NORMAL
- en: Verify that the response contains the `fakesession` cookie by selecting **Cookies**
    from the drop-down menu of the response section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Accordingly, we can define a logout endpoint that won’t return any session
    cookie in the response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: That’s all you need to manage sessions.
  prefs: []
  type: TYPE_NORMAL
- en: To test the `POST /logout` endpoint, restart the server with `uvicorn`. Then,
    when calling the endpoint, make sure you provide the `fakesession` cookie in your
    HTTP request with the user bearer token. If you previously called the login endpoint,
    it should be automatically stored; otherwise, you can set it in the `Cookies`
    section of the request.
  prefs: []
  type: TYPE_NORMAL
- en: Check the response and confirm that the `fakesession` cookie is not present
    anymore in the response.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is a lot to learn about cookies besides the basic recipe. In a real-world
    setting, you can use specialized libraries or even external services.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whatever your choice is, put security first and follow those practices to make
    your session secure and efficient:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Secure`, `HttpOnly`, and `SameSite` to protect against **cross-site request
    forgery** (**CSRF**) and **cross-site scripting** (**XSS**) attacks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Session expiry**: Implement session expiry both in your session store and
    by setting a maximum age on the cookie'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Regenerate Session ID**: Regenerate session IDs upon login to prevent session
    fixation attacks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Monitor sessions**: Implement mechanisms to monitor active sessions and detect
    anomalies'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By integrating session management and logout functionality into your FastAPI
    application, you ensure that user state is managed securely and efficiently across
    requests. This enhances both the security and user experience of your application.
    Remember to follow best practices for session security to protect your users and
    their data effectively.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see how to efficiently debug your FastAPI application.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can see more on managing cookies in Fast on the documentation page:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Response* *cookies*: [https://fastapi.tiangolo.com/advanced/response-cookies/](https://fastapi.tiangolo.com/advanced/response-cookies/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
