<html><head></head><body><div><h1 class="header-title">Machine Learning</h1>
                
            
            
                
<p>Robots and computers from its primitive days to even right now are being programmed to do a set of activities. These activities can be very large. Hence, to develop complex programs, there is a need for a lot of software engineers who work day and night to achieve a certain functionality. This is workable when the problem is well defined. But what about situations when the problem is also way complex?</p>
<p class="mce-root">Learning is something that has made us humans what we are. Our experiences molded us to adapt to situations in a better and a more efficient way. Every time we do something, we know more. This makes us better at doing that task over a period of time. It is said practice makes a man perfect, and it is learning through doing things again and again that makes us better.</p>
<p class="mce-root">However, let us step back and define what learning is? I would like to quote Google here according to it, <em>It is a knowledge acquired through study, experience or being taught</em>. So, learning is basically a way of acquiring information from our surroundings to understand a process and its nature. </p>
<p class="mce-root">Now, you must be thinking, wait a minute, haven't we made our system learn a lot of vision data in previous chapters when we were making the guard robot. You would be absolutely correct to think so. However, the learning can be done in different ways. What may work for one kind of problem can be futile for some other kind of problem. Hence, there are various types of learning algorithms and their principles. In this chapter, we will be focusing on an algorithm named <strong>k-nearest neighbor</strong>. It's named the <strong>lazy algorithm</strong>. I love this algorithm personally for classification. Why? Because technically there is no training phase. How? </p>
<p class="mce-root">k-nearest neighbor is actually a smart algorithm. Rather than computing a regression of data provided and do a lot of mathematics calculations, it simply takes a structured data from the dataset provided. Whenever there is new data that has come in for prediction, then it simply searches the closest <em>k</em> match of the data provided by the user to the database based on its classification given. So, in this chapter, we will learn how this algorithm will work and how we can use it to make our home smart. </p>
<p>We will cover the following topics in this chapter:</p>
<ul>
<li>Making a dataset</li>
<li>Prediction using dataset</li>
<li>Making your home learn</li>
<li>Home learning and automation</li>
</ul>


            

            
        
    </div>
<div><h1 class="header-title">Making a dataset</h1>
                
            
            
                
<p>Like in <a href="f5d8044d-e608-4ab6-adca-52ec2689f115.xhtml">Chapter 10</a>, <em>Making a Guard Robot</em>, we have used multiple images for the user to train the model to find out whether the object in the image is a man or something else. In a very similar way, we would have to make a dummy dataset so that the machine learning algorithm can predict based on that data what should be done. </p>
<p>To make a dataset, we need to understand what data is being considered. In this chapter, we will be making a machine learning algorithm based on time and the temperature to predict whether the fan should be on or off. Hence, there are at least two things that should be provided by us to the system one being <kbd>Temperature</kbd>, and the other would be <kbd>Time</kbd> so that the prediction can take place. But one thing to remember is that we are talking about a supervised learning algorithm, so to train the model, we need to also give the outcome of <kbd>Temperature</kbd> and <kbd>Time</kbd> onto the state of the fan. Here, the state of the fan would be either on or off. Hence, we can depict it using <kbd>0</kbd> or <kbd>1</kbd>. Now let's go ahead and make a dataset by ourselves. </p>
<p>Now, to make a dataset, you simply have to open Microsoft Excel and start writing the dataset as follows:</p>
<div><img src="img/f96de387-2d29-4a30-a656-6aabaaf3b3ab.png" style="width:21.33em;height:23.17em;"/></div>
<p>It is always better to have a dataset of more than 20 sets of data. Also, its important that the data has a distinct characteristic and its not random data. For example, in the preceding case, you can see that at <kbd>12.44</kbd> when the temperature is <kbd>28</kbd>, the fan will be on; however, at the same time, when the time is <kbd>12.13</kbd> and temperature is <kbd>21</kbd>, then the fan is off. </p>
<p>Once you have created a dataset, then you must save it with the name <kbd>dataset</kbd> in the CSV format. There may be some users who would not use a Microsoft Excel, in which case you can write the data with the same format in text editor and finally save it in the CSV format. </p>
<p>Once you have the <kbd>dataset.csv</kbd> files, then you must go ahead and copy them into the place where you will be saving the upcoming code. Once you are done, then we can move on to the next step. </p>
<p>Remember that the better the quality of data, the better the learning process. So you may take some time and carefully craft your dataset so that it does make sense. </p>


            

            
        
    </div>
<div><h1 class="header-title">Predicting using a dataset</h1>
                
            
            
                
<p>Without much talking, let's take a look at the following code:</p>
<pre>import numpy as np<br/>import pandas as pd<br/>from sklearn.neighbors import KNeighborsClassifier<br/><br/>knn = KNeighborsClassifier(n_neighbors=5)<br/>data = pd.read_csv('dataset.csv')<br/><br/>x = np.array(data[['Time', 'Temp']])<br/>y = np.array(data[['State']]).ravel()<br/><br/>knn.fit(x,y)<br/><br/>time = raw_input("Enter time")<br/>temp = raw_input("Enter temp")<br/><br/>data =. []<br/><br/>data.append(float(time))<br/>data.append(float(temp))<br/><br/>a = knn.predict([data])<br/><br/>print(a[0])}</pre>
<p>So, let's see what we are doing here:</p>
<pre>import numpy as np</pre>
<p>We are importing <kbd>numpy</kbd> to our program; this helps us handle lists and matrices:</p>
<pre>import pandas as pd</pre>
<p>Here, we are importing a library named <kbd>pandas</kbd>; this helps us read files in comma-separated values or in other words, CSV files. We will be using CSV files to store our data and access it for learning process:</p>
<pre>from sklearn.neighbors import KNeighborsClassifier</pre>
<p>Here, we are importing <kbd>KneighborsClassifier</kbd> from the library <kbd>sklearn</kbd>. <kbd>sklearn</kbd> itself is a huge library; hence, we are importing only a part of it as we will not be using all of it in this program:</p>
<pre>knn = KNeighborsClassifier(n_neighbors=5)</pre>
<p>Here, we are giving value to variable <kbd>knn</kbd> wherein the value would be <kbd>KNeighborsClassifer(n_neighbors =5)</kbd>; what this means is that it is using the <kbd>KneighborsClassifer()</kbd> function with the argument as <kbd>n_neighbors=5</kbd>. This argument tells the <kbd>KneighborsClassifer</kbd> function that we will be having five neighbors in the algorithm. Further to this using this declaration, the whole function can be called using <kbd>knn</kbd>:</p>
<pre>data = pd.read_csv('dataset.csv')</pre>
<p>Here, we are providing value to a variable called <kbd>data</kbd> and the value passed is <kbd>pd.read_csv('dataset.csv')</kbd>; what this means is that whenever <kbd>data</kbd> is called, then a <kbd>pd.read_csv()</kbd> function from the <kbd>pandas</kbd> library will be called. The purpose of this function is to read data from the CSV files. Here, the argument passed is <kbd>dataset.csv</kbd>; hence, it is indicating which data would be read by the function. In our case, it will read from a file name: <kbd>dataset.csv</kbd>:</p>
<pre>x = np.array(data[['Time', 'Temp']])</pre>
<p>In the following line, we are passing value to the variable <kbd>x</kbd>, and the value being passed is <kbd>np.array(data[['Time, 'Temp']])</kbd>. Now the <kbd>np.array</kbd> function to make an array through the <kbd>numpy</kbd> library. This array will store the data by the name of <kbd>Time</kbd> and <kbd>Temp</kbd>:</p>
<pre>y = np.array(data[['State']]).ravel()</pre>
<p>Just like the previous time, we are storing <kbd>State</kbd> in an array made through the <kbd>numpy</kbd> library <kbd>.ravel()</kbd> function at the end would transpose the array. This is done so that the mathematical functions can be done between two arrays—<kbd>x</kbd> and <kbd>y</kbd>:</p>
<pre>knn.fit(x,y)</pre>
<p>In this small line, we are using the function from the <kbd>knn</kbd> library called <kbd>fit()</kbd> what it is doing is fitting the model using the <kbd>x</kbd> as the primary data and <kbd>y</kbd> as the output resultant data:</p>
<pre>time = raw_input("Enter time")<br/>temp = raw_input("Enter temp")</pre>
<p>In this line, we are requesting the data from the user. In the first line, we will be printing <kbd>Enter time</kbd> and thereafter wait for user to enter the time. After user has entered the time, it will be stored in the variable named <kbd>time</kbd>. Once that is done, then it would move on to the next line; the code and it would print <kbd>Enter temp</kbd> once that is prompted to the user it would wait for data to be collected. Once data is fetched by the user, it will store that data in the variable called <kbd>temp:</kbd></p>
<pre>data =. []</pre>
<p>Here, we are making an empty list by the name of <kbd>data</kbd>; this list will be used for calculating the resultant state of the output. As all the machine learning algorithm is working in list data type. Hence, the input must be given for decision in the form of a list itself:</p>
<pre>data.append(float(time))<br/>data.append(float(temp))</pre>
<p>Here, we are adding data to the list that we just created with the name <kbd>data</kbd>. First, <kbd>time</kbd> will be added, followed by <kbd>temp</kbd>:</p>
<pre>a = knn.predict([data])</pre>
<p>Once that is done, a function named <kbd>predict</kbd> from the <kbd>knn</kbd> algorithm will be used to predict the output based on the list provided with the name of <kbd>data</kbd>. The output of the prediction algorithm is fetched to a variable by the name  <kbd>a</kbd>:</p>
<pre>print(a[0])</pre>
<p>Finally, once the prediction is done, then we would read the value of   <kbd>a</kbd> and remember that all the data I/O is happening in the form of lists. Hence, the data output given by the prediction algorithm would also be in the list format. Hence, we are printing the first element of the list. </p>
<p>This output will predict which state will be of the fan according to the dataset given by the user. So, go ahead and give a temperature and a time and let the system predict the outcome for you. See if it works fine or not. If it doesn't, then try adding some more datasets to the CSV files or see whether the values in the dataset actually make any sense. I am sure that you end up with a wonderful predictive system. </p>


            

            
        
    </div>
<div><h1 class="header-title">Making your home learn</h1>
                
            
            
                
<p>Once this constitution is done, go ahead and wire it up, as shown here:</p>
<div><img src="img/855c4bae-d685-44b1-bb0c-5926da8035a2.png"/></div>
<p>Once that is set, it is time for us to write the following code on to our Raspberry Pi:</p>
<pre>import Adafruit_DHT<br/>import datetime<br/>import RPi.GPIO as GPIO<br/>import time<br/>import numpy as np<br/>import pandas as pd<br/>import Adafruit_DHT<br/>from sklearn.neighbors import KNeighborsClassifier<br/><br/>GPIO.setmode(GPIO.BCM)<br/>GPIO.setwarnings(False)<br/><br/>fan = 22<br/>light = 23<br/>sw1 = 13<br/>sw2 = 14<br/><br/>GPIO.setup(led1,GPIO.OUT)<br/>GPIO.setup(led2,GPIO.OUT)<br/>GPIO.setup(sw1,GPIO.IN)<br/>GPIO.setup(sw2,GPIO.IN)<br/><br/>sensor = 11<br/>pin = 2<br/><br/><br/>f = open("dataset.csv","a+")<br/>count = 0<br/>while count &lt; 50:<br/><br/> data = ""<br/><br/> H = datetime.datetime.now().strftime('%H')<br/> M = datetime.datetime.now().strftime('%M')<br/><br/> data = str(H)+"."+str(M)<br/> humidity,temperature = Adafruit_DHT.read_retry(sensor,pin)<br/> data = data + "," + str(temperature)<br/><br/>prev_state = state<br/><br/> if (GPIO.input(sw1) == 0) and (GPIO.input(sw2) == 0):<br/>     state = 0<br/>     GPIO.output(light,GPIO.LOW)<br/>     GPIO.output(fan,GPIO.LOW)<br/><br/> elif (GPIO.input(sw1) == 0) and (GPIO.input(sw2) == 1):<br/>     state = 1<br/>     GPIO.output(light,GPIO.HIGH)<br/>     GPIO.output(fan,GPIO.LOW)<br/><br/> elif (GPIO.input(sw1) == 1) and (GPIO.input(sw2) == 0):<br/>    state = 2<br/>     GPIO.output(light,GPIO.LOW)<br/>     GPIO.output(fan,GPIO.HIGH)<br/><br/> elif (GPIO.input(sw1) == 1) and (GPIO.input(sw2) == 1):<br/>    state = 3<br/>     GPIO.output(light,GPIO.HIGH)<br/>     GPIO.output(fan,GPIO.HIGH)<br/><br/> data = ","+str(state)<br/> <br/>if prev_state =! state:<br/><br/>     f.write(data)<br/>     count = count+1<br/><br/><br/>f.close()</pre>
<p>Now, let's see what we have done here:</p>
<pre>f = open("dataset.csv","a+")</pre>
<p>In this line of the code, we have assigned the value <kbd>open("dataset.csv", "a+")</kbd> to the variable <kbd>f</kbd>. Thereafter, the <kbd>open()</kbd> function will open the file that is passed on to its argument, which in our case is <kbd>dataset.csv</kbd>; the argument <kbd>a+</kbd> stands for appending the value at the end of the CSV file. Hence, what this line will do is to open the file <kbd>dataset.csv</kbd> and add a value that we will pass later on:</p>
<pre> data = ""</pre>
<p>We are declaring an empty string by the name of <kbd>data</kbd>:</p>
<pre> data = str(H)+"."+str(M)</pre>
<p>We are adding values of hours and minutes to the string, separated by a dot in between for differentiation. Hence, the data will look like <kbd>HH.MM</kbd>:</p>
<pre> humidity,temperature = Adafruit_DHT.read_retry(sensor,pin)</pre>
<p>We are using this line to read the humidity and temperature reading from the DHT 11 sensor and the values that would be passed on to the variables <kbd>humidity</kbd> and <kbd>temperature</kbd>:</p>
<pre>data = data + "," + str(temperature)</pre>
<p>Once the data is read, we are adding temperature to the variable <kbd>data</kbd> as well. Hence, now the data would look like this <kbd>HH.MM</kbd> and <kbd>TT.TT</kbd>:</p>
<pre> if (GPIO.input(sw1) == 0) and (GPIO.input(sw2) == 0):<br/> state = 0<br/> elif (GPIO.input(sw1) == 0) and (GPIO.input(sw2) == 1):<br/> state = 1<br/> elif (GPIO.input(sw1) == 1) and (GPIO.input(sw2) == 0):<br/> state = 2<br/> elif (GPIO.input(sw1) == 1) and (GPIO.input(sw2) == 1):<br/> state = 3</pre>
<p>Here, we have defined different types of states which are corresponding to the switch combinations. The table for it is as follows:</p>
<table style="border-collapse: collapse" border="1">
<tbody>
<tr>
<td><strong>Switch 1</strong></td>
<td><strong>Switch 2</strong></td>
<td><strong>State</strong></td>
</tr>
<tr>
<td><kbd>0</kbd></td>
<td><kbd>0</kbd></td>
<td><kbd>0</kbd></td>
</tr>
<tr>
<td><kbd>0</kbd></td>
<td><kbd>1</kbd></td>
<td><kbd>1</kbd></td>
</tr>
<tr>
<td><kbd>1</kbd></td>
<td><kbd>0</kbd></td>
<td><kbd>2</kbd></td>
</tr>
<tr>
<td><kbd>1</kbd></td>
<td><kbd>1</kbd></td>
<td><kbd>3</kbd></td>
</tr>
</tbody>
</table>
<p> </p>
<p>Hence, by the value of state, we can understand which switch would be turned on and which would be turned off:</p>
<pre> data = ","+str(state)</pre>
<p>Finally, the value of state is also added to the variable named <kbd>data</kbd>. Now, finally, the data would look like <kbd>HH.MM</kbd>, <kbd>TT.TT</kbd>, and <kbd>S</kbd>:</p>
<pre>f.write(data)</pre>
<p>Now, using the <kbd>write()</kbd> function, we are writing the value of data to the file that we have already defined by the value <kbd>f</kbd> earlier. </p>
<p>Hence, with every single switch on or off, the data would be collected, and the value would be recorded with the time stamp in that file. This data can then be used to predict the state of the home at any given time without any intervention:</p>
<pre>if prev_state =! state:<br/><br/>     f.write(data)<br/>     count = count+1</pre>
<p>Here, we are comparing the state with the <kbd>prev_state</kbd> as you can see in our program. The previous state is calculated at the start of our program. So, if there is any change in the state of the system, then the value of <kbd>prev_state</kbd> and <kbd>state</kbd> would be different. This will lead to the <kbd>if</kbd> statement to be true. When that happens, the data would be written onto our file using the <kbd>write()</kbd> function. The argument passed is the value that needs to be written. Finally, the value of count is increased by <kbd>1</kbd>.</p>
<p>Once this is left running for a few hours or may be days, then it would collect some really useful data regarding your switching pattern of the lights and fan. Thereafter, this data can be fetched to the previous program wherein it would be able to to take its own decision based on the time and temperature. </p>


            

            
        
    </div>
<div><h1 class="header-title">Home learning and automation</h1>
                
            
            
                
<p>Now that in the previous section we have understood how the learning works, it's time to use this concept to make a robot that will automatically understand how we function and make decisions. Based on our decisions, the system will judge what should be done. But this time, rather than giving a set of data by the user, let's make this program create the data for itself. Once the data seems sufficient for itself to function. So, without much explanation, let's get right into it: </p>
<pre>import Adafruit_DHT<br/>import datetime<br/>import RPi.GPIO as GPIO<br/>import time<br/>import numpy as np<br/>import pandas as pd<br/>from sklearn.neighbors import KNeighborsClassifier<br/><br/>GPIO.setmode(GPIO.BCM)<br/>GPIO.setwarnings(False)<br/><br/>light = 22<br/>fan = 23<br/>sw1 = 13<br/>sw2 = 14<br/><br/>GPIO.setup(light,GPIO.OUT)<br/>GPIO.setup(fan,GPIO.OUT)<br/>GPIO.setup(sw1,GPIO.IN)<br/>GPIO.setup(sw2,GPIO.IN)<br/><br/><br/>sensor = 11<br/>pin = 2<br/><br/><br/>f = open("dataset.csv","a+")<br/>count = 0<br/><br/>while count &lt; 200:<br/><br/>        data = ""<br/><br/>        H = datetime.datetime.now().strftime('%H')<br/>        M = datetime.datetime.now().strftime('%M')<br/><br/>        data = str(H)+"."+str(M)<br/>        humidity,temperature = Adafruit_DHT.read_retry(sensor,pin)<br/>        data = data + "," + str(temperature)<br/><br/>prev_state = state<br/><br/> if (GPIO.input(sw1) == 0) and (GPIO.input(sw2) == 0):<br/>     state = 0<br/>     GPIO.output(light,GPIO.LOW)<br/>     GPIO.output(fan,GPIO.LOW)<br/><br/> elif (GPIO.input(sw1) == 0) and (GPIO.input(sw2) == 1):<br/>     state = 1<br/>     GPIO.output(light,GPIO.HIGH)<br/>     GPIO.output(fan,GPIO.LOW)<br/><br/> elif (GPIO.input(sw1) == 1) and (GPIO.input(sw2) == 0):<br/>    state = 2<br/>     GPIO.output(light,GPIO.LOW)<br/>     GPIO.output(fan,GPIO.HIGH)<br/><br/> elif (GPIO.input(sw1) == 1) and (GPIO.input(sw2) == 1):<br/>    state = 3<br/>     GPIO.output(light,GPIO.HIGH)<br/>     GPIO.output(fan,GPIO.HIGH)<br/><br/> data = ","+str(state)<br/><br/> if prev_state =! state:<br/><br/>     f.write(data)<br/>     count = count+1<br/><br/><br/>Test_set = []<br/>knn = KNeighborsClassifier(n_neighbors=5)<br/>data = pd.read_csv('dataset.csv')<br/><br/>X = np.array(data[['Time', 'Temp']])<br/>y = np.array(data[['State']]).ravel()<br/><br/>knn.fit(X,y)<br/><br/>While Count &gt; 200:<br/><br/>    time = ""<br/><br/>    H = datetime.datetime.now().strftime('%H')<br/>    M = datetime.datetime.now().strftime('%M')<br/><br/>    time = float(str(H)+"."+str(M))<br/><br/>    humidity, temperature = Adafruit_DHT.read_retry(sensor, pin)<br/><br/> <br/><br/> temp = int(temperature)<br/> test_set.append(time)<br/> test_set.append(temp)<br/><br/> a = knn.predict([test_set]])<br/> Out = a[0]<br/><br/> If out == 0:<br/> GPIO.output(light,GPIO.LOW)<br/> GPIO.output(fan,GPIO.LOW)<br/><br/> If out == 1:<br/> GPIO.output(light,GPIO.LOW)<br/> GPIO.output(fan,GPIO.HIGH)<br/><br/> If out == 2:<br/> GPIO.output(light,GPIO.HIGH)<br/> GPIO.output(fan,GPIO.LOW)<br/><br/> If out == 3:<br/> GPIO.output(light,GPIO.HIGH)<br/> GPIO.output(fan,GPIO.HIGH)<br/><br/></pre>
<p>Now let's see what we have done here. In this program, the first part of the program inside the condition <kbd>while count &lt; 200:</kbd> is exactly the same as what we have done in the last code. So, it is just doing the things according to the user, and at the same time, it's taking in the values from the users to understand their working behavior:</p>
<pre>while count &gt; 200:</pre>
<p>Thereafter, we have the second part of the code that will start to execute when the count is beyond <kbd>200</kbd> that is inside the preceding loop:</p>
<pre>    time = ""</pre>
<p>In this line, we are forming an empty string by the name of time where we would be storing the value of time:</p>
<pre>    H = datetime.datetime.now().strftime('%H')<br/>    M = datetime.datetime.now().strftime('%M')</pre>
<p>We are storing the values of time into the variable named <kbd>H</kbd> and <kbd>M</kbd>:</p>
<pre>    time = float(str(H)+"."+str(M))</pre>
<p>We are now storing the value of time in the string <kbd>time</kbd>. This would include both hours and minutes:</p>
<pre> temp = int(temperature)</pre>
<p>For the sake of ease of calculations and reducing the computing load on the system, we are reducing the size of the temperature variable . We are doing it by removing the decimal places. To do that <kbd>TT.TT</kbd>; we are simply eliminating the decimal point and converting it into integer. This is done by the function named <kbd>int()</kbd>. The value of temperature in <kbd>int</kbd> will be stored in the variable named <kbd>temp</kbd>:</p>
<pre> test_set.append(time)<br/> test_set.append(temp)</pre>
<p>Here, we are adding the value of the time and the temperature to a list named <kbd>test_set</kbd> if you look in the program, then you will see the declaration of an empty set in the mid of the program. So, now this <kbd>test_set</kbd> has the value of <kbd>time</kbd> and <kbd>temp</kbd>, which can be further used by the prediction algorithm to predict the state:</p>
<pre> a = knn.predict([test_set]])</pre>
<p>Using the simple function named <kbd>predict()</kbd> from the <kbd>knn</kbd> function, we can predict the value of the state. All we need to do is to pass on the data or <kbd>test_set</kbd> list over to the predict function. The output of this function will be a list that will be stored in a variable named <kbd>a</kbd>:</p>
<pre> Out = a[0]</pre>
<p>The value of <kbd>Out</kbd> will be set to the first element of the list <kbd>a</kbd>:</p>
<pre> If out == 0:<br/> GPIO.output(light,GPIO.LOW)<br/> GPIO.output(fan,GPIO.LOW)<br/><br/> If out == 1:<br/> GPIO.output(light,GPIO.LOW)<br/> GPIO.output(fan,GPIO.HIGH)<br/><br/> If out == 2:<br/> GPIO.output(light,GPIO.HIGH)<br/> GPIO.output(fan,GPIO.LOW)<br/><br/> If out == 3:<br/> GPIO.output(light,GPIO.HIGH)<br/> GPIO.output(fan,GPIO.HIGH)</pre>
<p>Using the preceding code block, we are able to switch on the light and fans selectively based on the state predicted by the algorithm. Hence, using this, the program would be able to automatically predict and switch on or off the light and the fans without your intervention. </p>


            

            
        
    </div>
<div><h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we understood how machine learning works even without learning. We understood how datasets can be provided, and we can create a new dataset using the existing system. Finally, we understood how the system can work seamlessly to collect data, learn from that data, and finally, provide the input. Want to build a wheeled self-balancing robot? Well, then see you in the next chapter! </p>


            

            
        
    </div></body></html>