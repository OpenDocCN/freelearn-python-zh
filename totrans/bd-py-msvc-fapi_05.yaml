- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Connecting to a Relational Database
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接到关系数据库
- en: Our previous applications have only used Python collections to hold data records
    instead of persistent data stores. This setup causes data wiping whenever the
    **Uvicorn** server restarts because these collections only store the data in *volatile
    memory*, such as **RAM**. From this chapter onward, we will be applying data persistency
    to avoid data loss and provide a platform to manage our records, even when the
    server is in shutdown mode.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前的应用程序仅使用 Python 集合来存储数据记录，而不是持久数据存储。这种设置会在 **Uvicorn** 服务器重启时导致数据丢失，因为这些集合仅在
    *易失性内存*，如 **RAM** 中存储数据。从本章开始，我们将应用数据持久性以避免数据丢失，并提供一个平台来管理我们的记录，即使在服务器关闭模式下也是如此。
- en: This chapter will focus on different **Object Relational Mappers** (**ORMs**)
    that can efficiently manage clients’ data using objects and a relational database.
    Object-relational mapping is a technique where SQL statements for **Creating***,*
    **Reading***,* **Updating** *and* **Deleting** (**CRUD**) are implemented and
    executed in an object-oriented programming approach. ORM requires all relationships
    or tables to be mapped to their corresponding entity or model classes to avoid
    tightly coupled connections to the database platform. And these model classes
    are the ones that are used to connect to the database.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将重点介绍不同的 **对象关系映射器**（**ORMs**），这些 ORM 可以有效地使用对象和关系数据库来管理客户端数据。对象关系映射是一种技术，其中
    SQL 语句用于 **创建**、**读取**、**更新** 和 **删除**（**CRUD**）在面向对象的编程方法中实现和执行。ORM 需要将所有关系或表映射到相应的实体或模型类，以避免与数据库平台的紧密耦合连接。这些模型类是用于连接到数据库的类。
- en: Aside from introducing ORM, this chapter will also discuss a design pattern
    called **Command and Query Responsibility Segregation** (**CQRS**), which can
    help resolve conflicts between read and write ORM transactions at the domain level.
    CQRS can help minimize the running time spent by read and write SQL transactions
    to improve the overall performance of the application over time compared to the
    data modeling approach.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 除了介绍 ORM，本章还将讨论一个名为 **命令和查询责任分离**（**CQRS**）的设计模式，该模式可以帮助在域级别解决读写 ORM 事务之间的冲突。CQRS
    可以帮助最小化读写 SQL 事务的运行时间，与数据建模方法相比，随着时间的推移可以提高应用程序的整体性能。
- en: Overall, the main objective of this chapter is to prove that the FastAPI framework
    supports all popular ORMs to provide applications with backend database access,
    which it does by using popular relational database management systems, and apply
    optimization to CRUD transactions using the CQRS design pattern.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，本章的主要目标是证明 FastAPI 框架支持所有流行的 ORM，为应用程序提供后端数据库访问，它通过使用流行的关系数据库管理系统来实现，并通过使用
    CQRS 设计模式对 CRUD 事务进行优化。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Preparing for database connectivity
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备数据库连接
- en: Creating synchronous CRUD transactions using *SQLAlchemy*
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 *SQLAlchemy* 创建同步 CRUD 事务
- en: Implementing asynchronous CRUD transactions using *SQLAlchemy*
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 *SQLAlchemy* 实现异步 CRUD 事务
- en: Using *GINO* for asynchronous CRUD transactions
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 *GINO* 进行异步 CRUD 事务
- en: Using Pony ORM for the repository layer
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Pony ORM 进行存储库层
- en: Building the repository using Peewee
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Peewee 构建存储库
- en: Applying the CQRS design pattern
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用 CQRS 设计模式
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The application prototype that’s been created for this chapter is called *fitness
    club management system*; it caters to membership and gym fitness operations. This
    prototype has administration, membership, class management, and attendance modules
    that utilize a `ch05a` and `ch05b` projects.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为本章创建的应用程序原型被称为 *健身俱乐部管理系统*；它服务于会员和健身房健身运营。此原型具有管理、会员、课程管理和出勤模块，这些模块利用 `ch05a`
    和 `ch05b` 项目。
- en: Preparing for database connectivity
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备数据库连接
- en: 'Let us consider some application-related concerns before we start discussing
    database connectivity in FastAPI:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始讨论 FastAPI 中的数据库连接之前，让我们考虑一些与应用程序相关的问题：
- en: First, all the application prototypes from this chapter onward will be using
    PostgreSQL as the sole relational DBMS. We can download its installer from [https://www.enterprisedb.com/downloads/postgres-postgresql-downloads](https://www.enterprisedb.com/downloads/postgres-postgresql-downloads).
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，从本章开始，所有应用程序原型都将使用 PostgreSQL 作为唯一的关联数据库管理系统。我们可以从 [https://www.enterprisedb.com/downloads/postgres-postgresql-downloads](https://www.enterprisedb.com/downloads/postgres-postgresql-downloads)
    下载其安装程序。
- en: 'Second, the *fitness club management system* prototype has an existing database
    called `fcms` with six tables, namely `signup`, `login`, `profile_members`, `profile_trainers`,
    `attendance_member`, and `gym_class`. All these tables, along with their metadata
    and relationships, can be seen in the following diagram:'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，*健身俱乐部管理系统* 原型有一个名为 `fcms` 的现有数据库，包含六个表，分别是 `signup`、`login`、`profile_members`、`profile_trainers`、`attendance_member`
    和 `gym_class`。所有这些表及其元数据和关系都可以在以下图中看到：
- en: '![Figure 5.1 – The fcms tables'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.1 – fcms 表格'
- en: '](img/Figure_5.1_B17975.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.1_B17975.jpg)'
- en: Figure 5.1 – The fcms tables
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – fcms 表格
- en: The project folder contains a script called `fcms_postgres.sql` that installs
    all these schemas.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 项目文件夹中包含一个名为 `fcms_postgres.sql` 的脚本，用于安装所有这些模式。
- en: Now that we’ve installed the latest version of PostgreSQL and run the `fcms`
    script file, let us learn about SQLAlchemy, the most widely used ORM library in
    the Python arena.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了最新版本的 PostgreSQL 并运行了 `fcms` 脚本文件，让我们来了解 SQLAlchemy，这是 Python 场景中最广泛使用的
    ORM 库。
- en: Important note
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: This chapter will compare and contrast the features of different Python ORMs.
    With this experimental setup, each project will have a multitude of database connectivity,
    which is against the convention of having a single piece of database connectivity
    per project.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将比较和对比不同 Python ORM 的功能。在这个实验设置中，每个项目都将拥有多种数据库连接，这与每个项目只有一个数据库连接的惯例相悖。
- en: Creating CRUD transactions using SQLAlchemy
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 SQLAlchemy 创建 CRUD 事务
- en: '**SQLAlchemy** is the most popular ORM library and can establish communication
    between any Python-based application and database platform. It is reliable because
    it is continuously updated and tested to be efficient, high-performing, and accurate
    with its SQL reads and writes.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**SQLAlchemy** 是最受欢迎的 ORM 库，能够建立任何基于 Python 的应用程序和数据库平台之间的通信。它之所以可靠，是因为它持续更新和测试，以确保其
    SQL 读写操作高效、高性能和准确。'
- en: This ORM is a boilerplated interface that aims to create a database-agnostic
    data layer that can connect to any database engine. But compared to other ORMs,
    SQLAlchemy is DBA-friendly because it can generate optimized native SQL statements.
    When it comes to formulating its queries, it only requires Python functions and
    expressions to pursue the CRUD operations.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 ORM 是一个模板化接口，旨在创建一个数据库无关的数据层，可以连接到任何数据库引擎。但与其他 ORM 相比，SQLAlchemy 更受数据库管理员（DBA）的欢迎，因为它可以生成优化的原生
    SQL 语句。在制定其查询时，它只需要 Python 函数和表达式来执行 CRUD 操作。
- en: 'Before we start using SQLAlchemy, check whether you have the module installed
    in your system by using the following command:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始使用 SQLAlchemy 之前，请使用以下命令检查您系统中是否已安装该模块：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If SQLAlchemy is not in the list, install it using the `pip` command:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 SQLAlchemy 不在列表中，请使用 `pip` 命令进行安装：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Currently, the version being used while developing the *fitness club management
    system* app is *1.4*.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，开发 *健身俱乐部管理系统* 应用程序所使用的版本是 *1.4*。
- en: Installing the database driver
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装数据库驱动程序
- en: 'SQLAlchemy will not work without the required database driver. It is mandatory
    to install the `psycopg2` dialect since the database of choice is PostgreSQL:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 没有所需的数据库驱动程序将无法工作。由于选择的是 PostgreSQL 数据库，因此必须安装 `psycopg2` 方言：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Psycopg2 is a *DB API 2.0-c*ompliant PostgreSQL driver that does connection
    pooling and can work with multi-threaded FastAPI applications. This wrapper or
    dialect is also essential in building synchronous CRUD transactions for our application.
    Once it’s been installed, we can start looking at SQLAlchemy’s database configuration
    details. All the code related to SQLAlchemy can be found in the `ch05a` project.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Psycopg2 是一个符合 *DB API 2.0-c*ompliant 的 PostgreSQL 驱动程序，可以进行连接池管理，并且可以与多线程 FastAPI
    应用程序一起工作。这个包装器或方言对于构建我们的应用程序的同步 CRUD 事务也是必不可少的。一旦安装，我们就可以开始查看 SQLAlchemy 的数据库配置细节。所有与
    SQLAlchemy 相关的代码都可以在 `ch05a` 项目中找到。
- en: Setting up the database connection
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置数据库连接
- en: 'To connect to any database, SQLAlchemy requires an engine that manages the
    connection pooling and the installed dialect. The `create_engine()` function from
    the `sqlalchemy` module is the source of the engine object. But to successfully
    derive it, `create_engine()` requires a database URL string to be configured.
    This URL string contains the *database name*, *the database API driver*, the *account
    credentials*, the *IP address* of the database server, and its *port*. The following
    script shows how to create the engine that will be used in our *fitness club management
    system* prototype:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了连接到任何数据库，SQLAlchemy需要一个管理连接池和已安装方言的引擎。`create_engine()`函数来自`sqlalchemy`模块，是引擎对象的来源。但为了成功派生它，`create_engine()`需要一个配置好的数据库URL字符串。这个URL字符串包含*数据库名称*、*数据库API驱动程序*、*账户凭证*、数据库服务器的*IP地址*和其*端口*。以下脚本展示了如何创建将在我们的*健身俱乐部管理系统*原型中使用的引擎：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`engine` is a global object and must be created only once in the entire application.
    Its first database connection happens right after the first SQL transaction of
    the application because it follows the *lazy initialization* design pattern.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`engine`是一个全局对象，必须在整个应用程序中只创建一次。它的第一个数据库连接发生在应用程序的第一个SQL事务之后，因为它遵循了*延迟初始化*设计模式。'
- en: Moreover, `engine` in the previous script is essential for creating the ORM
    session that will be used by SQLAlchemy to execute CRUD transactions.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，前一个脚本中的`engine`对于创建将被SQLAlchemy用于执行CRUD事务的ORM会话至关重要。
- en: Initializing the session factory
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化会话工厂
- en: All CRUD transactions in SQLAlchemy are driven by *sessions*. Each session manages
    a group of database "writes" and "reads," and it checks whether to execute them
    or not. For instance, it maintains a group of inserted, updated, and deleted objects,
    checks whether the changes are valid, and then coordinates with the SQLAlchemy
    core to pursue the changes to the database if all transactions have been validated.
    It follows the behavior of the *Unit of Work* design pattern. SQLAlchemy relies
    on sessions for data consistency and integrity.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy中的所有CRUD事务都是由*会话*驱动的。每个会话管理一组数据库“写入”和“读取”，并检查是否执行它们。例如，它维护一组已插入、更新和删除的对象，检查更改是否有效，然后与SQLAlchemy核心协调，如果所有事务都已验证，则将更改推进到数据库。它遵循*工作单元*设计模式的行为。SQLAlchemy依赖于会话来保证数据的一致性和完整性。
- en: 'But before we create a session, the data layer needs a session factory that
    is bound to the derived engine. The ORM has a `sessionmaker()`directive from the
    `sqlalchemy.orm` module, which requires the `engine` object. The following script
    shows how to invoke `sessionmaker()`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们创建会话之前，数据层需要一个绑定到派生引擎的会话工厂。ORM从`sqlalchemy.orm`模块中有一个`sessionmaker()`指令，它需要一个`engine`对象。以下脚本展示了如何调用`sessionmaker()`：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Apart from engine binding, we also need to set the session’s `autocommit` property
    to `False` to impose `commit()` and `rollback()` transactions. The application
    should be the one to flush all changes to the database, so we need to set its
    `autoflush` feature to `False` as well.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 除了引擎绑定之外，我们还需要将会话的`autocommit`属性设置为`False`以强制执行`commit()`和`rollback()`事务。应用程序应该是将所有更改刷新到数据库的那个，因此我们还需要将其`autoflush`功能设置为`False`。
- en: Applications can create more than one session through the `SessionFactory()`
    call, but having one session per `APIRouter` is recommended.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序可以通过`SessionFactory()`调用创建多个会话，但每个`APIRouter`拥有一个会话是推荐的。
- en: Defining the Base class
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义Base类
- en: 'Next, we need to set up the `Base` class, which is crucial in mapping model
    classes to database tables. Although SQLAlchemy can create tables at runtime,
    we opted to utilize an existing schema definition for our prototype. Now, this
    `Base` class must be subclassed by the model classes so that the mapping to the
    tables will happen once the server starts. The following script shows how straightforward
    it is to set up this component:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要设置`Base`类，这在将模型类映射到数据库表中至关重要。尽管SQLAlchemy可以在运行时创建表，但我们选择利用现有的模式定义来构建我们的原型。现在，这个`Base`类必须由模型类继承，以便在服务器启动时发生到表的映射。以下脚本展示了设置此组件是多么简单：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Invoking the `declarative_base()` function is the easiest way of creating the
    `Base` class rather than creating `registry()` to call `generate_base()`, which
    can also provide us with the `Base` class.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`declarative_base()`函数是创建`Base`类而不是创建`registry()`来调用`generate_base()`的最简单方法，这也可以为我们提供`Base`类。
- en: Note that all these configurations are part of the `/db_config/sqlalchemy_connect.py`
    module of the prototype. They are bundled into one module since they are crucial
    in building the SQLAlchemy repository. But before we implement the CRUD transactions,
    we need to create the model layer using the `Base` class.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，所有这些配置都是原型 `/db_config/sqlalchemy_connect.py` 模块的一部分。由于它们在构建 SQLAlchemy 存储库中至关重要，因此它们被捆绑在一个模块中。但在我们实现
    CRUD 事务之前，我们需要使用 `Base` 类创建模型层。
- en: Building the model layer
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建模型层
- en: 'The model classes of SQLAlchemy have all been placed in the `/models/data/sqlalchemy_models.py`
    file of the fitness club project folder. If `BaseModel` is important to API request
    models, the `Base` class is essential in building the data layer. It is imported
    from the configuration file to define SQLAlchemy entities or models. The following
    code is from the module script, which shows how we can create model class definitions
    in SQLAlchemy ORM:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 的模型类已放置在健身俱乐部项目文件夹的 `/models/data/sqlalchemy_models.py` 文件中。如果 `BaseModel`
    对 API 请求模型很重要，那么 `Base` 类在构建数据层时是必不可少的。它从配置文件导入以定义 SQLAlchemy 实体或模型。以下代码来自模块脚本，展示了我们如何在
    SQLAlchemy ORM 中创建模型类定义：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `Signup` class is a sample of a SQLAlchemy model because it inherits the
    `Base` class’s properties. It is a mapped class because all its attributes are
    reflections of the column metadata of its physical table schema counterpart. The
    model has a `primary_key` property set to `True` because SQLAlchemy recommends
    each table schema have at least one primary key. The rest of the `Column` objects
    are mapped to column metadata that’s non-primary but can be *unique* or *indexed*.
    Each model class inherits the `__tablename__` property, which sets the name of
    the mapped table.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`Signup` 类是 SQLAlchemy 模型的示例，因为它继承了 `Base` 类的属性。它是一个映射类，因为所有其属性都是其物理表模式对应项的列元数据的反映。该模型将
    `primary_key` 属性设置为 `True`，因为 SQLAlchemy 建议每个表模式至少有一个主键。其余的 `Column` 对象映射到非主键但可以是
    *唯一* 或 *索引* 的列元数据。每个模型类继承 `__tablename__` 属性，该属性设置映射表的名称。'
- en: Most importantly, we need to ensure that the data type of the class attribute
    matches the column type of its column counterpart in the table schema. The column
    attribute must have the same name as the column counterpart. Otherwise, we need
    to specify the actual column name in the first argument of the `Column` class,
    as shown in the `username` and `password` columns of `Signup`. But most of the
    time, we must always make sure they are the same to avoid confusion.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，我们需要确保类属性的数据类型与其在表模式中列对应的列类型相匹配。列属性必须与列对应项具有相同的名称。否则，我们需要在 `Column` 类的第一个参数中指定实际的列名，如
    `Signup` 中的 `username` 和 `password` 列所示。但大多数情况下，我们必须始终确保它们相同，以避免混淆。
- en: Mapping table relationships
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 映射表关系
- en: SQLAlchemy strongly supports different types of parent-child or associative
    table relationships. Model classes involved in the relationship require the `relationship()`
    directive from the `sqlalchemy.orm` module to be utilized to establish one-to-many
    or one-to-one relationships among model classes. This directive creates a reference
    from the parent to the child class using some foreign key indicated in the table
    schema definition.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 强烈支持不同类型的父子或关联表关系。参与关系的模型类需要使用 `sqlalchemy.orm` 模块中的 `relationship()`
    指令来利用模型类之间的一对多或一对一关系。此指令通过表模式定义中指示的外键从父类创建对子类的引用。
- en: 'A child model class uses the `ForeignKey` construct in its foreign key column
    object to link the model class to its parent’s reference key column object. This
    directive indicates that the values in this column should be within the values
    stored in the parent table’s reference column. The `ForeignKey` directive applies
    to both the primary and non-primary `Column` objects. The following model class
    defines a sample column relationship in our database schema:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一个子模型类使用其外键列对象中的 `ForeignKey` 构造来将其模型类与其父类的参考键列对象链接。此指令表示该列中的值应包含在父表参考列中存储的值内。`ForeignKey`
    指令适用于主键和非主键的 `Column` 对象。以下模型类定义了我们数据库模式中的一个示例列关系：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This `Login` model is linked to two children, `Profile_Trainers` and `Profile_Members`,
    based on its configuration. Both child models have the `ForeignKey` directive
    in their `id` column objects, as shown in the following model definitions:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 此 `Login` 模型根据其配置与两个子类 `Profile_Trainers` 和 `Profile_Members` 链接。这两个子模型在其 `id`
    列对象中都有 `ForeignKey` 指令，如下面的模型定义所示：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `relationship()` directive is the sole directive for creating table relationships.
    We need to specify some of its parameters, such as the *name of the child model
    class* and the *backreference specification*. The `back_populates` parameter refers
    to the complementary attribute names of the related model classes. This indicates
    the rows that need to be fetched using some relationship loading technique during
    join query transactions. The `backref` parameter can also be used instead of `back_populates`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`relationship()` 指令是创建表关系的唯一指令。我们需要指定一些其参数，例如 *子模型类的名称* 和 *反向引用指定*。`back_populates`
    参数指的是相关模型类的互补属性名称。这表示在连接查询事务期间需要使用某些关系加载技术获取的行。`backref` 参数也可以用来代替 `back_populates`。'
- en: 'On the other hand, `relationship()` can return either a `List` or scalar object,
    depending on the relationship type. If it is a *one-to-one type*, the parent class
    should set the `useList` parameter to `False` to indicate that it will return
    a scalar value. Otherwise, it will select a list of records from the child table.
    The previous `Login` class definition shows that `Profile_Trainers` and `Profile_Members`
    hold a one-to-one relationship with `Login` because `Login` sets its `uselist`
    to `False`. On the other hand, the model relationship between `Profile_Members`
    and `Attendance_Member` is a *one-to-many* type because `uselist` is set to `True`
    by default, as shown by the following definitions:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`relationship()` 方法可以返回一个 `List` 或标量对象，具体取决于关系类型。如果是一个 *一对一* 类型，父类应该将 `useList`
    参数设置为 `False` 以指示它将返回一个标量值。否则，它将从子表中选取记录列表。之前的 `Login` 类定义显示 `Profile_Trainers`
    和 `Profile_Members` 与 `Login` 之间保持一对一关系，因为 `Login` 将其 `uselist` 设置为 `False`。另一方面，`Profile_Members`
    和 `Attendance_Member` 之间的模型关系是一个 *一对多* 类型，因为默认情况下 `uselist` 被设置为 `True`，如下面的定义所示：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: While setting the model relationships, we must also consider the *relationship
    loading type* that these related model classes will be using during the join query
    transactions. We specify this detail in the `lazy` parameter of `relationship()`,
    which is assigned to `select` by default. This is because SQLAlchemy uses a lazy
    loading technique by default in retrieving join queries. However, you can modify
    it to use `joined` (`lazy="joined"`), `subquery` (`lazy="subquery"`), `select
    in` (`lazy="selectin"`), `raise` (`lazy="raise"`), or `no` (`lazy="no"`) loading.
    Among the options, the `joined` approach is better for *INNER JOIN* transactions.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置模型关系时，我们还必须考虑这些相关模型类在连接查询事务期间将使用的 *关系加载类型*。我们在 `relationship()` 的 `lazy`
    参数中指定此细节，默认情况下分配给 `select`。这是因为 SQLAlchemy 默认使用懒加载技术在检索连接查询。然而，您可以将其修改为使用 `joined`
    (`lazy="joined"`), `subquery` (`lazy="subquery"`), `select in` (`lazy="selectin"`),
    `raise` (`lazy="raise"`), 或 `no` (`lazy="no"`) 加载。在这些选项中，`joined` 方法更适合 *INNER
    JOIN* 事务。
- en: Implementing the repository layer
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现仓库层
- en: In the SQLAlchemy ORM, creating the repository layer requires the *model classes*
    and a `Session` object. The `Session` object, derived from the `SessionFactory()`directive,
    establishes all the communication to the database and manages all the model objects
    before the `commit()` or `rollback()` transaction. When it comes to the queries,
    the `Session` entity stores the result set of records in a data structure called
    an *identity map*, which maintains the unique identity of each data record using
    the primary keys.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SQLAlchemy ORM 中，创建仓库层需要 *模型类* 和一个 `Session` 对象。`Session` 对象由 `SessionFactory()`
    指令派生，它建立了与数据库的所有通信，并在 `commit()` 或 `rollback()` 事务之前管理所有模型对象。当涉及到查询时，`Session`
    实体将记录的结果集存储在一个称为 *身份映射* 的数据结构中，该映射使用主键维护每个数据记录的唯一标识。
- en: All repository transactions are *stateless*, which means the session is automatically
    closed after loading the model objects for insert, update, and delete transactions
    when the database issues a `commit()` or `rollback()` operation. We import the
    `Session` class from the `sqlalchemy.orm` module.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 所有仓库事务都是 *无状态的*，这意味着在数据库执行 `commit()` 或 `rollback()` 操作后，会自动关闭加载模型对象用于插入、更新和删除事务的会话。我们从
    `sqlalchemy.orm` 模块导入 `Session` 类。
- en: Building the CRUD transactions
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建CRUD事务
- en: 'Now, we can start building the repository layer of the fitness club application
    since we have already satisfied the requirements to build the CRUD transactions.
    The following `SignupRepository` class is the blueprint that will show us how
    to *insert*, *update*, *delete*, and *retrieve* record(s) to/from the `signup`
    table:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始构建健身俱乐部应用的仓库层了，因为我们已经满足了构建 CRUD 事务的要求。下面的 `SignupRepository` 类是蓝图，它将展示我们如何
    *插入*、*更新*、*删除* 和 *检索* 记录到/从 `signup` 表：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'So far, `insert_signup()` is the most accurate way of persisting records to
    the `signup` table using SQLAlchemy. `Session` has an `add()` method, which we
    can invoke to add all record objects to the table, and a `commit()` transaction
    to finally flush all the new records into the database. The `flush()` method of
    `Session` is sometimes used instead of `commit()` to pursue the insertion and
    close `Session`, but most developers often use the latter. Note that the `signup`
    table contains all the gym members and trainers who want to gain access to the
    system. Now, the next script implements update record transaction:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，`insert_signup()` 是使用 SQLAlchemy 将记录持久化到 `signup` 表的最准确的方法。`Session` 有一个
    `add()` 方法，我们可以调用它来将所有记录对象添加到表中，以及一个 `commit()` 事务来最终将所有新记录刷新到数据库中。`Session` 的
    `flush()` 方法有时会代替 `commit()` 来执行插入并关闭 `Session`，但大多数开发者通常使用后者。请注意，`signup` 表包含所有想要获取系统访问权限的健身房会员和教练。现在，下一个脚本实现了更新记录事务：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `update_signup()` provides a short, straightforward, and robust solution
    to updating a record in SQLAlchemy. Another possible solution is to query the
    record through `self.sess.query(Signup).filter(Signup.id == id).first()`, replace
    the attribute values of the retrieved object with the new values from the `details`
    dictionary, and then invoke `commit()`. This way is acceptable, but it takes three
    steps rather than calling the `update()` method after `filter()`, which only takes
    one. Next script is an implementation of a delete record transaction:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`update_signup()` 提供了一个简短、直接且健壮的解决方案来更新 SQLAlchemy 中的记录。另一种可能的解决方案是通过 `self.sess.query(Signup).filter(Signup.id
    == id).first()` 查询记录，用 `details` 字典中的新值替换检索到的对象的属性值，然后调用 `commit()`。这种方式是可以接受的，但它需要三个步骤，而不是在
    `filter()` 之后调用 `update()` 方法，后者只需要一步。下一个脚本是一个删除记录事务的实现：'
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'On the other hand, `delete_signup()` follows the strategy of `update_signup()`,
    which uses `filter()` first before `delete()` is called. Another way of implementing
    this is to retrieve the object using `sess.query()` again and pass the retrieved
    object as an argument to the `Session` object’s `delete(obj)`, which is a different
    function. Always remember to invoke `commit()` to flush the changes. Now, the
    following script shows how to implement the query transactions:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`delete_signup()` 遵循 `update_signup()` 的策略，在调用 `delete()` 之前先使用 `filter()`。另一种实现方式是再次使用
    `sess.query()` 检索对象，并将检索到的对象作为参数传递给 `Session` 对象的 `delete(obj)`，这是一个不同的函数。始终记得调用
    `commit()` 来刷新更改。现在，以下脚本展示了如何实现查询事务：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Moreover, `SignupRepository` also highlights multiple and single records being
    retrieved in many forms. The `Session` object has a `query()` method, which requires
    *model class(es)* or *model column names* as argument(s). The function argument
    performs the record retrieval with column projection. For instance, the given
    `get_all_signup()` selects all signup records with all the columns projected in
    the result. If we want to include only `username` and `password`, we can write
    our query as `sess.query(Signup.username, Signup.password)`, just like in the
    given `get_all_signup_where()`. This `query()` method also shows how to manage
    constraints using the `filter()` method with the appropriate conditional expressions.
    Filtering always comes after column projection.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`SignupRepository` 还突出了以多种形式检索多个和单个记录。`Session` 对象有一个 `query()` 方法，它需要一个或多个
    *模型类* 或 *模型列名* 作为参数。函数参数执行带有列投影的记录检索。例如，给定的 `get_all_signup()` 选择了所有带有所有列投影的注册记录。如果我们只想包括
    `username` 和 `password`，我们可以将查询写成 `sess.query(Signup.username, Signup.password)`，就像在给定的
    `get_all_signup_where()` 中一样。这个 `query()` 方法还展示了如何使用 `filter()` 方法以及适当的条件表达式来管理约束。过滤总是在列投影之后进行。
- en: On the other hand, the `Session` object has an `order_by()` method that takes
    column names as parameters. It is performed last in the series of query transactions,
    before the result is extracted. The given sample, `get_all_signup_sorted_desc()`,
    sorts all `Signup` objects in descending order by `username`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`Session`对象有一个`order_by()`方法，它接受列名作为参数。它在查询事务的提取之前执行，是查询事务系列中的最后一个操作。给定的示例`get_all_signup_sorted_desc()`按`username`降序排序所有`Signup`对象。
- en: The last portion of the `query()` builder returns the result of the transactions,
    whether it is a list of records or a single record. The `all()` function ends
    the query statement that returns multiple records, while `first()`, `scalar()`,
    `one()`, or `one_or_none()` can be applied if the result is a single row. In `get_signup()`,
    `one_or_none()` is utilized to raise an exception when no record is returned.
    For SQLAlchemy’s query transactions, all these functions can close the `Session`
    object. The repository classes for SQLAlchemy are in the `ch05a` folder’s `/repository/sqlalchemy/signup.py`
    module script file.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`query()`构建器的最后一部分返回事务的结果，无论是记录列表还是单个记录。`all()`函数结束返回多个记录的查询语句，而`first()`、`scalar()`、`one()`或`one_or_none()`可以应用于结果为单行的情况。在`get_signup()`中，使用`one_or_none()`在无记录返回时引发异常。对于
    SQLAlchemy 的查询事务，所有这些函数都可以关闭`Session`对象。SQLAlchemy 的存储库类位于`ch05a`文件夹的`/repository/sqlalchemy/signup.py`模块脚本文件中。'
- en: Creating the JOIN queries
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建 JOIN 查询
- en: For all the ORMs supported by FastAPI, only SQLAlchemy implements join queries
    pragmatically and functionally, just like how we implemented the previous CRUD
    transactions. We used almost all of the methods we need to create joins previously
    except for `join()`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 FastAPI 支持的所有 ORM，只有 SQLAlchemy 实现了具有实用性和功能的联合查询，就像我们之前实现 CRUD 事务一样。我们几乎使用了创建联合查询所需的所有方法，除了`join()`。
- en: 'Let us look at `LoginMemberRepository`, which shows how we can create a join
    query statement in SQLAlchemy with model classes in *one-to-one relationships*:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`LoginMemberRepository`，它展示了如何使用 SQLAlchemy 的模型类在*一对一关系*中创建联合查询语句：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`join_login_members()` shows the conventional way of creating *JOIN* queries.
    This solution requires passing the parent and child classes as query parameters
    and overriding the `ON` condition through the `filter()` method. The parent model
    class must come first in the column projection before the child class in the `query()`
    builder to extract the preferred result.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`join_login_members()`展示了创建*JOIN*查询的传统方法。此解决方案需要传递父类和子类作为查询参数，并通过`filter()`方法覆盖`ON`条件。在`query()`构建器中，父模型类必须在子类之前出现在列投影中，以便提取所需的结果。'
- en: Another way is to use the `select_from()` function instead of `query()` to distinguish
    the parent class from the child. This approach is more appropriate for a *one-to-one*
    relationship.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用`select_from()`函数而不是`query()`来区分父类和子类。这种方法更适合*一对一*关系。
- en: 'On the other hand, `MemberAttendanceRepository` showcases the *one-to-many*
    relationship between the `Profile_Members` and `Attendance_Member` model classes:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`MemberAttendanceRepository`展示了`Profile_Members`和`Attendance_Member`模型类之间的*一对多*关系：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`join_member_attendance()` shows the use of the `join()` method in building
    the *INNER JOIN* queries between `Profile_Members` and `Attendance_Member`. `filter()`
    is not needed anymore to build the `ON` condition because `join()` automatically
    detects and recognizes the `relationship()` parameters and the `ForeignKey` constructs
    defined at the beginning. But if there are other additional constraints, `filter()`
    can always be invoked, but only after the `join()` method.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`join_member_attendance()`展示了在构建`Profile_Members`和`Attendance_Member`之间的*内连接*查询时`join()`方法的使用。由于`join()`自动检测并识别在开头定义的`relationship()`参数和`ForeignKey`构造，因此不再需要`filter()`来构建`ON`条件。但如果存在其他附加约束，`filter()`始终可以调用，但必须在`join()`方法之后。'
- en: The `outer_join_member()` repository method implements an *OUTER JOIN* query
    from the one-to-many relationship. The `outerjoin()` method will extract all `Profile_Members`
    records mapped to their corresponding `Attendance_Member` or return `null` if
    there are none.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`outer_join_member()`存储库方法实现了从一对多关系中的*外连接*查询。`outerjoin()`方法将提取所有映射到相应`Attendance_Member`的`Profile_Members`记录，如果没有，则返回`null`。'
- en: Running the transactions
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行事务
- en: Now, let us apply these repository transactions to the administration-related
    API services of our application. Instead of using collections to store all the
    records, we will be utilizing the ORM’s transactions to manage the data using
    PostgreSQL. First, we need to import the essential components required by the
    repository, such as `SessionFactory`, the repository class, and the `Signup` model
    class. APIs such as `Session` and other `typing` APIs can only be part of the
    implementation for type hints.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将这些存储库事务应用到我们应用程序的与行政相关的API服务中。我们不会使用集合来存储所有记录，而是将利用ORM的事务来使用PostgreSQL管理数据。首先，我们需要导入存储库所需的必要组件，例如`SessionFactory`、存储库类和`Signup`模型类。像`Session`和其他`typing`
    API这样的API只能作为实现类型提示的一部分。
- en: 'The following script shows a portion of the administrator’s API services highlighting
    the insertion and retrieval services for new access registration:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下脚本展示了管理员API服务的一部分，突出了新访问注册的插入和检索服务：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'First, we need to create the `Session` instance through `SessionFactory()`,
    which we derived from `sessionmaker()`, since the repository layer is dependent
    on the session. In our application, a `sess_db()` custom generator is used to
    open and destroy the `Session` instance. It is injected into the API service methods
    to tell the `Session` instance to proceed with instantiating `SignupRepository`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要通过`SessionFactory()`创建`Session`实例，这是从`sessionmaker()`派生出来的，因为存储库层依赖于会话。在我们的应用程序中，使用了一个自定义生成器`sess_db()`来打开和销毁`Session`实例。它被注入到API服务方法中，以告诉`Session`实例继续实例化`SignupRepository`：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Once instantiated, the repository can provide record insertion through `insert_signup()`,
    which inserts the `Signup` record. Another of its methods is `get_all_signup()`,
    which retrieves all login accounts for approval:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦实例化，存储库可以通过`insert_signup()`方法提供记录插入，该方法插入`Signup`记录。它的另一个方法是`get_all_signup()`，该方法检索所有待批准的登录账户：
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Both the `get_signup()` and `list_signup()` services have a `request_model`
    of the `SignupReq` type, which determines the expected output of the APIs. But
    as you may have noticed, `get_signup()` returns the `Signup` object, while `list_signup()`
    returns a list of `Signup` records. How is that possible? If `request_model` is
    used to capture the query result of the SQLAlchemy query transactions, the `BaseModel`
    class or request model must include a nested `Config` class with its `orm_mode`
    set to `True`. This built-in configuration enables type mapping and validation
    of `BaseModel` for the SQLAlchemy model types used by the repository, before all
    the record objects are filtered and stored in the request models. More information
    about the `response_model` parameter can be found in [*Chapter 1*](B17975_01.xhtml#_idTextAnchor014),
    *Setting Up FastAPI for Starters*.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_signup()`和`list_signup()`服务都有一个`SignupReq`类型的`request_model`，这决定了API的预期输出。但正如你可能已经注意到的，`get_signup()`返回`Signup`对象，而`list_signup()`返回`Signup`记录的列表。这是如何实现的？如果`request_model`用于捕获SQLAlchemy查询事务的查询结果，则`BaseModel`类或请求模型必须包含一个嵌套的`Config`类，其`orm_mode`设置为`True`。这个内置配置在所有记录对象被过滤并存储在请求模型之前，为存储库使用的SQLAlchemy模型类型启用类型映射和验证。有关`response_model`参数的更多信息，请参阅[*第1章*](B17975_01.xhtml#_idTextAnchor014)，*为初学者设置FastAPI*。'
- en: '`SignupReq`, which is used by the query services of our application, is defined
    as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序的查询服务使用的`SignupReq`定义如下：
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The script shows how `orm_mode` is enabled using the equals sign (`=`) rather
    than the typical colon symbol (`:`), which means `orm_mode` is a configuration
    detail and not part of the class attribute.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本展示了如何使用等号（`=`）而不是典型的冒号符号（`:`）来启用`orm_mode`，这意味着`orm_mode`是配置细节，而不是类属性的一部分。
- en: Overall, using SQLAlchemy for the repository layer is systematic and procedural.
    It is easy to map and synchronize the model classes with the schema definitions.
    Establishing relationships through the model classes is handy and predictable.
    Although there are lots of APIs and directives involved, it is still the most
    widely supported library for domain modeling and repository construction. Its
    documentation ([https://docs.sqlalchemy.org/en/14/](https://docs.sqlalchemy.org/en/14/))
    is complete and informative enough to guide developers regarding the different
    API classes and methods.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，使用SQLAlchemy作为存储库层是系统化和程序化的。它很容易将模型类与模式定义进行映射和同步。通过模型类建立关系既方便又可预测。尽管涉及许多API和指令，但它仍然是领域建模和存储库构建最广泛支持的库。它的文档([https://docs.sqlalchemy.org/en/14/](https://docs.sqlalchemy.org/en/14/))完整且信息丰富，足以指导开发者了解不同的API类和方法。
- en: Another feature of SQLAlchemy that’s loved by many is its capability to generate
    table schemas at the application level.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy受到许多人喜爱的另一个特性是它能够在应用级别生成表模式。
- en: Creating tables
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建表
- en: Usually, SQLAlchemy works with the table schemas that have already been generated
    by the database administrator. In this project, the ORM setup started with designing
    the domain model classes before mapping them to the actual tables. But SQLAlchemy
    can auto-create table schemas at runtime for the FastAPI platform, which may be
    helpful during the testing or prototyping stage of the project.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，SQLAlchemy与数据库管理员已经生成的表模式一起工作。在这个项目中，ORM设置是从设计领域模型类开始的，然后将其映射到实际的表。但SQLAlchemy可以为FastAPI平台在运行时自动创建表模式，这在项目的测试或原型阶段可能很有帮助。
- en: 'The `sqlalchemy` module has a `Table()` directive that can create a table object
    with the essential column metadata using the `Column()` method, which we used
    in the mapping. The following is a sample script that shows how the ORM creates
    the signup table at the application level:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`sqlalchemy`模块有一个`Table()`指令，可以使用`Column()`方法创建一个表对象，该方法我们在映射中使用过。以下是一个示例脚本，展示了ORM如何在应用级别创建注册表：'
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Part of the schema definition is `MetaData()`, a registry that contains the
    necessary methods for generating the tables. When all the schema definitions are
    signed off, the `create_all()` method of the `MetaData()` instance is executed
    with the engine to create the tables. This process may sound straightforward,
    but we seldom pursue this DDL feature of SQLAlchemy in projects at the production
    stage.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 模式定义的一部分是`MetaData()`，这是一个包含生成表所需方法的注册表。当所有模式定义都获得批准后，`MetaData()`实例的`create_all()`方法与引擎一起执行以创建表。这个过程听起来很简单，但在生产阶段的项目中，我们很少追求SQLAlchemy的这个DDL特性。
- en: Now, let us explore how SQLAlchemy can be used to create asynchronous CRUD transactions
    for asynchronous API services.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们探索如何使用SQLAlchemy为异步API服务创建异步CRUD事务。
- en: Implementing async CRUD transactions using SQLAlchemy
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SQLAlchemy实现异步CRUD事务
- en: From version 1.4, SQLAlchemy supports `Session` object. Our `ch05b` project
    showcases the asynchronous side of SQLAlchemy.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本1.4开始，SQLAlchemy支持`Session`对象。我们的`ch05b`项目展示了SQLAlchemy的异步方面。
- en: Installing the asyncio-compliant database drivers
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装符合asyncio规范的数据库驱动程序
- en: 'Before we begin setting up the database configuration, we need to install the
    following asyncio-compliant drivers: `aiopg` and `asyncpg`. First, we need to
    install `aiopg`, a library that will assist with any asynchronous access to PostgreSQL:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始设置数据库配置之前，我们需要安装以下符合asyncio规范的驱动程序：`aiopg`和`asyncpg`。首先，我们需要安装`aiopg`，这是一个库，它将帮助进行任何异步访问PostgreSQL：
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, we must install `asyncpg`, which helps build PostgreSQL asynchronous
    transactions through Python’s AsyncIO framework:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须安装`asyncpg`，它通过Python的AsyncIO框架帮助构建PostgreSQL异步事务：
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This driver is a *non-database API-compliant* driver because it runs on top
    of the AsyncIO environment instead of the database API specification for synchronous
    database transactions.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个驱动程序是一个*非数据库API规范*的驱动程序，因为它在AsyncIO环境之上运行，而不是在同步数据库事务的数据库API规范之上。
- en: Setting up the database’s connection
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置数据库的连接
- en: 'After installing the necessary drivers, we can derive the database engine through
    the application’s `create_async_engine()` method, which creates an asynchronous
    version of SQLAlchemy’s `Engine`, known as `AsyncEngine`. This method has parameters
    to set such as `future`, which can enable a variety of asynchronous features during
    CRUD transactions when set to `True`. Also, it has an `echo` parameter that can
    provide us with the generated SQL queries in the server log at runtime. But the
    most essential is the database URL, which now reflects the asynchronous database
    access through calling the `asyncpg` protocol. The following is the complete script
    for the asynchronous connection to the PostgreSQL database:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 安装必要的驱动程序后，我们可以通过应用程序的`create_async_engine()`方法推导出数据库引擎，该方法创建了一个异步版本的SQLAlchemy的`Engine`，称为`AsyncEngine`。此方法有参数可以设置，如`future`，当设置为`True`时，可以在CRUD事务期间启用各种异步功能。此外，它还有一个`echo`参数，可以在运行时提供服务器日志中生成的SQL查询。但最重要的是数据库URL，现在它反映了通过调用`asyncpg`协议的异步数据库访问。以下是对PostgreSQL数据库的异步连接的完整脚本：
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The additional `"+asyncpg"` detail in `DB_URL` indicates that `psycopg2` will
    no longer be the core database driver for PostgreSQL; instead, `asyncpg` will
    be used. This detail enables `AsyncEngine` to utilize `asyncpg` to establish the
    connection to the database. Omitting this detail will instruct the engine to recognize
    the `psycopg2` database API driver, which will cause problems during the CRUD
    transactions.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`DB_URL`中的附加`"+asyncpg"`细节表明`psycopg2`将不再是PostgreSQL的核心数据库驱动程序；相反，将使用`asyncpg`。此细节使`AsyncEngine`能够利用`asyncpg`建立与数据库的连接。省略此细节将指示引擎识别`psycopg2`数据库API驱动程序，这将在CRUD事务期间引起问题。'
- en: Creating the session factory
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建会话工厂
- en: Like in the synchronous version, the `sessionmaker()` directive is utilized
    to create the session factory with some new parameters set to enable `AsyncSession`.
    First, its `expire_on_commit` parameter is set to `False` to make that model instances
    and its attribute values accessible for the duration of the transaction, even
    after calling `commit()`. Unlike in the synchronous environment, all entity classes
    and their column objects are still accessible by other processes, even after transaction
    commit. Then, its `class_` parameter bears the class name `AsyncSession`, the
    entity that will take control of the CRUD transactions. Of course, `sessionmaker()`
    still needs the engine for `AsyncConnection` and its underlying asynchronous context
    managers.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 与同步版本类似，`sessionmaker()`指令被用来创建带有一些新参数的会话工厂以启用`AsyncSession`。首先，将`expire_on_commit`参数设置为`False`，以便在事务期间，即使调用`commit()`后，模型实例及其属性值仍然可访问。与同步环境不同，所有实体类及其列对象在事务提交后仍然可以被其他进程访问。然后，其`class_`参数携带类名`AsyncSession`，该实体将控制CRUD事务。当然，`sessionmaker()`仍然需要`AsyncConnection`及其底层的异步上下文管理器。
- en: 'The following script shows how the session factory is derived using the `sessionmaker()`
    directive:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 以下脚本展示了如何使用`sessionmaker()`指令推导出会话工厂：
- en: '[PRE24]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The full configuration for the asynchronous SQLAlchemy database connection can
    be found in the `/db_config/sqlalchemy_async_connect.py` module script file. Let
    us now create the model layer.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 异步SQLAlchemy数据库连接的完整配置可以在`/db_config/sqlalchemy_async_connect.py`模块脚本文件中找到。现在让我们创建模型层。
- en: Creating the Base class and the model layer
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建基类和模型层
- en: Creating the `Base` class using `declarative_base()` and creating the model
    classes using `Base` is the same as what we did in the synchronous version. No
    additional parameters are needed to build the data layer for the asynchronous
    repository transactions.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`declarative_base()`创建`Base`类和使用`Base`创建模型类与同步版本中的操作相同。构建异步存储库事务的数据层不需要额外的参数。
- en: Building the repository layer
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建存储库层
- en: 'Implementing asynchronous CRUD transactions is entirely different from implementing
    synchronous ones. The ORM supports the use of the `execute()` method of the `AsyncConnection`
    API to run some of the built-in ORM core methods, namely `update()`, `delete()`,
    and `insert()`. When it comes to query transactions, the new `select()` directive
    from the `sqlalchemy.future` module is used instead of the core `select()` method.
    And since `execute()` is an `async` method, this requires that all repository
    transactions are `async` too to apply the *Async/Await* design pattern. The following
    `AttendanceRepository` uses the asynchronous type of SQLAlchemy:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 实现异步CRUD事务与实现同步事务完全不同。ORM支持使用`AsyncConnection` API的`execute()`方法来运行一些内置的ORM核心方法，即`update()`、`delete()`和`insert()`。当涉及到查询事务时，使用来自`sqlalchemy.future`模块的新`select()`指令而不是核心的`select()`方法。由于`execute()`是一个`async`方法，这要求所有仓库事务都是`async`，以便应用*Async/Await*设计模式。下面的`AttendanceRepository`使用了SQLAlchemy的异步类型：
- en: '[PRE25]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The given *asynchronous* `insert_attendance()` method in the preceding script
    shows the use of the `insert()` directive in creating an attendance log for a
    gym member. First, we need to pass the model class name to `insert()` to let the
    session know what table to access for the transaction. Afterward, it emits the
    `values()` method to project all the column values for insertion. Lastly, we need
    to call the `execute()` method to run the final `insert()` statement and automatically
    commit the changes since we didn’t turn off the `autocommit` parameter of `sessionmaker()`
    during the configuration. Do not forget to invoke `await` before running the asynchronous
    method because everything runs on top of the AsyncIO platform this time.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的脚本中给出的*异步*`insert_attendance()`方法展示了在创建健身房成员的出勤日志时使用`insert()`指令。首先，我们需要将模型类名传递给`insert()`，以便会话知道要访问哪个表进行事务。之后，它发出`values()`方法来投影插入的所有列值。最后，我们需要调用`execute()`方法来运行最终的`insert()`语句，并自动提交更改，因为我们没有在配置期间关闭`sessionmaker()`的`autocommit`参数。不要忘记在运行异步方法之前调用`await`，因为这次所有操作都是在AsyncIO平台上运行的。
- en: Also, you have the option to add some additional execution details before running
    `execute()`. One of these options is `synchronize_session`, which tells the session
    to always synchronize the model attribute values and the updated values from the
    database using the `fetch` method.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您还有在运行`execute()`之前添加一些额外执行细节的选项。这些选项之一是`synchronize_session`，它告诉会话始终使用`fetch`方法同步模型属性值和数据库中的更新值。
- en: 'Almost the same procedure is applied to the `update_attendance()` and `delete_attendance()`
    methods. We can run them through `execute()` and nothing else:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`update_attendance()`和`delete_attendance()`方法，几乎采用相同的程序。我们可以通过`execute()`运行它们，无需其他操作：
- en: '[PRE26]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: When it comes to queries, the repository class contains `get_all_attendance()`,
    which retrieves all the attendance records, and `get_attendance()`, which retrieves
    the attendance log of a particular member through its `id`. Constructing the `select()`
    method is a straightforward and pragmatic task since it is similar to writing
    a native `SELECT` statement in SQL development. First, the method needs to know
    what columns to project, and then it caters to some constraints if there are any.
    Then, it needs the `execute()` method to run the query asynchronously and extract
    the `Query` object. The resulting `Query` object has a `scalars()` method, which
    we can call to retrieve the list of records. Do not forget to close the session
    by calling the `all()` method.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到查询时，仓库类包含`get_all_attendance()`方法，用于检索所有出勤记录，以及`get_attendance()`方法，通过其`id`检索特定成员的出勤日志。构建`select()`方法是一个简单且实用的任务，因为它类似于在SQL开发中编写原生的`SELECT`语句。首先，该方法需要知道要投影哪些列，然后如果有任何约束，它将满足这些约束。然后，它需要`execute()`方法来异步运行查询并提取`Query`对象。生成的`Query`对象有一个`scalars()`方法，我们可以调用它来检索记录列表。不要忘记通过调用`all()`方法来关闭会话。
- en: '`check_attendance()`, on the other hand, uses the `scalar()` method of the
    `Query` object to retrieve one record: a specific attendance. Aside from record
    retrieval, `scalar()` also closes the session:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`check_attendance()`使用`Query`对象的`scalar()`方法来检索一条记录：特定的出勤记录。除了记录检索外，`scalar()`还会关闭会话：
- en: '[PRE27]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The repository classes for the asynchronous SQLAlchemy can be found in the `/repository/sqlalchemy/attendance.py`
    module script file. Now, let us apply these asynchronous transactions to pursue
    some attendance monitoring services for our fitness gym application.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: The `**` operator in `update_attendance()` is a Python operator overload that
    converts a dictionary into `kwargs`. Thus, the result of `**details` is a `kwargs`
    argument for the `values()` method of the `select()` directive.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Running the CRUD transactions
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There two big differences between AsyncIO-driven SQLAlchemy and the database
    API-compliant option when creating the `Session` instance:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: First, `AsyncSession`, which was created by the `AsyncSessionFactory()` directive,
    needs an asynchronous `with` context manager because of the connection’s `AsyncEngine`,
    which needs to be closed after every `commit()` transaction. Closing the session
    factory is not part of the procedure in the synchronous ORM version.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, after its creation, `AsyncSession` will only start executing all the
    CRUD transactions when the service calls its `begin()` method. The main reason
    is that `AsyncSession` can be closed and needs to be closed once the transaction
    has been executed. That is why another asynchronous context manager is used to
    manage `AsyncSession`.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code shows the `APIRouter` script, which implements the services
    for monitoring gym member attendance using the asynchronous `AttendanceRepository`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The preceding script shows no direct parameter passing between the repository
    class and the `AsyncSession` instance. The session must comply with the two context
    managers before it becomes a working one. This syntax is valid under *SQLAlchemy
    1.4*, which may undergo some changes in the future with SQLAlchemy’s next releases.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Other ORM platforms that have been created for asynchronous transactions are
    easier to use. One of these is **GINO**.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Using GINO for async transactions
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**GINO**, which stands for **GINO Is Not ORM**, is a lightweight asynchronous
    ORM that runs on top of an SQLAlchemy Core and AsyncIO environment. All its APIs
    are asynchronous-ready so that you can build contextual database connections and
    transactions. It has built-in *JSONB* support so that it can convert its results
    into JSON objects. But there is one catch: GINO only supports PostgreSQL databases.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: While creating the gym fitness project, the only available stable GINO version
    is 1.0.1, which requires *SQLAlchemy 1.3*. Therefore, installing GINO will automatically
    uninstall *SQLAlchemy 1.4*, thus adding the GINO repository to the `ch05a` project
    to avoid any conflicts with the async version of SQLAlchemy.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the following command to install the latest version of GINO:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Installing the database driver
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since the only RDBMS it supports is PostgreSQL, you only need to install `asyncpg`
    using the `pip` command.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Establishing the database connection
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'No other APIs are needed to open a connection to the database except for the
    `Gino` directive. We need to instantiate the class to start building the domain
    layer. The `Gino` class can be imported from the ORM’s `gino` module, as shown
    by the following script:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Its instance is like a façade that controls all database transactions. It starts
    by establishing a database connection once it’s been provided with the correct
    PostgreSQL administrator credentials. The full GINO database connectivity script
    can be found in the `/db_config/gino_connect.py` script file. Let us now build
    the model layer.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Building the model layer
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The model class definition in GINO has similarities with SQLAlchemy when it
    comes to structuring, column metadata, and even the existence of the `__tablename__`
    property. The only difference is the superclass type because GINO uses the `Model`
    class from the database reference instance’s `db`. The following script shows
    how the `Signup` domain model is mapped to the `signup` table:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Like in SQLAlchemy, the `__tablename__` property is mandatory for all model
    classes to indicate their mapped table schema. When defining the column metadata,
    the `db` object has a `Column` directive that can set properties such as the *column
    type*, *primary key*, *unique*, *default*, *nullable*, and *index*. The column
    types also come from the `db` reference object, and these types are also the same
    for SQLAlchemy – that is, `String`, `Integer`, `Date`, `Time`, `Unicode`, and
    `Float`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: And just in case the name of the model attribute does not match the column name,
    the `Column` directive has its first parameter register the name of the actual
    column and maps it to the model attributes. The `username` and `password` columns
    are example cases of mapping the class attributes to the table’s column names.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Mapping table relationships
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'At the time of writing, GINO only supports the *many-to-one relationship* by
    default. The `db` reference object has a `ForeignKey` directive, which establishes
    a foreign key relationship with the parent model. It just needs the actual reference
    key column and table name of the parent table to pursue the mapping. Setting the
    `ForeignKey` property in the `Column` object of the child model class is enough
    configuration to perform a *LEFT OUTER JOIN* to retrieve all the child records
    of the parent mode class. GINO has no `relationship()` function to address more
    details regarding how to fetch the child records of the parent model class. However,
    it has built-in loaders to automatically determine the foreign key and perform
    a many-to-one join query afterward. A perfect setup for this join query is the
    relationship configuration between the `Profile_Trainers` and `Gym_Class` model
    classes, as shown in the following script:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We will have to make some changes if we need to build a query that will deal
    with a *one-to-many* or a *one-to-one relationship*. For the *LEFT OUTER JOIN*
    query to work, the parent model class must have a `set` collection defined to
    contain all the child records during join queries involving one-to-many relationships.
    For a *one-to-one relationship*, the parent only needs to instantiate the child
    model:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This *set collection* or *child object* must be instantiated in the parent’s
    `__init__()` to be accessed by the ORM’s loader through the *children* or *child*
    `@property`, respectively. Using `@property` is the only way to manage joined
    records.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Note that the existence of the loader APIs is proof that GINO does not support
    the automated relationship that SQLAlchemy has. If we want to deviate from its
    core setup, Python programming is needed to add some features not supported by
    the platform, such as the one-to-many setup between `Profile_Members` and `Gym_Class`,
    and between `Login` and `Profile_Members`/`Profile_Trainers`. In the previous
    script, notice the inclusion of a constructor and the custom `children` Python
    property in `Profile_Members`, as well as the custom `child` property in `Login`.
    This is because GINO only has a built-in `parent` property.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: You can find the domain models of GINO in the `/models/data/gino_models.py`
    script.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '`@property` is a Python decorator that’s used to implement a getter/setter
    in a class. This hides an instance variable from the accessor and exposes its
    *getter* and *setter* property *fields*. Using `@property` is one way to implement
    the *encapsulation* principle in Python.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the CRUD transactions
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us consider the following `TrainerRepository`, which manages trainer profiles.
    Its `insert_trainer()` method shows the conventional way of implementing insert
    transactions. GINO requires its model class to call `create()`, an inherited method
    from the `db` reference object. All the column values are passed to the `create()`
    method through named parameters or as a bundle using `kwargs` before the record
    object is persisted. But GINO allows another insert option that uses the instance
    of the model derived by injecting column values into its constructor. The created
    instance has a method called `create()` that inserts the record object without
    requiring any parameters:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '`update_trainer()` highlights how GINO updates table records. Based on the
    script, updating the table in the GINO way involves doing the following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: First, it requires the `get()` class method of the model class to retrieve the
    record object with the `id` primary key.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Second, the extracted record has an instance method called `update()` that
    will automatically modify the mapped row with the new data specified in its `kwargs`
    argument. The `apply()` method will commit the changes and close the transaction:'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Another option is to use the SQLAlchemy `ModelClass.update.values(ModelClass).where(expression)`
    clause, which, when applied to `update_trainer()`, will give us this final statement:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Its `delete_trainer()` also follows the same approach as the GINO *update*
    transaction. This transaction is a two-step process, and the last step requires
    calling the `delete()` instance method of the extracted record object:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'On the other hand, `TrainerRepository` has two methods, `get_member()` and
    `get_all_member()`, which show how GINO constructs query statements:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: The former retrieves a specific record object using its primary key through
    the `get()` class method of the model class
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The latter uses the `gino` extension of `query` to utilize the `all()` method,
    which retrieves the records:'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'But what translates database rows into model objects in a query’s execution
    is the built-in loader of GINO. If we expand further on the solution presented
    in `get_all_member()`, this will look like this:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In the GINO ORM, all queries utilize `ModelLoader` to load each database record
    into a model object:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: If the normal query requires `ModelLoader`, what is needed for the *JOIN* query
    transactions? GINO has no automated support for table relationships, and creating
    *JOIN* queries is impossible without `ModelLoader`. The `join_classes_trainer()`
    method implements a *one-to-many* query for `Profile_Trainers` and `Gym_Class`.
    The `distinct(Gym_Class.id).load(parent=Profile_Trainers)` clause in the query
    creates a `ModelLoader` for `GymClass`, which will merge and load the `Profile_Trainers`
    parent record into its child `Gym_Class`. `join_member_classes()` creates *one-to-many*
    joins, while `distinct(Profile_Members.id).load(add_child=Gym_Class)` creates
    a `ModelLoader` to build the set of `Gym_Class` records, as per the `Profile_Members`
    parent.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, the *many-to-one* relationship of `Gym_Class` and `Profile_Members`
    uses the `load()` function of `Profile_Member`, which is a different approach
    to matching the `Gym_Class` child records to `Profile_Members`. The following
    joined query is the opposite of the *one-to-many* setup because the `Gym_Class`
    records here are on the left-hand side while the profiles are on the right:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: So, the loader plays an important role in building queries in GINO, especially
    joins. Although it makes query building difficult, it still gives flexibility
    to many complex queries.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: All the repository classes for GINO can be found in the `/repository/gino/trainers.py`
    script.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Running the CRUD transactions
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For our repositories to run in the `APIRouter` module, we need to open the
    database connection by binding the `db` reference object to the actual database
    through `DB_URL`. It is ideal to use a dependable function for the binding procedure
    because the easier form of rolling out is done through `APIRouter` injection.
    The following script shows how to set up this database binding:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `list_trainers()` and `update_trainer()` REST services shown in the preceding
    code are some services of our *fitness club* application that will successfully
    run `TrainerRepository` after injecting `sess_db()` into `APIRouter`. GINO does
    not ask for many details when establishing the connection to PostgreSQL except
    for `DB_URL`. Always specify the `asyncpg` dialect in the URL because it is the
    only driver that’s supported by GINO as a synchronous ORM.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Creating the tables
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'GINO and SQLAlchemy have the same approach to creating a table schema at the
    framework level. Both require the `MetaData` and `Column` directives for building
    the `Table` definitions. Then, an asynchronous function is preferred to derive
    the engine using the `create_engine()` method with our `DB_URL`. Like in SQLAlchemy,
    this engine plays a crucial role in building the tables through `create_all()`,
    but this time, it uses GINO’s `GinoSchemaVisitor` instance. The following script
    shows the complete implementation of how tables are generated in GINO using the
    AsyncIO platform:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: As stated in SQLAlchemy, performing DDL transactions such as schema auto-generation
    at the start is optional because it may cause FastAPI’s performance to degrade,
    and even some conflicts in the existing database schema.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let us explore another ORM that requires custom Python coding: **Pony
    ORM**.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Using Pony ORM for the repository layer
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pony ORM relies on Python syntax for building the model classes and repository
    transactions. This ORM only uses Python data types such as `int`, `str`, and `float`,
    as well as class types to implement model definitions. It applies Python `lambda`
    expressions to establish CRUD transactions, especially when mapping table relationships.
    Also, Pony heavily supports JSON conversion of record objects when reading records.
    On the other hand, Pony can cache the query objects, which provides faster performance
    than the others. The code for Pony ORM can be found in the `ch05a` project.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'To use Pony, we need to install it using `pip`. This is because it is a third-party
    platform:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Installing the database driver
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since Pony is an ORM designed to build synchronous transactions, we will need
    the `psycopg2` PostgreSQL driver. We can install it using the `pip` command:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Creating the database’s connectivity
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The approach to establishing database connectivity in Pony is simple and declarative.
    It only needs the `Database` directive from the `pony.orm` module to be instantiated
    to connect to the database using the correct database credentials. The following
    script is used in the *fitness club* prototype:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: As you can see, the first parameter of the constructor is the *database dialect*,
    followed by `kwargs`, which contains all the details about the connection. The
    full configuration can be found in the `/db_config/pony_connect.py` script file.
    Now, let us create Pony's model classes.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Defining the model classes
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The created database object, `db`, is the only component needed to define a
    Pony *entity*, a term that refers to a model class. It has an `Entity` attribute,
    which is used to subclass each model class to provide the `_table_` attribute,
    which is responsible for the *table-entity* mapping. All entity instances are
    bound to `db` and mapped to the tables. The following script shows how the `Signup`
    class becomes an entity of the model layer:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The `pony.orm` module contains `Required`, `Optional`, `PrimaryKey`, or `Set`
    directives, which are used to create column attributes. Since each entity must
    have a primary key, `PrimaryKey` is used to define the column attribute of the
    entity. If the class has no primary key, Pony ORM will implicitly generate an
    `id` primary for the entity with the following definition:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'On the other hand, the `Set` directive indicates relationships between entities.
    All these directives have a mandatory attribute column type, which declares the
    column value type in Python syntax (for example, `int`, `str`, `float`, `date`,
    or `time`) or any class type. Other column attributes include `auto`, `max_len`,
    `index`, `unique`, `nullable`, `default`, and `column`. Now, let us establish
    a relationship between model classes:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The given `Login` class has two additional attributes, `trainers` and `members`,
    which serve as reference keys to the `Profile_Trainers` and `Profile_Members`
    models, respectively. In turn, these child entities have their respective class
    attributes pointing back at the `Login` model, establishing a relationship. These
    column attributes and their reference-foreign keys relationship must match the
    physical database schema. The following code shows examples of Pony’s child model
    classes:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Defining the relationship attributes depends on the relationship type between
    the two entities. Attributes should be defined as *Optional(parent)*-*Required(child)*
    or *Optional(parent)*-*Optional(child)* if the relationship type is one-to-one.
    For one-to-many, attributes should be defined as *Set(parent)*-*Required(child)*.
    Finally, for many-to-one, the attributes must be defined as *Set(parent)*-*Set(child)*.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '`Login` has a one-to-one relationship with `Profile_Members`, which explains
    the use of the `Optional` attribute to point to the `id` key of `Profile_Members`.
    The primary keys are always the reference keys in this relationship for Pony.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, the `Profile_Trainers` model has a one-to-many setup with
    `Profile_Members`, which explains why the `trainer_id` attribute of the former
    uses the `Required` directive to point to the `Set` attribute `members` of the
    latter. Sometimes, the framework requires backreference through the directive’s
    `reverse` parameter. The preceding code also depicts the same scenario between
    the `Profile_Members` and `Gym_Class` models, where the `gclass` attribute of
    `Profile_Members` is declared as a `Set` collection that contains all the enrolled
    gym classes of the member. The reference key can be a primary key or just a typical
    class attribute in this relationship. The following snippet shows the blueprint
    of the `Gym_Class` model:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Unlike in other ORMs, Pony needs `generate_mapping()` to be executed to realize
    all the entity mappings to the actual tables. The method is an instance method
    of the `db` instance that must appear in the last part of the module script, as
    shown in the previous snippet, where `Gym_Class` was the last Pony model class
    to be defined. All the Pony model classes can be found in the `/models/data/pony_models.py`
    script file.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Note that we can create Pony entities manually or digitally using *Pony ORM
    ER Diagram Editor*, which we can access at [https://editor.ponyorm.com/](https://editor.ponyorm.com/).
    The editor can provide us with both free and commercial accounts. Let us now implement
    the CRUD transactions.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the CRUD transactions
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'CRUD transactions in Pony are session-driven. But unlike SQLAlchemy, its repository
    classes do not require injecting `db_session` into the repository constructor.
    Each transaction in Pony will not work without `db_session`. The following code
    shows a repository class that implements all the transactions needed to manage
    a list of gym members:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In Pony, inserting a record means instantiating the model class with the injected
    record values. An example is `insert_member()`, which inserts a profile by instantiating
    the `Profile_Members` model with the injected membership details. However, the
    case is different when updating records, as shown in the following script:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Updating a record in Pony, which is implemented in the `update_member()` script,
    means retrieving the record object through *indexing* using its `id`. The retrieved
    object is automatically converted into a JSON-able object since Pony has built-in
    support for JSON. Then, the new values of those attributes are overwritten as
    they must be changed. This *UPDATE* transaction is, again, within the bounds of
    `db_session`, thus automatically refreshing the record(s) after the overwrites.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, `delete_member()` of the repository class shows the same
    approach with *UPDATE*, except that a `delete()` class method is invoked right
    after retrieving the object record. The following is the script for this operation:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The delete transaction is also `db_session` bound, so invoking `delete()` automatically
    refreshes the table. The following code shows Pony’s implementation for query
    transactions:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '`get_member()` retrieves a single record using the `get()` class method, which
    requires a `lambda` expression in its parameter. Since `Login` has a one-to-one
    relationship with `Profile_Members`, first, we must extract the `Login` record
    of the member and use the `login` object to fetch the record through the `get()`
    helper function of the `Profile_Members` entity. This approach is also applicable
    to other entities with other entity relationships. Now, `get_all_member()` retrieves
    a result set using the `select()` method. The `select()` method can also utilize
    a lambda expression if there are constraints in the retrieval operation.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'Pony model classes have the `get()` and `select()` methods, which both return
    `Query` objects that FastAPI cannot process directly. So, we need an ORM-friendly
    `Pydantic` model to extract the final entities from these `Query` objects. Like
    in SQLAlchemy, a `ModelBase` class with a nested `Config` class is required to
    retrieve the records from the `Query` object. The nested class must configure
    `orm_mode` to `True`. If relationship mappings are involved, the request model
    must also declare the attributes involved in the relationship and their corresponding
    child object converters. The method converters, decorated by Pydantic’s `@validator`,
    are automatically called by Pony to interpret and validate the `Query` objects
    into JSON-able components such as `List` or entity objects. The following code
    shows the request model that’s used to extract the records from `select()` through
    list comprehension and the `Profile_Member dict` object from `get()`:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The presence of the `gclass_set_to_list ()` and `trainer_object_to_map()` converts
    in `ProfileMembersReq` enables data to be populated to the child objects in the
    `gclass` and `trainer_id` attributes, respectively. These additional features
    indicate why executing `select()` can already retrieve the *INNER JOIN* queries.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 'To build *LEFT JOIN* query transactions, the ORM has a built-in directive called
    `left_join()`, which is used to extract the `Query` object bearing the *LEFT JOIN*
    raw objects through a Python generator. The following code shows another repository
    class that showcases the use of `left_join()`:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: All the repository classes can be found in the `/repository/pony/members.py`
    script file.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Now, what makes Pony faster is that it uses an *identity map*, which contains
    all the record objects that have been retrieved from every single query transaction.
    The ORM applies the *Identity Map* design pattern to apply its caching mechanism
    to make read and write executions fast. It only requires memory management and
    monitoring to avoid memory leak problems in complex and huge applications.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Running the repository transactions
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since `db_session` is already managed internally, no additional requirements
    will be needed from Pony for the `APIRouter` script to run the repository transactions.
    The repository classes are directly accessed and instantiated in each of the APIs
    to access the CRUD transactions.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Creating the tables
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If the tables are non-existent yet, Pony can generate those tables through its
    entity classes. This DDL transaction is enabled when the `create_tables` parameter
    of the `generate_mapping()` method of `db` is set to `True`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: For the most compact and simplest ORM in terms of syntax, we have **Peewee**.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Building the repository using Peewee
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Among the different ORMs, Peewee is the simplest and smallest in terms of ORM
    features and APIs. The framework is easy to understand and use; it is not comprehensive,
    but it has intuitive ORM syntax. Its strength is in building and executing query
    transactions.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: 'Peewee is not designed for asynchronous platforms, but it can work with them
    by using some async-related libraries that it supports. We need to install at
    least *Python 3.7* for Peewee to work with FastAPI, an asynchronous framework.
    To install Peewee, we need to execute the following command:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Installing the database driver
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The ORM needs `psycopg2` as the PostgreSQL database driver. We can install
    it using `pip`:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Creating the database connection
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For Peewee to work with FastAPI, we must build a multi-threading mechanism
    where Peewee can cater to more than one request transaction on the same thread,
    and per request can do more executions simultaneously using different local threads.
    This customized multi-threading component, which can be created using the `ContextVar`
    class, bridges Peewee to the FastAPI platform. But for Peewee to utilize these
    threads, we also need to customize its `_ConnectionState` with the newly created
    threading state, `db_state`. The following code shows how `db_state` and a custom
    `_ConnectionState` can be derived:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'To apply the new `db_state` and `_ConnectionState` classes, cited in the preceding
    code as `PeeweeConnectionState`, we need to open the database connection through
    the `Database` class. Peewee has several variations of the `Database` class, depending
    on the type of database the application will choose to connect to. Since we will
    be using PostgreSQL, `PostgresqlDatabase` is the correct class to initialize with
    all the necessary database details. After establishing the connection, the `db`
    instance will have a `_state` attribute that will point to the `PeeweeConnectionState`
    instance. The following snippet shows how to connect to our *fitness gym* database’s
    `fcms` using the database credentials:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The preceding code also emphasizes that the default state of the database connection
    must be replaced with a non-blocking one that can work with the FastAPI platform.
    This configuration can be found in the `/db_config/peewee_connect.py` script file.
    Let us now build Peewee's model layer.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Creating the tables and the domain layer
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Peewee prefers *auto-generating tables* based on its model classes, unlike
    other ORMs. Peewee recommends *reverse engineering*, where tables are created
    rather than only being mapped to existing tables. Letting the application generate
    the tables lessens the hassle of establishing relationships and primary keys.
    This ORM is unique because it has an "implied" approach to creating primary keys
    and foreign keys. The following script shows how Peewee model classes are defined:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: We can’t see any primary keys in the model classes presented because the Peewee
    engine will create them during its schema auto-generation. The physical foreign
    key column and the model attribute will have the same name derived from its model
    name, with the `modelname_id` pattern in lowercase form. If we insist on adding
    the primary key for the model, a conflict will occur, making Peewee dysfunctional.
    We must let Peewee create the physical tables from the model classes to avoid
    this mishap.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: All model classes inherit properties from the `Model` directive of the ORM.
    It also has column directives such as `IntegerField`, `FloatField`, `DateField`,
    and `TimeField` for defining the column attributes of the model classes. Moreover,
    each domain class has a nested `Meta` class, which registers the references to
    `database` and `db_table`, which is mapped to the model class. Other properties
    that we can set here are `primary_key`, `indexes`, and `constraints`.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: 'The only problem in having this auto-generation is when creating table relationships.
    Linking the foreign key attributes of the child classes to the non-existent primary
    keys of the parent classes is difficult before auto-generation. For instance,
    the following `Profile_Trainers` model implies a *many-to-one* relationship with
    the `Login` class, which is only defined by the `ForeignKeyField` directive with
    the `trainer` backreference attribute and not by the `login_id` foreign key:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The `login_id` column that’s generated after auto-generation can be seen in
    the following screenshot:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – The generated profile_trainers schema'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.2_B17975.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.2 – The generated profile_trainers schema
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: 'Foreign key attributes are declared using the `ForeignKeyField` directive,
    which accepts at least three crucial parameters:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: The parent model’s name
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `backref` parameter, which references the child record (if in a *one-to-one*
    relationship) or a set of child objects (if in a *one-to-many* or *many-to-one*
    relationship)
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `unique` parameter, which indicates a *one-to-one* relationship when set
    to `True` or `False` otherwise
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After defining all the models, including their relationships, we need to call
    the following methods from Peewee’s `db` instance for the table mapping to occur:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '`connect()` to establish the connection'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`create_tables()` to pursue the schema generation based on its list of model
    classes'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following script shows a snapshot of the class definitions, including the
    call to the two `db` methods:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: As we can see, we need to set the `safe` parameter of `create_tables()` to `True`
    so that Peewee will only perform schema auto-generation once during the initial
    server startup of the application. All the model classes for the Peewee ORM can
    be found in the `/models/data/peewee_models.py` script file. Now, let us implement
    the repository layer.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the CRUD transactions
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Creating the asynchronous connection and building the model layer for the application
    in the Peewee ORM is tricky, but implementing its repository layer is straightforward.
    All the method operations are entirely derived from its model classes. For instance,
    `insert_login()`, which is shown in the following snippet, shows how the `create()`
    static method of `Login` takes the login details for record insertion:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This method can be re-implemented to perform bulk inserts, but Peewee has an
    alternative way to pursue multiple insertions through its `insert_many()` class
    method. Using `insert_many()` requires more accurate column details for mapping
    multiple schema values. It also needs an invocation of the `execute()` method
    to perform all the bulk insertions and close the operation afterward.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, the `update()` class method requires the `execute()` method after
    filtering the record that needs updating using the `id` primary key. This is shown
    in the following code snippet:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'When it comes to record deletion, `delete_login()` shows the easy approach
    – that is, by using `delete_by_id()`. But the ORM has another way, which is to
    retrieve the record object using the `get()` class method – for example, `Login.get(Login.id
    == id)` – and eventually delete the record through the `delete_instance()` instance
    method of the record object. The following `delete_login()` transaction shows
    how to utilize the `delete_by_id()` class method:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The following scripts, which are for `get_all_login()` and `get_login()`, highlight
    how Peewee retrieves records from the database. Peewee uses its `get()` class
    method to retrieve a single record using the primary key; the same method was
    applied to its *UPDATE* transaction in the previous code snippet. Similarly, Peewee
    uses a class method to extract multiple records, but this time, it uses the `select()`
    method. The resulting object can’t be encoded by FastAPI unless it’s contained
    in the `List` collection, which serializes the rows of data into a list of JSON-able
    objects:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'On the other hand, the following repository classes show how to create *JOIN*
    queries using its `join()` method:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '`join_login_trainers()` of `LoginTrainersRepository` builds the *INNER JOIN*
    query of the `Profile_Trainers` and `Login` objects. The leftmost model indicated
    in the parameter of the `Profile_Trainers` object’s `select()` directive is the
    parent model type, followed by its child model class in a *one-to-one* relationship.
    The `select()` directive emits the `join()` method with the model class type,
    which indicates the type of records that belong to the right-hand side of the
    query. The *ON* condition(s) and the foreign key constraints are optional but
    can be declared explicitly by adding the `on` and `join_type` attributes of the
    `join()` construct. An example of this query is `outer_join_member_gym()` of `MemberGymClassesRepository`,
    which implements a *LEFT OUTER JOIN* of `Profile_Members` and `Gym_Class` using
    the `LEFT_OUTER` option of the `join_type` attribute of `join()`.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: Joins in Peewee also need the `list()` collection to serialize the retrieved
    records. All the repository classes for Peewee can be found in the `/repository/peewee/login.py`
    script.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: Running the CRUD transaction
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since Peewee’s database connection is set at the model layer, no additional
    requirements are required for `APIRouter` or `FastAPI` to run the CRUD transactions.
    API services can easily access all the repository classes without calling methods
    or directives from the `db` instance.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have experimented with popular ORMs to integrate a relational database
    into the FastAPI framework. If applying an ORM is not enough for a microservice
    architecture, we can utilize some design patterns that can further refine the
    CRUD performance, such as **CQRS**.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: Applying the CQRS design pattern
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CQRS is a microservice design pattern responsible for segregating query transactions
    (*reads*) from the insert, update, and delete operations (*writes*). The separation
    of these two groups lessens the cohesion access to these transactions, which provides
    less traffic and faster performance, especially when the application becomes complex.
    Moreover, this design pattern creates a loose-coupling feature between the API
    services and the repository layer, which gives us an advantage if there are several
    turnovers and changes in the repository layers.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: Defining the handler interfaces
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To pursue CQRS, we need to create the two interfaces that define the query
    and the command transactions. The following code shows the interfaces that will
    identify the *read* and *write* transactions for `Profile_Trainers`:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Here, `IQueryHandler` and `ICommandHandler` are informal interfaces because
    Python does not have an actual definition of an interface.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: Creating the command and query classes
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, we need to implement the command and query classes. The command serves
    as an instruction to pursue the *write* transactions. It also carries the state
    of the result after they have been executed. On the other hand, the query instructs
    the *read* transaction to retrieve record(s) from the database and contain the
    result afterward. Both components are serializable classes with *getter/setter*
    attributes. The following code shows the script for `ProfileTrainerCommand`, which
    uses Python’s `@property` attribute to store the state of the *INSERT* execution:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The `details` property will store all the column values of the trainer’s profile
    record that need to be persisted.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: 'The following script implements a sample *query* class:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The constructor of `ProfileTrainerListQuery` prepares a dictionary object that
    will contain all the retrieved records after the query transaction has been executed.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: Creating the command and query handlers
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will be using our previous interfaces to define the command and query handlers.
    Note that the command handler accesses and executes the repository to execute
    the *write* transactions, while the query handler processes the *read* transactions.
    These handlers serve as the façade between the API services and the repository
    layer. The following code shows the script for `AddTrainerCommandHandler`, which
    manages the *INSERT* transaction for the trainer’s profile:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The handler depends on `ProfileTrainerCommand` for the record values that are
    crucial to the asynchronous execution of its `handle()` method.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: 'The following script shows a sample implementation for a query handler:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Query handlers return their *query* to the services and not the actual values.
    The `handle()` method of `ListTrainerQueryHandler` returns `ProfileTrainerListQuery`,
    which contains the list of records from the *read* transaction. This mechanism
    is one of the main objectives of applying CQRS to microservices.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the handlers
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CQRS, aside from managing the friction between the *read* and *write* executions,
    does not allow the API services to interact directly with the execution of CRUD
    transactions. Moreover, it streamlines and simplifies the access of the CRUD transactions
    by assigning only the handler that’s needed by a particular service.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: 'The following script shows how `AddTrainerCommand` is only directly associated
    with the `add_trainer()` service and how `LisTrainerQueryHandler` is only directly
    associated with the `list_trainers()` service:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: We can identify transactions that are accessed frequently in `APIRouter` through
    CQRS. It helps us find which transactions need performance tuning and focus, which
    can help us avoid performance issues when the amount of access increases. When
    it comes to enhancement and upgrades, the design pattern can help developers find
    what domain to prioritize because of the separation of aspects in the repository
    layer. Generally, it offers flexibility to the application when its business processes
    need to be revamped. All the CQRS-related scripts can be found in the `/cqrs/`
    project folder.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Applying ORM always has advantages and disadvantages for any application. It
    can bloat the application with so many configurations and layers of components,
    and it can even slow down the application if not managed well. But ORM, in general,
    can help optimize query development by simplifying the constructs by using its
    APIs and eliminating unimportant repetitive SQL scripts. Overall, it can reduce
    the time and cost of software development compared to using `cursor` from `psycopg2`.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, four Python ORMs were used, studied, and experimented with
    to help FastAPI create its repository layer. First, there is *SQLAlchemy*, which
    provides a boilerplated approach to creating standard and asynchronous data persistency
    and query operations. Then, there is *GINO*, which uses the AsyncIO environment
    to implement asynchronous CRUD transactions with its handy syntax. Also, there
    is *Pony*, the most Pythonic among the ORMs presented because it uses hardcore
    Python code to build its repository transactions. Lastly, there is *Peewee*, known
    for its concise syntax but tricky composition for the asynchronous database connection
    and CRUD transactions. Each ORM has its strengths and weaknesses, but all provide
    a logical solution rather than applying brute-force and native SQL.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: If the ORM needs fine-tuning, we can add some degree of optimization by using
    data-related design patterns such as CQRS, which minimizes friction between the
    "read" and "write" CRUD transactions.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: This chapter has highlighted the flexibility of FastAPI when utilizing ORMs
    to establish a connection to a relational database such as PostgreSQL. But what
    if we use a NoSQL database such as MongoDB to store information? Will FastAPI
    perform with the same level of performance when performing CRUD to and from MongoDB?
    The next chapter will discuss various solutions for integrating FastAPI into MongoDB.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
