- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Connecting to a Relational Database
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接到关系数据库
- en: Our previous applications have only used Python collections to hold data records
    instead of persistent data stores. This setup causes data wiping whenever the
    **Uvicorn** server restarts because these collections only store the data in *volatile
    memory*, such as **RAM**. From this chapter onward, we will be applying data persistency
    to avoid data loss and provide a platform to manage our records, even when the
    server is in shutdown mode.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前的应用程序仅使用 Python 集合来存储数据记录，而不是持久数据存储。这种设置会在 **Uvicorn** 服务器重启时导致数据丢失，因为这些集合仅在
    *易失性内存*，如 **RAM** 中存储数据。从本章开始，我们将应用数据持久性以避免数据丢失，并提供一个平台来管理我们的记录，即使在服务器关闭模式下也是如此。
- en: This chapter will focus on different **Object Relational Mappers** (**ORMs**)
    that can efficiently manage clients’ data using objects and a relational database.
    Object-relational mapping is a technique where SQL statements for **Creating***,*
    **Reading***,* **Updating** *and* **Deleting** (**CRUD**) are implemented and
    executed in an object-oriented programming approach. ORM requires all relationships
    or tables to be mapped to their corresponding entity or model classes to avoid
    tightly coupled connections to the database platform. And these model classes
    are the ones that are used to connect to the database.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将重点介绍不同的 **对象关系映射器**（**ORMs**），这些 ORM 可以有效地使用对象和关系数据库来管理客户端数据。对象关系映射是一种技术，其中
    SQL 语句用于 **创建**、**读取**、**更新** 和 **删除**（**CRUD**）在面向对象的编程方法中实现和执行。ORM 需要将所有关系或表映射到相应的实体或模型类，以避免与数据库平台的紧密耦合连接。这些模型类是用于连接到数据库的类。
- en: Aside from introducing ORM, this chapter will also discuss a design pattern
    called **Command and Query Responsibility Segregation** (**CQRS**), which can
    help resolve conflicts between read and write ORM transactions at the domain level.
    CQRS can help minimize the running time spent by read and write SQL transactions
    to improve the overall performance of the application over time compared to the
    data modeling approach.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 除了介绍 ORM，本章还将讨论一个名为 **命令和查询责任分离**（**CQRS**）的设计模式，该模式可以帮助在域级别解决读写 ORM 事务之间的冲突。CQRS
    可以帮助最小化读写 SQL 事务的运行时间，与数据建模方法相比，随着时间的推移可以提高应用程序的整体性能。
- en: Overall, the main objective of this chapter is to prove that the FastAPI framework
    supports all popular ORMs to provide applications with backend database access,
    which it does by using popular relational database management systems, and apply
    optimization to CRUD transactions using the CQRS design pattern.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，本章的主要目标是证明 FastAPI 框架支持所有流行的 ORM，为应用程序提供后端数据库访问，它通过使用流行的关系数据库管理系统来实现，并通过使用
    CQRS 设计模式对 CRUD 事务进行优化。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Preparing for database connectivity
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备数据库连接
- en: Creating synchronous CRUD transactions using *SQLAlchemy*
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 *SQLAlchemy* 创建同步 CRUD 事务
- en: Implementing asynchronous CRUD transactions using *SQLAlchemy*
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 *SQLAlchemy* 实现异步 CRUD 事务
- en: Using *GINO* for asynchronous CRUD transactions
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 *GINO* 进行异步 CRUD 事务
- en: Using Pony ORM for the repository layer
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Pony ORM 进行存储库层
- en: Building the repository using Peewee
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Peewee 构建存储库
- en: Applying the CQRS design pattern
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用 CQRS 设计模式
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The application prototype that’s been created for this chapter is called *fitness
    club management system*; it caters to membership and gym fitness operations. This
    prototype has administration, membership, class management, and attendance modules
    that utilize a `ch05a` and `ch05b` projects.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为本章创建的应用程序原型被称为 *健身俱乐部管理系统*；它服务于会员和健身房健身运营。此原型具有管理、会员、课程管理和出勤模块，这些模块利用 `ch05a`
    和 `ch05b` 项目。
- en: Preparing for database connectivity
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备数据库连接
- en: 'Let us consider some application-related concerns before we start discussing
    database connectivity in FastAPI:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始讨论 FastAPI 中的数据库连接之前，让我们考虑一些与应用程序相关的问题：
- en: First, all the application prototypes from this chapter onward will be using
    PostgreSQL as the sole relational DBMS. We can download its installer from [https://www.enterprisedb.com/downloads/postgres-postgresql-downloads](https://www.enterprisedb.com/downloads/postgres-postgresql-downloads).
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，从本章开始，所有应用程序原型都将使用 PostgreSQL 作为唯一的关联数据库管理系统。我们可以从 [https://www.enterprisedb.com/downloads/postgres-postgresql-downloads](https://www.enterprisedb.com/downloads/postgres-postgresql-downloads)
    下载其安装程序。
- en: 'Second, the *fitness club management system* prototype has an existing database
    called `fcms` with six tables, namely `signup`, `login`, `profile_members`, `profile_trainers`,
    `attendance_member`, and `gym_class`. All these tables, along with their metadata
    and relationships, can be seen in the following diagram:'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，*健身俱乐部管理系统* 原型有一个名为 `fcms` 的现有数据库，包含六个表，分别是 `signup`、`login`、`profile_members`、`profile_trainers`、`attendance_member`
    和 `gym_class`。所有这些表及其元数据和关系都可以在以下图中看到：
- en: '![Figure 5.1 – The fcms tables'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.1 – fcms 表格'
- en: '](img/Figure_5.1_B17975.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.1_B17975.jpg)'
- en: Figure 5.1 – The fcms tables
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – fcms 表格
- en: The project folder contains a script called `fcms_postgres.sql` that installs
    all these schemas.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 项目文件夹中包含一个名为 `fcms_postgres.sql` 的脚本，用于安装所有这些模式。
- en: Now that we’ve installed the latest version of PostgreSQL and run the `fcms`
    script file, let us learn about SQLAlchemy, the most widely used ORM library in
    the Python arena.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了最新版本的 PostgreSQL 并运行了 `fcms` 脚本文件，让我们来了解 SQLAlchemy，这是 Python 场景中最广泛使用的
    ORM 库。
- en: Important note
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: This chapter will compare and contrast the features of different Python ORMs.
    With this experimental setup, each project will have a multitude of database connectivity,
    which is against the convention of having a single piece of database connectivity
    per project.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将比较和对比不同 Python ORM 的功能。在这个实验设置中，每个项目都将拥有多种数据库连接，这与每个项目只有一个数据库连接的惯例相悖。
- en: Creating CRUD transactions using SQLAlchemy
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 SQLAlchemy 创建 CRUD 事务
- en: '**SQLAlchemy** is the most popular ORM library and can establish communication
    between any Python-based application and database platform. It is reliable because
    it is continuously updated and tested to be efficient, high-performing, and accurate
    with its SQL reads and writes.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**SQLAlchemy** 是最受欢迎的 ORM 库，能够建立任何基于 Python 的应用程序和数据库平台之间的通信。它之所以可靠，是因为它持续更新和测试，以确保其
    SQL 读写操作高效、高性能和准确。'
- en: This ORM is a boilerplated interface that aims to create a database-agnostic
    data layer that can connect to any database engine. But compared to other ORMs,
    SQLAlchemy is DBA-friendly because it can generate optimized native SQL statements.
    When it comes to formulating its queries, it only requires Python functions and
    expressions to pursue the CRUD operations.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 ORM 是一个模板化接口，旨在创建一个数据库无关的数据层，可以连接到任何数据库引擎。但与其他 ORM 相比，SQLAlchemy 更受数据库管理员（DBA）的欢迎，因为它可以生成优化的原生
    SQL 语句。在制定其查询时，它只需要 Python 函数和表达式来执行 CRUD 操作。
- en: 'Before we start using SQLAlchemy, check whether you have the module installed
    in your system by using the following command:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始使用 SQLAlchemy 之前，请使用以下命令检查您系统中是否已安装该模块：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If SQLAlchemy is not in the list, install it using the `pip` command:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 SQLAlchemy 不在列表中，请使用 `pip` 命令进行安装：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Currently, the version being used while developing the *fitness club management
    system* app is *1.4*.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，开发 *健身俱乐部管理系统* 应用程序所使用的版本是 *1.4*。
- en: Installing the database driver
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装数据库驱动程序
- en: 'SQLAlchemy will not work without the required database driver. It is mandatory
    to install the `psycopg2` dialect since the database of choice is PostgreSQL:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 没有所需的数据库驱动程序将无法工作。由于选择的是 PostgreSQL 数据库，因此必须安装 `psycopg2` 方言：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Psycopg2 is a *DB API 2.0-c*ompliant PostgreSQL driver that does connection
    pooling and can work with multi-threaded FastAPI applications. This wrapper or
    dialect is also essential in building synchronous CRUD transactions for our application.
    Once it’s been installed, we can start looking at SQLAlchemy’s database configuration
    details. All the code related to SQLAlchemy can be found in the `ch05a` project.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Psycopg2 是一个符合 *DB API 2.0-c*ompliant 的 PostgreSQL 驱动程序，可以进行连接池管理，并且可以与多线程 FastAPI
    应用程序一起工作。这个包装器或方言对于构建我们的应用程序的同步 CRUD 事务也是必不可少的。一旦安装，我们就可以开始查看 SQLAlchemy 的数据库配置细节。所有与
    SQLAlchemy 相关的代码都可以在 `ch05a` 项目中找到。
- en: Setting up the database connection
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置数据库连接
- en: 'To connect to any database, SQLAlchemy requires an engine that manages the
    connection pooling and the installed dialect. The `create_engine()` function from
    the `sqlalchemy` module is the source of the engine object. But to successfully
    derive it, `create_engine()` requires a database URL string to be configured.
    This URL string contains the *database name*, *the database API driver*, the *account
    credentials*, the *IP address* of the database server, and its *port*. The following
    script shows how to create the engine that will be used in our *fitness club management
    system* prototype:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了连接到任何数据库，SQLAlchemy需要一个管理连接池和已安装方言的引擎。`create_engine()`函数来自`sqlalchemy`模块，是引擎对象的来源。但为了成功派生它，`create_engine()`需要一个配置好的数据库URL字符串。这个URL字符串包含*数据库名称*、*数据库API驱动程序*、*账户凭证*、数据库服务器的*IP地址*和其*端口*。以下脚本展示了如何创建将在我们的*健身俱乐部管理系统*原型中使用的引擎：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`engine` is a global object and must be created only once in the entire application.
    Its first database connection happens right after the first SQL transaction of
    the application because it follows the *lazy initialization* design pattern.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`engine`是一个全局对象，必须在整个应用程序中只创建一次。它的第一个数据库连接发生在应用程序的第一个SQL事务之后，因为它遵循了*延迟初始化*设计模式。'
- en: Moreover, `engine` in the previous script is essential for creating the ORM
    session that will be used by SQLAlchemy to execute CRUD transactions.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，前一个脚本中的`engine`对于创建将被SQLAlchemy用于执行CRUD事务的ORM会话至关重要。
- en: Initializing the session factory
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化会话工厂
- en: All CRUD transactions in SQLAlchemy are driven by *sessions*. Each session manages
    a group of database "writes" and "reads," and it checks whether to execute them
    or not. For instance, it maintains a group of inserted, updated, and deleted objects,
    checks whether the changes are valid, and then coordinates with the SQLAlchemy
    core to pursue the changes to the database if all transactions have been validated.
    It follows the behavior of the *Unit of Work* design pattern. SQLAlchemy relies
    on sessions for data consistency and integrity.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy中的所有CRUD事务都是由*会话*驱动的。每个会话管理一组数据库“写入”和“读取”，并检查是否执行它们。例如，它维护一组已插入、更新和删除的对象，检查更改是否有效，然后与SQLAlchemy核心协调，如果所有事务都已验证，则将更改推进到数据库。它遵循*工作单元*设计模式的行为。SQLAlchemy依赖于会话来保证数据的一致性和完整性。
- en: 'But before we create a session, the data layer needs a session factory that
    is bound to the derived engine. The ORM has a `sessionmaker()`directive from the
    `sqlalchemy.orm` module, which requires the `engine` object. The following script
    shows how to invoke `sessionmaker()`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们创建会话之前，数据层需要一个绑定到派生引擎的会话工厂。ORM从`sqlalchemy.orm`模块中有一个`sessionmaker()`指令，它需要一个`engine`对象。以下脚本展示了如何调用`sessionmaker()`：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Apart from engine binding, we also need to set the session’s `autocommit` property
    to `False` to impose `commit()` and `rollback()` transactions. The application
    should be the one to flush all changes to the database, so we need to set its
    `autoflush` feature to `False` as well.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 除了引擎绑定之外，我们还需要将会话的`autocommit`属性设置为`False`以强制执行`commit()`和`rollback()`事务。应用程序应该是将所有更改刷新到数据库的那个，因此我们还需要将其`autoflush`功能设置为`False`。
- en: Applications can create more than one session through the `SessionFactory()`
    call, but having one session per `APIRouter` is recommended.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序可以通过`SessionFactory()`调用创建多个会话，但每个`APIRouter`拥有一个会话是推荐的。
- en: Defining the Base class
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义Base类
- en: 'Next, we need to set up the `Base` class, which is crucial in mapping model
    classes to database tables. Although SQLAlchemy can create tables at runtime,
    we opted to utilize an existing schema definition for our prototype. Now, this
    `Base` class must be subclassed by the model classes so that the mapping to the
    tables will happen once the server starts. The following script shows how straightforward
    it is to set up this component:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要设置`Base`类，这在将模型类映射到数据库表中至关重要。尽管SQLAlchemy可以在运行时创建表，但我们选择利用现有的模式定义来构建我们的原型。现在，这个`Base`类必须由模型类继承，以便在服务器启动时发生到表的映射。以下脚本展示了设置此组件是多么简单：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Invoking the `declarative_base()` function is the easiest way of creating the
    `Base` class rather than creating `registry()` to call `generate_base()`, which
    can also provide us with the `Base` class.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`declarative_base()`函数是创建`Base`类而不是创建`registry()`来调用`generate_base()`的最简单方法，这也可以为我们提供`Base`类。
- en: Note that all these configurations are part of the `/db_config/sqlalchemy_connect.py`
    module of the prototype. They are bundled into one module since they are crucial
    in building the SQLAlchemy repository. But before we implement the CRUD transactions,
    we need to create the model layer using the `Base` class.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，所有这些配置都是原型 `/db_config/sqlalchemy_connect.py` 模块的一部分。由于它们在构建 SQLAlchemy 存储库中至关重要，因此它们被捆绑在一个模块中。但在我们实现
    CRUD 事务之前，我们需要使用 `Base` 类创建模型层。
- en: Building the model layer
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建模型层
- en: 'The model classes of SQLAlchemy have all been placed in the `/models/data/sqlalchemy_models.py`
    file of the fitness club project folder. If `BaseModel` is important to API request
    models, the `Base` class is essential in building the data layer. It is imported
    from the configuration file to define SQLAlchemy entities or models. The following
    code is from the module script, which shows how we can create model class definitions
    in SQLAlchemy ORM:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 的模型类已放置在健身俱乐部项目文件夹的 `/models/data/sqlalchemy_models.py` 文件中。如果 `BaseModel`
    对 API 请求模型很重要，那么 `Base` 类在构建数据层时是必不可少的。它从配置文件导入以定义 SQLAlchemy 实体或模型。以下代码来自模块脚本，展示了我们如何在
    SQLAlchemy ORM 中创建模型类定义：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `Signup` class is a sample of a SQLAlchemy model because it inherits the
    `Base` class’s properties. It is a mapped class because all its attributes are
    reflections of the column metadata of its physical table schema counterpart. The
    model has a `primary_key` property set to `True` because SQLAlchemy recommends
    each table schema have at least one primary key. The rest of the `Column` objects
    are mapped to column metadata that’s non-primary but can be *unique* or *indexed*.
    Each model class inherits the `__tablename__` property, which sets the name of
    the mapped table.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`Signup` 类是 SQLAlchemy 模型的示例，因为它继承了 `Base` 类的属性。它是一个映射类，因为所有其属性都是其物理表模式对应项的列元数据的反映。该模型将
    `primary_key` 属性设置为 `True`，因为 SQLAlchemy 建议每个表模式至少有一个主键。其余的 `Column` 对象映射到非主键但可以是
    *唯一* 或 *索引* 的列元数据。每个模型类继承 `__tablename__` 属性，该属性设置映射表的名称。'
- en: Most importantly, we need to ensure that the data type of the class attribute
    matches the column type of its column counterpart in the table schema. The column
    attribute must have the same name as the column counterpart. Otherwise, we need
    to specify the actual column name in the first argument of the `Column` class,
    as shown in the `username` and `password` columns of `Signup`. But most of the
    time, we must always make sure they are the same to avoid confusion.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，我们需要确保类属性的数据类型与其在表模式中列对应的列类型相匹配。列属性必须与列对应项具有相同的名称。否则，我们需要在 `Column` 类的第一个参数中指定实际的列名，如
    `Signup` 中的 `username` 和 `password` 列所示。但大多数情况下，我们必须始终确保它们相同，以避免混淆。
- en: Mapping table relationships
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 映射表关系
- en: SQLAlchemy strongly supports different types of parent-child or associative
    table relationships. Model classes involved in the relationship require the `relationship()`
    directive from the `sqlalchemy.orm` module to be utilized to establish one-to-many
    or one-to-one relationships among model classes. This directive creates a reference
    from the parent to the child class using some foreign key indicated in the table
    schema definition.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 强烈支持不同类型的父子或关联表关系。参与关系的模型类需要使用 `sqlalchemy.orm` 模块中的 `relationship()`
    指令来利用模型类之间的一对多或一对一关系。此指令通过表模式定义中指示的外键从父类创建对子类的引用。
- en: 'A child model class uses the `ForeignKey` construct in its foreign key column
    object to link the model class to its parent’s reference key column object. This
    directive indicates that the values in this column should be within the values
    stored in the parent table’s reference column. The `ForeignKey` directive applies
    to both the primary and non-primary `Column` objects. The following model class
    defines a sample column relationship in our database schema:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一个子模型类使用其外键列对象中的 `ForeignKey` 构造来将其模型类与其父类的参考键列对象链接。此指令表示该列中的值应包含在父表参考列中存储的值内。`ForeignKey`
    指令适用于主键和非主键的 `Column` 对象。以下模型类定义了我们数据库模式中的一个示例列关系：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This `Login` model is linked to two children, `Profile_Trainers` and `Profile_Members`,
    based on its configuration. Both child models have the `ForeignKey` directive
    in their `id` column objects, as shown in the following model definitions:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 此 `Login` 模型根据其配置与两个子类 `Profile_Trainers` 和 `Profile_Members` 链接。这两个子模型在其 `id`
    列对象中都有 `ForeignKey` 指令，如下面的模型定义所示：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `relationship()` directive is the sole directive for creating table relationships.
    We need to specify some of its parameters, such as the *name of the child model
    class* and the *backreference specification*. The `back_populates` parameter refers
    to the complementary attribute names of the related model classes. This indicates
    the rows that need to be fetched using some relationship loading technique during
    join query transactions. The `backref` parameter can also be used instead of `back_populates`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`relationship()` 指令是创建表关系的唯一指令。我们需要指定一些其参数，例如 *子模型类的名称* 和 *反向引用指定*。`back_populates`
    参数指的是相关模型类的互补属性名称。这表示在连接查询事务期间需要使用某些关系加载技术获取的行。`backref` 参数也可以用来代替 `back_populates`。'
- en: 'On the other hand, `relationship()` can return either a `List` or scalar object,
    depending on the relationship type. If it is a *one-to-one type*, the parent class
    should set the `useList` parameter to `False` to indicate that it will return
    a scalar value. Otherwise, it will select a list of records from the child table.
    The previous `Login` class definition shows that `Profile_Trainers` and `Profile_Members`
    hold a one-to-one relationship with `Login` because `Login` sets its `uselist`
    to `False`. On the other hand, the model relationship between `Profile_Members`
    and `Attendance_Member` is a *one-to-many* type because `uselist` is set to `True`
    by default, as shown by the following definitions:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`relationship()` 方法可以返回一个 `List` 或标量对象，具体取决于关系类型。如果是一个 *一对一* 类型，父类应该将 `useList`
    参数设置为 `False` 以指示它将返回一个标量值。否则，它将从子表中选取记录列表。之前的 `Login` 类定义显示 `Profile_Trainers`
    和 `Profile_Members` 与 `Login` 之间保持一对一关系，因为 `Login` 将其 `uselist` 设置为 `False`。另一方面，`Profile_Members`
    和 `Attendance_Member` 之间的模型关系是一个 *一对多* 类型，因为默认情况下 `uselist` 被设置为 `True`，如下面的定义所示：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: While setting the model relationships, we must also consider the *relationship
    loading type* that these related model classes will be using during the join query
    transactions. We specify this detail in the `lazy` parameter of `relationship()`,
    which is assigned to `select` by default. This is because SQLAlchemy uses a lazy
    loading technique by default in retrieving join queries. However, you can modify
    it to use `joined` (`lazy="joined"`), `subquery` (`lazy="subquery"`), `select
    in` (`lazy="selectin"`), `raise` (`lazy="raise"`), or `no` (`lazy="no"`) loading.
    Among the options, the `joined` approach is better for *INNER JOIN* transactions.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置模型关系时，我们还必须考虑这些相关模型类在连接查询事务期间将使用的 *关系加载类型*。我们在 `relationship()` 的 `lazy`
    参数中指定此细节，默认情况下分配给 `select`。这是因为 SQLAlchemy 默认使用懒加载技术在检索连接查询。然而，您可以将其修改为使用 `joined`
    (`lazy="joined"`), `subquery` (`lazy="subquery"`), `select in` (`lazy="selectin"`),
    `raise` (`lazy="raise"`), 或 `no` (`lazy="no"`) 加载。在这些选项中，`joined` 方法更适合 *INNER
    JOIN* 事务。
- en: Implementing the repository layer
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现仓库层
- en: In the SQLAlchemy ORM, creating the repository layer requires the *model classes*
    and a `Session` object. The `Session` object, derived from the `SessionFactory()`directive,
    establishes all the communication to the database and manages all the model objects
    before the `commit()` or `rollback()` transaction. When it comes to the queries,
    the `Session` entity stores the result set of records in a data structure called
    an *identity map*, which maintains the unique identity of each data record using
    the primary keys.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SQLAlchemy ORM 中，创建仓库层需要 *模型类* 和一个 `Session` 对象。`Session` 对象由 `SessionFactory()`
    指令派生，它建立了与数据库的所有通信，并在 `commit()` 或 `rollback()` 事务之前管理所有模型对象。当涉及到查询时，`Session`
    实体将记录的结果集存储在一个称为 *身份映射* 的数据结构中，该映射使用主键维护每个数据记录的唯一标识。
- en: All repository transactions are *stateless*, which means the session is automatically
    closed after loading the model objects for insert, update, and delete transactions
    when the database issues a `commit()` or `rollback()` operation. We import the
    `Session` class from the `sqlalchemy.orm` module.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 所有仓库事务都是 *无状态的*，这意味着在数据库执行 `commit()` 或 `rollback()` 操作后，会自动关闭加载模型对象用于插入、更新和删除事务的会话。我们从
    `sqlalchemy.orm` 模块导入 `Session` 类。
- en: Building the CRUD transactions
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建CRUD事务
- en: 'Now, we can start building the repository layer of the fitness club application
    since we have already satisfied the requirements to build the CRUD transactions.
    The following `SignupRepository` class is the blueprint that will show us how
    to *insert*, *update*, *delete*, and *retrieve* record(s) to/from the `signup`
    table:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始构建健身俱乐部应用的仓库层了，因为我们已经满足了构建 CRUD 事务的要求。下面的 `SignupRepository` 类是蓝图，它将展示我们如何
    *插入*、*更新*、*删除* 和 *检索* 记录到/从 `signup` 表：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'So far, `insert_signup()` is the most accurate way of persisting records to
    the `signup` table using SQLAlchemy. `Session` has an `add()` method, which we
    can invoke to add all record objects to the table, and a `commit()` transaction
    to finally flush all the new records into the database. The `flush()` method of
    `Session` is sometimes used instead of `commit()` to pursue the insertion and
    close `Session`, but most developers often use the latter. Note that the `signup`
    table contains all the gym members and trainers who want to gain access to the
    system. Now, the next script implements update record transaction:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，`insert_signup()` 是使用 SQLAlchemy 将记录持久化到 `signup` 表的最准确的方法。`Session` 有一个
    `add()` 方法，我们可以调用它来将所有记录对象添加到表中，以及一个 `commit()` 事务来最终将所有新记录刷新到数据库中。`Session` 的
    `flush()` 方法有时会代替 `commit()` 来执行插入并关闭 `Session`，但大多数开发者通常使用后者。请注意，`signup` 表包含所有想要获取系统访问权限的健身房会员和教练。现在，下一个脚本实现了更新记录事务：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `update_signup()` provides a short, straightforward, and robust solution
    to updating a record in SQLAlchemy. Another possible solution is to query the
    record through `self.sess.query(Signup).filter(Signup.id == id).first()`, replace
    the attribute values of the retrieved object with the new values from the `details`
    dictionary, and then invoke `commit()`. This way is acceptable, but it takes three
    steps rather than calling the `update()` method after `filter()`, which only takes
    one. Next script is an implementation of a delete record transaction:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`update_signup()` 提供了一个简短、直接且健壮的解决方案来更新 SQLAlchemy 中的记录。另一种可能的解决方案是通过 `self.sess.query(Signup).filter(Signup.id
    == id).first()` 查询记录，用 `details` 字典中的新值替换检索到的对象的属性值，然后调用 `commit()`。这种方式是可以接受的，但它需要三个步骤，而不是在
    `filter()` 之后调用 `update()` 方法，后者只需要一步。下一个脚本是一个删除记录事务的实现：'
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'On the other hand, `delete_signup()` follows the strategy of `update_signup()`,
    which uses `filter()` first before `delete()` is called. Another way of implementing
    this is to retrieve the object using `sess.query()` again and pass the retrieved
    object as an argument to the `Session` object’s `delete(obj)`, which is a different
    function. Always remember to invoke `commit()` to flush the changes. Now, the
    following script shows how to implement the query transactions:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`delete_signup()` 遵循 `update_signup()` 的策略，在调用 `delete()` 之前先使用 `filter()`。另一种实现方式是再次使用
    `sess.query()` 检索对象，并将检索到的对象作为参数传递给 `Session` 对象的 `delete(obj)`，这是一个不同的函数。始终记得调用
    `commit()` 来刷新更改。现在，以下脚本展示了如何实现查询事务：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Moreover, `SignupRepository` also highlights multiple and single records being
    retrieved in many forms. The `Session` object has a `query()` method, which requires
    *model class(es)* or *model column names* as argument(s). The function argument
    performs the record retrieval with column projection. For instance, the given
    `get_all_signup()` selects all signup records with all the columns projected in
    the result. If we want to include only `username` and `password`, we can write
    our query as `sess.query(Signup.username, Signup.password)`, just like in the
    given `get_all_signup_where()`. This `query()` method also shows how to manage
    constraints using the `filter()` method with the appropriate conditional expressions.
    Filtering always comes after column projection.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`SignupRepository` 还突出了以多种形式检索多个和单个记录。`Session` 对象有一个 `query()` 方法，它需要一个或多个
    *模型类* 或 *模型列名* 作为参数。函数参数执行带有列投影的记录检索。例如，给定的 `get_all_signup()` 选择了所有带有所有列投影的注册记录。如果我们只想包括
    `username` 和 `password`，我们可以将查询写成 `sess.query(Signup.username, Signup.password)`，就像在给定的
    `get_all_signup_where()` 中一样。这个 `query()` 方法还展示了如何使用 `filter()` 方法以及适当的条件表达式来管理约束。过滤总是在列投影之后进行。
- en: On the other hand, the `Session` object has an `order_by()` method that takes
    column names as parameters. It is performed last in the series of query transactions,
    before the result is extracted. The given sample, `get_all_signup_sorted_desc()`,
    sorts all `Signup` objects in descending order by `username`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`Session`对象有一个`order_by()`方法，它接受列名作为参数。它在查询事务的提取之前执行，是查询事务系列中的最后一个操作。给定的示例`get_all_signup_sorted_desc()`按`username`降序排序所有`Signup`对象。
- en: The last portion of the `query()` builder returns the result of the transactions,
    whether it is a list of records or a single record. The `all()` function ends
    the query statement that returns multiple records, while `first()`, `scalar()`,
    `one()`, or `one_or_none()` can be applied if the result is a single row. In `get_signup()`,
    `one_or_none()` is utilized to raise an exception when no record is returned.
    For SQLAlchemy’s query transactions, all these functions can close the `Session`
    object. The repository classes for SQLAlchemy are in the `ch05a` folder’s `/repository/sqlalchemy/signup.py`
    module script file.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`query()`构建器的最后一部分返回事务的结果，无论是记录列表还是单个记录。`all()`函数结束返回多个记录的查询语句，而`first()`、`scalar()`、`one()`或`one_or_none()`可以应用于结果为单行的情况。在`get_signup()`中，使用`one_or_none()`在无记录返回时引发异常。对于
    SQLAlchemy 的查询事务，所有这些函数都可以关闭`Session`对象。SQLAlchemy 的存储库类位于`ch05a`文件夹的`/repository/sqlalchemy/signup.py`模块脚本文件中。'
- en: Creating the JOIN queries
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建 JOIN 查询
- en: For all the ORMs supported by FastAPI, only SQLAlchemy implements join queries
    pragmatically and functionally, just like how we implemented the previous CRUD
    transactions. We used almost all of the methods we need to create joins previously
    except for `join()`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 FastAPI 支持的所有 ORM，只有 SQLAlchemy 实现了具有实用性和功能的联合查询，就像我们之前实现 CRUD 事务一样。我们几乎使用了创建联合查询所需的所有方法，除了`join()`。
- en: 'Let us look at `LoginMemberRepository`, which shows how we can create a join
    query statement in SQLAlchemy with model classes in *one-to-one relationships*:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`LoginMemberRepository`，它展示了如何使用 SQLAlchemy 的模型类在*一对一关系*中创建联合查询语句：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`join_login_members()` shows the conventional way of creating *JOIN* queries.
    This solution requires passing the parent and child classes as query parameters
    and overriding the `ON` condition through the `filter()` method. The parent model
    class must come first in the column projection before the child class in the `query()`
    builder to extract the preferred result.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`join_login_members()`展示了创建*JOIN*查询的传统方法。此解决方案需要传递父类和子类作为查询参数，并通过`filter()`方法覆盖`ON`条件。在`query()`构建器中，父模型类必须在子类之前出现在列投影中，以便提取所需的结果。'
- en: Another way is to use the `select_from()` function instead of `query()` to distinguish
    the parent class from the child. This approach is more appropriate for a *one-to-one*
    relationship.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用`select_from()`函数而不是`query()`来区分父类和子类。这种方法更适合*一对一*关系。
- en: 'On the other hand, `MemberAttendanceRepository` showcases the *one-to-many*
    relationship between the `Profile_Members` and `Attendance_Member` model classes:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`MemberAttendanceRepository`展示了`Profile_Members`和`Attendance_Member`模型类之间的*一对多*关系：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`join_member_attendance()` shows the use of the `join()` method in building
    the *INNER JOIN* queries between `Profile_Members` and `Attendance_Member`. `filter()`
    is not needed anymore to build the `ON` condition because `join()` automatically
    detects and recognizes the `relationship()` parameters and the `ForeignKey` constructs
    defined at the beginning. But if there are other additional constraints, `filter()`
    can always be invoked, but only after the `join()` method.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`join_member_attendance()`展示了在构建`Profile_Members`和`Attendance_Member`之间的*内连接*查询时`join()`方法的使用。由于`join()`自动检测并识别在开头定义的`relationship()`参数和`ForeignKey`构造，因此不再需要`filter()`来构建`ON`条件。但如果存在其他附加约束，`filter()`始终可以调用，但必须在`join()`方法之后。'
- en: The `outer_join_member()` repository method implements an *OUTER JOIN* query
    from the one-to-many relationship. The `outerjoin()` method will extract all `Profile_Members`
    records mapped to their corresponding `Attendance_Member` or return `null` if
    there are none.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`outer_join_member()`存储库方法实现了从一对多关系中的*外连接*查询。`outerjoin()`方法将提取所有映射到相应`Attendance_Member`的`Profile_Members`记录，如果没有，则返回`null`。'
- en: Running the transactions
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行事务
- en: Now, let us apply these repository transactions to the administration-related
    API services of our application. Instead of using collections to store all the
    records, we will be utilizing the ORM’s transactions to manage the data using
    PostgreSQL. First, we need to import the essential components required by the
    repository, such as `SessionFactory`, the repository class, and the `Signup` model
    class. APIs such as `Session` and other `typing` APIs can only be part of the
    implementation for type hints.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将这些存储库事务应用到我们应用程序的与行政相关的API服务中。我们不会使用集合来存储所有记录，而是将利用ORM的事务来使用PostgreSQL管理数据。首先，我们需要导入存储库所需的必要组件，例如`SessionFactory`、存储库类和`Signup`模型类。像`Session`和其他`typing`
    API这样的API只能作为实现类型提示的一部分。
- en: 'The following script shows a portion of the administrator’s API services highlighting
    the insertion and retrieval services for new access registration:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下脚本展示了管理员API服务的一部分，突出了新访问注册的插入和检索服务：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'First, we need to create the `Session` instance through `SessionFactory()`,
    which we derived from `sessionmaker()`, since the repository layer is dependent
    on the session. In our application, a `sess_db()` custom generator is used to
    open and destroy the `Session` instance. It is injected into the API service methods
    to tell the `Session` instance to proceed with instantiating `SignupRepository`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要通过`SessionFactory()`创建`Session`实例，这是从`sessionmaker()`派生出来的，因为存储库层依赖于会话。在我们的应用程序中，使用了一个自定义生成器`sess_db()`来打开和销毁`Session`实例。它被注入到API服务方法中，以告诉`Session`实例继续实例化`SignupRepository`：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Once instantiated, the repository can provide record insertion through `insert_signup()`,
    which inserts the `Signup` record. Another of its methods is `get_all_signup()`,
    which retrieves all login accounts for approval:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦实例化，存储库可以通过`insert_signup()`方法提供记录插入，该方法插入`Signup`记录。它的另一个方法是`get_all_signup()`，该方法检索所有待批准的登录账户：
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Both the `get_signup()` and `list_signup()` services have a `request_model`
    of the `SignupReq` type, which determines the expected output of the APIs. But
    as you may have noticed, `get_signup()` returns the `Signup` object, while `list_signup()`
    returns a list of `Signup` records. How is that possible? If `request_model` is
    used to capture the query result of the SQLAlchemy query transactions, the `BaseModel`
    class or request model must include a nested `Config` class with its `orm_mode`
    set to `True`. This built-in configuration enables type mapping and validation
    of `BaseModel` for the SQLAlchemy model types used by the repository, before all
    the record objects are filtered and stored in the request models. More information
    about the `response_model` parameter can be found in [*Chapter 1*](B17975_01.xhtml#_idTextAnchor014),
    *Setting Up FastAPI for Starters*.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_signup()`和`list_signup()`服务都有一个`SignupReq`类型的`request_model`，这决定了API的预期输出。但正如你可能已经注意到的，`get_signup()`返回`Signup`对象，而`list_signup()`返回`Signup`记录的列表。这是如何实现的？如果`request_model`用于捕获SQLAlchemy查询事务的查询结果，则`BaseModel`类或请求模型必须包含一个嵌套的`Config`类，其`orm_mode`设置为`True`。这个内置配置在所有记录对象被过滤并存储在请求模型之前，为存储库使用的SQLAlchemy模型类型启用类型映射和验证。有关`response_model`参数的更多信息，请参阅[*第1章*](B17975_01.xhtml#_idTextAnchor014)，*为初学者设置FastAPI*。'
- en: '`SignupReq`, which is used by the query services of our application, is defined
    as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序的查询服务使用的`SignupReq`定义如下：
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The script shows how `orm_mode` is enabled using the equals sign (`=`) rather
    than the typical colon symbol (`:`), which means `orm_mode` is a configuration
    detail and not part of the class attribute.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本展示了如何使用等号（`=`）而不是典型的冒号符号（`:`）来启用`orm_mode`，这意味着`orm_mode`是配置细节，而不是类属性的一部分。
- en: Overall, using SQLAlchemy for the repository layer is systematic and procedural.
    It is easy to map and synchronize the model classes with the schema definitions.
    Establishing relationships through the model classes is handy and predictable.
    Although there are lots of APIs and directives involved, it is still the most
    widely supported library for domain modeling and repository construction. Its
    documentation ([https://docs.sqlalchemy.org/en/14/](https://docs.sqlalchemy.org/en/14/))
    is complete and informative enough to guide developers regarding the different
    API classes and methods.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，使用SQLAlchemy作为存储库层是系统化和程序化的。它很容易将模型类与模式定义进行映射和同步。通过模型类建立关系既方便又可预测。尽管涉及许多API和指令，但它仍然是领域建模和存储库构建最广泛支持的库。它的文档([https://docs.sqlalchemy.org/en/14/](https://docs.sqlalchemy.org/en/14/))完整且信息丰富，足以指导开发者了解不同的API类和方法。
- en: Another feature of SQLAlchemy that’s loved by many is its capability to generate
    table schemas at the application level.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy受到许多人喜爱的另一个特性是它能够在应用级别生成表模式。
- en: Creating tables
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建表
- en: Usually, SQLAlchemy works with the table schemas that have already been generated
    by the database administrator. In this project, the ORM setup started with designing
    the domain model classes before mapping them to the actual tables. But SQLAlchemy
    can auto-create table schemas at runtime for the FastAPI platform, which may be
    helpful during the testing or prototyping stage of the project.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，SQLAlchemy与数据库管理员已经生成的表模式一起工作。在这个项目中，ORM设置是从设计领域模型类开始的，然后将其映射到实际的表。但SQLAlchemy可以为FastAPI平台在运行时自动创建表模式，这在项目的测试或原型阶段可能很有帮助。
- en: 'The `sqlalchemy` module has a `Table()` directive that can create a table object
    with the essential column metadata using the `Column()` method, which we used
    in the mapping. The following is a sample script that shows how the ORM creates
    the signup table at the application level:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`sqlalchemy`模块有一个`Table()`指令，可以使用`Column()`方法创建一个表对象，该方法我们在映射中使用过。以下是一个示例脚本，展示了ORM如何在应用级别创建注册表：'
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Part of the schema definition is `MetaData()`, a registry that contains the
    necessary methods for generating the tables. When all the schema definitions are
    signed off, the `create_all()` method of the `MetaData()` instance is executed
    with the engine to create the tables. This process may sound straightforward,
    but we seldom pursue this DDL feature of SQLAlchemy in projects at the production
    stage.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 模式定义的一部分是`MetaData()`，这是一个包含生成表所需方法的注册表。当所有模式定义都获得批准后，`MetaData()`实例的`create_all()`方法与引擎一起执行以创建表。这个过程听起来很简单，但在生产阶段的项目中，我们很少追求SQLAlchemy的这个DDL特性。
- en: Now, let us explore how SQLAlchemy can be used to create asynchronous CRUD transactions
    for asynchronous API services.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们探索如何使用SQLAlchemy为异步API服务创建异步CRUD事务。
- en: Implementing async CRUD transactions using SQLAlchemy
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SQLAlchemy实现异步CRUD事务
- en: From version 1.4, SQLAlchemy supports `Session` object. Our `ch05b` project
    showcases the asynchronous side of SQLAlchemy.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本1.4开始，SQLAlchemy支持`Session`对象。我们的`ch05b`项目展示了SQLAlchemy的异步方面。
- en: Installing the asyncio-compliant database drivers
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装符合asyncio规范的数据库驱动程序
- en: 'Before we begin setting up the database configuration, we need to install the
    following asyncio-compliant drivers: `aiopg` and `asyncpg`. First, we need to
    install `aiopg`, a library that will assist with any asynchronous access to PostgreSQL:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始设置数据库配置之前，我们需要安装以下符合asyncio规范的驱动程序：`aiopg`和`asyncpg`。首先，我们需要安装`aiopg`，这是一个库，它将帮助进行任何异步访问PostgreSQL：
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, we must install `asyncpg`, which helps build PostgreSQL asynchronous
    transactions through Python’s AsyncIO framework:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须安装`asyncpg`，它通过Python的AsyncIO框架帮助构建PostgreSQL异步事务：
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This driver is a *non-database API-compliant* driver because it runs on top
    of the AsyncIO environment instead of the database API specification for synchronous
    database transactions.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个驱动程序是一个*非数据库API规范*的驱动程序，因为它在AsyncIO环境之上运行，而不是在同步数据库事务的数据库API规范之上。
- en: Setting up the database’s connection
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置数据库的连接
- en: 'After installing the necessary drivers, we can derive the database engine through
    the application’s `create_async_engine()` method, which creates an asynchronous
    version of SQLAlchemy’s `Engine`, known as `AsyncEngine`. This method has parameters
    to set such as `future`, which can enable a variety of asynchronous features during
    CRUD transactions when set to `True`. Also, it has an `echo` parameter that can
    provide us with the generated SQL queries in the server log at runtime. But the
    most essential is the database URL, which now reflects the asynchronous database
    access through calling the `asyncpg` protocol. The following is the complete script
    for the asynchronous connection to the PostgreSQL database:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 安装必要的驱动程序后，我们可以通过应用程序的`create_async_engine()`方法推导出数据库引擎，该方法创建了一个异步版本的SQLAlchemy的`Engine`，称为`AsyncEngine`。此方法有参数可以设置，如`future`，当设置为`True`时，可以在CRUD事务期间启用各种异步功能。此外，它还有一个`echo`参数，可以在运行时提供服务器日志中生成的SQL查询。但最重要的是数据库URL，现在它反映了通过调用`asyncpg`协议的异步数据库访问。以下是对PostgreSQL数据库的异步连接的完整脚本：
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The additional `"+asyncpg"` detail in `DB_URL` indicates that `psycopg2` will
    no longer be the core database driver for PostgreSQL; instead, `asyncpg` will
    be used. This detail enables `AsyncEngine` to utilize `asyncpg` to establish the
    connection to the database. Omitting this detail will instruct the engine to recognize
    the `psycopg2` database API driver, which will cause problems during the CRUD
    transactions.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`DB_URL`中的附加`"+asyncpg"`细节表明`psycopg2`将不再是PostgreSQL的核心数据库驱动程序；相反，将使用`asyncpg`。此细节使`AsyncEngine`能够利用`asyncpg`建立与数据库的连接。省略此细节将指示引擎识别`psycopg2`数据库API驱动程序，这将在CRUD事务期间引起问题。'
- en: Creating the session factory
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建会话工厂
- en: Like in the synchronous version, the `sessionmaker()` directive is utilized
    to create the session factory with some new parameters set to enable `AsyncSession`.
    First, its `expire_on_commit` parameter is set to `False` to make that model instances
    and its attribute values accessible for the duration of the transaction, even
    after calling `commit()`. Unlike in the synchronous environment, all entity classes
    and their column objects are still accessible by other processes, even after transaction
    commit. Then, its `class_` parameter bears the class name `AsyncSession`, the
    entity that will take control of the CRUD transactions. Of course, `sessionmaker()`
    still needs the engine for `AsyncConnection` and its underlying asynchronous context
    managers.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 与同步版本类似，`sessionmaker()`指令被用来创建带有一些新参数的会话工厂以启用`AsyncSession`。首先，将`expire_on_commit`参数设置为`False`，以便在事务期间，即使调用`commit()`后，模型实例及其属性值仍然可访问。与同步环境不同，所有实体类及其列对象在事务提交后仍然可以被其他进程访问。然后，其`class_`参数携带类名`AsyncSession`，该实体将控制CRUD事务。当然，`sessionmaker()`仍然需要`AsyncConnection`及其底层的异步上下文管理器。
- en: 'The following script shows how the session factory is derived using the `sessionmaker()`
    directive:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 以下脚本展示了如何使用`sessionmaker()`指令推导出会话工厂：
- en: '[PRE24]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The full configuration for the asynchronous SQLAlchemy database connection can
    be found in the `/db_config/sqlalchemy_async_connect.py` module script file. Let
    us now create the model layer.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 异步SQLAlchemy数据库连接的完整配置可以在`/db_config/sqlalchemy_async_connect.py`模块脚本文件中找到。现在让我们创建模型层。
- en: Creating the Base class and the model layer
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建基类和模型层
- en: Creating the `Base` class using `declarative_base()` and creating the model
    classes using `Base` is the same as what we did in the synchronous version. No
    additional parameters are needed to build the data layer for the asynchronous
    repository transactions.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`declarative_base()`创建`Base`类和使用`Base`创建模型类与同步版本中的操作相同。构建异步存储库事务的数据层不需要额外的参数。
- en: Building the repository layer
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建存储库层
- en: 'Implementing asynchronous CRUD transactions is entirely different from implementing
    synchronous ones. The ORM supports the use of the `execute()` method of the `AsyncConnection`
    API to run some of the built-in ORM core methods, namely `update()`, `delete()`,
    and `insert()`. When it comes to query transactions, the new `select()` directive
    from the `sqlalchemy.future` module is used instead of the core `select()` method.
    And since `execute()` is an `async` method, this requires that all repository
    transactions are `async` too to apply the *Async/Await* design pattern. The following
    `AttendanceRepository` uses the asynchronous type of SQLAlchemy:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 实现异步CRUD事务与实现同步事务完全不同。ORM支持使用`AsyncConnection` API的`execute()`方法来运行一些内置的ORM核心方法，即`update()`、`delete()`和`insert()`。当涉及到查询事务时，使用来自`sqlalchemy.future`模块的新`select()`指令而不是核心的`select()`方法。由于`execute()`是一个`async`方法，这要求所有仓库事务都是`async`，以便应用*Async/Await*设计模式。下面的`AttendanceRepository`使用了SQLAlchemy的异步类型：
- en: '[PRE25]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The given *asynchronous* `insert_attendance()` method in the preceding script
    shows the use of the `insert()` directive in creating an attendance log for a
    gym member. First, we need to pass the model class name to `insert()` to let the
    session know what table to access for the transaction. Afterward, it emits the
    `values()` method to project all the column values for insertion. Lastly, we need
    to call the `execute()` method to run the final `insert()` statement and automatically
    commit the changes since we didn’t turn off the `autocommit` parameter of `sessionmaker()`
    during the configuration. Do not forget to invoke `await` before running the asynchronous
    method because everything runs on top of the AsyncIO platform this time.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的脚本中给出的*异步*`insert_attendance()`方法展示了在创建健身房成员的出勤日志时使用`insert()`指令。首先，我们需要将模型类名传递给`insert()`，以便会话知道要访问哪个表进行事务。之后，它发出`values()`方法来投影插入的所有列值。最后，我们需要调用`execute()`方法来运行最终的`insert()`语句，并自动提交更改，因为我们没有在配置期间关闭`sessionmaker()`的`autocommit`参数。不要忘记在运行异步方法之前调用`await`，因为这次所有操作都是在AsyncIO平台上运行的。
- en: Also, you have the option to add some additional execution details before running
    `execute()`. One of these options is `synchronize_session`, which tells the session
    to always synchronize the model attribute values and the updated values from the
    database using the `fetch` method.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您还有在运行`execute()`之前添加一些额外执行细节的选项。这些选项之一是`synchronize_session`，它告诉会话始终使用`fetch`方法同步模型属性值和数据库中的更新值。
- en: 'Almost the same procedure is applied to the `update_attendance()` and `delete_attendance()`
    methods. We can run them through `execute()` and nothing else:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`update_attendance()`和`delete_attendance()`方法，几乎采用相同的程序。我们可以通过`execute()`运行它们，无需其他操作：
- en: '[PRE26]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: When it comes to queries, the repository class contains `get_all_attendance()`,
    which retrieves all the attendance records, and `get_attendance()`, which retrieves
    the attendance log of a particular member through its `id`. Constructing the `select()`
    method is a straightforward and pragmatic task since it is similar to writing
    a native `SELECT` statement in SQL development. First, the method needs to know
    what columns to project, and then it caters to some constraints if there are any.
    Then, it needs the `execute()` method to run the query asynchronously and extract
    the `Query` object. The resulting `Query` object has a `scalars()` method, which
    we can call to retrieve the list of records. Do not forget to close the session
    by calling the `all()` method.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到查询时，仓库类包含`get_all_attendance()`方法，用于检索所有出勤记录，以及`get_attendance()`方法，通过其`id`检索特定成员的出勤日志。构建`select()`方法是一个简单且实用的任务，因为它类似于在SQL开发中编写原生的`SELECT`语句。首先，该方法需要知道要投影哪些列，然后如果有任何约束，它将满足这些约束。然后，它需要`execute()`方法来异步运行查询并提取`Query`对象。生成的`Query`对象有一个`scalars()`方法，我们可以调用它来检索记录列表。不要忘记通过调用`all()`方法来关闭会话。
- en: '`check_attendance()`, on the other hand, uses the `scalar()` method of the
    `Query` object to retrieve one record: a specific attendance. Aside from record
    retrieval, `scalar()` also closes the session:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`check_attendance()`使用`Query`对象的`scalar()`方法来检索一条记录：特定的出勤记录。除了记录检索外，`scalar()`还会关闭会话：
- en: '[PRE27]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The repository classes for the asynchronous SQLAlchemy can be found in the `/repository/sqlalchemy/attendance.py`
    module script file. Now, let us apply these asynchronous transactions to pursue
    some attendance monitoring services for our fitness gym application.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 异步SQLAlchemy的存储库类可以在`/repository/sqlalchemy/attendance.py`模块脚本文件中找到。现在，让我们将这些异步事务应用到我们的健身馆应用程序的出勤监控服务中。
- en: Important note
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The `**` operator in `update_attendance()` is a Python operator overload that
    converts a dictionary into `kwargs`. Thus, the result of `**details` is a `kwargs`
    argument for the `values()` method of the `select()` directive.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在`update_attendance()`函数中的`**`操作符是一个Python操作符重载，它将字典转换为`kwargs`。因此，`**details`的结果是`select()`指令的`values()`方法的`kwargs`参数。
- en: Running the CRUD transactions
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行CRUD事务
- en: 'There two big differences between AsyncIO-driven SQLAlchemy and the database
    API-compliant option when creating the `Session` instance:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建`Session`实例时，AsyncIO驱动的SQLAlchemy与数据库API兼容选项之间有两个主要区别：
- en: First, `AsyncSession`, which was created by the `AsyncSessionFactory()` directive,
    needs an asynchronous `with` context manager because of the connection’s `AsyncEngine`,
    which needs to be closed after every `commit()` transaction. Closing the session
    factory is not part of the procedure in the synchronous ORM version.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，由`AsyncSessionFactory()`指令创建的`AsyncSession`需要一个异步的`with`上下文管理器，因为连接的`AsyncEngine`需要在每次`commit()`事务后关闭。在同步ORM版本中，关闭会话工厂不是程序的一部分。
- en: Second, after its creation, `AsyncSession` will only start executing all the
    CRUD transactions when the service calls its `begin()` method. The main reason
    is that `AsyncSession` can be closed and needs to be closed once the transaction
    has been executed. That is why another asynchronous context manager is used to
    manage `AsyncSession`.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，在其创建之后，`AsyncSession`只有在服务调用其`begin()`方法时才会开始执行所有的CRUD事务。主要原因在于`AsyncSession`可以被关闭，并且在事务执行后需要关闭。这就是为什么使用另一个异步上下文管理器来管理`AsyncSession`的原因。
- en: 'The following code shows the `APIRouter` script, which implements the services
    for monitoring gym member attendance using the asynchronous `AttendanceRepository`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了`APIRouter`脚本，它实现了使用异步`AttendanceRepository`监控健身馆会员出勤的服务：
- en: '[PRE28]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The preceding script shows no direct parameter passing between the repository
    class and the `AsyncSession` instance. The session must comply with the two context
    managers before it becomes a working one. This syntax is valid under *SQLAlchemy
    1.4*, which may undergo some changes in the future with SQLAlchemy’s next releases.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的脚本显示了存储库类和`AsyncSession`实例之间没有直接的参数传递。会话必须符合两个上下文管理器，才能成为一个有效的会话。这个语法在*SQLAlchemy
    1.4*下是有效的，未来随着SQLAlchemy的下一个版本可能会发生变化。
- en: Other ORM platforms that have been created for asynchronous transactions are
    easier to use. One of these is **GINO**.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为异步事务创建的其他ORM平台更容易使用。其中之一就是**GINO**。
- en: Using GINO for async transactions
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用GINO进行异步事务
- en: '**GINO**, which stands for **GINO Is Not ORM**, is a lightweight asynchronous
    ORM that runs on top of an SQLAlchemy Core and AsyncIO environment. All its APIs
    are asynchronous-ready so that you can build contextual database connections and
    transactions. It has built-in *JSONB* support so that it can convert its results
    into JSON objects. But there is one catch: GINO only supports PostgreSQL databases.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**GINO**，代表**GINO Is Not ORM**，是一个轻量级的异步ORM，它运行在SQLAlchemy Core和AsyncIO环境之上。它所有的API都是异步准备就绪的，这样你可以构建上下文数据库连接和事务。它内置了对*JSONB*的支持，因此可以将结果转换为JSON对象。但有一个限制：GINO仅支持PostgreSQL数据库。'
- en: While creating the gym fitness project, the only available stable GINO version
    is 1.0.1, which requires *SQLAlchemy 1.3*. Therefore, installing GINO will automatically
    uninstall *SQLAlchemy 1.4*, thus adding the GINO repository to the `ch05a` project
    to avoid any conflicts with the async version of SQLAlchemy.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建健身馆项目时，唯一可用的稳定GINO版本是1.0.1，它需要*SQLAlchemy 1.3*。因此，安装GINO将自动卸载*SQLAlchemy
    1.4*，从而将GINO存储库添加到`ch05a`项目中，以避免与SQLAlchemy的异步版本发生冲突。
- en: 'You can use the following command to install the latest version of GINO:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下命令安装GINO的最新版本：
- en: '[PRE29]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Installing the database driver
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装数据库驱动
- en: Since the only RDBMS it supports is PostgreSQL, you only need to install `asyncpg`
    using the `pip` command.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它只支持PostgreSQL作为RDBMS，你只需要使用`pip`命令安装`asyncpg`。
- en: Establishing the database connection
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 建立数据库连接
- en: 'No other APIs are needed to open a connection to the database except for the
    `Gino` directive. We need to instantiate the class to start building the domain
    layer. The `Gino` class can be imported from the ORM’s `gino` module, as shown
    by the following script:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`Gino`指令外，不需要其他API来打开数据库连接。我们需要实例化该类以开始构建领域层。`Gino`类可以从ORM的`gino`模块导入，如下面的脚本所示：
- en: '[PRE30]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Its instance is like a façade that controls all database transactions. It starts
    by establishing a database connection once it’s been provided with the correct
    PostgreSQL administrator credentials. The full GINO database connectivity script
    can be found in the `/db_config/gino_connect.py` script file. Let us now build
    the model layer.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 其实例类似于一个门面，它控制所有数据库事务。一旦提供了正确的PostgreSQL管理员凭据，它就会开始建立数据库连接。完整的GINO数据库连接脚本可以在`/db_config/gino_connect.py`脚本文件中找到。现在让我们构建模型层。
- en: Building the model layer
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建模型层
- en: 'The model class definition in GINO has similarities with SQLAlchemy when it
    comes to structuring, column metadata, and even the existence of the `__tablename__`
    property. The only difference is the superclass type because GINO uses the `Model`
    class from the database reference instance’s `db`. The following script shows
    how the `Signup` domain model is mapped to the `signup` table:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在结构、列元数据和`__tablename__`属性的存在方面，GINO中的模型类定义与SQLAlchemy相似。唯一的区别是超类类型，因为GINO使用数据库引用实例的`db`中的`Model`类。以下脚本展示了如何将`Signup`领域模型映射到`signup`表：
- en: '[PRE31]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Like in SQLAlchemy, the `__tablename__` property is mandatory for all model
    classes to indicate their mapped table schema. When defining the column metadata,
    the `db` object has a `Column` directive that can set properties such as the *column
    type*, *primary key*, *unique*, *default*, *nullable*, and *index*. The column
    types also come from the `db` reference object, and these types are also the same
    for SQLAlchemy – that is, `String`, `Integer`, `Date`, `Time`, `Unicode`, and
    `Float`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 与SQLAlchemy一样，所有模型类都必须有`__tablename__`属性来指示其映射的表模式。在定义列元数据时，`db`对象有一个`Column`指令可以设置属性，如*列类型*、*主键*、*唯一*、*默认值*、*可为空*和*索引*。列类型也来自`db`引用对象，这些类型与SQLAlchemy相同，即`String`、`Integer`、`Date`、`Time`、`Unicode`和`Float`。
- en: And just in case the name of the model attribute does not match the column name,
    the `Column` directive has its first parameter register the name of the actual
    column and maps it to the model attributes. The `username` and `password` columns
    are example cases of mapping the class attributes to the table’s column names.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果模型属性的名称与列名称不匹配，`Column`指令的第一个参数将注册实际列的名称并将其映射到模型属性。`username`和`password`列是映射类属性到表列名称的示例情况。
- en: Mapping table relationships
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 映射表关系
- en: 'At the time of writing, GINO only supports the *many-to-one relationship* by
    default. The `db` reference object has a `ForeignKey` directive, which establishes
    a foreign key relationship with the parent model. It just needs the actual reference
    key column and table name of the parent table to pursue the mapping. Setting the
    `ForeignKey` property in the `Column` object of the child model class is enough
    configuration to perform a *LEFT OUTER JOIN* to retrieve all the child records
    of the parent mode class. GINO has no `relationship()` function to address more
    details regarding how to fetch the child records of the parent model class. However,
    it has built-in loaders to automatically determine the foreign key and perform
    a many-to-one join query afterward. A perfect setup for this join query is the
    relationship configuration between the `Profile_Trainers` and `Gym_Class` model
    classes, as shown in the following script:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写本文时，GINO默认只支持*多对一关系*。`db`引用对象有一个`ForeignKey`指令，它建立了与父模型的键关系。它只需要父表的实际引用键列和表名称来追求映射。在子模型类的`Column`对象中设置`ForeignKey`属性就足够配置以执行*左外连接*来检索父模型类的所有子记录。GINO没有`relationship()`函数来处理有关如何检索父模型类子记录的更多细节。然而，它具有内置的加载器，可以自动确定外键并在之后执行多对一连接查询。此连接查询的完美设置是`Profile_Trainers`和`Gym_Class`模型类之间的关系配置，如下面的脚本所示：
- en: '[PRE32]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We will have to make some changes if we need to build a query that will deal
    with a *one-to-many* or a *one-to-one relationship*. For the *LEFT OUTER JOIN*
    query to work, the parent model class must have a `set` collection defined to
    contain all the child records during join queries involving one-to-many relationships.
    For a *one-to-one relationship*, the parent only needs to instantiate the child
    model:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要构建一个能够处理*一对多*或*一对一*关系的查询，我们可能需要做出一些调整。为了使*左外连接*查询能够工作，父模型类必须定义一个`set`集合来包含在涉及一对多关系的连接查询期间的所有子记录。对于*一对一*关系，父模型只需要实例化子模型：
- en: '[PRE33]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This *set collection* or *child object* must be instantiated in the parent’s
    `__init__()` to be accessed by the ORM’s loader through the *children* or *child*
    `@property`, respectively. Using `@property` is the only way to manage joined
    records.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这个*集合*或*子对象*必须在父的`__init__()`中实例化，以便通过ORM的loader通过*children*或*child* `@property`分别访问。使用`@property`是管理连接记录的唯一方式。
- en: Note that the existence of the loader APIs is proof that GINO does not support
    the automated relationship that SQLAlchemy has. If we want to deviate from its
    core setup, Python programming is needed to add some features not supported by
    the platform, such as the one-to-many setup between `Profile_Members` and `Gym_Class`,
    and between `Login` and `Profile_Members`/`Profile_Trainers`. In the previous
    script, notice the inclusion of a constructor and the custom `children` Python
    property in `Profile_Members`, as well as the custom `child` property in `Login`.
    This is because GINO only has a built-in `parent` property.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，loader API的存在证明了GINO不支持SQLAlchemy所具有的自动化关系。如果我们想偏离其核心设置，就需要使用Python编程来添加平台不支持的一些功能，例如在`Profile_Members`和`Gym_Class`之间以及`Login`和`Profile_Members`/`Profile_Trainers`之间的一对多设置。在前面的脚本中，请注意`Profile_Members`中包含了一个构造函数和自定义的`children`
    Python属性，以及`Login`中的自定义`child`属性。这是因为GINO只内置了一个`parent`属性。
- en: You can find the domain models of GINO in the `/models/data/gino_models.py`
    script.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`/models/data/gino_models.py`脚本中找到GINO的域模型。
- en: Important note
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: '`@property` is a Python decorator that’s used to implement a getter/setter
    in a class. This hides an instance variable from the accessor and exposes its
    *getter* and *setter* property *fields*. Using `@property` is one way to implement
    the *encapsulation* principle in Python.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`@property`是Python装饰器，用于在类中实现getter/setter。这隐藏了一个实例变量，并暴露了其*getter*和*setter*属性*字段*。使用`@property`是实现Python中*封装*原则的一种方式。'
- en: Implementing the CRUD transactions
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现CRUD事务
- en: 'Let us consider the following `TrainerRepository`, which manages trainer profiles.
    Its `insert_trainer()` method shows the conventional way of implementing insert
    transactions. GINO requires its model class to call `create()`, an inherited method
    from the `db` reference object. All the column values are passed to the `create()`
    method through named parameters or as a bundle using `kwargs` before the record
    object is persisted. But GINO allows another insert option that uses the instance
    of the model derived by injecting column values into its constructor. The created
    instance has a method called `create()` that inserts the record object without
    requiring any parameters:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下`TrainerRepository`，它管理教练档案。它的`insert_trainer()`方法展示了实现插入事务的传统方式。GINO要求其模型类调用从`db`引用对象继承的`create()`方法。所有列值都通过命名参数或作为`kwargs`的包传递给`create()`方法，在记录对象持久化之前。但GINO允许另一种插入选项，它使用通过向其构造函数注入列值得到的模型实例。创建的实例有一个名为`create()`的方法，它插入记录对象而不需要任何参数：
- en: '[PRE34]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '`update_trainer()` highlights how GINO updates table records. Based on the
    script, updating the table in the GINO way involves doing the following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`update_trainer()`展示了GINO如何更新表记录。根据脚本，以GINO的方式更新表涉及以下步骤：'
- en: First, it requires the `get()` class method of the model class to retrieve the
    record object with the `id` primary key.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，它需要模型类的`get()`类方法来检索具有`id`主键的记录对象。
- en: 'Second, the extracted record has an instance method called `update()` that
    will automatically modify the mapped row with the new data specified in its `kwargs`
    argument. The `apply()` method will commit the changes and close the transaction:'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二，提取的记录有一个名为`update()`的实例方法，它将自动使用其`kwargs`参数中指定的新数据修改映射的行。`apply()`方法将提交更改并关闭事务：
- en: '[PRE35]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Another option is to use the SQLAlchemy `ModelClass.update.values(ModelClass).where(expression)`
    clause, which, when applied to `update_trainer()`, will give us this final statement:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是使用 SQLAlchemy 的 `ModelClass.update.values(ModelClass).where(expression)`
    子句，当应用于 `update_trainer()` 时，将给出以下最终语句：
- en: '[PRE36]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Its `delete_trainer()` also follows the same approach as the GINO *update*
    transaction. This transaction is a two-step process, and the last step requires
    calling the `delete()` instance method of the extracted record object:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 它的 `delete_trainer()` 也遵循 GINO *更新* 事务的相同方法。这个事务是两步过程，最后一步需要调用提取的记录对象的 `delete()`
    实例方法：
- en: '[PRE37]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'On the other hand, `TrainerRepository` has two methods, `get_member()` and
    `get_all_member()`, which show how GINO constructs query statements:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`TrainerRepository` 有两个方法，`get_member()` 和 `get_all_member()`，展示了 GINO
    如何构建查询语句：
- en: The former retrieves a specific record object using its primary key through
    the `get()` class method of the model class
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前者通过模型类的 `get()` 类方法使用其主键检索特定记录对象
- en: 'The latter uses the `gino` extension of `query` to utilize the `all()` method,
    which retrieves the records:'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后者使用 `query` 的 `gino` 扩展来利用 `all()` 方法，该方法检索记录：
- en: '[PRE38]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'But what translates database rows into model objects in a query’s execution
    is the built-in loader of GINO. If we expand further on the solution presented
    in `get_all_member()`, this will look like this:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 但在查询执行过程中将数据库行转换为模型对象的是 GINO 的内置加载器。如果我们进一步扩展 `get_all_member()` 中提出的解决方案，这将看起来像这样：
- en: '[PRE39]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In the GINO ORM, all queries utilize `ModelLoader` to load each database record
    into a model object:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GINO ORM 中，所有查询都利用 `ModelLoader` 将每个数据库记录加载到模型对象中：
- en: '[PRE40]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: If the normal query requires `ModelLoader`, what is needed for the *JOIN* query
    transactions? GINO has no automated support for table relationships, and creating
    *JOIN* queries is impossible without `ModelLoader`. The `join_classes_trainer()`
    method implements a *one-to-many* query for `Profile_Trainers` and `Gym_Class`.
    The `distinct(Gym_Class.id).load(parent=Profile_Trainers)` clause in the query
    creates a `ModelLoader` for `GymClass`, which will merge and load the `Profile_Trainers`
    parent record into its child `Gym_Class`. `join_member_classes()` creates *one-to-many*
    joins, while `distinct(Profile_Members.id).load(add_child=Gym_Class)` creates
    a `ModelLoader` to build the set of `Gym_Class` records, as per the `Profile_Members`
    parent.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果正常查询需要 `ModelLoader`，那么 *连接* 查询事务需要什么？GINO 没有自动支持表关系，没有 `ModelLoader`，创建 *连接*
    查询是不可能的。`join_classes_trainer()` 方法实现了 `Profile_Trainers` 和 `Gym_Class` 的 *一对多*
    查询。查询中的 `distinct(Gym_Class.id).load(parent=Profile_Trainers)` 子句为 `GymClass`
    创建了一个 `ModelLoader`，它将合并并加载 `Profile_Trainers` 父记录到其子 `Gym_Class`。`join_member_classes()`
    创建 *一对多* 连接，而 `distinct(Profile_Members.id).load(add_child=Gym_Class)` 创建一个 `ModelLoader`
    来构建 `Gym_Class` 记录的集合，按照 `Profile_Members` 父记录。
- en: 'On the other hand, the *many-to-one* relationship of `Gym_Class` and `Profile_Members`
    uses the `load()` function of `Profile_Member`, which is a different approach
    to matching the `Gym_Class` child records to `Profile_Members`. The following
    joined query is the opposite of the *one-to-many* setup because the `Gym_Class`
    records here are on the left-hand side while the profiles are on the right:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`Gym_Class` 和 `Profile_Members` 之间的 *多对一* 关系使用 `Profile_Member` 的 `load()`
    函数，这是一种将 `Gym_Class` 子记录与 `Profile_Members` 匹配的不同方法。以下联合查询是 *一对多* 设置的反面，因为这里的
    `Gym_Class` 记录在左侧，而配置文件在右侧：
- en: '[PRE41]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: So, the loader plays an important role in building queries in GINO, especially
    joins. Although it makes query building difficult, it still gives flexibility
    to many complex queries.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，加载器在 GINO 中构建查询时扮演着重要角色，尤其是在连接操作中。尽管它使查询构建变得困难，但它仍然为许多复杂查询提供了灵活性。
- en: All the repository classes for GINO can be found in the `/repository/gino/trainers.py`
    script.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 GINO 的存储库类都可以在 `/repository/gino/trainers.py` 脚本中找到。
- en: Running the CRUD transactions
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行 CRUD 事务
- en: 'For our repositories to run in the `APIRouter` module, we need to open the
    database connection by binding the `db` reference object to the actual database
    through `DB_URL`. It is ideal to use a dependable function for the binding procedure
    because the easier form of rolling out is done through `APIRouter` injection.
    The following script shows how to set up this database binding:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们的存储库在 `APIRouter` 模块中运行，我们需要通过将 `db` 引用对象绑定到实际数据库的 `DB_URL` 来打开数据库连接。绑定过程使用可靠的函数是理想的，因为更简单的部署形式是通过
    `APIRouter` 注入完成的。以下脚本展示了如何设置这种数据库绑定：
- en: '[PRE42]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `list_trainers()` and `update_trainer()` REST services shown in the preceding
    code are some services of our *fitness club* application that will successfully
    run `TrainerRepository` after injecting `sess_db()` into `APIRouter`. GINO does
    not ask for many details when establishing the connection to PostgreSQL except
    for `DB_URL`. Always specify the `asyncpg` dialect in the URL because it is the
    only driver that’s supported by GINO as a synchronous ORM.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中显示的 `list_trainers()` 和 `update_trainer()` REST 服务是我们 *健身俱乐部* 应用程序的一些服务，在将
    `sess_db()` 注入 `APIRouter` 后将成功运行 `TrainerRepository`。GINO 在建立与 PostgreSQL 的连接时不需要太多细节，除了
    `DB_URL`。始终在 URL 中指定 `asyncpg` 方言，因为它是 GINO 作为同步 ORM 支持的唯一驱动程序。
- en: Creating the tables
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建表
- en: 'GINO and SQLAlchemy have the same approach to creating a table schema at the
    framework level. Both require the `MetaData` and `Column` directives for building
    the `Table` definitions. Then, an asynchronous function is preferred to derive
    the engine using the `create_engine()` method with our `DB_URL`. Like in SQLAlchemy,
    this engine plays a crucial role in building the tables through `create_all()`,
    but this time, it uses GINO’s `GinoSchemaVisitor` instance. The following script
    shows the complete implementation of how tables are generated in GINO using the
    AsyncIO platform:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: GINO 和 SQLAlchemy 在框架级别创建表架构的方法相同。两者都要求使用 `MetaData` 和 `Column` 指令来构建 `Table`
    定义。然后，建议使用异步函数通过 `create_engine()` 方法结合我们的 `DB_URL` 来获取引擎。与 SQLAlchemy 类似，这个引擎在通过
    `create_all()` 构建表时起着关键作用，但这次它使用 GINO 的 `GinoSchemaVisitor` 实例。以下脚本展示了 GINO 使用
    AsyncIO 平台生成表的完整实现：
- en: '[PRE43]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: As stated in SQLAlchemy, performing DDL transactions such as schema auto-generation
    at the start is optional because it may cause FastAPI’s performance to degrade,
    and even some conflicts in the existing database schema.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如 SQLAlchemy 所述，在开始时执行 DDL 事务（如模式自动生成）是可选的，因为这可能会降低 FastAPI 的性能，甚至可能导致现有数据库模式中的某些冲突。
- en: 'Now, let us explore another ORM that requires custom Python coding: **Pony
    ORM**.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们探索另一个需要自定义 Python 编码的 ORM：**Pony ORM**。
- en: Using Pony ORM for the repository layer
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在存储库层使用 Pony ORM
- en: Pony ORM relies on Python syntax for building the model classes and repository
    transactions. This ORM only uses Python data types such as `int`, `str`, and `float`,
    as well as class types to implement model definitions. It applies Python `lambda`
    expressions to establish CRUD transactions, especially when mapping table relationships.
    Also, Pony heavily supports JSON conversion of record objects when reading records.
    On the other hand, Pony can cache the query objects, which provides faster performance
    than the others. The code for Pony ORM can be found in the `ch05a` project.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Pony ORM 依赖于 Python 语法来构建模型类和存储库事务。这个 ORM 只使用 Python 数据类型，如 `int`、`str` 和 `float`，以及类类型来实现模型定义。它使用
    Python `lambda` 表达式来建立 CRUD 事务，尤其是在映射表关系时。此外，Pony 在读取记录时强烈支持记录对象的 JSON 转换。另一方面，Pony
    可以缓存查询对象，这比其他方法提供了更快的性能。Pony ORM 的代码可以在 `ch05a` 项目中找到。
- en: 'To use Pony, we need to install it using `pip`. This is because it is a third-party
    platform:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Pony，我们需要使用 `pip` 来安装它。这是因为它是一个第三方平台：
- en: '[PRE44]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Installing the database driver
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装数据库驱动程序
- en: 'Since Pony is an ORM designed to build synchronous transactions, we will need
    the `psycopg2` PostgreSQL driver. We can install it using the `pip` command:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Pony 是一个设计用于构建同步事务的 ORM，我们需要 `psycopg2` PostgreSQL 驱动程序。我们可以使用 `pip` 命令来安装它：
- en: '[PRE45]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Creating the database’s connectivity
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建数据库的连接性
- en: 'The approach to establishing database connectivity in Pony is simple and declarative.
    It only needs the `Database` directive from the `pony.orm` module to be instantiated
    to connect to the database using the correct database credentials. The following
    script is used in the *fitness club* prototype:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Pony 建立数据库连接的方法简单且声明式。它只需要从 `pony.orm` 模块实例化 `Database` 指令来使用正确的数据库凭据连接到数据库。以下脚本用于
    *健身俱乐部* 原型：
- en: '[PRE46]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: As you can see, the first parameter of the constructor is the *database dialect*,
    followed by `kwargs`, which contains all the details about the connection. The
    full configuration can be found in the `/db_config/pony_connect.py` script file.
    Now, let us create Pony's model classes.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，构造函数的第一个参数是 *数据库方言*，后面跟着 `kwargs`，其中包含有关连接的所有详细信息。完整的配置可以在 `/db_config/pony_connect.py`
    脚本文件中找到。现在，让我们创建 Pony 的模型类。
- en: Defining the model classes
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义模型类
- en: 'The created database object, `db`, is the only component needed to define a
    Pony *entity*, a term that refers to a model class. It has an `Entity` attribute,
    which is used to subclass each model class to provide the `_table_` attribute,
    which is responsible for the *table-entity* mapping. All entity instances are
    bound to `db` and mapped to the tables. The following script shows how the `Signup`
    class becomes an entity of the model layer:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的数据库对象 `db` 是定义 Pony *实体*（一个指模型类的术语）的唯一组件。它有一个 `Entity` 属性，用于将每个模型类子类化以提供
    `_table_` 属性，该属性负责 *表-实体* 映射。所有实体实例都绑定到 `db` 并映射到表。以下脚本展示了 `Signup` 类如何成为模型层的实体：
- en: '[PRE47]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The `pony.orm` module contains `Required`, `Optional`, `PrimaryKey`, or `Set`
    directives, which are used to create column attributes. Since each entity must
    have a primary key, `PrimaryKey` is used to define the column attribute of the
    entity. If the class has no primary key, Pony ORM will implicitly generate an
    `id` primary for the entity with the following definition:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`pony.orm` 模块包含 `Required`、`Optional`、`PrimaryKey` 或 `Set` 指令，用于创建列属性。由于每个实体都必须有一个主键，因此使用
    `PrimaryKey` 来定义实体的列属性。如果没有主键，Pony ORM 将隐式地为实体生成一个具有以下定义的 `id` 主键：'
- en: '[PRE48]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'On the other hand, the `Set` directive indicates relationships between entities.
    All these directives have a mandatory attribute column type, which declares the
    column value type in Python syntax (for example, `int`, `str`, `float`, `date`,
    or `time`) or any class type. Other column attributes include `auto`, `max_len`,
    `index`, `unique`, `nullable`, `default`, and `column`. Now, let us establish
    a relationship between model classes:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`Set` 指令表示实体之间的关系。所有这些指令都有一个强制属性列类型，它以 Python 语法（例如，`int`、`str`、`float`、`date`
    或 `time`）或任何类类型声明列值类型。其他列属性包括 `auto`、`max_len`、`index`、`unique`、`nullable`、`default`
    和 `column`。现在，让我们在模型类之间建立关系：
- en: '[PRE49]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The given `Login` class has two additional attributes, `trainers` and `members`,
    which serve as reference keys to the `Profile_Trainers` and `Profile_Members`
    models, respectively. In turn, these child entities have their respective class
    attributes pointing back at the `Login` model, establishing a relationship. These
    column attributes and their reference-foreign keys relationship must match the
    physical database schema. The following code shows examples of Pony’s child model
    classes:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 给定的 `Login` 类有两个额外的属性，`trainers` 和 `members`，它们分别作为 `Profile_Trainers` 和 `Profile_Members`
    模型的引用键。反过来，这些子实体各自有指向 `Login` 模型的类属性，从而建立了一种关系。这些列属性及其引用外键关系必须与物理数据库模式相匹配。以下代码展示了
    Pony 的子模型类示例：
- en: '[PRE50]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Defining the relationship attributes depends on the relationship type between
    the two entities. Attributes should be defined as *Optional(parent)*-*Required(child)*
    or *Optional(parent)*-*Optional(child)* if the relationship type is one-to-one.
    For one-to-many, attributes should be defined as *Set(parent)*-*Required(child)*.
    Finally, for many-to-one, the attributes must be defined as *Set(parent)*-*Set(child)*.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 定义关系属性取决于两个实体之间的关系类型。如果关系类型是一对一，则应将属性定义为 *Optional(parent)*-*Required(child)*
    或 *Optional(parent)*-*Optional(child)*。对于一对多，属性应定义为 *Set(parent)*-*Required(child)*。最后，对于多对一，属性必须定义为
    *Set(parent)*-*Set(child)*。
- en: '`Login` has a one-to-one relationship with `Profile_Members`, which explains
    the use of the `Optional` attribute to point to the `id` key of `Profile_Members`.
    The primary keys are always the reference keys in this relationship for Pony.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`Login` 与 `Profile_Members` 之间有一个一对一的关系，这解释了为什么使用 `Optional` 属性指向 `Profile_Members`
    的 `id` 键。在这个关系中，主键始终是 Pony 的引用键。'
- en: 'On the other hand, the `Profile_Trainers` model has a one-to-many setup with
    `Profile_Members`, which explains why the `trainer_id` attribute of the former
    uses the `Required` directive to point to the `Set` attribute `members` of the
    latter. Sometimes, the framework requires backreference through the directive’s
    `reverse` parameter. The preceding code also depicts the same scenario between
    the `Profile_Members` and `Gym_Class` models, where the `gclass` attribute of
    `Profile_Members` is declared as a `Set` collection that contains all the enrolled
    gym classes of the member. The reference key can be a primary key or just a typical
    class attribute in this relationship. The following snippet shows the blueprint
    of the `Gym_Class` model:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`Profile_Trainers`模型与`Profile_Members`有一个一对一的设置，这解释了为什么前者的`trainer_id`属性使用`Required`指令指向后者的`Set`属性`members`。有时，框架需要通过指令的`reverse`参数进行反向引用。前面的代码也描述了`Profile_Members`和`Gym_Class`模型之间的相同场景，其中`Profile_Members`的`gclass`属性被声明为一个包含成员所有报名健身课程的`Set`集合。在这个关系中，引用键可以是主键，也可以是典型的类属性。以下片段显示了`Gym_Class`模型的蓝图：
- en: '[PRE51]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Unlike in other ORMs, Pony needs `generate_mapping()` to be executed to realize
    all the entity mappings to the actual tables. The method is an instance method
    of the `db` instance that must appear in the last part of the module script, as
    shown in the previous snippet, where `Gym_Class` was the last Pony model class
    to be defined. All the Pony model classes can be found in the `/models/data/pony_models.py`
    script file.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他ORM不同，Pony需要执行`generate_mapping()`来将所有实体映射到实际表。该方法是`db`实例的一个实例方法，必须出现在模块脚本的最后部分，如前面的片段所示，其中`Gym_Class`是最后定义的Pony模型类。所有Pony模型类都可以在`/models/data/pony_models.py`脚本文件中找到。
- en: Note that we can create Pony entities manually or digitally using *Pony ORM
    ER Diagram Editor*, which we can access at [https://editor.ponyorm.com/](https://editor.ponyorm.com/).
    The editor can provide us with both free and commercial accounts. Let us now implement
    the CRUD transactions.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们可以使用**Pony ORM ER Diagram Editor**手动或数字化创建Pony实体，我们可以在[https://editor.ponyorm.com/](https://editor.ponyorm.com/)访问它。该编辑器可以提供免费和商业账户。现在让我们实现CRUD事务。
- en: Implementing the CRUD transactions
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现CRUD事务
- en: 'CRUD transactions in Pony are session-driven. But unlike SQLAlchemy, its repository
    classes do not require injecting `db_session` into the repository constructor.
    Each transaction in Pony will not work without `db_session`. The following code
    shows a repository class that implements all the transactions needed to manage
    a list of gym members:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: Pony中的CRUD事务是会话驱动的。但与SQLAlchemy不同，其存储库类不需要将`db_session`注入到存储库构造函数中。Pony中的每个事务在没有`db_session`的情况下都不会工作。以下代码显示了一个实现管理健身会员列表所需所有事务的存储库类：
- en: '[PRE52]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In Pony, inserting a record means instantiating the model class with the injected
    record values. An example is `insert_member()`, which inserts a profile by instantiating
    the `Profile_Members` model with the injected membership details. However, the
    case is different when updating records, as shown in the following script:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在Pony中，插入记录意味着使用注入的记录值实例化模型类。一个例子是`insert_member()`，它通过实例化`Profile_Members`模型并注入会员详情来插入个人资料。然而，更新记录的情况则不同，如下面的脚本所示：
- en: '[PRE53]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Updating a record in Pony, which is implemented in the `update_member()` script,
    means retrieving the record object through *indexing* using its `id`. The retrieved
    object is automatically converted into a JSON-able object since Pony has built-in
    support for JSON. Then, the new values of those attributes are overwritten as
    they must be changed. This *UPDATE* transaction is, again, within the bounds of
    `db_session`, thus automatically refreshing the record(s) after the overwrites.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在Pony中更新记录，通过`update_member()`脚本实现，意味着通过`id`进行索引检索记录对象。由于Pony内置了对JSON的支持，检索到的对象会自动转换为可JSON化的对象。然后，那些属性的新值会覆盖原有值，因为它们必须更改。这个*UPDATE*事务同样在`db_session`的范围内，因此覆盖后自动刷新记录（s）。
- en: 'On the other hand, `delete_member()` of the repository class shows the same
    approach with *UPDATE*, except that a `delete()` class method is invoked right
    after retrieving the object record. The following is the script for this operation:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，存储库类的`delete_member()`方法展示了与*UPDATE*相同的方法，只是在检索对象记录后立即调用`delete()`类方法。以下是这个操作的脚本：
- en: '[PRE54]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The delete transaction is also `db_session` bound, so invoking `delete()` automatically
    refreshes the table. The following code shows Pony’s implementation for query
    transactions:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 删除事务也是 `db_session` 绑定的，因此调用 `delete()` 会自动刷新表。以下代码展示了 Pony 对查询事务的实现：
- en: '[PRE55]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '`get_member()` retrieves a single record using the `get()` class method, which
    requires a `lambda` expression in its parameter. Since `Login` has a one-to-one
    relationship with `Profile_Members`, first, we must extract the `Login` record
    of the member and use the `login` object to fetch the record through the `get()`
    helper function of the `Profile_Members` entity. This approach is also applicable
    to other entities with other entity relationships. Now, `get_all_member()` retrieves
    a result set using the `select()` method. The `select()` method can also utilize
    a lambda expression if there are constraints in the retrieval operation.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_member()` 方法使用 `get()` 类方法检索单个记录，该方法在其参数中需要一个 `lambda` 表达式。由于 `Login`
    与 `Profile_Members` 之间存在一对一关系，首先，我们必须提取成员的 `Login` 记录，并使用 `login` 对象通过 `Profile_Members`
    实体的 `get()` 辅助函数获取记录。这种方法也适用于具有其他实体关系的其他实体。现在，`get_all_member()` 方法使用 `select()`
    方法检索结果集。如果检索操作中有约束条件，`select()` 方法也可以使用 `lambda` 表达式。'
- en: 'Pony model classes have the `get()` and `select()` methods, which both return
    `Query` objects that FastAPI cannot process directly. So, we need an ORM-friendly
    `Pydantic` model to extract the final entities from these `Query` objects. Like
    in SQLAlchemy, a `ModelBase` class with a nested `Config` class is required to
    retrieve the records from the `Query` object. The nested class must configure
    `orm_mode` to `True`. If relationship mappings are involved, the request model
    must also declare the attributes involved in the relationship and their corresponding
    child object converters. The method converters, decorated by Pydantic’s `@validator`,
    are automatically called by Pony to interpret and validate the `Query` objects
    into JSON-able components such as `List` or entity objects. The following code
    shows the request model that’s used to extract the records from `select()` through
    list comprehension and the `Profile_Member dict` object from `get()`:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: Pony 模型类具有 `get()` 和 `select()` 方法，这两个方法都返回 FastAPI 无法直接处理的 `Query` 对象。因此，我们需要一个
    ORM 友好的 `Pydantic` 模型来从这些 `Query` 对象中提取最终实体。类似于 SQLAlchemy，需要一个具有嵌套 `Config` 类的
    `ModelBase` 类来从 `Query` 对象中检索记录。嵌套类必须配置 `orm_mode` 为 `True`。如果涉及关系映射，请求模型还必须声明涉及关系的属性及其对应的子对象转换器。方法转换器，由
    Pydantic 的 `@validator` 装饰，将被 Pony 自动调用以解释和验证 `Query` 对象为可 JSON 化的组件，如 `List`
    或实体对象。以下代码展示了用于通过列表推导和 `Profile_Member dict` 对象从 `get()` 中提取记录的请求模型：
- en: '[PRE56]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The presence of the `gclass_set_to_list ()` and `trainer_object_to_map()` converts
    in `ProfileMembersReq` enables data to be populated to the child objects in the
    `gclass` and `trainer_id` attributes, respectively. These additional features
    indicate why executing `select()` can already retrieve the *INNER JOIN* queries.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProfileMembersReq` 中的 `gclass_set_to_list ()` 和 `trainer_object_to_map()`
    转换的存在使得数据可以填充到 `gclass` 和 `trainer_id` 属性的子对象中，分别。这些附加功能表明为什么执行 `select()` 已经可以检索
    *INNER JOIN* 查询。'
- en: 'To build *LEFT JOIN* query transactions, the ORM has a built-in directive called
    `left_join()`, which is used to extract the `Query` object bearing the *LEFT JOIN*
    raw objects through a Python generator. The following code shows another repository
    class that showcases the use of `left_join()`:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建 *LEFT JOIN* 查询事务，ORM 有一个内置指令称为 `left_join()`，它通过 Python 生成器提取带有 *LEFT JOIN*
    原始对象的 `Query` 对象。以下代码展示了另一个存储库类，展示了 `left_join()` 的使用：
- en: '[PRE57]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: All the repository classes can be found in the `/repository/pony/members.py`
    script file.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 所有存储库类都可以在 `/repository/pony/members.py` 脚本文件中找到。
- en: Now, what makes Pony faster is that it uses an *identity map*, which contains
    all the record objects that have been retrieved from every single query transaction.
    The ORM applies the *Identity Map* design pattern to apply its caching mechanism
    to make read and write executions fast. It only requires memory management and
    monitoring to avoid memory leak problems in complex and huge applications.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使 Pony 更快的是它使用了一个 *身份映射*，其中包含从每个查询事务中检索到的所有记录对象。ORM 应用 *身份映射* 设计模式来应用其缓存机制，以使读写执行快速。它只需要内存管理和监控，以避免在复杂和大型应用程序中发生内存泄漏问题。
- en: Running the repository transactions
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行存储库事务
- en: Since `db_session` is already managed internally, no additional requirements
    will be needed from Pony for the `APIRouter` script to run the repository transactions.
    The repository classes are directly accessed and instantiated in each of the APIs
    to access the CRUD transactions.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`db_session`已经由内部管理，因此对于`APIRouter`脚本来运行存储库事务，Pony不需要额外的要求。存储库类直接在每个API中访问和实例化，以访问CRUD事务。
- en: Creating the tables
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建表格
- en: If the tables are non-existent yet, Pony can generate those tables through its
    entity classes. This DDL transaction is enabled when the `create_tables` parameter
    of the `generate_mapping()` method of `db` is set to `True`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如果表格尚不存在，Pony可以通过其实体类生成这些表格。当`db`的`generate_mapping()`方法的`create_tables`参数设置为`True`时，此DDL事务被启用。
- en: For the most compact and simplest ORM in terms of syntax, we have **Peewee**.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在语法方面，最紧凑和最简单的ORM是**Peewee**。
- en: Building the repository using Peewee
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Peewee构建存储库
- en: Among the different ORMs, Peewee is the simplest and smallest in terms of ORM
    features and APIs. The framework is easy to understand and use; it is not comprehensive,
    but it has intuitive ORM syntax. Its strength is in building and executing query
    transactions.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同的ORM中，Peewee在ORM功能和API方面是最简单和最小的。该框架易于理解和使用；它不是全面的，但它具有直观的ORM语法。其优势在于构建和执行查询事务。
- en: 'Peewee is not designed for asynchronous platforms, but it can work with them
    by using some async-related libraries that it supports. We need to install at
    least *Python 3.7* for Peewee to work with FastAPI, an asynchronous framework.
    To install Peewee, we need to execute the following command:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: Peewee不是为异步平台设计的，但它可以通过使用它支持的某些与异步相关的库与它们一起工作。为了使Peewee与异步框架FastAPI一起工作，我们需要至少安装*Python
    3.7*。要安装Peewee，我们需要执行以下命令：
- en: '[PRE58]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Installing the database driver
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装数据库驱动程序
- en: 'The ORM needs `psycopg2` as the PostgreSQL database driver. We can install
    it using `pip`:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: ORM需要`psycopg2`作为PostgreSQL数据库驱动程序。我们可以使用`pip`来安装它：
- en: '[PRE59]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Creating the database connection
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建数据库连接
- en: 'For Peewee to work with FastAPI, we must build a multi-threading mechanism
    where Peewee can cater to more than one request transaction on the same thread,
    and per request can do more executions simultaneously using different local threads.
    This customized multi-threading component, which can be created using the `ContextVar`
    class, bridges Peewee to the FastAPI platform. But for Peewee to utilize these
    threads, we also need to customize its `_ConnectionState` with the newly created
    threading state, `db_state`. The following code shows how `db_state` and a custom
    `_ConnectionState` can be derived:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使Peewee与FastAPI一起工作，我们必须构建一个多线程机制，其中Peewee可以在同一线程上处理多个请求事务，并且每个请求可以使用不同的本地线程同时执行更多操作。这个定制的多线程组件，可以使用`ContextVar`类创建，将Peewee连接到FastAPI平台。但是，为了使Peewee利用这些线程，我们还需要自定义其`_ConnectionState`，使用新创建的线程状态`db_state`。以下代码显示了如何从`db_state`和自定义的`_ConnectionState`派生出：
- en: '[PRE60]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'To apply the new `db_state` and `_ConnectionState` classes, cited in the preceding
    code as `PeeweeConnectionState`, we need to open the database connection through
    the `Database` class. Peewee has several variations of the `Database` class, depending
    on the type of database the application will choose to connect to. Since we will
    be using PostgreSQL, `PostgresqlDatabase` is the correct class to initialize with
    all the necessary database details. After establishing the connection, the `db`
    instance will have a `_state` attribute that will point to the `PeeweeConnectionState`
    instance. The following snippet shows how to connect to our *fitness gym* database’s
    `fcms` using the database credentials:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 为了应用前面代码中引用的新的`db_state`和`_ConnectionState`类，即`PeeweeConnectionState`，我们需要通过`Database`类打开数据库连接。Peewee有几种`Database`类的变体，具体取决于应用程序将选择连接到的数据库类型。由于我们将使用PostgreSQL，因此`PostgresqlDatabase`是初始化所有必要数据库详情的正确类。建立连接后，`db`实例将有一个指向`PeeweeConnectionState`实例的`_state`属性。以下片段显示了如何使用数据库凭证连接到我们的*健身健身房*数据库的`fcms`：
- en: '[PRE61]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The preceding code also emphasizes that the default state of the database connection
    must be replaced with a non-blocking one that can work with the FastAPI platform.
    This configuration can be found in the `/db_config/peewee_connect.py` script file.
    Let us now build Peewee's model layer.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码还强调，数据库连接的默认状态必须替换为可以与FastAPI平台一起工作的非阻塞状态。此配置可以在`/db_config/peewee_connect.py`脚本文件中找到。现在让我们构建Peewee的模型层。
- en: Creating the tables and the domain layer
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建表格和领域层
- en: 'Peewee prefers *auto-generating tables* based on its model classes, unlike
    other ORMs. Peewee recommends *reverse engineering*, where tables are created
    rather than only being mapped to existing tables. Letting the application generate
    the tables lessens the hassle of establishing relationships and primary keys.
    This ORM is unique because it has an "implied" approach to creating primary keys
    and foreign keys. The following script shows how Peewee model classes are defined:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: Peewee 与其他 ORM 不同，它更喜欢根据其模型类自动生成表。Peewee 推荐进行 *逆向工程*，即创建表而不是仅将它们映射到现有表。让应用程序生成表可以减少建立关系和主键的麻烦。这个
    ORM 是独特的，因为它有一种“隐含”的方法来创建主键和外键。以下脚本显示了 Peewee 模型类的定义：
- en: '[PRE62]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: We can’t see any primary keys in the model classes presented because the Peewee
    engine will create them during its schema auto-generation. The physical foreign
    key column and the model attribute will have the same name derived from its model
    name, with the `modelname_id` pattern in lowercase form. If we insist on adding
    the primary key for the model, a conflict will occur, making Peewee dysfunctional.
    We must let Peewee create the physical tables from the model classes to avoid
    this mishap.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在模型类中看不到任何主键，因为 Peewee 引擎将在其模式自动生成期间创建它们。物理外键列和模型属性将具有与模型名称相同的名称，以小写形式采用 `modelname_id`
    模式。如果我们坚持为模型添加主键，将发生冲突，使 Peewee 无法正常工作。我们必须让 Peewee 从模型类创建物理表以避免这种错误。
- en: All model classes inherit properties from the `Model` directive of the ORM.
    It also has column directives such as `IntegerField`, `FloatField`, `DateField`,
    and `TimeField` for defining the column attributes of the model classes. Moreover,
    each domain class has a nested `Meta` class, which registers the references to
    `database` and `db_table`, which is mapped to the model class. Other properties
    that we can set here are `primary_key`, `indexes`, and `constraints`.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 所有模型类都从 ORM 的 `Model` 指令继承属性。它还具有如 `IntegerField`、`FloatField`、`DateField` 和
    `TimeField` 等列指令，用于定义模型类的列属性。此外，每个域类都有一个嵌套的 `Meta` 类，它注册了对 `database` 和 `db_table`
    的引用，它们映射到模型类。我们还可以在此设置的其他属性包括 `primary_key`、`indexes` 和 `constraints`。
- en: 'The only problem in having this auto-generation is when creating table relationships.
    Linking the foreign key attributes of the child classes to the non-existent primary
    keys of the parent classes is difficult before auto-generation. For instance,
    the following `Profile_Trainers` model implies a *many-to-one* relationship with
    the `Login` class, which is only defined by the `ForeignKeyField` directive with
    the `trainer` backreference attribute and not by the `login_id` foreign key:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在自动生成中唯一的问题是创建表关系。在自动生成之前，将子类的外键属性链接到父类不存在的主键是困难的。例如，以下 `Profile_Trainers` 模型暗示了与
    `Login` 类的 *多对一* 关系，这仅由 `ForeignKeyField` 指令的 `trainer` 反向引用属性定义，而不是由 `login_id`
    外键定义：
- en: '[PRE63]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The `login_id` column that’s generated after auto-generation can be seen in
    the following screenshot:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成后生成的 `login_id` 列可以在以下屏幕截图中看到：
- en: '![Figure 5.2 – The generated profile_trainers schema'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.2 – 生成的 profile_trainers 模式'
- en: '](img/Figure_5.2_B17975.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.2 – 生成的 profile_trainers 模式](img/Figure_5.2_B17975.jpg)'
- en: Figure 5.2 – The generated profile_trainers schema
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – 生成的 profile_trainers 模式
- en: 'Foreign key attributes are declared using the `ForeignKeyField` directive,
    which accepts at least three crucial parameters:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ForeignKeyField` 指令声明外键属性，它接受至少三个关键参数：
- en: The parent model’s name
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 父模型名称
- en: The `backref` parameter, which references the child record (if in a *one-to-one*
    relationship) or a set of child objects (if in a *one-to-many* or *many-to-one*
    relationship)
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`backref` 参数，它引用子记录（如果在 *一对一* 关系中）或一组子对象（如果在 *一对多* 或 *多对一* 关系中）'
- en: The `unique` parameter, which indicates a *one-to-one* relationship when set
    to `True` or `False` otherwise
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unique` 参数，当设置为 `True` 时表示 *一对一* 关系，否则为 `False`'
- en: 'After defining all the models, including their relationships, we need to call
    the following methods from Peewee’s `db` instance for the table mapping to occur:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了所有模型，包括它们的关系后，我们需要从 Peewee 的 `db` 实例调用以下方法以进行表映射：
- en: '`connect()` to establish the connection'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `connect()` 建立连接
- en: '`create_tables()` to pursue the schema generation based on its list of model
    classes'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `create_tables()` 来根据其模型类列表进行模式生成
- en: 'The following script shows a snapshot of the class definitions, including the
    call to the two `db` methods:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 以下脚本显示了类定义的快照，包括调用两个 `db` 方法：
- en: '[PRE64]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: As we can see, we need to set the `safe` parameter of `create_tables()` to `True`
    so that Peewee will only perform schema auto-generation once during the initial
    server startup of the application. All the model classes for the Peewee ORM can
    be found in the `/models/data/peewee_models.py` script file. Now, let us implement
    the repository layer.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们需要将 `create_tables()` 的 `safe` 参数设置为 `True`，这样 Peewee 就会在应用程序的初始服务器启动期间只执行一次模式自动生成。所有
    Peewee ORM 的模型类都可以在 `/models/data/peewee_models.py` 脚本文件中找到。现在，让我们实现仓库层。
- en: Implementing the CRUD transactions
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现CRUD事务
- en: 'Creating the asynchronous connection and building the model layer for the application
    in the Peewee ORM is tricky, but implementing its repository layer is straightforward.
    All the method operations are entirely derived from its model classes. For instance,
    `insert_login()`, which is shown in the following snippet, shows how the `create()`
    static method of `Login` takes the login details for record insertion:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Peewee ORM 中为应用程序创建异步连接并构建模型层是棘手的，但实现其仓库层是直接的。所有方法操作完全源自其模型类。例如，以下代码片段中显示的
    `insert_login()` 方法展示了 `Login` 的 `create()` 静态方法如何接受记录插入的登录详情：
- en: '[PRE65]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This method can be re-implemented to perform bulk inserts, but Peewee has an
    alternative way to pursue multiple insertions through its `insert_many()` class
    method. Using `insert_many()` requires more accurate column details for mapping
    multiple schema values. It also needs an invocation of the `execute()` method
    to perform all the bulk insertions and close the operation afterward.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法可以被重新实现以执行批量插入，但 Peewee 有另一种通过其 `insert_many()` 类方法追求多个插入的方法。使用 `insert_many()`
    需要更精确的列细节来映射多个模式值。它还需要调用 `execute()` 方法来执行所有批量插入并在之后关闭操作。
- en: 'Similarly, the `update()` class method requires the `execute()` method after
    filtering the record that needs updating using the `id` primary key. This is shown
    in the following code snippet:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`update()` 类方法在通过 `id` 主键过滤需要更新的记录后需要调用 `execute()` 方法。以下代码片段展示了这一点：
- en: '[PRE66]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'When it comes to record deletion, `delete_login()` shows the easy approach
    – that is, by using `delete_by_id()`. But the ORM has another way, which is to
    retrieve the record object using the `get()` class method – for example, `Login.get(Login.id
    == id)` – and eventually delete the record through the `delete_instance()` instance
    method of the record object. The following `delete_login()` transaction shows
    how to utilize the `delete_by_id()` class method:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到记录删除时，`delete_login()` 展示了简单的方法——即通过使用 `delete_by_id()`。但 ORM 有另一种方法，即使用
    `get()` 类方法检索记录对象——例如，`Login.get(Login.id == id)`——然后通过记录对象的 `delete_instance()`
    实例方法最终删除记录。以下 `delete_login()` 事务展示了如何利用 `delete_by_id()` 类方法：
- en: '[PRE67]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The following scripts, which are for `get_all_login()` and `get_login()`, highlight
    how Peewee retrieves records from the database. Peewee uses its `get()` class
    method to retrieve a single record using the primary key; the same method was
    applied to its *UPDATE* transaction in the previous code snippet. Similarly, Peewee
    uses a class method to extract multiple records, but this time, it uses the `select()`
    method. The resulting object can’t be encoded by FastAPI unless it’s contained
    in the `List` collection, which serializes the rows of data into a list of JSON-able
    objects:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 以下脚本，针对 `get_all_login()` 和 `get_login()`，突出了 Peewee 如何从数据库中检索记录。Peewee 使用其
    `get()` 类方法通过主键检索单个记录；在之前的代码片段中，同样的方法被应用于其 *UPDATE* 事务。同样，Peewee 使用类方法提取多个记录，但这次它使用的是
    `select()` 方法。结果对象不能被 FastAPI 编码，除非它包含在 `List` 集合中，该集合将数据行序列化为可序列化为 JSON 的对象列表：
- en: '[PRE68]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'On the other hand, the following repository classes show how to create *JOIN*
    queries using its `join()` method:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，以下仓库类展示了如何使用其 `join()` 方法创建 *JOIN* 查询：
- en: '[PRE69]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '`join_login_trainers()` of `LoginTrainersRepository` builds the *INNER JOIN*
    query of the `Profile_Trainers` and `Login` objects. The leftmost model indicated
    in the parameter of the `Profile_Trainers` object’s `select()` directive is the
    parent model type, followed by its child model class in a *one-to-one* relationship.
    The `select()` directive emits the `join()` method with the model class type,
    which indicates the type of records that belong to the right-hand side of the
    query. The *ON* condition(s) and the foreign key constraints are optional but
    can be declared explicitly by adding the `on` and `join_type` attributes of the
    `join()` construct. An example of this query is `outer_join_member_gym()` of `MemberGymClassesRepository`,
    which implements a *LEFT OUTER JOIN* of `Profile_Members` and `Gym_Class` using
    the `LEFT_OUTER` option of the `join_type` attribute of `join()`.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoginTrainersRepository` 的 `join_login_trainers()` 方法构建了 `Profile_Trainers`
    和 `Login` 对象的 *INNER JOIN* 查询。在 `Profile_Trainers` 对象的 `select()` 指令中指定的最左侧模型是父模型类型，其后是其一对一关系中的子模型类。`select()`
    指令发出带有模型类类型的 `join()` 方法，这表示属于查询右侧的记录类型。*ON* 条件和外键约束是可选的，但可以通过添加 `join()` 构造的
    `on` 和 `join_type` 属性来显式声明。此查询的一个示例是 `MemberGymClassesRepository` 的 `outer_join_member_gym()`，它使用
    `join_type` 属性的 `LEFT_OUTER` 选项实现了 `Profile_Members` 和 `Gym_Class` 的 *LEFT OUTER
    JOIN*。'
- en: Joins in Peewee also need the `list()` collection to serialize the retrieved
    records. All the repository classes for Peewee can be found in the `/repository/peewee/login.py`
    script.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Peewee 中进行连接操作也需要使用 `list()` 集合来序列化检索到的记录。所有 Peewee 的存储库类都可以在 `/repository/peewee/login.py`
    脚本中找到。
- en: Running the CRUD transaction
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行 CRUD 事务
- en: Since Peewee’s database connection is set at the model layer, no additional
    requirements are required for `APIRouter` or `FastAPI` to run the CRUD transactions.
    API services can easily access all the repository classes without calling methods
    or directives from the `db` instance.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Peewee 的数据库连接是在模型层设置的，因此 `APIRouter` 或 `FastAPI` 运行 CRUD 事务时不需要额外的要求。API
    服务可以轻松访问所有存储库类，而无需从 `db` 实例调用方法或指令。
- en: So far, we have experimented with popular ORMs to integrate a relational database
    into the FastAPI framework. If applying an ORM is not enough for a microservice
    architecture, we can utilize some design patterns that can further refine the
    CRUD performance, such as **CQRS**.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经尝试了流行的 ORM 来将关系数据库集成到 FastAPI 框架中。如果应用 ORM 对于微服务架构来说不够用，我们可以利用一些可以进一步优化
    CRUD 性能的设计模式，例如 **CQRS**。
- en: Applying the CQRS design pattern
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用 CQRS 设计模式
- en: CQRS is a microservice design pattern responsible for segregating query transactions
    (*reads*) from the insert, update, and delete operations (*writes*). The separation
    of these two groups lessens the cohesion access to these transactions, which provides
    less traffic and faster performance, especially when the application becomes complex.
    Moreover, this design pattern creates a loose-coupling feature between the API
    services and the repository layer, which gives us an advantage if there are several
    turnovers and changes in the repository layers.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: CQRS 是一种微服务设计模式，负责将查询事务（*读取*）与插入、更新和删除操作（*写入*）分离。这两个组的分离减少了对这些事务的访问耦合度，从而提供了更少的流量和更快的性能，尤其是在应用程序变得复杂时。此外，此设计模式在
    API 服务和存储库层之间创建了一个松散耦合的特性，如果存储库层有多个轮换和变更，这将给我们带来优势。
- en: Defining the handler interfaces
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义处理程序接口
- en: 'To pursue CQRS, we need to create the two interfaces that define the query
    and the command transactions. The following code shows the interfaces that will
    identify the *read* and *write* transactions for `Profile_Trainers`:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现 CQRS，我们需要创建定义查询和命令事务的两个接口。以下代码显示了将识别 `Profile_Trainers` 的 *读取* 和 *写入* 事务的接口：
- en: '[PRE70]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Here, `IQueryHandler` and `ICommandHandler` are informal interfaces because
    Python does not have an actual definition of an interface.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`IQueryHandler` 和 `ICommandHandler` 是非正式接口，因为 Python 没有实际的接口定义。
- en: Creating the command and query classes
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建命令和查询类
- en: 'Next, we need to implement the command and query classes. The command serves
    as an instruction to pursue the *write* transactions. It also carries the state
    of the result after they have been executed. On the other hand, the query instructs
    the *read* transaction to retrieve record(s) from the database and contain the
    result afterward. Both components are serializable classes with *getter/setter*
    attributes. The following code shows the script for `ProfileTrainerCommand`, which
    uses Python’s `@property` attribute to store the state of the *INSERT* execution:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要实现命令和查询类。命令作为执行*写入*事务的指令。它还携带执行后的结果状态。另一方面，查询指示*读取*事务从数据库检索记录并在之后包含结果。这两个组件都是具有*getter/setter*属性的序列化类。以下代码展示了`ProfileTrainerCommand`的脚本，它使用Python的`@property`属性来存储*INSERT*执行的状
    态：
- en: '[PRE71]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The `details` property will store all the column values of the trainer’s profile
    record that need to be persisted.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '`details`属性将存储需要持久化的训练员资料记录的所有列值。'
- en: 'The following script implements a sample *query* class:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 以下脚本实现了一个示例*查询*类：
- en: '[PRE72]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The constructor of `ProfileTrainerListQuery` prepares a dictionary object that
    will contain all the retrieved records after the query transaction has been executed.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProfileTrainerListQuery`的构造函数准备了一个字典对象，该对象将在查询事务执行后包含所有检索到的记录。'
- en: Creating the command and query handlers
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建命令和查询处理程序
- en: 'We will be using our previous interfaces to define the command and query handlers.
    Note that the command handler accesses and executes the repository to execute
    the *write* transactions, while the query handler processes the *read* transactions.
    These handlers serve as the façade between the API services and the repository
    layer. The following code shows the script for `AddTrainerCommandHandler`, which
    manages the *INSERT* transaction for the trainer’s profile:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用之前的接口来定义命令和查询处理程序。请注意，命令处理程序访问和执行存储库以执行*写入*事务，而查询处理程序处理*读取*事务。这些处理程序作为API服务和存储库层之间的外观。以下代码展示了`AddTrainerCommandHandler`的脚本，它管理训练员资料的*INSERT*事务：
- en: '[PRE73]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The handler depends on `ProfileTrainerCommand` for the record values that are
    crucial to the asynchronous execution of its `handle()` method.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 处理程序依赖于`ProfileTrainerCommand`来获取对异步执行其`handle()`方法至关重要的记录值。
- en: 'The following script shows a sample implementation for a query handler:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 以下脚本展示了查询处理程序的示例实现：
- en: '[PRE74]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Query handlers return their *query* to the services and not the actual values.
    The `handle()` method of `ListTrainerQueryHandler` returns `ProfileTrainerListQuery`,
    which contains the list of records from the *read* transaction. This mechanism
    is one of the main objectives of applying CQRS to microservices.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 查询处理程序将它们的*查询*返回给服务，而不是实际的值。`ListTrainerQueryHandler`的`handle()`方法返回`ProfileTrainerListQuery`，其中包含从*读取*事务中检索到的记录列表。这种机制是应用CQRS到微服务的主要目标之一。
- en: Accessing the handlers
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问处理程序
- en: CQRS, aside from managing the friction between the *read* and *write* executions,
    does not allow the API services to interact directly with the execution of CRUD
    transactions. Moreover, it streamlines and simplifies the access of the CRUD transactions
    by assigning only the handler that’s needed by a particular service.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: CQRS（Command Query Responsibility Segregation）除了管理*读取*和*写入*执行之间的摩擦外，不允许API服务直接与CRUD事务的执行进行交互。此外，它通过仅分配特定服务所需的处理程序来简化并简化CRUD事务的访问。
- en: 'The following script shows how `AddTrainerCommand` is only directly associated
    with the `add_trainer()` service and how `LisTrainerQueryHandler` is only directly
    associated with the `list_trainers()` service:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 以下脚本展示了`AddTrainerCommand`如何仅直接关联到`add_trainer()`服务，以及`LisTrainerQueryHandler`如何仅直接关联到`list_trainers()`服务：
- en: '[PRE75]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: We can identify transactions that are accessed frequently in `APIRouter` through
    CQRS. It helps us find which transactions need performance tuning and focus, which
    can help us avoid performance issues when the amount of access increases. When
    it comes to enhancement and upgrades, the design pattern can help developers find
    what domain to prioritize because of the separation of aspects in the repository
    layer. Generally, it offers flexibility to the application when its business processes
    need to be revamped. All the CQRS-related scripts can be found in the `/cqrs/`
    project folder.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过CQRS在`APIRouter`中识别出频繁访问的事务。这有助于我们找到哪些事务需要性能调整和关注，这可以帮助我们在访问量增加时避免性能问题。当涉及到增强和升级时，设计模式可以帮助开发者找到优先考虑的领域，因为仓库层中的方面是分离的。通常，当业务流程需要重整时，它为应用程序提供了灵活性。所有与CQRS相关的脚本都可以在`/cqrs/`项目文件夹中找到。
- en: Summary
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Applying ORM always has advantages and disadvantages for any application. It
    can bloat the application with so many configurations and layers of components,
    and it can even slow down the application if not managed well. But ORM, in general,
    can help optimize query development by simplifying the constructs by using its
    APIs and eliminating unimportant repetitive SQL scripts. Overall, it can reduce
    the time and cost of software development compared to using `cursor` from `psycopg2`.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何应用程序，应用ORM总是有利有弊。它可能会因为过多的配置和组件层而使应用程序膨胀，如果管理不当，甚至可能减慢应用程序的速度。但总的来说，ORM可以通过使用其API简化结构，消除不重要的重复SQL脚本，帮助优化查询开发。与使用`psycopg2`的`cursor`相比，ORM可以减少软件开发的时间和成本。
- en: In this chapter, four Python ORMs were used, studied, and experimented with
    to help FastAPI create its repository layer. First, there is *SQLAlchemy*, which
    provides a boilerplated approach to creating standard and asynchronous data persistency
    and query operations. Then, there is *GINO*, which uses the AsyncIO environment
    to implement asynchronous CRUD transactions with its handy syntax. Also, there
    is *Pony*, the most Pythonic among the ORMs presented because it uses hardcore
    Python code to build its repository transactions. Lastly, there is *Peewee*, known
    for its concise syntax but tricky composition for the asynchronous database connection
    and CRUD transactions. Each ORM has its strengths and weaknesses, but all provide
    a logical solution rather than applying brute-force and native SQL.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，使用了四个Python ORM进行研究和实验，以帮助FastAPI创建其仓库层。首先，是*SQLAlchemy*，它提供了一种创建标准异步数据持久性和查询操作的模板化方法。然后是*GINO*，它使用AsyncIO环境通过其便捷的语法实现异步CRUD事务。还有*Pony*，它是所展示ORM中最Pythonic的，因为它使用纯Python代码构建其仓库事务。最后是*Peewee*，以其简洁的语法而闻名，但在异步数据库连接和CRUD事务的复杂组合方面较为棘手。每个ORM都有其优势和劣势，但所有ORM都提供了一个逻辑解决方案，而不是应用蛮力和原生SQL。
- en: If the ORM needs fine-tuning, we can add some degree of optimization by using
    data-related design patterns such as CQRS, which minimizes friction between the
    "read" and "write" CRUD transactions.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 如果ORM需要微调，我们可以通过使用与数据相关的模式，如CQRS，来添加一些优化程度，这有助于最小化“读取”和“写入”CRUD事务之间的摩擦。
- en: This chapter has highlighted the flexibility of FastAPI when utilizing ORMs
    to establish a connection to a relational database such as PostgreSQL. But what
    if we use a NoSQL database such as MongoDB to store information? Will FastAPI
    perform with the same level of performance when performing CRUD to and from MongoDB?
    The next chapter will discuss various solutions for integrating FastAPI into MongoDB.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 本章强调了FastAPI在利用ORM连接到关系型数据库（如PostgreSQL）时的灵活性。但如果我们使用如MongoDB这样的NoSQL数据库来存储信息呢？FastAPI在执行对MongoDB的CRUD操作时，性能是否会保持相同水平？下一章将讨论将FastAPI集成到MongoDB的各种解决方案。
