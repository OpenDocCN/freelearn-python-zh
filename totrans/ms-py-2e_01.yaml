- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Getting Started – One Environment per Project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you’ll learn about the different ways of setting up Python
    environments for your projects and how to use multiple Python versions on a single
    system outside of what your package manager offers.
  prefs: []
  type: TYPE_NORMAL
- en: After the environment is set up, we will continue with the installation of packages
    using both the **Python Package Index** (**PyPI**) and `conda-forge`, the package
    index that is coupled with Anaconda.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we will look at several methods of keeping track of project dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize, the following topics will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating environments using `venv`, `pipenv`, `poetry`, `pyenv`, and `anaconda`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Package installation through `pip`, `poetry`, `pipenv`, and `conda`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing dependencies using `requirements.txt`, `poetry`, and `pipenv`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Virtual environments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Python ecosystem offers many methods of installing and managing packages.
    You can simply download and extract code to your project directory, use the package
    manager from your operating system, or use a tool such as `pip` to install a package.
    To make sure your packages don’t collide, it is recommended that you use a virtual
    environment. A virtual environment is a lightweight Python installation with its
    own package directories and a Python binary copied (or linked) from the binary
    used to create the environment.
  prefs: []
  type: TYPE_NORMAL
- en: Why virtual environments are a good idea
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It might seem like a hassle to create a virtual environment for every Python
    project, but it offers enough advantages to do so. More importantly, there are
    several reasons why installing packages globally using `pip` is a really bad idea:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing packages globally usually requires elevated privileges (such as `sudo`,
    `root`, or `administrator`), which is a huge security risk. When executing `pip
    install <package>`, the `setup.py` of that package is executed as the user that
    executed the `pip install` command. That means that if the package contains malware,
    it now has superuser privileges to do whatever it wants. Don’t forget that anyone
    can upload a package to PyPI ([pypi.org](http://pypi.org)) without any vetting.
    As you will see later in this book, it only takes a couple of minutes for anyone
    to create and upload a package.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Depending on how you installed Python, it can mess with the existing packages
    that are installed by your package manager. On an Ubuntu Linux system, that means
    you could break `pip` or even `apt` itself because a `pip install -U <package>`
    installs and updates both the package and all of the dependencies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can break your other projects. Many projects try their best to remain backward
    compatible, but every `pip install` could pull in new/updated dependencies that
    could break compatibility with other packages and projects. The Django Web Framework,
    for example, changes enough between versions that many projects using Django will
    need several changes after an upgrade to the latest release. So, when you’re upgrading
    Django on your system to the latest version and have a project that was written
    for a previous version, your project will most likely be broken.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It pollutes your list of packages, making it hard to keep track of your project’s
    dependencies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to alleviating the issues above, there is a major advantage as well.
    You can specify the Python version (assuming you have it installed) when creating
    the virtual environment. This allows you to test and debug your projects in multiple
    Python versions easily while keeping the exact same package versions beyond that.
  prefs: []
  type: TYPE_NORMAL
- en: Using venv and virtualenv
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You are probably already familiar with `virtualenv`, a library used to create
    a virtual environment for your Python installation. What you might not know is
    the `venv` command, which has been included with Python since version 3.3 and
    can be used as a drop-in replacement for `virtualenv` in most cases. To keep things
    simple, I recommend creating a directory where you keep all of your environments.
    Some people opt for an `env`, .`venv`, or `venv` directory within the project,
    but I advise against that for several reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Your project files are important, so you probably want to back them up as often
    as possible. By keeping the bulky environment with all of the installed packages
    outside of your backups, your backups become faster and lighter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your project directory stays portable. You can even keep it on a remote drive
    or flash drive without having to worry that the virtual environment will only
    work on a single system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It prevents you from accidentally adding the virtual environment files to your
    source control system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you do decide to keep your virtual environment inside your project directory,
    make sure that you add that directory to your `.gitignore` file (or similar) for
    your version control system. And if you want to keep your backups faster and lighter,
    exclude it from the backups. With correct dependency tracking, the virtual environment
    should be easy enough to rebuild.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a venv
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Creating a `venv` is a reasonably simple process, but it varies slightly according
    to the operating system being used.
  prefs: []
  type: TYPE_NORMAL
- en: The following examples use the `virtualenv` module directly, but for ease I
    recommend using `poetry` instead, which is covered later in this chapter. This
    module will automatically create a virtual environment for you when you first
    use it. Before you make the step up to `poetry`, however, it is important to understand
    how virtual environments work.
  prefs: []
  type: TYPE_NORMAL
- en: Since Python 3.6, the `pyvenv` command has been deprecated in favor of `python
    -m venv`.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of Ubuntu, the `python3-venv` package has to be installed through
    `apt` because the Ubuntu developers have mutilated the default Python installation
    by not including `ensurepip`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Linux/Unix/OS X, using `zsh` or `bash` as a shell, it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'And for Windows `cmd.exe` (assuming `python.exe` is in your `PATH`), it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'PowerShell is also supported and can be used in a similar fashion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The first command creates the environment and the second activates the environment.
    After activating the environment, commands such as `python` and `pip` use the
    environment-specific versions, so `pip` `install` only installs within your virtual
    environment. A useful side effect of activating the environment is the prefix
    with the name of your environment, which is `(your_env)` in this case.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we are **not** using `sudo` or other methods of elevating privileges.
    Elevating privileges is both unnecessary and a potential security risk, as explained
    in the *Why virtual environments are a good idea* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `virtualenv` instead of `venv` is as simple as replacing the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'with this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'An additional advantage of using `virtualenv` instead of `venv`, in that case,
    is that you can specify the Python interpreter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Whereas with the `venv` command, it uses the currently running Python installation,
    so you need to change it through the following invocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Activating a venv/virtualenv
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Every time you get back to your project after closing the shell, you need to
    reactivate the environment. The activation of a virtual environment consists of:'
  prefs: []
  type: TYPE_NORMAL
- en: Modifying your `PATH` environment variable to use `envs\your_env\Script` or
    `envs/your_env/bin` for Windows or Linux/Unix, respectively
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifying your prompt so that instead of `$`, you see `(your_env) $`, indicating
    that you are working in a virtual environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the case of `poetry`, you can use the `poetry shell` command to create a
    new shell with the activated environment.
  prefs: []
  type: TYPE_NORMAL
- en: While you can easily modify those manually, an easier method is to run the `activate`
    script that was generated when creating the virtual environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Linux/Unix with `zsh` or `bash` as the shell, it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'For Windows using `cmd.exe`, it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'For Windows using PowerShell, it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, the PowerShell permissions might be too restrictive to allow this.
    You can change this policy for the current PowerShell session by executing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If you wish to permanently change it for every PowerShell session for the current
    user, execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Different shells, such as `fish` and `csh`, are also supported by using the
    `activate.fish` and `activate.csh` scripts, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'When not using an interactive shell (with a cron job, for example), you can
    still use the environment by using the Python interpreter in the `bin` or `scripts`
    directory for Linux/Unix or Windows, respectively. Instead of running `python
    script.py` or `/usr/bin/python script.py`, you can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that commands installed through `pip` (and `pip` itself) can be run in
    a similar fashion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Installing packages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Installing packages within your virtual environment can be done using `pip`
    as normal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The great advantage comes when looking at the list of installed packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Because our environment is isolated from the system, we only see the packages
    and dependencies that we have explicitly installed.
  prefs: []
  type: TYPE_NORMAL
- en: Fully isolating the virtual environment from the system Python packages can
    be a downside in some cases. It takes up more disk space and the package might
    not be in sync with the C/C++ libraries on the system. The PostgreSQL database
    server, for example, is often used together with the `psycopg2` package. While
    binaries are available for most platforms and building the package from the source
    is fairly easy, it can sometimes be more convenient to use the package that is
    bundled with your system. That way, you are certain that the package is compatible
    with both the installed Python and PostgreSQL versions.
  prefs: []
  type: TYPE_NORMAL
- en: 'To mix your virtual environment with system packages, you can use the `--system-site-packages`
    flag when creating the environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: When enabling this flag, the environment will have the system Python environment
    `sys.path` appended to your virtual environment’s `sys.path`, effectively providing
    the system packages as a fallback when an `import` from the virtual environment
    fails.
  prefs: []
  type: TYPE_NORMAL
- en: Explicitly installing or updating a package within your virtual environment
    will effectively hide the system package from within your virtual environment.
    Uninstalling the package from your virtual environment will make it reappear.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you might suspect, this also affects the results of `pip freeze`. Luckily,
    `pip freeze` can be told to only list the packages local to the virtual environment,
    which excludes the system packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Later in this chapter, we will discuss `pipenv,` which transparently handles
    the creation of the virtual environment for you.
  prefs: []
  type: TYPE_NORMAL
- en: Using pyenv
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `pyenv` library makes it really easy to quickly install and switch between
    multiple Python versions. A common issue with many Linux and Unix systems is that
    the package managers opt for stability over recency. In most cases, this is definitely
    an advantage, but if you are running a project that requires the latest and greatest
    Python version, or a really old version, it requires you to compile and install
    it manually. The `pyenv` package makes this process really easy for you but does
    still require the compiler to be installed.
  prefs: []
  type: TYPE_NORMAL
- en: A nice addition to `pyenv` for testing purposes is the `tox` library. This library
    allows you to run your tests on a whole list of Python versions simultaneously.
    The usage of `tox` is covered in *Chapter 10,* *Testing and Logging – Preparing
    for Bugs*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install `pyenv`, I recommend visiting the `pyenv` project page, since it
    depends highly on your operating system and operating system version. For Linux/Unix,
    you can use the regular `pyenv` installation manual or the `pyenv-installer` ([https://github.com/pyenv/pyenv-installer](https://github.com/pyenv/pyenv-installer))
    one-liner, if you deem it safe enough:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Make sure that you follow the instructions given by the installer. To ensure
    `pyenv` works properly, you will need to modify your `.zshrc` or `.bashrc`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Windows does not support `pyenv` natively (outside of Windows Subsystem for
    Linux) but has a `pyenv` fork available: [https://github.com/pyenv-win/pyenv-win#installation](https://github.com/pyenv-win/pyenv-win#installation%20)'
  prefs: []
  type: TYPE_NORMAL
- en: 'After installing `pyenv`, you can view the list of supported Python versions
    using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The list is rather long, but can be shortened with `grep` on Linux/Unix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you’ve found the version you like, you can install it through the `install`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `pyenv install` command takes an optional `--debug` parameter, which builds
    a debug version of Python that makes debugging C/C++ extensions possible using
    a debugger such as `gdb`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the Python version has been built, you can activate it globally, but you
    can also use the `pyenv-virtualenv` plugin ([https://github.com/pyenv/pyenv-virtualenv](https://github.com/pyenv/pyenv-virtualenv))
    to create a `virtualenv` for your newly created Python environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'you can see in the preceding example, as opposed to the `venv` and `virtualenv`
    commands, `pyenv virtualenv` automatically creates the environment in the `~/.pyenv/versions/<version>/envs/`
    directory so you’re not allowed to fully specify your own path. You can change
    the base path (`~/.pyenv/`) through the `PYENV_ROOT` environment variable, however.
    Activating the environment using the `activate` script in the environment directory
    is still possible, but more complicated than it needs to be since there’s an easy
    shortcut:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now that the environment is activated, you can run environment-specific commands,
    such as `pip`, and they will only modify your environment.
  prefs: []
  type: TYPE_NORMAL
- en: Using Anaconda
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Anaconda is a distribution that supports both the Python and R programming languages.
    It is much more than simply a virtual environment manager, though; it’s a whole
    different Python distribution with its own virtual environment system and even
    a completely different package system. In addition to supporting PyPI, it also
    supports `conda-forge`, which features a very impressive number of packages focused
    on scientific computing.
  prefs: []
  type: TYPE_NORMAL
- en: For the end user, the most important difference is that packages are installed
    through the `conda` command instead of `pip`. This brings a much more advanced
    dependency check when installing packages. Whereas `pip` will simply install a
    package and all of its dependencies without regard for other installed packages,
    `conda` will look at all of the installed packages and make sure it won’t install
    a version that is not supported by the installed packages.
  prefs: []
  type: TYPE_NORMAL
- en: The `conda` package manager is not alone in smart dependency checking. The `pipenv`
    package manager (discussed later in this chapter) does something similar.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with Anaconda Navigator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Installing Anaconda is quite easy on all common platforms. For Windows, OS
    X, and Linux, you can go to the Anaconda site and download the (graphical) installer:
    [https://www.anaconda.com/products/distribution#Downloads](https://www.anaconda.com/products/distribution#Downloads)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once it’s installed, the easiest way to continue is by launching Anaconda Navigator,
    which should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15882_01_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.1: Anaconda Navigator – Home'
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating an environment and installing packages is pretty straightforward as
    well:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the **Environments** button on the left.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Create** button below.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter your name and Python version.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Create** to create your environment and wait a bit until Anaconda
    is done:![](img/B15882_01_02.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 1.2: Anaconda Navigator – Creating an environment'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once Anaconda has finished creating your environment, you should see a list
    of installed packages. Installing packages can be done by changing the filter
    of the package list from **Installed** to **All**, marking the checkbox near the
    packages you want to install, and applying the changes.
  prefs: []
  type: TYPE_NORMAL
- en: While creating an environment, Anaconda Navigator shows you where the environment
    will be created.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with conda
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While Anaconda Navigator is a really nice tool to use to get an overview, being
    able to run your code from the command line can be convenient too. With the `conda`
    command, that is luckily very easy.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you need to open the `conda` shell. You can do this from Anaconda Navigator
    if you wish, but you can also run it straightaway. On Windows, you can open Anaconda
    Prompt or Anaconda PowerShell Prompt from the start menu. On Linux and OS X, the
    most convenient method is to initialize the shell integration. For zsh, you can
    use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'For other shells, the process is similar. Note that this process modifies your
    shell configuration to automatically activate the `base` environment every time
    you open a shell. This can be disabled with a simple configuration option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'If automatic activation is not enabled, you will need to run the `activate`
    command to get back into the `conda base` environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If, instead of the `conda base` environment, you wish to activate the environment
    you created earlier, you need to specify the name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have not created the environment yet, you can do so using the command
    line as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'To list the available environments, you can use the `conda info` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Installing conda packages
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now it’s time to install a package. For `conda` packages, you can simply use
    the `conda install` command. For example, to install the `progressbar2` package
    that I maintain, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can run Python and see that the package has been installed and is working
    properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way to verify whether the package has been installed is by running
    the `conda` `list` command, which lists the installed packages similarly to `pip
    list`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Installing PyPI packages
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'With PyPI packages, we have two options within the Anaconda distribution. The
    most obvious is using `pip`, but this has the downside of partially circumventing
    the `conda` dependency checker. While `conda install` will take the packages installed
    through PyPI into consideration, the `pip` command might upgrade packages undesirably.
    This behavior can be improved by enabling the `conda`/`pip` interoperability setting,
    but this seriously impacts the performance of `conda` commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Depending on how important fixed versions or `conda` performance is for you,
    you can also opt for converting the package to a `conda` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have a package, we can modify the files if needed, but using the
    automatically generated files works most of the time. All that is left now is
    to build and install the package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: And now we are done! The package has been installed through `conda` instead
    of `pip`.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing your environment
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When collaborating with others, it is essential to have environments that are
    as similar as possible to avoid debugging local issues. With `pip`, we can simply
    create a requirements file by using `pip freeze`, but that will not include the
    `conda` packages. With `conda`, there’s actually an even better solution, which
    stores not only the dependencies and versions but also the installation channels,
    environment name, and environment location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Installing the packages from that environment file can be done while creating
    the environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Or they can be added to an existing environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Managing dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The simplest way of managing dependencies is storing them in a `requirements.txt`
    file. In its simplest form, this is a list of package names and nothing else.
    This file can be extended with version requirements and can even support environment-specific
    installations.
  prefs: []
  type: TYPE_NORMAL
- en: A fancier method of installing and managing your dependencies is by using a
    tool such as `poetry` or `pipenv`. Internally, these use the regular `pip` installation
    method, but they build a full dependency graph of all the packages. This makes
    sure that all package versions are compatible with each other and allows the parallel
    installation of non-dependent packages.
  prefs: []
  type: TYPE_NORMAL
- en: Using pip and a requirements.txt file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `requirements.txt` format allows you to list all of the dependencies of
    your project as broadly or as specifically as you feel is necessary. You can easily
    create this file yourself, but you can also tell `pip` to generate it for you,
    or even to generate a new file based on a previous `requirements.txt` file so
    you can view the changes. I recommend using `pip freeze` to generate an initial
    file and cherry-picking the dependencies (versions) you want.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, assuming that we run `pip freeze` in our virtual environment from
    before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'If we store that file in a `requirements.txt` file, install a package, and
    look at the difference, we get this result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `pip freeze` command automatically detected the addition
    of the `six`, `progressbar2`, and `python-utils` packages, and it immediately
    pinned those versions to the currently installed ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'The lines in the `requirements.txt` file are understood by `pip` on the command
    line as well, so to install a specific version, you can run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Version specifiers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Often, pinning a version as strictly as that is not desirable, however, so
    let’s change the requirements file to only contain what we actually care about:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'If someone else wants to install all of the requirements in this file, they
    can simply tell `pip` to include that requirement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In this case, `pip` checks to see whether all packages are installed and will
    install or update them if needed.
  prefs: []
  type: TYPE_NORMAL
- en: '`-r requirements.txt` works recursively, allowing you to include multiple requirements
    files.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s assume we’ve encountered a bug in the latest version and we wish
    to skip it. We can assume that only this specific version is affected, so we will
    only blacklist that version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we should talk about wildcards. One of the most common scenarios is
    needing a specific major version number but still wanting the latest security
    update and bug fixes. There are a few ways to specify these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: With the compatible release pattern (~=), you can select the newest version
    that is within the same major release but is at least the specified version.
  prefs: []
  type: TYPE_NORMAL
- en: 'The version identification and dependency specification standard is described
    thoroughly in PEP 440:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://peps.python.org/pep-0440/](https://peps.python.org/pep-0440/)'
  prefs: []
  type: TYPE_NORMAL
- en: Installing through source control repositories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now let’s say that we’re really unlucky and there is no working release of
    the package yet, but it has been fixed in the `develop` branch of the Git repository.
    We can install that either through `pip` or through a `requirements.txt` file,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'You may notice that `pip` not only installed the package but actually did a
    `git clone` to `your_env/src/progressbar2`. This is an optional step caused by
    the `--editable` (short option: `-e`) flag, which has the additional advantage
    that every time you re-run the command, the `git` clone will be updated. It also
    makes it rather easy to go to that directory, modify the code, and create a pull
    request with a fix.'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to Git, other source control systems such as Bazaar, Mercurial,
    and Subversion are also supported.
  prefs: []
  type: TYPE_NORMAL
- en: Additional dependencies using extras
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Many packages offer optional dependencies for specific use cases. In the case
    of the `progressbar2` library, I have added `tests` and `docs` extras to install
    the test or documentation building dependencies needed to run the tests for the
    package. Extras can be specified using square brackets separated by commas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Conditional dependencies using environment markers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If your project needs to run on multiple systems, you will most likely encounter
    dependencies that are not required on all systems. One example of this is libraries
    that are required on some operating systems but not on others. An example of this
    is the `portalocker` package I maintain; on Linux/Unix systems, the locking mechanisms
    needed are supported out of the box. On Windows, however, they require the `pywin32`
    package to work. The `install_requires` part of the package (which uses the same
    syntax as `requirements.txt`) contains this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This specifies that on Windows, the `pywin32` package is required, and version
    `226` was blacklisted due to a bug.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to `platform_system`, there are several more markers, such as `python_version`
    and `platform_machine` (contains architecture `x86_64`, for example).
  prefs: []
  type: TYPE_NORMAL
- en: 'The full list of markers can be found in PEP 496: [https://peps.python.org/pep-0496/](https://peps.python.org/pep-0496/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'One other useful example of this is the `dataclasses` library. This library
    has been included with Python since version 3.7, so we only need to install the
    backport for older Python versions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Automatic project management using poetry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `poetry` tool provides a really easy-to-use solution for creating, updating,
    and sharing your Python projects. It’s also very fast, which makes it a fantastic
    starting point for a project.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new poetry project
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Starting a new project is very easy. It will automatically handle virtual environments,
    dependencies, and other project-related tasks for you. To start, we will use the
    `poetry init` wizard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Following these few questions, it automatically creates a `pyproject.toml`
    file for us that contains all the data we entered and some automatically generated
    data. As you may have noticed, it automatically prefilled several values for us:'
  prefs: []
  type: TYPE_NORMAL
- en: The project name. This is based on the current directory name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The version. This is fixed to `0.1.0`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The author field. This looks at your `git` user information. This can be set
    using:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The Python version. This is based on the Python version you are running `poetry`
    with, but it can be customized using `poetry init --python=...`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Looking at the generated `pyproject.toml`, we can see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Adding dependencies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once we have the project up and running, we can now add dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'This automatically installs the package, adds it to the `pyproject.toml` file,
    and adds the specific version to the `poetry.lock` file. After this command, the
    `pyproject.toml` file has a new line added to the `tool.poetry.dependencies` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The `poetry.lock` file is a bit more specific. Whereas the `progressbar2` dependency
    could have a wildcard version, the `poetry.lock` file stores the exact version,
    the file hashes, and all the dependencies that were installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'By having all this data, we can build or rebuild a virtual environment for
    a `poetry`-based project on another system exactly as it was created on the original
    system. To install, upgrade, and/or downgrade the packages exactly as specified
    in the `poetry.lock` file, we need a single command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: This is very similar to how the `npm` and `yarn` commands work if you are familiar
    with those.
  prefs: []
  type: TYPE_NORMAL
- en: Upgrading dependencies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous examples, we simply added a dependency without specifying an
    explicit version. Often this is a safe approach, as the default version requirement
    will allow for any version within that major version.
  prefs: []
  type: TYPE_NORMAL
- en: If the project uses normal Python versioning or semantic versioning (more about
    that in *Chapter 18,* *Packaging - Creating Your Own Libraries or Applications*),
    that should be perfect. At the very least, all of my projects (such as progressbar2)
    are generally both backward and largely forward compatible, so simply fixing the
    major version is enough. In this case, `poetry` defaulted to version `^3.55.0`,
    which means that any version newer than or equal to 3.55.0, up to (but not including)
    4.0.0, is valid.
  prefs: []
  type: TYPE_NORMAL
- en: 'Due to the `poetry.lock` file, a `poetry install` will result in those exact
    versions being installed instead of the new versions, however. So how can we upgrade
    the dependencies? For this purpose, we will start by installing an older version
    of the `progressbar2` library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we will relax the version in the `pyproject.toml` file to `^3.1.0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have done this, a `poetry install` will still keep the `3.1.0` version,
    but we can make `poetry` update the dependencies for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Now, poetry has nicely updated the dependencies in our project while still adhering
    to the requirements we set in the `pyproject.toml` `file`. If you set the version
    requirements of all packages to `*`, it will always update everything to the latest
    available versions that are compatible with each other.
  prefs: []
  type: TYPE_NORMAL
- en: Running commands
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To run a single command using the `poetry` environment, you can use `poetry
    run`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'For an entire development session, however, I would suggest using the `shell`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: After this, you can run all Python commands as normal, but these will now be
    running from the activated virtual environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'For cron jobs this is similar, but you will need to make sure that you change
    directories first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: This command runs every day at 03:00 (24-hour clock, so A.M.).
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that cron might not be able to find the `poetry` command due to having
    a different environment. In that case, I would recommend using the absolute path
    to the `poetry` command, which can be found using `which`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Automatic dependency tracking using pipenv
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For large projects, your dependencies can change often, which makes the manual
    manipulation of the `requirements.txt` file rather tedious. Additionally, having
    to create a virtual environment before you can install your packages is also a
    pretty repetitive task if you work on many projects. The `pipenv` tool aims to
    transparently solve these issues for you, while also making sure that all of your
    dependencies are compatible and updated. And as a final bonus, it combines the
    strict and loose dependency versions so you can make sure your production environment
    uses the exact same versions you tested.
  prefs: []
  type: TYPE_NORMAL
- en: 'Initial usage is simple; go to your project directory and install a package.
    Let’s give it a try:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s quite a bit of output even when abbreviated. But let’s look at what
    happened:'
  prefs: []
  type: TYPE_NORMAL
- en: A virtual environment was created.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `Pipfile` was created, which contains the dependency as you specified it.
    If you specify a specific version, that will be added to the `Pipfile`; otherwise,
    it will be a wildcard requirement, meaning that any version will be accepted as
    long as there are no conflicts with other packages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `Pipfile.lock` was created containing the exact list of packages and versions
    as installed. This allows an identical install on a different machine with the
    exact same versions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The generated `Pipfile` contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'And the `Pipfile.lock` is a bit larger, but immediately shows another advantage
    of this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, in addition to the exact package versions, the `Pipfile.lock`
    contains the hashes of the packages as well. In this case, the package provides
    both a `.tar.gz` (source) and a `.whl` (wheel) file, which is why there are two
    hashes. Additionally, the `Pipfile.lock` contains all packages installed by `pipenv`,
    including all dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Using these hashes, you can be certain that during a deployment, you will receive
    the exact same file and not some corrupt or even malicious file.
  prefs: []
  type: TYPE_NORMAL
- en: Because the versions are completely fixed, you can also be certain that anyone
    deploying your project using the `Pipfile.lock` will get the exact same package
    versions. This is very useful when working together with other developers.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install all the necessary packages as specified in the `Pipfile` (even for
    the initial install), you can simply run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Any time you run `pipenv install package`, the `Pipfile` will be automatically
    modified with your changes and checked for incompatible packages. The big downside
    is that `pipenv` can become terribly slow for large projects. I have encountered
    multiple projects where a no-op `pip install` would take several minutes due to
    the fetching and checking of the entire dependency graph. In most cases, it’s
    still worth it, however; the added functionality can save you a lot of headaches.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t forget to run your regular Python commands with the `pipenv run` prefix
    or from `pipenv shell`.
  prefs: []
  type: TYPE_NORMAL
- en: Updating your packages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Because of the dependency graph, you can easily update your packages without
    having to worry about dependency conflicts. With one command, you’re done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Should you still encounter issues with the versions because some packages haven’t
    been checked against each other, you can fix that by specifying the versions of
    the package you do or do not want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'By running that command, the `packages` section of the `Pipfile` changes to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Deploying to production
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Getting the exact same versions on all of your production servers is absolutely
    essential to prevent hard-to-trace bugs. For this very purpose, you can tell `pipenv`
    to install everything as specified in the `Pipenv.lock` file while still checking
    to see whether `Pipfile.lock` is out of date. With one command, you have a fully
    functioning production virtual environment with all packages installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a new directory and see if it all works out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: All of the versions are exactly as expected and ready for use.
  prefs: []
  type: TYPE_NORMAL
- en: Running cron commands
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To run your Python commands outside of the `pipenv shell`, you can use the
    `pipenv run` prefix. Instead of `python`, you would run `pipenv run python`. In
    normal usage, this is a lot less practical than activating the `pipenv shell`,
    but for non-interactive sessions, such as cron jobs, this is an essential feature.
    For example, a cron job that runs at 03:00 (24-hour clock, so A.M.) every day
    would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many of the topics discussed in this chapter already gave full examples, leaving
    little room for exercises. There are additional resources to discover, however.
  prefs: []
  type: TYPE_NORMAL
- en: Reading the Python Enhancement Proposals (PEPs)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A good way to learn more about the topics discussed in this chapter (and all
    the following chapters) is to read the PEP pages. These proposals were written
    before the changes were accepted into the Python core. Note that not all of the
    PEPs on the Python site have been accepted, but they will remain on the Python
    site:'
  prefs: []
  type: TYPE_NORMAL
- en: 'PEP 440 – Version Identification and Dependency Specification: [https://peps.python.org/pep-0440/](https://peps.python.org/pep-0440/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'PEP 496 – Environment Markers: [https://peps.python.org/pep-0496/](https://peps.python.org/pep-0496/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining pyenv and poetry or pipenv
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even though the chapter did not cover it, there is nothing stopping you from
    telling `poetry` or `pipenv` to use a `pyenv`-based Python interpreter. Give it
    a try!
  prefs: []
  type: TYPE_NORMAL
- en: Converting an existing project to a poetry project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Part of this exercise should be to either create a brand new `pyproject.toml`
    or to convert an existing `requirements.txt` file to a `pyproject.toml`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned why virtual environments are useful and you discovered
    several implementations of them and their advantages. We explored how to create
    virtual environments and how to install multiple different Python versions. Finally,
    we covered how to manage the dependencies for your Python projects.
  prefs: []
  type: TYPE_NORMAL
- en: Since Python is an interpreted language, it is easily possible to run code from
    the interpreter directly instead of through a Python file.
  prefs: []
  type: TYPE_NORMAL
- en: The default Python interpreter already features command history and depending
    on your install, basic autocompletion.
  prefs: []
  type: TYPE_NORMAL
- en: But with alternative interpreters we can have many more features in our interpreter
    such as syntax highlighting, smart autocompletion which includes documentation,
    and more.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will show us several alternative interpreters and their advantages.
  prefs: []
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers: [https://discord.gg/QMzJenHuJf](https://discord.gg/QMzJenHuJf)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code156081100001293319171.png)'
  prefs: []
  type: TYPE_IMG
