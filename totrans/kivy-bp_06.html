<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;Making the 2048 Game"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Making the 2048 Game</h1></div></div></div><p>In the next few chapters, we <a id="id391" class="indexterm"/>will build a series of increasingly complex game projects to demonstrate some of the concepts commonly associated with game development: state management, controls, sound effects, and fast shader-based graphics, to name a few.</p><p>An important thing to consider upfront is that no approach is actually unique to game development: there are whole other classes of software that use the same algorithms and performance hacks as video games.</p><p>However, let's start small and gradually work our way to complex things. Our first project is re-implementing the relatively well-known <span class="strong"><strong>2048</strong></span> board game.</p><p>This chapter will shed light on a number of Kivy techniques that are practically required when developing games:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating Kivy widgets with custom visual appearance and behavior</li><li class="listitem" style="list-style-type: disc">Drawing on canvas and utilizing built-in graphics instructions</li><li class="listitem" style="list-style-type: disc">Using absolute positioning to arrange widgets arbitrarily on screen (as opposed to relying on a structured layout)</li><li class="listitem" style="list-style-type: disc">Moving widgets smoothly using Kivy's built-in support for animations</li></ul></div><p>Positioning widgets in absolute coordinates may sound like a regression after getting used to layout classes, but it's necessary in highly interactive applications such as games. For example, a rectangular playing field of many board games can be represented by a <code class="literal">GridLayout</code>, but even a basic animation such as movement from cell to cell will be tricky to implement. Such a task is doomed to include widget reparenting in some form; this alone pretty much marginalizes any gains from using a fixed layout.</p><div class="section" title="About the game"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec40"/>About the game</h1></div></div></div><p>For the uninitiated, the game<a id="id392" class="indexterm"/> of 2048 is a math puzzle where you combine numbers to get to 2048 and possibly beyond that, to 4096 and 8192 (albeit this may prove challenging, so 2048 is a sufficiently hard-to-achieve winning condition). The board is a 4×4 square grid. It is mostly empty at first, with a few <span class="strong"><strong>2</strong></span> tiles. Each turn the <a id="id393" class="indexterm"/>player moves all tiles in the same direction of choice: up, right, down, or left. If a tile cannot advance in that direction (there is no free space available), then it stays put in place.</p><div class="mediaobject"><img src="graphics/B01620_06_01.jpg" alt="About the game"/><div class="caption"><p>The 2048 board (a screenshot from the original game)</p></div></div><p>When two tiles having the same value touch (or rather, attempt to move on top of one another), they merge into one and sum up, increasing the tile nominal to a next power of two. So the progression looks like this: 2, 4, 8, 16, ... , 2048 and so on; programmers usually find this sequence familiar. After each turn, another <span class="strong"><strong>2</strong></span> tile is spawned in a random empty space.</p><p>The original version of 2048 also sometimes creates <span class="strong"><strong>4</strong></span> instead of <span class="strong"><strong>2</strong></span>; this is a minor feature that won't be addressed in this chapter, but should be rather simple to implement.</p><p>The game ends if there are no valid moves available to the player (the board is filled up in an unfortunate combination where no tiles of the same value are next to each other). You can play the original <a id="id394" class="indexterm"/>game of 2048 at <a class="ulink" href="http://gabrielecirulli.github.io/2048/">http://gabrielecirulli.github.io/2048/</a>.</p><div class="section" title="Gameplay concepts and overview"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec72"/>Gameplay concepts and overview</h2></div></div></div><p>Games <a id="id395" class="indexterm"/>are generally very much stateful: the application goes through a number of distinctive states, such as the start screen, world map, town screen, and so on, depending on the specifics of the game. Certainly, each game is very different and there aren't many aspects that are common across a significant number of games.</p><p>One such aspect, and very basic at that, is that most games have either a win or a loss condition, often both. This may sound trivial, but these conditions and associated game states may have a tremendous impact on player's engagement and perception of the game.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note38"/>Note</h3><p>There are games that are completely endless by design and have no connotation of the "game over" state (neither win nor loss) within the rules, and they are incredibly hard to get right in terms of player motivation. Such games also commonly provide a state of strong local advantage and disadvantage to compensate.</p><p>For example, while you cannot win the game or die completely and get into a "game over" state in World of Warcraft, or numerous other MMORPG titles that followed the same design concepts, you are certainly punished for neglecting your character's health and stats by having to perform in-game revival and associated tasks like repairing broken equipment.</p><p>Also, if you're exceptionally good, oftentimes you can team up with other highly skilled players and obtain items that aren't otherwise obtainable (and hence are unavailable to bad or casual players). This includes numerous boss encounters, raids, and those hard-to-get achievements.</p></div></div><p>The <a id="id396" class="indexterm"/>aforementioned losing condition found in 2048—the game ends when there are no available moves on the board—works great in practice because it makes the game gradually harder towards the end.</p><p>At the very beginning, the game isn't difficult at all: the player can basically perform completely random moves without any strategy. New tiles are added to the board having the same value, so it's impossible to fill all cells and run out of valid moves during first few turns, even on purpose—all the tiles are compatible and can be combined, no matter which direction the player chooses to move.</p><p>However, as you progress further in the game and variation is introduced to the board, free cells become increasingly scarcer. Since different values cannot be merged together, board management quickly becomes a problem.</p><p>Gameplay mechanics is what makes 2048 so engaging: it's really easy to start, the rules are simple and don't change over the course of the game, and 2048 doesn't punish experimentation in the beginning, even in the form of clearly suboptimal behavior, until much later in the game.</p><div class="section" title="Randomness, or lack thereof"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec15"/>Randomness, or lack thereof</h3></div></div></div><p>Since<a id="id397" class="indexterm"/> all tiles (up to 16) move at once, some of the resulting situations may have not been foreseen by players if they don't pay close attention. Albeit completely deterministic, this algorithm is perceived as having a touch of randomness to it. This also helps engagement by making 2048 feel more like an arcade game, slightly unpredictable and surprising.</p><p>This is generally a good thing: random encounters (or more accurately, encounters that are perceived as random, like in this case) may add life to an otherwise linear process, making the gameplay more interesting.</p></div></div><div class="section" title="The 2048 project outline"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec73"/>The 2048 project outline</h2></div></div></div><p>To summarize, the<a id="id398" class="indexterm"/> following are the defining characteristics of the game:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The playing field (the board) is 4×4 cells</li><li class="listitem" style="list-style-type: disc">The following actions occur during each turn:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Player moves all tiles in a direction of choice</li><li class="listitem" style="list-style-type: disc">Colliding two tiles having the same value produces one tile of greater value</li><li class="listitem" style="list-style-type: disc">New <span class="strong"><strong>2</strong></span> tile is spawned in empty space</li></ul></div></li><li class="listitem" style="list-style-type: disc">The player wins by creating a <span class="strong"><strong>2048</strong></span> tile</li><li class="listitem" style="list-style-type: disc">The game ends when there are no valid moves left (that is, none of the possible moves can change the situation on the board anymore)</li></ul></div><p>This checklist will come in handy later on, as it forms the essential technical outline of what we're going to implement in this chapter.</p></div><div class="section" title="What makes 2048 a good choice of project?"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec74"/>What makes 2048 a good choice of project?</h2></div></div></div><p>One<a id="id399" class="indexterm"/> might ask whether re-implementing an existing game is a sound idea. The answer is, by all means, yes; a more detailed explanation follows.</p><p>This is slightly off-topic when talking about practical software development, but the rationale to recreate a well-known project may not be obvious. If this chapter's approach makes perfect sense to you without lengthy explanations, then feel free to skip to the next section where the actual development begins.</p><p>To support the choice of 2048 (and the approach of "re-implementing the wheel" as a whole), let's first assume the following: game development is extremely challenging on many different levels:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Interesting game designs are hard to come by. There has to be a central idea to game mechanics, which may require a healthy amount of creativity.</li><li class="listitem" style="list-style-type: disc">A good game requires that gameplay isn't way too complex, which may quickly lead to frustration, but not too easy and therefore boring either. Balancing this may sound simple at first, but is usually hard to get right.</li><li class="listitem" style="list-style-type: disc">Some algorithms are harder than others. Path-finding on a flat, tiled map is easily approachable, but path-finding in a dynamic arbitrary three-dimensional space is a whole other story; <span class="strong"><strong>artificial intelligence</strong></span> (<span class="strong"><strong>AI</strong></span>)<a id="id400" class="indexterm"/> for a shooter may be simplistic and still deliver excellent results, while AI for a strategy game has to be clever and unpredictable to provide sufficient challenge and variety.</li><li class="listitem" style="list-style-type: disc">The attention to detail and the amount of polish that makes a good game can be downright overwhelming, even to professionals working in the field.</li></ul></div><p>This list is by no means exhaustive and serves not to scare everyone away from game development, but to get the point across—there are many things that can go wrong, so don't hesitate to offload some of the tasks to a third party. This increases your chances of delivering a working project and reduces the associated amount of frustration.</p><p>A go-to approach in gamedev (especially a sporadic, zero-budget effort like this book's projects) is to avoid costly creative search, especially in terms of gameplay. If you cannot get the project out of the door, its uniqueness is of very little value. That's why one should reuse as many existing elements as possible when building a new game.</p><p>You don't have to copy someone else's ideas verbatim, of course—tweaking every aspect of the game can be fun and a very rewarding endeavor.</p><p>In fact, most games borrow ideas, gameplay, and sometimes even visual attributes from their predecessors, and there is very little variety overall (this isn't necessarily a good thing, just the state of today's industry, for better or worse).</p><div class="section" title="Simplicity as a feature"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec16"/>Simplicity as a feature</h3></div></div></div><p>Getting back to <a id="id401" class="indexterm"/>the 2048 game, it's worth noting that its rules are very simple, borderline trivial. The fun factor, however, is inexplicably high; 2048 was very popular for a relatively long time, with numerous spin-offs flooding the Internet and app stores.</p><p>This alone makes the game of 2048 well worth rebuilding from scratch, even more so for the purpose of learning. Let's assume that at this point you're entirely convinced that 2048 is a fantastic choice of a project, and are eager to move on to actual development.</p></div></div></div></div>
<div class="section" title="Creating the 2048 board"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec41"/>Creating the 2048 board</h1></div></div></div><p>Up until <a id="id402" class="indexterm"/>now, we were relying on existing Kivy widgets, customizing them as needed to fit our specific use case. For this application, we're going to build our own unique widgets: <code class="literal">Board</code> (the playing field) and <code class="literal">Tile</code>.</p><p>Let's begin with the simple stuff and create the background for the playing field. The most unimaginative way to do so would be just using a static image; this approach has many problems, for example, it does not support the multitude of possible screen sizes properly (remember that we're talking about both desktop and mobile at the same time, so the screen size can vary wildly).</p><p>Instead, we will create the <code class="literal">Board</code> widget<a id="id403" class="indexterm"/> that renders the playing field graphics onto its canvas. This way, the board's positioning and size will be given declaratively in a Kivy language file, same as with other widgets we've used before (such as text labels and buttons).</p><p>Probably the easiest thing to start with is indeed setting the position and size of a board. To do this efficiently, we can use <code class="literal">FloatLayout</code>; this is one of the simplest layout classes provided by Kivy, which uses just the size and position hints. The following listing pretty much summarizes the usage of <code class="literal">FloatLayout</code> (this code resides in the <code class="literal">game.kv</code> file):</p><div class="informalexample"><pre class="programlisting">#:set padding 20

FloatLayout:
    Board:
        id: board
        pos_hint: {'center_x': 0.5, 'center_y': 0.5}
        size_hint: (None, None)
        center: root.center
        size: [min(root.width, root.height) - 2 * padding] * 2</pre></div><p>Here, the <code class="literal">Board</code> widget is centered on the screen, both vertically and horizontally. In order to account for any possible screen orientation or aspect ratio, we compute board size by picking the smaller side of the screen (either width or height) and subtracting the padding twice (we want the same gap from both sides). The board is square, so its dimensions are equal.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip35"/>Tip</h3><p>The <code class="literal">[...] * 2</code> trick on the <code class="literal">size:</code> line is a fairly standard Python feature to avoid repeating the same value in a list or tuple many times over when initializing the data structure, for example, <code class="literal">[1] * 3</code> equals <code class="literal">[1, 1, 1]</code>.</p><p>To avoid confusion with the arithmetic multiplication, we employ this feature sparingly. However, in production you should consider using this syntax where appropriate, as it's more concise than writing the same repetitive list or tuple by hand.</p></div></div><p>In order to see the result of our work so far, we need to define the <code class="literal">Board</code> widget itself and make it render something (by default, empty widgets are completely invisible). This will take place in the <code class="literal">main.py</code> file:</p><div class="informalexample"><pre class="programlisting">from kivy.graphics import BorderImage
from kivy.uix.widget import Widget

spacing = 15

class Board(Widget):
    def __init__(self, **kwargs):
        super(Board, self).__init__(**kwargs)
        self.resize()

    def resize(self, *args):
        self.cell_size = (0.25 * (self.width - 5 * spacing), ) * 2
        self.canvas.before.clear()
        with self.canvas.before:
            BorderImage(pos=self.pos, size=self.size,
                        source='board.png')

    on_pos = resize
    on_size = resize</pre></div><p>Similar to<a id="id404" class="indexterm"/> the definition of <code class="literal">padding</code> in <code class="literal">game.kv</code>, we define <code class="literal">spacing</code> at the top of the Python source code. This is the distance between two adjacent cells and from an edge of the board to an edge of the nearby cell.</p><p>The <code class="literal">resize()</code> method<a id="id405" class="indexterm"/> plays a central role in this part of the code: it's called when the <code class="literal">Board</code> widget is created (directly from <code class="literal">__init__()</code>) or repositioned (with the help of <code class="literal">on_pos</code> and <code class="literal">on_size</code> event callbacks). If the widget was indeed resized, we compute the new <code class="literal">cell_size</code> up front; it's a very simple computation actually, so it won't hurt even if the size of the widget did not change between invocations:</p><div class="mediaobject"><img src="graphics/7849OS_06_02.jpg" alt="Creating the 2048 board"/></div><p>Here, <span class="emphasis"><em>size</em></span> means either width or height, since all objects in question are square.</p><p>Next, we render the background. We clear the <code class="literal">canvas.before</code> graphics instruction group and fill it with primitives (which are represented by just <code class="literal">BorderImage</code> at the moment). The <code class="literal">canvas.before</code> group, as opposed to <code class="literal">canvas.after</code> or just <code class="literal">canvas</code>, is executed first when a widget is being rendered. This makes it perfect for background imagery that needs to be below any child other graphics.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note39"/>Note</h3><p>Canvas instruction groups are Kivy's way of organizing lower-level graphical operations, such as copying image data to canvas, drawing lines, and performing raw OpenGL calls. For a brief introduction to using the canvas, refer to <a class="link" href="ch02.html" title="Chapter 2. Building a Paint App">Chapter 2</a>, <span class="emphasis"><em>Building a Paint App</em></span>.</p><p>Individual canvas instructions, living in the <code class="literal">kivy.graphics</code> namespace, are conceptually children of a <code class="literal">canvas</code> object (or <code class="literal">canvas.before</code> and <code class="literal">canvas.after</code>), just like leaf widgets are children of a container or root widget. Hierarchical definitions in code also look very similar.</p><p>An important difference, however, is that widgets have a complex lifecycle, can align themselves on the screen, respond to events, and do more. Rendering instructions, on the contrary, are just that—mostly self-contained primitives for drawing. For example, the <code class="literal">Color</code> instruction changes the color (tint) for next instructions in queue, if any; <code class="literal">Image</code> draws an image on canvas; and so on.</p></div></div><p>For now, the <a id="id406" class="indexterm"/>background is just a rectangle. It has rounded corners, thanks to the background image, <code class="literal">board.png</code>, rendered using the <code class="literal">BorderImage</code> instruction—a 9-patch technique described in <a class="link" href="ch01.html" title="Chapter 1. Building a Clock App">Chapter 1</a>, <span class="emphasis"><em>Building a Clock App</em></span>, similar to how bordered buttons were implemented in all previous examples over the course of this book.</p><div class="section" title="Going through cells"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec75"/>Going through cells</h2></div></div></div><p>Our<a id="id407" class="indexterm"/> playing field is two-dimensional, and traversing a two-dimensional array can be achieved in a very obvious fashion by nesting <code class="literal">for</code> loops like this:</p><div class="informalexample"><pre class="programlisting">for x in range(4):
    for y in range(4):
        # code that uses cell at (x, y)</pre></div><p>Not only is this unwieldy and adds two levels of indentation, but also leads to repetitive code when used in many places throughout the program, which is undesirable. In Python, we can refactor this code using a generator function as shown here:</p><div class="informalexample"><pre class="programlisting"># In main.py
def all_cells():
    for x in range(4):
        for y in range(4):
            yield (x, y)</pre></div><p>The generator function itself looks similar to the straightforward approach shown in the previous code snippet. Its usage, however, is clearer:</p><div class="informalexample"><pre class="programlisting">for x, y in all_cells():
    # code that uses cell at (x, y)</pre></div><p>This is basically the same code running two nested loops, but the details of those are abstracted, and as such we have a tidy one-liner, which is also more customizable than the code interspersed with literal <code class="literal">for</code> loops over each coordinate.</p><p>In the following <a id="id408" class="indexterm"/>code, we will refer to board coordinates (those that designate a board cell, as opposed to pixel coordinates of rendered objects on screen) as <code class="literal">board_x</code> and <code class="literal">board_y</code>.</p></div><div class="section" title="Rendering empty cells"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec76"/>Rendering empty cells</h2></div></div></div><p>The position<a id="id409" class="indexterm"/> and size of the game board as a whole are defined by placement of the <code class="literal">Board</code> widget, but the location of individual cells is yet undefined. Next, we're going to compute each cell's coordinates on screen and draw all cells on the canvas.</p><p>The location of a cell on screen, taking <code class="literal">spacing</code> into account, can be calculated as follows:</p><div class="informalexample"><pre class="programlisting"># In main.py
class Board(Widget):
    def cell_pos(self, board_x, board_y):
        return (self.x + board_x *
                (self.cell_size[0] + spacing) + spacing,
                self.y + board_y *
                (self.cell_size[1] + spacing) + spacing)</pre></div><p>Canvas operations typically expect absolute coordinates, and this is why we're adding the <code class="literal">Board</code> location (<code class="literal">self.x</code>, <code class="literal">self.y</code>) to the computed value.</p><p>Now that we can iterate over the playing field and compute an onscreen position of each cell based on its board location, the only thing that's left is actually rendering cells on the canvas. Tweaking the <code class="literal">canvas.before</code> code as follows should suffice:</p><div class="informalexample"><pre class="programlisting">from kivy.graphics import Color, BorderImage
from kivy.utils import get_color_from_hex

with self.canvas.before:
    BorderImage(pos=self.pos, size=self.size,
                source='board.png')
    Color(*get_color_from_hex('CCC0B4'))
    for board_x, board_y in all_cells():
        BorderImage(pos=self.cell_pos(board_x, board_y),
                    size=self.cell_size,
                    source='cell.png')</pre></div><p>When rendering images, the <code class="literal">Color</code> instruction serves the same purpose as we've discussed previously in this book (for example, in <a class="link" href="ch02.html" title="Chapter 2. Building a Paint App">Chapter 2</a>, <span class="emphasis"><em>Building a Paint App</em></span>): it allows every tile to be colored differently while using the same (white) image for a texture.</p><p>Also, note<a id="id410" class="indexterm"/> the use of <code class="literal">cell_pos</code> and <code class="literal">cell_size</code>—these are the <span class="emphasis"><em>real</em></span> screen coordinates in pixels. They vary according to the application's window size, and are generally computed just to draw something on the screen. For game logic, we are going to use much simpler board coordinates <code class="literal">board_x</code> and <code class="literal">board_y</code>.</p><p>This screenshot summarizes all work we've done so far:</p><div class="mediaobject"><img src="graphics/B01620_06_03.jpg" alt="Rendering empty cells"/><div class="caption"><p>The playing field, devoid of anything remotely interesting yet</p></div></div></div><div class="section" title="Board data structure"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec77"/>Board data structure</h2></div></div></div><p>To be <a id="id411" class="indexterm"/>able to work on game logic, we need to keep an<a id="id412" class="indexterm"/> internal representation of the board. For this, we will use a simple two-dimensional array (to be technically correct, a list of lists). The blank state of the board looks like this:</p><div class="informalexample"><pre class="programlisting">[[None, None, None, None],
 [None, None, None, None],
 [None, None, None, None],
 [None, None, None, None]]</pre></div><p>The value of <code class="literal">None</code> means the cell is empty. The described data structure can be initialized using the nested list comprehension, as shown in the following code fragment:</p><div class="informalexample"><pre class="programlisting">class Board(Widget):
    b = None

    def reset(self):
        self.b = [[None for i in range(4)]
                  for j in range(4)]</pre></div><p>We call the preceding function <code class="literal">reset()</code> because, in addition to initializing the data structure beforehand, it will also be used to return the game to a blank state after a game-over situation.</p><p>The use<a id="id413" class="indexterm"/> of list comprehensions isn't strictly necessary; this notation is just more concise than the literal list of lists which is also shown earlier. If <a id="id414" class="indexterm"/>you think that the literal form (as shown earlier) is more readable, by all means use it instead when initializing the grid.</p><div class="section" title="Variable naming"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec17"/>Variable naming</h3></div></div></div><p>A short <a id="id415" class="indexterm"/>name, <code class="literal">b</code>, is deemed appropriate because this property should be considered internal to the class, so it doesn't take part in the external API (or lack thereof). We will also use this variable heavily in the following code, so this also serves to reduce typing, akin to the commonly used loop iterator variables <code class="literal">i</code> and <code class="literal">j</code>.</p><p>In Python, private fields are usually designated with the leading underscore, for example, <code class="literal">_name</code>. We do not follow this convention strictly here, partly because this looks bad when used with very short names. This whole class is largely internal to the application anyway and barely, if at all, reusable as a separate module.</p><p>Consider <code class="literal">Board.b</code> a local variable for all intents and purposes, especially since <code class="literal">Board</code> acts as a singleton in our app: there should be only one instance of it at a given time.</p></div><div class="section" title="Calling reset()"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec18"/>Calling reset()</h3></div></div></div><p>We <a id="id416" class="indexterm"/>should call <code class="literal">Board.reset()</code> at the beginning of the game to initialize the internal representation of the board. The right place to do so is the application's <code class="literal">on_start</code> callback, as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting"># In main.py
from kivy.app import App

class GameApp(App):
    def on_start(self):
        board = self.root.ids.board
        board.reset()</pre></div></div></div><div class="section" title="Testing passability"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec78"/>Testing passability</h2></div></div></div><p>We don't have <a id="id417" class="indexterm"/>anything clever to put in the grid yet, but this doesn't prevent us from writing a passability check, <code class="literal">can_move()</code>. This helper function tests whether we can place a tile at the specified location on the board.</p><p>The check is two-fold. First we need to make sure that the coordinates that are provided generally make sense (that is, don't fall outside the board), and this check will live in a separate function called <code class="literal">valid_cell()</code>. Then, we look up the board cell to see if it's empty (equals to <code class="literal">None</code>). The return value will be <code class="literal">True</code> if the move is legal and the cell is free, and <code class="literal">False</code> otherwise.</p><p>The preceding sentence can be literally translated to Python:</p><div class="informalexample"><pre class="programlisting"># In main.py, under class Board:
def valid_cell(self, board_x, board_y):
    return (board_x &gt;= 0 and board_y &gt;= 0 and
            board_x &lt;= 3 and board_y &lt;= 3)

def can_move(self, board_x, board_y):
    return (self.valid_cell(board_x, board_y) and
            self.b[board_x][board_y] is None)</pre></div><p>These methods will be used later when writing the code responsible for tile movement. But first, we need to create the tiles.</p></div></div>
<div class="section" title="Making tiles"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec42"/>Making tiles</h1></div></div></div><p>This <a id="id418" class="indexterm"/>part <a id="id419" class="indexterm"/>of the chapter is devoted to building the <code class="literal">Tile</code> widget. Tiles are more dynamic in nature than, for example, the <code class="literal">Board</code> widget that we've seen earlier. To account for this, we are going to create a number of Kivy properties on the <code class="literal">Tile</code> class so that any visible change to tile automatically leads to redrawing it.</p><p>Kivy properties differ from regular Python ones: a property in Python is basically just a variable bound to an instance of class, possibly coupled with getter and setter functions. In Kivy, properties have an additional feature: they emit events when changed and as such you can observe interesting properties and adjust other related variables accordingly, or perhaps repaint the screen.</p><p>Most of this work happens under the hood without your intervention: when you issue a change to, for example, the <code class="literal">pos</code> or <code class="literal">size</code> of a widget, an event (<code class="literal">on_pos</code> or <code class="literal">on_size</code> respectively) is fired.</p><p>Interestingly, all properties that are defined in a <code class="literal">.kv</code> file are propagated automatically. For example, you can write things such as:</p><div class="informalexample"><pre class="programlisting">Label:
    pos: root.pos</pre></div><p>When <a id="id420" class="indexterm"/>the <code class="literal">root.pos</code> property changes, so does this label's <code class="literal">pos</code> value; they are kept in sync effortlessly.</p><p>We are <a id="id421" class="indexterm"/>going to use this quality to our advantage when creating the <code class="literal">Tile</code> widget. First, let's declare interesting properties that should be accounted for when rendering the widget:</p><div class="informalexample"><pre class="programlisting"># In main.py
from kivy.properties import ListProperty, NumericProperty

class Tile(Widget):
    font_size = NumericProperty(24)
    number = NumericProperty(2)  # Text shown on the tile
    color = ListProperty(get_color_from_hex(tile_colors[2]))
    number_color = ListProperty(get_color_from_hex('776E65'))</pre></div><p>This is all that's needed to draw a tile; property names should be rather self-explanatory, with the possible exception of <code class="literal">color</code>, a tile's background color. The <code class="literal">number</code> property denotes the <span class="emphasis"><em>face value</em></span> of the tile.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip36"/>Tip</h3><p>If you want to run this code right now, please replace <code class="literal">tile_colors[2]</code> with a literal color value, for example, <code class="literal">'#EEE4DA'</code>. We will define the <code class="literal">tile_colors</code> list properly later in this section.</p></div></div><p>Next, in <code class="literal">game.kv</code>, we define graphical elements that constitute our widget:</p><div class="informalexample"><pre class="programlisting">&lt;Tile&gt;:
    canvas:
        Color:
            rgb: <span class="strong"><strong>self.color</strong></span>

        BorderImage:
            pos: self.pos
            size: self.size
            source: 'cell.png'

    Label:
        pos: root.pos
        size: root.size
        bold: True
        color: <span class="strong"><strong>root.number_color</strong></span>
        font_size: <span class="strong"><strong>root.font_size</strong></span>
        text: str(<span class="strong"><strong>root.number</strong></span>)</pre></div><p>Custom properties <a id="id422" class="indexterm"/>coming from the <code class="literal">Tile</code> class are highlighted. Note that inside the <code class="literal">canvas</code> declaration, <code class="literal">self</code> refers to <code class="literal">&lt;Tile&gt;</code>, and not to the canvas itself. This is because <code class="literal">canvas</code> is merely <a id="id423" class="indexterm"/>a property of the corresponding widget. <code class="literal">Label</code>, on the other hand, is a nested widget in its own right, so it uses <code class="literal">root.XXX</code> to refer to <code class="literal">&lt;Tile&gt;</code> properties. It's the top-level definition in this case, so it works.</p><div class="section" title="Tile initialization"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec79"/>Tile initialization</h2></div></div></div><p>In the original 2048 game, tiles have varying background colors according to their numeric value. We are going to implement the same effect, and for this we need a color mapping, <span class="emphasis"><em>number → color</em></span>.</p><p>The following list of colors is close to what the original 2048 game uses:</p><div class="informalexample"><pre class="programlisting"># In main.py
colors = (
    'EEE4DA', 'EDE0C8', 'F2B179', 'F59563',
    'F67C5F', 'F65E3B', 'EDCF72', 'EDCC61',
    'EDC850', 'EDC53F', 'EDC22E')</pre></div><p>In order to map them to numbers, which in 2048 are powers of two, we can use the following code:</p><div class="informalexample"><pre class="programlisting">tile_colors = {2 ** i: color for i, color in
               enumerate(colors, start=1)}</pre></div><p>This is exactly the mapping we need, with tile numbers as keys and corresponding colors as values:</p><div class="informalexample"><pre class="programlisting">{2: 'EEE4DA',
 4: 'EDE0C8',
 # ...
 1024: 'EDC53F',
 2048: 'EDC22E'}</pre></div><p>With the colors in place, we can write an initializer of the <code class="literal">Tile</code> class, the <code class="literal">Tile.__init__</code> method. It will mostly just assign properties of the tile in question, as shown in the following listing:</p><div class="informalexample"><pre class="programlisting">class Tile(Widget):
    font_size = NumericProperty(24)
    number = NumericProperty(2)
    color = ListProperty(get_color_from_hex(tile_colors[2]))
    number_color = ListProperty(get_color_from_hex('776E65'))

    def __init__(self, number=2, **kwargs):
        super(Tile, self).__init__(**kwargs)
        self.font_size = 0.5 * self.width
        self.number = number
        self.update_colors()

    def update_colors(self):
        self.color = get_color_from_hex(
            tile_colors[self.number])
        if self.number &gt; 4:
            self.number_color = \
                get_color_from_hex('F9F6F2')</pre></div><p>Let's briefly talk about every property that we see here:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">font_size</code>: This <a id="id424" class="indexterm"/>is set to half of <code class="literal">cell_size</code>. This is basically an arbitrary value which looks fine. We cannot just put an absolute font size here, because the board is scaled to fit the window; the best approach is to keep font size to scale.</li><li class="listitem" style="list-style-type: disc"><code class="literal">number</code>: This <a id="id425" class="indexterm"/>is passed from the calling function and defaults to <span class="strong"><strong>2</strong></span>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">color</code> (the background color of a tile): This <a id="id426" class="indexterm"/>originates from the mapping discussed earlier, based on the value of <code class="literal">number</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">number_color</code>: This<a id="id427" class="indexterm"/> is chosen based on the <code class="literal">number</code> property, too, but with much less variety. There are just two colors: a dark one (the default) which is used on a light background, and a lighter one for better contrast on a bright background, as numbers go up; hence the check (<code class="literal">if self.number &gt; 4</code>).</li></ul></div><p>Everything <a id="id428" class="indexterm"/>else is passed to the superclass in the form of <code class="literal">kwargs</code> (keyword arguments). This includes position and size attributes, which coincidentally are the topic of the next section.</p><p>Colors live in a helper function of their own, <code class="literal">update_colors()</code>, because later we will need to update them when merging tiles.</p><p>It's worth mentioning that at this point, you can create a tile using something along the lines of:</p><div class="informalexample"><pre class="programlisting">tile = Tile(pos=self.cell_pos(x, y), size=self.cell_size)
self.add_widget(tile)</pre></div><p>As a result, a new tile will be visible on the screen. (The preceding code should reside in the <code class="literal">Board</code> class. Alternatively, change all <code class="literal">self</code> references to an instance of <code class="literal">Board</code>.)</p></div><div class="section" title="Resizing tiles"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec80"/>Resizing tiles</h2></div></div></div><p>Another <a id="id429" class="indexterm"/>problem with tiles is that they aren't aware that they should keep up with the board being resized. If you enlarge or shrink the application window, the board adjusts its size and position, but tiles don't. We're going to fix that.</p><p>Let's start with a helper method for updating all relevant <code class="literal">Tile</code> properties at once:</p><div class="informalexample"><pre class="programlisting">class Tile(Widget):
    # Other methods skipped to save space

    def resize(self, pos, size):
        self.pos = pos
        self.size = size
        self.font_size = 0.5 * self.width</pre></div><p>Although this method isn't strictly required, it makes the following code a bit more concise.</p><p>The actual resizing code will be located at the end of the <code class="literal">Board.resize()</code> method, which is invoked by Kivy property bindings. Here, we can iterate over all tiles and fix their metrics according to new values of <code class="literal">cell_size</code> and <code class="literal">cell_pos</code>:</p><div class="informalexample"><pre class="programlisting">def resize(self, *args):
    # Previously-seen code omitted

    for board_x, board_y in all_cells():
        tile = self.b[board_x][board_y]
        if tile:
            tile.resize(pos=self.cell_pos(board_x, board_y),
                        size=self.cell_size)</pre></div><p>This approach is the exact opposite of automatic property binding we've seen earlier: we do all resizing in a centralized, explicit fashion. Some programmers may find this way of doing things more readable and less <span class="emphasis"><em>magical</em></span> (for example, Python code allows you to set breakpoints inside event handlers and such; on the contrary, Kivy language files are much harder to meaningfully debug, should the need arise).</p></div></div>
<div class="section" title="Implementing the game logic"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec43"/>Implementing the game logic</h1></div></div></div><p>Now that <a id="id430" class="indexterm"/>we've built all the components required<a id="id431" class="indexterm"/> to make an implementation of the 2048 game, let's move on to more interesting things: spawning, moving, and combining tiles.</p><p>It's only logical that we begin with spawning new tiles in random empty cells. The algorithm for doing so is as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Find all cells that are currently empty.</li><li class="listitem">Pick a random one from those found in step 1.</li><li class="listitem">Create a new tile at the position determined in step 2.</li><li class="listitem">Add it to the internal grid (<code class="literal">Board.b</code>), and to the board widget itself (using <code class="literal">add_widget()</code>) for Kivy to render it.</li></ol></div><p>The <a id="id432" class="indexterm"/>sequence of actions should be self-evident; the <a id="id433" class="indexterm"/>following Python implementation of this algorithm is also very straightforward:</p><div class="informalexample"><pre class="programlisting"># In main.py, a method of class Board:
def new_tile(self, *args):
    empty_cells = [(x, y) for x, y in all_cells()  # Step 1
                   if self.b[x][y] is None]

    x, y = random.choice(empty_cells)  # Step 2
    tile = Tile(pos=self.cell_pos(x, y),  # Step 3
                size=self.cell_size)
    self.b[x][y] = tile  # Step 4
    self.add_widget(tile)</pre></div><p>New tiles spawn at the beginning of the game and after every move. We will get to moving tiles shortly, and we can already implement spawning tiles at the beginning:</p><div class="informalexample"><pre class="programlisting">def reset(self):
    self.b = [[None for i in range(4)]
              for j in range(4)]  # same as before
    self.new_tile()
    self.new_tile()  # put down 2 tiles</pre></div><p>If you run the program after this change, you should see two tiles added to the board in random places.</p><div class="mediaobject"><img src="graphics/B01620_06_04.jpg" alt="Implementing the game logic"/><div class="caption"><p>Spawning tiles in action</p></div></div><div class="section" title="Moving tiles"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec81"/>Moving tiles</h2></div></div></div><p>To<a id="id434" class="indexterm"/> implement movement efficiently, we'll <a id="id435" class="indexterm"/>need to map every input event to a directional vector. Then, the <code class="literal">Board.move()</code> method<a id="id436" class="indexterm"/> will accept such a vector and rearrange the board accordingly. A directional vector is typically normalized (its length equals to one), and in our case, we can just add it to the current tile's coordinates to get its possible new location.</p><p>The 2048 game only allows four options for movement, so the keyboard mapping definition is very short:</p><div class="informalexample"><pre class="programlisting">from kivy.core.window import Keyboard

key_vectors = {
    Keyboard.keycodes['up']: (0, 1),
    Keyboard.keycodes['right']: (1, 0),
    Keyboard.keycodes['down']: (0, -1),
    Keyboard.keycodes['left']: (-1, 0),
}</pre></div><p>In this listing, we're referring to arrow keys, aptly named <code class="literal">'up'</code>, <code class="literal">'right'</code>, <code class="literal">'down'</code>, and <code class="literal">'left'</code> in Kivy's predefined <code class="literal">keycodes</code> dictionary.</p><p>Listening to keyboard events in Kivy can be implemented using the <code class="literal">Window.bind()</code> method, as shown in the following code:</p><div class="informalexample"><pre class="programlisting"># In main.py, under class Board:
def on_key_down(self, window, key, *args):
    if key in key_vectors:
        self.move(*key_vectors[key])

# Then, during the initialization (in GameApp.on_start())
Window.bind(on_key_down=board.on_key_down)</pre></div><p>The <a id="id437" class="indexterm"/>
<code class="literal">Board.move()</code> method gets called<a id="id438" class="indexterm"/> as a result. It accepts the directional vector components, <code class="literal">dir_x</code> and <code class="literal">dir_y</code>, unpacked from <code class="literal">key_vectors[key]</code>.</p><div class="section" title="Controlling the iteration sequence"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec19"/>Controlling the iteration sequence</h3></div></div></div><p>Before <a id="id439" class="indexterm"/>we get to actually build the <code class="literal">Board.move()</code> method, we need to make the <code class="literal">all_cells()</code> generator function customizable; correct iteration order depends on the movement direction.</p><p>For example, when going up, we have to start with the topmost cell in each column. This way we can ensure that all tiles will be arranged densely at the top of the board. In the event of incorrect iteration, you will inevitably see holes remaining from cells at the bottom bumping into cells at the top before those have reached their topmost available position.</p><p>Taking this new requirement into account, we can easily write a new version of the generator function as shown here:</p><div class="informalexample"><pre class="programlisting">def all_cells(flip_x=False, flip_y=False):
    for x in (reversed(range(4)) if flip_x else range(4)):
        for y in (reversed(range(4)) if flip_y else range(4)):
            yield (x, y)</pre></div><p>You may also want to write just <code class="literal">(3, 2, 1, 0)</code> instead of <code class="literal">reversed(range(4))</code>. In this specific case, literal enumeration is more concise than the iterator that produces it. Whether you choose to do so is a matter of personal preference and doesn't affect the functionality in any way.</p></div><div class="section" title="Implementing the move() method"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec20"/>Implementing the move() method</h3></div></div></div><p>Now, we <a id="id440" class="indexterm"/>can build the simplest version of the <code class="literal">Board.move()</code> function. At the moment, it will only facilitate moving tiles around, but we will soon upgrade it to also merge tiles together.</p><p>Here's an overview of this function's algorithm so far:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Go through all (existing) tiles.</li><li class="listitem">For each tile, move it in the specified direction until it bumps into another tile or the playing field boundary.</li><li class="listitem">If the tile's coordinates stay the same, continue to the next tile.</li><li class="listitem">Animate the tile's transition to new coordinates and continue to the next tile.</li></ol></div><p>The Python implementation closely follows the previous description:</p><div class="informalexample"><pre class="programlisting">def move(self, dir_x, dir_y):
    for board_x, board_y in all_cells(dir_x &gt; 0, dir_y &gt; 0):
        tile = self.b[board_x][board_y]
        if not tile:
            continue

        x, y = board_x, board_y
        while self.can_move(x + dir_x, y + dir_y):
            self.b[x][y] = None
            x += dir_x
            y += dir_y
            self.b[x][y] = tile

        if x == board_x and y == board_y:
            continue  # nothing has happened

        anim = Animation(pos=self.cell_pos(x, y),
                         duration=0.25, transition='linear')
        anim.start(tile)</pre></div><p>In this listing, you <a id="id441" class="indexterm"/>can see the usage of <code class="literal">can_move()</code> function that we've built earlier.</p><p>The <code class="literal">Animation</code> API<a id="id442" class="indexterm"/> works akin to CSS transitions in a browser. We need to provide:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Values of properties we want to animate (in this example, <code class="literal">pos</code>)</li><li class="listitem" style="list-style-type: disc">Duration, in seconds</li><li class="listitem" style="list-style-type: disc">Transition type (<code class="literal">'linear'</code> means equal speed throughout the route)</li></ul></div><p>Given all that, Kivy renders a smooth animation with the widget morphing from the current state to a new one.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note40"/>Note</h3><p>All transition types are detailed in the <a id="id443" class="indexterm"/>Kivy manual (<a class="ulink" href="http://kivy.org/docs/api-kivy.animation.html">http://kivy.org/docs/api-kivy.animation.html</a>). There are just too many of them to provide a meaningful summary here.</p></div></div></div><div class="section" title="Binding touch controls"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec21"/>Binding touch controls</h3></div></div></div><p>Let's also<a id="id444" class="indexterm"/> implement touch controls (swipes) in addition to keyboard bindings that we've done previously. Thanks to mouse input events being processed just like touches in Kivy, our code will also support mouse gestures.</p><p>To do so, we need to merely add an event handler to the <code class="literal">Board</code> class:</p><div class="informalexample"><pre class="programlisting">from kivy.vector import Vector

# A method of class Board:
def on_touch_up(self, touch):
    v = Vector(touch.pos) - Vector(touch.opos)
    if v.length() &lt; 20:
        return

    if abs(v.x) &gt; abs(v.y):
        v.y = 0
    else:
        v.x = 0

    self.move(*v.normalize())</pre></div><p>In this code, we're converting an arbitrary gesture to a unit vector that we need for <code class="literal">Board.move()</code> to work. The complete walkthrough is as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The <code class="literal">if v.length() &lt; 20:</code> condition checks for eliminating very short gestures. If the travel distance is very short, then probably it was a click or tap, not a swipe.</li><li class="listitem">The <code class="literal">if abs(v.x) &gt; abs(v.y):</code> condition sets the shorter component of the vector to zero. The remaining component thus designates the direction.</li><li class="listitem">And then we simply normalize the vector and feed it into <code class="literal">Board.move()</code>.</li></ol></div><p>This last point <a id="id445" class="indexterm"/>is exactly the reason why you shouldn't invent your own ways to represent <span class="emphasis"><em>mathematically expressible</em></span> things such as directions.</p><p>Everyone out there understands vectors, you get compatibility with any other library essentially for free when you use them; but should you reinvent the wheel and define some other representation, for example, <code class="literal">UP = 0</code>, <code class="literal">RIGHT = 1</code> and so on—and boom, you're now all alone in the cold, dark nowhere, inconsistent with the rest of the world. Seriously, don't do that unless you have at least two very good reasons.</p></div></div><div class="section" title="Combining tiles"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec82"/>Combining tiles</h2></div></div></div><p>We will<a id="id446" class="indexterm"/> discuss the last fun part of the gameplay now: merging tiles as they bump into one another. The following code is surprisingly not very convoluted; one would probably expect it to be harder than that.</p><p>We will build yet another helper function, <code class="literal">can_combine()</code>. Conceptually very similar to <code class="literal">can_move()</code>, this function returns <code class="literal">True</code> if we can combine the current tile with the one at the provided location, that is, if the coordinates are same and the location contains a tile having the same value.</p><p>This is the unabridged listing of the described method. Compare this function to its counterpart, <code class="literal">can_move()</code>, and you will notice that it looks almost identical:</p><div class="informalexample"><pre class="programlisting">def can_combine(self, board_x, board_y, number):
    return (self.valid_cell(board_x, board_y) and
            self.b[board_x][board_y] is not None and
            self.b[board_x][board_y].number == number)</pre></div><p>With this <a id="id447" class="indexterm"/>function in place, we can now expand the <code class="literal">Board.move()</code> function to support merging cells.</p><p>Just add the following snippet after the movement <code class="literal">while self.can_move()</code> block:</p><div class="informalexample"><pre class="programlisting">if self.can_combine(x + dir_x, y + dir_y,
                    tile.number):
    self.b[x][y] = None
    x += dir_x
    y += dir_y
    self.remove_widget(self.b[x][y])
    self.b[x][y] = tile
    tile.number *= 2
    tile.update_colors()</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip37"/>Tip</h3><p>Please see the full source code for this project if you're unsure about the code layout. The latest version of all the source code accompanying this book can be found at <a class="ulink" href="https://github.com/mvasilkov/kb">https://github.com/mvasilkov/kb</a>.</p></div></div><p>Again, this code resembles the movement logic, with two notable differences. The tile we're combining with gets removed using <code class="literal">remove_widget()</code>, and the remaining tile's number is updated, which means that we need to also update its colors.</p><p>So, our tiles merge happily and their values add up. The game would absolutely be playable at this point, if not for the last few things discussed next.</p></div><div class="section" title="Adding more tiles"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec83"/>Adding more tiles</h2></div></div></div><p>Our <a id="id448" class="indexterm"/>game really should spawn new tiles after each turn. To complicate things further, this has to be done at the end of the animation sequence, when tiles that were affected by the last turn are done moving.</p><p>Thankfully, there is a fitting event, <code class="literal">Animation.on_complete</code>, which is exactly what we're going to use here. Since we run a number of animations equal to the number of active tiles simultaneously, we need to bind the event only to the first <code class="literal">Animation</code> instance—they all start at the same time and have the same duration anyway, so there shouldn't be a noticeable difference between the timings of the first and the last animation in a synchronized batch.</p><p>The implementation resides in the same <code class="literal">Board.move()</code> method that we've seen previously:</p><div class="informalexample"><pre class="programlisting">def move(self, dir_x, dir_y):
    moving = False
	
    # Large portion of the code is omitted to save trees

        if x == board_x and y == board_y:
            continue  # nothing has happened

        anim = Animation(pos=self.cell_pos(x, y),
                         duration=0.25, transition='linear')
        if not moving:
            anim.on_complete = self.new_tile
            moving = True

        anim.start(tile)</pre></div><p>As soon as<a id="id449" class="indexterm"/> the animation ends and the <code class="literal">on_complete</code> event fires, <code class="literal">new_tile()</code> is called and the game continues.</p><p>The reason we introduce a Boolean flag named <code class="literal">moving</code> is to ensure that <code class="literal">new_tile()</code> won't be called more than once per turn. Skipping this check leads to the board getting flooded with new titles in no time.</p><div class="section" title="Synchronizing turns"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec22"/>Synchronizing turns</h3></div></div></div><p>You might have<a id="id450" class="indexterm"/> noticed that there is a bug in the current implementation of animated tiles: the player can start a new turn before the previous one has ended. The easiest way to reproduce and obviate this issue is to increase the duration of the movement considerably, for example, to 10 seconds:</p><div class="informalexample"><pre class="programlisting"># This is for demonstration only
anim = Animation(pos=self.cell_pos(x, y),
                 <span class="strong"><strong>duration=10,</strong></span> transition='linear')</pre></div><p>The easiest way we can fix this bug is by ignoring subsequent calls to <code class="literal">move()</code> while the tiles are in motion already. In order to do that, we have to broaden the scope of the previously seen <code class="literal">moving</code> flag. From now on, it will be a property of the <code class="literal">Board</code> class. We are also adjusting the <code class="literal">move()</code> method accordingly:</p><div class="informalexample"><pre class="programlisting">class Board(Widget):
<span class="strong"><strong>    moving = False</strong></span>

    def move(self, dir_x, dir_y):
<span class="strong"><strong>        if self.moving:</strong></span>
<span class="strong"><strong>            return</strong></span>

        # Again, large portion of the code is omitted

            anim = Animation(pos=self.cell_pos(x, y),
                             duration=0.25,
                             transition='linear')
<span class="strong"><strong>            if not self.moving:</strong></span>
                anim.on_complete = self.new_tile
<span class="strong"><strong>                self.moving = True</strong></span>

            anim.start(tile)</pre></div><p>Don't forget<a id="id451" class="indexterm"/> to reset <code class="literal">moving</code> back to <code class="literal">False</code> in <code class="literal">new_tile()</code>, or else tiles will cease to move at all after the first turn.</p></div></div><div class="section" title="Game over"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec84"/>Game over</h2></div></div></div><p>One more<a id="id452" class="indexterm"/> thing that is <a id="id453" class="indexterm"/>missing from the game is the "game over" state. We discussed winning and losing conditions at the beginning of the chapter, so it's stylistically appropriate to end the implementation with the same topic.</p><div class="section" title="The winning condition"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec23"/>The winning condition</h3></div></div></div><p>Testing<a id="id454" class="indexterm"/> whether the player has managed to assemble a 2048 tile can be easily done in the only place where the tile value is doubled when combining tiles in the <code class="literal">Board.move()</code> function:</p><div class="informalexample"><pre class="programlisting">tile.number *= 2
if (tile.number == 2048):
    print('You win the game')</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip38"/>Tip</h3><p>Note that the specific UI for reporting end game conditions is purposefully omitted. Creating yet another simple screen with a button and some text would unnecessarily clutter the chapter without adding anything to the content already present in the book.</p><p>In other words, implementing visually appealing end game states is again left as an exercise—we will only suggest an algorithm for detecting them.</p><p>To test end game conditions, it may be useful to lower the winning requirement severely by replacing <code class="literal">2048</code> by, for example, <code class="literal">64</code>, but don't forget to change it back before a public release!</p></div></div></div><div class="section" title="The loss condition"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec24"/>The loss condition</h3></div></div></div><p>This <a id="id455" class="indexterm"/>algorithm is a bit more complex, and as such it can be written in a number of ways. Probably the most literal approach would be to traverse the board completely before each move to test whether the board is deadlocked:</p><div class="informalexample"><pre class="programlisting">def is_deadlocked(self):
    for x, y in all_cells():
        if self.b[x][y] is None:
            return False  # Step 1

        number = self.b[x][y].number
        if self.can_combine(x + 1, y, number) or \
                self.can_combine(x, y + 1, number):
            return False  # Step 2
    return True  # Step 3</pre></div><p>The explanation: for every tile on the board we're testing the following:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Found an empty cell? This instantly means that we're not deadlocked—another tile can move to that cell.</li><li class="listitem">Otherwise, if the selected tile can combine with the one to the right or to the bottom, we're good, since we have a possible move.</li><li class="listitem">If all else fails and we cannot find a cell that satisfies either of the previous conditions, this means we're out of moves—the game is over at this point.</li></ol></div><div class="mediaobject"><img src="graphics/B01620_06_05.jpg" alt="The loss condition"/><div class="caption"><p>Game over: there are no valid moves</p></div></div><p>A fitting place to run this test would be in the <code class="literal">new_tile()</code> method:</p><div class="informalexample"><pre class="programlisting">def new_tile(self, *args):
    empty_cells = [(x, y) for x, y in all_cells()
                   if self.b[x][y] is None]

    # Spawning a new tile (omitted)

    if len(empty_cells) == 1 and self.is_deadlocked():
        print('Game over (board is deadlocked)')

    self.moving = False  # See above, "Synchronizing turns"</pre></div><p>The <a id="id456" class="indexterm"/>precondition (<code class="literal">len(empty_cells) == 1</code>) allows us to run the check less often: there is no point in testing for the loss when the board isn't full yet. It's worth noting that our <code class="literal">is_deadlocked()</code> method would have correctly returned <code class="literal">False</code> in this case anyway, so this is purely an optimization, not affecting the "business logic" in any way.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip39"/>Tip</h3><p>This approach is still a little suboptimal, performance-wise, and could be improved at the cost of lengthening the code: one obvious optimization would be skipping the last row and column, and then not checking for bounds on each iteration, which <code class="literal">can_combine()</code> function implicitly does.</p><p>However, the gain in this case would be negligible, since this check runs at most once every turn, and we're mostly waiting for user input anyway.</p></div></div></div></div></div>
<div class="section" title="Where to go from here"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec44"/>Where to go from here</h1></div></div></div><p>The game is finally playable, but there certainly are many areas in which it can be improved. If you're<a id="id457" class="indexterm"/> willing to toy with the concept of 2048 some more, consider some of the following tasks:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Add more animations—they do wonders in terms of perceived interactivity.</li><li class="listitem" style="list-style-type: disc">As an additional motivational factor, add a score counter and the related infrastructure (for instance, the ability to save high scores and transmit them to the global server-side leaderboard).</li><li class="listitem" style="list-style-type: disc">Tweak the game rules so that they are exactly like the original 2048 game.</li><li class="listitem" style="list-style-type: disc">For a more mind-bending experimentation, build an algorithm that predicts fruitless game sessions in advance. As a player, I would positively love to receive a notification that reads, "No matter what you do, in 7 turns it's over for you, thanks for playing."</li><li class="listitem" style="list-style-type: disc">Change the <a id="id458" class="indexterm"/>rules completely. Add a multiplayer arena death match mode—be creative.</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note41"/>Note</h3><p>If you're interested in seeing another, more complete Kivy implementation of the same 2048 game, take a look at <a class="ulink" href="https://github.com/tito/2048">https://github.com/tito/2048</a>. This project, written by a core Kivy developer Mathieu Virbel, features Google Play integration, achievements, and a high-score leaderboard, among other things.</p><p>It should be postulated that reading other people's code is a great way to learn.</p></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec45"/>Summary</h1></div></div></div><p>In this chapter, we built a playable replica of the 2048 game. We also showcased a number of implementation details that can be reused in other similar projects:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating a scalable board that fits the screen in any resolution and orientation</li><li class="listitem" style="list-style-type: disc">Putting together custom tiles, and implementing smooth movement for those with the help of Kivy's <code class="literal">Animation</code> API</li><li class="listitem" style="list-style-type: disc">Mapping player's controls to both touch screen gestures and keyboard arrow keys at the same time, to account for any control scheme the user might expect from the game</li></ul></div><p>The Kivy framework supports game development nicely; in particular, canvas rendering and support for animations can be very useful when building video games. Prototyping in Kivy is also feasible, albeit somewhat harder to do than in JavaScript (a modern browser is a very powerful platform, and it's especially hard to beat when it comes to cheap prototyping).</p><p>The resulting Python program is also inherently cross-platform unless you're using an OS-specific API in a way that prevents other systems from functioning. This means that technically your game can be played by everyone, reaching the widest possible audience.</p><p>The use of Kivy also doesn't conflict with publishing your work on major app distribution platforms, be it Apple AppStore, Google Play, or even Steam.</p><p>Certainly, Kivy lacks a great many features and most of the toolchain if compared to a full-fledged game engine like the Unreal Engine or Unity. This is due to the fact that Kivy is a general purpose UI framework and not a game engine per se; one can argue that such a comparison of vastly different software categories over respective feature sets is incorrect.</p><p>To summarize, Kivy is a solid choice for sporadic indie game development. Angry Birds could have been implemented in Python and Kivy by <span class="emphasis"><em>you</em></span>! Imagine the scale of the opportunity you've missed back then. (But please don't feel bad about this, it was meant as an encouragement. Rovio's path to a successful game title wasn't exactly easy either.)</p><p>This brings us to the topic of the next chapter: writing an arcade game using Kivy. It will utilize the familiar concept of Kivy widgets in a variety of unorthodox ways to create an interactive side-scrolling environment, reminiscent of another critically acclaimed indie game, Flappy Bird.</p></div></body></html>