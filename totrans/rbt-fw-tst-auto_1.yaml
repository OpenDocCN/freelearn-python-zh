- en: Chapter 1. Getting Started with the Robot Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Definition and need for acceptance testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction and a brief history of the Robot Framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Components of the Robot Framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Various installation methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different installation environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creation and execution of a sample project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Brief description of the generated files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This book introduces you to the Robot Framework, which is a Python-based, keyword-driven,
    and acceptance test automation framework. It is very flexible and easy to use
    and extend according to your intentions. Built to provide acceptance test regardless
    of the platform size and scope of the software to be tested, also known as System
    Under Test (SUT), it is an ideal software tool to structure and manage different
    tests as part of a comprehensive test suite. Since this tool utilizes and manages
    the tests as well as deals with the software under test, it is beneficial for
    both testers and developers alike. Today, with the rise of versatile software
    tools and greater emphasis on test-driven development, the line between tester
    and developer has become blurred. To learn and use this tool effectively, you
    will have to put yourself in the shoes of both tester as well as a developer.
    The Python and/or ports into Java and .Net framework such as, Jython and Ironpython
    are also required.
  prefs: []
  type: TYPE_NORMAL
- en: As with any other physical creation, software is built with an aim of directly
    or indirectly changing our lives to solve a task or desire of someone. However,
    programming is an abstract science that is not dependent upon its end-user's desires,
    commonly referred to as garbage in – garbage out. A difference between the created
    software and its expected behavior by its user determines its implementation by
    the user. Thus, the end user must accept the software that is intended to be sold
    to him. However, the user often does not wants to be involved in the finer details
    and just needs to get the things done as he envisages with each iteration of the
    software. In order to perform this, the interactions that the end user does with
    the software is needed to be verified beforehand, which has led to creation of
    testing especially designed to perform this process of testing and verification.
    This process is known as acceptance testing. However, as the software grows, more
    and more, acceptance tests come up that give rise to a sense of chaos as upon
    failure of a test, proper context is not easily identified.
  prefs: []
  type: TYPE_NORMAL
- en: As the scale and complexity of software has grown up, so has the need for its
    quality assurance. Manual tests often are quite easy to set up, but they give
    diminishing returns of scale and are only feasible up to an extent, where a tester
    can manually work through different scenarios and identify bugs and errors in
    time without affecting the delivery schedule of the resultant product.
  prefs: []
  type: TYPE_NORMAL
- en: The need for acceptance testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For tests that are large in size or complexity, a structured approach can help
    you to pinpoint the errors, which arise while testing for the system is carried
    out under test''s acceptance. Increase in the development speed and efficiency
    as well as create accountability for various features of the software are also
    taken into consideration. These benefits can be summarized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Pinpoint application failure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reduced error rate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide automation and reusability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a test audit trail
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pinpoint application failure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Through testing, it is possible for you to identify complete or partial failures
    as well as identify bottlenecks in performance that might have slipped during
    development or in other forms of testing.
  prefs: []
  type: TYPE_NORMAL
- en: Reducing the error rate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Through automation, the predetermined steps involved to run the program can
    be performed exactly as desired with no interference as well as no extra or erroneous
    user interactions. This is different from monkey testing as in acceptance testing;
    only the happy path scenario is to be dealt with.
  prefs: []
  type: TYPE_NORMAL
- en: Providing automation and re-use
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Testers or any other human resources are expensive than computation cycles.
    So it is best to automate the repetitive tasks, which will also reduce time that
    is normally spent in typing, clicking, and digesting the user interface as well
    by the test user. Furthermore, test can be reused or iterated over, which reduces
    the amount of tests while making sure that the complete acceptance testing remains
    while you can focus on other problems.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the a test audit trail
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By keeping a record of various test results, you can gather interesting facts
    about acceptance testing such as how much of the system under test is covered
    under acceptance tests as well as how many failures were reported. This can be
    useful in changing management as well as re-engineering/modernization of the existing
    software.
  prefs: []
  type: TYPE_NORMAL
- en: What is the Robot Framework?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Robot Framework is an open source, general purpose test automation framework
    used for acceptance testing and streamlines it into mainstream development, giving
    rise to the concept of **acceptance test driven development** (**ATDD**). While
    commercial and in-house automated testing tools have been used traditionally to
    provide this kind of test automation. It suffers from the problem of reinventing
    the wheel and vendor lock-in as well as lack of flexibility to use tests with
    different software and under different circumstances. It stands out from other
    tools used for the same purpose by working on easy-to-use tabular test files that
    provide different approaches towards test creation. As different projects require
    acceptance testing in various ways, there is a need to make tests flexible, as
    the Robot Framework is flexible and extensible enough for handling these scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: It is the extensible nature of the tool that makes it so versatile that it can
    be adjusted into different scenarios and used with different software backend.
    While it is most popularly used with selenium as a website automation tool, it
    can also be used with image-based testing software like **sikuli** and also with
    software that require remote access over multiple machines while only running
    the tests over a given machine. All of these can be made easily available through
    creation of custom libraries, which link up the Robot Framework configuration
    code keywords with tasks associated with whatever software the Robot Framework
    is using. On the other hand, the output that the framework produces can also be
    used in multiple ways, first of which is the HTML report and log file that not
    only produces a XUnit styled output, but also contains test operations in detail
    while signifying the execution order and test hierarchy of entire tests. This
    contrasts with the optional `.xml` generation that can be useful in further manipulation
    of the processes. One such example is creation of customized programs that use
    the information obtained by running tests to create a wide variety of results.
    Another example is the log files' subsequent use in continuous delivery environments
    that can allow a build to continue or fail based on all the individual acceptance
    tests which are in use.
  prefs: []
  type: TYPE_NORMAL
- en: It was created by *Pekka Klärck* as part of his master's thesis ([http://eliga.fi/Thesis-Pekka-Laukkanen.pdf](http://http://eliga.fi/Thesis-Pekka-Laukkanen.pdf))
    and was developed within Nokia Siemens Networks in 2005\. Its second version has
    been open sourced under Apache License, Version 2 since 2008 and has an active
    community of volunteers. It is available at [http://code.google.com/p/robotframework](http://code.google.com/p/robotframework).
  prefs: []
  type: TYPE_NORMAL
- en: The Robot Framework ecosystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following diagram presents a conceptual, high-level overview of the framework,
    and offers an insight into various components involved:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Robot Framework ecosystem](img/3033_01_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This can be explained broadly as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tests & Test Data**: This is the configuration of the tests, the closest
    to what most testers of the framework will be. It comprises test and data files
    and folders as well as the contents of those which dictate the test execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test Results**: These are the end products of the tests, which are used to
    determine the results of tests as well as logs that can be used to assess various
    portions of the test.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Robot Framework**: This is the core framework that performs the actual heavy
    lifting to get things done.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test tool driver**: This provides communication between the framework and
    the actual tools in place. It can be custom-tailored to meet specific requirements
    by the testing tool in place.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testing Tool**: This is the actual software that is used to perform acceptance
    testing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**End Application (System under test)**: This is the actual software that is
    to be tested for usability for its acceptance by the client or the end user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing and setting up the Robot Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The current version of the Robot Framework requires Python 2.7 for setup.
  prefs: []
  type: TYPE_NORMAL
- en: As of now, only pybot script gets created from a Python environment. In case
    of other environments, only the corresponding execution script gets created. If
    you happen to have multiple environments, then installation of different scripts
    is also possible. This differs from the previous versions where on installation,
    both pybot and jybot scripts were installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'For custom installation, you will require Python, Jython, or Ironpython pre-installed;
    and environment `PATH` variable set correctly as the Robot Framework will use
    the first Python binary available on `PATH` or the exact library if supplied with
    the python command. You can verify this from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: On the project downloads page, there are various options, listed here under
    the following self-explanatory headings.
  prefs: []
  type: TYPE_NORMAL
- en: Source installation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use the source, you can either download the zip containing sources or clone
    the project using mercurial hg clone: [https://code.google.com/p/robotframework](https://code.google.com/p/robotframework).'
  prefs: []
  type: TYPE_NORMAL
- en: This will clone the project in the current directory and then you can either
    straightaway install the project, or make some modifications for customizing the
    framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now go to the folder where source is checked out/unzipped and perform the following
    commands based upon the environment present:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command installs the Python based version with pybot and rebot
    runner scripts.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command installs the Jython based version, with jybot and jyrebot
    scripts.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command installs the Ironpython based runtime with ipybot and
    ipyrebot scripts.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you see this folder, along with standard `setup.py,` there is another file,
    `install.py`, that can be used to install (it is the similar as installation from
    `setup.py`), reinstall, or uninstall the framework that can be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: To install with Jython or IronPython, replace `python` with `jython` or `ipy`
    respectively in the command. You may have to use `sudo/run` console as administrator
    if you run into any authentication errors, depending upon the user privileges.
  prefs: []
  type: TYPE_NORMAL
- en: '![Source installation](img/3033_01_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Installing from source with python
  prefs: []
  type: TYPE_NORMAL
- en: One-click graphical installer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you happen to be running Windows XP (32-bit), than you will want to use the
    one-click installer that installs the Robot Framework as well as Python and optionally,
    Jython and sets the paths without requiring any intervention. Other graphical
    installers for windows also exist in 32 and 64 bit versions.
  prefs: []
  type: TYPE_NORMAL
- en: Java environment installation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can use the standalone jar that contains a bundled Jython as well as the
    framework. You just need to have Java installed on your system to execute the
    runnable jar for its installation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this method, instead of a command, the jar file is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The Python package installation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The pip install mechanism only requires, you to have the Python and package
    managers such as `easy_install` or `pip` installed on your computer. To install
    this, you just have to type `pip install robotframework` or `easy_install robotframework`
    from the command prompt and the Python based Robot Framework gets installed.
  prefs: []
  type: TYPE_NORMAL
- en: Note that, for Python to run correctly, you'll need `elementtree` module as
    the default one is already broken.
  prefs: []
  type: TYPE_NORMAL
- en: The user can install more than one environment simultaneously on a computer
    and use the specified commands separately without affecting either of the installations.
  prefs: []
  type: TYPE_NORMAL
- en: Support for different runtimes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Robot Framework not only works on the native python (`CPython/pypy` installations
    ), but also supports Java and .NET based runtimes in the form of Jython and ironpython
    respectively. While there are some features that are exclusive to native Python-or
    Jython-based Robot Framework installations, most of the functionality is equivalent
    on all the runtimes. As people might have different OS and application software
    a stack setup according to their needs or desires, so they can integrate this
    tool in their existing runtime without requiring a separate runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Based upon the installer environment used, the Robot Framework will create
    appropriate startup and post-processing scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Environment | Startup command | Post-processing command |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Python | `pybot` | `rebot` |'
  prefs: []
  type: TYPE_TB
- en: '| Jython | `jybot` | `jyrebot` |'
  prefs: []
  type: TYPE_TB
- en: '| Iron Python | `ipybot` | `ipyrebot` |'
  prefs: []
  type: TYPE_TB
- en: 'In addition to these commands used in starting the execution, the Robot Framework
    can directly be started through the `robot.run` module itself if the standard
    Robot Framework is installed. This can also be used instead of the standard commands
    as the commands also call the module internally. The module can be called if the
    Python command in use is the one that has the Robot Framework installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This is handy if the Robot Framework is called by some the Python script. Instead
    of executing the scripts separately, you can call the framework from inside the
    same program easily.
  prefs: []
  type: TYPE_NORMAL
- en: The post processing command is useful to recreate test executions in the long
    run. After the test has been executed, you can save the XML file generated as
    output without saving any other file. To recreate the report and log files again
    in future, the `rebot` command can be used which takes the XML file as an argument
    and results in the generation of the log and report files without recalling or
    running the actual tests again.
  prefs: []
  type: TYPE_NORMAL
- en: Command details
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Pybot` command provides the following major options:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Options | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `-N --name <name>` | Sets the name of topmost test suite in the test hierarchy—thereby
    effectively customizes those areas. |'
  prefs: []
  type: TYPE_TB
- en: '| `-D --doc <documentation>` | Sets the documentation of the top level test
    suite. |'
  prefs: []
  type: TYPE_TB
- en: '| `-M --metadata [name:value]` | Sets the metadata of the top level test suite.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `-G --settag <tagname>` | Sets the given tag to all executed test cases.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `-t --test name` | Selects the test cases available by performing a pattern
    match against them. |'
  prefs: []
  type: TYPE_TB
- en: '| `-s --suite name` | Selects the specified test suite by its name and also
    allows for the test reports to have the desired name instead of the name picked
    up by file/folder name. |'
  prefs: []
  type: TYPE_TB
- en: '| `-i --include tag` | Selects a test for execution on the basis of its tag
    name. |'
  prefs: []
  type: TYPE_TB
- en: '| `-e --exclude tag` | Opposite of include tag. |'
  prefs: []
  type: TYPE_TB
- en: '| `-R --runfailed output` | Selected failed tests of earlier test runs have
    another goal. |'
  prefs: []
  type: TYPE_TB
- en: '| `-c --critical tag` | Tests having this tag are considered critical (default
    for all tests). |'
  prefs: []
  type: TYPE_TB
- en: '| `-n --noncritical tag` | Tests having this tag are overridden to be of non-critical
    type. |'
  prefs: []
  type: TYPE_TB
- en: '| `-v --variable name:value` | Set variables in tests, only scalar variables(${})
    are supported. |'
  prefs: []
  type: TYPE_TB
- en: '| `-V --variablefile path` | Specify explicitly the file that contains variables.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `-d --output dir` | Specify the desired directory where resultant files are
    placed. |'
  prefs: []
  type: TYPE_TB
- en: '| `-o --output file` | The generated XML output file. |'
  prefs: []
  type: TYPE_TB
- en: '| `-l --log file` | The generated HTML log file. |'
  prefs: []
  type: TYPE_TB
- en: '| `-r --report file` | The generated HTML log file. |'
  prefs: []
  type: TYPE_TB
- en: '| `-x --xunit file` | xUnit compatible result file (not created by default).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `-b --debugginge rake` | Debug file written during the execution(not created
    by default). |'
  prefs: []
  type: TYPE_TB
- en: '| `-T --timestampoutputs` | Adds timestamp and provides a custom title to all
    output files. |'
  prefs: []
  type: TYPE_TB
- en: '| `-L --Loglevel` | Threshold level for logging and logging and test order
    customization. |'
  prefs: []
  type: TYPE_TB
- en: '| `-W --monitorwidth` | Specify the width of monitor output. |'
  prefs: []
  type: TYPE_TB
- en: '| `-C --monitotcolors` | Specify whether to use color on console or not. |'
  prefs: []
  type: TYPE_TB
- en: '| `-K --monitormarkers` | Specify test success on console for each test that
    passes. |'
  prefs: []
  type: TYPE_TB
- en: '| `-P --pythonpath path` | Additional locations to search test libraries from.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `-E -escape what` | Specify escape characters in console with common representation.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `-A --argumentfile path` | Specify a text file to read more arguments in
    tests. |'
  prefs: []
  type: TYPE_TB
- en: '| `-h -? --help` | Prints detailed help for the command. |'
  prefs: []
  type: TYPE_TB
- en: '| `--version` | Prints the version of the installed Robot Framework. |'
  prefs: []
  type: TYPE_TB
- en: A small exercise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To demonstrate the Robot Framework, we will create a simple dummy application
    as follows:.
  prefs: []
  type: TYPE_NORMAL
- en: Create a folder named `simpleapp`, this will serve as the application root folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside this, create a folder named `testsuites`, this will contain all the test
    configuration files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Within the `testsuites` folder create a file, `Test_Case_1.txt`, with the following
    contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that there are two spaces before and after the log keyword.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now run the project by calling Pybot script and passing the `testsuites` folder
    as an argument. You should get something similar to the following screenshot:![A
    small exercise](img/3033_01_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This confirms that the project has run successfully. You can view the results
    and log from generated HTML pages and perform future calculations over the data
    by using the XML file.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we used a simple log statement, you get a logged message in the out log,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A small exercise](img/3033_01_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The generated XML is also easy-to-read (as shown in the following screenshot),
    which can then be used by any other external tool as an input parameter—thereby
    reducing the human intervention between different stages of testing if this process
    is also automated.
  prefs: []
  type: TYPE_NORMAL
- en: '![A small exercise](img/3033_01_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we studied the need for acceptance test-driven development
    and how can we use the Robot Framework to achieve it. Various methods of installation
    were discussed over the supported platforms namely Python and its ported equivalents
    in form of Jython and Ironpython. We then proceed with exploring various commands
    that are available to perform various tasks as well as their possibilities. Later
    we created and run a basic test over the Robot Framework that validated the correctness
    of our setup. Lastly we examined the output files generated to get a look and
    feel of the framework.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the basics have been covered, it is time for us to learn about the
    syntax, the different available actions, and different files involved in the Robot
    Framework project; which will enable us to write tests with various formats and
    be aware of the various options that are allowable in tests.
  prefs: []
  type: TYPE_NORMAL
