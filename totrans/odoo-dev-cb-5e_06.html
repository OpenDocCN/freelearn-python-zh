<html><head></head><body>
		<div id="_idContainer048">
			<h1 id="_idParaDest-256" class="chapter-number"><a id="_idTextAnchor319"/>6</h1>
			<h1 id="_idParaDest-257"><a id="_idTextAnchor320"/>Managing Module Data</h1>
			<p>In Odoo, managing module data involves various tasks such as creating, updating, and deleting records in a database upon installation, upgrade, or removal of a module. This is typically<a id="_idIndexMarker357"/> done through XML files called <span class="No-Break">data files.</span></p>
			<p>We’ll study how add-on modules might offer data during installation in this chapter. This helps us when we provide metadata, such as view descriptions, menus, or actions, or when we provide default settings. Another important usage is providing demonstration data, which is loaded when a database is created with the <strong class="bold">Load demonstration data</strong> <span class="No-Break">checkbox checked.</span></p>
			<p>In this chapter, we will cover the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>Using external IDs <span class="No-Break">and namespaces</span></li>
				<li>Loading data using <span class="No-Break">XML files</span></li>
				<li>Using the <strong class="source-inline">noupdate</strong> and <span class="No-Break"><strong class="source-inline">forcecreate</strong></span><span class="No-Break"> flags</span></li>
				<li>Loading data using <span class="No-Break">CSV files</span></li>
				<li>Add-on updates and <span class="No-Break">data migration</span></li>
				<li>Deleting records from <span class="No-Break">XML files</span></li>
				<li>Invoking functions from <span class="No-Break">XML files</span></li>
			</ul>
			<h1 id="_idParaDest-258"><a id="_idTextAnchor321"/>Technical requirements</h1>
			<p>The technical requirements for this chapter include the online <span class="No-Break">Odoo platform.</span></p>
			<p>All the code that’s used in this chapter can be downloaded from the following GitHub <span class="No-Break">repository: </span><a href="https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter06"><span class="No-Break">https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter06</span></a><span class="No-Break">.</span></p>
			<p>In order to avoid repeating a lot of code, we’ll make use of the models that were defined in <a href="B20997_04.xhtml#_idTextAnchor118"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, <em class="italic">Application Models</em>. To follow these examples, make sure you grab the code from the <strong class="source-inline">my_hostel</strong> module <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">Chapter05/my_hostel</strong></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-259"><a id="_idTextAnchor322"/>Using external IDs and namespaces</h1>
			<p>Records in Odoo are identified<a id="_idIndexMarker358"/> using external IDs<a id="_idIndexMarker359"/> or XML IDs. We have utilized XML IDs so far in this book in areas such as views, menus, and actions, but we still don’t know what an XML ID is. This recipe will give you more clarity <span class="No-Break">about it.</span></p>
			<h2 id="_idParaDest-260"><a id="_idTextAnchor323"/>How to do it...</h2>
			<p>We will write in the already-existing records to demonstrate how to use <span class="No-Break">cross-module references:</span></p>
			<ol>
				<li>Update the manifest file of the <strong class="source-inline">my_hostel</strong> module by registering a data file <span class="No-Break">like this:</span><pre class="source-code">
'data': [
'data/data.xml',
],</pre></li>				<li>Create a new room in the <span class="No-Break"><strong class="source-inline">hostel.room</strong></span><span class="No-Break"> model:</span><pre class="source-code">
&lt;record id="hostel_room" model="hostel.room"&gt;
&lt;field name="name"&gt; Hostel Room 01 &lt;/field&gt;
&lt;/record&gt;</pre></li>				<li>Change the name of the <span class="No-Break">main company:</span><pre class="source-code">
&lt;record id="base.main_company" model="res.company"&gt;
&lt;field name="name"&gt;Packt Publishing&lt;/field&gt;
&lt;/record&gt;</pre></li>			</ol>
			<p>Install the module to apply the changes. After installation, a new record for the <strong class="source-inline">Hostel Room 01</strong> room will be created, and the company will be renamed <span class="No-Break"><strong class="source-inline">Packt Publishing</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-261"><a id="_idTextAnchor324"/>How it works...</h2>
			<p>An XML ID is a string<a id="_idIndexMarker360"/> that refers <a id="_idIndexMarker361"/>to a record in<a id="_idIndexMarker362"/> the database. The IDs themselves are records of their <strong class="source-inline">ir.model.data</strong> model. This model includes information such as the module name that declares the XML ID, the ID string, the referred model, and the <span class="No-Break">referred ID.</span></p>
			<p>Every time we use an XML ID on a <strong class="source-inline">&lt;record&gt;</strong> tag, Odoo checks whether the string is namespaced (that is, whether it contains exactly one dot), and if not, it adds the current module name as a namespace. Then, it looks up whether there is already a record in <strong class="source-inline">ir.model.data</strong> with the specified name. If so, an <strong class="source-inline">UPDATE</strong> statement for the listed fields is executed; if not, a <strong class="source-inline">CREATE</strong> statement is executed. This is how you can provide partial data when a record already exists, as we <span class="No-Break">did earlier.</span></p>
			<p>In the first example of this tutorial, the record has the ID <strong class="source-inline">hostel_room_1</strong>. As it is not namespaced, the final external ID will have a module name like this – <strong class="source-inline">my_hostel.hostel_room_1</strong>. Then, Odoo will try to find a record for <strong class="source-inline">my_hostel.hostel_room_1</strong>. As Odoo doesn’t have a record for that external ID yet, it will generate a new record in the <span class="No-Break"><strong class="source-inline">hostel.room</strong></span><span class="No-Break"> model.</span></p>
			<p>In the second example, we have used the external ID of the main company, which is <strong class="source-inline">base.main_company</strong>. As its namespace suggests, it is loaded from the base module. As the external ID is already present, instead of creating a record, Odoo will perform the write <strong class="source-inline">(UPDATE)</strong> operation so that the company name will change to <span class="No-Break"><strong class="source-inline">Packt Publishing</strong></span><span class="No-Break">.</span></p>
			<p class="callout-heading">Important note</p>
			<p class="callout">A widespread application for partial data, apart from changing records defined by other modules, is using a shortcut element to create a record conveniently and writing a field on that record, which is not supported by the shortcut element – <strong class="source-inline">&lt;act_window id="my_action" name="My action" model="res.partner" /&gt;&lt;record id="my_action" model="ir.actions.act_window"&gt; &lt;field name="auto_search" </strong><span class="No-Break"><strong class="source-inline">eval="False" /&gt;&lt;/record&gt;</strong></span><span class="No-Break">.</span></p>
			<p>In Odoo, the <strong class="source-inline">ref</strong> function is used to establish relationships between different records within the system. It allows you to create references from one record to another, typically using a <span class="No-Break"><em class="italic">many2one</em></span><span class="No-Break"> relationship.</span></p>
			<p>The <strong class="source-inline">ref</strong> function, as used in the <em class="italic">Loading data using XML files</em> tutorial of this chapter, also adds the current module as a namespace if appropriate but raises an error if the resulting XML ID does not exist already. This also applies to the <strong class="source-inline">id</strong> attribute if it is not <span class="No-Break">namespaced already.</span></p>
			<p>If you want to see the list<a id="_idIndexMarker363"/> of all external<a id="_idIndexMarker364"/> identifiers, start developer mode and open the menu at <strong class="bold">Settings</strong> | <strong class="bold">Technical</strong> | <strong class="bold">Sequence &amp; Identifiers</strong> | <span class="No-Break"><strong class="bold">External Identifiers</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-262"><a id="_idTextAnchor325"/>There’s more…</h2>
			<p>You will probably need to access records with an XML ID from your Python code sooner or later. Use the <strong class="source-inline">self.env.ref()</strong> function in these cases. This returns a browse record (<strong class="source-inline">recordset</strong>) of the referenced record. Note that, here, you always have to pass the full XML ID. Here’s an example of a full XML ID – <strong class="source-inline">&lt;</strong><span class="No-Break"><strong class="source-inline">module_name&gt;.&lt;record_id&gt;</strong></span><span class="No-Break">.</span></p>
			<p>Sooner or later, you’ll probably need to use Python code to retrieve records that have an XML ID. In these circumstances, use the <strong class="source-inline">self.env.ref()</strong> method. This gives you access to the linked record’s browsing record (<strong class="source-inline">recordset</strong>). Keep in mind that you must always pass the complete XML <span class="No-Break">ID here.</span></p>
			<p>You can see the XML ID of any record from the user interface. For that, you need to activate developer mode in Odoo; refer to <a href="B20997_01.xhtml#_idTextAnchor020"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Installing the Odoo Development Environment</em>, to do so. After activating developer mode, open the <strong class="bold">Form</strong> view of the record for which<a id="_idIndexMarker365"/> you want to find out the XML ID. You will see a bug icon in the top bar. From that menu, click on the <strong class="bold">View Metadata</strong> option. See the following screenshot <span class="No-Break">for reference:</span></p>
			<div>
				<div id="_idContainer047" class="IMG---Figure">
					<img src="image/B20997_06_1.jpg" alt="Figure 6.1 – The menu to open a record’s metadata"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 – The menu to open a record’s metadata</p>
			<h2 id="_idParaDest-263"><a id="_idTextAnchor326"/>See also</h2>
			<p>Consult the <em class="italic">Using the noupdate and forcecreate flags</em> tutorial of this chapter to find out why the company’s name is only changed during the installation of <span class="No-Break">the module.</span></p>
			<h1 id="_idParaDest-264"><a id="_idTextAnchor327"/>Loading data using XML files</h1>
			<p>In the previous tutorial, we created<a id="_idIndexMarker366"/> the new room<a id="_idIndexMarker367"/> record with the <strong class="source-inline">hostel_room_1</strong> external identifier. In this tutorial, we will add a different type of data from the XML file. We’ll add a room and an author as demonstration data. We’ll also add a well-known publisher as normal data to <span class="No-Break">our module.</span></p>
			<h2 id="_idParaDest-265"><a id="_idTextAnchor328"/>How to do it...</h2>
			<p>Follow the following steps to create two data XML files and link them in <span class="No-Break"><strong class="source-inline">your__manifest__.py</strong></span><span class="No-Break"> file:</span></p>
			<ol>
				<li>Add a file called <strong class="source-inline">data/demo.xml</strong> to your manifest, in the <span class="No-Break"><strong class="source-inline">demo</strong></span><span class="No-Break"> section:</span><pre class="source-code">
'demo': [
'data/demo.xml',
],</pre></li>				<li>Add the following content to <span class="No-Break">this file:</span><pre class="source-code">
&lt;odoo&gt;
&lt;record id="member_hda" model="res.partner"&gt;
&lt;field name="name"&gt;Husen Daudi&lt;/field&gt;
&lt;/record&gt;
&lt;record id="member_jvo" model="res.partner"&gt;
&lt;field name="name"&gt;Jay Vora&lt;/field&gt;
&lt;/record&gt;
&lt;record id="hostel_room_1" model="hostel.room"&gt;
&lt;field name="name"&gt;Hostel Room 01&lt;/field&gt;
&lt;field name="room_no"&gt;HR001&lt;/field&gt;
&lt;field name="author_ids"
eval="[(6, 0, [ref('author_hda'), ref('author_jvo')])]"
/&gt;
&lt;/record&gt;
&lt;/odoo&gt;</pre></li>				<li>Add a file called <strong class="source-inline">data/data.xml</strong> to your manifest, in the <span class="No-Break"><strong class="source-inline">data</strong></span><span class="No-Break"> section:</span><pre class="source-code">
'data': [
'data/data.xml',
...
],</pre></li>				<li>Add the following XML content to the <span class="No-Break"><strong class="source-inline">data/data.xml</strong></span><span class="No-Break"> file:</span><pre class="source-code">
&lt;odoo&gt;
&lt;record id="res_partner_packt" model="res.partner"&gt;
&lt;field name="name"&gt;Packt Publishing&lt;/field&gt;
&lt;field name="city"&gt;Birmingham&lt;/field&gt;
&lt;field name="country_id" ref="base.uk" /&gt;
&lt;/record&gt;
&lt;/odoo&gt;</pre></li>			</ol>
			<p>When you update<a id="_idIndexMarker368"/> your module<a id="_idIndexMarker369"/> now, you’ll see the publisher we created, and if your database has demo data enabled, as pointed out in <a href="B20997_03.xhtml#_idTextAnchor083"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, <em class="italic">Creating Add-On Odoo Modules</em>, you’ll also find this room and <span class="No-Break">its members.</span></p>
			<h2 id="_idParaDest-266"><a id="_idTextAnchor329"/>How it works...</h2>
			<p>The data XML files uses the <strong class="source-inline">&lt;record&gt;</strong> tag to create a row in the database table. The <strong class="source-inline">&lt;record&gt;</strong> tag has two mandatory attributes, <strong class="source-inline">id</strong> and <strong class="source-inline">model</strong>. For the <strong class="source-inline">id</strong> attribute, consult the <em class="italic">Using external IDs and namespaces</em> tutorial; the <strong class="source-inline">model</strong> attribute refers to a model’s <strong class="source-inline">_name</strong> property. Then, we use the <strong class="source-inline">&lt;field&gt;</strong> element to fill the columns in the database, as defined by the model you named. The model also decides which fields it is mandatory to fill and also defines the default values. In this case, you don’t need to give those fields a <span class="No-Break">value explicitly.</span></p>
			<p>There are two ways<a id="_idIndexMarker370"/> to register<a id="_idIndexMarker371"/> data XML files in a module manifest. The first is with the <strong class="source-inline">data</strong> key and the second is with the <strong class="source-inline">demo</strong> key. The XML files in the <strong class="source-inline">data</strong> key are loaded every time you install or update the module, while XML files with <strong class="source-inline">demo</strong> keys are loaded only if you enabled demo data for <span class="No-Break">your database.</span></p>
			<p>In <em class="italic">step 1</em>, we registered a <strong class="source-inline">data XML</strong> file in the manifest with the <strong class="source-inline">demo</strong> key. Because we are using the demo key, the <strong class="source-inline">XML</strong> file will be loaded only if you have enabled demo data for <span class="No-Break">the database.</span></p>
			<p>In <em class="italic">step 2</em>, the <strong class="source-inline">&lt;field&gt;</strong> element can contain a value as simple text in the case of scalar values. If you need to pass the content of a file (to set an image, for example), use the <strong class="source-inline">file</strong> attribute on the <strong class="source-inline">&lt;field&gt;</strong> element and pass the file’s name relative to the <span class="No-Break">add-ons path.</span></p>
			<p>To set up references, there are two possibilities. The simplest is using the <strong class="source-inline">ref</strong> attribute, which works for <em class="italic">many2one</em> fields and just contains the XML ID of the record to be referenced. For <em class="italic">one2many</em> and <em class="italic">many2many</em> fields, we need to use the <strong class="source-inline">eval</strong> attribute. Use the <strong class="source-inline">eval</strong> attribute in XML to evaluate expressions dynamically. This is a general-purpose attribute that can be used to evaluate Python code to use as the field’s value. Normally, content within <strong class="source-inline">&lt;field&gt;</strong> tags is treated as strings – for example, <strong class="source-inline">&lt;field name="value"&gt;4.5&lt;/field&gt;</strong>. This will evaluate to the string <strong class="source-inline">4.5</strong> and not <strong class="source-inline">float</strong>. If you want to evaluate the value to a float, a Boolean, or another type, except <strong class="source-inline">string</strong>, you need to use the eval attribute, such as <strong class="source-inline">&lt;field name="value" eval="4.5" /&gt; &lt;field name="value" </strong><span class="No-Break"><strong class="source-inline">eval="False" /&gt;</strong></span><span class="No-Break">.</span></p>
			<p>Here’s another example – think of <strong class="source-inline">strftime('%Y-01-01')</strong> as a way to populate a <strong class="source-inline">date</strong> field. <strong class="source-inline">X2many</strong> fields expect to be populated by a list of three tuples, where the first value of the tuple determines the operation to be carried out. Within an <strong class="source-inline">eval</strong> attribute, we have access to a function called <strong class="source-inline">ref</strong>, which returns the database ID of an XML ID, given as a string. This allows us to refer to a record without knowing its concrete ID, which is probably different in different databases, a<a id="_idTextAnchor330"/>s <span class="No-Break">shown here:</span></p>
			<ul>
				<li><strong class="source-inline">(2, id, False)</strong>: This deletes the linked record with <strong class="source-inline">id</strong> from the database. The third element of the tuple <span class="No-Break">is ignored.</span></li>
				<li><strong class="source-inline">(3, id, False)</strong>: This detaches the record with <strong class="source-inline">id</strong> from the <strong class="source-inline">one2many</strong> field. Note that this operation does not delete the record – it just leaves the existing record as it is. The last element of the tuple is <span class="No-Break">also ignored.</span></li>
				<li><strong class="source-inline">(4, id, False)</strong>: This adds a link to the existing record <strong class="source-inline">id</strong>, and the last element of the tuple is ignored. This should be what you use most of the time, usually accompanied by the <strong class="source-inline">ref</strong> function to get the database ID of a record known by its <span class="No-Break">XML ID.</span></li>
				<li><strong class="source-inline">(5, False, False)</strong>: This cuts all links but keeps the linked <span class="No-Break">records intact.</span></li>
				<li><strong class="source-inline">(6, False, [id, ...])</strong>: This clears out currently referenced records to replace them with the ones mentioned in the list of IDs. The second <a id="_idIndexMarker372"/>element of the tuple<a id="_idIndexMarker373"/> <span class="No-Break">is ignored.</span></li>
			</ul>
			<p class="callout-heading">Important note</p>
			<p class="callout">Note that order matters in data files and that records within data files can only refer to records defined in data files earlier in the list. This is why you should always check whether your module installs in an empty database because, during development, you often add records all over the place, and the records defined afterward are already in the database from an <span class="No-Break">earlier update.</span></p>
			<p class="callout">Demo data is always loaded after the files from the <strong class="source-inline">data</strong> key, which is why the reference in this <span class="No-Break">example works.</span></p>
			<h2 id="_idParaDest-267"><a id="_idTextAnchor331"/>There’s more...</h2>
			<p>While you can do basically anything with the <strong class="source-inline">record</strong> element, there are shortcut elements that make it more convenient for a developer to create certain kinds of records. These include menu items, templates, and act windows. Refer to <a href="B20997_09.xhtml#_idTextAnchor446"><span class="No-Break"><em class="italic">Chapter 9</em></span></a>, <em class="italic">Backend Views</em>, and <a href="B20997_14.xhtml#_idTextAnchor734"><span class="No-Break"><em class="italic">Chapter 14</em></span></a>, <em class="italic">CMS Website Development</em>, for more information <span class="No-Break">about these.</span></p>
			<p>A <strong class="source-inline">field</strong> element can also contain the <strong class="source-inline">function</strong> element, which calls a function defined on a model to provide a field’s value. Refer to the <em class="italic">Invoking functions from XML files</em> tutorial for an application in which we simply call a function to directly write to the database, circumventing the <span class="No-Break">loading mechanism.</span></p>
			<p>The preceding list misses entries for <strong class="source-inline">0</strong> and <strong class="source-inline">1</strong> because they are not very useful when loading the data. They are entered, as follows, for the sake <span class="No-Break">of completeness:</span></p>
			<ul>
				<li><strong class="source-inline">(0, False, {'key': value})</strong>: This creates a new record of the referenced model, with its fields filled from the dictionary at position three. The second element of the tuple is ignored. As these records don’t have an XML ID and are evaluated every time the module is updated, leading to double entries, it’s better to avoid this. Instead, create the record in its own record element, and link it as explained in the <em class="italic">How it works…</em> section of <span class="No-Break">this tutorial.</span></li>
				<li><strong class="source-inline">(1, id, {'key': value})</strong>: This can be used to write on an existing linked record. For the same reasons that we mentioned earlier, you should avoid this syntax in your <span class="No-Break">XML files.</span></li>
			</ul>
			<p>These syntaxes are the same as the ones we explained in the <em class="italic">Creating new records</em> and <em class="italic">Updating values of records</em> tutorials in <a href="B20997_05.xhtml#_idTextAnchor238"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, <em class="italic">Basic </em><span class="No-Break"><em class="italic">Server-Side Development</em></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-268"><a id="_idTextAnchor332"/>Using the noupdate and forcecreate flags</h1>
			<p>Most add-on modules<a id="_idIndexMarker374"/> have different types<a id="_idIndexMarker375"/> of data. Some data simply needs to exist for the module to work properly, other data shouldn’t be changed by the user, and most data can be changed as the user wants and is only provided as a convenience. This tutorial will detail how to address the different types. First, we’ll write a field in an already-existing record, and then we’ll create a record that is supposed to be recreated during a <span class="No-Break">module update.</span></p>
			<h2 id="_idParaDest-269"><a id="_idTextAnchor333"/>How to do it...</h2>
			<p>We can enforce different behaviors from Odoo when loading data by setting certain attributes on the enclosing <strong class="source-inline">&lt;odoo&gt;</strong> element, or the <strong class="source-inline">&lt;record&gt;</strong> <span class="No-Break">element itself:</span></p>
			<ol>
				<li>Add a publisher that will be created at installation time but not updated on subsequent updates. However, if the user deletes it, it will <span class="No-Break">be recreated:</span><pre class="source-code">
&lt;odoo noupdate="1"&gt;
    &lt;record id="res_partner_packt" model="res.partner"&gt;
        &lt;field name="name"&gt;Packt Publishing&lt;/field&gt;
        &lt;field name="city"&gt;Birmingham&lt;/field&gt;
        &lt;field name="country_id" ref="base.uk"/&gt;
    &lt;/record&gt;
&lt;/odoo&gt;</pre></li>				<li>Add a <strong class="source-inline">room</strong> category that<a id="_idIndexMarker376"/> is not changed<a id="_idIndexMarker377"/> during add-on updates and is not recreated if the user <span class="No-Break">deletes it:</span><pre class="source-code">
&lt;odoo noupdate="1"&gt;
    &lt;record id="room_category_all" model="hoste<a id="_idTextAnchor334"/>l.room.category"
            forcecreate="false"&gt;
        &lt;field name="name"&gt;All rooms&lt;/field&gt;
    &lt;/record&gt;
&lt;/odoo&gt;</pre></li>			</ol>
			<h2 id="_idParaDest-270"><a id="_idTextAnchor335"/>How it works...</h2>
			<p>The <strong class="source-inline">&lt;odoo&gt;</strong> element can have a <strong class="source-inline">noupdate</strong> attribute, which is propagated to the <strong class="source-inline">ir.model.data</strong> records that are created when reading the enclosed data records for the first time, thus ending up as a column in <span class="No-Break">this table.</span></p>
			<p>When Odoo installs an add-on (called <strong class="source-inline">init</strong> mode), all records are written, whether <strong class="source-inline">noupdate</strong> is <strong class="source-inline">true</strong> or <strong class="source-inline">false</strong>. When you update an add-on (called <strong class="source-inline">update</strong> mode), the existing XML IDs are checked to see whether they have the <strong class="source-inline">noupdate</strong> flag set, and if so, elements that try to write to this XML ID are ignored. This is not the case if the record in question was deleted by the user, which is why you can force <strong class="source-inline">notrecreate</strong> <strong class="source-inline">noupdate</strong> records in <strong class="source-inline">update</strong> mode<a id="_idIndexMarker378"/> by setting the <strong class="source-inline">forcecreate</strong> flag on the record<a id="_idIndexMarker379"/> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">false</strong></span><span class="No-Break">.</span></p>
			<p class="callout-heading">Important note</p>
			<p class="callout">In legacy add-ons (prior to and including version 8.0), you’ll often find an <strong class="source-inline">&lt;openerp&gt;</strong> element enclosing a <strong class="source-inline">&lt;data&gt;</strong> element, which contains <strong class="source-inline">&lt;record&gt; </strong>and other elements. This is still possible but deprecated. Now, <strong class="source-inline">&lt;odoo&gt;</strong>, <strong class="source-inline">&lt;openerp&gt;</strong>, and <strong class="source-inline">&lt;data&gt;</strong> have exactly the same semantics; they are meant as a bracket to enclose <span class="No-Break">XML data.</span></p>
			<h2 id="_idParaDest-271"><a id="_idTextAnchor336"/>There’s more...</h2>
			<p>If you want to load records even with the <strong class="source-inline">noupdate</strong> flag, you can run the Odoo server with the <strong class="source-inline">--init=your_addon</strong> or <strong class="source-inline">-i your_addon</strong> parameter. This will force Odoo to reload your records. However, this will also cause deleted records to be recreated. Note that this can cause double records and related installation errors if a module circumvents the XML ID mechanism – for example, by creating records in Python code called by the <strong class="source-inline">&lt;</strong><span class="No-Break"><strong class="source-inline">function&gt;</strong></span><span class="No-Break"> tag.</span></p>
			<p>With this code, you can circumvent any <strong class="source-inline">noupdate</strong> flag, but first, make sure that this is really what you want. Another option to solve the scenario presented here is to write a migration script, as outlined in the <em class="italic">Add-on updates and data </em><span class="No-Break"><em class="italic">migration</em></span><span class="No-Break"> tutorial.</span></p>
			<h2 id="_idParaDest-272"><a id="_idTextAnchor337"/>See also</h2>
			<p>Odoo also uses XML IDs to keep track of which data is to be deleted after an add-on update. If a record has an XML ID from the module’s namespace before the update but the XML ID is not reinstated during the update, the record and its XML ID will be deleted from the database because they’re considered obsolete. For a more in-depth discussion of this mechanism, refer to the <em class="italic">Add-on updates and data </em><span class="No-Break"><em class="italic">migration</em></span><span class="No-Break"> tutorial.</span></p>
			<h1 id="_idParaDest-273"><a id="_idTextAnchor338"/>Loading data using CSV files</h1>
			<p>While you can<a id="_idIndexMarker380"/> do everything<a id="_idIndexMarker381"/> you need to with XML files, this format is not the most convenient when you need to provide larger amounts of data, especially given that many people are more comfortable preprocessing data in Calc or other spreadsheet software. Another advantage of the CSV format is that it is what you get when you use the standard <strong class="source-inline">export</strong> function. In this tutorial, we’ll take a look at importing <span class="No-Break">table-like data.</span></p>
			<h2 id="_idParaDest-274"><a id="_idTextAnchor339"/>How to do it...</h2>
			<p>Traditionally, <strong class="bold">access-control lists</strong> (<strong class="bold">ACLs</strong>) in Odoo are used to manage<a id="_idIndexMarker382"/> record and operation access rights. ACLs specify who can execute particular actions (such as read, write, create, and delete) on specified entries using predefined rules. ACLs are commonly defined in Odoo modules via XML files. For more details on ACLs, check out the ACLs tutorial in <a href="B20997_10.xhtml#_idTextAnchor549"><span class="No-Break"><em class="italic">Chapter 10</em></span></a><em class="italic">, </em><span class="No-Break"><em class="italic">Security Access</em></span></p>
			<p>Add <strong class="source-inline">security/ir.model.access.csv</strong> to your <span class="No-Break">data files:</span></p>
			<pre class="source-code">
'data': [
    ...
    'security/ir.model.access.csv',
],</pre>			<ol>
				<li>Add access security to the module in the <strong class="source-inline">ir.model.data</strong> <span class="No-Break">CSV file:</span><pre class="source-code">
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_hostel_manager,hostel.room.manager,model_hostel_room,group_hostel_manager,1,1,1,1</pre></li>			</ol>
			<p>We now have an ACL that permits hostel managers to read book records, and it also allows them to edit, create, or <span class="No-Break">delete them.</span></p>
			<h2 id="_idParaDest-275"><a id="_idTextAnchor340"/>How it works...</h2>
			<p>You simply drop all your data files into your manifest’s <em class="italic">data</em> list. Odoo will use the file extension to decide which type of file it is. A specialty of CSV files is that their filenames must match the name of the model to be imported – in our case, <strong class="source-inline">ir.model.access</strong>. The first line needs to be a header with column names that match the model’s field <span class="No-Break">names exactly.</span></p>
			<p>For scalar values, you can use a quoted (if necessary, because the string contains quotes or commas itself) or an <span class="No-Break">unquoted string.</span></p>
			<p>When writing <em class="italic">many2one</em> fields with<a id="_idIndexMarker383"/> a CSV file, Odoo first tries to interpret<a id="_idIndexMarker384"/> the column value as an XML ID. If there’s no dot, Odoo adds the current module name as a namespace and looks up the result in <strong class="source-inline">ir.model.data</strong>. If this fails, the model’s <strong class="source-inline">name_search</strong> function is called with the column’s value as a parameter, and the first returned result wins. If this also fails, the line is considered invalid and Odoo raises <span class="No-Break">an error.</span></p>
			<h1 id="_idParaDest-276"><a id="_idTextAnchor341"/>Add-on updates and data migration</h1>
			<p>The data model you choose<a id="_idIndexMarker385"/> when writing <a id="_idIndexMarker386"/>an add-on module might turn out to have some weaknesses, so you may need to adjust it during the life cycle of your add-on module. In order to allow that without a lot of hacks, Odoo supports versioning in add-on modules and running migrations <span class="No-Break">if necessary.</span></p>
			<h2 id="_idParaDest-277"><a id="_idTextAnchor342"/>How to do it...</h2>
			<p>We assume that in an earlier version of our module, the <strong class="source-inline">allocation_date</strong> field was a character field, where people wrote whatever they saw fit as the date. We now realize that we need this field for comparisons and aggregations, which is why we want to change its type <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">Date</strong></span><span class="No-Break">.</span></p>
			<p>Odoo does a great job at type conversions, but in this case, we’re on our own, which is why we need to provide instructions as to how to transform a database with the previous version of our module installed on it, where the current version can run. Let’s try this with the <span class="No-Break">following steps:</span></p>
			<ol>
				<li>Bump the version in your <span class="No-Break"><strong class="source-inline">__manifest__.py</strong></span><span class="No-Break"> file:</span><pre class="source-code">
    'version': '17.0.2.0.1',</pre></li>				<li>Provide the pre-migration code <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">migrations/17.0.1.0.1/pre-migrate.py</strong></span><span class="No-Break">:</span><pre class="source-code">
def migrate(cr, version):
    cr.execute('ALTER TABLE hostel_room RENAME COLUMN allocation_date TO allocation_date_char')</pre></li>				<li>Provide the<a id="_idIndexMarker387"/> post-migration<a id="_idIndexMarker388"/> code <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">migrations/17.0.1.0.1/post-migrate.py</strong></span><span class="No-Break">:</span><pre class="source-code">
from odoo import fields
from datetime import date
def migrate(cr, version):
    cr.execute('SELECT id, allocation_date_char FROM
    hostel_room')
    for record_id, old_date in cr.fetchall():
        # check if the field happens to be set in Odoo's
        internal
        # format
        new_date = None
        try:
            new_date = fields.Date.to_date(old_date)
        except ValueError:
            if len(old_date) == 4 and old_date.isdigit():
                # probably a year
                new_date = date(int(old_date), 1, 1)
        if new_date:
            cr.execute('UPDATE hostel_room SET allocation_date=%s WHERE id=2',
                       (new_date,))</pre></li>			</ol>
			<p>Without this code, Odoo would have renamed the old <strong class="source-inline">allocation_date</strong> column <strong class="source-inline">allocation_date_moved</strong> and created a new one, as there’s no automatic conversion from character fields to date fields. From the point of view of the user, the data in <strong class="source-inline">allocation_date</strong> is <span class="No-Break">simply gone.</span></p>
			<h2 id="_idParaDest-278"><a id="_idTextAnchor343"/>How it works...</h2>
			<p>The first crucial point<a id="_idIndexMarker389"/> is that you increase<a id="_idIndexMarker390"/> the version number of your add-on, as migrations run only between different versions. During every update, Odoo writes the version number from the manifest at the time of the update into the <strong class="source-inline">ir_module_module</strong> table. The version number is prefixed with Odoo’s major and minor versions if the version number has three or fewer components. In the preceding example, we explicitly named Odoo’s major and minor version, which is good practice, but a value of <strong class="source-inline">1.0.1</strong> would have had the same effect because, internally, Odoo prefixes short version numbers for add-ons with its own major and minor version numbers. Generally, using the long notation is a good idea because you can see at a glance which version of Odoo an add-on is <span class="No-Break">meant for.</span></p>
			<p>The two migration files are just code files that don’t need to be registered anywhere. When updating an add-on, Odoo compares the add-on’s version, as noted in <strong class="source-inline">ir_module_module</strong>, with the version in the add-on’s manifest. If the manifest’s version is higher (after adding Odoo’s major and minor version), this add-on’s <strong class="source-inline">migrations</strong> folder will be searched to see whether it contains folders with the version(s) in between, up to and including the version that is <span class="No-Break">currently updated.</span></p>
			<p>Then, within the folders found, Odoo searches for Python files whose names start with <strong class="source-inline">pre-</strong>, loads them, and expects them to define a function called <strong class="source-inline">migrate</strong>, which has two parameters. This function is called with a database cursor as the first argument and the currently installed version as the second argument. This happens before Odoo even looks at the rest of the code that the add-on defines, so you can assume that nothing changes in your database layout compared to the <span class="No-Break">previous version.</span></p>
			<p>After all the <strong class="source-inline">pre-migrate</strong> functions run successfully, Odoo loads the models and the data declared in the add-on, which can cause changes in the database layout. Given that we renamed <strong class="source-inline">date_release in pre-migrate.py</strong>, Odoo will just create a new column with that name but with the correct <span class="No-Break">data type.</span></p>
			<p>After that, with the same search algorithm, the <strong class="source-inline">post-migrate</strong> files will be searched and executed if found. In our case, we need to look at every value to see whether we can make something usable out of it; otherwise, we keep the data as <strong class="source-inline">NULL</strong>. Don’t write scripts that iterate over a whole table if not absolutely necessary; in this case, we would<a id="_idIndexMarker391"/> have written a very big, unr<a id="_idTextAnchor344"/>eadable<a id="_idIndexMarker392"/> <span class="No-Break">SQL switch.</span></p>
			<p class="callout-heading">Important tip</p>
			<p class="callout">If you simply want to rename a column, you don’t need a migration script. In this case, you can set the <strong class="source-inline">oldname</strong> parameter of the field in question to the field’s original column name; Odoo then <a id="_idTextAnchor345"/>takes care of the <span class="No-Break">renaming itself.</span></p>
			<h2 id="_idParaDest-279"><a id="_idTextAnchor346"/>There’s more...</h2>
			<p>In both the pre- and post-migration steps, you only have access to a cursor, which is not very convenient if you’re used to Odoo environments. It can<a id="_idIndexMarker393"/> lead to unexpected results to use models at this<a id="_idIndexMarker394"/> stage because, in the pre-migration step, the add-on’s models are not yet loaded, and also, in the post-migration step, the models defined by add-ons that depend on the current add-on are not yet loaded either. However, if this is not a problem for you, either because you want to use a model that your add-on doesn’t touch or a model for which you know that this issue is not a problem, you can create the environment you’re used to by writing <span class="No-Break">the following:</span></p>
			<pre class="source-code">
from odoo import api, SU<a id="_idTextAnchor347"/>PERUSER_ID
def migrate(cr, version):
    env = api.Environment(cr, SUPERUSER_ID, {})
    # env holds all currently loaded models</pre>			<h2 id="_idParaDest-280"><a id="_idTextAnchor348"/>See also</h2>
			<p>When writing migration scripts, you’ll often be confronted with repetitive tasks, such as checking whether a column or table exists, renaming things, or mapping some old values to new values. It’s frustrating and error-prone to reinvent the wheel here; consider using <a href="https://github.com/OCA/openupgradelib">https://github.com/OCA/openupgradelib</a> if you can afford the <span class="No-Break">extra depende<a id="_idTextAnchor349"/>ncy.</span></p>
			<h1 id="_idParaDest-281"><a id="_idTextAnchor350"/>Deleting records from XML files</h1>
			<p>We learned how<a id="_idIndexMarker395"/> to generate<a id="_idIndexMarker396"/> or change records from the XML file in the previous tutorials. You may occasionally wish to remove the records that have already been created from the dependent module. The <strong class="source-inline">&lt;delete&gt;</strong> tag can <span class="No-Break">be used.</span></p>
			<h2 id="_idParaDest-282"><a id="_idTextAnchor351"/>Getting ready</h2>
			<p>In this tutorial, we will add some categories from the XML file and then delete them. In real situations, you will create this record from another module. But for simplicity, we will just add some catego<a id="_idTextAnchor352"/>ries to the same XML file, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
&lt;record id="room_category_to_remove" model="hostel.room.category"&gt;
    &lt;field name="name"&gt;Single sharing&lt;/field&gt;
&lt;/record&gt;
&lt;record id="room_category_not_remove" model="hostel.room.category"&gt;
    &lt;field name="name"&gt;Double Sharing&lt;/field&gt;
&lt;/record&gt;</pre>			<h2 id="_idParaDest-283"><a id="_idTextAnchor353"/>How to do it...</h2>
			<p>There are two ways to remove records from the <span class="No-Break">XML file:</span></p>
			<ul>
				<li>Using the XML ID of previously <span class="No-Break">created records:</span><pre class="source-code">
&lt;delete model="hostel.room.category" id="room_category_to_remove"/&gt;</pre></li>				<li>With the <span class="No-Break">search domain:</span><pre class="source-code">
&lt;delete model="hostel.room.category" search="[('name', 'ilike', 'Single Room Category')]"/&gt;</pre></li>			</ul>
			<h2 id="_idParaDest-284"><a id="_idTextAnchor354"/>How it works...</h2>
			<p>You will need to use the <strong class="source-inline">&lt;delete&gt;</strong> tag. To remove a record from a model, you need to provide the name of the model in the <strong class="source-inline">model</strong> attribute. This is a <span class="No-Break">mandatory attribute.</span></p>
			<p>The XML IDs of the records that had been generated from the data files of another module must be supplied in the first method. Odoo will look for the record while installing the module. If the specified XML ID matches a record, the record will be deleted; otherwise, an error will be raised. Only records that were generated from XML files (or records with XML IDs) are able to <span class="No-Break">be deleted.</span></p>
			<p>In the second method, you need to pass the domain in the <strong class="source-inline">domain</strong> attribute. During the installation of the module, Odoo will search the records by this domain. If records are found, it deletes them. This option will not raise an error if no records match the given domain. Use this option with extreme caution because it might delete your user’s data, since the search option<a id="_idIndexMarker397"/> deletes all the records that match<a id="_idIndexMarker398"/> <span class="No-Break">the domain.</span></p>
			<p class="callout-heading">Warning</p>
			<p class="callout"><strong class="source-inline">&lt;delete&gt;</strong> is rarely used in Odoo, as it is dangerous. If you are not careful with this, you might<a id="_idTextAnchor355"/> break the system. Avoid it <span class="No-Break">if possible.</span></p>
			<h1 id="_idParaDest-285"><a id="_idTextAnchor356"/>Invoking functions from XML files</h1>
			<p>You can create all types<a id="_idIndexMarker399"/> of records<a id="_idIndexMarker400"/> from XML files, but sometimes, it is difficult to generate data that includes some business logic. You might want to modify records when a user installs a dependent module in production. In this case, you can invoke the <strong class="source-inline">model</strong> method through the <strong class="source-inline">&lt;</strong><span class="No-Break"><strong class="source-inline">function&gt;</strong></span><span class="No-Break"> tag.</span></p>
			<h2 id="_idParaDest-286"><a id="_idTextAnchor357"/>How to do it...</h2>
			<p>For this tutorial, we will use the code from the previous tutorial. As an example, we will increase the existing room price by $10 USD. Note that you might use another currency based on <span class="No-Break">company configurations.</span></p>
			<p>Follow these steps to invoke the Python method from the <span class="No-Break">XML file:</span></p>
			<ol>
				<li>Add the <strong class="source-inline">_update_room_price()</strong> method to the <span class="No-Break"><strong class="source-inline">hostel.room</strong></span><span class="No-Break"> model:</span><pre class="source-code">
@api.model
def _update_room_price(self):
    all_rooms = self.search([])
    for room in all_rooms:
        room.cost_price += 10</pre></li>				<li>Add <strong class="source-inline">&lt;function&gt;</strong> to the data <span class="No-Break">XML file:</span><pre class="source-code">
&lt;function model="hostel.room" name="_update_room_price"/&gt;</pre></li>			</ol>
			<h2 id="_idParaDest-287"><a id="_idTextAnchor358"/>How it works...</h2>
			<p>In <em class="italic">step 1</em>, we added<a id="_idIndexMarker401"/> the <strong class="source-inline">_update_room_price()</strong> method, which searches<a id="_idIndexMarker402"/> for all books and increases the price by $10 USD. We started the method name with <strong class="source-inline">_</strong>, as this is considered private by ORM and cannot be invoked <span class="No-Break">through RPC.</span></p>
			<p>In <em class="italic">step 2</em>, we used the <strong class="source-inline">&lt;function&gt;</strong> tag with <span class="No-Break">two attributes:</span></p>
			<ul>
				<li><strong class="source-inline">model</strong>: The model name with which the method <span class="No-Break">is declared</span></li>
				<li><strong class="source-inline">name</strong>: The name of the method you want <span class="No-Break">to invoke</span></li>
			</ul>
			<p>When you install this module, <strong class="source-inline">_update_room_price()</strong> will be called and the price of books will increase by $<span class="No-Break">10 USD.</span></p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Always use this function with the <strong class="source-inline">noupdate</strong> options. Otherwise, it will be invoked every time you update <span class="No-Break">your module.</span></p>
			<h2 id="_idParaDest-288"><a id="_idTextAnchor359"/>There’s more...</h2>
			<p>With <strong class="source-inline">&lt;function&gt;</strong>, it is also possible<a id="_idIndexMarker403"/> to send parameters to the functions. Let’s say you only want to increase the price of rooms in a particular category and you want to send that amount as <span class="No-Break">a parameter.</span></p>
			<p>To do that, you need to create a method that accepts the catego<a id="_idTextAnchor360"/>ry as a parameter, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
    @api.model
    def update_room_price(self, category, amount_to_increase):
        category_rooms = self.search([('category_id', '=', category.id)])
        for room in category_rooms:
            room.cost_price += amount_to_increase</pre>			<p>To pass the category and amount as a parameter, yo<a id="_idTextAnchor361"/>u need to use the <strong class="source-inline">eval</strong> attribute, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
&lt;function mod<a id="_idTextAnchor362"/>el="hostel.room"
    name="update_room_price"
    eval="(ref('category_xml_id'), 20)"/&gt;</pre>			<p>When you install the module, it will increase the price of the rooms of the given category by $<span class="No-Break">20 USD.</span></p>
		</div>
	</body></html>