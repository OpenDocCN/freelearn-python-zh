<html><head></head><body>
		<div><h1 id="_idParaDest-256" class="chapter-number"><a id="_idTextAnchor319"/>6</h1>
			<h1 id="_idParaDest-257"><a id="_idTextAnchor320"/>Managing Module Data</h1>
			<p>In Odoo, managing module data involves various tasks such as creating, updating, and deleting records in a database upon installation, upgrade, or removal of a module. This is typically<a id="_idIndexMarker357"/> done through XML files called data files.</p>
			<p>We’ll study how add-on modules might offer data during installation in this chapter. This helps us when we provide metadata, such as view descriptions, menus, or actions, or when we provide default settings. Another important usage is providing demonstration data, which is loaded when a database is created with the <strong class="bold">Load demonstration data</strong> checkbox checked.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Using external IDs and namespaces</li>
				<li>Loading data using XML files</li>
				<li>Using the <code>noupdate</code> and <code>forcecreate</code> flags</li>
				<li>Loading data using CSV files</li>
				<li>Add-on updates and data migration</li>
				<li>Deleting records from XML files</li>
				<li>Invoking functions from XML files</li>
			</ul>
			<h1 id="_idParaDest-258"><a id="_idTextAnchor321"/>Technical requirements</h1>
			<p>The technical requirements for this chapter include the online Odoo platform.</p>
			<p>All the code that’s used in this chapter can be downloaded from the following GitHub repository: <a href="https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter06">https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter06</a>.</p>
			<p>In order to avoid repeating a lot of code, we’ll make use of the models that were defined in <a href="B20997_04.xhtml#_idTextAnchor118"><em class="italic">Chapter 4</em></a>, <em class="italic">Application Models</em>. To follow these examples, make sure you grab the code from the <code>my_hostel</code> module from <code>Chapter05/my_hostel</code>.</p>
			<h1 id="_idParaDest-259"><a id="_idTextAnchor322"/>Using external IDs and namespaces</h1>
			<p>Records in Odoo are identified<a id="_idIndexMarker358"/> using external IDs<a id="_idIndexMarker359"/> or XML IDs. We have utilized XML IDs so far in this book in areas such as views, menus, and actions, but we still don’t know what an XML ID is. This recipe will give you more clarity about it.</p>
			<h2 id="_idParaDest-260"><a id="_idTextAnchor323"/>How to do it...</h2>
			<p>We will write in the already-existing records to demonstrate how to use cross-module references:</p>
			<ol>
				<li>Update the manifest file of the <code>my_hostel</code> module by registering a data file like this:<pre class="source-code">
'data': [
'data/data.xml',
],</pre></li>				<li>Create a new room in the <code>hostel.room</code> model:<pre class="source-code">
&lt;record id="hostel_room" model="hostel.room"&gt;
&lt;field name="name"&gt; Hostel Room 01 &lt;/field&gt;
&lt;/record&gt;</pre></li>				<li>Change the name of the main company:<pre class="source-code">
&lt;record id="base.main_company" model="res.company"&gt;
&lt;field name="name"&gt;Packt Publishing&lt;/field&gt;
&lt;/record&gt;</pre></li>			</ol>
			<p>Install the module to apply the changes. After installation, a new record for the <code>Hostel Room 01</code> room will be created, and the company will be renamed <code>Packt Publishing</code>.</p>
			<h2 id="_idParaDest-261"><a id="_idTextAnchor324"/>How it works...</h2>
			<p>An XML ID is a string<a id="_idIndexMarker360"/> that refers <a id="_idIndexMarker361"/>to a record in<a id="_idIndexMarker362"/> the database. The IDs themselves are records of their <code>ir.model.data</code> model. This model includes information such as the module name that declares the XML ID, the ID string, the referred model, and the referred ID.</p>
			<p>Every time we use an XML ID on a <code>&lt;record&gt;</code> tag, Odoo checks whether the string is namespaced (that is, whether it contains exactly one dot), and if not, it adds the current module name as a namespace. Then, it looks up whether there is already a record in <code>ir.model.data</code> with the specified name. If so, an <code>UPDATE</code> statement for the listed fields is executed; if not, a <code>CREATE</code> statement is executed. This is how you can provide partial data when a record already exists, as we did earlier.</p>
			<p>In the first example of this tutorial, the record has the ID <code>hostel_room_1</code>. As it is not namespaced, the final external ID will have a module name like this – <code>my_hostel.hostel_room_1</code>. Then, Odoo will try to find a record for <code>my_hostel.hostel_room_1</code>. As Odoo doesn’t have a record for that external ID yet, it will generate a new record in the <code>hostel.room</code> model.</p>
			<p>In the second example, we have used the external ID of the main company, which is <code>base.main_company</code>. As its namespace suggests, it is loaded from the base module. As the external ID is already present, instead of creating a record, Odoo will perform the write <code>(UPDATE)</code> operation so that the company name will change to <code>Packt Publishing</code>.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">A widespread application for partial data, apart from changing records defined by other modules, is using a shortcut element to create a record conveniently and writing a field on that record, which is not supported by the shortcut element – <code>&lt;act_window id="my_action" name="My action" model="res.partner" /&gt;&lt;record id="my_action" model="ir.actions.act_window"&gt; &lt;field name="auto_search" </code><code>eval="False" /&gt;&lt;/record&gt;</code>.</p>
			<p>In Odoo, the <code>ref</code> function is used to establish relationships between different records within the system. It allows you to create references from one record to another, typically using a <em class="italic">many2one</em> relationship.</p>
			<p>The <code>ref</code> function, as used in the <em class="italic">Loading data using XML files</em> tutorial of this chapter, also adds the current module as a namespace if appropriate but raises an error if the resulting XML ID does not exist already. This also applies to the <code>id</code> attribute if it is not namespaced already.</p>
			<p>If you want to see the list<a id="_idIndexMarker363"/> of all external<a id="_idIndexMarker364"/> identifiers, start developer mode and open the menu at <strong class="bold">Settings</strong> | <strong class="bold">Technical</strong> | <strong class="bold">Sequence &amp; Identifiers</strong> | <strong class="bold">External Identifiers</strong>.</p>
			<h2 id="_idParaDest-262"><a id="_idTextAnchor325"/>There’s more…</h2>
			<p>You will probably need to access records with an XML ID from your Python code sooner or later. Use the <code>self.env.ref()</code> function in these cases. This returns a browse record (<code>recordset</code>) of the referenced record. Note that, here, you always have to pass the full XML ID. Here’s an example of a full XML ID – <code>&lt;</code><code>module_name&gt;.&lt;record_id&gt;</code>.</p>
			<p>Sooner or later, you’ll probably need to use Python code to retrieve records that have an XML ID. In these circumstances, use the <code>self.env.ref()</code> method. This gives you access to the linked record’s browsing record (<code>recordset</code>). Keep in mind that you must always pass the complete XML ID here.</p>
			<p>You can see the XML ID of any record from the user interface. For that, you need to activate developer mode in Odoo; refer to <a href="B20997_01.xhtml#_idTextAnchor020"><em class="italic">Chapter 1</em></a>, <em class="italic">Installing the Odoo Development Environment</em>, to do so. After activating developer mode, open the <strong class="bold">Form</strong> view of the record for which<a id="_idIndexMarker365"/> you want to find out the XML ID. You will see a bug icon in the top bar. From that menu, click on the <strong class="bold">View Metadata</strong> option. See the following screenshot for reference:</p>
			<div><div><img src="img/B20997_06_1.jpg" alt="Figure 6.1 – The menu to open a record’s metadata"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 – The menu to open a record’s metadata</p>
			<h2 id="_idParaDest-263"><a id="_idTextAnchor326"/>See also</h2>
			<p>Consult the <em class="italic">Using the noupdate and forcecreate flags</em> tutorial of this chapter to find out why the company’s name is only changed during the installation of the module.</p>
			<h1 id="_idParaDest-264"><a id="_idTextAnchor327"/>Loading data using XML files</h1>
			<p>In the previous tutorial, we created<a id="_idIndexMarker366"/> the new room<a id="_idIndexMarker367"/> record with the <code>hostel_room_1</code> external identifier. In this tutorial, we will add a different type of data from the XML file. We’ll add a room and an author as demonstration data. We’ll also add a well-known publisher as normal data to our module.</p>
			<h2 id="_idParaDest-265"><a id="_idTextAnchor328"/>How to do it...</h2>
			<p>Follow the following steps to create two data XML files and link them in <code>your__manifest__.py</code> file:</p>
			<ol>
				<li>Add a file called <code>data/demo.xml</code> to your manifest, in the <code>demo</code> section:<pre class="source-code">
'demo': [
'data/demo.xml',
],</pre></li>				<li>Add the following content to this file:<pre class="source-code">
&lt;odoo&gt;
&lt;record id="member_hda" model="res.partner"&gt;
&lt;field name="name"&gt;Husen Daudi&lt;/field&gt;
&lt;/record&gt;
&lt;record id="member_jvo" model="res.partner"&gt;
&lt;field name="name"&gt;Jay Vora&lt;/field&gt;
&lt;/record&gt;
&lt;record id="hostel_room_1" model="hostel.room"&gt;
&lt;field name="name"&gt;Hostel Room 01&lt;/field&gt;
&lt;field name="room_no"&gt;HR001&lt;/field&gt;
&lt;field name="author_ids"
eval="[(6, 0, [ref('author_hda'), ref('author_jvo')])]"
/&gt;
&lt;/record&gt;
&lt;/odoo&gt;</pre></li>				<li>Add a file called <code>data/data.xml</code> to your manifest, in the <code>data</code> section:<pre class="source-code">
'data': [
'data/data.xml',
...
],</pre></li>				<li>Add the following XML content to the <code>data/data.xml</code> file:<pre class="source-code">
&lt;odoo&gt;
&lt;record id="res_partner_packt" model="res.partner"&gt;
&lt;field name="name"&gt;Packt Publishing&lt;/field&gt;
&lt;field name="city"&gt;Birmingham&lt;/field&gt;
&lt;field name="country_id" ref="base.uk" /&gt;
&lt;/record&gt;
&lt;/odoo&gt;</pre></li>			</ol>
			<p>When you update<a id="_idIndexMarker368"/> your module<a id="_idIndexMarker369"/> now, you’ll see the publisher we created, and if your database has demo data enabled, as pointed out in <a href="B20997_03.xhtml#_idTextAnchor083"><em class="italic">Chapter 3</em></a>, <em class="italic">Creating Add-On Odoo Modules</em>, you’ll also find this room and its members.</p>
			<h2 id="_idParaDest-266"><a id="_idTextAnchor329"/>How it works...</h2>
			<p>The data XML files uses the <code>&lt;record&gt;</code> tag to create a row in the database table. The <code>&lt;record&gt;</code> tag has two mandatory attributes, <code>id</code> and <code>model</code>. For the <code>id</code> attribute, consult the <em class="italic">Using external IDs and namespaces</em> tutorial; the <code>model</code> attribute refers to a model’s <code>_name</code> property. Then, we use the <code>&lt;field&gt;</code> element to fill the columns in the database, as defined by the model you named. The model also decides which fields it is mandatory to fill and also defines the default values. In this case, you don’t need to give those fields a value explicitly.</p>
			<p>There are two ways<a id="_idIndexMarker370"/> to register<a id="_idIndexMarker371"/> data XML files in a module manifest. The first is with the <code>data</code> key and the second is with the <code>demo</code> key. The XML files in the <code>data</code> key are loaded every time you install or update the module, while XML files with <code>demo</code> keys are loaded only if you enabled demo data for your database.</p>
			<p>In <em class="italic">step 1</em>, we registered a <code>data XML</code> file in the manifest with the <code>demo</code> key. Because we are using the demo key, the <code>XML</code> file will be loaded only if you have enabled demo data for the database.</p>
			<p>In <em class="italic">step 2</em>, the <code>&lt;field&gt;</code> element can contain a value as simple text in the case of scalar values. If you need to pass the content of a file (to set an image, for example), use the <code>file</code> attribute on the <code>&lt;field&gt;</code> element and pass the file’s name relative to the add-ons path.</p>
			<p>To set up references, there are two possibilities. The simplest is using the <code>ref</code> attribute, which works for <em class="italic">many2one</em> fields and just contains the XML ID of the record to be referenced. For <em class="italic">one2many</em> and <em class="italic">many2many</em> fields, we need to use the <code>eval</code> attribute. Use the <code>eval</code> attribute in XML to evaluate expressions dynamically. This is a general-purpose attribute that can be used to evaluate Python code to use as the field’s value. Normally, content within <code>&lt;field&gt;</code> tags is treated as strings – for example, <code>&lt;field name="value"&gt;4.5&lt;/field&gt;</code>. This will evaluate to the string <code>4.5</code> and not <code>float</code>. If you want to evaluate the value to a float, a Boolean, or another type, except <code>string</code>, you need to use the eval attribute, such as <code>&lt;field name="value" eval="4.5" /&gt; &lt;field name="value" </code><code>eval="False" /&gt;</code>.</p>
			<p>Here’s another example – think of <code>strftime('%Y-01-01')</code> as a way to populate a <code>date</code> field. <code>X2many</code> fields expect to be populated by a list of three tuples, where the first value of the tuple determines the operation to be carried out. Within an <code>eval</code> attribute, we have access to a function called <code>ref</code>, which returns the database ID of an XML ID, given as a string. This allows us to refer to a record without knowing its concrete ID, which is probably different in different databases, a<a id="_idTextAnchor330"/>s shown here:</p>
			<ul>
				<li><code>(2, id, False)</code>: This deletes the linked record with <code>id</code> from the database. The third element of the tuple is ignored.</li>
				<li><code>(3, id, False)</code>: This detaches the record with <code>id</code> from the <code>one2many</code> field. Note that this operation does not delete the record – it just leaves the existing record as it is. The last element of the tuple is also ignored.</li>
				<li><code>(4, id, False)</code>: This adds a link to the existing record <code>id</code>, and the last element of the tuple is ignored. This should be what you use most of the time, usually accompanied by the <code>ref</code> function to get the database ID of a record known by its XML ID.</li>
				<li><code>(5, False, False)</code>: This cuts all links but keeps the linked records intact.</li>
				<li><code>(6, False, [id, ...])</code>: This clears out currently referenced records to replace them with the ones mentioned in the list of IDs. The second <a id="_idIndexMarker372"/>element of the tuple<a id="_idIndexMarker373"/> is ignored.</li>
			</ul>
			<p class="callout-heading">Important note</p>
			<p class="callout">Note that order matters in data files and that records within data files can only refer to records defined in data files earlier in the list. This is why you should always check whether your module installs in an empty database because, during development, you often add records all over the place, and the records defined afterward are already in the database from an earlier update.</p>
			<p class="callout">Demo data is always loaded after the files from the <code>data</code> key, which is why the reference in this example works.</p>
			<h2 id="_idParaDest-267"><a id="_idTextAnchor331"/>There’s more...</h2>
			<p>While you can do basically anything with the <code>record</code> element, there are shortcut elements that make it more convenient for a developer to create certain kinds of records. These include menu items, templates, and act windows. Refer to <a href="B20997_09.xhtml#_idTextAnchor446"><em class="italic">Chapter 9</em></a>, <em class="italic">Backend Views</em>, and <a href="B20997_14.xhtml#_idTextAnchor734"><em class="italic">Chapter 14</em></a>, <em class="italic">CMS Website Development</em>, for more information about these.</p>
			<p>A <code>field</code> element can also contain the <code>function</code> element, which calls a function defined on a model to provide a field’s value. Refer to the <em class="italic">Invoking functions from XML files</em> tutorial for an application in which we simply call a function to directly write to the database, circumventing the loading mechanism.</p>
			<p>The preceding list misses entries for <code>0</code> and <code>1</code> because they are not very useful when loading the data. They are entered, as follows, for the sake of completeness:</p>
			<ul>
				<li><code>(0, False, {'key': value})</code>: This creates a new record of the referenced model, with its fields filled from the dictionary at position three. The second element of the tuple is ignored. As these records don’t have an XML ID and are evaluated every time the module is updated, leading to double entries, it’s better to avoid this. Instead, create the record in its own record element, and link it as explained in the <em class="italic">How it works…</em> section of this tutorial.</li>
				<li><code>(1, id, {'key': value})</code>: This can be used to write on an existing linked record. For the same reasons that we mentioned earlier, you should avoid this syntax in your XML files.</li>
			</ul>
			<p>These syntaxes are the same as the ones we explained in the <em class="italic">Creating new records</em> and <em class="italic">Updating values of records</em> tutorials in <a href="B20997_05.xhtml#_idTextAnchor238"><em class="italic">Chapter 5</em></a>, <em class="italic">Basic </em><em class="italic">Server-Side Development</em>.</p>
			<h1 id="_idParaDest-268"><a id="_idTextAnchor332"/>Using the noupdate and forcecreate flags</h1>
			<p>Most add-on modules<a id="_idIndexMarker374"/> have different types<a id="_idIndexMarker375"/> of data. Some data simply needs to exist for the module to work properly, other data shouldn’t be changed by the user, and most data can be changed as the user wants and is only provided as a convenience. This tutorial will detail how to address the different types. First, we’ll write a field in an already-existing record, and then we’ll create a record that is supposed to be recreated during a module update.</p>
			<h2 id="_idParaDest-269"><a id="_idTextAnchor333"/>How to do it...</h2>
			<p>We can enforce different behaviors from Odoo when loading data by setting certain attributes on the enclosing <code>&lt;odoo&gt;</code> element, or the <code>&lt;record&gt;</code> element itself:</p>
			<ol>
				<li>Add a publisher that will be created at installation time but not updated on subsequent updates. However, if the user deletes it, it will be recreated:<pre class="source-code">
&lt;odoo noupdate="1"&gt;
    &lt;record id="res_partner_packt" model="res.partner"&gt;
        &lt;field name="name"&gt;Packt Publishing&lt;/field&gt;
        &lt;field name="city"&gt;Birmingham&lt;/field&gt;
        &lt;field name="country_id" ref="base.uk"/&gt;
    &lt;/record&gt;
&lt;/odoo&gt;</pre></li>				<li>Add a <code>room</code> category that<a id="_idIndexMarker376"/> is not changed<a id="_idIndexMarker377"/> during add-on updates and is not recreated if the user deletes it:<pre class="source-code">
&lt;odoo noupdate="1"&gt;
    &lt;record id="room_category_all" model="hoste<a id="_idTextAnchor334"/>l.room.category"
            forcecreate="false"&gt;
        &lt;field name="name"&gt;All rooms&lt;/field&gt;
    &lt;/record&gt;
&lt;/odoo&gt;</pre></li>			</ol>
			<h2 id="_idParaDest-270"><a id="_idTextAnchor335"/>How it works...</h2>
			<p>The <code>&lt;odoo&gt;</code> element can have a <code>noupdate</code> attribute, which is propagated to the <code>ir.model.data</code> records that are created when reading the enclosed data records for the first time, thus ending up as a column in this table.</p>
			<p>When Odoo installs an add-on (called <code>init</code> mode), all records are written, whether <code>noupdate</code> is <code>true</code> or <code>false</code>. When you update an add-on (called <code>update</code> mode), the existing XML IDs are checked to see whether they have the <code>noupdate</code> flag set, and if so, elements that try to write to this XML ID are ignored. This is not the case if the record in question was deleted by the user, which is why you can force <code>notrecreate</code> <code>noupdate</code> records in <code>update</code> mode<a id="_idIndexMarker378"/> by setting the <code>forcecreate</code> flag on the record<a id="_idIndexMarker379"/> to <code>false</code>.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">In legacy add-ons (prior to and including version 8.0), you’ll often find an <code>&lt;openerp&gt;</code> element enclosing a <code>&lt;data&gt;</code> element, which contains <code>&lt;record&gt; </code>and other elements. This is still possible but deprecated. Now, <code>&lt;odoo&gt;</code>, <code>&lt;openerp&gt;</code>, and <code>&lt;data&gt;</code> have exactly the same semantics; they are meant as a bracket to enclose XML data.</p>
			<h2 id="_idParaDest-271"><a id="_idTextAnchor336"/>There’s more...</h2>
			<p>If you want to load records even with the <code>noupdate</code> flag, you can run the Odoo server with the <code>--init=your_addon</code> or <code>-i your_addon</code> parameter. This will force Odoo to reload your records. However, this will also cause deleted records to be recreated. Note that this can cause double records and related installation errors if a module circumvents the XML ID mechanism – for example, by creating records in Python code called by the <code>&lt;</code><code>function&gt;</code> tag.</p>
			<p>With this code, you can circumvent any <code>noupdate</code> flag, but first, make sure that this is really what you want. Another option to solve the scenario presented here is to write a migration script, as outlined in the <em class="italic">Add-on updates and data </em><em class="italic">migration</em> tutorial.</p>
			<h2 id="_idParaDest-272"><a id="_idTextAnchor337"/>See also</h2>
			<p>Odoo also uses XML IDs to keep track of which data is to be deleted after an add-on update. If a record has an XML ID from the module’s namespace before the update but the XML ID is not reinstated during the update, the record and its XML ID will be deleted from the database because they’re considered obsolete. For a more in-depth discussion of this mechanism, refer to the <em class="italic">Add-on updates and data </em><em class="italic">migration</em> tutorial.</p>
			<h1 id="_idParaDest-273"><a id="_idTextAnchor338"/>Loading data using CSV files</h1>
			<p>While you can<a id="_idIndexMarker380"/> do everything<a id="_idIndexMarker381"/> you need to with XML files, this format is not the most convenient when you need to provide larger amounts of data, especially given that many people are more comfortable preprocessing data in Calc or other spreadsheet software. Another advantage of the CSV format is that it is what you get when you use the standard <code>export</code> function. In this tutorial, we’ll take a look at importing table-like data.</p>
			<h2 id="_idParaDest-274"><a id="_idTextAnchor339"/>How to do it...</h2>
			<p>Traditionally, <strong class="bold">access-control lists</strong> (<strong class="bold">ACLs</strong>) in Odoo are used to manage<a id="_idIndexMarker382"/> record and operation access rights. ACLs specify who can execute particular actions (such as read, write, create, and delete) on specified entries using predefined rules. ACLs are commonly defined in Odoo modules via XML files. For more details on ACLs, check out the ACLs tutorial in <a href="B20997_10.xhtml#_idTextAnchor549"><em class="italic">Chapter 10</em></a><em class="italic">, </em><em class="italic">Security Access</em></p>
			<p>Add <code>security/ir.model.access.csv</code> to your data files:</p>
			<pre class="source-code">
'data': [
    ...
    'security/ir.model.access.csv',
],</pre>			<ol>
				<li>Add access security to the module in the <code>ir.model.data</code> CSV file:<pre class="source-code">
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_hostel_manager,hostel.room.manager,model_hostel_room,group_hostel_manager,1,1,1,1</pre></li>			</ol>
			<p>We now have an ACL that permits hostel managers to read book records, and it also allows them to edit, create, or delete them.</p>
			<h2 id="_idParaDest-275"><a id="_idTextAnchor340"/>How it works...</h2>
			<p>You simply drop all your data files into your manifest’s <em class="italic">data</em> list. Odoo will use the file extension to decide which type of file it is. A specialty of CSV files is that their filenames must match the name of the model to be imported – in our case, <code>ir.model.access</code>. The first line needs to be a header with column names that match the model’s field names exactly.</p>
			<p>For scalar values, you can use a quoted (if necessary, because the string contains quotes or commas itself) or an unquoted string.</p>
			<p>When writing <em class="italic">many2one</em> fields with<a id="_idIndexMarker383"/> a CSV file, Odoo first tries to interpret<a id="_idIndexMarker384"/> the column value as an XML ID. If there’s no dot, Odoo adds the current module name as a namespace and looks up the result in <code>ir.model.data</code>. If this fails, the model’s <code>name_search</code> function is called with the column’s value as a parameter, and the first returned result wins. If this also fails, the line is considered invalid and Odoo raises an error.</p>
			<h1 id="_idParaDest-276"><a id="_idTextAnchor341"/>Add-on updates and data migration</h1>
			<p>The data model you choose<a id="_idIndexMarker385"/> when writing <a id="_idIndexMarker386"/>an add-on module might turn out to have some weaknesses, so you may need to adjust it during the life cycle of your add-on module. In order to allow that without a lot of hacks, Odoo supports versioning in add-on modules and running migrations if necessary.</p>
			<h2 id="_idParaDest-277"><a id="_idTextAnchor342"/>How to do it...</h2>
			<p>We assume that in an earlier version of our module, the <code>allocation_date</code> field was a character field, where people wrote whatever they saw fit as the date. We now realize that we need this field for comparisons and aggregations, which is why we want to change its type to <code>Date</code>.</p>
			<p>Odoo does a great job at type conversions, but in this case, we’re on our own, which is why we need to provide instructions as to how to transform a database with the previous version of our module installed on it, where the current version can run. Let’s try this with the following steps:</p>
			<ol>
				<li>Bump the version in your <code>__manifest__.py</code> file:<pre class="source-code">
    'version': '17.0.2.0.1',</pre></li>				<li>Provide the pre-migration code in <code>migrations/17.0.1.0.1/pre-migrate.py</code>:<pre class="source-code">
def migrate(cr, version):
    cr.execute('ALTER TABLE hostel_room RENAME COLUMN allocation_date TO allocation_date_char')</pre></li>				<li>Provide the<a id="_idIndexMarker387"/> post-migration<a id="_idIndexMarker388"/> code in <code>migrations/17.0.1.0.1/post-migrate.py</code>:<pre class="source-code">
from odoo import fields
from datetime import date
def migrate(cr, version):
    cr.execute('SELECT id, allocation_date_char FROM
    hostel_room')
    for record_id, old_date in cr.fetchall():
        # check if the field happens to be set in Odoo's
        internal
        # format
        new_date = None
        try:
            new_date = fields.Date.to_date(old_date)
        except ValueError:
            if len(old_date) == 4 and old_date.isdigit():
                # probably a year
                new_date = date(int(old_date), 1, 1)
        if new_date:
            cr.execute('UPDATE hostel_room SET allocation_date=%s WHERE id=2',
                       (new_date,))</pre></li>			</ol>
			<p>Without this code, Odoo would have renamed the old <code>allocation_date</code> column <code>allocation_date_moved</code> and created a new one, as there’s no automatic conversion from character fields to date fields. From the point of view of the user, the data in <code>allocation_date</code> is simply gone.</p>
			<h2 id="_idParaDest-278"><a id="_idTextAnchor343"/>How it works...</h2>
			<p>The first crucial point<a id="_idIndexMarker389"/> is that you increase<a id="_idIndexMarker390"/> the version number of your add-on, as migrations run only between different versions. During every update, Odoo writes the version number from the manifest at the time of the update into the <code>ir_module_module</code> table. The version number is prefixed with Odoo’s major and minor versions if the version number has three or fewer components. In the preceding example, we explicitly named Odoo’s major and minor version, which is good practice, but a value of <code>1.0.1</code> would have had the same effect because, internally, Odoo prefixes short version numbers for add-ons with its own major and minor version numbers. Generally, using the long notation is a good idea because you can see at a glance which version of Odoo an add-on is meant for.</p>
			<p>The two migration files are just code files that don’t need to be registered anywhere. When updating an add-on, Odoo compares the add-on’s version, as noted in <code>ir_module_module</code>, with the version in the add-on’s manifest. If the manifest’s version is higher (after adding Odoo’s major and minor version), this add-on’s <code>migrations</code> folder will be searched to see whether it contains folders with the version(s) in between, up to and including the version that is currently updated.</p>
			<p>Then, within the folders found, Odoo searches for Python files whose names start with <code>pre-</code>, loads them, and expects them to define a function called <code>migrate</code>, which has two parameters. This function is called with a database cursor as the first argument and the currently installed version as the second argument. This happens before Odoo even looks at the rest of the code that the add-on defines, so you can assume that nothing changes in your database layout compared to the previous version.</p>
			<p>After all the <code>pre-migrate</code> functions run successfully, Odoo loads the models and the data declared in the add-on, which can cause changes in the database layout. Given that we renamed <code>date_release in pre-migrate.py</code>, Odoo will just create a new column with that name but with the correct data type.</p>
			<p>After that, with the same search algorithm, the <code>post-migrate</code> files will be searched and executed if found. In our case, we need to look at every value to see whether we can make something usable out of it; otherwise, we keep the data as <code>NULL</code>. Don’t write scripts that iterate over a whole table if not absolutely necessary; in this case, we would<a id="_idIndexMarker391"/> have written a very big, unr<a id="_idTextAnchor344"/>eadable<a id="_idIndexMarker392"/> SQL switch.</p>
			<p class="callout-heading">Important tip</p>
			<p class="callout">If you simply want to rename a column, you don’t need a migration script. In this case, you can set the <code>oldname</code> parameter of the field in question to the field’s original column name; Odoo then <a id="_idTextAnchor345"/>takes care of the renaming itself.</p>
			<h2 id="_idParaDest-279"><a id="_idTextAnchor346"/>There’s more...</h2>
			<p>In both the pre- and post-migration steps, you only have access to a cursor, which is not very convenient if you’re used to Odoo environments. It can<a id="_idIndexMarker393"/> lead to unexpected results to use models at this<a id="_idIndexMarker394"/> stage because, in the pre-migration step, the add-on’s models are not yet loaded, and also, in the post-migration step, the models defined by add-ons that depend on the current add-on are not yet loaded either. However, if this is not a problem for you, either because you want to use a model that your add-on doesn’t touch or a model for which you know that this issue is not a problem, you can create the environment you’re used to by writing the following:</p>
			<pre class="source-code">
from odoo import api, SU<a id="_idTextAnchor347"/>PERUSER_ID
def migrate(cr, version):
    env = api.Environment(cr, SUPERUSER_ID, {})
    # env holds all currently loaded models</pre>			<h2 id="_idParaDest-280"><a id="_idTextAnchor348"/>See also</h2>
			<p>When writing migration scripts, you’ll often be confronted with repetitive tasks, such as checking whether a column or table exists, renaming things, or mapping some old values to new values. It’s frustrating and error-prone to reinvent the wheel here; consider using <a href="https://github.com/OCA/openupgradelib">https://github.com/OCA/openupgradelib</a> if you can afford the extra depende<a id="_idTextAnchor349"/>ncy.</p>
			<h1 id="_idParaDest-281"><a id="_idTextAnchor350"/>Deleting records from XML files</h1>
			<p>We learned how<a id="_idIndexMarker395"/> to generate<a id="_idIndexMarker396"/> or change records from the XML file in the previous tutorials. You may occasionally wish to remove the records that have already been created from the dependent module. The <code>&lt;delete&gt;</code> tag can be used.</p>
			<h2 id="_idParaDest-282"><a id="_idTextAnchor351"/>Getting ready</h2>
			<p>In this tutorial, we will add some categories from the XML file and then delete them. In real situations, you will create this record from another module. But for simplicity, we will just add some catego<a id="_idTextAnchor352"/>ries to the same XML file, as follows:</p>
			<pre class="source-code">
&lt;record id="room_category_to_remove" model="hostel.room.category"&gt;
    &lt;field name="name"&gt;Single sharing&lt;/field&gt;
&lt;/record&gt;
&lt;record id="room_category_not_remove" model="hostel.room.category"&gt;
    &lt;field name="name"&gt;Double Sharing&lt;/field&gt;
&lt;/record&gt;</pre>			<h2 id="_idParaDest-283"><a id="_idTextAnchor353"/>How to do it...</h2>
			<p>There are two ways to remove records from the XML file:</p>
			<ul>
				<li>Using the XML ID of previously created records:<pre class="source-code">
&lt;delete model="hostel.room.category" id="room_category_to_remove"/&gt;</pre></li>				<li>With the search domain:<pre class="source-code">
&lt;delete model="hostel.room.category" search="[('name', 'ilike', 'Single Room Category')]"/&gt;</pre></li>			</ul>
			<h2 id="_idParaDest-284"><a id="_idTextAnchor354"/>How it works...</h2>
			<p>You will need to use the <code>&lt;delete&gt;</code> tag. To remove a record from a model, you need to provide the name of the model in the <code>model</code> attribute. This is a mandatory attribute.</p>
			<p>The XML IDs of the records that had been generated from the data files of another module must be supplied in the first method. Odoo will look for the record while installing the module. If the specified XML ID matches a record, the record will be deleted; otherwise, an error will be raised. Only records that were generated from XML files (or records with XML IDs) are able to be deleted.</p>
			<p>In the second method, you need to pass the domain in the <code>domain</code> attribute. During the installation of the module, Odoo will search the records by this domain. If records are found, it deletes them. This option will not raise an error if no records match the given domain. Use this option with extreme caution because it might delete your user’s data, since the search option<a id="_idIndexMarker397"/> deletes all the records that match<a id="_idIndexMarker398"/> the domain.</p>
			<p class="callout-heading">Warning</p>
			<p class="callout"><code>&lt;delete&gt;</code> is rarely used in Odoo, as it is dangerous. If you are not careful with this, you might<a id="_idTextAnchor355"/> break the system. Avoid it if possible.</p>
			<h1 id="_idParaDest-285"><a id="_idTextAnchor356"/>Invoking functions from XML files</h1>
			<p>You can create all types<a id="_idIndexMarker399"/> of records<a id="_idIndexMarker400"/> from XML files, but sometimes, it is difficult to generate data that includes some business logic. You might want to modify records when a user installs a dependent module in production. In this case, you can invoke the <code>model</code> method through the <code>&lt;</code><code>function&gt;</code> tag.</p>
			<h2 id="_idParaDest-286"><a id="_idTextAnchor357"/>How to do it...</h2>
			<p>For this tutorial, we will use the code from the previous tutorial. As an example, we will increase the existing room price by $10 USD. Note that you might use another currency based on company configurations.</p>
			<p>Follow these steps to invoke the Python method from the XML file:</p>
			<ol>
				<li>Add the <code>_update_room_price()</code> method to the <code>hostel.room</code> model:<pre class="source-code">
@api.model
def _update_room_price(self):
    all_rooms = self.search([])
    for room in all_rooms:
        room.cost_price += 10</pre></li>				<li>Add <code>&lt;function&gt;</code> to the data XML file:<pre class="source-code">
&lt;function model="hostel.room" name="_update_room_price"/&gt;</pre></li>			</ol>
			<h2 id="_idParaDest-287"><a id="_idTextAnchor358"/>How it works...</h2>
			<p>In <em class="italic">step 1</em>, we added<a id="_idIndexMarker401"/> the <code>_update_room_price()</code> method, which searches<a id="_idIndexMarker402"/> for all books and increases the price by $10 USD. We started the method name with <code>_</code>, as this is considered private by ORM and cannot be invoked through RPC.</p>
			<p>In <em class="italic">step 2</em>, we used the <code>&lt;function&gt;</code> tag with two attributes:</p>
			<ul>
				<li><code>model</code>: The model name with which the method is declared</li>
				<li><code>name</code>: The name of the method you want to invoke</li>
			</ul>
			<p>When you install this module, <code>_update_room_price()</code> will be called and the price of books will increase by $10 USD.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Always use this function with the <code>noupdate</code> options. Otherwise, it will be invoked every time you update your module.</p>
			<h2 id="_idParaDest-288"><a id="_idTextAnchor359"/>There’s more...</h2>
			<p>With <code>&lt;function&gt;</code>, it is also possible<a id="_idIndexMarker403"/> to send parameters to the functions. Let’s say you only want to increase the price of rooms in a particular category and you want to send that amount as a parameter.</p>
			<p>To do that, you need to create a method that accepts the catego<a id="_idTextAnchor360"/>ry as a parameter, as follows:</p>
			<pre class="source-code">
    @api.model
    def update_room_price(self, category, amount_to_increase):
        category_rooms = self.search([('category_id', '=', category.id)])
        for room in category_rooms:
            room.cost_price += amount_to_increase</pre>			<p>To pass the category and amount as a parameter, yo<a id="_idTextAnchor361"/>u need to use the <code>eval</code> attribute, as follows:</p>
			<pre class="source-code">
&lt;function mod<a id="_idTextAnchor362"/>el="hostel.room"
    name="update_room_price"
    eval="(ref('category_xml_id'), 20)"/&gt;</pre>			<p>When you install the module, it will increase the price of the rooms of the given category by $20 USD.</p>
		</div>
	</body></html>