<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer010">
<h1 class="chapter-number" id="_idParaDest-190"><a id="_idTextAnchor193"/>6</h1>
<h1 id="_idParaDest-191"><a id="_idTextAnchor194"/>Integrating FastAPI with SQL Databases</h1>
<p>We’ll now embark on a journey to harness the full potential of SQL databases within your FastAPI applications. This chapter is meticulously designed to guide you through the nuances of leveraging <strong class="bold">SQLAlchemy</strong>, a <a id="_idIndexMarker346"/>powerful SQL toolkit and <strong class="bold">object-relational </strong><strong class="bold">mapping</strong> (<strong class="bold">ORM</strong>) for<a id="_idIndexMarker347"/> Python. From setting up your database environment to implementing sophisticated <strong class="bold">create, read, update and delete</strong> (<strong class="bold">CRUD</strong>) operations and managing complex relationships, this chapter provides a comprehensive blueprint for integrating SQL databases seamlessly<a id="_idIndexMarker348"/> <span class="No-Break">with FastAPI.</span></p>
<p>By creating a basic ticketing platform, you’ll practically engage in configuring SQLAlchemy with FastAPI, creating data models that reflect your application’s data structures, and crafting efficient, secure <span class="No-Break">CRUD operations.</span></p>
<p>Moreover, you’ll explore the management of database migrations with <strong class="bold">Alembic</strong>, ensuring your database schema evolves alongside your application without hassle. This chapter doesn’t stop at just handling data; it delves into optimizing SQL queries for performance, securing sensitive information within your database, and managing transactions and concurrency to ensure data integrity <span class="No-Break">and reliability.</span></p>
<p>By the end of this chapter, you’ll be adept at integrating and managing SQL databases in your FastAPI applications, equipped with the skills to ensure your applications are not only efficient and scalable but also secure. Whether you’re building a new application from scratch or integrating a database into an existing project, the insights and techniques covered here will empower you to leverage the full power of SQL databases in your <span class="No-Break">FastAPI projects.</span></p>
<p>In this chapter, we’re going to cover the <span class="No-Break">following recipes:</span></p>
<ul>
<li>Setting <span class="No-Break">up SQLAlchemy</span></li>
<li>Implementing <span class="No-Break">CRUD operations</span></li>
<li>Working <span class="No-Break">with migrations</span></li>
<li>Handling relationships in <span class="No-Break">SQL databases</span></li>
<li>Optimizing SQL queries <span class="No-Break">for performance</span></li>
<li>Securing sensitive data in <span class="No-Break">SQL databases</span></li>
<li>Handling transactions <span class="No-Break">and concurrency</span></li>
</ul>
<h1 id="_idParaDest-192"><a id="_idTextAnchor195"/>Technical requirements</h1>
<p>To follow along with all the recipes of the chapter, make sure you have these essentials in <span class="No-Break">your setup:</span></p>
<ul>
<li><strong class="bold">Python</strong>: Your environment should have a Python version above <span class="No-Break">3.9 installed.</span></li>
<li><strong class="bold">FastAPI</strong>: It should be installed in your virtual environment with all the dependencies it needs. If you didn’t do it in the previous chapters, you can easily do it from <span class="No-Break">your terminal:</span><pre class="source-code">
<strong class="bold">$ pip install fastapi[all]</strong></pre></li> </ul>
<p>The code that accompanies the chapter is available on GitHub at the following <span class="No-Break">link: </span><a href="https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter06"><span class="No-Break">https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter06</span></a></p>
<p>It is also advisable to create a virtual environment for the project inside the project root folder, to handle dependencies well and keep the project separate. In your virtual environment, you can install all the dependencies at once by using the <strong class="source-inline">requirements.txt</strong> file from the GitHub repo in the <span class="No-Break">project folder:</span></p>
<pre class="console">
$ pip install –r requirements.txt</pre> <p>Since the code of the chapter will make use of the <strong class="source-inline">async</strong>/<strong class="source-inline">await</strong> syntax from the <strong class="source-inline">asyncio</strong> Python library, you should be already familiar with it. Feel free to read more about <strong class="source-inline">asyncio</strong> and <strong class="source-inline">async</strong>/<strong class="source-inline">await</strong> syntax at the <span class="No-Break">following links:</span></p>
<ul>
<li><a href="https://docs.python.org/3/library/asyncio.xhtml"><span class="No-Break">https://docs.python.org/3/library/asyncio.xhtml</span></a></li>
<li><a href="https://fastapi.tiangolo.com/async/"><span class="No-Break">https://fastapi.tiangolo.com/async/</span></a></li>
</ul>
<p>Now that we have this ready Once we have everything ready, we can begin preparing <span class="No-Break">our recipes.</span></p>
<h1 id="_idParaDest-193"><a id="_idTextAnchor196"/>Setting up SQLAlchemy</h1>
<p>To begin any data application, you <a id="_idIndexMarker349"/>need to establish a database connection. This recipe will help you set up and configure <strong class="source-inline">sqlalchemy</strong> package with an <strong class="bold">SQLite</strong> database<a id="_idIndexMarker350"/> so that you can use the advantages of SQL databases in <span class="No-Break">your applications.</span></p>
<h2 id="_idParaDest-194"><a id="_idTextAnchor197"/>Getting ready</h2>
<p>The project is going to be fairly large, so we will put the working modules for the application in a folder named <strong class="source-inline">app</strong>, which will be under the root project folder that we will <span class="No-Break">call </span><span class="No-Break"><strong class="source-inline">ticketing_system</strong></span><span class="No-Break">.</span></p>
<p>You need <strong class="source-inline">fastapi</strong>, <strong class="source-inline">sqlalchemy</strong>, and <strong class="source-inline">aiosqlite</strong> installed in your environment to use the recipe. The recipe is meant to work with <strong class="source-inline">sqlalchemy</strong> with versions above 2.0.0. You can still use version 1; however, some adaptions are required. You can find a migration guide at the following <span class="No-Break">link: </span><a href="https://docs.sqlalchemy.org/en/20/changelog/migration_20.xhtml"><span class="No-Break">https://docs.sqlalchemy.org/en/20/changelog/migration_20.xhtml</span></a><span class="No-Break">.</span></p>
<p>If you haven’t installed the packages with the <strong class="source-inline">requirements.txt</strong> file in the repo, you can do it by running <span class="No-Break">the following:</span></p>
<pre class="console">
$ pip install fastapi[all] "sqlalchemy&gt;=2.0.0" aiosqlite</pre> <p>Once the packages are correctly installed, you can follow <span class="No-Break">the recipe.</span></p>
<h2 id="_idParaDest-195"><a id="_idTextAnchor198"/>How to do it...</h2>
<p>The setup of a generic SQL database connection with <strong class="source-inline">sqlalchemy</strong> will go through the <span class="No-Break">following steps:</span></p>
<ol>
<li>Creating mapping object classes, that will match the <span class="No-Break">database tables</span></li>
<li>Creating abstraction layers, an engine, and a session to communicate with <span class="No-Break">the database</span></li>
<li>Initializing a database connection, at the <span class="No-Break">server startup</span></li>
</ol>
<h3>Creating mapping object classes</h3>
<p>In the <strong class="source-inline">app</strong> folder, let’s <a id="_idIndexMarker351"/>create a module<a id="_idIndexMarker352"/> called <strong class="source-inline">database.py</strong> and then create a class object to track tickets <span class="No-Break">as follows:</span></p>
<pre class="source-code">
from sqlalchemy import Column, Float, ForeignKey, Table
from sqlalchemy.orm import (
    DeclarativeBase,
    Mapped,
    mapped_column,
)
class Base(DeclarativeBase):
    pass
class Ticket(Base):
    __tablename__ = "tickets"
    id: Mapped[int] = mapped_column(primary_key=True)
    price: Mapped[float] = mapped_column(nullable=True)
    show: Mapped[str | None]
    user: Mapped[str | None]</pre> <p>We just created a <strong class="source-inline">Ticket</strong> class that will be used to match the <strong class="source-inline">tickets</strong> table into our <span class="No-Break">SQL database.</span></p>
<h3>Creating abstraction layers</h3>
<p>In SQLAlchemy, the <em class="italic">engine</em> manages database connections and executes SQL statements, while <a id="_idIndexMarker353"/>a <em class="italic">session</em> allows querying, inserting, updating, and deleting data within a transactional context, ensuring consistency and atomicity. Sessions are bound to an engine for communication with <span class="No-Break">the database.</span></p>
<p>We will start by creating a function that returns the engine. In a new module called <strong class="source-inline">db_connection.py</strong>, under the <strong class="source-inline">app</strong> folder, let’s write the function <span class="No-Break">as follows:</span></p>
<pre class="source-code">
from sqlalchemy.ext.asyncio import (
    create_async_engine,
)
from sqlalchemy.orm import sessionmaker
SQLALCHEMY_DATABASE_URL = (
    "sqlite+aiosqlite:///.database.db"
)
def get_engine():
    return create_async_engine(
        SQLALCHEMY_DATABASE_URL, echo=True
    )</pre> <p>You may have observed <a id="_idIndexMarker354"/>that the <strong class="source-inline">SQLALCHEMY_DATABASE_URL</strong> database URL uses the <strong class="source-inline">sqlite</strong> and <span class="No-Break"><strong class="source-inline">aiosqlite</strong></span><span class="No-Break"> modules.</span></p>
<p>This implies that we will use an SQLite database where the operations will happen via the <strong class="source-inline">aiosqlite</strong> asynchronous library that supports the <span class="No-Break"><strong class="source-inline">asyncio</strong></span><span class="No-Break"> library.</span></p>
<p>Then, we will use a session maker to specify that the session will be asynchronous, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
from sqlalchemy.ext.asyncio import (
    AsyncSession,
)
AsyncSessionLocal = sessionmaker(
    autocommit=False,
    autoflush=False,
    bind=get_engine(),
    class_=AsyncSession,
)
async def get_db_session():
    async with AsyncSessionLocal() as session:
        yield session</pre> <p>The <strong class="source-inline">get_db_session</strong> function will be used as a dependency for each endpoint interacting <a id="_idIndexMarker355"/>with<a id="_idIndexMarker356"/> <span class="No-Break">the database.</span></p>
<h3>Initializing a database connection</h3>
<p>Once we have the <a id="_idIndexMarker357"/>abstraction layers, we<a id="_idIndexMarker358"/> need to create our FastAPI server object and start the database classes when the server runs. We can do it in the <strong class="source-inline">main.py</strong> module under the <span class="No-Break"><strong class="source-inline">app</strong></span><span class="No-Break"> folder:</span></p>
<pre class="source-code">
from contextlib import asynccontextmanager
from fastapi import FastAPI
from app.database import Base
from app.db_connection import (
    AsynSessionLocal,
    get_db_session
)
@asynccontextmanager
async def lifespan(app: FastAPI):
    engine = get_engine()
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)
        yield
    await engine.dispose()ispose()
app = FastAPI(lifespan=lifespan)</pre> <p>To specify server actions at the startup event, we have used the <span class="No-Break"><strong class="source-inline">lifespan</strong></span><span class="No-Break"> parameter.</span></p>
<p>We have everything in <a id="_idIndexMarker359"/>place to connect our <a id="_idIndexMarker360"/>application with <span class="No-Break">the database.</span></p>
<h2 id="_idParaDest-196"><a id="_idTextAnchor199"/>How it works…</h2>
<p>The creation of the <strong class="source-inline">Ticket</strong> database <a id="_idIndexMarker361"/>mapping class tells our application how the database is structured, and the session will manage the transactions. Then, the engine will not only execute the operations but compare the mapping classes with the database, and it will create tables if any <span class="No-Break">are missing.</span></p>
<p>To check that our app communicates with our database, let’s spin up the server from the command line at the project <span class="No-Break">root folder:</span></p>
<pre class="console">
$ uvicorn app.main:app</pre> <p>You should see message logs on the command output that says table tickets have been created. Furthermore, open the <strong class="source-inline">.database.db</strong> file with the database reader you prefer, and the table should be there with the schema that is defined in the <span class="No-Break"><strong class="source-inline">database.py</strong></span><span class="No-Break"> module.</span></p>
<h2 id="_idParaDest-197"><a id="_idTextAnchor200"/>See also</h2>
<p>You can see more about how to set up a database with SQLAlchemy and how to make it compatible with the <strong class="source-inline">asyncio</strong> module on the official <span class="No-Break">documentation pages:</span></p>
<ul>
<li><em class="italic">How to set up an SQLAlchemy </em><span class="No-Break"><em class="italic">database</em></span><span class="No-Break">: </span><a href="https://docs.sqlalchemy.org/en/20/orm/quickstart.xhtml"><span class="No-Break">https://docs.sqlalchemy.org/en/20/orm/quickstart.xhtml</span></a></li>
<li><em class="italic">SQLAlchemy</em> <strong class="source-inline">asyncio</strong> <em class="italic">extension </em><span class="No-Break"><em class="italic">reference</em></span><span class="No-Break">: </span><a href="https://docs.sqlalchemy.org/en/20/orm/extensions/asyncio.xhtml"><span class="No-Break">https://docs.sqlalchemy.org/en/20/orm/extensions/asyncio.xhtml</span></a></li>
</ul>
<p>In this example, we have used an SQLite database by specifying <span class="No-Break">the following:</span></p>
<pre class="source-code">
SQLALCHEMY_DATABASE_URL = "sqlite+aiosqlite:///.database.db"</pre> <p>However, you can use SQLAlchemy to interact with multiple SQL databases such as <strong class="bold">MySQL</strong> or <strong class="bold">PostgreSQL</strong> by <a id="_idIndexMarker362"/>simply <a id="_idIndexMarker363"/>specifying the database driver, the <strong class="source-inline">asyncio</strong>-supported driver, and the <span class="No-Break">database address.</span></p>
<p>For example, for MySQL, the connection string would look <span class="No-Break">like this:</span></p>
<pre class="source-code">
mysql+aiomysql://user:password@host:port/dbname[?key=value&amp;key=value...]</pre> <p>In this case, you need the <strong class="source-inline">aiomysql</strong> package installed in <span class="No-Break">your environment.</span></p>
<p>You can check more on the official <span class="No-Break">documentation pages:</span></p>
<ul>
<li>SQLAlchemy MySQL <span class="No-Break">dialect: </span><a href="https://docs.sqlalchemy.org/en/20/dialects/mysql.xhtml"><span class="No-Break">https://docs.sqlalchemy.org/en/20/dialects/mysql.xhtml</span></a></li>
<li>SQLAlchemy PostgreSQL <span class="No-Break">dialect: </span><a href="https://docs.sqlalchemy.org/en/20/dialects/postgresql.xhtml"><span class="No-Break">https://docs.sqlalchemy.org/en/20/dialects/postgresql.xhtml</span></a></li>
</ul>
<h1 id="_idParaDest-198"><a id="_idTextAnchor201"/>Implementing CRUD operations</h1>
<p>CRUD operations with a<a id="_idIndexMarker364"/> RESTful API can be implemented using HTTP methods (<strong class="source-inline">POST</strong>, <strong class="source-inline">GET</strong>, <strong class="source-inline">PUT</strong>, and <strong class="source-inline">DELETE</strong>) for web services. This recipe demonstrates how to use SQLAlchemy and <strong class="source-inline">asyncio</strong> to build CRUD operations asynchronously on an SQL database with the <span class="No-Break">corresponding endpoints.</span></p>
<h2 id="_idParaDest-199"><a id="_idTextAnchor202"/>Getting ready</h2>
<p>Before you start with the recipe, you need to have a database connection and a table in the dataset, as well as a matching class in the code base. If you completed the previous recipe, you should have <span class="No-Break">them ready.</span></p>
<h2 id="_idParaDest-200"><a id="_idTextAnchor203"/>How to do it…</h2>
<p>We’ll begin by making an <strong class="source-inline">operations.py</strong> module under the <strong class="source-inline">app</strong> folder to contain our database operations by following <span class="No-Break">these steps.</span></p>
<ol>
<li>First, we can<a id="_idIndexMarker365"/> set up the operation to add a new ticket to the database <span class="No-Break">as follows:</span><pre class="source-code">
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from app.database import Ticket
async def create_ticket(
    db_session: AsyncSession,
    show_name: str,
    user: str = None,
    price: float = None,
) -&gt; int:
    ticket = Ticket(
        show=show_name,
        user=user,
        price=price,
    )
    async with db_session.begin():
        db_session.add(ticket)
        await db_session.flush()
        ticket_id = ticket.id
        await db_session.commit()
    return ticket_id</pre><p class="list-inset">The function will give back the ID attached to the ticket <span class="No-Break">when saved.</span></p></li> <li>Then, let’s create a function to get <span class="No-Break">a ticket:</span><pre class="source-code">
async def get_ticket(
    db_session: AsyncSession, ticket_id: int
) -&gt; Ticket | None:
    query = (
        select(Ticket)
        .where(Ticket.id == ticket_id)
    )
    async with db_session as session:
        tickets = await session.execute(query)
        return tickets.scalars().first()</pre><p class="list-inset">If the ticket is<a id="_idIndexMarker366"/> not found, the function will return a <span class="No-Break"><strong class="source-inline">None</strong></span><span class="No-Break"> object.</span></p></li> <li>Then, we build an operation to update only the price of <span class="No-Break">the ticket:</span><pre class="source-code">
async def update_ticket_price(
    db_session: AsyncSession,
    ticket_id: int,
    new_price: float,
) -&gt; bool:
    query = (
        update(Ticket)
        .where(Ticket.id == ticket_id)
        .values(price=new_price)
    )
    async with db_session as session:
        ticket_updated = await session.execute(query)
        await session.commit()
        if ticket_updated.rowcount == 0:
            return False
        return True</pre><p class="list-inset">The function gives back <strong class="source-inline">False</strong> if the operation couldn’t delete <span class="No-Break">any ticket.</span></p></li> <li>To conclude the<a id="_idIndexMarker367"/> CRUD operations, we define a <span class="No-Break"><strong class="source-inline">delete_ticket</strong></span><span class="No-Break"> operation:</span><pre class="source-code">
async def delete_ticket(
    db_session: AsyncSession, ticket_id
) -&gt; bool:
    async with db_session as session:
        tickets_removed = await session.execute(
            delete(
                Ticket
            ).where(Ticket.id == ticket_id)
        )
        await session.commit()
        if tickets_removed.rowcount == 0:
            return False
        return True</pre><p class="list-inset">Similarly to the update operation, the function returns <strong class="source-inline">False</strong> if it does not find any ticket <span class="No-Break">to delete.</span></p></li> <li>After defining the operations, we can expose them by creating the corresponding endpoints in the <span class="No-Break"><strong class="source-inline">main.py</strong></span><span class="No-Break"> module.</span><p class="list-inset">Let’s do it for the <a id="_idIndexMarker368"/>create operation right after defining the <span class="No-Break">app server:</span></p><pre class="source-code">
from typing import Annotated
from sqlalchemy.ext.asyncio import AsyncSession
from app.db_connection import (
    AsyncSessionLocal,
    get_engine,
    get_session
)
from app.operations import create_ticket
# rest of the code 
class TicketRequest(BaseModel):
    price: float | None
    show: str | None
    user: str | None = None
@app.post("/ticket", response_model=dict[str, int])
async def create_ticket_route(
    ticket: TicketRequest,
    db_session: Annotated[
        AsyncSession,
        Depends(get_db_session)
    ]
):
    ticket_id = await create_ticket(
        db_session,
        ticket.show,
        ticket.user,
        ticket.price,
    )
    return {"ticket_id": ticket_id}</pre><p class="list-inset">The remaining operations can be exposed in the <span class="No-Break">same way.</span></p></li> </ol>
<p class="callout-heading">Exercise</p>
<p class="callout">Similarly to what we did for the <strong class="source-inline">create_ticket</strong> operation, expose the other operations (get, update, and delete) with the <span class="No-Break">respective endpoints.</span></p>
<h2 id="_idParaDest-201"><a id="_idTextAnchor204"/>How it works…</h2>
<p>The functions <a id="_idIndexMarker369"/>created to interact with the database are exposed through the endpoints. This means that an external user will execute the operations by calling the <span class="No-Break">respective endpoints.</span></p>
<p>Let’s verify that the endpoint <span class="No-Break">works correctly.</span></p>
<p>Start the server from the command line as usual by running <span class="No-Break">the following:</span></p>
<pre class="console">
$ uvicorn app.main:app</pre> <p>Then, go to the interactive documentation link at <strong class="source-inline">http://localhost:8000/docs</strong>, and you will see the endpoints you just created. Experiment with them in different combinations and see the results in the <strong class="source-inline">.database.db</strong> <span class="No-Break">database file.</span></p>
<p>You have just created CRUD operations to interact with an SQL database by using <strong class="source-inline">sqlalchemy</strong> with<a id="_idIndexMarker370"/> the <span class="No-Break"><strong class="source-inline">asyncio</strong></span><span class="No-Break"> library.</span></p>
<p class="callout-heading">Exercise</p>
<p class="callout">Make a <strong class="source-inline">tests</strong> folder in the root project folder and write all the unit tests for the operation functions and the endpoints. You can refer to <a href="B21025_05.xhtml#_idTextAnchor157"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, <em class="italic">Testing and Debugging FastAPI Applications</em>, to learn how to unit test <span class="No-Break">FastAPI applications.</span></p>
<h1 id="_idParaDest-202"><a id="_idTextAnchor205"/>Working with migrations</h1>
<p>Database migrations <a id="_idIndexMarker371"/>let you version control your database schema and keep it consistent across environments. They also help you automate the deployment of your database changes and track the history of your <span class="No-Break">schema evolution.</span></p>
<p>The recipe shows you how to <a id="_idIndexMarker372"/>use <strong class="bold">Alembic</strong>, a popular tool for managing database migrations in Python. You will learn how to create, run, and roll back migrations and how to integrate them with your <span class="No-Break">ticketing system.</span></p>
<h2 id="_idParaDest-203"><a id="_idTextAnchor206"/>Getting ready</h2>
<p>To use the recipe, you need to have <strong class="source-inline">alembic</strong> in your environment. You can install it with <strong class="source-inline">pip,</strong> if you didn’t do it with the <strong class="source-inline">requirements.txt</strong> file from the GitHub repository, by typing this on the <span class="No-Break">command line:</span></p>
<pre class="console">
$ pip install alembic</pre> <p>You also need to make sure you have at least one class that corresponds to the table in the database you want to create. If you don’t have one, go back to the <em class="italic">Setting up SQLAlchemy</em> recipe and make one. If you’re already running the application, delete the <strong class="source-inline">.database.db</strong> file that the application <span class="No-Break">has created.</span></p>
<h2 id="_idParaDest-204"><a id="_idTextAnchor207"/>How to do it…</h2>
<p>To configure Alembic and manage database migrations, go through the <span class="No-Break">following steps.</span></p>
<ol>
<li>The first step is to set up <strong class="source-inline">alembic</strong>. In the project root folder, run the following command in the <span class="No-Break">command line:</span><pre class="source-code">
<strong class="bold">$ alembic init alembic</strong></pre><p class="list-inset">This command will make an <strong class="source-inline">alembic.ini</strong> file and an <strong class="source-inline">alembic</strong> folder with some files inside it. The <strong class="source-inline">alembic.ini</strong> file is a configuration file <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">alembic</strong></span><span class="No-Break">.</span></p><p class="list-inset">If you copy the project from the GitHub repository make sure to delete the existing <strong class="source-inline">alembic</strong> folder before running the <strong class="source-inline">alembic </strong><span class="No-Break"><strong class="source-inline">init</strong></span><span class="No-Break"> command.</span></p></li> <li>Find the <strong class="source-inline">sqlalchemy.url</strong> variable and set the database URL to <span class="No-Break">the following:</span><pre class="source-code">
sqlalchemy.url = sqlite:///.database.db</pre><p class="list-inset">This specifies<a id="_idIndexMarker373"/> that we are using an SQLite database If you use a different database, adjust <span class="No-Break">it accordingly.</span></p></li> <li>The <strong class="source-inline">alembic</strong> directory contains a folder version and an <strong class="source-inline">env.py</strong> file that has the variable for creating our <span class="No-Break">database migrations.</span><p class="list-inset">Open the <strong class="source-inline">env.py</strong> file and find the <strong class="source-inline">target_metadata</strong> variable. Set its value to the metadata of our application <span class="No-Break">as follows:</span></p><pre class="source-code">
from app.database import Base
target_metadata = Base.metadata</pre><p class="list-inset">We can now create our first database migration script and apply <span class="No-Break">the migration.</span></p></li> <li>Execute the following command from the command line to create an <span class="No-Break">initial migration:</span><pre class="source-code">
<strong class="bold">$ alembic revision --autogenerate -m "Start database"</strong></pre><p class="list-inset">This will create a migration script automatically placed in the <span class="No-Break"><strong class="source-inline">alembic/versions</strong></span><span class="No-Break"> folder.</span></p></li> <li>Make sure you removed the existing <strong class="source-inline">.database.db</strong> file, and let’s execute our first migration with the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">$ alembic upgrade head</strong></pre><p class="list-inset">This will automatically rebuild the <strong class="source-inline">.database.db</strong> file with the <strong class="source-inline">tickets</strong> table <span class="No-Break">in it.</span></p></li> </ol>
<h2 id="_idParaDest-205"><a id="_idTextAnchor208"/>How it works…</h2>
<p>Once we have the first version of our database, let’s see the migration <span class="No-Break">in action.</span></p>
<p>Imagine we want to change the table in the <strong class="source-inline">database.py</strong> module while the application is already deployed in a production environment so that we can’t delete any records when <span class="No-Break">updating it.</span></p>
<p>Add some tickets<a id="_idIndexMarker374"/> to the database, then in the code, let’s add a new field called <strong class="source-inline">sold</strong> that will indicate if the ticket has been sold <span class="No-Break">or not:</span></p>
<pre class="source-code">
class Ticket(Base):
    __tablename__ = "tickets"
    id: Mapped[int] = mapped_column(primary_key=True)
    price: Mapped[float] = mapped_column(nullable=True)
    show: Mapped[str | None]
    user: Mapped[str | None]
<strong class="bold">    sold: Mapped[bool] = mapped_column(default=False)</strong></pre> <p>To make a new migration, run the <span class="No-Break">following command:</span></p>
<pre class="console">
$ alembic revision –-autogenerate -m "Add sold field"</pre> <p>You will find a new script in the <span class="No-Break"><strong class="source-inline">alembic/versions</strong></span><span class="No-Break"> folder.</span></p>
<p>Run the migration <span class="No-Break">command again:</span></p>
<pre class="console">
$ alembic upgrade head</pre> <p>Open the database, and you will see that the <strong class="source-inline">tickets</strong> table schema has the <strong class="source-inline">sold</strong> field added to it, and no record has <span class="No-Break">been deleted.</span></p>
<p>You just created a migration strategy that will seamlessly change our database while running without any data loss. From now on, remember to use migrations to track changes on <span class="No-Break">database schemas.</span></p>
<h2 id="_idParaDest-206"><a id="_idTextAnchor209"/>See also</h2>
<p>You can see more on <a id="_idIndexMarker375"/>how to manage database migrations with Alembic at the official <span class="No-Break">documentation links:</span></p>
<ul>
<li><em class="italic">Setting up </em><span class="No-Break"><em class="italic">Alembic</em></span><span class="No-Break">: </span><a href="https://alembic.sqlalchemy.org/en/latest/tutorial.xhtml"><span class="No-Break">https://alembic.sqlalchemy.org/en/latest/tutorial.xhtml</span></a></li>
<li><em class="italic">Autogenerating </em><span class="No-Break"><em class="italic">migrations</em></span><span class="No-Break">: </span><a href="https://alembic.sqlalchemy.org/en/latest/autogenerate.xhtml"><span class="No-Break">https://alembic.sqlalchemy.org/en/latest/autogenerate.xhtml</span></a></li>
</ul>
<h1 id="_idParaDest-207"><a id="_idTextAnchor210"/>Handling relationships in SQL databases</h1>
<p>Database relationships <a id="_idIndexMarker376"/>are associations between two or more tables that allow you to model complex data structures and perform queries across multiple tables. In this recipe, you will learn how to implement one-to-one, many-to-one, and many-to-many relationships for the existing ticketing system application. You will also see how to use SQLAlchemy to define your database schema relationships and query <span class="No-Break">the database.</span></p>
<h2 id="_idParaDest-208"><a id="_idTextAnchor211"/>Getting ready</h2>
<p>To follow the recipe, you need to have the core of the application already implemented with at least one table in it. If you have already done that, you will also have the necessary packages ready. We will keep on working on our ticketing system <span class="No-Break">platform application.</span></p>
<h2 id="_idParaDest-209"><a id="_idTextAnchor212"/>How to do it…</h2>
<p>We will now proceed to set up relationships. We will show an example for each type of SQL <span class="No-Break">table relationship.</span></p>
<h3>One to one</h3>
<p>We will demonstrate<a id="_idIndexMarker377"/> the one-to-one relationship by making a new table that holds details about <span class="No-Break">the ticket.</span></p>
<p>One-to-one relationships are used to group specific information about a record in a <span class="No-Break">separate logic.</span></p>
<p>That being said, let’s make the table in the <strong class="source-inline">database.py</strong> module. The records will have information such as the seat associated with the ticket, with a ticket type that we will use as a label for possible information. Let's create the table in <span class="No-Break">two steps.</span></p>
<ol>
<li>First, we will add the ticket details reference to the existing <span class="No-Break"><strong class="source-inline">Ticket</strong></span><span class="No-Break"> class:</span><pre class="source-code">
class Ticket(Base):
    __tablename__ = "tickets"
    id: Mapped[int] = mapped_column(primary_key=True)
    price: Mapped[float] = mapped_column(
        nullable=True
    )
    show: Mapped[str | None]
    user: Mapped[str | None]
    sold: Mapped[bool] = mapped_column(default=False)
<strong class="bold">    details: Mapped["TicketDetails"] = relationship(</strong>
<strong class="bold">        back_populates="ticket"</strong>
<strong class="bold">    )</strong></pre></li> <li>Then, we create the table to map the ticket’s details <span class="No-Break">as follows:</span><pre class="source-code">
from sqlalchemy import ForeignKey
<strong class="bold">class TicketDetails(Base):</strong>
<strong class="bold">    __tablename__ = "ticket_details"</strong>
<strong class="bold">    id: Mapped[int] = mapped_column(primary_key=True)</strong>
<strong class="bold">    ticket_id: Mapped[int] = mapped_column(</strong>
<strong class="bold">        ForeignKey("tickets.id")</strong>
<strong class="bold">    </strong><strong class="bold">)</strong>
<strong class="bold">    ticket: Mapped["Ticket"] = relationship(</strong>
<strong class="bold">        back_populates="details"</strong>
<strong class="bold">    )</strong>
<strong class="bold">    seat: Mapped[str | None]</strong>
<strong class="bold">    ticket_type: Mapped[str | None]</strong></pre></li> </ol>
<p>Once the database classes are set up to accommodate the new table, we can proceed to update the CRUD operations <a id="_idIndexMarker378"/><a id="_idIndexMarker379"/>with the <span class="No-Break">following steps.</span></p>
<ol>
<li>To update ticket details, let’s create a dedicated function in the <span class="No-Break"><strong class="source-inline">operations.py</strong></span><span class="No-Break"> module:</span><pre class="source-code">
async def update_ticket_details(
    db_session: AsyncSession,
    ticket_id: int,
    updating_ticket_details: dict,
) -&gt; bool:
    ticket_query = update(TicketDetails).where(
        TicketDetails.ticket_id == ticket_id
    )
    if updating_ticket_details != {}:
        ticket_query = ticket_query.values(
             *updating_ticket_details
        )
        result = await db_session.execute(
                ticket_query
            )
        await db_session.commit()
        if result.rowcount == 0:
                return False
    return True</pre><p class="list-inset">The function will return <strong class="source-inline">False</strong> if no records have <span class="No-Break">been updated.</span></p></li> <li>Next, modify the <strong class="source-inline">create_ticket</strong> function to consider the details of the ticket and create an<a id="_idIndexMarker380"/> endpoint to expose the updating operation we just created, <span class="No-Break">like so:</span><pre class="source-code">
async def create_ticket(
    db_session: AsyncSession,
    show_name: str,
    user: str = None,
    price: float = None,
) -&gt; int:
    ticket = Ticket(
        show=show_name,
        user=user,
        price=price,
<strong class="bold">        details=TicketDetails(),</strong>
    )
    async with db_session.begin():
        db_session.add(ticket)
        await db_session.flush()
        ticket_id = ticket.id
        await db_session.commit()
    return ticket_id</pre><p class="list-inset">In this example, each time a ticket is created, an empty record of ticket details is created as well to keep the <span class="No-Break">database consistent.</span></p></li> </ol>
<p>This was the minimum <a id="_idIndexMarker381"/>setup to handle one-to-one relationships. We will continue by setting up <span class="No-Break">many-to-one relationships.</span></p>
<h3>Many to one</h3>
<p>A ticket can be<a id="_idIndexMarker382"/> associated with an event, and an event can have multiple tickets. To showcase a many-to-one relationship, we will create an <strong class="source-inline">events</strong> table that will have a relationship with the <strong class="source-inline">tickets</strong> table. Let’s go through the <span class="No-Break">following steps:</span></p>
<p>Let’s first create a column in the <strong class="source-inline">tickets</strong> table that will accommodate the reference to the <strong class="source-inline">events</strong> table in the <strong class="source-inline">database.py</strong> module, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
class Ticket(Base):
    __tablename__ = "tickets"
    # skip existing columns
<strong class="bold">    event_id: Mapped[int | None] = mapped_column(</strong>
<strong class="bold">        ForeignKey("events.id")</strong>
<strong class="bold">    )</strong>
<strong class="bold">    event: Mapped["Event | None"] = relationship(</strong>
<strong class="bold">        back_populates="tickets"</strong>
<strong class="bold">    )</strong></pre> <p>Then, we create an <strong class="source-inline">Event</strong> class to map the <strong class="source-inline">events</strong> table into <span class="No-Break">the database:</span></p>
<pre class="source-code">
class Event(Base):
    __tablename__ = "events"
    id: Mapped[int] = mapped_column(primary_key=True)
    name: Mapped[str]
    tickets: Mapped[list["Ticket"]] = relationship(
        back_populates="event"
    )</pre> <p><strong class="source-inline">ForeignKey</strong>, in this case, is defined only in the <strong class="source-inline">Ticket</strong> class since the event associated can be <span class="No-Break">only one.</span></p>
<p>This is all you need to <a id="_idIndexMarker383"/>create a <span class="No-Break">many-to-one relationship.</span></p>
<p class="callout-heading">Exercise</p>
<p class="callout">You can add to the application the operations to create an event and specify the number of tickets to create with it. Once you’ve done this, expose the operation with the <span class="No-Break">corresponding endpoint.</span></p>
<h3>Many to many</h3>
<p>Let’s imagine that we<a id="_idIndexMarker384"/> have a list of sponsors that can sponsor our events. Since we can have multiple sponsors that can sponsor multiple events, this situation is best representative of a <span class="No-Break">many-to-many relationship.</span></p>
<p>To work with many-to-many relationships, we need to define a class for the concerned tables and another class to track the so-called <span class="No-Break"><em class="italic">association table</em></span><span class="No-Break">.</span></p>
<p>Let’s start by defining a column to accommodate relationships in the <span class="No-Break"><strong class="source-inline">Event</strong></span><span class="No-Break"> class:</span></p>
<pre class="source-code">
class Event(Base):
    __tablename__ = "events"
    # existing columns
<strong class="bold">    sponsors: Mapped[list["Sponsor"]] = relationship(</strong>
<strong class="bold">        secondary="sponsorships",</strong>
<strong class="bold">        back_populates="events",</strong>
<strong class="bold">    )</strong></pre> <p>Then, we can create a class to map the <span class="No-Break"><strong class="source-inline">sponsors</strong></span><span class="No-Break"> table:</span></p>
<pre class="source-code">
class Sponsor(Base):
    __tablename__ = "sponsors"
    id: Mapped[int] = mapped_column(primary_key=True)
    name: Mapped[str] = mapped_column(unique=True)
    events: Mapped[list["Event"]] = relationship(
        secondary="sponsorships",
        back_populates="sponsors",
    )</pre> <p>As you might have <a id="_idIndexMarker385"/>noticed, the class contains columns to accommodate the <span class="No-Break"><strong class="source-inline">events</strong></span><span class="No-Break"> reference.</span></p>
<p>Finally, we can define an association table that will be the <span class="No-Break"><strong class="source-inline">sponsorships</strong></span><span class="No-Break"> table:</span></p>
<pre class="source-code">
class Sponsorship(Base):
    __tablename__ = "sponsorships"
    event_id: Mapped[int] = mapped_column(
        ForeignKey("events.id"), primary_key=True
    )
    sponsor_id: Mapped[int] = mapped_column(
        ForeignKey("sponsors.id"), primary_key=True
    )
    amount: Mapped[float] = mapped_column(
        nullable=False, default=10
    )</pre> <p>The association table can contain information on the relationship itself. For example, in our case, a piece of useful information is the amount provided by the sponsor for <span class="No-Break">the event.</span></p>
<p>This is all you need to <a id="_idIndexMarker386"/>create many-to-many relationships for your ticketing <span class="No-Break">system platform.</span></p>
<p class="callout-heading">Exercise</p>
<p class="callout">To complete your application, create an operations function with the relative endpoints to do <span class="No-Break">the following:</span></p>
<p class="callout">- Add a sponsor to <span class="No-Break">the database.</span></p>
<p class="callout">- Add a sponsorship with the amount. If the sponsorship already exists, replace the sponsorship with the <span class="No-Break">new amount.</span></p>
<h2 id="_idParaDest-210"><a id="_idTextAnchor213"/>See also</h2>
<p>You can dive deeper into handling relationships with SQLAlchemy at the following official <span class="No-Break">documentation page:</span></p>
<ul>
<li><em class="italic">SQLAlchemy basic </em><span class="No-Break"><em class="italic">relationships</em></span><span class="No-Break">: </span><a href="https://docs.sqlalchemy.org/en/20/orm/basic_relationships.xhtml"><span class="No-Break">https://docs.sqlalchemy.org/en/20/orm/basic_relationships.xhtml</span></a></li>
</ul>
<h1 id="_idParaDest-211"><a id="_idTextAnchor214"/>Optimizing SQL queries for performance</h1>
<p>Optimizing SQL <a id="_idIndexMarker387"/>queries is key in database management, as it enhances efficiency, scalability, cost-effectiveness, user satisfaction, data integrity, compliance, <span class="No-Break">and security.</span></p>
<p>This recipe shows how to make applications run faster by improving SQL queries. Queries that use fewer resources and less time can enhance user satisfaction and application capacity. Improving SQL queries is a repeated process, but you could use some tips that could <span class="No-Break">assist you.</span></p>
<h2 id="_idParaDest-212"><a id="_idTextAnchor215"/>Getting ready</h2>
<p>Make sure you have an existing application running using SQLAlchemy for database interaction or to keep working on the ticketing system application all along the chapter. Also, basic knowledge of SQL and database schema design can <span class="No-Break">be beneficial.</span></p>
<h2 id="_idParaDest-213"><a id="_idTextAnchor216"/>How to do it…</h2>
<p>Improving SQL queries is a process that involves several steps. As with most optimization processes, many steps are specific to the use case, but there are general rules that can help optimize SQL queries overall, such as <span class="No-Break">the following:</span></p>
<ul>
<li>Avoid <span class="No-Break"><em class="italic">N</em></span><span class="No-Break">+1 queries</span></li>
<li>Use the <strong class="source-inline">JOIN</strong> <span class="No-Break">statement sparingly</span></li>
<li>Minimize data <span class="No-Break">to fetch</span></li>
</ul>
<p>We will apply each with a <span class="No-Break">significant example.</span></p>
<h3>Avoiding N+1 queries</h3>
<p>The N+1 query issue<a id="_idIndexMarker388"/> happens when your application does one query to get a list of items and then loops over those items to get related data, making N <span class="No-Break">more queries.</span></p>
<p>Let’s say we want an endpoint to show all events with the associated sponsors. A first try might be to fetch the <strong class="source-inline">events</strong> table and loop over the events to fetch the <strong class="source-inline">sponsors</strong> table. This solution means a first query to get the events and N more queries to get the sponsors for each event, which is exactly what we want <span class="No-Break">to avoid.</span></p>
<p>The solution is to load all related records in the query to retrieve the related sponsors. This is technically called <span class="No-Break"><em class="italic">eager loading</em></span><span class="No-Break">.</span></p>
<p>In SQLAlchemy, this is done by using a <strong class="source-inline">joinedload</strong> option so that the function operation will look <span class="No-Break">like this:</span></p>
<pre class="source-code">
async def get_events_with_sponsors(
    db_session: AsyncSession
) -&gt; list[Event]:
    query = (
        select(Event)
<strong class="bold">        .options(</strong>
<strong class="bold">            </strong><strong class="bold">joinedload(Event.sponsors)</strong>
<strong class="bold">        )</strong>
    )
    async with db_session as session:
        result = await session.execute(query)
        events = result.scalars().all()
    return events</pre> <p>The <strong class="source-inline">joinedload</strong> method <a id="_idIndexMarker389"/>will include a <strong class="source-inline">JOIN</strong> operation on the query, so it is no longer necessary to make N queries to get <span class="No-Break">the sponsors.</span></p>
<h3>Using the join statement sparingly</h3>
<p>Joined tables can<a id="_idIndexMarker390"/> make the query easier to read. But be careful and only join tables that you need for <span class="No-Break">your query.</span></p>
<p>Suppose we want to get a list of sponsors names with the amount given for a certain event in order from the highest to <span class="No-Break">the lowest.</span></p>
<p>We can use multiple joins since we need to fetch three tables. The function would look <span class="No-Break">like this:</span></p>
<pre class="source-code">
async def get_event_sponsorships_with_amount(
    db_session: AsyncSession, event_id: int
):
    query = (
<strong class="bold">        select(Sponsor.name, Sponsorship.amount)</strong>
<strong class="bold">        .join(</strong>
<strong class="bold">            Sponsorship,</strong>
<strong class="bold">            Sponsorship.sponsor_id == Sponsor.id,</strong>
<strong class="bold">        )</strong>
<strong class="bold">        .join(</strong>
<strong class="bold">            Event,</strong>
<strong class="bold">            Sponsorship.event_id == Event.id</strong>
<strong class="bold">        </strong><strong class="bold">)</strong>
<strong class="bold">        .order_by(Sponsorship.amount.desc())</strong>
    )
    async with db_session as session:
        result = await session.execute(query)
        sponsor_contributions = result.fetchall()
    return sponsor_contributions</pre> <p>The double join <a id="_idIndexMarker391"/>implies to call the <strong class="source-inline">events</strong> table that we won’t use, so it would be much more efficient to organize the query <span class="No-Break">as follows:</span></p>
<pre class="source-code">
async def get_event_sponsorships_with_amount(
    db_session: AsyncSession, event_id: int
):
    query = (
<strong class="bold">        </strong><strong class="bold">select(Sponsor.name, Sponsorship.amount)</strong>
<strong class="bold">        .join(</strong>
<strong class="bold">            Sponsorship,</strong>
<strong class="bold">            Sponsorship.sponsor_id == Sponsor.id,</strong>
<strong class="bold">        )</strong>
<strong class="bold">        .where(Sponsorship.event_id == event_id)</strong>
<strong class="bold">        .order_by(Sponsorship.amount.desc())</strong>
    )
    async with db_session as session:
        result = await session.execute(query)
        sponsor_contributions = result.fetchall()
    return sponsor_contributions</pre> <p>This will return <a id="_idIndexMarker392"/>what we need without selecting the <strong class="source-inline">events</strong> table <span class="No-Break">at all.</span></p>
<h3>Minimizing data to fetch</h3>
<p>Fetching more data<a id="_idIndexMarker393"/> than needed can slow down your queries and <span class="No-Break">the application.</span></p>
<p>Use SQLAlchemy’s <strong class="source-inline">load_only</strong> function to load only specific columns from <span class="No-Break">the database.</span></p>
<p>Imagine that for a marketing analysis, we are asked to make a function that gets a list of tickets with only the ticket ID, the user, and <span class="No-Break">the price:</span></p>
<pre class="source-code">
async def get_events_tickets_with_user_price(
    db_session: AsyncSession, event_id: int
) -&gt; list[Ticket]:
    query = (
        select(Ticket)
        .where(Ticket.event_id == event_id)
        .options(
            load_only(
                Ticket.id, Ticket.user, Ticket.price
            )
        )
    )
    async with db_session as session:
        result = await session.execute(query)
        tickets = result.scalars().all()
    return tickets</pre> <p>We now try to retrieve the tickets from this function, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
tickets = await get_events_tickets_with_user_price(
    session, event_id
)</pre> <p>You will notice that each element only has the <strong class="source-inline">id</strong>, <strong class="source-inline">user</strong>, and <strong class="source-inline">price</strong> fields and it will give an error if you<a id="_idIndexMarker394"/> attempt to access the <strong class="source-inline">show</strong> field, for example. In larger applications, this can reduce memory usage and make responses <span class="No-Break">much faster.</span></p>
<h2 id="_idParaDest-214"><a id="_idTextAnchor217"/>There’s more…</h2>
<p>SQL query optimization <a id="_idIndexMarker395"/>involves more than what the recipe showed. Often, choosing a certain SQL database depends on specific <span class="No-Break">optimization needs.</span></p>
<p>Different SQL databases may have different strengths and weaknesses in handling these factors, depending on their architecture and features. For example, some SQL databases may support partitioning, sharding, replication, or distributed processing, which can improve the scalability and availability of data. Some SQL databases may offer more advanced query optimization techniques, such as cost-based optimization, query rewriting, or query caching, which can reduce the execution time and resource consumption of queries. Some SQL databases may implement different storage engines, transaction models, or index types, which can affect the performance and consistency of <span class="No-Break">data operations.</span></p>
<p>Therefore, when choosing an SQL database for a specific application, it is important to consider the characteristics and requirements of the data and queries, and compare the capabilities and limitations of the available SQL databases. A good way to do this is to benchmark the performance of SQL databases using realistic datasets and queries and measure the relevant metrics, such as throughput, latency, accuracy, and reliability. By doing so, one can find the optimal SQL database for the given scenario and also identify potential areas for<a id="_idIndexMarker396"/> improvement in the database design and <span class="No-Break">query formulation.</span></p>
<h1 id="_idParaDest-215"><a id="_idTextAnchor218"/>Securing sensitive data in SQL databases</h1>
<p>Sensitive data, such<a id="_idIndexMarker397"/> as personal information, financial<a id="_idIndexMarker398"/> records, or confidential documents, is often stored in SQL databases for various applications and purposes. However, this also exposes the data to potential risks of unauthorized access, theft, leakage, or corruption. Therefore, it is essential to secure sensitive data in SQL databases and protect it from malicious attacks or <span class="No-Break">accidental errors.</span></p>
<p>This recipe will show how to store sensitive data, such as credit card information, in <span class="No-Break">SQL databases.</span></p>
<h2 id="_idParaDest-216"><a id="_idTextAnchor219"/>Getting ready</h2>
<p>To follow the recipe, you need to have an application with a database connection already <span class="No-Break">in place.</span></p>
<p>Furthermore, we will use the <strong class="source-inline">cryptography</strong> package. If you haven’t installed it with the <strong class="source-inline">requirements.txt</strong> file, you can do it by running this command in <span class="No-Break">your environment:</span></p>
<pre class="console">
$ pip install cryptography</pre> <p>A sound knowledge of cryptography can be beneficial but is <span class="No-Break">not necessary.</span></p>
<h2 id="_idParaDest-217"><a id="_idTextAnchor220"/>How to do it…</h2>
<p>We will make a new table from the ground up to store credit card information. Some of the information, such as credit card numbers <a id="_idIndexMarker399"/>and <strong class="bold">Card Verification Values</strong> (<strong class="bold">CVV</strong>), will not be saved in clear text in our database but rather encrypted. Since we need to get it back, we will use a symmetric encryption that needs a key. Let's make the process through the <span class="No-Break">following steps.</span></p>
<ol>
<li>Let’s start by creating a class in the <strong class="source-inline">database.py</strong> module that corresponds to the <strong class="source-inline">credit_card</strong> table in our database, <span class="No-Break">as follows:</span><pre class="source-code">
class CreditCard(Base):
    __tablename__ = "credit_cards"
    id: Mapped[int] = mapped_column(primary_key=True)
    number: Mapped[str]
    expiration_date: Mapped[str]
    cvv: Mapped[str]
    card_holder_name: Mapped[str]</pre></li> <li>Next, in<a id="_idIndexMarker400"/> the <strong class="source-inline">app</strong> folder, we <a id="_idIndexMarker401"/>create a module named <strong class="source-inline">security.py</strong> where we will write our code for encrypting and decrypting data <a id="_idIndexMarker402"/>using <strong class="bold">Fernet symmetric encryption</strong>, <span class="No-Break">as follows:</span><pre class="source-code">
from cryptography.fernet import Fernet
cypher_key = Fernet.generate_key()
cypher_suite = Fernet(cypher_key)</pre><p class="list-inset">The <strong class="source-inline">cypher_suite</strong> object will be used to define the encryption and <span class="No-Break">decryption function.</span></p><p class="list-inset">It is worth mentioning that in a production environment, the <strong class="source-inline">cypher_key</strong> object can be either kept in an external service that offers rotation or created at startup, based on the security needs of <span class="No-Break">the business.</span></p></li> <li>In the same module, we can create a function to encrypt credit card info and one to decrypt it <span class="No-Break">as follows:</span><pre class="source-code">
def encrypt_credit_card_info(card_info: str) -&gt; str:
    return cypher_suite.encrypt(
        card_info.encode()
    ).decode()
def decrypt_credit_card_info(
    encrypted_card_info: str,
) -&gt; str:
    return cypher_suite.decrypt(
        encrypted_card_info.encode()
    ).decode()</pre><p class="list-inset">Those functions will<a id="_idIndexMarker403"/> be<a id="_idIndexMarker404"/> used when writing and reading from <span class="No-Break">the database.</span></p></li> <li>Then, we can write a storing operation in the same <strong class="source-inline">security.py</strong> module <span class="No-Break">as follows:</span><pre class="source-code">
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession
from app.database import CreditCard
async def store_credit_card_info(
    db_session: AsyncSession,
    card_number: str,
    card_holder_name: str,
    expiration_date: str,
    cvv: str,
):
    encrypted_card_number = encrypt_credit_card_info(
        card_number
    )
    encrypted_cvv = encrypt_credit_card_info(cvv)
    # Store encrypted credit card information
    # in the database
    credit_card = CreditCard(
        number=encrypted_card_number,
        card_holder_name=card_holder_name,
        expiration_date=expiration_date,
        cvv=encrypted_cvv,
    )
    async with db_session.begin():
        db_session.add(credit_card)
        await db_session.flush()
        credit_card_id = credit_card.id
        await db_session.commit()
    return credit_card_id</pre><p class="list-inset">Each time the function is awaited, the credit card information will be stored with the confidential <span class="No-Break">data encrypted.</span></p></li> <li>Similarly, we <a id="_idIndexMarker405"/>can<a id="_idIndexMarker406"/> define a function to retrieve the encrypted credit card information from the database <span class="No-Break">as follows:</span><pre class="source-code">
async def retrieve_credit_card_info(
    db_session: AsyncSession, credit_card_id: int
):
    query = select(CreditCard).where(
        CreditCard.id == credit_card_id
    )
    async with db_session as session:
        result = await session.execute(query)
        credit_card = result.scalars().first()
    credit_card_number = decrypt_credit_card_info(
            credit_card.number
        ),
    cvv = decrypt_credit_card_info(credit_card.cvv)
    card_holder = credit_card.card_holder_name
    expiry = credit_card.expiration_date
    return {
        "card_number": credit_card_number,
        "card_holder_name": card_holder,
        "expiration_date": expiry,
        "cvv": cvv
    }</pre><p class="list-inset">We have just developed code to save confidential information in <span class="No-Break">our database.</span></p></li> </ol>
<p class="callout-heading">Exercise</p>
<p class="callout">We just saw the backbone of how to store sensitive data securely. You can complete the feature by yourself by doing <span class="No-Break">the following:</span></p>
<p class="callout">- Writing unit tests for our encryption operations. In the <strong class="source-inline">tests</strong> folder, let’s create a new test module called <strong class="source-inline">test_security.py</strong>. Verify that the credit card is securely saved in our database, but the fields for credit card numbers and CVV <span class="No-Break">are encrypted.</span></p>
<p class="callout">- Creating endpoints to store, retrieve, and delete credit card information in <span class="No-Break">the database.</span></p>
<p class="callout">- Associating a credit card with a sponsor and managing the relative <span class="No-Break">CRUD operations.</span></p>
<h2 id="_idParaDest-218"><a id="_idTextAnchor221"/>See also</h2>
<p>We have used<a id="_idIndexMarker407"/> Fernet <a id="_idIndexMarker408"/>symmetric encryption to encrypt credit card information. You can have a deeper insight about it at the <span class="No-Break">following link:</span></p>
<ul>
<li><em class="italic">Fernet symmetric </em><span class="No-Break"><em class="italic">encryption</em></span><span class="No-Break">: </span><a href="https://cryptography.io/en/latest/fernet/"><span class="No-Break">https://cryptography.io/en/latest/fernet/</span></a></li>
</ul>
<h1 id="_idParaDest-219"><a id="_idTextAnchor222"/>Handling transactions and concurrency</h1>
<p>In the realm of database<a id="_idIndexMarker409"/> management, two critical aspects govern the reliability and performance of applications: handling transactions and <span class="No-Break">managing concurrency.</span></p>
<p>Transactions, encapsulating a series of database operations, are fundamental for maintaining data consistency by ensuring that changes occur as a single unit of work. Concurrency, on the other hand, addresses the challenge of managing simultaneous access to shared resources by multiple users <span class="No-Break">or processes.</span></p>
<p>The relationship between transactions and concurrency becomes apparent when considering scenarios where multiple transactions may attempt to access or modify the same data concurrently. Without proper concurrency control mechanisms such as locking, transactions could interfere with each other, potentially leading to data corruption <span class="No-Break">or inconsistencies.</span></p>
<p>The recipe will show how to manage transactions and concurrency with FastAPI and SQLAlchemy by emulating the process of selling tickets from the ticketing platform <span class="No-Break">we created.</span></p>
<h2 id="_idParaDest-220"><a id="_idTextAnchor223"/>Getting ready</h2>
<p>You need a CRUD application as the basis for the recipe, or you can continue to use the ticketing system application that we have been using throughout <span class="No-Break">the chapter.</span></p>
<h2 id="_idParaDest-221"><a id="_idTextAnchor224"/>How to do it…</h2>
<p>The most significant <a id="_idIndexMarker410"/>situation where transaction and concurrency become important is in managing updating operations, such as with the sales ticket for <span class="No-Break">our application.</span></p>
<p>We will begin by creating a function operation that will label our ticket as sold and give the name of the customer. Then, we will simulate two sales occurring at the same time and observe the outcome. To do so, follow <span class="No-Break">these steps.</span></p>
<ol>
<li>In the <strong class="source-inline">operations.py</strong> module, create the function to sell a ticket <span class="No-Break">as follows::</span><pre class="source-code">
async def sell_ticket_to_user(
    db_session: AsyncSession, ticket_id: int, user: str
) -&gt; bool:
    ticket_query = (
        update(Ticket)
        .where(
            and_(
                Ticket.id == ticket_id,
                Ticket.sold == False,
            )
        )
        .values(user=user, sold=True)
    )
    async with db_session as session:
        result = (
           await db_session.execute(ticket_query)
        )
        await db_session.commit()
        if result.rowcount == 0:
            return False
    return True</pre><p class="list-inset">The query will only sell the ticket if the ticket has not been sold yet; otherwise, the function will <span class="No-Break">return </span><span class="No-Break"><strong class="source-inline">False</strong></span><span class="No-Break">.</span></p></li> <li>Let’s try to add <a id="_idIndexMarker411"/>a ticket to our database and try to simulate two users buying the same ticket at the same time. Let’s write all in the form of <span class="No-Break">unit tests.</span><p class="list-inset">We start by defining a fixture to write our ticket into the database in the <strong class="source-inline">tests/conftest.py</strong> file <span class="No-Break">as follows:</span></p><pre class="source-code">
@pytest.fixture
async def add_special_ticket(db_session_test):
    ticket = Ticket(
        id=1234,
        show="Special Show",
        details=TicketDetails(),
    )
    async with db_session_test.begin():
        db_session_test.add(ticket)
        await db_session_test.commit()</pre></li> <li>We can create a test by performing two concurrent sales with two separate database sessions (define another one as a different fixture) to do them at the same time in<a id="_idIndexMarker412"/> the <span class="No-Break"><strong class="source-inline">tests/test_operations.py</strong></span><span class="No-Break"> file:</span><pre class="source-code">
import asyncio
async def test_concurrent_ticket_sales(
    add_special_ticket,
    db_session_test,
    second_session_test,
):
    result = await asyncio.gather(
        sell_ticket_to_user(
            db_session_test, 1234, "Jake Fake"
        ),
        sell_ticket_to_user(
            second_session_test, 1234, "John Doe"
        ),
    )
    assert result in (
        [True, False],
        [False, True],
    )  # only one of the sales should be successful
    ticket = await get_ticket(db_session_test, 1234)
    # assert that the user who bought the ticket
    # correspond to the successful sale
    if result[0]:
        assert ticket.user == "Jake Fake"
    else:
        assert ticket.user == "John Doe"</pre><p class="list-inset">In the test function, we run two coroutines at the same time by using the <strong class="source-inline">asyncio.gather</strong> <span class="No-Break">function.</span></p><p class="list-inset">We just assume <a id="_idIndexMarker413"/>that only one user can purchase the ticket and they will match the successful transaction. Once we have created the test, we can execute with <strong class="source-inline">pytest</strong> <span class="No-Break">as follows:</span></p><pre class="source-code"><strong class="bold">$ pytest tests/test_operations.py::test_concurrent_ticket_sales</strong></pre></li> </ol>
<p>The test will succeed, which means that the asynchronous session handles <span class="No-Break">transaction conflicts.</span></p>
<p class="callout-heading">Exercise</p>
<p class="callout">You have just created a draft of the selling ticket operation. As an exercise, you can improve the draft by doing <span class="No-Break">the following:</span></p>
<p class="callout">- Adding a table for users to <span class="No-Break">the database</span></p>
<p class="callout">- Adding the foreign key reference of the user on the ticket to make <span class="No-Break">it sold</span></p>
<p class="callout">- Creating an <strong class="source-inline">alembic</strong> migration for the <span class="No-Break">database modification</span></p>
<p class="callout">- Creating an API endpoint that exposes the <span class="No-Break"><strong class="source-inline">sell_ticket_to_user</strong></span><span class="No-Break"> function</span></p>
<h2 id="_idParaDest-222"><a id="_idTextAnchor225"/>There’s more…</h2>
<p>One of the fundamental challenges of database systems is to handle concurrent transactions from <a id="_idIndexMarker414"/>multiple users while preserving data consistency and integrity. Different types of transactions may have different requirements for how they access and modify data and how they deal with other transactions that may conflict with them. For example, a common way to manage concurrency is to use <em class="italic">locks</em>, which are mechanisms that prevent unauthorized or incompatible operations on data. However, locks can also introduce trade-offs between performance, availability, <span class="No-Break">and correctness.</span></p>
<p>Depending on the business needs, some transactions may need to acquire locks for longer periods or at different levels of granularity, such as table-level or row-level. For example, SQLite only allows locks on a database level, while PostgreSQL allows locks till the row <span class="No-Break">table level.</span></p>
<p>Another key aspect of managing concurrent transactions is the concept of <em class="italic">isolation levels</em>, which define the degree to which one transaction must be isolated from the effects of other concurrent transactions. Isolation levels ensure that transactions maintain data consistency despite simultaneous access and modification by <span class="No-Break">multiple users.</span></p>
<p>The SQL standard <a id="_idIndexMarker415"/>defines four isolation levels, each offering different trade-offs between concurrency and <span class="No-Break">data consistency:</span></p>
<ol>
<li><span class="No-Break"><strong class="bold">READ UNCOMMITTED</strong></span><span class="No-Break">:</span><ul><li>Transactions at this level allow dirty reads, meaning a transaction can see uncommitted changes made by other <span class="No-Break">concurrent transactions.</span></li><li>Non-repeatable reads and phantom reads <span class="No-Break">are possible.</span></li><li>This isolation level provides the highest concurrency but the lowest level of <span class="No-Break">data consistency.</span></li></ul></li>
<li><span class="No-Break"><strong class="bold">READ COMMITTED</strong></span><span class="No-Break">:</span><ul><li>Transactions at this level only see changes committed by <span class="No-Break">other transactions.</span></li><li>They do not allow <span class="No-Break">dirty reads.</span></li><li>Non-repeatable<a id="_idIndexMarker416"/> reads are possible, but phantom reads can <span class="No-Break">still occur.</span></li><li>This level strikes a balance between concurrency <span class="No-Break">and consistency.</span></li></ul></li>
<li><span class="No-Break"><strong class="bold">REPEATABLE READ</strong></span><span class="No-Break">:</span><ul><li>Transactions at this level see a consistent snapshot of the data throughout <span class="No-Break">the transaction.</span></li><li>Changes committed by other transactions after the transaction began are <span class="No-Break">not visible.</span></li><li>Non-repeatable reads are prevented, but phantom reads <span class="No-Break">can occur.</span></li><li>This level provides stronger consistency at the cost of <span class="No-Break">some concurrency.</span></li></ul></li>
<li><span class="No-Break"><strong class="bold">SERIALIZABLE</strong></span><span class="No-Break">:</span><ul><li>Transactions at this level behave as if they are executed serially – that is, one <span class="No-Break">after another.</span></li><li>They provide the highest level of <span class="No-Break">data consistency.</span></li><li>Non-repeatable reads and phantom reads <span class="No-Break">are prevented.</span></li><li>This level offers strong consistency but may result in reduced concurrency due to <span class="No-Break">increased locking.</span></li></ul></li>
</ol>
<p>SQLite, for example, allows isolation, while MySQL and PostgreSQL offer all four <span class="No-Break">transaction levels.</span></p>
<p>When the database supports it, in SQLAlchemy, you can set up the isolation level per engine or connection by specifying it as an argument <span class="No-Break">when initializing.</span></p>
<p>For example, if you want to specify the isolation level at the engine level for PostgreSQL, the engine will be initialized <span class="No-Break">as follows:</span></p>
<pre class="source-code">
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
eng = create_engine(
    "postgresql+psycopg2://scott:tiger@localhost/test",
<strong class="bold">    isolation_level="REPEATABLE READ",</strong>
)
Session = sessionmaker(eng)</pre> <p>All these choices in terms of locks and isolation level affect the architecture and design of the database <a id="_idIndexMarker417"/>system since not all SQL databases support it. Therefore, it is important to understand the principles and best practices of locking strategies and how they relate to the transaction behavior and the <span class="No-Break">business logic.</span></p>
<p>You have just completed a comprehensive overview of integrating SQL databases with FastAPI. In the next chapter, we will explore integrating FastAPI applications with <span class="No-Break">NoSQL databases.</span></p>
<h2 id="_idParaDest-223"><a id="_idTextAnchor226"/>See also</h2>
<p>You can find more information about locking strategies for SQLite and PostgreSQL at the <span class="No-Break">following links:</span></p>
<ul>
<li><em class="italic">SQLite </em><span class="No-Break"><em class="italic">locking</em></span><span class="No-Break">: </span><a href="https://www.sqlite.org/lockingv3.xhtml"><span class="No-Break">https://www.sqlite.org/lockingv3.xhtml</span></a></li>
<li><em class="italic">PostgreSQL </em><span class="No-Break"><em class="italic">locking</em></span><span class="No-Break">: </span><a href="https://www.postgresql.org/docs/current/explicit-locking.xhtml"><span class="No-Break">https://www.postgresql.org/docs/current/explicit-locking.xhtml</span></a></li>
</ul>
<p>Information on the isolation level for singular databases can be found on the respective <span class="No-Break">documentation pages:</span></p>
<ul>
<li><em class="italic">SQLite </em><span class="No-Break"><em class="italic">isolation</em></span><span class="No-Break">: </span><a href="https://www.sqlite.org/isolation.xhtml"><span class="No-Break">https://www.sqlite.org/isolation.xhtml</span></a></li>
<li><em class="italic">MySQL isolation </em><span class="No-Break"><em class="italic">levels</em></span><span class="No-Break">: </span><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.xhtml"><span class="No-Break">https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.xhtml</span></a></li>
<li><em class="italic">PostgreSQL isolation </em><span class="No-Break"><em class="italic">levels</em></span><span class="No-Break">: </span><a href="https://www.postgresql.org/docs/current/transaction-iso.xhtml"><span class="No-Break">https://www.postgresql.org/docs/current/transaction-iso.xhtml</span></a></li>
</ul>
<p>Also, a comprehensive guide on how to manage isolation levels with SQLAlchemy is available at <span class="No-Break">the link:</span></p>
<ul>
<li><em class="italic">SQLAlchemy session </em><span class="No-Break"><em class="italic">transaction</em></span><span class="No-Break">: </span><a href="https://docs.sqlalchemy.org/en/20/orm/session_transaction.xhtml"><span class="No-Break">https://docs.sqlalchemy.org/en/20/orm/session_transaction.xhtml</span></a></li>
</ul>
</div>
</div></body></html>