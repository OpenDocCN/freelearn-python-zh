<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-190"><a id="_idTextAnchor193"/>6</h1>
<h1 id="_idParaDest-191"><a id="_idTextAnchor194"/>Integrating FastAPI with SQL Databases</h1>
<p>We’ll now embark on a journey to harness the full potential of SQL databases within your FastAPI applications. This chapter is meticulously designed to guide you through the nuances of leveraging <strong class="bold">SQLAlchemy</strong>, a <a id="_idIndexMarker346"/>powerful SQL toolkit and <strong class="bold">object-relational </strong><strong class="bold">mapping</strong> (<strong class="bold">ORM</strong>) for<a id="_idIndexMarker347"/> Python. From setting up your database environment to implementing sophisticated <strong class="bold">create, read, update and delete</strong> (<strong class="bold">CRUD</strong>) operations and managing complex relationships, this chapter provides a comprehensive blueprint for integrating SQL databases seamlessly<a id="_idIndexMarker348"/> with FastAPI.</p>
<p>By creating a basic ticketing platform, you’ll practically engage in configuring SQLAlchemy with FastAPI, creating data models that reflect your application’s data structures, and crafting efficient, secure CRUD operations.</p>
<p>Moreover, you’ll explore the management of database migrations with <strong class="bold">Alembic</strong>, ensuring your database schema evolves alongside your application without hassle. This chapter doesn’t stop at just handling data; it delves into optimizing SQL queries for performance, securing sensitive information within your database, and managing transactions and concurrency to ensure data integrity and reliability.</p>
<p>By the end of this chapter, you’ll be adept at integrating and managing SQL databases in your FastAPI applications, equipped with the skills to ensure your applications are not only efficient and scalable but also secure. Whether you’re building a new application from scratch or integrating a database into an existing project, the insights and techniques covered here will empower you to leverage the full power of SQL databases in your FastAPI projects.</p>
<p>In this chapter, we’re going to cover the following recipes:</p>
<ul>
<li>Setting up SQLAlchemy</li>
<li>Implementing CRUD operations</li>
<li>Working with migrations</li>
<li>Handling relationships in SQL databases</li>
<li>Optimizing SQL queries for performance</li>
<li>Securing sensitive data in SQL databases</li>
<li>Handling transactions and concurrency</li>
</ul>
<h1 id="_idParaDest-192"><a id="_idTextAnchor195"/>Technical requirements</h1>
<p>To follow along with all the recipes of the chapter, make sure you have these essentials in your setup:</p>
<ul>
<li><strong class="bold">Python</strong>: Your environment should have a Python version above 3.9 installed.</li>
<li><strong class="bold">FastAPI</strong>: It should be installed in your virtual environment with all the dependencies it needs. If you didn’t do it in the previous chapters, you can easily do it from your terminal:<pre class="source-code">
<strong class="bold">$ pip install fastapi[all]</strong></pre></li> </ul>
<p>The code that accompanies the chapter is available on GitHub at the following link: <a href="https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter06">https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter06</a></p>
<p>It is also advisable to create a virtual environment for the project inside the project root folder, to handle dependencies well and keep the project separate. In your virtual environment, you can install all the dependencies at once by using the <code>requirements.txt</code> file from the GitHub repo in the project folder:</p>
<pre class="console">
$ pip install –r requirements.txt</pre> <p>Since the code of the chapter will make use of the <code>async</code>/<code>await</code> syntax from the <code>asyncio</code> Python library, you should be already familiar with it. Feel free to read more about <code>asyncio</code> and <code>async</code>/<code>await</code> syntax at the following links:</p>
<ul>
<li><a href="https://docs.python.org/3/library/asyncio.xhtml">https://docs.python.org/3/library/asyncio.xhtml</a></li>
<li><a href="https://fastapi.tiangolo.com/async/">https://fastapi.tiangolo.com/async/</a></li>
</ul>
<p>Now that we have this ready Once we have everything ready, we can begin preparing our recipes.</p>
<h1 id="_idParaDest-193"><a id="_idTextAnchor196"/>Setting up SQLAlchemy</h1>
<p>To begin any data application, you <a id="_idIndexMarker349"/>need to establish a database connection. This recipe will help you set up and configure <code>sqlalchemy</code> package with an <strong class="bold">SQLite</strong> database<a id="_idIndexMarker350"/> so that you can use the advantages of SQL databases in your applications.</p>
<h2 id="_idParaDest-194"><a id="_idTextAnchor197"/>Getting ready</h2>
<p>The project is going to be fairly large, so we will put the working modules for the application in a folder named <code>app</code>, which will be under the root project folder that we will call <code>ticketing_system</code>.</p>
<p>You need <code>fastapi</code>, <code>sqlalchemy</code>, and <code>aiosqlite</code> installed in your environment to use the recipe. The recipe is meant to work with <code>sqlalchemy</code> with versions above 2.0.0. You can still use version 1; however, some adaptions are required. You can find a migration guide at the following link: <a href="https://docs.sqlalchemy.org/en/20/changelog/migration_20.xhtml">https://docs.sqlalchemy.org/en/20/changelog/migration_20.xhtml</a>.</p>
<p>If you haven’t installed the packages with the <code>requirements.txt</code> file in the repo, you can do it by running the following:</p>
<pre class="console">
$ pip install fastapi[all] "sqlalchemy&gt;=2.0.0" aiosqlite</pre> <p>Once the packages are correctly installed, you can follow the recipe.</p>
<h2 id="_idParaDest-195"><a id="_idTextAnchor198"/>How to do it...</h2>
<p>The setup of a generic SQL database connection with <code>sqlalchemy</code> will go through the following steps:</p>
<ol>
<li>Creating mapping object classes, that will match the database tables</li>
<li>Creating abstraction layers, an engine, and a session to communicate with the database</li>
<li>Initializing a database connection, at the server startup</li>
</ol>
<h3>Creating mapping object classes</h3>
<p>In the <code>app</code> folder, let’s <a id="_idIndexMarker351"/>create a module<a id="_idIndexMarker352"/> called <code>database.py</code> and then create a class object to track tickets as follows:</p>
<pre class="source-code">
from sqlalchemy import Column, Float, ForeignKey, Table
from sqlalchemy.orm import (
    DeclarativeBase,
    Mapped,
    mapped_column,
)
class Base(DeclarativeBase):
    pass
class Ticket(Base):
    __tablename__ = "tickets"
    id: Mapped[int] = mapped_column(primary_key=True)
    price: Mapped[float] = mapped_column(nullable=True)
    show: Mapped[str | None]
    user: Mapped[str | None]</pre> <p>We just created a <code>Ticket</code> class that will be used to match the <code>tickets</code> table into our SQL database.</p>
<h3>Creating abstraction layers</h3>
<p>In SQLAlchemy, the <em class="italic">engine</em> manages database connections and executes SQL statements, while <a id="_idIndexMarker353"/>a <em class="italic">session</em> allows querying, inserting, updating, and deleting data within a transactional context, ensuring consistency and atomicity. Sessions are bound to an engine for communication with the database.</p>
<p>We will start by creating a function that returns the engine. In a new module called <code>db_connection.py</code>, under the <code>app</code> folder, let’s write the function as follows:</p>
<pre class="source-code">
from sqlalchemy.ext.asyncio import (
    create_async_engine,
)
from sqlalchemy.orm import sessionmaker
SQLALCHEMY_DATABASE_URL = (
    "sqlite+aiosqlite:///.database.db"
)
def get_engine():
    return create_async_engine(
        SQLALCHEMY_DATABASE_URL, echo=True
    )</pre> <p>You may have observed <a id="_idIndexMarker354"/>that the <code>SQLALCHEMY_DATABASE_URL</code> database URL uses the <code>sqlite</code> and <code>aiosqlite</code> modules.</p>
<p>This implies that we will use an SQLite database where the operations will happen via the <code>aiosqlite</code> asynchronous library that supports the <code>asyncio</code> library.</p>
<p>Then, we will use a session maker to specify that the session will be asynchronous, as follows:</p>
<pre class="source-code">
from sqlalchemy.ext.asyncio import (
    AsyncSession,
)
AsyncSessionLocal = sessionmaker(
    autocommit=False,
    autoflush=False,
    bind=get_engine(),
    class_=AsyncSession,
)
async def get_db_session():
    async with AsyncSessionLocal() as session:
        yield session</pre> <p>The <code>get_db_session</code> function will be used as a dependency for each endpoint interacting <a id="_idIndexMarker355"/>with<a id="_idIndexMarker356"/> the database.</p>
<h3>Initializing a database connection</h3>
<p>Once we have the <a id="_idIndexMarker357"/>abstraction layers, we<a id="_idIndexMarker358"/> need to create our FastAPI server object and start the database classes when the server runs. We can do it in the <code>main.py</code> module under the <code>app</code> folder:</p>
<pre class="source-code">
from contextlib import asynccontextmanager
from fastapi import FastAPI
from app.database import Base
from app.db_connection import (
    AsynSessionLocal,
    get_db_session
)
@asynccontextmanager
async def lifespan(app: FastAPI):
    engine = get_engine()
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)
        yield
    await engine.dispose()ispose()
app = FastAPI(lifespan=lifespan)</pre> <p>To specify server actions at the startup event, we have used the <code>lifespan</code> parameter.</p>
<p>We have everything in <a id="_idIndexMarker359"/>place to connect our <a id="_idIndexMarker360"/>application with the database.</p>
<h2 id="_idParaDest-196"><a id="_idTextAnchor199"/>How it works…</h2>
<p>The creation of the <code>Ticket</code> database <a id="_idIndexMarker361"/>mapping class tells our application how the database is structured, and the session will manage the transactions. Then, the engine will not only execute the operations but compare the mapping classes with the database, and it will create tables if any are missing.</p>
<p>To check that our app communicates with our database, let’s spin up the server from the command line at the project root folder:</p>
<pre class="console">
$ uvicorn app.main:app</pre> <p>You should see message logs on the command output that says table tickets have been created. Furthermore, open the <code>.database.db</code> file with the database reader you prefer, and the table should be there with the schema that is defined in the <code>database.py</code> module.</p>
<h2 id="_idParaDest-197"><a id="_idTextAnchor200"/>See also</h2>
<p>You can see more about how to set up a database with SQLAlchemy and how to make it compatible with the <code>asyncio</code> module on the official documentation pages:</p>
<ul>
<li><em class="italic">How to set up an SQLAlchemy </em><em class="italic">database</em>: <a href="https://docs.sqlalchemy.org/en/20/orm/quickstart.xhtml">https://docs.sqlalchemy.org/en/20/orm/quickstart.xhtml</a></li>
<li><em class="italic">SQLAlchemy</em> <code>asyncio</code> <em class="italic">extension </em><em class="italic">reference</em>: <a href="https://docs.sqlalchemy.org/en/20/orm/extensions/asyncio.xhtml">https://docs.sqlalchemy.org/en/20/orm/extensions/asyncio.xhtml</a></li>
</ul>
<p>In this example, we have used an SQLite database by specifying the following:</p>
<pre class="source-code">
SQLALCHEMY_DATABASE_URL = "sqlite+aiosqlite:///.database.db"</pre> <p>However, you can use SQLAlchemy to interact with multiple SQL databases such as <code>asyncio</code>-supported driver, and the database address.</p>
<p>For example, for MySQL, the connection string would look like this:</p>
<pre class="source-code">
mysql+aiomysql://user:password@host:port/dbname[?key=value&amp;key=value...]</pre> <p>In this case, you need the <code>aiomysql</code> package installed in your environment.</p>
<p>You can check more on the official documentation pages:</p>
<ul>
<li>SQLAlchemy MySQL dialect: <a href="https://docs.sqlalchemy.org/en/20/dialects/mysql.xhtml">https://docs.sqlalchemy.org/en/20/dialects/mysql.xhtml</a></li>
<li>SQLAlchemy PostgreSQL dialect: <a href="https://docs.sqlalchemy.org/en/20/dialects/postgresql.xhtml">https://docs.sqlalchemy.org/en/20/dialects/postgresql.xhtml</a></li>
</ul>
<h1 id="_idParaDest-198"><a id="_idTextAnchor201"/>Implementing CRUD operations</h1>
<p>CRUD operations with a<a id="_idIndexMarker364"/> RESTful API can be implemented using HTTP methods (<code>POST</code>, <code>GET</code>, <code>PUT</code>, and <code>DELETE</code>) for web services. This recipe demonstrates how to use SQLAlchemy and <code>asyncio</code> to build CRUD operations asynchronously on an SQL database with the corresponding endpoints.</p>
<h2 id="_idParaDest-199"><a id="_idTextAnchor202"/>Getting ready</h2>
<p>Before you start with the recipe, you need to have a database connection and a table in the dataset, as well as a matching class in the code base. If you completed the previous recipe, you should have them ready.</p>
<h2 id="_idParaDest-200"><a id="_idTextAnchor203"/>How to do it…</h2>
<p>We’ll begin by making an <code>operations.py</code> module under the <code>app</code> folder to contain our database operations by following these steps.</p>
<ol>
<li>First, we can<a id="_idIndexMarker365"/> set up the operation to add a new ticket to the database as follows:<pre class="source-code">
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from app.database import Ticket
async def create_ticket(
    db_session: AsyncSession,
    show_name: str,
    user: str = None,
    price: float = None,
) -&gt; int:
    ticket = Ticket(
        show=show_name,
        user=user,
        price=price,
    )
    async with db_session.begin():
        db_session.add(ticket)
        await db_session.flush()
        ticket_id = ticket.id
        await db_session.commit()
    return ticket_id</pre><p class="list-inset">The function will give back the ID attached to the ticket when saved.</p></li> <li>Then, let’s create a function to get a ticket:<pre class="source-code">
async def get_ticket(
    db_session: AsyncSession, ticket_id: int
) -&gt; Ticket | None:
    query = (
        select(Ticket)
        .where(Ticket.id == ticket_id)
    )
    async with db_session as session:
        tickets = await session.execute(query)
        return tickets.scalars().first()</pre><p class="list-inset">If the ticket is<a id="_idIndexMarker366"/> not found, the function will return a <code>None</code> object.</p></li> <li>Then, we build an operation to update only the price of the ticket:<pre class="source-code">
async def update_ticket_price(
    db_session: AsyncSession,
    ticket_id: int,
    new_price: float,
) -&gt; bool:
    query = (
        update(Ticket)
        .where(Ticket.id == ticket_id)
        .values(price=new_price)
    )
    async with db_session as session:
        ticket_updated = await session.execute(query)
        await session.commit()
        if ticket_updated.rowcount == 0:
            return False
        return True</pre><p class="list-inset">The function gives back <code>False</code> if the operation couldn’t delete any ticket.</p></li> <li>To conclude the<a id="_idIndexMarker367"/> CRUD operations, we define a <code>delete_ticket</code> operation:<pre class="source-code">
async def delete_ticket(
    db_session: AsyncSession, ticket_id
) -&gt; bool:
    async with db_session as session:
        tickets_removed = await session.execute(
            delete(
                Ticket
            ).where(Ticket.id == ticket_id)
        )
        await session.commit()
        if tickets_removed.rowcount == 0:
            return False
        return True</pre><p class="list-inset">Similarly to the update operation, the function returns <code>False</code> if it does not find any ticket to delete.</p></li> <li>After defining the operations, we can expose them by creating the corresponding endpoints in the <code>main.py</code> module.<p class="list-inset">Let’s do it for the <a id="_idIndexMarker368"/>create operation right after defining the app server:</p><pre class="source-code">
from typing import Annotated
from sqlalchemy.ext.asyncio import AsyncSession
from app.db_connection import (
    AsyncSessionLocal,
    get_engine,
    get_session
)
from app.operations import create_ticket
# rest of the code 
class TicketRequest(BaseModel):
    price: float | None
    show: str | None
    user: str | None = None
@app.post("/ticket", response_model=dict[str, int])
async def create_ticket_route(
    ticket: TicketRequest,
    db_session: Annotated[
        AsyncSession,
        Depends(get_db_session)
    ]
):
    ticket_id = await create_ticket(
        db_session,
        ticket.show,
        ticket.user,
        ticket.price,
    )
    return {"ticket_id": ticket_id}</pre><p class="list-inset">The remaining operations can be exposed in the same way.</p></li> </ol>
<p class="callout-heading">Exercise</p>
<p class="callout">Similarly to what we did for the <code>create_ticket</code> operation, expose the other operations (get, update, and delete) with the respective endpoints.</p>
<h2 id="_idParaDest-201"><a id="_idTextAnchor204"/>How it works…</h2>
<p>The functions <a id="_idIndexMarker369"/>created to interact with the database are exposed through the endpoints. This means that an external user will execute the operations by calling the respective endpoints.</p>
<p>Let’s verify that the endpoint works correctly.</p>
<p>Start the server from the command line as usual by running the following:</p>
<pre class="console">
$ uvicorn app.main:app</pre> <p>Then, go to the interactive documentation link at <code>http://localhost:8000/docs</code>, and you will see the endpoints you just created. Experiment with them in different combinations and see the results in the <code>.database.db</code> database file.</p>
<p>You have just created CRUD operations to interact with an SQL database by using <code>sqlalchemy</code> with<a id="_idIndexMarker370"/> the <code>asyncio</code> library.</p>
<p class="callout-heading">Exercise</p>
<p class="callout">Make a <code>tests</code> folder in the root project folder and write all the unit tests for the operation functions and the endpoints. You can refer to <a href="B21025_05.xhtml#_idTextAnchor157"><em class="italic">Chapter 5</em></a>, <em class="italic">Testing and Debugging FastAPI Applications</em>, to learn how to unit test FastAPI applications.</p>
<h1 id="_idParaDest-202"><a id="_idTextAnchor205"/>Working with migrations</h1>
<p>Database migrations <a id="_idIndexMarker371"/>let you version control your database schema and keep it consistent across environments. They also help you automate the deployment of your database changes and track the history of your schema evolution.</p>
<p>The recipe shows you how to <a id="_idIndexMarker372"/>use <strong class="bold">Alembic</strong>, a popular tool for managing database migrations in Python. You will learn how to create, run, and roll back migrations and how to integrate them with your ticketing system.</p>
<h2 id="_idParaDest-203"><a id="_idTextAnchor206"/>Getting ready</h2>
<p>To use the recipe, you need to have <code>alembic</code> in your environment. You can install it with <code>pip,</code> if you didn’t do it with the <code>requirements.txt</code> file from the GitHub repository, by typing this on the command line:</p>
<pre class="console">
$ pip install alembic</pre> <p>You also need to make sure you have at least one class that corresponds to the table in the database you want to create. If you don’t have one, go back to the <em class="italic">Setting up SQLAlchemy</em> recipe and make one. If you’re already running the application, delete the <code>.database.db</code> file that the application has created.</p>
<h2 id="_idParaDest-204"><a id="_idTextAnchor207"/>How to do it…</h2>
<p>To configure Alembic and manage database migrations, go through the following steps.</p>
<ol>
<li>The first step is to set up <code>alembic</code>. In the project root folder, run the following command in the command line:<pre class="source-code">
<code>alembic.ini</code> file and an <code>alembic</code> folder with some files inside it. The <code>alembic.ini</code> file is a configuration file for <code>alembic</code>.</p><p class="list-inset">If you copy the project from the GitHub repository make sure to delete the existing <code>alembic</code> folder before running the <code>alembic </code><code>init</code> command.</p></li> <li>Find the <code>sqlalchemy.url</code> variable and set the database URL to the following:<pre class="source-code">
sqlalchemy.url = sqlite:///.database.db</pre><p class="list-inset">This specifies<a id="_idIndexMarker373"/> that we are using an SQLite database If you use a different database, adjust it accordingly.</p></li> <li>The <code>alembic</code> directory contains a folder version and an <code>env.py</code> file that has the variable for creating our database migrations.<p class="list-inset">Open the <code>env.py</code> file and find the <code>target_metadata</code> variable. Set its value to the metadata of our application as follows:</p><pre class="source-code">
from app.database import Base
target_metadata = Base.metadata</pre><p class="list-inset">We can now create our first database migration script and apply the migration.</p></li> <li>Execute the following command from the command line to create an initial migration:<pre class="source-code">
<code>alembic/versions</code> folder.</p></li> <li>Make sure you removed the existing <code>.database.db</code> file, and let’s execute our first migration with the following command:<pre class="source-code">
<code>.database.db</code> file with the <code>tickets</code> table in it.</p></li> </ol>
<h2 id="_idParaDest-205"><a id="_idTextAnchor208"/>How it works…</h2>
<p>Once we have the first version of our database, let’s see the migration in action.</p>
<p>Imagine we want to change the table in the <code>database.py</code> module while the application is already deployed in a production environment so that we can’t delete any records when updating it.</p>
<p>Add some tickets<a id="_idIndexMarker374"/> to the database, then in the code, let’s add a new field called <code>sold</code> that will indicate if the ticket has been sold or not:</p>
<pre class="source-code">
class Ticket(Base):
    __tablename__ = "tickets"
    id: Mapped[int] = mapped_column(primary_key=True)
    price: Mapped[float] = mapped_column(nullable=True)
    show: Mapped[str | None]
    user: Mapped[str | None]
<strong class="bold">    sold: Mapped[bool] = mapped_column(default=False)</strong></pre> <p>To make a new migration, run the following command:</p>
<pre class="console">
$ alembic revision –-autogenerate -m "Add sold field"</pre> <p>You will find a new script in the <code>alembic/versions</code> folder.</p>
<p>Run the migration command again:</p>
<pre class="console">
$ alembic upgrade head</pre> <p>Open the database, and you will see that the <code>tickets</code> table schema has the <code>sold</code> field added to it, and no record has been deleted.</p>
<p>You just created a migration strategy that will seamlessly change our database while running without any data loss. From now on, remember to use migrations to track changes on database schemas.</p>
<h2 id="_idParaDest-206"><a id="_idTextAnchor209"/>See also</h2>
<p>You can see more on <a id="_idIndexMarker375"/>how to manage database migrations with Alembic at the official documentation links:</p>
<ul>
<li><em class="italic">Setting up </em><em class="italic">Alembic</em>: <a href="https://alembic.sqlalchemy.org/en/latest/tutorial.xhtml">https://alembic.sqlalchemy.org/en/latest/tutorial.xhtml</a></li>
<li><em class="italic">Autogenerating </em><em class="italic">migrations</em>: <a href="https://alembic.sqlalchemy.org/en/latest/autogenerate.xhtml">https://alembic.sqlalchemy.org/en/latest/autogenerate.xhtml</a></li>
</ul>
<h1 id="_idParaDest-207"><a id="_idTextAnchor210"/>Handling relationships in SQL databases</h1>
<p>Database relationships <a id="_idIndexMarker376"/>are associations between two or more tables that allow you to model complex data structures and perform queries across multiple tables. In this recipe, you will learn how to implement one-to-one, many-to-one, and many-to-many relationships for the existing ticketing system application. You will also see how to use SQLAlchemy to define your database schema relationships and query the database.</p>
<h2 id="_idParaDest-208"><a id="_idTextAnchor211"/>Getting ready</h2>
<p>To follow the recipe, you need to have the core of the application already implemented with at least one table in it. If you have already done that, you will also have the necessary packages ready. We will keep on working on our ticketing system platform application.</p>
<h2 id="_idParaDest-209"><a id="_idTextAnchor212"/>How to do it…</h2>
<p>We will now proceed to set up relationships. We will show an example for each type of SQL table relationship.</p>
<h3>One to one</h3>
<p>We will demonstrate<a id="_idIndexMarker377"/> the one-to-one relationship by making a new table that holds details about the ticket.</p>
<p>One-to-one relationships are used to group specific information about a record in a separate logic.</p>
<p>That being said, let’s make the table in the <code>database.py</code> module. The records will have information such as the seat associated with the ticket, with a ticket type that we will use as a label for possible information. Let's create the table in two steps.</p>
<ol>
<li>First, we will add the ticket details reference to the existing <code>Ticket</code> class:<pre class="source-code">
class Ticket(Base):
    __tablename__ = "tickets"
    id: Mapped[int] = mapped_column(primary_key=True)
    price: Mapped[float] = mapped_column(
        nullable=True
    )
    show: Mapped[str | None]
    user: Mapped[str | None]
    sold: Mapped[bool] = mapped_column(default=False)
<strong class="bold">    details: Mapped["TicketDetails"] = relationship(</strong>
<strong class="bold">        back_populates="ticket"</strong>
<strong class="bold">    )</strong></pre></li> <li>Then, we create the table to map the ticket’s details as follows:<pre class="source-code">
from sqlalchemy import ForeignKey
<strong class="bold">class TicketDetails(Base):</strong>
<strong class="bold">    __tablename__ = "ticket_details"</strong>
<strong class="bold">    id: Mapped[int] = mapped_column(primary_key=True)</strong>
<strong class="bold">    ticket_id: Mapped[int] = mapped_column(</strong>
<strong class="bold">        ForeignKey("tickets.id")</strong>
<strong class="bold">    </strong><strong class="bold">)</strong>
<strong class="bold">    ticket: Mapped["Ticket"] = relationship(</strong>
<strong class="bold">        back_populates="details"</strong>
<strong class="bold">    )</strong>
<strong class="bold">    seat: Mapped[str | None]</strong>
<strong class="bold">    ticket_type: Mapped[str | None]</strong></pre></li> </ol>
<p>Once the database classes are set up to accommodate the new table, we can proceed to update the CRUD operations <a id="_idIndexMarker378"/><a id="_idIndexMarker379"/>with the following steps.</p>
<ol>
<li>To update ticket details, let’s create a dedicated function in the <code>operations.py</code> module:<pre class="source-code">
async def update_ticket_details(
    db_session: AsyncSession,
    ticket_id: int,
    updating_ticket_details: dict,
) -&gt; bool:
    ticket_query = update(TicketDetails).where(
        TicketDetails.ticket_id == ticket_id
    )
    if updating_ticket_details != {}:
        ticket_query = ticket_query.values(
             *updating_ticket_details
        )
        result = await db_session.execute(
                ticket_query
            )
        await db_session.commit()
        if result.rowcount == 0:
                return False
    return True</pre><p class="list-inset">The function will return <code>False</code> if no records have been updated.</p></li> <li>Next, modify the <code>create_ticket</code> function to consider the details of the ticket and create an<a id="_idIndexMarker380"/> endpoint to expose the updating operation we just created, like so:<pre class="source-code">
async def create_ticket(
    db_session: AsyncSession,
    show_name: str,
    user: str = None,
    price: float = None,
) -&gt; int:
    ticket = Ticket(
        show=show_name,
        user=user,
        price=price,
<strong class="bold">        details=TicketDetails(),</strong>
    )
    async with db_session.begin():
        db_session.add(ticket)
        await db_session.flush()
        ticket_id = ticket.id
        await db_session.commit()
    return ticket_id</pre><p class="list-inset">In this example, each time a ticket is created, an empty record of ticket details is created as well to keep the database consistent.</p></li> </ol>
<p>This was the minimum <a id="_idIndexMarker381"/>setup to handle one-to-one relationships. We will continue by setting up many-to-one relationships.</p>
<h3>Many to one</h3>
<p>A ticket can be<a id="_idIndexMarker382"/> associated with an event, and an event can have multiple tickets. To showcase a many-to-one relationship, we will create an <code>events</code> table that will have a relationship with the <code>tickets</code> table. Let’s go through the following steps:</p>
<p>Let’s first create a column in the <code>tickets</code> table that will accommodate the reference to the <code>events</code> table in the <code>database.py</code> module, as follows:</p>
<pre class="source-code">
class Ticket(Base):
    __tablename__ = "tickets"
    # skip existing columns
<strong class="bold">    event_id: Mapped[int | None] = mapped_column(</strong>
<strong class="bold">        ForeignKey("events.id")</strong>
<strong class="bold">    )</strong>
<strong class="bold">    event: Mapped["Event | None"] = relationship(</strong>
<strong class="bold">        back_populates="tickets"</strong>
<code>Event</code> class to map the <code>events</code> table into the database:</p>
<pre class="source-code">
class Event(Base):
    __tablename__ = "events"
    id: Mapped[int] = mapped_column(primary_key=True)
    name: Mapped[str]
    tickets: Mapped[list["Ticket"]] = relationship(
        back_populates="event"
    )</pre> <p><code>ForeignKey</code>, in this case, is defined only in the <code>Ticket</code> class since the event associated can be only one.</p>
<p>This is all you need to <a id="_idIndexMarker383"/>create a many-to-one relationship.</p>
<p class="callout-heading">Exercise</p>
<p class="callout">You can add to the application the operations to create an event and specify the number of tickets to create with it. Once you’ve done this, expose the operation with the corresponding endpoint.</p>
<h3>Many to many</h3>
<p>Let’s imagine that we<a id="_idIndexMarker384"/> have a list of sponsors that can sponsor our events. Since we can have multiple sponsors that can sponsor multiple events, this situation is best representative of a many-to-many relationship.</p>
<p>To work with many-to-many relationships, we need to define a class for the concerned tables and another class to track the so-called <em class="italic">association table</em>.</p>
<p>Let’s start by defining a column to accommodate relationships in the <code>Event</code> class:</p>
<pre class="source-code">
class Event(Base):
    __tablename__ = "events"
    # existing columns
<strong class="bold">    sponsors: Mapped[list["Sponsor"]] = relationship(</strong>
<strong class="bold">        secondary="sponsorships",</strong>
<strong class="bold">        back_populates="events",</strong>
<code>sponsors</code> table:</p>
<pre class="source-code">
class Sponsor(Base):
    __tablename__ = "sponsors"
    id: Mapped[int] = mapped_column(primary_key=True)
    name: Mapped[str] = mapped_column(unique=True)
    events: Mapped[list["Event"]] = relationship(
        secondary="sponsorships",
        back_populates="sponsors",
    )</pre> <p>As you might have <a id="_idIndexMarker385"/>noticed, the class contains columns to accommodate the <code>events</code> reference.</p>
<p>Finally, we can define an association table that will be the <code>sponsorships</code> table:</p>
<pre class="source-code">
class Sponsorship(Base):
    __tablename__ = "sponsorships"
    event_id: Mapped[int] = mapped_column(
        ForeignKey("events.id"), primary_key=True
    )
    sponsor_id: Mapped[int] = mapped_column(
        ForeignKey("sponsors.id"), primary_key=True
    )
    amount: Mapped[float] = mapped_column(
        nullable=False, default=10
    )</pre> <p>The association table can contain information on the relationship itself. For example, in our case, a piece of useful information is the amount provided by the sponsor for the event.</p>
<p>This is all you need to <a id="_idIndexMarker386"/>create many-to-many relationships for your ticketing system platform.</p>
<p class="callout-heading">Exercise</p>
<p class="callout">To complete your application, create an operations function with the relative endpoints to do the following:</p>
<p class="callout">- Add a sponsor to the database.</p>
<p class="callout">- Add a sponsorship with the amount. If the sponsorship already exists, replace the sponsorship with the new amount.</p>
<h2 id="_idParaDest-210"><a id="_idTextAnchor213"/>See also</h2>
<p>You can dive deeper into handling relationships with SQLAlchemy at the following official documentation page:</p>
<ul>
<li><em class="italic">SQLAlchemy basic </em><em class="italic">relationships</em>: <a href="https://docs.sqlalchemy.org/en/20/orm/basic_relationships.xhtml">https://docs.sqlalchemy.org/en/20/orm/basic_relationships.xhtml</a></li>
</ul>
<h1 id="_idParaDest-211"><a id="_idTextAnchor214"/>Optimizing SQL queries for performance</h1>
<p>Optimizing SQL <a id="_idIndexMarker387"/>queries is key in database management, as it enhances efficiency, scalability, cost-effectiveness, user satisfaction, data integrity, compliance, and security.</p>
<p>This recipe shows how to make applications run faster by improving SQL queries. Queries that use fewer resources and less time can enhance user satisfaction and application capacity. Improving SQL queries is a repeated process, but you could use some tips that could assist you.</p>
<h2 id="_idParaDest-212"><a id="_idTextAnchor215"/>Getting ready</h2>
<p>Make sure you have an existing application running using SQLAlchemy for database interaction or to keep working on the ticketing system application all along the chapter. Also, basic knowledge of SQL and database schema design can be beneficial.</p>
<h2 id="_idParaDest-213"><a id="_idTextAnchor216"/>How to do it…</h2>
<p>Improving SQL queries is a process that involves several steps. As with most optimization processes, many steps are specific to the use case, but there are general rules that can help optimize SQL queries overall, such as the following:</p>
<ul>
<li>Avoid <em class="italic">N</em>+1 queries</li>
<li>Use the <code>JOIN</code> statement sparingly</li>
<li>Minimize data to fetch</li>
</ul>
<p>We will apply each with a significant example.</p>
<h3>Avoiding N+1 queries</h3>
<p>The N+1 query issue<a id="_idIndexMarker388"/> happens when your application does one query to get a list of items and then loops over those items to get related data, making N more queries.</p>
<p>Let’s say we want an endpoint to show all events with the associated sponsors. A first try might be to fetch the <code>events</code> table and loop over the events to fetch the <code>sponsors</code> table. This solution means a first query to get the events and N more queries to get the sponsors for each event, which is exactly what we want to avoid.</p>
<p>The solution is to load all related records in the query to retrieve the related sponsors. This is technically called <em class="italic">eager loading</em>.</p>
<p>In SQLAlchemy, this is done by using a <code>joinedload</code> option so that the function operation will look like this:</p>
<pre class="source-code">
async def get_events_with_sponsors(
    db_session: AsyncSession
) -&gt; list[Event]:
    query = (
        select(Event)
<strong class="bold">        .options(</strong>
<strong class="bold">            </strong><strong class="bold">joinedload(Event.sponsors)</strong>
<strong class="bold">        )</strong>
    )
    async with db_session as session:
        result = await session.execute(query)
        events = result.scalars().all()
    return events</pre> <p>The <code>joinedload</code> method <a id="_idIndexMarker389"/>will include a <code>JOIN</code> operation on the query, so it is no longer necessary to make N queries to get the sponsors.</p>
<h3>Using the join statement sparingly</h3>
<p>Joined tables can<a id="_idIndexMarker390"/> make the query easier to read. But be careful and only join tables that you need for your query.</p>
<p>Suppose we want to get a list of sponsors names with the amount given for a certain event in order from the highest to the lowest.</p>
<p>We can use multiple joins since we need to fetch three tables. The function would look like this:</p>
<pre class="source-code">
async def get_event_sponsorships_with_amount(
    db_session: AsyncSession, event_id: int
):
    query = (
<strong class="bold">        select(Sponsor.name, Sponsorship.amount)</strong>
<strong class="bold">        .join(</strong>
<strong class="bold">            Sponsorship,</strong>
<strong class="bold">            Sponsorship.sponsor_id == Sponsor.id,</strong>
<strong class="bold">        )</strong>
<strong class="bold">        .join(</strong>
<strong class="bold">            Event,</strong>
<strong class="bold">            Sponsorship.event_id == Event.id</strong>
<strong class="bold">        </strong><strong class="bold">)</strong>
<strong class="bold">        .order_by(Sponsorship.amount.desc())</strong>
    )
    async with db_session as session:
        result = await session.execute(query)
        sponsor_contributions = result.fetchall()
    return sponsor_contributions</pre> <p>The double join <a id="_idIndexMarker391"/>implies to call the <code>events</code> table that we won’t use, so it would be much more efficient to organize the query as follows:</p>
<pre class="source-code">
async def get_event_sponsorships_with_amount(
    db_session: AsyncSession, event_id: int
):
    query = (
<strong class="bold">        </strong><strong class="bold">select(Sponsor.name, Sponsorship.amount)</strong>
<strong class="bold">        .join(</strong>
<strong class="bold">            Sponsorship,</strong>
<strong class="bold">            Sponsorship.sponsor_id == Sponsor.id,</strong>
<strong class="bold">        )</strong>
<strong class="bold">        .where(Sponsorship.event_id == event_id)</strong>
<strong class="bold">        .order_by(Sponsorship.amount.desc())</strong>
    )
    async with db_session as session:
        result = await session.execute(query)
        sponsor_contributions = result.fetchall()
    return sponsor_contributions</pre> <p>This will return <a id="_idIndexMarker392"/>what we need without selecting the <code>events</code> table at all.</p>
<h3>Minimizing data to fetch</h3>
<p>Fetching more data<a id="_idIndexMarker393"/> than needed can slow down your queries and the application.</p>
<p>Use SQLAlchemy’s <code>load_only</code> function to load only specific columns from the database.</p>
<p>Imagine that for a marketing analysis, we are asked to make a function that gets a list of tickets with only the ticket ID, the user, and the price:</p>
<pre class="source-code">
async def get_events_tickets_with_user_price(
    db_session: AsyncSession, event_id: int
) -&gt; list[Ticket]:
    query = (
        select(Ticket)
        .where(Ticket.event_id == event_id)
        .options(
            load_only(
                Ticket.id, Ticket.user, Ticket.price
            )
        )
    )
    async with db_session as session:
        result = await session.execute(query)
        tickets = result.scalars().all()
    return tickets</pre> <p>We now try to retrieve the tickets from this function, as follows:</p>
<pre class="source-code">
tickets = await get_events_tickets_with_user_price(
    session, event_id
)</pre> <p>You will notice that each element only has the <code>id</code>, <code>user</code>, and <code>price</code> fields and it will give an error if you<a id="_idIndexMarker394"/> attempt to access the <code>show</code> field, for example. In larger applications, this can reduce memory usage and make responses much faster.</p>
<h2 id="_idParaDest-214"><a id="_idTextAnchor217"/>There’s more…</h2>
<p>SQL query optimization <a id="_idIndexMarker395"/>involves more than what the recipe showed. Often, choosing a certain SQL database depends on specific optimization needs.</p>
<p>Different SQL databases may have different strengths and weaknesses in handling these factors, depending on their architecture and features. For example, some SQL databases may support partitioning, sharding, replication, or distributed processing, which can improve the scalability and availability of data. Some SQL databases may offer more advanced query optimization techniques, such as cost-based optimization, query rewriting, or query caching, which can reduce the execution time and resource consumption of queries. Some SQL databases may implement different storage engines, transaction models, or index types, which can affect the performance and consistency of data operations.</p>
<p>Therefore, when choosing an SQL database for a specific application, it is important to consider the characteristics and requirements of the data and queries, and compare the capabilities and limitations of the available SQL databases. A good way to do this is to benchmark the performance of SQL databases using realistic datasets and queries and measure the relevant metrics, such as throughput, latency, accuracy, and reliability. By doing so, one can find the optimal SQL database for the given scenario and also identify potential areas for<a id="_idIndexMarker396"/> improvement in the database design and query formulation.</p>
<h1 id="_idParaDest-215"><a id="_idTextAnchor218"/>Securing sensitive data in SQL databases</h1>
<p>Sensitive data, such<a id="_idIndexMarker397"/> as personal information, financial<a id="_idIndexMarker398"/> records, or confidential documents, is often stored in SQL databases for various applications and purposes. However, this also exposes the data to potential risks of unauthorized access, theft, leakage, or corruption. Therefore, it is essential to secure sensitive data in SQL databases and protect it from malicious attacks or accidental errors.</p>
<p>This recipe will show how to store sensitive data, such as credit card information, in SQL databases.</p>
<h2 id="_idParaDest-216"><a id="_idTextAnchor219"/>Getting ready</h2>
<p>To follow the recipe, you need to have an application with a database connection already in place.</p>
<p>Furthermore, we will use the <code>cryptography</code> package. If you haven’t installed it with the <code>requirements.txt</code> file, you can do it by running this command in your environment:</p>
<pre class="console">
$ pip install cryptography</pre> <p>A sound knowledge of cryptography can be beneficial but is not necessary.</p>
<h2 id="_idParaDest-217"><a id="_idTextAnchor220"/>How to do it…</h2>
<p>We will make a new table from the ground up to store credit card information. Some of the information, such as credit card numbers <a id="_idIndexMarker399"/>and <strong class="bold">Card Verification Values</strong> (<strong class="bold">CVV</strong>), will not be saved in clear text in our database but rather encrypted. Since we need to get it back, we will use a symmetric encryption that needs a key. Let's make the process through the following steps.</p>
<ol>
<li>Let’s start by creating a class in the <code>database.py</code> module that corresponds to the <code>credit_card</code> table in our database, as follows:<pre class="source-code">
class CreditCard(Base):
    __tablename__ = "credit_cards"
    id: Mapped[int] = mapped_column(primary_key=True)
    number: Mapped[str]
    expiration_date: Mapped[str]
    cvv: Mapped[str]
    card_holder_name: Mapped[str]</pre></li> <li>Next, in<a id="_idIndexMarker400"/> the <code>app</code> folder, we <a id="_idIndexMarker401"/>create a module named <code>security.py</code> where we will write our code for encrypting and decrypting data <a id="_idIndexMarker402"/>using <strong class="bold">Fernet symmetric encryption</strong>, as follows:<pre class="source-code">
from cryptography.fernet import Fernet
cypher_key = Fernet.generate_key()
cypher_suite = Fernet(cypher_key)</pre><p class="list-inset">The <code>cypher_suite</code> object will be used to define the encryption and decryption function.</p><p class="list-inset">It is worth mentioning that in a production environment, the <code>cypher_key</code> object can be either kept in an external service that offers rotation or created at startup, based on the security needs of the business.</p></li> <li>In the same module, we can create a function to encrypt credit card info and one to decrypt it as follows:<pre class="source-code">
def encrypt_credit_card_info(card_info: str) -&gt; str:
    return cypher_suite.encrypt(
        card_info.encode()
    ).decode()
def decrypt_credit_card_info(
    encrypted_card_info: str,
) -&gt; str:
    return cypher_suite.decrypt(
        encrypted_card_info.encode()
    ).decode()</pre><p class="list-inset">Those functions will<a id="_idIndexMarker403"/> be<a id="_idIndexMarker404"/> used when writing and reading from the database.</p></li> <li>Then, we can write a storing operation in the same <code>security.py</code> module as follows:<pre class="source-code">
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession
from app.database import CreditCard
async def store_credit_card_info(
    db_session: AsyncSession,
    card_number: str,
    card_holder_name: str,
    expiration_date: str,
    cvv: str,
):
    encrypted_card_number = encrypt_credit_card_info(
        card_number
    )
    encrypted_cvv = encrypt_credit_card_info(cvv)
    # Store encrypted credit card information
    # in the database
    credit_card = CreditCard(
        number=encrypted_card_number,
        card_holder_name=card_holder_name,
        expiration_date=expiration_date,
        cvv=encrypted_cvv,
    )
    async with db_session.begin():
        db_session.add(credit_card)
        await db_session.flush()
        credit_card_id = credit_card.id
        await db_session.commit()
    return credit_card_id</pre><p class="list-inset">Each time the function is awaited, the credit card information will be stored with the confidential data encrypted.</p></li> <li>Similarly, we <a id="_idIndexMarker405"/>can<a id="_idIndexMarker406"/> define a function to retrieve the encrypted credit card information from the database as follows:<pre class="source-code">
async def retrieve_credit_card_info(
    db_session: AsyncSession, credit_card_id: int
):
    query = select(CreditCard).where(
        CreditCard.id == credit_card_id
    )
    async with db_session as session:
        result = await session.execute(query)
        credit_card = result.scalars().first()
    credit_card_number = decrypt_credit_card_info(
            credit_card.number
        ),
    cvv = decrypt_credit_card_info(credit_card.cvv)
    card_holder = credit_card.card_holder_name
    expiry = credit_card.expiration_date
    return {
        "card_number": credit_card_number,
        "card_holder_name": card_holder,
        "expiration_date": expiry,
        "cvv": cvv
    }</pre><p class="list-inset">We have just developed code to save confidential information in our database.</p></li> </ol>
<p class="callout-heading">Exercise</p>
<p class="callout">We just saw the backbone of how to store sensitive data securely. You can complete the feature by yourself by doing the following:</p>
<p class="callout">- Writing unit tests for our encryption operations. In the <code>tests</code> folder, let’s create a new test module called <code>test_security.py</code>. Verify that the credit card is securely saved in our database, but the fields for credit card numbers and CVV are encrypted.</p>
<p class="callout">- Creating endpoints to store, retrieve, and delete credit card information in the database.</p>
<p class="callout">- Associating a credit card with a sponsor and managing the relative CRUD operations.</p>
<h2 id="_idParaDest-218"><a id="_idTextAnchor221"/>See also</h2>
<p>We have used<a id="_idIndexMarker407"/> Fernet <a id="_idIndexMarker408"/>symmetric encryption to encrypt credit card information. You can have a deeper insight about it at the following link:</p>
<ul>
<li><em class="italic">Fernet symmetric </em><em class="italic">encryption</em>: <a href="https://cryptography.io/en/latest/fernet/">https://cryptography.io/en/latest/fernet/</a></li>
</ul>
<h1 id="_idParaDest-219"><a id="_idTextAnchor222"/>Handling transactions and concurrency</h1>
<p>In the realm of database<a id="_idIndexMarker409"/> management, two critical aspects govern the reliability and performance of applications: handling transactions and managing concurrency.</p>
<p>Transactions, encapsulating a series of database operations, are fundamental for maintaining data consistency by ensuring that changes occur as a single unit of work. Concurrency, on the other hand, addresses the challenge of managing simultaneous access to shared resources by multiple users or processes.</p>
<p>The relationship between transactions and concurrency becomes apparent when considering scenarios where multiple transactions may attempt to access or modify the same data concurrently. Without proper concurrency control mechanisms such as locking, transactions could interfere with each other, potentially leading to data corruption or inconsistencies.</p>
<p>The recipe will show how to manage transactions and concurrency with FastAPI and SQLAlchemy by emulating the process of selling tickets from the ticketing platform we created.</p>
<h2 id="_idParaDest-220"><a id="_idTextAnchor223"/>Getting ready</h2>
<p>You need a CRUD application as the basis for the recipe, or you can continue to use the ticketing system application that we have been using throughout the chapter.</p>
<h2 id="_idParaDest-221"><a id="_idTextAnchor224"/>How to do it…</h2>
<p>The most significant <a id="_idIndexMarker410"/>situation where transaction and concurrency become important is in managing updating operations, such as with the sales ticket for our application.</p>
<p>We will begin by creating a function operation that will label our ticket as sold and give the name of the customer. Then, we will simulate two sales occurring at the same time and observe the outcome. To do so, follow these steps.</p>
<ol>
<li>In the <code>operations.py</code> module, create the function to sell a ticket as follows::<pre class="source-code">
async def sell_ticket_to_user(
    db_session: AsyncSession, ticket_id: int, user: str
) -&gt; bool:
    ticket_query = (
        update(Ticket)
        .where(
            and_(
                Ticket.id == ticket_id,
                Ticket.sold == False,
            )
        )
        .values(user=user, sold=True)
    )
    async with db_session as session:
        result = (
           await db_session.execute(ticket_query)
        )
        await db_session.commit()
        if result.rowcount == 0:
            return False
    return True</pre><p class="list-inset">The query will only sell the ticket if the ticket has not been sold yet; otherwise, the function will return <code>False</code>.</p></li> <li>Let’s try to add <a id="_idIndexMarker411"/>a ticket to our database and try to simulate two users buying the same ticket at the same time. Let’s write all in the form of unit tests.<p class="list-inset">We start by defining a fixture to write our ticket into the database in the <code>tests/conftest.py</code> file as follows:</p><pre class="source-code">
@pytest.fixture
async def add_special_ticket(db_session_test):
    ticket = Ticket(
        id=1234,
        show="Special Show",
        details=TicketDetails(),
    )
    async with db_session_test.begin():
        db_session_test.add(ticket)
        await db_session_test.commit()</pre></li> <li>We can create a test by performing two concurrent sales with two separate database sessions (define another one as a different fixture) to do them at the same time in<a id="_idIndexMarker412"/> the <code>tests/test_operations.py</code> file:<pre class="source-code">
import asyncio
async def test_concurrent_ticket_sales(
    add_special_ticket,
    db_session_test,
    second_session_test,
):
    result = await asyncio.gather(
        sell_ticket_to_user(
            db_session_test, 1234, "Jake Fake"
        ),
        sell_ticket_to_user(
            second_session_test, 1234, "John Doe"
        ),
    )
    assert result in (
        [True, False],
        [False, True],
    )  # only one of the sales should be successful
    ticket = await get_ticket(db_session_test, 1234)
    # assert that the user who bought the ticket
    # correspond to the successful sale
    if result[0]:
        assert ticket.user == "Jake Fake"
    else:
        assert ticket.user == "John Doe"</pre><p class="list-inset">In the test function, we run two coroutines at the same time by using the <code>asyncio.gather</code> function.</p><p class="list-inset">We just assume <a id="_idIndexMarker413"/>that only one user can purchase the ticket and they will match the successful transaction. Once we have created the test, we can execute with <code>pytest</code> as follows:</p><pre class="source-code"><strong class="bold">$ pytest tests/test_operations.py::test_concurrent_ticket_sales</strong></pre></li> </ol>
<p>The test will succeed, which means that the asynchronous session handles transaction conflicts.</p>
<p class="callout-heading">Exercise</p>
<p class="callout">You have just created a draft of the selling ticket operation. As an exercise, you can improve the draft by doing the following:</p>
<p class="callout">- Adding a table for users to the database</p>
<p class="callout">- Adding the foreign key reference of the user on the ticket to make it sold</p>
<p class="callout">- Creating an <code>alembic</code> migration for the database modification</p>
<p class="callout">- Creating an API endpoint that exposes the <code>sell_ticket_to_user</code> function</p>
<h2 id="_idParaDest-222"><a id="_idTextAnchor225"/>There’s more…</h2>
<p>One of the fundamental challenges of database systems is to handle concurrent transactions from <a id="_idIndexMarker414"/>multiple users while preserving data consistency and integrity. Different types of transactions may have different requirements for how they access and modify data and how they deal with other transactions that may conflict with them. For example, a common way to manage concurrency is to use <em class="italic">locks</em>, which are mechanisms that prevent unauthorized or incompatible operations on data. However, locks can also introduce trade-offs between performance, availability, and correctness.</p>
<p>Depending on the business needs, some transactions may need to acquire locks for longer periods or at different levels of granularity, such as table-level or row-level. For example, SQLite only allows locks on a database level, while PostgreSQL allows locks till the row table level.</p>
<p>Another key aspect of managing concurrent transactions is the concept of <em class="italic">isolation levels</em>, which define the degree to which one transaction must be isolated from the effects of other concurrent transactions. Isolation levels ensure that transactions maintain data consistency despite simultaneous access and modification by multiple users.</p>
<p>The SQL standard <a id="_idIndexMarker415"/>defines four isolation levels, each offering different trade-offs between concurrency and data consistency:</p>
<ol>
<li><strong class="bold">READ UNCOMMITTED</strong>:<ul><li>Transactions at this level allow dirty reads, meaning a transaction can see uncommitted changes made by other concurrent transactions.</li><li>Non-repeatable reads and phantom reads are possible.</li><li>This isolation level provides the highest concurrency but the lowest level of data consistency.</li></ul></li>
<li><strong class="bold">READ COMMITTED</strong>:<ul><li>Transactions at this level only see changes committed by other transactions.</li><li>They do not allow dirty reads.</li><li>Non-repeatable<a id="_idIndexMarker416"/> reads are possible, but phantom reads can still occur.</li><li>This level strikes a balance between concurrency and consistency.</li></ul></li>
<li><strong class="bold">REPEATABLE READ</strong>:<ul><li>Transactions at this level see a consistent snapshot of the data throughout the transaction.</li><li>Changes committed by other transactions after the transaction began are not visible.</li><li>Non-repeatable reads are prevented, but phantom reads can occur.</li><li>This level provides stronger consistency at the cost of some concurrency.</li></ul></li>
<li><strong class="bold">SERIALIZABLE</strong>:<ul><li>Transactions at this level behave as if they are executed serially – that is, one after another.</li><li>They provide the highest level of data consistency.</li><li>Non-repeatable reads and phantom reads are prevented.</li><li>This level offers strong consistency but may result in reduced concurrency due to increased locking.</li></ul></li>
</ol>
<p>SQLite, for example, allows isolation, while MySQL and PostgreSQL offer all four transaction levels.</p>
<p>When the database supports it, in SQLAlchemy, you can set up the isolation level per engine or connection by specifying it as an argument when initializing.</p>
<p>For example, if you want to specify the isolation level at the engine level for PostgreSQL, the engine will be initialized as follows:</p>
<pre class="source-code">
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
eng = create_engine(
    "postgresql+psycopg2://scott:tiger@localhost/test",
<strong class="bold">    isolation_level="REPEATABLE READ",</strong>
)
Session = sessionmaker(eng)</pre> <p>All these choices in terms of locks and isolation level affect the architecture and design of the database <a id="_idIndexMarker417"/>system since not all SQL databases support it. Therefore, it is important to understand the principles and best practices of locking strategies and how they relate to the transaction behavior and the business logic.</p>
<p>You have just completed a comprehensive overview of integrating SQL databases with FastAPI. In the next chapter, we will explore integrating FastAPI applications with NoSQL databases.</p>
<h2 id="_idParaDest-223"><a id="_idTextAnchor226"/>See also</h2>
<p>You can find more information about locking strategies for SQLite and PostgreSQL at the following links:</p>
<ul>
<li><em class="italic">SQLite </em><em class="italic">locking</em>: <a href="https://www.sqlite.org/lockingv3.xhtml">https://www.sqlite.org/lockingv3.xhtml</a></li>
<li><em class="italic">PostgreSQL </em><em class="italic">locking</em>: <a href="https://www.postgresql.org/docs/current/explicit-locking.xhtml">https://www.postgresql.org/docs/current/explicit-locking.xhtml</a></li>
</ul>
<p>Information on the isolation level for singular databases can be found on the respective documentation pages:</p>
<ul>
<li><em class="italic">SQLite </em><em class="italic">isolation</em>: <a href="https://www.sqlite.org/isolation.xhtml">https://www.sqlite.org/isolation.xhtml</a></li>
<li><em class="italic">MySQL isolation </em><em class="italic">levels</em>: <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.xhtml">https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.xhtml</a></li>
<li><em class="italic">PostgreSQL isolation </em><em class="italic">levels</em>: <a href="https://www.postgresql.org/docs/current/transaction-iso.xhtml">https://www.postgresql.org/docs/current/transaction-iso.xhtml</a></li>
</ul>
<p>Also, a comprehensive guide on how to manage isolation levels with SQLAlchemy is available at the link:</p>
<ul>
<li><em class="italic">SQLAlchemy session </em><em class="italic">transaction</em>: <a href="https://docs.sqlalchemy.org/en/20/orm/session_transaction.xhtml">https://docs.sqlalchemy.org/en/20/orm/session_transaction.xhtml</a></li>
</ul>
</div>
</div></body></html>