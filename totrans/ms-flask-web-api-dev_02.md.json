["```py\n from flask import Flask\nfrom flask_sqlalchemy import SQLAlchemy\nimport logging\nimport logging.config\nimport logging.handlers\nimport sys\nimport toml\n# Extension modules initialization\ndb = SQLAlchemy()\ndef configure_func_logging(log_path):\n    logging.getLogger(\"werkzeug\").disabled = True\n    console_handler =   logging.StreamHandler(stream=sys.stdout)\n    console_handler.setLevel(logging.DEBUG)\n    logging.basicConfig(level=logging.DEBUG,  format='%(asctime)s %(levelname)s %(module)s\n          %(funcName)s %(message)s',\n     datefmt='%Y-%m-%d %H:%M:%S',  handlers=[logging.handlers.RotatingFileHandler(\n        log_path, backupCount=3, maxBytes=1024 ),\n           console_handler])\ndef <st c=\"6464\">create_app(config_file):</st> app = Flask(__name__, template_folder='../app/pages', static_folder='../app/resources')\n    app.config.from_file(config_file, toml.load)\n    db.init_app(app)\n    configure_func_logging('log_msg.txt') <st c=\"6677\">with app.app_context():</st> from app.views import login\n        from app.views import menu\n        from app.views import customer\n        from app.views import admin\n        from app.views import product\n        from app.views import order\n        from app.views import payment\n        from app.views import shipping\n    return app\n```", "```py\n     app_ctx = <st c=\"8873\">app.app_context()</st> app_ctx.<st c=\"8963\">with</st>-block, setting a limit on where to access the application-level components, such as allowing access to <st c=\"9072\">current_app</st> from the <st c=\"9093\">views</st> module only, as depicted in the following example:\n\n    ```", "```py\n\n    ```", "```py\n<st c=\"9981\">from flask import current_app</st> @<st c=\"10013\">current_app</st>.route('/delivery/officer/add', methods = ['GET', 'POST'])\ndef add_delivery_officer():\n    if request.method == 'POST': <st c=\"10140\">current_app.logger.info('add_delivery_officer</st><st c=\"10185\">POST view executed')</st> repo = DeliveryOfficerRepository(db)\n        officer = DeliveryOfficer(id=int(request.form['id']), firstname=request.form['firstname'], middlename=request.form['middlename'],\n          … … … … … …\n        result = repo.insert(officer)\n        return render_template(\n         'shipping/add_delivery_officer_form.html'), 200 <st c=\"10488\">current_app.logger.info('add_delivery_officer</st><st c=\"10533\">GET view executed')</st> return render_template(\n       'shipping/add_delivery_officer_form.html'), 200\n```", "```py\n<st c=\"11520\">def get_database():</st><st c=\"11540\">if 'db' not in g:</st><st c=\"11558\">g.db = db</st> app.logger.info('storing … as context data') <st c=\"11614\">@app.teardown_appcontext</st> def teardown_database(exception): <st c=\"11673\">db = g.pop('db', None)</st> app.logger.info('removing … as context data')\n```", "```py\n<st c=\"12908\">@app.before_request</st> def init_request(): <st c=\"12994\">list_login</st> view function to access the database for query transactions:\n\n```", "```py\n\n\t\t\t<st c=\"13320\">Although it is an advantage to verify the existence of a context attribute in</st> `<st c=\"13399\">g</st>` <st c=\"13400\">before accessing it, sometimes accessing the data right away is inevitable, such as in our</st> `<st c=\"13492\">list_login</st>` <st c=\"13502\">view function</st> <st c=\"13517\">that directly passes the</st> `<st c=\"13542\">g.db</st>` <st c=\"13546\">context object into</st> `<st c=\"13567\">LoginRepository</st>`<st c=\"13582\">. Another approach to accessing the context data is through the</st> `<st c=\"13646\">g.set()</st>` <st c=\"13653\">method that allows a default value if the data is non-existent, such as using</st> `<st c=\"13732\">g.get('db', db)</st>` <st c=\"13747\">instead of</st> `<st c=\"13759\">g.db</st>`<st c=\"13763\">, where</st> `<st c=\"13771\">db</st>` <st c=\"13773\">in the second parameter is a</st> <st c=\"13803\">backup connection.</st>\n\t\t\t<st c=\"13821\">Important note</st>\n\t\t\t<st c=\"13836\">Both application and request contexts exist only during a request-response life cycle.</st> <st c=\"13924\">The application context provides the</st> `<st c=\"13961\">current_app</st>` <st c=\"13972\">proxy and the</st> `<st c=\"13987\">g</st>` <st c=\"13988\">variable, while the request context contains the request variables and the view function details.</st> <st c=\"14087\">Unlike in other web frameworks, Flask’s application context will not be valid for access after the life cycle destroys the</st> <st c=\"14210\">request context.</st>\n\t\t\t<st c=\"14226\">Aside from the application factory, we can also use Flask’s blueprints to establish a</st> <st c=\"14313\">project directory.</st>\n\t\t\t<st c=\"14331\">Using the Blueprint</st>\n\t\t\t`<st c=\"14351\">Blueprints</st>` <st c=\"14362\">are Flask’s built-in</st> <st c=\"14384\">components from its</st> `<st c=\"14404\">flask</st>` <st c=\"14409\">module.</st> <st c=\"14418\">Their core purpose is to organize all related views with the repository, services, templates, and other associated features to form a solid and self-contained structure.</st> <st c=\"14588\">The strength of the Blueprint is that it can break down a single huge application into independent</st> <st c=\"14687\">business units that can be considered sub-applications but are still dependent on the main application.</st> *<st c=\"14791\">Figure 2</st>**<st c=\"14799\">.2</st>* <st c=\"14801\">shows the organization of the</st> `<st c=\"14832\">ch02-blueprint</st>` <st c=\"14846\">project, a version of our</st> *<st c=\"14873\">Online Shipping Management System</st>* <st c=\"14906\">that uses Blueprints in building its</st> <st c=\"14944\">project structure:</st>\n\t\t\t![Figure 2.2 – Flask project directory with Blueprints](img/B19383_02_2.jpg)\n\n\t\t\t<st c=\"15287\">Figure 2.2 – Flask project directory with Blueprints</st>\n\t\t\t<st c=\"15339\">Defining the Blueprint</st>\n\t\t\t<st c=\"15362\">Instead of placing all view files in</st> <st c=\"15400\">one folder, the project’s related views are grouped based on business units, then assigned their respective Blueprint sub-projects, namely,</st> `<st c=\"15540\">home</st>`<st c=\"15544\">,</st> `<st c=\"15546\">login</st>`<st c=\"15551\">,</st> `<st c=\"15553\">order</st>`<st c=\"15558\">,</st> `<st c=\"15560\">payment</st>`<st c=\"15567\">,</st> `<st c=\"15569\">product</st>`<st c=\"15576\">, and</st> `<st c=\"15582\">shipping</st>`<st c=\"15590\">. Each Blueprint represents a section with the templates, static resources, repositories, services, and utilities needed to build</st> <st c=\"15720\">a sub-application.</st>\n\t\t\t<st c=\"15738\">Now, the</st> `<st c=\"15748\">__init__.py</st>` <st c=\"15759\">file of each sub-application is very important because this is where the Blueprint object is created and instantiated.</st> <st c=\"15879\">The blueprint</st> `<st c=\"15893\">home</st>`<st c=\"15897\">’s</st> `<st c=\"15901\">__init__.py</st>` <st c=\"15912\">file, for instance, has the following</st> <st c=\"15951\">Blueprint definition:</st>\n\n```", "```py\n\n\t\t\t<st c=\"16150\">Meanwhile, the</st> `<st c=\"16166\">login</st>` <st c=\"16171\">section’s</st> <st c=\"16181\">Blueprint has the</st> `<st c=\"16200\">__init__py</st>` <st c=\"16210\">file that</st> <st c=\"16221\">contains this:</st>\n\n```", "```py\n\n\t\t\t<st c=\"16486\">The constructor of the</st> `<st c=\"16510\">Blueprint</st>` <st c=\"16519\">class requires two parameters for it to instantiate</st> <st c=\"16572\">the class:</st>\n\n\t\t\t\t*   <st c=\"16582\">The first parameter is the</st> *<st c=\"16610\">name of Blueprint</st>*<st c=\"16627\">, usually the name of the reference variable of</st> <st c=\"16675\">its instance.</st>\n\t\t\t\t*   <st c=\"16688\">The second parameter is</st> `<st c=\"16713\">__name__</st>`<st c=\"16721\">, which depicts the</st> *<st c=\"16741\">current package</st>* <st c=\"16756\">of</st> <st c=\"16760\">the section.</st>\n\n\t\t\t<st c=\"16772\">The name of the Blueprint must be unique to the sub-application because it is responsible for its internal routings, which must not have any collisions with the other Blueprints.</st> <st c=\"16952\">The Blueprint package, on the other hand, will indicate the root path of</st> <st c=\"17025\">the sub-application.</st>\n\t\t\t<st c=\"17045\">Implementing the Blueprint’s routes</st>\n\t\t\t<st c=\"17081\">One purpose of using a Blueprint is to avoid circular import issues in implementing the routes.</st> <st c=\"17178\">Rather than accessing the</st> <st c=\"17204\">app instance from</st> `<st c=\"17222\">main.py</st>`<st c=\"17229\">, sub-applications can now directly access their respective Blueprint instance to build their routes.</st> <st c=\"17331\">The following code shows how the login Blueprint implements its route using its Blueprint instance, the</st> `<st c=\"17435\">login_bp</st>` <st c=\"17443\">object:</st>\n\n```", "```py\n\n\t\t\t<st c=\"17908\">The</st> `<st c=\"17913\">login_bp</st>` <st c=\"17921\">object is instantiated from</st> `<st c=\"17950\">__init__py</st>` <st c=\"17960\">of the</st> `<st c=\"17968\">login</st>` <st c=\"17973\">directory, thus importing it from there.</st> <st c=\"18015\">But this route and the rest of the views will only work after registering these Blueprints with the</st> `<st c=\"18115\">app</st>` <st c=\"18118\">instance.</st>\n\t\t\t<st c=\"18128\">Registering the blueprints</st>\n\t\t\t<st c=\"18155\">Blueprint registration happens in the</st> `<st c=\"18194\">main.py</st>` <st c=\"18201\">file, which is the location of the Flask app.</st> <st c=\"18248\">The following snippet is part of the</st> `<st c=\"18285\">main.py</st>` <st c=\"18292\">file of our</st> `<st c=\"18305\">ch02-blueprint</st>` <st c=\"18319\">project that shows how to</st> <st c=\"18346\">establish the registration</st> <st c=\"18373\">procedure correctly:</st>\n\n```", "```py\n\n\t\t\t<st c=\"19125\">The</st> `<st c=\"19130\">register_blueprint()</st>` <st c=\"19150\">method from the</st> `<st c=\"19167\">app</st>` <st c=\"19170\">instance has three parameters, namely,</st> <st c=\"19210\">the following:</st>\n\n\t\t\t\t*   <st c=\"19224\">The Blueprint object imported from</st> <st c=\"19260\">the sub-application.</st>\n\t\t\t\t*   <st c=\"19280\">The</st> `<st c=\"19285\">url_prefix</st>`<st c=\"19295\">, the assigned URL</st> <st c=\"19314\">base route.</st>\n\t\t\t\t*   <st c=\"19325\">The</st> `<st c=\"19330\">url_defaults</st>`<st c=\"19342\">, the dictionary of parameters required by the views linked to</st> <st c=\"19405\">the Blueprint.</st>\n\n\t\t\t<st c=\"19419\">Registering the Blueprints can also be</st> <st c=\"19459\">considered a workaround in providing our Flask applications with a context root.</st> <st c=\"19540\">The context root defines the application, and it serves as the base URL that can be used to access the application.</st> <st c=\"19656\">In the given snippet, our application was assigned the</st> `<st c=\"19711\">/ch02</st>` <st c=\"19716\">context root through the</st> `<st c=\"19742\">url_prefix</st>` <st c=\"19752\">parameter of</st> `<st c=\"19766\">register_blueprint()</st>`<st c=\"19786\">. On the other hand, as shown from the given code, the imports to the Blueprints must be placed below the app instantiation to avoid circular</st> <st c=\"19928\">import issues.</st>\n\t\t\t<st c=\"19942\">Another way of building a clean Flask project is by combining the application factory design technique with the</st> <st c=\"20055\">Blueprint approach.</st>\n\t\t\t<st c=\"20074\">Utilizing both the application factory and the Blueprint</st>\n\t\t\t<st c=\"20131\">To make the Blueprint structures</st> <st c=\"20165\">flexible when managing configuration variables and more organized by utilizing the application context proxies</st> `<st c=\"20276\">g</st>` <st c=\"20277\">and</st> `<st c=\"20282\">current_app</st>`<st c=\"20293\">, add an</st> `<st c=\"20302\">__init__.py</st>` <st c=\"20313\">file in the</st> `<st c=\"20326\">modules</st>` <st c=\"20333\">folder.</st> *<st c=\"20342\">Figure 2</st>**<st c=\"20350\">.3</st>* <st c=\"20352\">shows the project structure of</st> `<st c=\"20384\">ch02-blueprint-factory</st>` <st c=\"20406\">with the</st> `<st c=\"20416\">__init__.py</st>` <st c=\"20427\">file in place to implement the factory</st> <st c=\"20467\">method definition:</st>\n\t\t\t![Figure 2.3 – Flask directory with Blueprints and application factory](img/B19383_02_3.jpg)\n\n\t\t\t<st c=\"20827\">Figure 2.3 – Flask directory with Blueprints and application factory</st>\n\t\t\t<st c=\"20895\">The</st> `<st c=\"20900\">create_app()</st>` <st c=\"20912\">factory method can now include the import of the Blueprints and their registration to the app.</st> <st c=\"21008\">The rest of its setup is the same as the</st> `<st c=\"21049\">ch01</st>` <st c=\"21053\">project.</st> <st c=\"21063\">The following code shows its</st> <st c=\"21092\">entire</st> <st c=\"21098\">implementation:</st>\n\n```", "```py\n\n\t\t\t<st c=\"21716\">The application factory here uses the</st> `<st c=\"21755\">with</st>`<st c=\"21759\">-block to bind the application context only within the</st> <st c=\"21815\">Blueprint components.</st>\n\t\t\t<st c=\"21836\">Depending on the scope of the software requirements and the appropriate architecture, any of the given approaches</st> <st c=\"21950\">will be reliable and applicable in building organized, enterprise-grade Flask applications.</st> <st c=\"22043\">Adding more packages and other design patterns is possible, but the core structure emphasized in the previous discussions must remain intact to avoid</st> <st c=\"22193\">cyclic imports.</st>\n\t\t\t<st c=\"22208\">From project structuring, it is time to discuss the setup indicated in the application factory and</st> `<st c=\"22308\">main.py</st>` <st c=\"22315\">of the Blueprints, which is about the configuration of SQLAlchemy ORM and Flask’s</st> <st c=\"22398\">logging mechanism.</st>\n\t\t\t<st c=\"22416\">Applying object-relational mapping (ORM)</st>\n\t\t\t<st c=\"22457\">The most used</st> **<st c=\"22472\">object-relational mapping</st>** <st c=\"22497\">(</st>**<st c=\"22499\">ORM</st>**<st c=\"22502\">) that can work perfectly with the Flask framework is SQLAlchemy.</st> <st c=\"22569\">This</st> <st c=\"22574\">ORM is a boilerplated interface that aims to create a database-agnostic data layer to connect to any database engine.</st> <st c=\"22692\">But compared to other ORMs, SQLAlchemy has support in optimizing native SQL statements, which makes it popular with many database administrators.</st> <st c=\"22838\">When formulating its queries, it only requires Python functions and expressions to pursue</st> <st c=\"22928\">CRUD operations.</st>\n\t\t\t<st c=\"22944\">Before using the ORM, the</st> `<st c=\"22971\">flask-sqlalchemy</st>` <st c=\"22987\">and</st> `<st c=\"22992\">psycopg2-binary</st>` <st c=\"23007\">extensions for the PostgreSQL database must be installed in the virtual environment using the</st> <st c=\"23102\">following command:</st>\n\n```", "```py\n\n\t\t\t<st c=\"23165\">What follows next is</st> <st c=\"23186\">the setup of the</st> <st c=\"23204\">database connectivity.</st>\n\t\t\t<st c=\"23226\">Setting up the database connectivity</st>\n\t\t\t<st c=\"23263\">Now, we are ready to implement the configuration file for our database setup.</st> <st c=\"23342\">Flask 3.x supports the declarative extension of SQLAlchemy, which is the commonly used approach in implementing</st> <st c=\"23453\">SQLAlchemy ORM in most frameworks such</st> <st c=\"23493\">as FastAPI.</st>\n\t\t\t<st c=\"23504\">In this approach, the first step is to create the database connectivity by building the SQLAlchemy engine, which manages the connection pooling and the installed dialect.</st> <st c=\"23676\">The</st> `<st c=\"23680\">create_engine()</st>` <st c=\"23695\">function from the</st> `<st c=\"23714\">sqlalchemy</st>` <st c=\"23724\">module derives the engine object with a</st> **<st c=\"23765\">database URL</st>** <st c=\"23777\">(</st>**<st c=\"23779\">DB URL</st>**<st c=\"23785\">) string as its</st> <st c=\"23802\">main parameter.</st> <st c=\"23818\">This URL string contains the database name, DB API driver, account credentials, IP address of the database server, and</st> <st c=\"23937\">its port.</st>\n\t\t\t<st c=\"23946\">Now, the engine is required to create the session factory through the</st> `<st c=\"24017\">sessionmaker()</st>` <st c=\"24031\">method.</st> <st c=\"24040\">And this session factory becomes the essential parameter to the</st> `<st c=\"24104\">session_scoped()</st>` <st c=\"24120\">method in extracting the session registry, which provides the session to SQLAlchemy’s CRUD operations.</st> <st c=\"24224\">The following is the database configuration found in the</st> `<st c=\"24281\">/modules/model/config.py</st>` <st c=\"24305\">module of the</st> `<st c=\"24320\">ch02-blueprint</st>` <st c=\"24334\">project:</st>\n\n```", "```py\n\n\t\t\t<st c=\"24743\">When the sessions are all set, the derivation of the base object from the</st> `<st c=\"24818\">declarative_base()</st>` <st c=\"24836\">method is</st> <st c=\"24847\">the next focus for the model layer implementation.</st> <st c=\"24898\">The instance returned by this method will subclass all the SQLAlchemy entity or</st> <st c=\"24978\">model classes.</st>\n\t\t\t<st c=\"24992\">Building the model layer</st>\n\t\t\t<st c=\"25017\">Each entity class needs to extend the</st> `<st c=\"25056\">Base</st>` <st c=\"25060\">instance to derive the necessary properties and methods in mapping the schema table to the ORM platform.</st> <st c=\"25166\">It will allow the classes to use the</st> `<st c=\"25203\">Column</st>` <st c=\"25209\">helper class to</st> <st c=\"25225\">build the properties of the actual column metadata.</st> <st c=\"25278\">There are support classes that the models can utilize such as</st> `<st c=\"25340\">Integer</st>`<st c=\"25347\">,</st> `<st c=\"25349\">String</st>`<st c=\"25355\">,</st> `<st c=\"25357\">Date</st>`<st c=\"25361\">, and</st> `<st c=\"25367\">DateTime</st>` <st c=\"25375\">to define the data types and other constraints of the columns, and</st> `<st c=\"25443\">ForeignKey</st>` <st c=\"25453\">to establish parent-child table relationships.</st> <st c=\"25501\">The following are some model classes from the</st> `<st c=\"25547\">/</st>``<st c=\"25548\">modules/model/db.py</st>` <st c=\"25567\">module:</st>\n\n```", "```py\n\n\t\t\t<st c=\"26358\">Now, the</st> `<st c=\"26368\">relationship()</st>` <st c=\"26382\">directive in the code links to model classes based on their actual reference and foreign keys.</st> <st c=\"26478\">The</st> <st c=\"26482\">model class invokes the method and configures it by setting up some parameters, beginning with the name of the entity it must establish a relationship with and the backreference specification.</st> <st c=\"26675\">The</st> `<st c=\"26679\">back_populates</st>` <st c=\"26693\">parameter refers to the complementary attribute names of the related model classes, which express the rows needed to be queried based on some relationship loading technique, typically the lazy type.</st> <st c=\"26893\">Using the</st> `<st c=\"26903\">backref</st>` <st c=\"26910\">parameter instead of</st> `<st c=\"26932\">back_populates</st>` <st c=\"26946\">is also acceptable.</st> <st c=\"26967\">The following</st> `<st c=\"26981\">Customer</st>` <st c=\"26989\">model class shows its one-to-one relationship with</st> <st c=\"27040\">the</st> `<st c=\"27045\">Login</st>` <st c=\"27050\">entity model as depicted in their respective calls to the</st> `<st c=\"27109\">relationship()</st>` <st c=\"27123\">directive:</st>\n\n```", "```py\n\n\t\t\t<st c=\"27545\">The return value of the</st> `<st c=\"27570\">relationship()</st>` <st c=\"27584\">call in</st> `<st c=\"27593\">Login</st>` <st c=\"27598\">is the scalar object of the filtered</st> `<st c=\"27636\">Customer</st>` <st c=\"27644\">record.</st> <st c=\"27653\">Likewise, the</st> `<st c=\"27667\">Customer</st>` <st c=\"27675\">model has the joined</st> `<st c=\"27697\">Login</st>` <st c=\"27702\">instance because of the directive.</st> <st c=\"27738\">On the other hand, the method can also return either a</st> `<st c=\"27793\">List</st>` <st c=\"27797\">collection or scalar value if the relationship is a</st> *<st c=\"27850\">one-to-many</st>* <st c=\"27861\">or</st> *<st c=\"27865\">many-to-one</st>* <st c=\"27876\">type.</st> <st c=\"27883\">When setting this setup in the parent model class, the</st> `<st c=\"27938\">useList</st>` <st c=\"27945\">parameter must be omitted or set to</st> `<st c=\"27982\">True</st>` <st c=\"27986\">to indicate that it will return a filtered list of records from its child class.</st> <st c=\"28068\">However, if</st> `<st c=\"28080\">useList</st>` <st c=\"28087\">is set to</st> `<st c=\"28098\">False</st>`<st c=\"28103\">, the indicated relationship</st> <st c=\"28132\">is</st> *<st c=\"28135\">one-to-one</st>*<st c=\"28145\">.</st>\n\t\t\t<st c=\"28146\">The following</st> `<st c=\"28161\">Orders</st>` <st c=\"28167\">class creates a</st> *<st c=\"28184\">many-to-one</st>* <st c=\"28195\">relationship with the</st> `<st c=\"28218\">Products</st>` <st c=\"28226\">and</st> `<st c=\"28231\">Customer</st>` <st c=\"28239\">models but a</st> *<st c=\"28253\">one-to-one</st>* <st c=\"28263\">relationship</st> <st c=\"28277\">with the</st> `<st c=\"28286\">Payment</st>` <st c=\"28293\">model:</st>\n\n```", "```py\n\n\t\t\t<st c=\"29131\">The</st> `<st c=\"29136\">main.py</st>` <st c=\"29143\">module needs to call the custom method, the</st> `<st c=\"29188\">init_db()</st>` <st c=\"29197\">method found in the</st> `<st c=\"29218\">config.py</st>` <st c=\"29227\">module, to</st> <st c=\"29238\">load, and register all these model classes for the</st> <st c=\"29290\">repository classes.</st>\n\t\t\t<st c=\"29309\">Implementing the repository layer</st>\n\t\t\t<st c=\"29343\">Each repository class</st> <st c=\"29365\">requires SQLAlchemy’s</st> `<st c=\"29388\">Session</st>` <st c=\"29395\">instance to implement its CRUD transactions.</st> <st c=\"29441\">The following</st> `<st c=\"29455\">ProductRepository</st>` <st c=\"29472\">code is a sample repository class that manages the</st> `<st c=\"29524\">product</st>` <st c=\"29531\">table:</st>\n\n```", "```py\n\n\t\t\t`<st c=\"29798\">ProductRepository</st>`<st c=\"29816\">’s constructor is essential in accepting the</st> `<st c=\"29862\">Session</st>` <st c=\"29869\">instance from the view or service functions and preparing it for internal processing.</st> <st c=\"29956\">The first transaction is the</st> `<st c=\"29985\">INSERT</st>` <st c=\"29991\">product record transaction that uses the</st> `<st c=\"30033\">add()</st>` <st c=\"30038\">method of the</st> `<st c=\"30053\">Session</st>`<st c=\"30060\">. SQLAlchemy always imposes transaction management in every CRUD operation.</st> <st c=\"30136\">Thus, invoking</st> `<st c=\"30151\">commit()</st>` <st c=\"30159\">of its</st> `<st c=\"30167\">Session</st>` <st c=\"30174\">object is required after successfully executing the</st> `<st c=\"30227\">add()</st>` <st c=\"30232\">method.</st> <st c=\"30241\">The following</st> `<st c=\"30255\">insert()</st>` <st c=\"30263\">method shows the correct implementation of an</st> `<st c=\"30310\">INSERT</st>` <st c=\"30316\">transaction</st> <st c=\"30329\">in SQLAlchemy:</st>\n\n```", "```py\n\n\t\t\t<st c=\"30586\">The</st> `<st c=\"30591\">Session</st>` <st c=\"30598\">object has an</st> `<st c=\"30613\">update</st>` <st c=\"30619\">method that can perform an</st> `<st c=\"30647\">UPDATE</st>` <st c=\"30653\">transaction.</st> <st c=\"30667\">The following</st> <st c=\"30681\">is an</st> `<st c=\"30687\">update()</st>` <st c=\"30695\">implementation that updates a</st> `<st c=\"30726\">product</st>` <st c=\"30733\">record based on its primary</st> <st c=\"30762\">key ID:</st>\n\n```", "```py\n\n\t\t\t<st c=\"31075\">The</st> `<st c=\"31080\">Session</st>` <st c=\"31087\">also has a</st> `<st c=\"31099\">delete()</st>` <st c=\"31107\">method that performs record deletion based on a constraint, usually by ID.</st> <st c=\"31183\">The following is an SQLAlchemy way of deleting a</st> `<st c=\"31232\">product</st>` <st c=\"31239\">record based on</st> <st c=\"31256\">its ID:</st>\n\n```", "```py\n\n\t\t\t<st c=\"31547\">And lastly, the</st> `<st c=\"31564\">Session</st>` <st c=\"31571\">supports a query transaction implementation through its</st> `<st c=\"31628\">query()</st>` <st c=\"31635\">method.</st> <st c=\"31644\">It can allow</st> <st c=\"31657\">the filtering of records using some constraints that will result in retrieving a list or a single one.</st> <st c=\"31760\">The following snippet shows a snapshot of these</st> <st c=\"31808\">query implementations:</st>\n\n```", "```py\n\n\t\t\t<st c=\"32369\">Since the</st> `<st c=\"32380\">selectall()</st>` <st c=\"32391\">query transaction must return a list of</st> `<st c=\"32432\">Product</st>` <st c=\"32439\">records, it needs to call the</st> `<st c=\"32470\">all()</st>` <st c=\"32475\">method of the</st> `<st c=\"32490\">Query</st>` <st c=\"32495\">object.</st> <st c=\"32504\">On the other hand, both</st> `<st c=\"32528\">select_one()</st>` <st c=\"32540\">and</st> `<st c=\"32545\">select_one_code()</st>` <st c=\"32562\">use</st> `<st c=\"32567\">Query</st>`<st c=\"32572\">’s</st> `<st c=\"32576\">one_to_many()</st>` <st c=\"32589\">method because they need to return only a single</st> `<st c=\"32639\">Product</st>` <st c=\"32646\">record based on</st> `<st c=\"32663\">select_one()</st>`<st c=\"32675\">’s primary key or</st> `<st c=\"32694\">select_one_code()</st>`<st c=\"32711\">’s unique</st> <st c=\"32722\">key filter.</st>\n\t\t\t<st c=\"32733\">In the</st> `<st c=\"32741\">ch02-blueprint</st>` <st c=\"32755\">project, each Blueprint module has its repository classes placed in their respective</st> `<st c=\"32841\">/repository</st>` <st c=\"32852\">directory.</st> <st c=\"32864\">Whether these repository classes use the</st> `<st c=\"32905\">SQLAlchemy</st>` <st c=\"32915\">instance or</st> `<st c=\"32928\">Session</st>` <st c=\"32935\">of the declarative approach, Flask 3.x has no issues supporting either</st> <st c=\"33006\">of these</st> <st c=\"33016\">repository implementations.</st>\n\t\t\t<st c=\"33043\">Service and repository layers are among the components that require a logging mechanism to audit all the process flows occurring within these two layers.</st> <st c=\"33198\">Let us now explore how to employ software logging in Flask</st> <st c=\"33257\">web applications.</st>\n\t\t\t<st c=\"33274\">Configuring the logging mechanism</st>\n\t\t\t<st c=\"33308\">Flask utilizes the standard logging modules of Python.</st> <st c=\"33364\">The app instance has a built-in</st> `<st c=\"33396\">logger()</st>` <st c=\"33404\">method, which is</st> <st c=\"33421\">pre-configured and can log views, repositories, services, and events.</st> <st c=\"33492\">The only problem is that this default logger cannot perform info logging because the default severity level of the configuration is</st> `<st c=\"33624\">WARNING</st>`<st c=\"33631\">. By the way, turn off debug mode when running applications with a logger to avoid</st> <st c=\"33714\">logging errors.</st>\n\t\t\t<st c=\"33729\">The Python logging mechanism has the following</st> <st c=\"33777\">severity levels:</st>\n\n\t\t\t\t*   `<st c=\"33793\">Debug</st>`<st c=\"33799\">: This level has a</st> *<st c=\"33819\">severity value of 10</st>* <st c=\"33839\">and can provide traces of results during the</st> <st c=\"33885\">debugging process.</st>\n\t\t\t\t*   `<st c=\"33903\">Info</st>`<st c=\"33908\">: This level has a</st> *<st c=\"33928\">severity value of 20</st>* <st c=\"33948\">and can provide general details about</st> <st c=\"33987\">execution flows.</st>\n\t\t\t\t*   `<st c=\"34003\">Warning</st>`<st c=\"34011\">: This level has a</st> *<st c=\"34031\">severity value of 30</st>* <st c=\"34051\">and can inform about areas of the application that may cause problems in the future due to some changes in the platform or</st> <st c=\"34175\">API classes.</st>\n\t\t\t\t*   `<st c=\"34187\">Error</st>`<st c=\"34193\">: This level has a</st> *<st c=\"34213\">severity value of 40</st>* <st c=\"34233\">and can track down executions that encountered failures in performing the</st> <st c=\"34308\">expected features.</st>\n\t\t\t\t*   `<st c=\"34326\">Critical</st>`<st c=\"34335\">: This level</st> <st c=\"34349\">has a</st> *<st c=\"34355\">severity value of 50</st>* <st c=\"34375\">and can show audits of serious issues in</st> <st c=\"34417\">the application.</st>\n\n\t\t\t<st c=\"34433\">Important note</st>\n\t\t\t<st c=\"34448\">The log level value or severity value provides a numerical weight on a logging level that signifies the importance of the audited log messages.</st> <st c=\"34593\">Usually, the higher the value, the more critical the priority level or log</st> <st c=\"34668\">message is.</st>\n\t\t\t<st c=\"34679\">The logger can only log events with a severity level greater than or equal to the severity level of its configuration.</st> <st c=\"34799\">For instance, if the logger has a severity level of</st> `<st c=\"34851\">WARNING</st>`<st c=\"34858\">, it can only log transactions with warnings, errors, and critical events.</st> <st c=\"34933\">Thus, Flask requires a custom configuration of its</st> <st c=\"34984\">logging setup.</st>\n\t\t\t<st c=\"34998\">In all our three projects, we implemented the following ways to configure the</st> <st c=\"35077\">Flask logger:</st>\n\n\t\t\t\t*   **<st c=\"35090\">Approach 1</st>**<st c=\"35101\">: Set up the logger, handlers, and formatter programmatically using the classes from Python’s logging module, as shown in the</st> <st c=\"35228\">following method:</st>\n\n    ```", "```py\n     def configure_logger(log_path):\n               logging.config.dictConfig({\n                 'version': 1,\n                 'formatters': {\n                  'default': {'format': '%(asctime)s\n                    %(levelname)s %(module)s %(funcName)s\n                    %(message)s', 'datefmt': '%Y-%m-%d\n                            %H:%M:%S'}\n                    },\n                'handlers': {\n                  '<st c=\"35998\">console</st>': { <st c=\"36012\">'level': 'DEBUG',</st><st c=\"36029\">'class': 'logging.StreamHandler'</st>,\n                    'formatter': 'default',\n                    'stream': 'ext://sys.stdout'\n                  },\n                  '<st c=\"36121\">file</st>': { <st c=\"36132\">'level': 'DEBUG'</st>, <st c=\"36150\">'class':</st><st c=\"36158\">'logging.handlers .RotatingFileHandler'</st>,\n                    'formatter': 'default',\n                    'filename': log_path,\n                    'maxBytes': 1024,\n                    'backupCount': 3\n                  }\n              }, <st c=\"36286\">'loggers'</st>: {\n                'default': { <st c=\"36313\">'level': 'DEBUG',</st><st c=\"36330\">'handlers': ['console', 'file']</st> }\n            }, <st c=\"36368\">'disable_existing_loggers': False</st> })\n    ```", "```py\n\n\t\t\t<st c=\"36404\">In maintaining clean logs, it is always a good practice to disable all default loggers, such as the</st> `<st c=\"36505\">werkzeug</st>` <st c=\"36513\">logger.</st> <st c=\"36522\">In applying</st> *<st c=\"36534\">Approach 1</st>*<st c=\"36544\">, disable the server logging by explicitly deselecting the</st> `<st c=\"36603\">werkzeug</st>` <st c=\"36611\">logger from the working loggers.</st> <st c=\"36645\">When using</st> *<st c=\"36656\">Approach 2</st>*<st c=\"36666\">, on the other</st> <st c=\"36680\">hand, setting the</st> `<st c=\"36699\">disable_existing_loggers</st>` <st c=\"36723\">key to</st> `<st c=\"36731\">False</st>` <st c=\"36736\">disables the</st> `<st c=\"36750\">werkzeug</st>` <st c=\"36758\">logger and other</st> <st c=\"36776\">unwanted ones.</st>\n\t\t\t<st c=\"36790\">All in all, both of the given configurations produce a similar logging mechanism.</st> <st c=\"36873\">The</st> `<st c=\"36877\">ch02-factory</st>` <st c=\"36889\">project of our</st> *<st c=\"36905\">Online Shipping Management System</st>* <st c=\"36938\">applied the programmatical approach, and its</st> `<st c=\"36984\">add_payment()</st>` <st c=\"36997\">view function has the following implementation</st> <st c=\"37045\">with logging:</st>\n\n```", "```py\n\n\t\t\t<st c=\"37953\">Regarding logging the repository layer, the following is a snapshot of</st> `<st c=\"38025\">ShippingRepository</st>` <st c=\"38043\">that</st> <st c=\"38048\">manages shipment transactions and uses logging to audit all</st> <st c=\"38109\">these transactions:</st>\n\n```", "```py\n\n\t\t\t<st c=\"38539\">The given</st> `<st c=\"38550\">insert()</st>` <st c=\"38558\">method of the repository uses the</st> `<st c=\"38593\">info()</st>` <st c=\"38599\">method to log the insert transactions found in the</st> `<st c=\"38651\">try</st>` <st c=\"38654\">block, while the</st> `<st c=\"38672\">error()</st>` <st c=\"38679\">method logs the</st> `<st c=\"38696\">exception</st>` <st c=\"38705\">block.</st>\n\t\t\t<st c=\"38712\">Now, every framework has its own way of managing session data, so let us learn how Flask enables its session</st> <st c=\"38822\">handling mechanism.</st>\n\t\t\t<st c=\"38841\">Creating user sessions</st>\n\t\t\t<st c=\"38864\">Assigning an uncompromised</st> <st c=\"38892\">value to Flask’s</st> `<st c=\"38909\">SECRET_KEY</st>` <st c=\"38919\">built-in configuration variable pushes the</st> `<st c=\"38963\">Session</st>` <st c=\"38970\">context into the platform.</st> <st c=\"38998\">Here are the ways to generate the</st> <st c=\"39032\">secret key:</st>\n\n\t\t\t\t*   <st c=\"39043\">Apply the</st> `<st c=\"39054\">uuid4()</st>` <st c=\"39061\">method from the</st> `<st c=\"39078\">uuid</st>` <st c=\"39082\">module.</st>\n\t\t\t\t*   <st c=\"39090\">Utilize any</st> `<st c=\"39103\">openssl</st>` <st c=\"39110\">utility.</st>\n\t\t\t\t*   <st c=\"39119\">Use the</st> `<st c=\"39128\">token_urlsafe()</st>` <st c=\"39143\">method from the</st> `<st c=\"39160\">secrets</st>` <st c=\"39167\">module.</st>\n\t\t\t\t*   <st c=\"39175\">Apply encryption tools such as AES, RSA,</st> <st c=\"39217\">and SHA.</st>\n\n\t\t\t<st c=\"39225\">Our three applications include a separate Python script that runs the</st> `<st c=\"39296\">token_urlsafe()</st>` <st c=\"39311\">method to generate a random key string with 16 random bytes for the</st> `<st c=\"39380\">SECRET_KEY</st>` <st c=\"39390\">environment variable.</st> <st c=\"39413\">The following snippet shows how our applications set the secret key with the</st> `<st c=\"39490\">app</st>` <st c=\"39493\">instance:</st>\n\n```", "```py\n @current_app.route('/login/auth', methods=['GET', 'POST'])\ndef login_db_auth():\n    if request.method == 'POST':\n        current_app.logger.info('add_db_auth POST view executed')\n        repo = LoginRepository(db)\n        username = request.form['username'].strip()\n        password = request.form['password'].strip()\n        user:Login = repo.select_one_username(username)\n        if user == None:\n          flash(f'User account { request.form[\"username\"] } does not exist.', 'error')\n          return render_template('login/login.html') , 200\n        elif not user.password == password:\n          flash('Invalid password.', 'error')\n          return render_template('login/login.html') , 200\n        else: <st c=\"40980\">session['username'] = request.form['username']</st> return redirect('/menu')\n    current_app.logger.info('add_db_auth GET view executed')\n    return render_template('login/login.html') , 200\n```", "```py\n session.pop(\"username\", None)\n```", "```py\n @app.before_request\ndef init_request():\n    get_database()\n    if (( request.endpoint != 'login_db_auth' and  request.endpoint != 'index' and request.endpoint != 'static')  and <st c=\"41878\">'username' not in session</st>):\n        app.logger.info('a user is unauthenticated')\n        return redirect('/login/auth')\n    elif (( request.endpoint == 'login_db_auth' and  request.endpoint != 'index' and request.endpoint != 'static')  and <st c=\"42097\">'username' in session</st>):\n        app.logger.info('a user is already logged in')\n        return redirect('/menu')\n```", "```py\n @current_app.route('/logout', methods=['GET'])\ndef logout(): <st c=\"43094\">session.clear()</st> current_app.logger.info('logout view executed')\n    return redirect('/login/auth')\n```", "```py\n @current_app.route('/login/add', methods=['GET', 'POST'])\ndef add_login():\n    if request.method == 'POST':\n        current_app.logger.info('add_login POST view executed')\n        login = Login(username=request.form['username'], password=request.form['password'], user_type=int(request.form['user_type']) )\n        repo = LoginRepository(db)\n        result = repo.insert(login)\n        if result == True: <st c=\"44263\">flash('Successully added a user', 'success')</st> else: <st c=\"44314\">flash(f'Error adding { request.form[\"username\"]</st> <st c=\"44361\">}', 'error')</st> return render_template('login/login_add.html') , 200\n    current_app.logger.info('add_login GET view executed')\n    return render_template('login/login_add.html') , 200\n```", "```py\n {% macro render_error_flash(class_id) %} <st c=\"45510\">{% with errors =</st> <st c=\"45526\">get_flashed_messages(category_filter=[\"error\"]) %}</st> {% if errors %}\n            <p id=\"{{class_id}}\" class=\"w-lg-50\">\n            {% for msg in errors %}\n                {{ msg }}\n            {% endfor %}\n            </p>\n        {% endif %}\n    {% endwith %}\n{% endmacro %}\n```", "```py\n {%macro render_list_flash()%} <st c=\"46132\">{% with messages = get_flashed_messages() %}</st> {% if messages %}\n            <h1 class=\"display-4 \">\n                {% for message in messages %}\n                    {{ message }}\n                {% endfor %}\n            </h1>\n        {% endif %}\n    {% endwith %}\n{%endmacro%}\n```", "```py\n<st c=\"47856\">{% from \"macros/flask_segment.html\" import</st> <st c=\"47899\">render_list_flash with context</st> %}\n<!DOCTYPE html>\n<html lang=\"en\">\n    <head>\n        <title>List Login Accounts</title>\n        <link rel=\"stylesheet\" href=\"{{ url_for('static', filename='css/styles.css')}}\">\n        <link rel=\"stylesheet\" href=\"{{ url_for('static', filename='css/bootstrap.min.css')}}\">\n        <script src=\"img/jquery-3.6.4.js') }}\"></script>\n        <script src=\"img/bootstrap.bundle.min.js') }}\"></script>\n    </head>\n    <body>\n        <section class=\"position-relative py-4 py-xl-5\">\n            <div class=\"container position-relative\">\n                <div class=\"row d-flex\">\n                    <div class=\"col-md-8 col-xl-6 text-center mx-auto\"> <st c=\"48527\">{{render_list_flash()}}</st> … … … … … …\n                     </div>\n                </div>\n                … … … … … …\n        </section>\n    </body>\n</html>\n```", "```py\n <!DOCTYPE html>\n<html lang=\"en\">\n    <head>\n        <title>List of Products</title>\n        <link rel=\"stylesheet\" href=\"{{ url_for('static', filename='css/styles.css')}}\">\n        <link rel=\"stylesheet\" href=\"{{ url_for('static', filename='css/bootstrap.min.css')}}\">\n        <script src=\"img/jquery-3.6.4.js') }}\"></script>\n        <script src=\"img/bootstrap.bundle.min.js') }}\"></script>\n    </head>\n    <body>\n        <table>\n        {% for p in prods %}\n            <tr>\n                <td>{{p.id}}</td>\n                <td>{{p.name|<st c=\"49926\">trim</st>|<st c=\"49933\">upper</st>}}</td>\n                <td>{<st c=\"49952\">{\"\\u20B1%.2f\"|format(</st>p.price<st c=\"49982\">)</st> }}</td>\n                <td>{{p.code}}</td>\n            </tr>\n        {% endfor %}\n        </table>\n    </body>\n</html>\n```", "```py\n def server_error(<st c=\"52107\">e</st>):\n    print(e)\n    return make_response(render_template(\"error/500.html\", title=\"Internal server error\"), 500)\napp.<st c=\"52265\">register_error_handler()</st> method has two parameters:\n\n\t\t\t\t*   <st c=\"52316\">The status code that will trigger the</st> <st c=\"52355\">error handling.</st>\n\t\t\t\t*   <st c=\"52370\">The function name of the custom</st> <st c=\"52403\">error handler.</st>\n\n\t\t\t<st c=\"52417\">There should only be one registered custom error handler per</st> <st c=\"52479\">status code.</st>\n\t\t\t<st c=\"52491\">Applying the @errorhandler decorator</st>\n\t\t\t<st c=\"52528\">The easiest way to</st> <st c=\"52547\">implement error handlers is to</st> <st c=\"52578\">decorate customer error handlers with the app’s</st> `<st c=\"52627\">errorhandler()</st>` <st c=\"52641\">decorator.</st> <st c=\"52653\">The structure and behavior of the custom method are the same as the previous approach except that it has an</st> `<st c=\"52761\">errorhandler</st>` <st c=\"52773\">decorator with the assigned status code.</st> <st c=\"52815\">The following shows the error handlers implemented</st> <st c=\"52865\">using</st> <st c=\"52872\">the decorator:</st>\n\n```", "```py\n\n\t\t\t<st c=\"53137\">Accessing an invalid URL path</st> <st c=\"53168\">will auto-render the error page in</st> *<st c=\"53203\">Figure 2</st>**<st c=\"53211\">.5</st>* <st c=\"53213\">because of the given error handler for HTTP status</st> <st c=\"53265\">code</st> `<st c=\"53270\">404</st>`<st c=\"53273\">:</st>\n\t\t\t![Figure 2.5 – An error page rendered by the not_found() error handler](img/B19383_02_5.jpg)\n\n\t\t\t<st c=\"53321\">Figure 2.5 – An error page rendered by the not_found() error handler</st>\n\t\t\t<st c=\"53389\">Creating custom exceptions</st>\n\t\t\t<st c=\"53416\">Another wise approach is</st> <st c=\"53441\">assigning custom exceptions to error handlers.</st> <st c=\"53489\">First, create a custom exception by subclassing</st> `<st c=\"53537\">HttpException</st>` <st c=\"53550\">from the</st> `<st c=\"53560\">werkzeug.exceptions</st>` <st c=\"53579\">module.</st> <st c=\"53588\">The following shows how to create</st> <st c=\"53621\">custom exceptions for</st> <st c=\"53644\">Flask transactions:</st>\n\n```", "```py\n\n\t\t\t<st c=\"54001\">View functions and repository methods can throw this custom</st> `<st c=\"54062\">DuplicateRecordException</st>` <st c=\"54086\">class when an</st> `<st c=\"54101\">INSERT</st>` <st c=\"54107\">record transaction encounters a primary or unique key duplicate error.</st> <st c=\"54179\">It requires setting the two inherited fields from the parent</st> `<st c=\"54240\">HTTPException</st>` <st c=\"54253\">class, namely the</st> `<st c=\"54272\">code</st>` <st c=\"54276\">and</st> `<st c=\"54281\">description</st>` <st c=\"54292\">fields.</st> <st c=\"54301\">Once triggered, the exception class can auto-render its error page when it has an overridden</st> `<st c=\"54394\">get_response()</st>` <st c=\"54408\">method that creates a custom</st> `<st c=\"54438\">Response</st>` <st c=\"54446\">object to make way for the rendering of its error page with the</st> <st c=\"54511\">exception message.</st>\n\t\t\t<st c=\"54529\">But overriding the</st> `<st c=\"54549\">get_response()</st>` <st c=\"54563\">instance method of the custom exception is just an option.</st> <st c=\"54623\">Sometimes, assigning values to the code and description fields is enough, and then we map them to a custom error handler for the rendition of its error page, either through the</st> `<st c=\"54800\">@errorhandler</st>` <st c=\"54813\">decorator or</st> `<st c=\"54827\">register_error_handler()</st>`<st c=\"54851\">. The following code shows this kind</st> <st c=\"54888\">of approach:</st>\n\n```", "```py\n from werkzeug.exceptions import HTTPException <st c=\"55657\">@app.errorhandler(Exception)</st> def handle_built_exception(e):\n    if isinstance(e, HTTPException):\n        return e <st c=\"55759\">return render_template(\"error/generic.html\",</st> <st c=\"55803\">title=\"Internal server error\", e=e), 500</st>\n```", "```py\n @current_app.route('/payment/add', methods = ['GET', 'POST'])\ndef add_payment():\n    if request.method == 'POST':\n        current_app.logger.info('add_payment POST view executed')\n        … … … … … …\n        result = repo.insert(payment)\n        if result == False: <st c=\"56766\">abort(500)</st> return render_template('payment/add_payment_form.html', orders=orders, ptypes=ptypes), 200\n    current_app.logger.info('add_payment GET view executed')\n    … … … … … …\n    return render_template('payment/add_payment_form.html', orders=orders, ptypes=ptypes), 200\n```", "```py\n @current_app.route('/orders/add', methods=['GET', 'POST'])\ndef add_order():\n    if request.method == 'POST':\n        current_app.logger.info('add_order POST view executed')\n        repo = OrderRepository(db)\n        … … … … … …\n        result = repo.insert(order)\n        if result == False: <st c=\"57529\">raise DatabaseException()</st> customers = get_all_cid(db)\n        products = get_all_pid(db)\n        return render_template('order/add_order_form.html', customers=customers, products=products), 200\n    current_app.logger.info('add_order GET view executed')\n    customers = get_all_cid(db)\n    products = get_all_pid(db)\n    return render_template('order/add_order_form.html', customers=customers, products=products), 200\n```", "```py\n def create_app(config_file):\n    app = Flask(__name__, template_folder='../app/pages', <st c=\"59052\">static_folder='../app/resources'</st>)\n    app.config.from_file(config_file, toml.load)\n    db.init_app(app)\n    configure_func_logging('log_msg.txt')\n    … … … … … …\n```", "```py\n shipping_bp = Blueprint('shipping_bp', __name__,\n    template_folder='pages', <st c=\"59596\">/resources</st> folder of the main application, while *<st c=\"59645\">Figure 2</st>**<st c=\"59653\">.7</st>* shows the <st c=\"59666\">/resources</st> folder of the shipping Blueprint package:\n\t\t\t![Figure 2.6 – The location of /resources in the main application](img/B19383_02_6.jpg)\n\n\t\t\t<st c=\"59837\">Figure 2.6 – The location of /resources in the main application</st>\n\t\t\t![Figure 2.7 – The location of /resources in the shipping Blueprint](img/B19383_02_7.jpg)\n\n\t\t\t<st c=\"59985\">Figure 2.7 – The location of /resources in the shipping Blueprint</st>\n\t\t\t<st c=\"60050\">The</st> `<st c=\"60055\">static</st>` <st c=\"60061\">directory is the default and common folder name used to contain the Flask application’s web assets.</st> <st c=\"60162\">But in the</st> <st c=\"60173\">succeeding chapters, we will use</st> `<st c=\"60206\">/resources</st>` <st c=\"60216\">instead of</st> `<st c=\"60228\">/static</st>` <st c=\"60235\">for naming</st> <st c=\"60247\">convention purposes.</st>\n\t\t\t<st c=\"60267\">Accessing the assets in the templates</st>\n\t\t\t<st c=\"60305\">To avoid accessing relative paths, Flask manages, accesses, and loads static files or web assets in template pages using</st> `<st c=\"60427\">static_url_path</st>`<st c=\"60442\">, a logical path name used to access web resources from</st> <st c=\"60497\">the</st> `<st c=\"60502\">static</st>` <st c=\"60508\">folder.</st> <st c=\"60517\">Its default path</st> <st c=\"60534\">value is</st> `<st c=\"60543\">static</st>`<st c=\"60549\">, but applications can set an appropriate value</st> <st c=\"60597\">if needed.</st>\n\t\t\t<st c=\"60607\">Our application uses the Bootstrap 4 framework to apply responsive web design.</st> <st c=\"60687\">All its assets are in the</st> `<st c=\"60713\">/resources</st>` <st c=\"60723\">folder, and the following</st> `<st c=\"60750\">menu.html</st>` <st c=\"60759\">template shows how to access these assets from</st> <st c=\"60807\">the folder:</st>\n\n```", "```py\n\n\t\t\t<st c=\"61876\">The</st> `<st c=\"61881\">url_for()</st>` <st c=\"61890\">function, used to</st> <st c=\"61908\">access view endpoints in the</st> <st c=\"61938\">templates, is the way to access the static resources from the</st> `<st c=\"62000\">/resources</st>` <st c=\"62010\">folder using</st> `<st c=\"62024\">static_url_path</st>` <st c=\"62039\">as the</st> <st c=\"62046\">directory name.</st>\n\t\t\t<st c=\"62062\">Summary</st>\n\t\t\t<st c=\"62070\">This chapter provided information on additional features of Flask that can support building complete, enterprise-grade, scalable, and complex but manageable Flask web applications.</st> <st c=\"62252\">The details about adding error handling in many ways, integrating the Bootstrap framework to the application without using extensions, implementing SQLAlchemy using the declarative and standard approaches, and optimizing the Jinja2 templates using macros, indicate that the Flask framework is a lightweight but powerful solution to building</st> <st c=\"62593\">web applications.</st>\n\t\t\t<st c=\"62610\">After learning about creating full-blown web applications with Flask, let us discuss and highlight, in the next chapter, the components and procedures for building API-based applications using the Flask</st> <st c=\"62814\">3.x framework.</st>\n\n```", "```py\n\n```", "```py\n\n```"]