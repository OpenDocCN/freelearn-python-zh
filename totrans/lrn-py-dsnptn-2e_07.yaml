- en: Chapter 7. The Command Pattern – Encapsulating Invocation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we started with an introduction to behavioral design
    patterns. You learned the concept of `Observers` and discussed the Observer design
    pattern. We understood the concept of the Observer design pattern with a UML diagram
    and also learned how it's applied in the real world with the help of Python implementations.
    We discussed the pros and cons of the Observer pattern. You also learned about
    the Observer pattern with an FAQ section and summarized the discussion at the
    end of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will talk about the Command design pattern. Like the Observer
    pattern, the Command pattern falls under the hood of Behavioral patterns. We will
    get introduced to the Command design pattern and discuss how it is used in software
    application development. We will work with a sample use case and implement it
    in Python v3.5.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics in brief:'
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to Command design patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Command pattern and its UML diagram
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A real-world use case with the Python v3.5 code implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Command pattern's pros and cons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Frequently asked questions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing the Command pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we saw in the previous chapter, Behavioral patterns focus on the responsibilities
    that an object has. It deals with the interaction among objects to achieve larger
    functionality. The Command pattern is a behavioral design pattern in which an
    object is used to encapsulate all the information needed to perform an action
    or trigger an event at a later time. This information includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The method name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An object that owns the method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Values for method parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's understand the pattern with a very simple software example. Consider the
    case of an installation wizard. A typical wizard may contain multiple phases or
    screens that capture a user's preferences. While the user browses through the
    wizard, s/he makes certain choices. Wizards are typically implemented with the
    Command pattern. A wizard is first launched with an object called the `Command`
    object. The preferences or choices made by the user in multiple phases of the
    wizard are then stored in the `Command` object. When the user clicks on the **Finish**
    button on the last screen of the wizard, the `Command` object runs an `execute()`
    method, which considers all the stored choices and runs the appropriate installation
    procedure. Thus, all the information regarding the choices are encapsulated in
    an object that can be used later to take an action.
  prefs: []
  type: TYPE_NORMAL
- en: Another easy example is that of the printer spooler. A spooler can be implemented
    as a `Command` object that stores information such as the page type (*A5*-*A1*),
    portrait/landscape, collated/non-collated. When the user prints something (say,
    an image), the spooler runs the `execute()` method on the `Command` object and
    the image is printed with the set preferences.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Command design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Command pattern works with the following terms—`Command`, `Receiver`, `Invoker`,
    and `Client`:'
  prefs: []
  type: TYPE_NORMAL
- en: A `Command` object knows about the `Receiver` objects and invokes a method of
    the `Receiver` object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Values for parameters of the receiver method are stored in the `Command` object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The invoker knows how to execute a command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The client creates a `Command` object and sets its receiver
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The main intentions of the Command pattern are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulating a request as an object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allowing the parameterization of clients with different requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allowing to save the requests in a queue (we will talk about this later in the
    chapter)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing an object-oriented callback
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Command pattern can be used in the following multiple scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: Parameterizing objects depending on the action to be performed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding actions to a queue and executing requests at different points
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a structure for high-level operations that are based on smaller operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following Python code implements the Command design pattern. We talked
    about the example of the wizard earlier in the chapter. Consider that we want
    to develop a wizard for installation or, popularly, installer. Typically, an installation
    implies the copying or moving of files in the filesystem based on the choices
    that a user makes. In the following example, in the client code, we start by creating
    the `Wizard` object and use the `preferences()` method that stores the choices
    made by the user during various screens of the wizard. On the wizard, when **Finish**
    button is clicked, the `execute()` method is called. The `execute()` method picks
    up the preference and starts the installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding the Command design pattern](img/00023.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A UML class diagram for the Command pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's now understand more about the Command pattern with the help of the following
    UML diagram.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we discussed in the previous paragraph, the Command pattern has these main
    participants: the `Command`, `ConcreteCommand`, `Receiver`, `Invoker`, and `Client`.
    Let''s put these in a UML diagram and see how the classes look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A UML class diagram for the Command pattern](img/00024.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As we look at the UML diagram, you''ll realize that there are five main participants
    in this pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Command`: This declares an interface to execute an operation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConcreteCommand`: This defines a binding between the `Receiver` object and
    action'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Client`: This creates a `ConcreteCommand` object and sets its receiver'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Invoker`: This asks `ConcreteCommand` to carry out the request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Receiver`: This knows how to perform the operations associated with carrying
    out the request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The flow is straightforward. The client asks for a command to be executed.
    The invoker takes the command, encapsulates it, and places it in a queue. The
    `ConcreteCommand` class is in charge of the requested command and asks the receiver
    to perform the given action. The following code example is to understand the pattern
    with all the participants involved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Implementing the Command pattern in the real world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will take up an example of the stock exchange (much talked about in the Internet
    world) to demonstrate the implementation of the Command pattern. What happens
    in a stock exchange? You, as a user of the stock exchange, create orders to buy
    or sell stocks. Typically, you don't buy or sell them; it's the agent or broker
    who plays the intermediary between you and the stock exchange. The agent is responsible
    for taking your request to the stock exchange and getting the work done. Imagine
    that you want to sell a stock on Monday morning when the exchange opens up. You
    can still make the request to sell stock on Sunday night to your agent even though
    the exchange is not yet open. The agent then queues this request to be executed
    on Monday morning when the exchange is open for the trading. This presents a classical
    case for the Command pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Design considerations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Based on the UML diagram, you learned that the Command pattern has four main
    participants—`Command`, `ConcreteCommand`, `Invoker`, and `Receiver`. For the
    preceding scenario, we should create an `Order` interface that defines the order
    that a client places. We should define `ConcreteCommand` classes to buy or sell
    a stock. A class also needs to be defined for the stock exchange. We should define
    the `Receiver` class that will actually execute the trade and the agent (known
    as the invoker) that invokes the order and gets it executed by the receiver.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s develop an application in Python v3.5 and implement the preceding use
    case. We start with the `Command` object, `Order`:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Command` object is represented by the `Order` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Order` provides you with an interface (Python''s abstract base class) so that
    `ConcreteCommand` can implement the behavior'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `execute()` method is the abstract method that needs to be defined by the
    `ConcreteCommand` classes to execute the `Order` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code represents the abstract class `Order` and the abstract method
    `execute()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We have also developed certain classes that represent `ConcreteCommand`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we have two main concrete classes: `BuyStockOrder` and `SellStockOrder`
    that implement the `Order` interface'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both the `ConcreteCommand` classes use the object of the stock trading system
    so that they can define appropriate actions for the trading system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `execute()` method of each of these `ConcreteCommand` classes uses the stock
    trade object to execute the actions to buy and sell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s now look at concrete classes that implement the interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s talk about the stock trading system and how it''s implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: The `StockTrade` class represents the `Receiver` object in this example
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It defines multiple methods (actions) to execute the orders placed by `ConcreteCommand`
    objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `buy()` and `sell()` methods are defined by the receiver which are called
    by `BuyStockOrder` and `SellStockOrder` respectively to buy or sell the stock
    in the exchange
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s take a look at the `StockTrade` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Another part of the implementation is the invoker:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Agent` class represents the invoker.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Agent is the intermediary between the client and `StockExchange` and executes
    the orders placed by the client.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Agent defines a data member, `__orderQueue` (a list), that acts as a queue.
    Any new orders placed by the client are added to the queue.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `placeOrder()` method of Agent is responsible for queuing the orders and
    also executing the orders.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code depicts the `Agent` class which performs the role of `Invoker`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us now put all the above classes into perspective and look at how the client
    is implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: The client first sets its receiver, the `StockTrade` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It creates orders to buy and sell stocks with `BuyStockOrder` and `SellStockOrder`
    (`ConcreteCommand`) that executes the action on `StockTrade`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The invoker object is created by instantiating the `Agent` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `placeOrder()` method of `Agent` is used to get the orders that the client
    places
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is the code for the client is implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Design considerations](img/00025.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'There are multiple ways in which the Command pattern is used in software applications.
    We will discuss two specific implementations that are very relevant to the cloud
    applications:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Redo or rollback operations:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While implementing the rollback or redo operations, developers can do two different
    things.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: These are to create a snapshot in the filesystem or memory, and when asked for
    a rollback, revert to this snapshot.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: With the Command pattern, you can store the sequence of commands, and when asked
    for a redo, rerun the same set of actions.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Asynchronous task execution:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In distributed systems, we often need the facility to perform the asynchronous
    execution of tasks so that the core service is never blocked in case of more requests.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In the Command pattern, the invoker object can maintain a queue of requests
    and send these tasks to the `Receiver` object so that they can be acted on independent
    of the main application thread.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Advantages and disadvantages of Command patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Command pattern has the following advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: It decouples the classes that invoke the operation from the object that knows
    how to execute the operation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It allows you to create a sequence of commands by providing a queue system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extensions to add a new command is easy and can be done without changing the
    existing code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also define a rollback system with the Command pattern, for example,
    in the Wizard example, we could write a rollback method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are the disadvantages of the Command pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: There are a high number of classes and objects working together to achieve a
    goal. Application developers need to be careful developing these classes correctly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every individual command is a `ConcreteCommand` class that increases the volume
    of classes for implementation and maintenance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Frequently asked questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Q1\. Can there be no `Receiver` and `ConcreteCommand` implement execute method?
  prefs: []
  type: TYPE_NORMAL
- en: 'A: Yes, it is definitely possible to do so. Many software applications use
    the Command pattern in this way too. The only thing to note here is the interaction
    between the invoker and receiver. If the receiver is not defined, the level of
    decoupling goes down; moreover, the facility to parameterize commands is lost.'
  prefs: []
  type: TYPE_NORMAL
- en: Q2\. What data structure do I use to implement the queue mechanism in the invoker
    object?
  prefs: []
  type: TYPE_NORMAL
- en: 'A: In the stock exchange example that we studied earlier in the chapter, we
    used a list to implement the queue. However, the Command pattern talks about a
    stack implementation that is really helpful in the case of redo or rollback development.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We began the chapter by understanding the Command design pattern and how it
    is effectively used in software architecture.
  prefs: []
  type: TYPE_NORMAL
- en: We looked at how Command design patterns are used to encapsulate all the information
    needed to trigger an event or action at a later point in time.
  prefs: []
  type: TYPE_NORMAL
- en: You also learned the pattern with a UML diagram and sample code implementation
    in Python v3.5 along with the explanation.
  prefs: []
  type: TYPE_NORMAL
- en: We also covered an FAQ section that would help you get more ideas on the pattern
    and its possible advantages/disadvantages.
  prefs: []
  type: TYPE_NORMAL
- en: We will now take up other behavioral design patterns in the chapters to come.
  prefs: []
  type: TYPE_NORMAL
