- en: '2'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '2'
- en: Introducing Essential Functional Concepts
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 介绍基本函数式概念
- en: Most of the features of functional programming are already part of the Python
    language. Our goal in writing functional Python is to shift our focus away from
    imperative (procedural or object-oriented) techniques as much as possible.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程的大多数特性已经包含在 Python 语言中。我们编写函数式 Python 的目标是尽可能地将我们的关注点从命令式（过程式或面向对象）技术转移到函数式编程上。
- en: 'We’ll look at the following functional programming topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨以下函数式编程主题：
- en: In Python, functions are first-class objects.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Python 中，函数是一等对象。
- en: We can use and create higher-order functions.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用和创建高阶函数。
- en: We can create pure functions very easily.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以非常容易地创建纯函数。
- en: We can work with immutable data.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以处理不可变数据。
- en: In a limited way, we can create functions that have non-strict evaluation of
    sub-expressions. Python generally evaluates expressions strictly. As we’ll see
    later, a few operators are non-strict.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一定程度上，我们可以创建具有非严格子表达式评估的函数。Python 通常严格评估表达式。正如我们稍后将要看到的，一些运算符是非严格的。
- en: We can design functions that exploit eager versus lazy evaluation.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以设计利用贪婪与惰性评估的函数。
- en: We can use recursion instead of an explicit loop state.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以用递归代替显式的循环状态。
- en: We have a type system that can apply to functions and objects.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有一个类型系统，可以应用于函数和对象。
- en: 'This expands on the concepts from the first chapter: firstly, that purely functional
    programming avoids the complexities of an explicit state maintained through variable
    assignments; and secondly, that Python is not a purely functional language.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分内容是对第一章概念的扩展：首先，纯函数式编程避免了通过变量赋值来维护显式状态的复杂性；其次，Python 不是一个纯函数式语言。
- en: Because Python is not a purely functional language, we’ll focus on those features
    that are indisputably important in functional programming. We’ll start by looking
    at functions as first-class Python objects, with properties and methods of their
    own.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Python 不是一个纯函数式语言，我们将关注那些在函数式编程中无可争议的重要特性。我们将从查看函数作为具有自己属性和方法的独立 Python 对象开始。
- en: 2.1 Functions as first-class objects
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1 函数作为一等对象
- en: Functional programming is often succinct and expressive. One way to achieve
    this is by providing functions as arguments and return values for other functions.
    We’ll look at numerous examples of manipulating functions.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程通常简洁且表达力强。实现这一目标的一种方法是通过将函数作为其他函数的参数和返回值。我们将探讨许多操作函数的示例。
- en: For this to work, functions must be first-class objects in the runtime environment.
    In programming languages such as C, a function is not a runtime object; because
    the compiled C code generally lacks internal attributes and methods, there’s little
    runtime introspection that can be performed on a function. In Python, however,
    functions are objects that are created (usually) by `def` statements and can be
    manipulated by other Python functions. We can also create a function as a callable
    object or by assigning a lambda object to a variable.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，函数必须在运行时环境中是一等对象。在像 C 这样的编程语言中，函数不是运行时对象；因为编译的 C 代码通常缺乏内部属性和方法，所以对函数的运行时内省很少。然而，在
    Python 中，函数是由 `def` 语句创建的对象（通常），并且可以被其他 Python 函数操作。我们还可以通过将 lambda 对象赋给变量来创建一个可调用的函数对象。
- en: 'Here’s how a function definition creates an object with attributes:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 函数定义如何创建具有属性的对象的示例如下：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We’ve created an object, `example`, that is of the `function` class. This object
    has numerous attributes. The `__code__` attribute of the function object has attributes
    of its own. The implementation details aren’t important. What is important is
    functions are first-class objects and can be manipulated like all other objects.
    The example shows the values of two of the many attributes of a function object.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个对象，名为 `example`，它属于 `function` 类。这个对象有许多属性。函数对象的 `__code__` 属性也有自己的属性。实现细节并不重要。重要的是函数是一等对象，可以像所有其他对象一样被操作。以下示例展示了函数对象许多属性中的两个。
- en: 2.1.1 Pure functions
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.1.1 纯函数
- en: A function free from the confusion created by side effects is often more expressive
    than a function that also updates state elsewhere in an application. Using pure
    functions can also allow some optimizations by changing evaluation order. The
    big win, however, stems from pure functions being conceptually simpler and much
    easier to test.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一个不受副作用混淆影响的函数通常比在应用程序的其他地方更新状态的函数更具表达性。使用纯函数还可以通过改变评估顺序进行一些优化。然而，主要的优势来自于纯函数在概念上更简单，并且更容易测试。
- en: To write a pure function in Python, we have to write local-only code. This means
    we have to avoid `global` statements. We need to avoid entanglements with objects
    that have hidden state; often, this means avoiding input and output operations.
    We need to look closely at any use of `nonlocal`, also. While assigning to a non-local
    variable is a side effect, the state change is confined to a nested function definition.
    Avoiding global variables and file operations is an easy standard to meet. Pure
    functions are a common feature of Python programs.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Python 中编写纯函数，我们必须编写局部代码。这意味着我们必须避免使用 `global` 语句。我们需要避免与具有隐藏状态的对象纠缠；通常，这意味着避免输入和输出操作。我们还需要仔细检查任何对
    `nonlocal` 的使用。虽然将值赋给非局部变量是一个副作用，但状态变化仅限于嵌套函数定义。避免全局变量和文件操作是一个容易达到的标准。纯函数是 Python
    程序的常见特性。
- en: There isn’t a built-in tool to guarantee a Python function is free from side
    effects. For folks interested in the details, a tool like `mr-proper`, [https://pypi.org/project/mr-proper/](https://pypi.org/project/mr-proper/),
    can be used to confirm that a function is pure.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 没有内置的工具可以保证 Python 函数没有副作用。对于对细节感兴趣的人，可以使用 `mr-proper` 工具，[https://pypi.org/project/mr-proper/](https://pypi.org/project/mr-proper/)，来确认函数是纯的。
- en: A Python lambda is often used to create a very small, pure function. It’s possible
    for a lambda object to perform input or output or use an impure function. A bit
    of code inspection is still helpful to remove any doubts.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中的 lambda 经常用于创建一个非常小的、纯函数。lambda 对象执行输入或输出或使用不纯函数是可能的。一些代码检查仍然有助于消除任何疑虑。
- en: 'Here’s a function created by assigning a lambda object to a variable:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个通过将 lambda 对象赋值给变量创建的函数：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We created a pure function using `lambda` and assigned this to the variable
    `mersenne`. This is a callable object with a single parameter, `x`, that returns
    a single value.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `lambda` 创建了一个纯函数，并将其赋值给变量 `mersenne`。这是一个具有单个参数 `x` 的可调用对象，返回单个值。
- en: 'The following example shows an impure function defined as a lambda object:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个作为 lambda 对象定义的不纯函数的示例：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This function has the potential to update a dictionary in the event the key,
    `’ZIP’`, is not present. There are two cases, as shown in the following example:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数有更新字典的潜力，如果键 `'ZIP'` 不存在。以下示例中有两种情况：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the first case, the dictionary object `r_0` does not have the key, `’ZIP’`.
    The dictionary object is updated by the lambda object. This is a consequence of
    using the `setdefault()` method of a dictionary.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，字典对象 `r_0` 没有键 `'ZIP'`。字典对象被 lambda 对象更新。这是使用字典的 `setdefault()` 方法的后果。
- en: In the second case, the `r_1` object contains the key, `’ZIP’`. There’s no update
    to the dictionary. The side effect depends on the state of the object prior to
    the function, making the function potentially more difficult to understand.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二种情况下，`r_1` 对象包含键 `'ZIP'`。没有更新字典。副作用取决于函数之前对象的状态，这使得函数可能更难以理解。
- en: 2.1.2 Higher-order functions
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.1.2 高阶函数
- en: We can achieve expressive, succinct programs using higher-order functions. These
    are functions that accept a function as an argument or return a function as a
    value. We can use higher-order functions as a way to create composite functions
    from simpler functions.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用高阶函数来实现表达性、简洁的程序。这些函数可以接受一个函数作为参数或返回一个函数作为值。我们可以使用高阶函数作为从简单函数创建复合函数的一种方式。
- en: Consider the Python `max()` function. We can provide a function as an argument
    and modify how the `max()` function behaves.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑 Python 的 `max()` 函数。我们可以提供一个函数作为参数，并修改 `max()` 函数的行为。
- en: 'Here’s some data we might want to process:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些我们可能想要处理的数据：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can apply the `max()` function, as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像下面这样应用 `max()` 函数：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The default behavior is to simply compare each tuple in the sequence. This will
    return the tuple with the largest value on position zero of each tuple.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 默认行为是简单地比较序列中的每个元组。这将返回每个元组中位置零上具有最大值的元组。
- en: 'Since the `max()` function is a higher-order function, we can provide another
    function as an argument. In this case, we’ll use a lambda as the function; this
    is used by the `max()` function, as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `max()` 函数是一个高阶函数，我们可以提供一个函数作为参数。在这种情况下，我们将使用 lambda 作为函数；这被 `max()` 函数使用，如下所示：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this example, the `max()` function applies the supplied lambda and returns
    the tuple with the largest value in position one of each tuple.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`max()` 函数应用提供的 lambda 并返回每个元组中位置一的最大值的元组。
- en: Python provides a rich collection of higher-order functions. We’ll see examples
    of each of Python’s higher-order functions in later chapters, primarily in [Chapter 5](Chapter_05.xhtml#x1-1000005),
    [Higher-Order Functions](Chapter_05.xhtml#x1-1000005). We’ll also see how we can
    easily write our own higher-order functions.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Python 提供了丰富的集合高阶函数。我们将在后面的章节中看到 Python 每个高阶函数的示例，主要在[第5章](Chapter_05.xhtml#x1-1000005)，[高阶函数](Chapter_05.xhtml#x1-1000005)。我们还将看到我们如何轻松编写我们自己的高阶函数。
- en: 2.2 Immutable data
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2 不可变数据
- en: Since we’re not using variables to track the state of a computation, our focus
    needs to stay on immutable objects. We can make extensive use of tuples, `typing.NamedTuples`,
    and frozen `@dataclass` to provide more complex data structures that are also
    immutable. We’ll look at these class definitions in detail in [Chapter 7](Chapter_07.xhtml#x1-1530007),
    [Complex Stateless Objects](Chapter_07.xhtml#x1-1530007).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不使用变量来跟踪计算的状态，我们的焦点需要保持在不可变对象上。我们可以大量使用元组、`typing.NamedTuples` 和冻结的 `@dataclass`
    来提供更复杂且不可变的数据结构。我们将在[第7章](Chapter_07.xhtml#x1-1530007)，[复杂无状态对象](Chapter_07.xhtml#x1-1530007)中详细查看这些类定义。
- en: The idea of immutable objects is not foreign to Python. Strings and tuples are
    two widely-used immutable objects. There can be a performance advantage to using
    immutable tuples instead of more complex mutable objects. In some cases, the benefits
    come from rethinking the algorithm to avoid the costs of object mutation.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变对象的概念对Python来说并不陌生。字符串和元组是两种广泛使用的不可变对象。使用不可变元组而不是更复杂的可变对象可能会有性能优势。在某些情况下，好处来自于重新思考算法以避免对象修改的成本。
- en: 'As an example, here’s a common design pattern that works well with immutable
    objects: the `wrapper()` function. A list of tuples is a fairly common data structure.
    We will often process this list of tuples in one of the two following ways:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这里有一个与不可变对象配合得很好的常见设计模式：`wrapper()` 函数。元组列表是一种相当常见的数据结构。我们通常会以以下两种方式之一处理这个元组列表：
- en: 'Using higher-order functions: As shown earlier, we provided a lambda as an
    argument to the `max()` function: `max(year_cheese,`` key=lambda`` yc:`` yc[1])`.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '使用高阶函数：如前所述，我们向 `max()` 函数提供了一个 lambda 作为参数：`max(year_cheese, key=lambda yc:
    yc[1])`。'
- en: 'Using the wrap-process-unwrap pattern: In a functional context, we can implement
    this with code that follows an `unwrap(process(wrap(structure)))` pattern.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用封装-处理-解封装模式：在函数式上下文中，我们可以使用遵循 `unwrap(process(wrap(structure)))` 模式的代码来实现这一点。
- en: 'For example, look at the following command snippet:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，看看以下命令片段：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This fits the three-part pattern of wrapping a data structure, finding the maximum
    of the wrapped structures, and then unwrapping the structure.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这符合封装数据结构、找到封装结构中的最大值以及然后解封装的三部分模式。
- en: The expression `map(lambda`` yc:`` (yc[1],`` yc),`` year_cheese)` will transform
    each item into a two-tuple with a key followed by the original item. In this example,
    the comparison key value is the expression `yc[1]`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '表达式 `map(lambda yc: (yc[1], yc), year_cheese)` 将每个项目转换为一个包含键和原始项目的两个元组的元组。在这个例子中，比较键值是表达式
    `yc[1]`。'
- en: The processing is done using the `max()` function. Since each piece of the source
    data has been simplified to a new two-tuple, the higher-order function features
    of the `max()` function aren’t required. To make this work, the comparison value
    was taken from position one of the source record and placed first into the two-tuple.
    The default behavior of the `max()` function uses the first item in each two-tuple
    to locate the largest value.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 处理是通过 `max()` 函数完成的。由于源数据中的每一部分都已简化为一个新的两个元组，因此 `max()` 函数的高阶函数特性不是必需的。为了使这可行，比较值是从源记录的位置一取出的，并首先放入两个元组中。`max()`
    函数的默认行为使用每个两个元组中的第一个项目来定位最大值。
- en: Finally, we unwrap using the subscript expression `[1]`. This will pick the
    second element of the two-tuple selected by the `max()` function.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用下标表达式 `[1]` 来解封装。这将选择 `max()` 函数选择的两个元组的第二个元素。
- en: 'This kind of wrap-and-unwrap is so common that some languages have special
    functions with names like `fst()` and `snd()` that we can use as function prefixes
    instead of a syntactic suffix of `[0]` or `[1]`. We can use this idea to modify
    our wrap-process-unwrap example, as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这种包装和解包的方式非常常见，以至于一些语言有名为 `fst()` 和 `snd()` 的特殊函数，我们可以用它们作为函数前缀而不是 `[0]` 或 `[1]`
    的语法后缀。我们可以用这个想法来修改我们的包装-处理-解包示例，如下所示：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, a lambda is used to define the `snd()` function to pick the second item
    from a tuple. This provides an easier-to-read version of `unwrap(process(wrap()))`.
    As with the previous example, the `map(lambda...`` ,`` year_cheese)` expression
    is used to wrap our raw data items, and the `max()` function does the processing.
    Finally, the `snd()` function extracts the second item from the tuple.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，使用lambda定义了 `snd()` 函数来从元组中选取第二个元素。这提供了一个更易于阅读的 `unwrap(process(wrap()))`
    版本。与前面的例子一样，`map(lambda...`` ,`` year_cheese)` 表达式用于包装我们的原始数据项，而 `max()` 函数进行处理。最后，`snd()`
    函数从元组中提取第二个元素。
- en: This can be simplified by using `typing.NamedTuple` or a `@dataclass`. In [Chapter 7](Chapter_07.xhtml#x1-1530007),
    [Complex Stateless Objects](Chapter_07.xhtml#x1-1530007), we’ll look at these
    two alternatives.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过使用 `typing.NamedTuple` 或 `@dataclass` 来简化。在[第7章](Chapter_07.xhtml#x1-1530007)
    [复杂无状态对象](Chapter_07.xhtml#x1-1530007)中，我们将探讨这两种替代方案。
- en: We will—as a general design principle—avoid class definitions. It can seem like
    anathema to avoid objects in an Object-Oriented Programming (OOP) language, but
    we note that functional programming doesn’t depend on stateful objects. When we
    use class definitions, we’ll avoid designs that update attribute values.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将——作为一个一般的设计原则——避免使用类定义。在面向对象编程（OOP）语言中避免对象可能看起来是一种禁忌，但我们注意到函数式编程不依赖于有状态的对象。当我们使用类定义时，我们将避免更新属性值的设计。
- en: There are a number of good reasons for using immutable objects. We can, for
    example, use an object as a named collection of attribute values. Additionally,
    callable objects can provide some optimizations, like the caching of computed
    results. Caching is important because Python doesn’t have an optimizing compiler.
    Another reason for using class definitions is to provide a namespace for closely
    related functions.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不可变对象有多个很好的理由。例如，我们可以将对象用作属性值的命名集合。此外，可调用对象可以提供一些优化，如计算结果的缓存。缓存很重要，因为Python没有优化编译器。使用类定义的另一个原因是提供一个命名空间，用于紧密相关的函数。
- en: 2.3 Strict and non-strict evaluation
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3 严格和非严格评估
- en: 'Functional programming’s efficiency stems, in part, from being able to defer
    a computation until it’s required. There are two similar concepts for avoiding
    computation. These are:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程的效率部分源于能够将计算推迟到需要时。有两个类似的概念用于避免计算。这些是：
- en: 'Strictness: Python operators are generally strict and evaluate all sub-expressions
    from left to right. This means an expression like `f(a)+f(b)+f(c)` is evaluated
    as if it was `(f(a)+f(b))+f(c)`. An optimizing compiler might avoid strict ordering
    to improve performance. Python doesn’t optimize and code is mostly strict. We’ll
    look at cases where Python is not strict below.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 严格性：Python运算符通常是严格的，并从左到右评估所有子表达式。这意味着表达式 `f(a)+f(b)+f(c)` 的评估方式就像它是 `(f(a)+f(b))+f(c)`。优化编译器可能会避免严格的顺序以提高性能。Python不进行优化，代码大多是严格的。我们将在下面探讨Python不严格的情况。
- en: 'Eagerness and laziness: Python operators are generally eager and evaluate all
    sub-expressions to compute the final answer. This means `(3-3)`` *`` f(d)` is
    fully evaluated even though the first part of the multiplication—the `(3-3)` sub-expression—is
    always zero, meaning the result is always zero, no matter what value is computed
    by the expression `f(d)`. Generator expressions are an example of Python doing
    lazy evaluation. We’ll look at an example of this in the next section, [Lazy and
    eager evaluation](#x1-400004).'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 热切与懒惰：Python运算符通常是热切的，并评估所有子表达式以计算最终答案。这意味着 `(3-3)`` *`` f(d)` 被完全评估，即使乘法的第一部分——`(3-3)`
    子表达式——始终为零，这意味着结果始终为零，无论表达式 `f(d)` 计算出什么值。生成器表达式是Python进行懒惰评估的一个例子。我们将在下一节，[懒惰和热切评估](#x1-400004)中探讨这个例子。
- en: In Python, the logical expression operators `and`, `or`, and `if-else` are all
    non-strict. We sometimes call them short-circuit operators because they don’t
    need to evaluate all arguments to determine the resulting value.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，逻辑表达式运算符 `and`、`or` 和 `if-else` 都是非严格的。我们有时称它们为短路运算符，因为它们不需要评估所有参数来确定结果值。
- en: 'The following command snippet shows the `and` operator’s non-strict feature:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令片段显示了 `and` 运算符的非严格特性：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When we execute the first of the preceding command snippets, the left-hand side
    of the `and` operator is equivalent to `False`; the right-hand side is not evaluated.
    In the second example, when the left-hand side is equivalent to `True`, the right-hand
    side is evaluated.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行前面命令片段中的第一个时，`and` 运算符的左侧等效于 `False`；右侧没有评估。在第二个例子中，当左侧等效于 `True` 时，右侧被评估。
- en: Other parts of Python are strict. Outside the logical operators, an expression
    is evaluated strictly from left to right. A sequence of statement lines is also
    evaluated strictly in order. Literal lists and tuples require strict evaluation.
    When a class is created, the methods are defined in a strict order.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的其他部分是严格的。在逻辑运算符之外，表达式严格从左到右评估。一系列语句行也严格按顺序评估。字面列表和元组需要严格评估。在创建类时，方法按严格顺序定义。
- en: 2.4 Lazy and eager evaluation
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4 惰性评估和急切评估
- en: 'Python’s generator expressions and generator functions are lazy. These expressions
    don’t create all possible results immediately. It’s difficult to see this without
    explicitly logging the details of a calculation. Here is an example of the version
    of the `range()` function that has the side effect of showing the numbers it creates:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的生成器表达式和生成器函数是惰性的。这些表达式不会立即创建所有可能的结果。如果不显式记录计算的详细信息，很难看到这一点。以下是一个具有副作用显示其创建的数字的
    `range()` 函数版本：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: To provide some debugging hints, this function prints each value as the value
    is yielded. If this function were eager, evaluating `numbers(1024)` would take
    the time (and storage) to create all 1,024 numbers. Since the `numbers()` function
    is lazy, it only creates a number as it is requested.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供一些调试提示，此函数在值产生时打印每个值。如果此函数是急切的，评估 `numbers(1024)` 将需要创建所有 1,024 个数字所需的时间（和存储空间）。由于
    `numbers()` 函数是惰性的，它仅在请求时创建一个数字。
- en: 'We can use this noisy `numbers()` function in a way that will show lazy evaluation.
    We’ll write a function that evaluates some, but not all, of the values from this
    iterator:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个嘈杂的 `numbers()` 函数以显示惰性评估的方式。我们将编写一个函数，它评估一些值，但不评估所有值从这个迭代器：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `sum_to()` function has type hints to show that it should accept an integer
    value for the `n` parameter and return an integer result. This function will not
    evaluate the entire result of the values produced by the `numbers()` function.
    It will break after only consuming a few values from the `numbers()` function.
    We can see this consumption of values in the following log:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`sum_to()` 函数有类型提示，表明它应该接受一个整数值作为 `n` 参数，并返回一个整数结果。此函数不会评估由 `numbers()` 函数产生的值的整个结果。它将在仅消耗
    `numbers()` 函数中的一些值后停止。我们可以在以下日志中看到这种值的消耗：'
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As we’ll see later, Python generator functions have some properties that make
    them a little awkward for simple functional programming. Specifically, a generator
    can only be used once in Python. We have to be cautious with how we use the lazy
    Python generator expressions.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们稍后将要看到的，Python 生成器函数有一些特性，使得它们对于简单的函数式编程来说有些笨拙。具体来说，Python 中的生成器只能使用一次。我们必须谨慎地使用惰性的
    Python 生成器表达式。
- en: 2.5 Recursion instead of an explicit loop state
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5 使用递归而不是显式循环状态
- en: Functional programs don’t rely on loops and the associated overhead of tracking
    the state of loops. Instead, functional programs try to rely on the much simpler
    approach of recursive functions. In some languages, the programs are written as
    recursions, but Tail-Call Optimization (TCO) in the compiler changes them to loops.
    We’ll introduce some recursion here and examine it closely in [Chapter 6](Chapter_06.xhtml#x1-1260006),
    [Recursions and Reductions](Chapter_06.xhtml#x1-1260006).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式程序不依赖于循环及其跟踪循环状态的关联开销。相反，函数式程序试图依赖于更简单的递归函数方法。在某些语言中，程序以递归的形式编写，但编译器中的尾调用优化（TCO）将它们转换为循环。我们将在本章介绍一些递归，并在
    [第 6 章](Chapter_06.xhtml#x1-1260006)，[递归和归约](Chapter_06.xhtml#x1-1260006) 中对其进行详细检查。
- en: 'We’ll look at an iteration to test whether a number is a prime number. Here’s
    a definition from [https://mathworld.wolfram.com/PrimeNumber.html](https://mathworld.wolfram.com/PrimeNumber.html):
    “A prime number ... is a positive integer p > 1 that has no positive integer divisors
    other than 1 and p itself.” We can create a naive and poorly performing algorithm
    to determine whether a number has any factors between 2 and the number. This is
    called the Trial Division algorithm. It has the advantage of simplicity; it works
    acceptably for solving some of the Project Euler problems. Read up on Miller-Rabin
    primality tests for a much better algorithm.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将研究一个迭代来测试一个数是否为素数。以下是从[https://mathworld.wolfram.com/PrimeNumber.html](https://mathworld.wolfram.com/PrimeNumber.html)的一个定义：“素数...是一个大于1的正整数p，它除了1和它本身外没有其他正整数除数。”我们可以创建一个简单且性能不佳的算法来确定一个数是否有介于2和该数之间的任何因子。这被称为试除法算法。它具有简单性的优点；对于解决一些欧拉计划问题来说，它的工作是可接受的。阅读有关Miller-Rabin素性测试的更多信息，以获得更好的算法。
- en: We’ll use the term coprime to mean that two numbers have only 1 as their common
    factor. The numbers 2 and 3, for example, are coprime. The numbers 6 and 9, however,
    are not coprime because they have 3 as a common factor.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用“互质”这个术语来表示两个数只有1作为它们的公因数。例如，2和3是互质的。然而，6和9不是互质的，因为它们有3作为公因数。
- en: 'If we want to know whether a number, n, is prime, we actually ask this: is
    the number n coprime to all prime numbers, p, such that p² < n? We can simplify
    this using all integers, i, such that 2 ≤ i² < n. The simplification does more
    work, but is much easier to implement.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要知道一个数n是否为素数，我们实际上会问这个问题：数n是否与所有小于n的平方的素数p互质？我们可以通过使用所有整数i，使得2 ≤ i² < n，来简化这个问题。这种简化做了更多的工作，但实现起来要容易得多。
- en: 'Sometimes, it helps to formalize this as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，将这个问题形式化如下会很有帮助：
- en: '![prime(n) = ∀x[2 ≤ x < √n-+ 1 ∧ n ⁄≡ 0 mod x ] ](img/file16.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![prime(n) = ∀x[2 ≤ x < √n-+ 1 ∧ n ≠ 0 mod x ]](img/file16.jpg)'
- en: 'The expression could look as follows in Python:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表达式在Python中可能看起来如下：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: An alternative conversion from mathematical formalism to Python would use `all(n`` %`` p`` !=`` 0,`` ...)`.
    The `all()` function will stop when it finds the first `False` value. The `not`` any()`
    will stop when it finds the first `True` value. While the results are identical,
    the performance varies depending on whether or not `p` is a prime number.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 从数学形式主义到Python的另一种转换将使用`all(n % p != 0, ...)`. 当`all()`函数找到第一个`False`值时，它将停止。`not
    any()`将在找到第一个`True`值时停止。虽然结果相同，但性能取决于`p`是否为素数。
- en: 'This expression has a `for` iteration inside it: it’s not a pure example of
    stateless functional programming. We can reframe this into a function that works
    with a collection of values. We can ask whether the number, n, is coprime within
    any value in the half-open interval [2,![√ -- n](img/file17.jpg) + 1). This uses
    the symbols [) to show a half-open interval: the lower values are included, and
    the upper value is not included. This is typical behavior of the Python `range()`
    function. We will also restrict ourselves to the domain of natural numbers. The
    square root values, for example, are implicitly truncated to integers.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表达式内部有一个`for`循环：它不是一个纯粹的无状态函数式编程的例子。我们可以将其重构为一个与值集合一起工作的函数。我们可以询问数n是否在半开区间[2,
    ![√n](img/file17.jpg) + 1)中的任何值上互质。这使用了符号[)来表示半开区间：包含下限值，但不包含上限值。这是Python `range()`函数的典型行为。我们还将限制自己只使用自然数域。例如，平方根值被隐式截断为整数。
- en: 'We can think of the definition of prime as the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将素数的定义视为以下：
- en: '![prime(n) = coprime (n,[2,√n-+ 1)) ](img/file18.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![prime(n) = coprime (n,[2,√n-+ 1))](img/file18.jpg)'
- en: given n > 1\. We know n is prime when it is coprime to all values in the range
    [2,![ -- √ n](img/file19.jpg) + 1).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 给定n > 1。我们知道当n与范围[2, ![--√n](img/file19.jpg) + 1)中的所有值互质时，n是素数。
- en: While the formal math can feel daunting, this is a search for a coprime in the
    given range of values. If we find a coprime, the value of n is not prime. If we
    fail to find a coprime, then the value of n must be prime.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然形式化的数学可能感觉令人畏惧，但这是在给定值范围内的一个互质搜索。如果我们找到一个互质数，那么n的值不是素数。如果我们未能找到互质数，那么n的值必须是素数。
- en: 'When defining a recursive search over a range of values, the base case can
    be the empty range. Searching the empty range means no values can be found. Searching
    a non-empty range is handled recursively by processing one value combined with
    a range that’s narrower by the one value processed. We could formalize it as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义一个值域的递归搜索时，基本情况可以是空值域。搜索空值域意味着找不到任何值。搜索非空值域是通过处理一个值与一个比处理过的值窄的值域递归处理的。我们可以将其形式化如下：
- en: '![ ( |||| True if a = b, { coprime (n,[a,b)) = | ( ) the range is empty |||(
    (n ⁄≡ 0 mod a )∧ coprime n, [a + 1,b) if a < b ](img/file20.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![ ( |||| True if a = b, { coprime (n,[a,b)) = | ( ) the range is empty |||(
    (n ⁄≡ 0 mod a )∧ coprime n, [a + 1,b) if a < b ](img/file20.jpg)'
- en: 'In the case where the range is non-empty, one value, a, is checked to see if
    it is coprime with n; then, the remaining values in the range [a + 1,b) are checked.
    This expression can be confirmed by providing concrete examples of the two cases,
    which are given as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在值域非空的情况下，检查一个值 a 是否与 n 互质；然后，检查值域 [a + 1,b) 中剩余的值。可以通过提供以下两种情况的具体示例来验证这个表达式：
- en: 'If the range is empty, a = b, we evaluated something like this:'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果值域为空，a = b，我们评估如下：
- en: '![ ( ) coprime 131073,[363,363) ](img/file21.jpg)'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![ ( ) coprime 131073,[363,363) ](img/file21.jpg)'
- en: 'The range contains no values, so the return is `True`. This is analogous to
    computing the sum of an empty list: the sum is zero.'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 值域不包含任何值，所以返回值是 `True`。这类似于计算空列表的总和：总和为零。
- en: 'If the range is not empty, we evaluated something like this:'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果值域不为空，我们评估如下：
- en: '![ ( ) coprime 131073,[2,363) ](img/file22.jpg)'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![ ( ) coprime 131073,[2,363) ](img/file22.jpg)'
- en: 'This decomposes into evaluating:'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这分解为评估：
- en: '![ ( ) (131073 ⁄≡ 0 mod 2)∧ coprime 131073,[3,363) ](img/file23.jpg)'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![ ( ) (131073 ⁄≡ 0 mod 2)∧ coprime 131073,[3,363) ](img/file23.jpg)'
- en: For this example, we can see that the first clause is `True`, and we’ll evaluate
    the second clause recursively. Compare this with evaluating coprime![(](img/file24.jpg)16,![[2,5)](img/file25.jpg)![)](img/file26.jpg).
    The value of 16≢0 mod 2 would be `False`; the values of 16 and 2 are not coprime.
    The evaluation of coprime![(](img/file27.jpg)131073,![[3,363)](img/file28.jpg)![)](img/file29.jpg)
    becomes irrelevant, since we know the 16 is composite.
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于这个例子，我们可以看到第一个子句是 `True`，我们将递归地评估第二个子句。将此与评估 coprime![(](img/file24.jpg)16,![[2,5)](img/file25.jpg)![)](img/file26.jpg)
    进行比较。16≢0 mod 2 的值将是 `False`；16 和 2 不是互质的。由于我们知道 16 是合数，所以 coprime![(](img/file27.jpg)131073,![[3,363)](img/file28.jpg)![)](img/file29.jpg)
    的评估变得无关紧要。
- en: As an exercise for the reader, this recursion can be redefined to count down
    instead of up, using [a,b− 1) in the second case. Try this revision to see what,
    if any, changes are required.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 作为读者的练习，这个递归可以重新定义为向下计数而不是向上，在第二种情况下使用 [a,b− 1)。尝试这个修订版，看看是否需要做出任何更改。
- en: Some folks like to define the empty interval as a ≥ b instead of a = b. The
    extra > condition is needless, since a is incremented by 1 and we can easily guarantee
    that a ≤ b, initially. There’s no way for a to somehow magically leap past b through
    some error in the function; we don’t need to over-specify the rules for an empty
    interval.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人喜欢将空区间定义为 a ≥ b 而不是 a = b。额外的 > 条件是不必要的，因为 a 会增加 1，我们可以很容易地保证最初 a ≤ b。a 通过函数中的某些错误神奇地跳过
    b 的方式是不可能的；我们不需要过度指定空区间的规则。
- en: 'Here is a Python code snippet that implements this definition of prime:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个实现这个素数定义的 Python 代码片段：
- en: '[PRE14]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This shows a recursive definition of an `iscoprime()` function. The function
    expects an `int` value for all three parameters. The type hints claim it will
    return a `bool` result.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了 `iscoprime()` 函数的递归定义。该函数期望所有三个参数都是 `int` 类型的值。类型提示表明它将返回 `bool` 类型的结果。
- en: The recursion base case is implemented as `a`` ==`` b`. When this is true, the
    range of values from `a` to one less than `b` is empty. Because the recursive
    evaluation of `iscoprime()` is the tail end of the function, this is an example
    of tail recursion.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 递归的基本情况实现为 `a`` ==`` b`。当这个条件为真时，从 `a` 到 `b` 减一的值域为空。因为 `iscoprime()` 的递归评估是函数的尾部，这是一个尾递归的例子。
- en: The `iscoprime()` function is embedded in the `isprimer()` function. The outer
    function serves to establish the boundary condition for the range of values that
    will be searched.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`iscoprime()` 函数嵌入在 `isprimer()` 函数中。外部函数的作用是为将要搜索的值域建立边界条件。'
- en: What’s important in this example is that the two cases of this recursive function
    follow the mathematical definition in a direct way. Making the range of values
    an explicit argument to the internal `iscoprime()` function allows us to call
    the function recursively with argument values that reflect a steadily shrinking
    interval.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中重要的是，这个递归函数的两个情况直接遵循数学定义。将值范围作为内部`iscoprime()`函数的显式参数允许我们使用反映不断缩小的区间的参数值递归调用该函数。
- en: 'While recursion is often succinct and expressive, we have to be cautious about
    using it in Python. There are two problems that can arise:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然递归通常简洁且表达性强，但在Python中使用递归时我们必须谨慎。可能会出现两个问题：
- en: Python imposes a recursion limit to detect recursive functions with improperly
    defined base cases.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python设置了一个递归限制，以检测定义不当的基准情况的递归函数。
- en: Python does not have a compiler that does Tail-Call Optimization (TCO) for us.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python没有为我们执行尾调用优化（TCO）的编译器。
- en: The default recursion limit is 1,000, which is adequate for many algorithms.
    It’s possible to change this with the `sys.setrecursionlimit()` function. It’s
    not wise to raise this arbitrarily since it might lead to exceeding the OS memory
    limitations and crashing the Python runtime.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的递归限制是1,000，这对于许多算法来说是足够的。可以通过`sys.setrecursionlimit()`函数来更改这个限制。随意提高这个限制是不明智的，因为它可能导致超出操作系统的内存限制并导致Python运行时崩溃。
- en: If we try a recursive `isprimer()` function on a prime number `n` over 1,000,000,
    we’ll run afoul of the recursion limit. (Folks using IPython have a higher default
    limit on the size of the stack; try `isprimer(9_000_011)` to see the problem.)
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试对一个大于1,000,000的质数`n`使用递归的`isprimer()`函数，我们将违反递归限制。（使用IPython的人有一个更高的默认栈大小限制；尝试`isprimer(9_000_011)`来查看问题。）
- en: Some functional programming languages can optimize these “tail call” recursive
    functions. An optimizing compiler will transform the recursive evaluation of the
    `iscoprime(k,`` a+1,`` b)` expression into a low-overhead `for` statement. The
    optimization tends to make debugging optimized programs more difficult. Python
    doesn’t perform this optimization. Performance and memory are sacrificed for clarity
    and simplicity. This also means we are forced to do the optimization manually.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一些函数式编程语言可以优化这些“尾递归”递归函数。优化编译器将`iscoprime(k, a+1, b)`表达式的递归评估转换为低开销的`for`语句。这种优化往往使得调试优化程序更加困难。Python不执行这种优化。性能和内存被牺牲以换取清晰和简单。这也意味着我们必须手动进行优化。
- en: This is the subject of [Chapter 6](Chapter_06.xhtml#x1-1260006), [Recursions
    and Reductions](Chapter_06.xhtml#x1-1260006). We’ll look at several examples of
    doing manual TCO.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这是[第6章](Chapter_06.xhtml#x1-1260006)，[递归与归约](Chapter_06.xhtml#x1-1260006)的主题。我们将查看几个手动进行尾递归优化的例子。
- en: 2.6 Functional type systems
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.6 函数类型系统
- en: Some functional programming languages, such as Haskell and Scala, are statically
    compiled, and depend on declared types for functions and their arguments. To provide
    the kind of flexibility Python already has, these languages have sophisticated
    type-matching rules allowing a generic function to work for a variety of related
    types.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 一些函数式编程语言，如Haskell和Scala，是静态编译的，并且依赖于声明的类型来为函数及其参数提供支持。为了提供Python已经拥有的那种灵活性，这些语言有复杂的类型匹配规则，允许泛型函数适用于多种相关类型。
- en: In object-oriented Python, we often use the class inheritance hierarchy instead
    of sophisticated function type matching. We rely on Python to dispatch an operator
    to a proper method based on simple name-matching rules.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象的Python中，我们通常使用类继承层次结构而不是复杂的函数类型匹配。我们依赖Python根据简单的名称匹配规则将操作符调度到适当的方法。
- en: Python’s built-in ”duck typing” rules offer a great deal of type flexibility.
    The more complex type matching rules for a compiled functional language aren’t
    relevant. It’s common to define a `typing.Protocol` to specify the features an
    object must have. The actual class hierarchy doesn’t matter; what matters is the
    presence of the appropriate methods and attributes.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Python的内置“鸭子类型”规则提供了大量的类型灵活性。编译函数语言的更复杂类型匹配规则并不相关。通常定义一个`typing.Protocol`来指定对象必须具有的功能。实际的类层次结构并不重要；重要的是适当的方法和属性的存在。
- en: Python’s `match` statement offers a number of structure and type matching capabilities.
    Because the `match` statement has so many alternatives, we’ll return to it several
    times. For now, we’ll provide an introductory example to show the core syntax.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的 `match` 语句提供了一系列结构和类型匹配能力。由于 `match` 语句有如此多的选择，我们将在多个地方回到它。现在，我们将提供一个介绍性示例来展示核心语法。
- en: 'Here’s an example that relies on literal matching, wildcard matching with `_`,
    and guard conditions:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个依赖于字面匹配、通配符匹配 `_` 和守卫条件的示例：
- en: '[PRE15]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: When working with a single data type, the `match` statement is not dramatically
    simpler than an `if-elif` chain. The `case`` _` blocks use the `_` pattern, which
    matches anything without binding any variables. Some of these are followed by
    additional guards, for example, `if`` n`` <`` 2`, to provide a more nuanced decision
    to these cases.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理单个数据类型时，`match` 语句并不比 `if-elif` 链明显简单。`case _` 块使用 `_` 模式，它匹配任何东西而不绑定任何变量。其中一些后面跟着额外的守卫，例如
    `if n < 2`，为这些情况提供更细微的决策。
- en: The final `case`` _:` matches any possible value not matched by any of the prior
    `case` blocks. It is analogous to the `else:` clause in an `if` statement.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的 `case _:` 匹配任何先前 `case` 块未匹配的可能值。它与 `if` 语句中的 `else:` 子句类似。
- en: The single `return` statement at the end is expected by mypy. We could rewrite
    this to use `return` statements for each case. While it would work properly, without
    a single, clear `return` it’s difficult for the mypy tool to confirm that the
    `match` statement truly covers all possible conditions.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: mypy 预期在末尾有一个单独的 `return` 语句。我们可以将其重写为为每个情况使用 `return` 语句。虽然这样会正常工作，但没有一个清晰的单独
    `return`，对于 mypy 工具来说，很难确认 `match` 语句真正覆盖了所有可能的情况。
- en: As we look at other examples, we’ll see more of the power of the pattern and
    type matching capabilities. This example matches literal values of a single type.
    The `match` statement can do quite a bit more. In later chapters, we’ll see the
    distinction between type hints, checked by a tool like mypy, and type matching
    that can be done by the `match` statement.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看其他示例时，我们将看到更多模式匹配和类型匹配能力的强大之处。这个示例匹配单个类型的字面值。`match` 语句可以做更多的事情。在后面的章节中，我们将看到由
    mypy 等工具检查的类型提示和 `match` 语句可以执行的类型匹配之间的区别。
- en: 2.7 Familiar territory
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.7 熟悉的领域
- en: One of the ideas that emerges from the previous list of topics is that many
    functional programming constructs are already present in Python. Indeed, elements
    of functional programming are already a very typical and common part of OOP.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的话题列表中浮现出的一个想法是，许多函数式编程结构已经存在于 Python 中。实际上，函数式编程的元素已经是面向对象编程中非常典型和常见的部分。
- en: 'As a very specific example, a fluent Application Program Interface (API) is
    a very clear example of functional programming. If we take time to create a class
    with `return`` self` in each method, we can use it as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个非常具体的例子，流畅的应用程序编程接口 (API) 是函数式编程的一个非常清晰的例子。如果我们花时间创建一个在每个方法中都有 `return self`
    的类，我们可以这样使用它：
- en: '[PRE16]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can just as easily write several closely related functions that work as
    follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以同样容易地编写几个紧密相关的函数，它们的工作方式如下：
- en: '[PRE17]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We’ve switched the syntax from traditional object-oriented suffix notation to
    a more functional prefix notation. Python uses both notations freely, often using
    a prefix version of a special method name. For example, the `len()` function is
    generally implemented by the `__len__()` class special method.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将语法从传统的面向对象的后缀表示法切换到了更函数式的前缀表示法。Python 可以自由地使用这两种表示法，通常使用特殊方法名的前缀版本。例如，`len()`
    函数通常是通过 `__len__()` 类特殊方法实现的。
- en: Of course, the implementation of the preceding class might involve a highly
    stateful object. Even then, a small change in viewpoint may reveal a functional
    approach that can lead to more succinct or more expressive programming.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，前面类的实现可能涉及一个高度状态化的对象。即使如此，一个小的观点改变可能会揭示一种可以导致更简洁或更丰富的编程的函数式方法。
- en: The point is not that imperative programming is broken in some way, or that
    functional programming offers a vastly superior technology. The point is that
    functional programming leads to a change in viewpoint that can, in many cases,
    be helpful for designing succinct, expressive programs.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 问题的关键不在于命令式编程在某些方面出了问题，或者函数式编程提供了一种远超技术的技术。关键在于函数式编程导致了一种观点的改变，在很多情况下，这种改变对于设计简洁、表达丰富的程序是有帮助的。
- en: 2.8 Learning some advanced concepts
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.8 学习一些高级概念
- en: We will set some more advanced concepts aside for consideration in later chapters.
    These concepts are part of the implementation of a purely functional language.
    Since Python isn’t purely functional, our hybrid approach won’t require deep consideration
    of these topics.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把一些更高级的概念放在一边，留待后续章节讨论。这些概念是纯函数式语言实现的一部分。由于Python不是纯函数式语言，我们的混合方法不需要对这些主题进行深入考虑。
- en: We will identify these here for the benefit of readers who already know a functional
    language such as Haskell and are learning Python. The underlying concerns are
    present in all programming languages, but we’ll tackle them differently in Python.
    In many cases, we can and will drop into imperative programming rather than use
    a strictly functional approach.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里确定这些内容，以供已经了解像Haskell这样的函数式语言并正在学习Python的读者参考。这些基本问题存在于所有编程语言中，但我们在Python中将以不同的方式处理它们。在许多情况下，我们可以并且会转向命令式编程，而不是严格使用函数式方法。
- en: 'The topics are as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 主题如下：
- en: 'Referential transparency: When looking at lazy evaluation and the various kinds
    of optimizations that are possible in a compiled language, the idea of multiple
    routes to the same object is important. In Python, this isn’t as important because
    there aren’t any relevant compile-time optimizations.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用透明性：在考虑惰性评估和编译语言中可能的各种优化时，到达同一对象的多个路径的概念很重要。在Python中，这并不那么重要，因为不存在相关的编译时优化。
- en: 'Currying: The type systems will employ currying to reduce multiple-argument
    functions to single-argument functions. We’ll look at currying in some depth in
    [Chapter 12](Chapter_12.xhtml#x1-25000012), [Decorator Design Techniques](Chapter_12.xhtml#x1-25000012).'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 柯里化：类型系统将使用柯里化将多参数函数减少为单参数函数。我们将在[第12章](Chapter_12.xhtml#x1-25000012)，[装饰器设计技术](Chapter_12.xhtml#x1-25000012)中深入探讨柯里化。
- en: 'Monads: These are purely functional constructs that allow us to structure a
    sequential pipeline of processing in a flexible way. In some cases, we’ll resort
    to imperative Python to achieve the same end. We’ll also leverage the elegant
    PyMonad library for this. We’ll defer this until [Chapter 13](Chapter_13.xhtml#x1-26600013),
    [The PyMonad Library](Chapter_13.xhtml#x1-26600013).'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Monads：这些是纯粹的功能性结构，允许我们以灵活的方式结构化一个顺序处理管道。在某些情况下，我们将求助于命令式Python来实现相同的目标。我们还将利用优雅的PyMonad库来完成这项工作。我们将推迟到[第13章](Chapter_13.xhtml#x1-26600013)，[PyMonad库](Chapter_13.xhtml#x1-26600013)进行讨论。
- en: 2.9 Summary
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.9 概述
- en: In this chapter, we’ve identified a number of features that characterize the
    functional programming paradigm. We started with first-class and higher-order
    functions. The idea is that a function can be an argument to a function or the
    result of a function. When functions become the object of additional programming,
    we can write some extremely flexible and generic algorithms.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们确定了一些特征，这些特征表征了函数式编程范式。我们从一等函数和高级函数开始。其理念是函数可以作为函数的参数或函数的结果。当函数成为额外编程的对象时，我们可以编写一些非常灵活和通用的算法。
- en: The idea of immutable data is sometimes odd in an imperative and object-oriented
    programming language such as Python. When we start to focus on functional programming,
    however, we see a number of ways that state changes can be confusing or unhelpful.
    Using immutable objects can be a helpful simplification.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在像Python这样的命令式和面向对象的编程语言中，不可变数据的概念有时是奇怪的。然而，当我们开始关注函数式编程时，我们会看到许多方式，这些方式可能会使状态变化变得令人困惑或无益。使用不可变对象可以是一种有用的简化。
- en: 'Python focuses on strict evaluation: all sub-expressions are evaluated from
    left to right through the statement. Python, however, does perform some non-strict
    evaluation. The `or`, `and`, and `if`-`else` logical operators are non-strict:
    all sub-expressions are not necessarily evaluated.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Python侧重于严格评估：所有子表达式都从左到右通过语句进行评估。然而，Python确实执行了一些非严格评估。`or`、`and`和`if-else`逻辑运算符是非严格的：所有子表达式不一定都会被评估。
- en: Generator functions can be described as lazy. While Python is generally eager,
    and evaluates all sub-expressions a soon as possible, we can leverage generator
    functions to create lazy evaluation. With lazy evaluation, a computation is not
    performed until it’s needed.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器函数可以被描述为惰性的。虽然Python通常是急切的，并且尽可能快地评估所有子表达式，但我们可以利用生成器函数来创建惰性评估。在惰性评估中，计算只有在需要时才会执行。
- en: While functional programming relies on recursion instead of the explicit loop
    state, Python imposes some limitations here. Because of the stack limitation and
    the lack of an optimizing compiler, we’re forced to manually optimize recursive
    functions. We’ll return to this topic in [Chapter 6](Chapter_06.xhtml#x1-1260006),
    [Recursions and Reductions](Chapter_06.xhtml#x1-1260006).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然函数式编程依赖于递归而不是显式的循环状态，但Python在这里施加了一些限制。由于堆栈限制和缺乏优化编译器，我们被迫手动优化递归函数。我们将在[第6章](Chapter_06.xhtml#x1-1260006)、[递归和归约](Chapter_06.xhtml#x1-1260006)中回到这个话题。
- en: Although many functional languages have sophisticated type systems, we’ll rely
    on Python’s dynamic type resolution. In some cases, this means we’ll have to write
    manual coercion for various types.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管许多函数式语言都有复杂的类型系统，但我们将依赖Python的动态类型解析。在某些情况下，这意味着我们可能需要为各种类型编写手动强制转换。
- en: In the next chapter, we’ll look at the core concepts of pure functions and how
    these fit in with Python’s built-in data structures. Given this foundation, we
    can look at the higher-order functions available in Python and how we can define
    our own higher-order functions.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨纯函数的核心概念以及这些概念如何与Python的内置数据结构相匹配。有了这个基础，我们可以探讨Python中可用的更高阶函数以及如何定义我们自己的更高阶函数。
- en: 2.10 Exercises
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.10 练习
- en: This chapter’s exercises are based on code available from Packt Publishing on
    GitHub. See [https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition](https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的练习基于Packt Publishing在GitHub上提供的代码。请参阅[https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition](https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition)。
- en: In some cases, the reader will notice that the code provided on GitHub includes
    partial solutions to some of the exercises. These serve as hints, allowing the
    reader to explore alternative solutions.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，读者会注意到GitHub上提供的代码包括一些练习的部分解决方案。这些作为提示，允许读者探索替代解决方案。
- en: In many cases, exercises will need unit test cases to confirm they actually
    solve the problem. These are often identical to the unit test cases already provided
    in the GitHub repository. The reader should replace the book’s example function
    name with their own solution to confirm that it works.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，练习需要单元测试用例来确认它们确实解决了问题。这些通常与GitHub存储库中已提供的单元测试用例相同。读者应将书中的示例函数名替换为自己的解决方案以确认其工作。
- en: 2.10.1 Apply map() to a sequence of values
  id: totrans-162
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.10.1 将map()应用于值序列
- en: Some analysis has revealed a consistent measurement error in a device. The machine’s
    revolutions per minute (RPM) as displayed on the tachometer are consistently incorrect.
    (Gathering the true RPM involves some heroic engineering effort, but is not a
    sustainable way to manage the machine.)
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 一些分析揭示了一个设备中一致的测量误差。转速表上显示的机器每分钟转速（RPM）是一致的错误。收集真实的RPM需要一些英勇的工程努力，但这不是管理机器的可持续方式。
- en: 'The result is a model that translates observed, o, to actual, a:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个将观察到的o转换为实际的a的模型：
- en: '![a = f (o) = 0.9× o − 90 ](img/file30.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![a = f (o) = 0.9× o − 90 ](img/file30.jpg)'
- en: The machine can only operate in the range of 800 to 2,500 RPM. Until the tachometer
    can be replaced with one that’s properly calibrated, we need a table of values
    from observed RPM to actual RPM. This can be printed and laminated and put near
    the machine to help gauge fuel consumption and workload.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 机器只能在800到2,500 RPM的范围内运行。直到转速表被替换为正确校准的转速表之前，我们需要一个从观察到的RPM到实际RPM的值表。这个值表可以打印出来，然后覆膜，并放在机器附近，以帮助测量燃油消耗和工作量。
- en: Because the tachometer can only be read to the nearest 100 RPM, the table only
    needs to show values like 800, 900, 1000, 1100, ..., 2500.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 因为转速表只能读到最近的100 RPM，所以表格只需要显示像800、900、1000、1100、...、2500这样的值。
- en: 'The output should be something like the following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该是以下类似的内容：
- en: '[PRE18]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In order to provide a flexible solution, it helps to create the following two
    separate functions:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供一个灵活的解决方案，创建以下两个独立的函数很有帮助：
- en: A function to implement the model, which computes the actual value from the
    observation
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个实现模型的函数，该函数从观察值计算实际值
- en: A function to display the table of values produced from the results of the model
    function
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于显示从模型函数结果生成的值表的函数
- en: These two–separate–functions will be used as part of the recalibration effort
    for the piece of equipment.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个独立的函数将作为该设备重新校准工作的一部分被使用。
- en: Test cases for the model can be isolated from test cases for the table of values,
    allowing new models to be used as more data is gathered.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 模型的测试用例可以与值表的测试用例分离，允许在收集更多数据时使用新的模型。
- en: While it is the topic of a later chapter, and has only been mentioned here,
    use of `map()` is encouraged, but not required.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是下一章的主题，并且在这里只被提及，但鼓励使用 `map()`，但不是必需的。
- en: 2.10.2 Function vs. lambda design question
  id: totrans-176
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.10.2 函数与 lambda 设计问题
- en: 'The model in the [Apply map() to a sequence of values](#x1-470001) problem
    is a small function, only about one line of code. Here are three different ways
    this can be written:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [将 map() 应用到值序列](#x1-470001) 问题中的模型是一个小函数，只有大约一行代码。这里有三种不同的方式可以编写它：
- en: As a proper `def` function.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为正确的 `def` 函数。
- en: As a lambda object.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为 lambda 对象。
- en: As a class definition that implements the `__call__()` method.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为实现 `__call__()` 方法的类定义。
- en: Create all three implementations. Compare and contrast them with respect to
    ease of understanding. Defend one as being ideal by (a) providing some criteria
    for software quality and (b) showing how the implementation meets those criteria.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 创建所有三种实现。比较和对比它们在理解上的难易程度。通过（a）提供一些软件质量标准，以及（b）展示实现如何满足这些标准，来捍卫其中一种实现是理想的。
- en: 2.10.3 Optimize a recursion
  id: totrans-182
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.10.3 优化递归
- en: See [Recursion instead of an explicit loop state](#x1-410005) earlier in this
    chapter.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 参见本章前面的 [递归而不是显式循环状态](#x1-410005)。
- en: As an exercise for the reader, this recursion can be redefined to count down
    instead of up, using [a,b − 1) in the second case. Implement this change to see
    what, if any, changes are required. Measure the performance to see if there is
    any performance consequence.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对读者的练习，这个递归可以被重新定义为向下计数而不是向上，在第二种情况下使用 [a,b − 1)。实现这个更改以查看是否需要任何更改。测量性能以查看是否有任何性能影响。
- en: Join our community Discord space
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加入我们的社区 Discord 空间
- en: 'Join our Python Discord workspace to discuss and know more about the book:
    [https://packt.link/dHrHU](https://packt.link/dHrHU)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的 Python Discord 工作空间，讨论并了解更多关于这本书的信息：[https://packt.link/dHrHU](https://packt.link/dHrHU)
- en: '![PIC](img/file1.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file1.png)'
