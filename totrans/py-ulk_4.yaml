- en: Chapter 4. Data Structures and Algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Data structures are the building blocks to solve programming problems. They
    provide organization for the data, and algorithms provide the logic to carve the
    perfect solution. Python provides many efficient built-in data structures that
    can be used effectively. There are other good data-structure implementations in
    the standard library as well as third-party libraries. Often, the more pressing
    question is when to use what, or what data-structure is good for the present problem
    description. To resolve this, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Python data structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python library data structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Third-party data structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Algorithms on scale
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python built-in data structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Key 1: Understanding Python''s in-built data structure.**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before going in on how to use different data structures, we should take a look
    at the attributes of the object that are important for built-in data structures.
    For the default sorting to work, the object should have one of the `__lt__`, and
    `__gt__` methods defined. Otherwise, we can pass a key function to the sorting
    method to use in getting the intermediate keys that are used to compare it, as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Whether two objects are equal in value is defined by the output of the `__eq__`
    method. Collections have the same value if they have the same length and the same
    value of all items, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Hash function maps a larger value set to the smaller hash set. Hence, two different
    objects can have the same hash, but objects with a different hash must be different.
    In other words, equal value objects should have the same hash, and objects with
    a different hash must have different values for hash to be meaningful. When we
    define `__eq__` in a class, we must define a hash function as well. By default,
    for user class instances, hash uses the ID of the object, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'It can be seen that mutable objects do not have hash defined. Although this
    is not advised, we can, however, do so in our user defined classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tuples**: These are immutable lists, slice operations are *O(n)*, retrieval
    is *O(n)*, and they have small memory requirements. They are normally used to
    group objects of different types in a single structure, such as C language structures,
    where the position is fixed for particular types of information, shown as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Named tuples that are available from the collections module can be used to
    access values with object notation, as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Lists** : These are mutable data structures that are similar to tuples. They
    are good to collect objects of similar types. When analyzing their time-complexity,
    we see that insert, delete, slice, and copy operations require *O(n)*, Retrieval
    require len *O(1)*, and sort requires *O(nlogn)*. Lists are implemented as dynamic
    arrays. It must resize to double of its previous on increase in size greater than
    current capacity. Insert and delete at the front of the list takes more time as
    it must move all references to other elements one by one:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Dictionary**: These are mutable mappings. A key can be any hashable object.
    Getting a value for key, setting a value for a key, and deleting a key are all
    *O(1)*, and copying is *O(n)*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Sets**: These can be thought as of groups of items where hash is used to
    retrieve items. Sets have methods to check union, and intersection, which is useful
    rather than checking the same with lists. Let''s take an example of groups of
    animals, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Their implementation and time-complexity is very similar to dictionary, shown
    as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Python library data structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Key 2: Using Python''s** **standard library data structures.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**collections.deque**: The collections module have a `deque` implementation.
    Deque is useful for the scenarios where item insertion and deletion occurs at
    both ends of structure as it has efficient inserts at the start of structure as
    well. Time-complexity is similar to copy *O(n)*, insert—*O(1)*, and delete—*O(n)*.
    The following graph shows an insert at 0 position operation comparison between
    list and deque:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following image is the graphical representation of the preceding code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Python library data structures](img/B04885_04_02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**PriorityQueue**: A standard library queue module has implementations for
    multiproducer, and multiconsumer queues. We can simplify and reuse its `PriorityQueue`
    for simpler cases using the `heapq` module, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Other than these, queue modules have `threadsafe`, `LifoQueue`, `PriorityQueue`,
    `queue`, `deque` implementations. Also, lists can be used as stacks or queues.
    Collections also have `orderedDict`, which remembers the sequence of elements.
  prefs: []
  type: TYPE_NORMAL
- en: Third party data structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Key 3: Using third-party data structures.**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Python has a good bunch of data structures in the core language/library. But
    sometimes, an application has very specific requirements. We can always use third-party
    data-structure packages. Most of such modules are Python wrapper over C, C++ implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: The `blist` module provides a drop-in replacement for list, `sortedList`, and
    `sortedset`. It is discussed in greater detail in later chapters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `bintrees` module provides binary, AVL tree, and Red-Black trees.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `banyan` module provides Red-Black trees, splay tree, and sorted lists.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Sortedcontainers` module provides `SortedList`, `SortedDict`, and `SortedSet`.
    So, one can get almost every data structure for Python easily. More stress should
    be given on why one data structure is better than another for a use case.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrays/List
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For numeric calculations involving math, NumPy arrays should be considered.
    They are fast, memory-efficient, and provide many vector and matrix operations.
  prefs: []
  type: TYPE_NORMAL
- en: Binary tree
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Trees have better worst-case insertion/removal, *O(log(n))*, min/max, and look-ups
    than dictionaries. There are several implementations that are available.
  prefs: []
  type: TYPE_NORMAL
- en: 'One module is `bintrees`, which have C implementations that are available for
    Red-Black trees, AVL tree, and Binary trees. For example, in Red-Black trees,
    it is easy to find max, and min, ranges as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Sorted containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'These are pure-Python modules having `SortedList`, `SortedSet`, and `SortedDict`
    Data structures, which can keep the keys/items sorted. The `SortedContainers`
    module claims to have speed comparable to C extensions modules, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Trie
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is an ordered-tree data-structure, where the position in the tree defines
    the key. The keys are normally strings. In comparison to dictionaries, it has
    faster worst-case data retrieval *O(m)*. Hash functions are not needed. If we
    are using strings only to be stored in the keys, it can take a lot less space
    then dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: '![Trie](img/B04885_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In Python, we have the `marisa-trie` package that provides this functionality
    as static Data structures. It is a Cython wrapper over the C++ library. We can
    associate values with the keys as well. It also provides memory mapped I/O, which
    is useful to decrease memory usage on cost of speed. The `datrie` is another package
    that provides read-write tries, The following are some basic usage of these libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Algorithms on scale
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Key 4: Thinking out-of-the-box for the algorithms.**'
  prefs: []
  type: TYPE_NORMAL
- en: 'An algorithm is how we solve a problem. The most common issue of not being
    able to solve the problem is to not being able to define it properly. Normally,
    we look to apply an algorithm only at a small level, such as in a small functionality,
    or sorting in a function. We, however, do not think about algorithms when the
    scale increases, mostly the stress is on how fast it is. Let''s take a simple
    requirement of sorting a file and sending it to a user. If the file is, let''s
    say 10-20 KB or so, it will be best to simply use the Python sorted function to
    sort the entries. In the following code, the file is of format where columns are
    ID, name, due, and due-date. We want to sort it based on dues, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This works great, but as the file increases in size, the memory requirement
    increases. We cannot load all contents in the memory at the same time. Hence,
    we can use external merge-sort to divide the file into small parts, sort them,
    and then merge the sorted results together. In the following code, we used `heapq.merge`
    to merge iterators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we use up memory of a single computer, or have files distributed over
    multiple computers in a network, the file-based algorithm will not work. We will
    need to sort incoming streams from upstream servers, and send the sorted stream
    to the downstream. If we look at the following code carefully, we will see that
    we have not changed the underlying mechanism. We are still using `heapq.merge`
    to merge elements, but now, we are getting elements from the network instead.
    The following client code is simple, it just starts sending sorted lines by lines
    on receive of the next command from a downstream server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In the server code, the `ClientConn` class abstracts away network operations
    and provides an iterator interface to `heapq.merge`. We can greatly enhance the
    code using buffering. Here, the `get_next` method gets new line from the client.
    Simple abstraction solved a great problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the data structures that are available in
    the Python standard library and some third-party libraries, which are extremely
    useful for everyday programming. Knowledge of data-structure usage is very much
    important in choosing right tool for the job. Choosing of an algorithm is highly
    application-specific, and we should always try to find out a solution that is
    simpler to read.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover design patterns that provide great help in
    writing elegant solutions to the problems.
  prefs: []
  type: TYPE_NORMAL
