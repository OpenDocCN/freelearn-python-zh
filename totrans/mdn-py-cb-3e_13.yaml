- en: '13'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Application Integration: Configuration'
  prefs: []
  type: TYPE_NORMAL
- en: 'Python’s concept of an extensible library gives us rich access to numerous
    computing resources. The language provides avenues to make even more resources
    available. This makes Python programs particularly strong at integrating components
    to create sophisticated composite processing. In this chapter, we’ll address the
    fundamentals of creating complex applications: managing configuration files, logging,
    and a design pattern for scripts that permits automated testing.'
  prefs: []
  type: TYPE_NORMAL
- en: These new recipes leverage ideas shown in recipes in other chapters. Specifically,
    in the [Using argparse to get command-line input](ch010.xhtml#x1-3490004), [Using
    cmd to create command-line applications](ch010.xhtml#x1-3610006), and [Using the
    OS environment settings](ch010.xhtml#x1-3670007) recipes in Chapter [6](ch010.xhtml#x1-3300006),
    some specific techniques for creating top-level (main) application scripts were
    shown. It may help to review those recipes to see examples of Python application
    scripts. In Chapter [11](ch015_split_000.xhtml#x1-61500011), we looked at filesystem
    input and output.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll look at a number of ways to handle configuration files.
    There are many file formats that can be used to store long-term configuration
    information:'
  prefs: []
  type: TYPE_NORMAL
- en: The INI file format as processed by the configparser module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The TOML file format is very easy to work with but requires an add-on module
    that’s not currently part of the Python distribution. We’ll look at this in the
    [Using TOML for configuration files](ch017.xhtml#x1-7230002) recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The properties file format is typical of Java programming and can be handled
    in Python without writing too much code. Some of the syntax overlaps with Python
    scripts and TOML files. A switch from the properties file format to TOML only
    requires changing any name: value to name = "value", permitting use of the TOML
    parser.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For Python scripts, a file with assignment statements looks a lot like a properties
    file, and is very easy to process using the compile() and exec() functions. We’ll
    look at this in the [Using Python for configuration files](ch017.xhtml#x1-7290003)
    recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Python module with class definitions is a variation that uses Python syntax
    but isolates the settings into separate classes. This can be processed with the
    import statement. We’ll look at this in the [Using a class as a namespace for
    configuration](ch017.xhtml#x1-7350004) recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some recipes in this chapter will extend some of the concepts from Chapter [7](ch011_split_000.xhtml#x1-3760007),
    and Chapter [8](ch012.xhtml#x1-4520008). This chapter will apply those concepts
    to defining configuration files using classes.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to consider the kinds of information required in configuration
    files. Carelessly including passwords or security tokens in a configuration file
    can be fatal to secure use of data. Including personal information in a configuration
    file is also a common security weakness. See the [Common Weakness Enumeration](https://cwe.mitre.org/index.html)
    for other more specific issues with poorly designed configuration files.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll look at the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Finding configuration files](ch017.xhtml#x1-7160001)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Using TOML for configuration files](ch017.xhtml#x1-7230002)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Using Python for configuration files](ch017.xhtml#x1-7290003)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Using a class as a namespace for configuration](ch017.xhtml#x1-7350004)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Designing scripts for composition](ch017.xhtml#x1-7410005)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Using logging for control and audit output](ch017.xhtml#x1-7470006)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll start with a recipe for handling multiple configuration files that must
    be combined. This gives users some helpful flexibility. From there, we can dive
    into the specifics of a few of the common configuration file formats.
  prefs: []
  type: TYPE_NORMAL
- en: 13.1 Finding configuration files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many applications will have a hierarchy of configuration options. The foundation
    of the hierarchy is often the default values built into the application. These
    might be supplemented by server-wide (or cluster-wide) values from centralized
    configuration files. There might also be user-specific files, or perhaps even
    configuration files provided when starting a program.
  prefs: []
  type: TYPE_NORMAL
- en: In many cases, configuration parameters are written in text files, so they are
    persistent and easy to change. The common tradition in Linux is to put system-wide
    configuration in the /etc directory. A user’s personal changes would be in their
    home directory, often named ~username or $HOME.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we’ll see how an application can support a rich hierarchy of
    locations for configuration files.
  prefs: []
  type: TYPE_NORMAL
- en: 13.1.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The example we’ll use is an application to simulate dice rolling. The application
    is shown in several recipes throughout Chapter [6](ch010.xhtml#x1-3300006). Specifically,
    look at [Using argparse to get command-line input](ch010.xhtml#x1-3490004) and
    [Using cmd to create command-line applications](ch010.xhtml#x1-3610006).
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll follow the design pattern of the Bash shell, which looks for configuration
    files in the following places:'
  prefs: []
  type: TYPE_NORMAL
- en: It starts with the /etc/profile file, applicable to everyone using the system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After reading that file, it looks for one of these files, in this order:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: ~/.bash_profile
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: ~/.bash_login
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: ~/.profile
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Other shells, like zsh, use some additional files but follow this pattern of
    working through a sequence of files in order.
  prefs: []
  type: TYPE_NORMAL
- en: In a POSIX-compliant operating system, the shell expands the ~ to be the home
    directory for the logged-in user. In general, the Python pathlib module handles
    this for Windows, Linux, and macOS automatically via the Path.home() method.
  prefs: []
  type: TYPE_NORMAL
- en: In later recipes, we’ll look at ways to parse and process specific formats of
    configuration files. For the purposes of this recipe, we won’t pick a specific
    format. Instead, we’ll assume that an existing function, load_config_file(), has
    been defined that will load a specific configuration mapping from the contents
    of the configuration files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We’ll look at a number of different ways to implement this function.
  prefs: []
  type: TYPE_NORMAL
- en: Why so many choices?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There’s a side topic that sometimes arises when discussing this kind of design
    – why have so many choices? Why not specify exactly one place?
  prefs: []
  type: TYPE_NORMAL
- en: It’s common to offer variations typical for one distribution, but atypical for
    another. Also, user expectations depend on software with which they’re already
    familiar; this is very difficult to anticipate. And, of course, when dealing with
    Windows, there will be the possibility of yet more variant file paths that are
    unique to that platform. For these reasons, it’s easier to offer multiple locations
    and permit the user or administrator to pick the one they prefer.
  prefs: []
  type: TYPE_NORMAL
- en: 13.1.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll make use of the pathlib module to provide a handy way to work with files
    in various locations. We’ll also use the collections module to provide the very
    useful ChainMap class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the Path class and the ChainMap class. There are several type hints
    that are also required:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define an overall function to get the configuration files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create paths for the various locations of the configuration files. These are
    called pure paths and start with the names of potential files. We can decompose
    these locations into a system path and a sequence of local paths. Here are the
    two assignment statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the application’s built-in defaults as a list of dictionaries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Each individual configuration file is a mapping from keys to values. Each of
    these mapping objects is combined to form a list; this becomes the final ChainMap
    configuration mapping.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If the system-wide configuration file exists, load this file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Iterate through other locations looking for a file to load. This loads the
    first file that it finds and uses a break statement to stop after the first file
    is found:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Reverse the list and create the final ChainMap mapping:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The list needs to be reversed so that the local file (appended last) is searched
    first, then the system settings, and finally the application default settings.
    It’s certainly possible to assemble the list in the reverse order to avoid the
    reversed() function; we’ve left this possible change as an exercise for you.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once we’ve built the configuration object, we can use the final configuration
    like a simple mapping. This object supports all of the expected dictionary operations.
  prefs: []
  type: TYPE_NORMAL
- en: 13.1.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the [Creating dictionaries – inserting and updating](ch009.xhtml#x1-2900001)
    recipe in Chapter [5](ch009.xhtml#x1-2890005), we looked at the basics of using
    a dictionary. Here, we’ve combined several dictionaries into a chain. When a key
    is not located in the first dictionary of the chain, then later dictionaries in
    the chain are checked. This is a handy way to provide default values for each
    key in the mapping. Because the ChainMap is nearly indistinguishable from the
    built-in dict class, it permits a lot of flexibility in the implementation details:
    any kind of configuration file that can be read to create a dictionary is perfectly
    acceptable. The rest of the application can be based on the dictionary without
    being exposed to the details of how the configuration was built.'
  prefs: []
  type: TYPE_NORMAL
- en: 13.1.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The subtle distinction between the single system-wide configuration file and
    the collection of alternative names for the local configuration files isn’t ideal.
    This distinction between a singleton and a list of choices doesn’t seem to serve
    any particular purpose. Often, we want to extend this design and the tiny asymmetry
    leads to complications.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll consider changing the configuration to have the following four tiers:'
  prefs: []
  type: TYPE_NORMAL
- en: The built-in defaults.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A host-wide configuration in a central directory like /etc or /opt. This is
    often used for details of the OS or network context for this container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A home directory configuration for the user running the app. This may be used
    for distinguishing test and production instances.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A local file in the current working directory. This may be used by a developer
    or tester.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This suggests a modification to the recipe to use nested lists of paths. The
    outer list contains all of the tiers of configuration. Within each tier, a list
    will contain the alternative locations for a configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This list[list[Path]] structure provides three tiers of configuration files.
    Each of the tiers has a number of alternative names. The order of the tiers and
    the names within each tier are important. The lower tiers provide overrides to
    the upper tiers. We can then use nested for statements to examine all of the alternative
    locations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We’ve factored out the default configuration into a global variable with the
    name DEFAULT_CONFIGURATION. We have conspicuously left the collection of configuration
    paths with the name config_paths. It’s not perfectly clear if this should be global
    (and have a global variable name in ALL-CAPITALS) or if this should be part of
    the get_config() function. We’ve adopted a bit of both by using a lowercase name
    and putting it outside the function.
  prefs: []
  type: TYPE_NORMAL
- en: The value of config_paths is unlikely to be needed elsewhere, making it a bad
    choice for being a global variable. It is, however, something that may change
    – perhaps in the next major release – and deserves to be exposed so it can be
    changed.
  prefs: []
  type: TYPE_NORMAL
- en: 13.1.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the [Using TOML for configuration files](ch017.xhtml#x1-7230002) and [Using
    Python for configuration files](ch017.xhtml#x1-7290003) recipes in this chapter,
    we’ll look at ways to implement the load_config_file() function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the [Mocking external resources](ch019_split_001.xhtml#x1-85500010) recipe
    in Chapter [15](ch019_split_000.xhtml#x1-79400015), we look at ways to test functions
    such as this, which interact with external resources.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The pathlib module is central to this processing. This module provides the Path
    class definition, which provides a great deal of sophisticated information about
    the OS’s files. For more information, see the [Using pathlib to work with filenames](ch015_split_000.xhtml#x1-6160001)
    recipe in Chapter [11](ch015_split_000.xhtml#x1-61500011).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 13.2 Using TOML for configuration files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python offers a variety of ways to package application inputs and configuration
    files. We’ll look at writing files in TOML notation because this format is elegant
    and simple. For more information on this format, see [https://toml.io/en/](https://toml.io/en/).
  prefs: []
  type: TYPE_NORMAL
- en: Most TOML files look quite a bit like INI-format files. This overlap is intentional.
    When parsed in Python, a TOML file will be a nested dictionary structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'We might have a file like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This will become a dictionary like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The [some_app.feature] is called a ”table”. The use of a . in the key creates
    a nested table.
  prefs: []
  type: TYPE_NORMAL
- en: 13.2.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll often use the [Finding configuration files](ch017.xhtml#x1-7160001) recipe,
    shown earlier in this chapter, to check a variety of locations for a given configuration
    file. This flexibility is often essential for creating an application that’s easy
    to use on a variety of platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we’ll build the missing part of the [Finding configuration
    files](ch017.xhtml#x1-7160001) recipe, the load_config_file() function. Here’s
    the template that needs to be filled in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this recipe, we’ll fill in the space held by the Details omitted line to
    load configuration files in TOML format.
  prefs: []
  type: TYPE_NORMAL
- en: 13.2.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe will make use of the tomllib module to parse a YAML-TOML file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the tomllib module along with the Path definition and the type hints
    required by the load_config_file() function definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the tomllib.load() function to load the TOML-syntax document:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: An unusual requirement of TOML parsing in Python requires us to open the file
    in ”binary” mode when using the load() function. We can use ’rb’ as the mode to
    be explicit that the file is opened for reading.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The alternative is to use the loads() function on a block of text. It looks
    like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This load_config_file() function produced the required dictionary structure.
    It can be fit into the design from the [Finding configuration files](ch017.xhtml#x1-7160001)
    recipe to load a configuration file using TOML syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 13.2.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As noted above, the idea of TOML syntax is to be easy to read and map directly
    to a Python dictionary. There is some intentional overlap between TOML notation
    and INI file syntax. There is also some overlap with some aspects of property
    file syntax.
  prefs: []
  type: TYPE_NORMAL
- en: The core of TOML syntax is key-value pairings generally written as key = value.
    The keys include valid Python symbols. This means that any sort of dataclass or
    Pydantic structure with a dictionary mapping can be mapped into TOML syntax, too.
  prefs: []
  type: TYPE_NORMAL
- en: It’s valid for a TOML key to have a hyphen, which is not part of allowed Python
    names. A key can be a quoted string, too. This permits quite a wide variety of
    alternative keys. These features may need some caution depending on ultimate use
    for the configuration dictionary objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'A key can also be dotted; this will create sub-dictionaries. Here’s an example
    of dotted keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This looks quite a bit like a properties file often used with Java applications.
    This creates nested dictionaries by decomposing the keys at the . character.
  prefs: []
  type: TYPE_NORMAL
- en: A wide variety of values are available, including string values, integer values,
    float values, and Boolean values (using true and false as the literal values).
    Additionally, TOML recognizes ISO date-time strings; see [RFC 3339](https://tools.ietf.org/html/rfc3339)
    for the formats supported.
  prefs: []
  type: TYPE_NORMAL
- en: 'TOML permits two data structures:'
  prefs: []
  type: TYPE_NORMAL
- en: An array is enclosed in [ and ]. We can use sizes = [1, 2, 3] to create a Python
    list value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An in-line table can be created using { and } around one or more key = value
    items. For example, sample = {x = 10, y = 8.4} creates a nested dict value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'One of the most important features of TOML syntax is using [table] as the key
    for a nested dictionary. We’ll often see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The [some_app] is a key for a dictionary containing the indented key-value pairs.
    TOML syntax of [some_app.feature] defines a more deeply nested dictionary. The
    use of a dotted key means the string "some_app" will be a key for a dictionary
    containing the key feature. The value associated with this key will be a dictionary
    with the key "option_1". In TOML the [table] prefix for nested values creates
    a visual organization, making it easier to find and change configuration settings.
  prefs: []
  type: TYPE_NORMAL
- en: 13.2.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'TOML notation is used for a the overall pyproject.toml file that can be used
    to describe a Python project. This file often has two top-level tables: [project]
    and [build-system]. The project table will have some metadata about the [project].
    Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The [build-system] table provides information on tools needed to install the
    module, package, or application. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This file provides a few essential pieces of information about the project.
    The use of TOML notation makes it relatively easy to read and change.
  prefs: []
  type: TYPE_NORMAL
- en: 13.2.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the [Finding configuration files](ch017.xhtml#x1-7160001) recipe earlier
    in this chapter to see how to search multiple filesystem locations for a configuration
    file. We can easily have application defaults, system-wide settings, and personal
    settings built into separate files and combined by an application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information on TOML syntax, see [https://toml.io/en/](https://toml.io/en/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information on the pyproject.toml file, see the Python Packaging Authority
    document [https://pip.pypa.io/en/stable/reference/build-system/pyproject-toml/](https://pip.pypa.io/en/stable/reference/build-system/pyproject-toml/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 13.3 Using Python for configuration files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to syntax like TOML for providing configuration data, we can also
    write files in Python notation; it’s elegant and simple. It offers tremendous
    flexibility, since the configuration file is a Python module.
  prefs: []
  type: TYPE_NORMAL
- en: 13.3.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python assignment statements are particularly elegant for creating configuration
    files. The syntax can be simple, easy to read, and extremely flexible. If we use
    assignment statements, we can import an application’s configuration details from
    a separate module. This could have a name like settings.py to show the module’s
    focus on configuration parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Because Python treats each imported module as a global Singleton object, we
    can have several parts of an application all use an import settings statement
    to get a consistent view of the current, global application configuration parameters.
    We don’t need to worry about managing an object using the Singleton design pattern,
    since that’s already part of Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’d like to be able to provide definitions in a text file that look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This configuration is a Python script. The parameters include two variables,
    query and base_url. The value of the query variable is a dictionary with a single
    key, ’mz’, and a sequence of values.
  prefs: []
  type: TYPE_NORMAL
- en: This can be seen as a specification for a number of related URLs that are all
    similar to [http://forecast.weather.gov/shmrn.php?mz=ANZ532](http://forecast.weather.gov/shmrn.php?mz=ANZ532).
  prefs: []
  type: TYPE_NORMAL
- en: We’ll often use the [Finding configuration files](ch017.xhtml#x1-7160001) recipe
    to check a variety of locations for a given configuration file. This flexibility
    is often essential for creating an application that’s easily used on a variety
    of platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we’ll build the missing part of the [Finding configuration
    files](ch017.xhtml#x1-7160001) recipe, the load_config_file() function. Here’s
    the template that needs to be filled in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In this recipe, we’ll fill in the space held by the # Details omitted line
    to load configuration files in Python format.'
  prefs: []
  type: TYPE_NORMAL
- en: 13.3.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can make use of the pathlib module to locate the files. We’ll also leverage
    the built-in compile() and exec() functions to process the code in the configuration
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the Path definition and the type hints required by the load_config_file()
    function definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the built-in compile() function to compile the Python module into an executable
    form. This function requires the source text as well as the filename from which
    the text was read. The filename is essential for creating trace-back messages
    that are useful and correct:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In rare cases where the code doesn’t come from a file, the general practice
    is to provide a name such as <string> for the filename.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Execute the code object created by the compile() function. This requires two
    contexts. The global context provides any previously imported modules, plus the
    __builtins__ module. The local context is the locals dictionary; this is where
    new variables will be created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This load_config_file() function produces the required dictionary structure.
    It can be fit into the design from the [Finding configuration files](ch017.xhtml#x1-7160001)
    recipe to load a configuration file using Python syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 13.3.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The details of the Python language – the syntax and semantics – are embodied
    in the built-in compile() and exec() functions. The three essential steps are
    these:'
  prefs: []
  type: TYPE_NORMAL
- en: Read the text.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compile the text with the compile() function to create a code object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the exec() function to execute the code object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The exec() function reflects the way Python handles global and local variables.
    There are two namespaces (mappings) provided to this function. These are visible
    via the globals() and locals() functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can provide two distinct dictionaries to the exec() function:'
  prefs: []
  type: TYPE_NORMAL
- en: A dictionary of global objects. The most common use is to provide access to
    the imported modules, which are always global. The __builtins__ module can be
    provided in this dictionary. In some cases, other modules like pathlib should
    be added.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A dictionary for the locals that will be created (or updated) by each assignment
    statement. This local dictionary allows us to capture the variables created when
    executing the settings module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The locals dictionary will be updated by the exec() function. We don’t expect
    the globals to be updated and will ignore any changes that happen to this collection.
  prefs: []
  type: TYPE_NORMAL
- en: 13.3.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe suggests a configuration file is entirely a sequence of name = value
    assignment statements. The assignment statement is in Python syntax, as are the
    variable names and the literal syntax. This permits the configuration to leverage
    Python’s large collection of built-in types. Additionally, the full spectrum of
    Python statements is available. This leads to some engineering trade-offs.
  prefs: []
  type: TYPE_NORMAL
- en: Because any statement can be used in the configuration file, it can lead to
    complexity. If the processing in the configuration file becomes too complex, the
    file ceases to be configuration and becomes a first-class part of the application.
    Very complex features should be implemented by modifying the application programming,
    not hacking around with the configuration settings. Python applications include
    the full source, as it is generally easier to fix the source than create hyper-complex
    configuration files. The goal is for a configuration file to provide values to
    tailor operations, not provide plug-in functionality.
  prefs: []
  type: TYPE_NORMAL
- en: We might want to include the OS environment variables as part of the global
    variables used for configuration. Doing this helps ensure the configuration values
    match the current environment settings. This can be done with the os.environ mapping.
  prefs: []
  type: TYPE_NORMAL
- en: 'It can also be sensible to do some processing for related settings. For example,
    it can be helpful to write a configuration file with a number of adjacent paths
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In many cases, the settings file is edited by a person who can be trusted. Mistakes
    do happen, though, and it’s wise to be careful about what functions are available
    in the dictionary of globals provided to the exec() function. Providing the narrowest
    set of functions to support configuration is the recommended practice.
  prefs: []
  type: TYPE_NORMAL
- en: 13.3.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the [Finding configuration files](ch017.xhtml#x1-7160001) recipe earlier
    in this chapter to learn how to search multiple filesystem locations for a configuration
    file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 13.4 Using a class as a namespace for configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python offers a variety of ways to package application inputs and configuration
    files. We’ll continue to look at writing files in Python notation because it’s
    elegant and the familiar syntax can lead to easy-to-read configuration files.
    A number of projects allow us to use a class definition to provide configuration
    parameters. This uses Python syntax, of course. It also uses the class definition
    as a namespace to allow multiple configurations to be provided in a single module.
    The use of a class hierarchy means that inheritance techniques can be used to
    simplify the organization of parameters.
  prefs: []
  type: TYPE_NORMAL
- en: This avoids the use of a ChainMap to permit user-specific overrides of generic
    settings. Instead, this uses ordinary inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: We’re never going to create instances of these classes. We’re going to use the
    attributes of the class definition and rely on class inheritance methods to track
    down the appropriate value for an attribute. This will differ from the other recipes
    in this chapter because it will produce a ConfigClass object, instead of a dict[str, Any]
    object.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we’ll look at how we can represent configuration details in
    Python class notation.
  prefs: []
  type: TYPE_NORMAL
- en: 13.4.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python notation for defining the attributes of a class can be simple, easy to
    read, and reasonably flexible. We can, with a little work, define a sophisticated
    configuration language that allows someone to change configuration parameters
    for a Python application quickly and reliably.
  prefs: []
  type: TYPE_NORMAL
- en: We can base this language on class definitions. This allows us to package a
    number of configuration alternatives in a single module. An application can load
    the module and pick the relevant class definition from the module.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’d like to be able to provide definitions that look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We can create this class definition in a settings.py file to create a settings
    module. To use the configuration, the main application could do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The application will gather the settings using the module name of settings with
    a class name of Configuration.
  prefs: []
  type: TYPE_NORMAL
- en: The configuration file locations follow Python’s rules for finding modules.
    Rather than implementing our own search for the configuration, we can leverage
    Python’s built-in search of sys.path, and the use of the PYTHONPATH environment
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we’ll build a missing part that’s similar to the [Finding configuration
    files](ch017.xhtml#x1-7160001) recipe, the load_config_file() function. However,
    there will be an important difference: we’ll return an object instead of a dictionary.
    We can then refer to configuration values by attribute name instead of using the
    more cumbersome notation of a dictionary. Here’s the revised template that needs
    to be filled in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We’ve used a similar template in a number of recipes in this chapter. For this
    recipe, we’ve added a parameter to this definition and changed the return type.
    The classname parameter is not present in previous recipes, but it is used here
    to select one of the classes from a module at the location in the filesystem named
    by the config_path parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 13.4.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can make use of the pathlib module to locate the files. We’ll leverage the
    built-in compile() and exec() functions to process the code in the configuration
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the Path definition and the type hints required by the load_config_file()
    function definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the built-in compile() function to compile the Python module into an executable
    form. This function requires the source text as well as a filename from which
    the text was read. The filename is essential for creating trace-back messages
    that are useful and correct:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Execute the code object created by the compile() method. We need to provide
    two contexts. The global context can provide the __builtins__ module, plus the
    Path class and the platform module. The local context is where new variables will
    be created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This locates the named class in the locals() mapping and returns the class as
    the configuration object. This does not return a dictionary.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This variation on the load_config_file() function produces a useful structure
    that can be accessed using attribute names. It does not provide the design expected
    by the [Finding configuration files](ch017.xhtml#x1-7160001) recipe. The resulting
    configuration object does – because it uses attribute names – more useful than
    a simple dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 13.4.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can load a Python module by using compile() and exec(). From the module,
    we can extract an individual class name that contains the various application
    settings. Overall, it looks like the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We can put any kind of object into the attributes of the configuration class.
    Our example showed lists of strings and strings. Any object of any class becomes
    a possibility when using class definitions.
  prefs: []
  type: TYPE_NORMAL
- en: We can have complex calculations within the class statement. We can use this
    to create attributes that are derived from other attributes. We can execute any
    kind of statement, including if statements and for statements, to create attribute
    values.
  prefs: []
  type: TYPE_NORMAL
- en: We will not, however, create an instance of the given class. Tools like Pydantic
    will validate instances of a class, but aren’t helpful for validating a class
    definition. Any kind of validation rules would have to be defined in a metaclass
    that is used to build the resulting configuration class. Additionally, ordinary
    methods of the class will not be used. If a function-like definition is needed,
    it would have to be decorated with @classmethod to be useful.
  prefs: []
  type: TYPE_NORMAL
- en: 13.4.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using a class definition means that we will leverage inheritance to organize
    the configuration values. We can easily create multiple subclasses of Configuration,
    one of which will be selected for use in the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The configuration might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Our application must choose an appropriate class from the available classes
    in the settings module. We might use an OS environment variable or a command-line
    option to specify the class name to use. The idea is that our program can be executed
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This would locate the Chesapeake class in the settings module. Processing would
    then be based on the details in that particular configuration class. This idea
    leads to an extension to the load_config_class() function.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to pick one of the available classes, we can separate the module name
    and class name by looking for a "." separator in the command-line argument value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Rather than manually compiling and executing the module, we’ve used the higher-level
    importlib module. This module contains functions implementing the import statement
    semantics. The requested module is imported, then compiled and executed, and the
    resulting module object is assigned to the variable named result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can use this function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We’ve located the Chesapeake configuration class in the settings module and
    extracted the various settings the application needs from this class.
  prefs: []
  type: TYPE_NORMAL
- en: 13.4.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll look at class definitions in detail in Chapter [7](ch011_split_000.xhtml#x1-3760007),
    and Chapter [8](ch012.xhtml#x1-4520008).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See the [Finding configuration files](ch017.xhtml#x1-7160001) recipe in this
    chapter for an alternative approach that doesn’t use class definitions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 13.5 Designing scripts for composition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An important part of overall application design is creating a script that can
    process command-line arguments and configuration files. Further, it’s very important
    to design a script so that it can be tested as well as combined with other scripts
    into a composite application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea is that many good ideas evolve through a series of stages. One such
    evolution might be the following path:'
  prefs: []
  type: TYPE_NORMAL
- en: The idea starts as a collection of separate notebooks for separate parts of
    a larger task.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the initial period of exploration and experimentation, this becomes a
    simple repetitive task. Rather than open and click manually to run the notebook,
    it’s saved into a script file, Then the script files can be run from the command
    line.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After an initial period of making this a regular part of the organization’s
    operations, the three-part script needs to be consolidated into a single script.
    At this point, refactoring is needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The most painful time to refactor is after combining a number of scripts into
    a single application and uncovering unexpected problems. This often happens because
    global variables will be shared when multiple scripts are integrated.
  prefs: []
  type: TYPE_NORMAL
- en: A much less painful time is earlier in the life of the project. As soon as a
    script is created, some effort should be made to design the script for testing
    and composition into a larger application.
  prefs: []
  type: TYPE_NORMAL
- en: 13.5.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we’ll look at what constitutes a good design for a script. In
    particular, we want to be sure that parameters and configuration files are considered
    in the design.
  prefs: []
  type: TYPE_NORMAL
- en: 'The target is to have a structure like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A docstring for the module or script as a whole.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The imports. There’s an internal ordering to these. Tools like isort and ruff
    can handle this.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The class and function definitions that apply to the script.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A function to gather the configuration file options and runtime parameters into
    a single object that can be used by other classes and functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A single function that does the useful work. This is often called main(), but
    there’s nothing sacred about this name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A small block of code that is executed only when the module is run as a script,
    and never when the module is imported:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 13.5.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the target design as our goal, here is one approach:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by writing a summary docstring at the top of the file. It’s important
    to start with something and add details later. Here’s an example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The import statements go after the docstring. It’s not always possible to foresee
    all of the imports in advance. As the module is being written and modified, imports
    will be added and removed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The class and function definitions go next. The order is important for resolving
    the type names in the def or class statements. This means the most fundamental
    type definitions must go first.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Again, it’s not always possible to write all the definitions in their proper
    order during the first wave of design. What’s important is keeping them together
    in a logical organization and rearranging them so the order makes sense to someone
    reading the code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Write a function (with a name like get_config()) to get all of the configuration
    parameters. Generally, there are two parts to this; sometimes they need to be
    decomposed into two separate functions because each part can be rather complicated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then we have the main() function. This does the essential work of the script.
    When evolving from a notebook, this can be built from the sequence of cells.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the Main-Import Switch code block at the end:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The resulting module will work properly as a script. It can also be tested more
    easily because testing tools like pytest can import the module without it making
    changes to the filesystem when it tries to starting processing data. It can be
    integrated with other scripts to create a useful composite application.
  prefs: []
  type: TYPE_NORMAL
- en: 13.5.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The core consideration in designing a script is distinguishing between two
    use cases for a module:'
  prefs: []
  type: TYPE_NORMAL
- en: When run from the command line. In this case, the built-in global variable __name__
    will have a value of "__main__".
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When imported for testing or as part of a larger, composite application. In
    this case, __name__ will have a value that is the name of the module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a module is imported, we do not want it to start doing work. During import,
    we don’t want the module to open files, read data, do computations, or produce
    output. All of this work is something that can only happen when the module is
    run as the main program.
  prefs: []
  type: TYPE_NORMAL
- en: The original cells of the notebook or script statements are now part of the
    body of the main() function, so the script will work properly. It will, however,
    it will also be in a form that can be tested. It can also be integrated into a
    larger and more sophisticated application.
  prefs: []
  type: TYPE_NORMAL
- en: 13.5.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When starting the conversion to an application, the main() function is often
    quite lengthy. There are two ways to make the processing clear:'
  prefs: []
  type: TYPE_NORMAL
- en: Large, prominent billboard comments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactoring to create a number of smaller functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We might start with a script that has comments like these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The In[n]: comments are provided by JupyterLab to identify the cells in a notebook.
    We can create billboard comments like these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This is less than ideal. It’s an acceptable temporary measure, but these steps
    should be proper functions, each with a docstring and test cases. Billboard comments
    are traditional in languages that don’t have proper docstrings and lack documentation
    generators that exploit the docstrings.
  prefs: []
  type: TYPE_NORMAL
- en: Python has docstrings and several tools – like Sphinx – to create documentation
    from the docstrings.
  prefs: []
  type: TYPE_NORMAL
- en: 13.5.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the [Using argparse to get command-line input](ch010.xhtml#x1-3490004) recipe
    in Chapter [6](ch010.xhtml#x1-3300006), for background on using argparse to get
    inputs from a user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See [Using TOML for configuration files](ch017.xhtml#x1-7230002), [Using Python
    for configuration files](ch017.xhtml#x1-7290003), and [Using a class as a namespace
    for configuration](ch017.xhtml#x1-7350004) in this chapter for recipes related
    to configuration files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [Using logging for control and audit output](ch017.xhtml#x1-7470006) recipe
    later in this chapter looks at logging.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the [Combining two applications into one](ch018.xhtml#x1-7590001) recipe
    in Chapter [14](ch018.xhtml#x1-75800014), we’ll look at ways to combine applications
    that follow this design pattern.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The details of testing and integration are covered in separate chapters. See
    Chapter [15](ch019_split_000.xhtml#x1-79400015) for details on creating tests.
    See Chapter [14](ch018.xhtml#x1-75800014) for details on combining applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 13.6 Using logging for control and audit output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we consider an application, we can decompose the overall computation into
    three distinct aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: Gathering input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The essential processing that transforms the input into the output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Producing output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are several different kinds of output that applications produce:'
  prefs: []
  type: TYPE_NORMAL
- en: The main output that helps a user make a decision or take action. In some cases,
    this might be a JSON-formatted document downloaded by a web server. It might be
    a more complicated collection of documents that – together – will create a PDF
    file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control information that confirms that the program worked completely and correctly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Audit summaries that can be used to track the history of state changes in a
    persistent databases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any error messages that indicate why the application didn’t work.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s less than optimal to lump all of these various aspects into print() requests
    that write to standard output. Indeed, it can lead to confusion because too many
    different outputs can be interleaved in a single stream.
  prefs: []
  type: TYPE_NORMAL
- en: The OS provides each running process with two output files, standard output
    and standard error. These are visible in Python through the sys module with the
    names sys.stdout and sys.stderr. By default, the print() function writes to the
    sys.stdout file. We can change the target file and write the control, audit, and
    error messages to sys.stderr. This is an important step in the right direction.
  prefs: []
  type: TYPE_NORMAL
- en: Python also offers the logging package, which can be used to direct the ancillary
    output to a separate file (and/or other output channels, such as a database).
    It can also be used to format and filter that additional output.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we’ll look at good ways to use the logging module.
  prefs: []
  type: TYPE_NORMAL
- en: 13.6.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One approach to meeting a variety of output needs is to create multiple loggers,
    each with a different intent. It’s common to name loggers around the module or
    class associated with the logger. We can also name loggers around an overall purpose,
    like audit or control.
  prefs: []
  type: TYPE_NORMAL
- en: The names of loggers form a hierarchy, punctuated by .. The root logger is the
    parent of all loggers and has a name of "". This suggests that we can have families
    of loggers focused on particular classes, modules, or features.
  prefs: []
  type: TYPE_NORMAL
- en: 'A set of top-level loggers can include a number of separate focus areas, including:'
  prefs: []
  type: TYPE_NORMAL
- en: error will preface all loggers for warnings and errors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: debug will preface all loggers for debugging messages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: audit will name loggers with counts and totals used to confirm that data was
    processed fully.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: control will name loggers that provide information about when the application
    was run, the environment, configuration files, and command-line argument values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In most cases, it is helpful to have errors and debugging in a single logger.
    In other cases – for example, a web server – the request error response log should
    be separate from any internal error or debugging log.
  prefs: []
  type: TYPE_NORMAL
- en: A complicated application might have several loggers with names like audit.input
    and audit.output to show the counts of data consumed and the counts of data produced.
    Keeping these separate can help focus attention on problems with data providers.
  prefs: []
  type: TYPE_NORMAL
- en: 'A severity level serves as a kind of filter for each logger. The severity levels
    defined in the logging package include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'DEBUG: These messages are not generally shown since their intent is to support
    debugging. Above, we suggested this is a distinct variety of debugging. We suggest
    an application create a logging debugger, and use ordinary INFO messages for the
    debugging entries.'
  prefs: []
  type: TYPE_NORMAL
- en: 'INFO: These messages provide information on the normal, happy-path processing.'
  prefs: []
  type: TYPE_NORMAL
- en: 'WARNING: These messages indicate that processing may be compromised in some
    way. The most sensible use case for a warning is when functions or classes have
    been deprecated: they still work, but they should be replaced.'
  prefs: []
  type: TYPE_NORMAL
- en: 'ERROR: Processing is invalid and the output is incorrect or incomplete. In
    the case of a long-running server, an individual request may have problems, but
    the server as a whole can continue to operate.'
  prefs: []
  type: TYPE_NORMAL
- en: 'CRITICAL: A more severe level of error. Generally, this is used by long-running
    servers where the server itself can no longer operate and is about to crash.'
  prefs: []
  type: TYPE_NORMAL
- en: Each logger has method names that are similar to the severity levels. We use
    the info() method to write a message with the INFO severity level.
  prefs: []
  type: TYPE_NORMAL
- en: For error handling, the severity levels are mostly appropriate. A debugging
    logger, however, often produces volumes of data that need to be kept separate.
    Further, any audit and control output doesn’t seem to have a severity level. The
    severity level seems to be focused only on error logging. For this reason, it
    seems to be better to have distinct logs with names like debug.some_function.
    We can then configure debugging by enabling or disabling the output from these
    loggers, and configure the severity level to be INFO.
  prefs: []
  type: TYPE_NORMAL
- en: 13.6.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll look at logging in a class as well as a function in two mini-recipes.
  prefs: []
  type: TYPE_NORMAL
- en: Logging in a class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Be sure the logging module is imported.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the __init__() method, include the following to create an error and debug
    loggers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In any method that might require future debugging, use the debug logger’s methods
    to write details to the log. While f-strings can be used to write log messages,
    they involve a bit of overhead to interpolate values into the text. Using the
    logger’s formatting options and separate argument values involves slightly less
    computation when the configuration silences the logger’s output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In a few key places, include overall status messages. These are often in the
    overall application control classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Logging in a function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Be sure the logging module is imported.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For larger and more complicated functions, it makes sense to include the logger
    inside the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Because the loggers are cached, only the first request to get_logger() involves
    any significant overhead. All subsequent requests are dictionary lookups.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For smaller functions, it can make sense to have a globally defined logger.
    This can help to reduce visual clutter within a function’s body:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that without any further configuration, no output will be produced. This
    is because the default severity level for each logger will be WARNING, which means
    the handler will not show INFO- or DEBUG-level messages..
  prefs: []
  type: TYPE_NORMAL
- en: 13.6.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are three parts to introducing logging into an application:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating Logger objects with the getLogger() function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Placing log messages near important state changes with one of the methods similar
    to info() or error() for each logger.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring the logging system as a whole when the application is run. This
    is essential for seeing output from the loggers. We’ll look at this in the There’s
    more... section of this recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Creating loggers can be done in a variety of ways. A common approach is to
    create one logger with the same name as the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: For the top-level main script, this will have the name __main__. For imported
    modules, the name will match the module name.
  prefs: []
  type: TYPE_NORMAL
- en: In more complex applications, there could be a variety of loggers serving a
    variety of purposes. In these cases, simply naming a logger after a module may
    not provide the required level of flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: It’s also possible to use the logging module itself as the root logger. This
    means a module can use the logging.info() function, for example. This isn’t recommended
    because the root logger is anonymous, and we sacrifice the possibility of using
    the logger name as an important source of information.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe suggests naming loggers based on the audience or use case. The topmost
    name – for example, debug. – will distinguish the audience or purpose for the
    log. This can make it easy to route all loggers under a given parent to a specific
    handler.
  prefs: []
  type: TYPE_NORMAL
- en: It’s helpful to associate logging messages with the important state changes
    made by the code.
  prefs: []
  type: TYPE_NORMAL
- en: The third aspect of logging is configuring the loggers so that they route the
    requests to the appropriate destination. By default, with no configuration at
    all, the logger instances will quietly ignore the various messages being created.
  prefs: []
  type: TYPE_NORMAL
- en: 'With a minimal configuration, we can see all of the log events on the console.
    This can be done with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 13.6.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to route the different loggers to different destinations, we’ll need
    a more sophisticated configuration. Often, this goes beyond what we can build
    with the basicConfig() function. We’ll need to use the logging.config module and
    the dictConfig() function. This can provide a complete set of configuration options.
    The easiest way to use this function is to write the configuration in TOML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some key points in this TOML configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: The value of the version key must be 1\. This is required.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The values in the formatters table define the log formats available. If a formatter
    is not specified, a built-in formatter will display the message body only:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The default formatter defined in the example mirrors the format created by the
    basicConfig() function. This includes the message severity level and the logger
    name.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The new timestamp formatter defined in the example is a more complex format
    that includes the date-time stamp for the record. To make the file easier to parse,
    a column separator of // was used.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The handlers table defines the handlers available for loggers to use:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The console handler writes to the sys.stderr stream and uses default formatter.
    The text starting "ext://..." is how a configuration file can refer to objects
    defined in the Python environment – in this case, the sys.stderr value from the
    sys module.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The file handler uses the FileHandler class to write to a file. The default
    mode for opening the file is a, which will append to any existing log file. The
    configuration specifies the timestamp formatter that will be used for the file.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The loggers table provides a configuration for two specific named loggers that
    the application will use. Any logger name that begins with overview_stats.detail
    will be handled only by the console handler. Any logger name that begins with
    overview_stats.write will go to both the file handler and the console handler.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The special root key defines the top-level logger. Within an application, it
    has a name of "" (empty string) when referred to in code. Within the configuration
    file, it has the key root.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting the severity level on the root logger will set the level used to show
    – or hide – messages for all of the children of this logger. This will show messages
    with the severity INFO or higher, which includes warnings, errors, and severe
    errors.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Assuming the contents of this file are present in a variable named config_toml,
    the configuration to wrap the main() function will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: This will start the logging in a known state. It will do the processing of the
    application. It will finalize all of the logging buffers and properly close any
    files.
  prefs: []
  type: TYPE_NORMAL
- en: 13.6.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the [Designing scripts for composition](ch017.xhtml#x1-7410005) recipe earlier
    in this chapter for the complementary part of this application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See the [Using TOML for configuration files](ch017.xhtml#x1-7230002) recipe
    in this chapter for more on parsing TOML documents.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Join our community Discord space
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our Python Discord workspace to discuss and find out more about the book:
    [https://packt.link/dHrHU](https://packt.link/dHrHU)'
  prefs: []
  type: TYPE_NORMAL
- en: '![PIC](img/file1.png)'
  prefs: []
  type: TYPE_IMG
