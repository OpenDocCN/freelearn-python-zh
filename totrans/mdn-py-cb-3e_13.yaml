- en: '13'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '13'
- en: 'Application Integration: Configuration'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序集成：配置
- en: 'Python’s concept of an extensible library gives us rich access to numerous
    computing resources. The language provides avenues to make even more resources
    available. This makes Python programs particularly strong at integrating components
    to create sophisticated composite processing. In this chapter, we’ll address the
    fundamentals of creating complex applications: managing configuration files, logging,
    and a design pattern for scripts that permits automated testing.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Python的可扩展库概念为我们提供了对众多计算资源的丰富访问。该语言提供了使更多资源可用的途径。这使得Python程序特别擅长集成组件以创建复杂的复合处理。在本章中，我们将讨论创建复杂应用程序的基本原则：管理配置文件、日志记录以及允许自动化测试的脚本设计模式。
- en: These new recipes leverage ideas shown in recipes in other chapters. Specifically,
    in the [Using argparse to get command-line input](ch010.xhtml#x1-3490004), [Using
    cmd to create command-line applications](ch010.xhtml#x1-3610006), and [Using the
    OS environment settings](ch010.xhtml#x1-3670007) recipes in Chapter [6](ch010.xhtml#x1-3300006),
    some specific techniques for creating top-level (main) application scripts were
    shown. It may help to review those recipes to see examples of Python application
    scripts. In Chapter [11](ch015_split_000.xhtml#x1-61500011), we looked at filesystem
    input and output.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这些新食谱借鉴了其他章节中食谱中的想法。具体来说，在第[6](ch010.xhtml#x1-3300006)章的[使用argparse获取命令行输入](ch010.xhtml#x1-3490004)、[使用cmd创建命令行应用程序](ch010.xhtml#x1-3610006)和[使用OS环境设置](ch010.xhtml#x1-3670007)的食谱中，展示了创建顶级（主）应用程序脚本的一些特定技术。回顾这些食谱可能有助于查看Python应用程序脚本的示例。在第[11](ch015_split_000.xhtml#x1-61500011)章中，我们探讨了文件系统的输入和输出。
- en: 'In this chapter, we’ll look at a number of ways to handle configuration files.
    There are many file formats that can be used to store long-term configuration
    information:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨处理配置文件的各种方法。有许多文件格式可以用来存储长期配置信息：
- en: The INI file format as processed by the configparser module.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: configparser模块处理的INI文件格式。
- en: The TOML file format is very easy to work with but requires an add-on module
    that’s not currently part of the Python distribution. We’ll look at this in the
    [Using TOML for configuration files](ch017.xhtml#x1-7230002) recipe.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TOML文件格式非常易于处理，但需要一个不是Python发行版中当前部分的附加模块。我们将在[使用TOML作为配置文件](ch017.xhtml#x1-7230002)的食谱中探讨这一点。
- en: The properties file format is typical of Java programming and can be handled
    in Python without writing too much code. Some of the syntax overlaps with Python
    scripts and TOML files. A switch from the properties file format to TOML only
    requires changing any name: value to name = "value", permitting use of the TOML
    parser.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性文件格式是Java编程的典型格式，在Python中无需编写太多代码即可处理。一些语法与Python脚本和TOML文件重叠。从属性文件格式切换到TOML只需要将任何name:value更改为name
    = "value"，允许使用TOML解析器。
- en: For Python scripts, a file with assignment statements looks a lot like a properties
    file, and is very easy to process using the compile() and exec() functions. We’ll
    look at this in the [Using Python for configuration files](ch017.xhtml#x1-7290003)
    recipe.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于Python脚本，具有赋值语句的文件看起来很像属性文件，并且可以使用compile()和exec()函数非常容易地处理。我们将在[使用Python作为配置文件](ch017.xhtml#x1-7290003)的食谱中探讨这一点。
- en: A Python module with class definitions is a variation that uses Python syntax
    but isolates the settings into separate classes. This can be processed with the
    import statement. We’ll look at this in the [Using a class as a namespace for
    configuration](ch017.xhtml#x1-7350004) recipe.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有类定义的Python模块是一种使用Python语法但将设置隔离到单独类中的变体。这可以通过导入语句进行处理。我们将在[使用类作为配置的命名空间](ch017.xhtml#x1-7350004)的食谱中探讨这一点。
- en: Some recipes in this chapter will extend some of the concepts from Chapter [7](ch011_split_000.xhtml#x1-3760007),
    and Chapter [8](ch012.xhtml#x1-4520008). This chapter will apply those concepts
    to defining configuration files using classes.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的一些食谱将扩展第[7](ch011_split_000.xhtml#x1-3760007)章和第[8](ch012.xhtml#x1-4520008)章中的一些概念。本章将应用这些概念来定义使用类定义配置文件。
- en: It’s important to consider the kinds of information required in configuration
    files. Carelessly including passwords or security tokens in a configuration file
    can be fatal to secure use of data. Including personal information in a configuration
    file is also a common security weakness. See the [Common Weakness Enumeration](https://cwe.mitre.org/index.html)
    for other more specific issues with poorly designed configuration files.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑配置文件中所需的信息类型非常重要。在配置文件中不小心包含密码或安全令牌可能会对数据的安全使用造成致命影响。在配置文件中包含个人信息也是一种常见的安全弱点。请参阅[常见弱点枚举](https://cwe.mitre.org/index.html)了解设计不良配置文件的其他更具体问题。
- en: 'In this chapter, we’ll look at the following recipes:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下菜谱：
- en: '[Finding configuration files](ch017.xhtml#x1-7160001)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[查找配置文件](ch017.xhtml#x1-7160001)'
- en: '[Using TOML for configuration files](ch017.xhtml#x1-7230002)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用TOML配置文件](ch017.xhtml#x1-7230002)'
- en: '[Using Python for configuration files](ch017.xhtml#x1-7290003)'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用Python配置文件](ch017.xhtml#x1-7290003)'
- en: '[Using a class as a namespace for configuration](ch017.xhtml#x1-7350004)'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[将类用作配置的命名空间](ch017.xhtml#x1-7350004)'
- en: '[Designing scripts for composition](ch017.xhtml#x1-7410005)'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[设计用于组合的脚本](ch017.xhtml#x1-7410005)'
- en: '[Using logging for control and audit output](ch017.xhtml#x1-7470006)'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用日志进行控制和审计输出](ch017.xhtml#x1-7470006)'
- en: We’ll start with a recipe for handling multiple configuration files that must
    be combined. This gives users some helpful flexibility. From there, we can dive
    into the specifics of a few of the common configuration file formats.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个处理必须组合的多个配置文件的菜谱开始。这为用户提供了一些有用的灵活性。从那里，我们可以深入了解一些常见配置文件格式的具体细节。
- en: 13.1 Finding configuration files
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 13.1 查找配置文件
- en: Many applications will have a hierarchy of configuration options. The foundation
    of the hierarchy is often the default values built into the application. These
    might be supplemented by server-wide (or cluster-wide) values from centralized
    configuration files. There might also be user-specific files, or perhaps even
    configuration files provided when starting a program.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 许多应用程序将具有配置选项的层次结构。这个层次结构的基础通常是应用程序中内置的默认值。这些可能由来自集中式配置文件的整个服务器（或集群）范围内的值补充。也可能有特定于用户的文件，或者甚至可能是启动程序时提供的配置文件。
- en: In many cases, configuration parameters are written in text files, so they are
    persistent and easy to change. The common tradition in Linux is to put system-wide
    configuration in the /etc directory. A user’s personal changes would be in their
    home directory, often named ~username or $HOME.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，配置参数是以文本文件的形式编写的，因此它们是持久的并且易于更改。在Linux中，常见的传统是将系统范围的配置放在/etc目录中。用户的个人更改将放在他们的家目录中，通常命名为~username或$HOME。
- en: In this recipe, we’ll see how an application can support a rich hierarchy of
    locations for configuration files.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将看到应用程序如何支持配置文件的丰富层次结构。
- en: 13.1.1 Getting ready
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.1.1 准备工作
- en: The example we’ll use is an application to simulate dice rolling. The application
    is shown in several recipes throughout Chapter [6](ch010.xhtml#x1-3300006). Specifically,
    look at [Using argparse to get command-line input](ch010.xhtml#x1-3490004) and
    [Using cmd to create command-line applications](ch010.xhtml#x1-3610006).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的示例是一个模拟掷骰子的应用程序。该应用程序在第六章的几个菜谱中有所展示。[6](ch010.xhtml#x1-3300006)。具体来说，请查看[使用argparse获取命令行输入](ch010.xhtml#x1-3490004)和[使用cmd创建命令行应用程序](ch010.xhtml#x1-3610006)。
- en: 'We’ll follow the design pattern of the Bash shell, which looks for configuration
    files in the following places:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将遵循Bash shell的设计模式，它会在以下位置查找配置文件：
- en: It starts with the /etc/profile file, applicable to everyone using the system.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它从/etc/profile文件开始，适用于使用系统的每个人。
- en: 'After reading that file, it looks for one of these files, in this order:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在读取该文件后，它会按以下顺序查找这些文件之一：
- en: ~/.bash_profile
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: ~/.bash_profile
- en: ~/.bash_login
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: ~/.bash_login
- en: ~/.profile
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: ~/.profile
- en: Other shells, like zsh, use some additional files but follow this pattern of
    working through a sequence of files in order.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 其他shell，如zsh，使用一些额外的文件，但遵循通过一系列文件顺序工作的模式。
- en: In a POSIX-compliant operating system, the shell expands the ~ to be the home
    directory for the logged-in user. In general, the Python pathlib module handles
    this for Windows, Linux, and macOS automatically via the Path.home() method.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在符合POSIX标准的操作系统上，shell将~展开为登录用户的家目录。通常，Python的pathlib模块通过Path.home()方法自动处理Windows、Linux和macOS。
- en: In later recipes, we’ll look at ways to parse and process specific formats of
    configuration files. For the purposes of this recipe, we won’t pick a specific
    format. Instead, we’ll assume that an existing function, load_config_file(), has
    been defined that will load a specific configuration mapping from the contents
    of the configuration files.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在后面的菜谱中，我们将探讨解析和处理配置文件特定格式的各种方法。对于本菜谱的目的，我们不会选择特定的格式。相反，我们将假设已经定义了一个名为load_config_file()的现有函数，该函数将从配置文件的
    内容中加载特定的配置映射。
- en: 'The function looks like this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 函数看起来是这样的：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We’ll look at a number of different ways to implement this function.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨实现此函数的多种不同方法。
- en: Why so many choices?
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为什么有这么多选择？
- en: There’s a side topic that sometimes arises when discussing this kind of design
    – why have so many choices? Why not specify exactly one place?
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论这类设计时，有时会出现一个相关话题——为什么有这么多选择？为什么不指定一个确切的位置？
- en: It’s common to offer variations typical for one distribution, but atypical for
    another. Also, user expectations depend on software with which they’re already
    familiar; this is very difficult to anticipate. And, of course, when dealing with
    Windows, there will be the possibility of yet more variant file paths that are
    unique to that platform. For these reasons, it’s easier to offer multiple locations
    and permit the user or administrator to pick the one they prefer.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 提供一个分布特有的变体，但另一个分布不典型的情况很常见。此外，用户的期望取决于他们已经熟悉的软件；这很难预测。当然，当处理Windows时，还可能出现更多仅适用于该平台的变体文件路径。出于这些原因，提供多个位置并允许用户或管理员选择他们偏好的位置更容易。
- en: 13.1.2 How to do it...
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.1.2 如何做到这一点...
- en: 'We’ll make use of the pathlib module to provide a handy way to work with files
    in various locations. We’ll also use the collections module to provide the very
    useful ChainMap class:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用pathlib模块提供一种方便的方式来处理各种位置上的文件。我们还将使用collections模块提供非常有用的ChainMap类：
- en: 'Import the Path class and the ChainMap class. There are several type hints
    that are also required:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入Path类和ChainMap类。还需要几个类型提示：
- en: '[PRE1]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Define an overall function to get the configuration files:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个获取配置文件的整体函数：
- en: '[PRE2]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Create paths for the various locations of the configuration files. These are
    called pure paths and start with the names of potential files. We can decompose
    these locations into a system path and a sequence of local paths. Here are the
    two assignment statements:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为配置文件的各个位置创建路径。这些被称为纯路径，并以潜在文件的名字开头。我们可以将这些位置分解为系统路径和一系列本地路径。以下是两个赋值语句：
- en: '[PRE3]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Define the application’s built-in defaults as a list of dictionaries:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将应用程序的内置默认值定义为一个字典列表：
- en: '[PRE4]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Each individual configuration file is a mapping from keys to values. Each of
    these mapping objects is combined to form a list; this becomes the final ChainMap
    configuration mapping.
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每个单独的配置文件是从键到值的映射。这些映射对象中的每一个都被组合成一个列表；这成为最终的ChainMap配置映射。
- en: 'If the system-wide configuration file exists, load this file:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果存在系统范围的配置文件，则加载此文件：
- en: '[PRE5]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Iterate through other locations looking for a file to load. This loads the
    first file that it finds and uses a break statement to stop after the first file
    is found:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历其他位置以查找要加载的文件。这将加载它找到的第一个文件，并使用break语句在找到第一个文件后停止：
- en: '[PRE6]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Reverse the list and create the final ChainMap mapping:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 反转列表并创建最终的ChainMap映射：
- en: '[PRE7]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The list needs to be reversed so that the local file (appended last) is searched
    first, then the system settings, and finally the application default settings.
    It’s certainly possible to assemble the list in the reverse order to avoid the
    reversed() function; we’ve left this possible change as an exercise for you.
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 列表需要反转，以便首先搜索附加在最后的本地文件，然后是系统设置，最后是应用程序默认设置。当然，可以按相反的顺序组装列表以避免reversed()函数；我们把这个可能的变化留给你作为练习。
- en: Once we’ve built the configuration object, we can use the final configuration
    like a simple mapping. This object supports all of the expected dictionary operations.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们构建了配置对象，我们就可以像简单的映射一样使用最终的配置。此对象支持所有预期的字典操作。
- en: 13.1.3 How it works...
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.1.3 它是如何工作的...
- en: 'In the [Creating dictionaries – inserting and updating](ch009.xhtml#x1-2900001)
    recipe in Chapter [5](ch009.xhtml#x1-2890005), we looked at the basics of using
    a dictionary. Here, we’ve combined several dictionaries into a chain. When a key
    is not located in the first dictionary of the chain, then later dictionaries in
    the chain are checked. This is a handy way to provide default values for each
    key in the mapping. Because the ChainMap is nearly indistinguishable from the
    built-in dict class, it permits a lot of flexibility in the implementation details:
    any kind of configuration file that can be read to create a dictionary is perfectly
    acceptable. The rest of the application can be based on the dictionary without
    being exposed to the details of how the configuration was built.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 [5](ch009.xhtml#x1-2890005) 章的 [创建字典——插入和更新](ch009.xhtml#x1-2900001) 配方中，我们探讨了使用字典的基本知识。在这里，我们将几个字典组合成一个链。当一个键不在链的第一个字典中时，则检查链中的后续字典。这是一种为映射中的每个键提供默认值的好方法。由于
    ChainMap 几乎与内置的 dict 类无法区分，它允许在实现细节上具有很大的灵活性：任何可以读取以创建字典的配置文件都是完全可接受的。应用程序的其余部分可以基于字典，而不必暴露配置构建的细节。
- en: 13.1.4 There’s more...
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.1.4 更多...
- en: The subtle distinction between the single system-wide configuration file and
    the collection of alternative names for the local configuration files isn’t ideal.
    This distinction between a singleton and a list of choices doesn’t seem to serve
    any particular purpose. Often, we want to extend this design and the tiny asymmetry
    leads to complications.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 单一的全局配置文件和本地配置文件替代名称集合之间的微妙区别并不理想。这种单例和选择列表之间的区别似乎没有特定的用途。通常，我们希望扩展这种设计，而微小的非对称性会导致复杂性。
- en: 'We’ll consider changing the configuration to have the following four tiers:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将考虑将配置修改为以下四个层级：
- en: The built-in defaults.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内置的默认值。
- en: A host-wide configuration in a central directory like /etc or /opt. This is
    often used for details of the OS or network context for this container.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在像 /etc 或 /opt 这样的中心目录中的主机级配置。这通常用于此容器的 OS 或网络上下文的详细信息。
- en: A home directory configuration for the user running the app. This may be used
    for distinguishing test and production instances.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为运行应用程序的用户配置的 home 目录。这可能用于区分测试和生产实例。
- en: A local file in the current working directory. This may be used by a developer
    or tester.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当前工作目录中的本地文件。这可能由开发者或测试人员使用。
- en: This suggests a modification to the recipe to use nested lists of paths. The
    outer list contains all of the tiers of configuration. Within each tier, a list
    will contain the alternative locations for a configuration file.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明对配方进行修改以使用路径的嵌套列表。外层列表包含所有配置层级。在每个层级内，一个列表将包含配置文件的替代位置。
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This list[list[Path]] structure provides three tiers of configuration files.
    Each of the tiers has a number of alternative names. The order of the tiers and
    the names within each tier are important. The lower tiers provide overrides to
    the upper tiers. We can then use nested for statements to examine all of the alternative
    locations.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这种 list[list[Path]] 结构提供了三个配置文件层级。每个层级都有多个替代名称。层级的顺序以及每个层级内的名称都很重要。较低层级提供对较高层级的覆盖。然后我们可以使用嵌套的
    for 语句来检查所有替代位置。
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We’ve factored out the default configuration into a global variable with the
    name DEFAULT_CONFIGURATION. We have conspicuously left the collection of configuration
    paths with the name config_paths. It’s not perfectly clear if this should be global
    (and have a global variable name in ALL-CAPITALS) or if this should be part of
    the get_config() function. We’ve adopted a bit of both by using a lowercase name
    and putting it outside the function.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将默认配置提取到一个名为 DEFAULT_CONFIGURATION 的全局变量中。我们明显地留下了名为 config_paths 的配置路径集合。不清楚这是否应该是全局的（并且使用全大写的全局变量名）或者是否应该是
    get_config() 函数的一部分。我们通过使用小写名称并将其放在函数外部，采取了一部分两者的做法。
- en: The value of config_paths is unlikely to be needed elsewhere, making it a bad
    choice for being a global variable. It is, however, something that may change
    – perhaps in the next major release – and deserves to be exposed so it can be
    changed.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: config_paths 的值可能不会在其他地方需要，因此将其作为全局变量是一个糟糕的选择。然而，这却是一样可能会改变的东西——也许在下一个主要版本中——并且值得暴露出来以便进行更改。
- en: 13.1.5 See also
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.1.5 参见
- en: In the [Using TOML for configuration files](ch017.xhtml#x1-7230002) and [Using
    Python for configuration files](ch017.xhtml#x1-7290003) recipes in this chapter,
    we’ll look at ways to implement the load_config_file() function.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章的 [使用 TOML 作为配置文件](ch017.xhtml#x1-7230002) 和 [使用 Python 作为配置文件](ch017.xhtml#x1-7290003)
    菜谱中，我们将探讨实现 load_config_file() 函数的方法。
- en: In the [Mocking external resources](ch019_split_001.xhtml#x1-85500010) recipe
    in Chapter [15](ch019_split_000.xhtml#x1-79400015), we look at ways to test functions
    such as this, which interact with external resources.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第 [15](ch019_split_000.xhtml#x1-79400015) 章的 [模拟外部资源](ch019_split_001.xhtml#x1-85500010)
    菜谱中，我们将探讨测试此类函数的方法，这些函数与外部资源交互。
- en: The pathlib module is central to this processing. This module provides the Path
    class definition, which provides a great deal of sophisticated information about
    the OS’s files. For more information, see the [Using pathlib to work with filenames](ch015_split_000.xhtml#x1-6160001)
    recipe in Chapter [11](ch015_split_000.xhtml#x1-61500011).
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: pathlib 模块是此处理的核心。此模块提供了 Path 类定义，它提供了关于操作系统文件的许多复杂信息。有关更多信息，请参阅第 [11](ch015_split_000.xhtml#x1-61500011)
    章的 [使用 pathlib 处理文件名](ch015_split_000.xhtml#x1-6160001) 菜谱。
- en: 13.2 Using TOML for configuration files
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 13.2 使用 TOML 作为配置文件
- en: Python offers a variety of ways to package application inputs and configuration
    files. We’ll look at writing files in TOML notation because this format is elegant
    and simple. For more information on this format, see [https://toml.io/en/](https://toml.io/en/).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Python 提供了多种打包应用程序输入和配置文件的方式。我们将探讨使用 TOML 语法编写文件，因为这种格式优雅且简单。有关此格式的更多信息，请参阅
    [https://toml.io/en/](https://toml.io/en/)。
- en: Most TOML files look quite a bit like INI-format files. This overlap is intentional.
    When parsed in Python, a TOML file will be a nested dictionary structure.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 TOML 文件看起来与 INI 格式文件非常相似。这种重叠是有意为之的。在 Python 中解析时，TOML 文件将是一个嵌套字典结构。
- en: 'We might have a file like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能有一个这样的文件：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This will become a dictionary like the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这将变成如下所示的字典：
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The [some_app.feature] is called a ”table”. The use of a . in the key creates
    a nested table.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '[some_app.feature] 被称为“表格”。在键中使用 . 会创建一个嵌套表格。'
- en: 13.2.1 Getting ready
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.2.1 准备工作
- en: We’ll often use the [Finding configuration files](ch017.xhtml#x1-7160001) recipe,
    shown earlier in this chapter, to check a variety of locations for a given configuration
    file. This flexibility is often essential for creating an application that’s easy
    to use on a variety of platforms.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常会使用本章前面展示的 [寻找配置文件](ch017.xhtml#x1-7160001) 菜谱，以检查给定配置文件的各种位置。这种灵活性对于创建易于在各种平台上使用的应用程序通常是必不可少的。
- en: 'In this recipe, we’ll build the missing part of the [Finding configuration
    files](ch017.xhtml#x1-7160001) recipe, the load_config_file() function. Here’s
    the template that needs to be filled in:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱中，我们将构建 [寻找配置文件](ch017.xhtml#x1-7160001) 菜谱中缺失的部分，即 load_config_file() 函数。以下是需要填写的模板：
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this recipe, we’ll fill in the space held by the Details omitted line to
    load configuration files in TOML format.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱中，我们将填写 Details 省略行保留的空间，以加载 TOML 格式的配置文件。
- en: 13.2.2 How to do it...
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.2.2 如何做...
- en: 'This recipe will make use of the tomllib module to parse a YAML-TOML file:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱将使用 tomllib 模块解析 YAML-TOML 文件：
- en: 'Import the tomllib module along with the Path definition and the type hints
    required by the load_config_file() function definition:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 tomllib 模块以及 Path 定义和 load_config_file() 函数定义所需的类型提示：
- en: '[PRE13]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Use the tomllib.load() function to load the TOML-syntax document:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 tomllib.load() 函数加载 TOML 语法文档：
- en: '[PRE14]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: An unusual requirement of TOML parsing in Python requires us to open the file
    in ”binary” mode when using the load() function. We can use ’rb’ as the mode to
    be explicit that the file is opened for reading.
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Python 中 TOML 解析的一个不寻常的要求是我们需要在使用 load() 函数时以“二进制”模式打开文件。我们可以使用 'rb' 作为模式，以明确表示文件是为读取而打开的。
- en: 'The alternative is to use the loads() function on a block of text. It looks
    like this:'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另一种选择是使用 loads() 函数对一个文本块进行操作。它看起来像这样：
- en: '[PRE15]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This load_config_file() function produced the required dictionary structure.
    It can be fit into the design from the [Finding configuration files](ch017.xhtml#x1-7160001)
    recipe to load a configuration file using TOML syntax.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 此 load_config_file() 函数生成了所需的字典结构。它可以适应 [寻找配置文件](ch017.xhtml#x1-7160001) 菜谱中的设计，以使用
    TOML 语法加载配置文件。
- en: 13.2.3 How it works...
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.2.3 它是如何工作的...
- en: As noted above, the idea of TOML syntax is to be easy to read and map directly
    to a Python dictionary. There is some intentional overlap between TOML notation
    and INI file syntax. There is also some overlap with some aspects of property
    file syntax.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所述，TOML 语法的理念是易于阅读，并直接映射到 Python 字典。TOML 语法与 INI 文件语法之间有一些有意重叠。它也与属性文件语法的某些方面有重叠。
- en: The core of TOML syntax is key-value pairings generally written as key = value.
    The keys include valid Python symbols. This means that any sort of dataclass or
    Pydantic structure with a dictionary mapping can be mapped into TOML syntax, too.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: TOML 语法的核心是键值对，通常写作 key = value。键包括有效的 Python 符号。这意味着任何具有字典映射的数据类或 Pydantic
    结构都可以映射到 TOML 语法中。
- en: It’s valid for a TOML key to have a hyphen, which is not part of allowed Python
    names. A key can be a quoted string, too. This permits quite a wide variety of
    alternative keys. These features may need some caution depending on ultimate use
    for the configuration dictionary objects.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: TOML 的键可以包含连字符，这不是 Python 允许的名称的一部分。键也可以是引号字符串。这允许有相当广泛的替代键。这些特性在使用配置字典对象时可能需要一些谨慎。
- en: 'A key can also be dotted; this will create sub-dictionaries. Here’s an example
    of dotted keys:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 键也可以是点分隔的；这将创建子字典。以下是一个点分隔键的示例：
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This looks quite a bit like a properties file often used with Java applications.
    This creates nested dictionaries by decomposing the keys at the . character.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来与常用于 Java 应用程序的属性文件非常相似。这通过在点字符处分解键来创建嵌套字典。
- en: A wide variety of values are available, including string values, integer values,
    float values, and Boolean values (using true and false as the literal values).
    Additionally, TOML recognizes ISO date-time strings; see [RFC 3339](https://tools.ietf.org/html/rfc3339)
    for the formats supported.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的值种类繁多，包括字符串值、整数值、浮点值和布尔值（使用 true 和 false 作为字面值）。此外，TOML 还识别 ISO 日期时间字符串；有关支持的格式，请参阅
    [RFC 3339](https://tools.ietf.org/html/rfc3339)。
- en: 'TOML permits two data structures:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: TOML 允许两种数据结构：
- en: An array is enclosed in [ and ]. We can use sizes = [1, 2, 3] to create a Python
    list value.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组用 `[` 和 `]` 括起来。我们可以使用 `sizes = [1, 2, 3]` 来创建一个 Python 列表值。
- en: An in-line table can be created using { and } around one or more key = value
    items. For example, sample = {x = 10, y = 8.4} creates a nested dict value.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用 `{` 和 `}` 包围一个或多个键值对来创建内联表格。例如，`sample = {x = 10, y = 8.4}` 创建了一个嵌套字典值。
- en: 'One of the most important features of TOML syntax is using [table] as the key
    for a nested dictionary. We’ll often see this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: TOML 语法的一个重要特性是使用 [table] 作为嵌套字典的键。我们经常会看到这种情况：
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The [some_app] is a key for a dictionary containing the indented key-value pairs.
    TOML syntax of [some_app.feature] defines a more deeply nested dictionary. The
    use of a dotted key means the string "some_app" will be a key for a dictionary
    containing the key feature. The value associated with this key will be a dictionary
    with the key "option_1". In TOML the [table] prefix for nested values creates
    a visual organization, making it easier to find and change configuration settings.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`[some_app]` 是一个字典的键，该字典包含缩进的键值对。TOML 语法中的 `[some_app.feature]` 定义了一个更深层次的字典。使用点分隔的键意味着字符串
    "some_app" 将成为包含键 "feature" 的字典的键。与该键关联的值将是一个包含键 "option_1" 的字典。在 TOML 中，[table]
    前缀用于嵌套值，创建了一个视觉组织，使得查找和更改配置设置更加容易。'
- en: 13.2.4 There’s more...
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.2.4 更多内容...
- en: 'TOML notation is used for a the overall pyproject.toml file that can be used
    to describe a Python project. This file often has two top-level tables: [project]
    and [build-system]. The project table will have some metadata about the [project].
    Here’s an example:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: TOML 语法用于描述 Python 项目的整体 `pyproject.toml` 文件。此文件通常有两个顶级表格：[project] 和 [build-system]。项目表将包含有关
    [project] 的元数据。以下是一个示例：
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The [build-system] table provides information on tools needed to install the
    module, package, or application. Here’s an example:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`[build-system]` 表格提供了有关安装模块、软件包或应用程序所需工具的信息。以下是一个示例：'
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This file provides a few essential pieces of information about the project.
    The use of TOML notation makes it relatively easy to read and change.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件提供了关于项目的一些基本信息。使用 TOML 语法使得阅读和更改相对容易。
- en: 13.2.5 See also
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.2.5 参见
- en: See the [Finding configuration files](ch017.xhtml#x1-7160001) recipe earlier
    in this chapter to see how to search multiple filesystem locations for a configuration
    file. We can easily have application defaults, system-wide settings, and personal
    settings built into separate files and combined by an application.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参考本章前面的[查找配置文件](ch017.xhtml#x1-7160001)配方，了解如何搜索多个文件系统位置以查找配置文件。我们可以轻松地将应用程序默认设置、系统级设置和个人设置分别存入不同的文件，并由应用程序组合。
- en: For more information on TOML syntax, see [https://toml.io/en/](https://toml.io/en/).
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多关于TOML语法的详细信息，请参阅[https://toml.io/en/](https://toml.io/en/)。
- en: For more information on the pyproject.toml file, see the Python Packaging Authority
    document [https://pip.pypa.io/en/stable/reference/build-system/pyproject-toml/](https://pip.pypa.io/en/stable/reference/build-system/pyproject-toml/).
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多关于pyproject.toml文件的信息，请参阅Python打包权威机构文档[https://pip.pypa.io/en/stable/reference/build-system/pyproject-toml/](https://pip.pypa.io/en/stable/reference/build-system/pyproject-toml/)。
- en: 13.3 Using Python for configuration files
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 13.3 使用Python配置文件
- en: In addition to syntax like TOML for providing configuration data, we can also
    write files in Python notation; it’s elegant and simple. It offers tremendous
    flexibility, since the configuration file is a Python module.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 除了提供配置数据的TOML语法之外，我们还可以用Python符号编写文件；它既优雅又简单。由于配置文件是一个Python模块，因此它提供了极大的灵活性。
- en: 13.3.1 Getting ready
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.3.1 准备工作
- en: Python assignment statements are particularly elegant for creating configuration
    files. The syntax can be simple, easy to read, and extremely flexible. If we use
    assignment statements, we can import an application’s configuration details from
    a separate module. This could have a name like settings.py to show the module’s
    focus on configuration parameters.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Python赋值语句对于创建配置文件来说特别优雅。语法可以简单、易于阅读且非常灵活。如果我们使用赋值语句，我们可以从单独的模块导入应用程序的配置细节。这个模块可以命名为settings.py，以表明该模块专注于配置参数。
- en: Because Python treats each imported module as a global Singleton object, we
    can have several parts of an application all use an import settings statement
    to get a consistent view of the current, global application configuration parameters.
    We don’t need to worry about managing an object using the Singleton design pattern,
    since that’s already part of Python.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Python将每个导入的模块视为一个全局Singleton对象，因此我们可以让应用程序的多个部分都使用import settings语句来获取当前全局应用程序配置参数的一致视图。我们不需要担心使用Singleton设计模式管理对象，因为Python已经包含了这部分。
- en: 'We’d like to be able to provide definitions in a text file that look like this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望能够在文本文件中提供如下定义：
- en: '[PRE20]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This configuration is a Python script. The parameters include two variables,
    query and base_url. The value of the query variable is a dictionary with a single
    key, ’mz’, and a sequence of values.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置是一个Python脚本。参数包括两个变量，query和base_url。query变量的值是一个包含单个键'mz'和一系列值的字典。
- en: This can be seen as a specification for a number of related URLs that are all
    similar to [http://forecast.weather.gov/shmrn.php?mz=ANZ532](http://forecast.weather.gov/shmrn.php?mz=ANZ532).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以被视为一系列相关URL的规范，这些URL都与[http://forecast.weather.gov/shmrn.php?mz=ANZ532](http://forecast.weather.gov/shmrn.php?mz=ANZ532)类似。
- en: We’ll often use the [Finding configuration files](ch017.xhtml#x1-7160001) recipe
    to check a variety of locations for a given configuration file. This flexibility
    is often essential for creating an application that’s easily used on a variety
    of platforms.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常使用[查找配置文件](ch017.xhtml#x1-7160001)的配方来检查给定配置文件的各种位置。这种灵活性对于创建易于在各种平台上使用的应用程序通常是必不可少的。
- en: 'In this recipe, we’ll build the missing part of the [Finding configuration
    files](ch017.xhtml#x1-7160001) recipe, the load_config_file() function. Here’s
    the template that needs to be filled in:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将构建[查找配置文件](ch017.xhtml#x1-7160001)配方中缺失的部分，即load_config_file()函数。以下是需要填写的模板：
- en: '[PRE21]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In this recipe, we’ll fill in the space held by the # Details omitted line
    to load configuration files in Python format.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将填充由# Details omitted行保留的空间，以在Python格式中加载配置文件。
- en: 13.3.2 How to do it...
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.3.2 如何做...
- en: 'We can make use of the pathlib module to locate the files. We’ll also leverage
    the built-in compile() and exec() functions to process the code in the configuration
    file:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用pathlib模块来定位文件。我们还将利用内置的compile()和exec()函数来处理配置文件中的代码：
- en: 'Import the Path definition and the type hints required by the load_config_file()
    function definition:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入Path定义和load_config_file()函数定义所需的类型提示：
- en: '[PRE22]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Use the built-in compile() function to compile the Python module into an executable
    form. This function requires the source text as well as the filename from which
    the text was read. The filename is essential for creating trace-back messages
    that are useful and correct:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用内置的 compile() 函数将 Python 模块编译成可执行形式。此函数需要源文本以及读取文本的文件名。文件名对于创建有用且正确的回溯消息至关重要：
- en: '[PRE23]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In rare cases where the code doesn’t come from a file, the general practice
    is to provide a name such as <string> for the filename.
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在代码不来自文件的情况下，通常的做法是为文件名提供一个名称，如 <string>。
- en: 'Execute the code object created by the compile() function. This requires two
    contexts. The global context provides any previously imported modules, plus the
    __builtins__ module. The local context is the locals dictionary; this is where
    new variables will be created:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行由 compile() 函数创建的代码对象。这需要两个上下文。全局上下文提供了任何先前导入的模块，以及 __builtins__ 模块。局部上下文是
    locals 字典；这是新变量将被创建的地方：
- en: '[PRE24]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This load_config_file() function produces the required dictionary structure.
    It can be fit into the design from the [Finding configuration files](ch017.xhtml#x1-7160001)
    recipe to load a configuration file using Python syntax.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 此 load_config_file() 函数生成所需的字典结构。它可以适应从 [查找配置文件](ch017.xhtml#x1-7160001) 配方中加载配置文件的设计，使用
    Python 语法。
- en: 13.3.3 How it works...
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.3.3 它是如何工作的...
- en: 'The details of the Python language – the syntax and semantics – are embodied
    in the built-in compile() and exec() functions. The three essential steps are
    these:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Python 语言细节——语法和语义——体现在内置的 compile() 和 exec() 函数中。三个基本步骤如下：
- en: Read the text.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取文本。
- en: Compile the text with the compile() function to create a code object.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 compile() 函数编译文本以创建代码对象。
- en: Use the exec() function to execute the code object.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 exec() 函数执行代码对象。
- en: The exec() function reflects the way Python handles global and local variables.
    There are two namespaces (mappings) provided to this function. These are visible
    via the globals() and locals() functions.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: exec() 函数反映了 Python 处理全局和局部变量的方式。为此函数提供了两个命名空间（映射）。这些可以通过 globals() 和 locals()
    函数访问。
- en: 'We can provide two distinct dictionaries to the exec() function:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以向 exec() 函数提供两个不同的字典：
- en: A dictionary of global objects. The most common use is to provide access to
    the imported modules, which are always global. The __builtins__ module can be
    provided in this dictionary. In some cases, other modules like pathlib should
    be added.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局对象的字典。最常见的用途是提供对导入的模块的访问，这些模块始终是全局的。可以在该字典中提供 __builtins__ 模块。在某些情况下，还需要添加其他模块，如
    pathlib。
- en: A dictionary for the locals that will be created (or updated) by each assignment
    statement. This local dictionary allows us to capture the variables created when
    executing the settings module.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于 locals 的字典，它将由每个赋值语句创建（或更新）。此局部字典允许我们在执行设置模块时捕获创建的变量。
- en: The locals dictionary will be updated by the exec() function. We don’t expect
    the globals to be updated and will ignore any changes that happen to this collection.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: exec() 函数将更新 locals 字典。我们预计全局字典不会被更新，并将忽略此集合发生的任何更改。
- en: 13.3.4 There’s more...
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.3.4 更多内容...
- en: This recipe suggests a configuration file is entirely a sequence of name = value
    assignment statements. The assignment statement is in Python syntax, as are the
    variable names and the literal syntax. This permits the configuration to leverage
    Python’s large collection of built-in types. Additionally, the full spectrum of
    Python statements is available. This leads to some engineering trade-offs.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方建议配置文件完全是一系列 name = value 赋值语句。赋值语句使用 Python 语法，变量名和字面量语法也是如此。这允许配置利用 Python
    的内置类型的大量集合。此外，Python 语句的全系列都可用。这导致了一些工程权衡。
- en: Because any statement can be used in the configuration file, it can lead to
    complexity. If the processing in the configuration file becomes too complex, the
    file ceases to be configuration and becomes a first-class part of the application.
    Very complex features should be implemented by modifying the application programming,
    not hacking around with the configuration settings. Python applications include
    the full source, as it is generally easier to fix the source than create hyper-complex
    configuration files. The goal is for a configuration file to provide values to
    tailor operations, not provide plug-in functionality.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 因为配置文件中可以使用任何语句，这可能导致复杂性。如果配置文件中的处理变得过于复杂，文件就不再是配置，而是应用程序的第一级部分。非常复杂的功能应该通过修改应用程序编程来实现，而不是通过配置设置进行黑客攻击。Python应用程序包含完整的源代码，因为通常修复源代码比创建超复杂的配置文件更容易。目标是让配置文件提供值以定制操作，而不是提供插件功能。
- en: We might want to include the OS environment variables as part of the global
    variables used for configuration. Doing this helps ensure the configuration values
    match the current environment settings. This can be done with the os.environ mapping.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能希望将操作系统环境变量作为配置的全局变量的一部分。这样做有助于确保配置值与当前环境设置匹配。这可以通过os.environ映射来完成。
- en: 'It can also be sensible to do some processing for related settings. For example,
    it can be helpful to write a configuration file with a number of adjacent paths
    like this:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 对于相关设置进行一些处理也是合理的。例如，编写一个包含多个相邻路径的配置文件可能会有所帮助：
- en: '[PRE25]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In many cases, the settings file is edited by a person who can be trusted. Mistakes
    do happen, though, and it’s wise to be careful about what functions are available
    in the dictionary of globals provided to the exec() function. Providing the narrowest
    set of functions to support configuration is the recommended practice.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，设置文件是由可以信赖的人编辑的。尽管如此，错误仍然会发生，因此对提供给exec()函数的全局字典中可用的函数保持谨慎是明智的。提供最窄的函数集以支持配置是推荐的做法。
- en: 13.3.5 See also
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.3.5 参见
- en: See the [Finding configuration files](ch017.xhtml#x1-7160001) recipe earlier
    in this chapter to learn how to search multiple filesystem locations for a configuration
    file.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅本章前面的[查找配置文件](ch017.xhtml#x1-7160001)配方，了解如何搜索多个文件系统位置以查找配置文件。
- en: 13.4 Using a class as a namespace for configuration
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 13.4 使用类作为配置的命名空间
- en: Python offers a variety of ways to package application inputs and configuration
    files. We’ll continue to look at writing files in Python notation because it’s
    elegant and the familiar syntax can lead to easy-to-read configuration files.
    A number of projects allow us to use a class definition to provide configuration
    parameters. This uses Python syntax, of course. It also uses the class definition
    as a namespace to allow multiple configurations to be provided in a single module.
    The use of a class hierarchy means that inheritance techniques can be used to
    simplify the organization of parameters.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了多种打包应用程序输入和配置文件的方法。我们将继续探讨使用Python符号编写文件，因为它优雅且熟悉的语法可以导致易于阅读的配置文件。许多项目允许我们使用类定义来提供配置参数。这当然使用Python语法。它还使用类定义作为命名空间，以允许在单个模块中提供多个配置。使用类层次结构意味着可以使用继承技术来简化参数的组织。
- en: This avoids the use of a ChainMap to permit user-specific overrides of generic
    settings. Instead, this uses ordinary inheritance.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这避免了使用ChainMap来允许用户对通用设置进行特定覆盖。相反，它使用普通的继承。
- en: We’re never going to create instances of these classes. We’re going to use the
    attributes of the class definition and rely on class inheritance methods to track
    down the appropriate value for an attribute. This will differ from the other recipes
    in this chapter because it will produce a ConfigClass object, instead of a dict[str, Any]
    object.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们永远不会创建这些类的实例。我们将使用类定义的属性并依赖类继承方法来追踪属性的适当值。这与本章中的其他配方不同，因为它将生成一个ConfigClass对象，而不是一个dict[str,
    Any]对象。
- en: In this recipe, we’ll look at how we can represent configuration details in
    Python class notation.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们将探讨如何使用Python类符号表示配置细节。
- en: 13.4.1 Getting ready
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.4.1 准备工作
- en: Python notation for defining the attributes of a class can be simple, easy to
    read, and reasonably flexible. We can, with a little work, define a sophisticated
    configuration language that allows someone to change configuration parameters
    for a Python application quickly and reliably.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Python定义类属性的方式可以简单、易于阅读，并且相当灵活。我们可以通过一些工作，定义一个复杂的配置语言，允许某人快速且可靠地更改Python应用程序的配置参数。
- en: We can base this language on class definitions. This allows us to package a
    number of configuration alternatives in a single module. An application can load
    the module and pick the relevant class definition from the module.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这种语言基于类定义。这允许我们将多个配置选项打包在一个模块中。应用程序可以加载该模块并从模块中选择相关的类定义。
- en: 'We’d like to be able to provide definitions that look like this:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望能够提供如下所示的定义：
- en: '[PRE26]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can create this class definition in a settings.py file to create a settings
    module. To use the configuration, the main application could do this:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在settings.py文件中创建这个类定义来创建一个设置模块。要使用配置，主应用程序可以这样做：
- en: '[PRE27]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The application will gather the settings using the module name of settings with
    a class name of Configuration.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序将使用名为settings的模块名和名为Configuration的类名来收集设置。
- en: The configuration file locations follow Python’s rules for finding modules.
    Rather than implementing our own search for the configuration, we can leverage
    Python’s built-in search of sys.path, and the use of the PYTHONPATH environment
    variable.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件的存储位置遵循Python查找模块的规则。我们不需要自己实现配置的搜索，而是可以利用Python内置的sys.path搜索以及PYTHONPATH环境变量的使用。
- en: 'In this recipe, we’ll build a missing part that’s similar to the [Finding configuration
    files](ch017.xhtml#x1-7160001) recipe, the load_config_file() function. However,
    there will be an important difference: we’ll return an object instead of a dictionary.
    We can then refer to configuration values by attribute name instead of using the
    more cumbersome notation of a dictionary. Here’s the revised template that needs
    to be filled in:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将构建一个类似于[查找配置文件](ch017.xhtml#x1-7160001)菜谱的缺失部分，即load_config_file()函数。然而，会有一个重要的区别：我们将返回一个对象而不是一个字典。然后我们可以通过属性名来引用配置值，而不是使用更繁琐的字典表示法。以下是需要填写的修订模板：
- en: '[PRE28]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We’ve used a similar template in a number of recipes in this chapter. For this
    recipe, we’ve added a parameter to this definition and changed the return type.
    The classname parameter is not present in previous recipes, but it is used here
    to select one of the classes from a module at the location in the filesystem named
    by the config_path parameter.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章的多个菜谱中使用了类似的模板。对于这个菜谱，我们添加了一个参数并更改了返回类型。在之前的菜谱中，没有classname参数，但在这里它被用来从由config_path参数命名的文件系统位置选择模块中的一个类。
- en: 13.4.2 How to do it...
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.4.2 如何实现...
- en: 'We can make use of the pathlib module to locate the files. We’ll leverage the
    built-in compile() and exec() functions to process the code in the configuration
    file:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用pathlib模块来定位文件。我们将利用内置的compile()和exec()函数来处理配置文件中的代码：
- en: 'Import the Path definition and the type hints required by the load_config_file()
    function definition:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入Path定义以及load_config_file()函数定义所需的类型提示：
- en: '[PRE29]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Use the built-in compile() function to compile the Python module into an executable
    form. This function requires the source text as well as a filename from which
    the text was read. The filename is essential for creating trace-back messages
    that are useful and correct:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用内置的compile()函数将Python模块编译成可执行形式。此函数需要源文本以及从其中读取文本的文件名。文件名对于创建有用且正确的回溯消息是必不可少的：
- en: '[PRE30]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Execute the code object created by the compile() method. We need to provide
    two contexts. The global context can provide the __builtins__ module, plus the
    Path class and the platform module. The local context is where new variables will
    be created:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行由compile()方法创建的代码对象。我们需要提供两个上下文。全局上下文可以提供__builtins__模块、Path类和platform模块。局部上下文是新变量将被创建的地方：
- en: '[PRE31]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This locates the named class in the locals() mapping and returns the class as
    the configuration object. This does not return a dictionary.
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将在locals()映射中定位命名的类并返回该类作为配置对象。这不会返回一个字典。
- en: This variation on the load_config_file() function produces a useful structure
    that can be accessed using attribute names. It does not provide the design expected
    by the [Finding configuration files](ch017.xhtml#x1-7160001) recipe. The resulting
    configuration object does – because it uses attribute names – more useful than
    a simple dictionary.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在 load_config_file() 函数的这种变体中，产生了一个有用的结构，可以通过属性名称来访问。它并不提供 [查找配置文件](ch017.xhtml#x1-7160001)
    菜单中预期的设计。由于它使用属性名称，因此产生的配置对象比简单的字典更有用。
- en: 13.4.3 How it works...
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.4.3 它是如何工作的...
- en: 'We can load a Python module by using compile() and exec(). From the module,
    we can extract an individual class name that contains the various application
    settings. Overall, it looks like the following example:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用 compile() 和 exec() 来加载 Python 模块。从模块中，我们可以提取包含各种应用程序设置的单独类名。总体来说，它看起来像以下示例：
- en: '[PRE32]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We can put any kind of object into the attributes of the configuration class.
    Our example showed lists of strings and strings. Any object of any class becomes
    a possibility when using class definitions.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将任何类型的对象放入配置类的属性中。我们的示例显示了字符串列表和字符串。使用类定义时，任何类的任何对象都成为可能。
- en: We can have complex calculations within the class statement. We can use this
    to create attributes that are derived from other attributes. We can execute any
    kind of statement, including if statements and for statements, to create attribute
    values.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在类声明中包含复杂的计算。我们可以使用这个功能来创建由其他属性派生出来的属性。我们可以执行任何类型的语句，包括 if 语句和 for 语句，来创建属性值。
- en: We will not, however, create an instance of the given class. Tools like Pydantic
    will validate instances of a class, but aren’t helpful for validating a class
    definition. Any kind of validation rules would have to be defined in a metaclass
    that is used to build the resulting configuration class. Additionally, ordinary
    methods of the class will not be used. If a function-like definition is needed,
    it would have to be decorated with @classmethod to be useful.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不会创建给定类的实例。像 Pydantic 这样的工具将验证类的实例，但对于验证类定义并不有帮助。任何类型的验证规则都必须定义在用于构建结果配置类的元类中。此外，类的一般方法将不会被使用。如果需要一个类似函数的定义，它必须用
    @classmethod 装饰器来使其有用。
- en: 13.4.4 There’s more...
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.4.4 更多...
- en: Using a class definition means that we will leverage inheritance to organize
    the configuration values. We can easily create multiple subclasses of Configuration,
    one of which will be selected for use in the application.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类定义意味着我们将利用继承来组织配置值。我们可以轻松地创建 Configuration 的多个子类，其中一个将被选中用于应用程序。
- en: 'The configuration might look like this:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 配置可能看起来像这样：
- en: '[PRE33]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Our application must choose an appropriate class from the available classes
    in the settings module. We might use an OS environment variable or a command-line
    option to specify the class name to use. The idea is that our program can be executed
    like this:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序必须从 settings 模块中可用的类中选择一个合适的类。我们可能使用操作系统环境变量或命令行选项来指定要使用的类名。我们的程序可以这样执行：
- en: '[PRE34]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This would locate the Chesapeake class in the settings module. Processing would
    then be based on the details in that particular configuration class. This idea
    leads to an extension to the load_config_class() function.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这将定位 settings 模块中的 Chesapeake 类。然后，处理将基于该特定配置类中的详细信息。这个想法导致了 load_config_class()
    函数的扩展。
- en: 'In order to pick one of the available classes, we can separate the module name
    and class name by looking for a "." separator in the command-line argument value:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 为了选择一个可用的类，我们可以通过在命令行参数值中查找 "." 分隔符来分隔模块名称和类名称：
- en: '[PRE35]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Rather than manually compiling and executing the module, we’ve used the higher-level
    importlib module. This module contains functions implementing the import statement
    semantics. The requested module is imported, then compiled and executed, and the
    resulting module object is assigned to the variable named result.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是手动编译和执行模块，而是使用了更高层次的 importlib 模块。此模块包含实现导入语句语法的函数。请求的模块被导入，然后编译和执行，结果模块对象被分配给名为
    result 的变量。
- en: 'Now we can use this function as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以如下使用这个函数：
- en: '[PRE36]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We’ve located the Chesapeake configuration class in the settings module and
    extracted the various settings the application needs from this class.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在 settings 模块中找到了 Chesapeake 配置类，并从中提取了应用程序需要的各种设置。
- en: 13.4.5 See also
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.4.5 参见
- en: We’ll look at class definitions in detail in Chapter [7](ch011_split_000.xhtml#x1-3760007),
    and Chapter [8](ch012.xhtml#x1-4520008).
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将在第[7](ch011_split_000.xhtml#x1-3760007)章和第[8](ch012.xhtml#x1-4520008)章中详细探讨类定义。
- en: See the [Finding configuration files](ch017.xhtml#x1-7160001) recipe in this
    chapter for an alternative approach that doesn’t use class definitions.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章中查看[查找配置文件](ch017.xhtml#x1-7160001)的配方，了解一种不使用类定义的替代方法。
- en: 13.5 Designing scripts for composition
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 13.5 设计用于组合的脚本
- en: An important part of overall application design is creating a script that can
    process command-line arguments and configuration files. Further, it’s very important
    to design a script so that it can be tested as well as combined with other scripts
    into a composite application.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 整体应用程序设计的一个重要部分是创建一个可以处理命令行参数和配置文件的脚本。此外，设计脚本以便它可以被测试以及与其他脚本组合成一个复合应用程序也非常重要。
- en: 'The idea is that many good ideas evolve through a series of stages. One such
    evolution might be the following path:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 想法是这样的：许多好主意通过一系列阶段演变而来。这样的演变可能是一条以下路径：
- en: The idea starts as a collection of separate notebooks for separate parts of
    a larger task.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个想法最初是一系列单独的笔记本，用于处理更大任务的不同部分。
- en: After the initial period of exploration and experimentation, this becomes a
    simple repetitive task. Rather than open and click manually to run the notebook,
    it’s saved into a script file, Then the script files can be run from the command
    line.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在探索和实验的初期阶段之后，这变成了一项简单的重复性任务。与其手动打开和点击来运行笔记本，不如将其保存到脚本文件中，然后可以从命令行运行这些脚本文件。
- en: After an initial period of making this a regular part of the organization’s
    operations, the three-part script needs to be consolidated into a single script.
    At this point, refactoring is needed.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在将这一过程作为组织运营的常规部分的一段时间后，三部分脚本需要合并成一个单一的脚本。此时，需要进行重构。
- en: The most painful time to refactor is after combining a number of scripts into
    a single application and uncovering unexpected problems. This often happens because
    global variables will be shared when multiple scripts are integrated.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在将多个脚本组合成一个应用程序并发现意外问题时，重构是最痛苦的时刻。这通常是因为当多个脚本集成时，全局变量将被共享。
- en: A much less painful time is earlier in the life of the project. As soon as a
    script is created, some effort should be made to design the script for testing
    and composition into a larger application.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目生命周期的早期，这是一个不那么痛苦的时刻。一旦创建了脚本，就应该努力设计脚本以便进行测试和组合到更大的应用程序中。
- en: 13.5.1 Getting ready
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.5.1 准备工作
- en: In this recipe, we’ll look at what constitutes a good design for a script. In
    particular, we want to be sure that parameters and configuration files are considered
    in the design.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将探讨构成脚本良好设计的要素。特别是，我们想要确保在设计时考虑参数和配置文件。
- en: 'The target is to have a structure like the following:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是拥有以下结构：
- en: A docstring for the module or script as a whole.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对整个模块或脚本的一个文档字符串。
- en: The imports. There’s an internal ordering to these. Tools like isort and ruff
    can handle this.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入语句。这些有一个内部顺序。像isort和ruff这样的工具可以处理这个问题。
- en: The class and function definitions that apply to the script.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用于脚本的类和函数定义。
- en: A function to gather the configuration file options and runtime parameters into
    a single object that can be used by other classes and functions.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个函数，用于将配置文件选项和运行时参数收集到一个单一的对象中，该对象可以被其他类和函数使用。
- en: A single function that does the useful work. This is often called main(), but
    there’s nothing sacred about this name.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个执行有用工作的单个函数。这通常被称为main()，但这个名字并没有什么神圣的。
- en: 'A small block of code that is executed only when the module is run as a script,
    and never when the module is imported:'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个只有当模块作为脚本运行时才会执行的小块代码，而模块被导入时则不会执行：
- en: '[PRE37]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 13.5.2 How to do it...
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.5.2 如何实现...
- en: 'With the target design as our goal, here is one approach:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 以目标设计为目标，这里有一个方法：
- en: 'Start by writing a summary docstring at the top of the file. It’s important
    to start with something and add details later. Here’s an example:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先在文件顶部编写一个总结文档字符串。开始时先有一个大致的想法，然后再添加细节。以下是一个示例：
- en: '[PRE38]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The import statements go after the docstring. It’s not always possible to foresee
    all of the imports in advance. As the module is being written and modified, imports
    will be added and removed.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入语句跟在文档字符串后面。事先预见所有导入并不总是可能的。随着模块的编写和修改，导入将被添加和删除。
- en: The class and function definitions go next. The order is important for resolving
    the type names in the def or class statements. This means the most fundamental
    type definitions must go first.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是类和函数的定义。顺序对于在 def 或 class 语句中解析类型名称很重要。这意味着最基本类型定义必须首先进行。
- en: Again, it’s not always possible to write all the definitions in their proper
    order during the first wave of design. What’s important is keeping them together
    in a logical organization and rearranging them so the order makes sense to someone
    reading the code.
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 再次强调，在设计的第一波中，并不总是能够按照正确的顺序编写所有定义。重要的是保持它们在逻辑组织中的统一，并重新排列它们，以便阅读代码的人能够理解顺序。
- en: Write a function (with a name like get_config()) to get all of the configuration
    parameters. Generally, there are two parts to this; sometimes they need to be
    decomposed into two separate functions because each part can be rather complicated.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个函数（例如 get_config()），用于获取所有配置参数。通常，这包括两个部分；有时需要将它们分解为两个单独的函数，因为每个部分可能相当复杂。
- en: Then we have the main() function. This does the essential work of the script.
    When evolving from a notebook, this can be built from the sequence of cells.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后是 main() 函数。它执行脚本的必要工作。当从笔记本演变而来时，这可以由单元格序列构建。
- en: 'Add the Main-Import Switch code block at the end:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在最后添加 Main-Import 切换代码块：
- en: '[PRE39]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The resulting module will work properly as a script. It can also be tested more
    easily because testing tools like pytest can import the module without it making
    changes to the filesystem when it tries to starting processing data. It can be
    integrated with other scripts to create a useful composite application.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的模块将作为脚本正常工作。它还可以更容易地进行测试，因为测试工具如 pytest 可以导入模块，而无需在尝试处理数据时对文件系统进行更改。它可以与其他脚本集成，以创建有用的复合应用程序。
- en: 13.5.3 How it works...
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.5.3 它是如何工作的...
- en: 'The core consideration in designing a script is distinguishing between two
    use cases for a module:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 设计脚本时的核心考虑是区分模块的两个用途：
- en: When run from the command line. In this case, the built-in global variable __name__
    will have a value of "__main__".
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当从命令行运行时。在这种情况下，内置的全局变量 __name__ 将具有 "__main__" 的值。
- en: When imported for testing or as part of a larger, composite application. In
    this case, __name__ will have a value that is the name of the module.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当作为测试的一部分或作为更大、复合应用程序的一部分导入时。在这种情况下，__name__ 将具有模块的名称值。
- en: When a module is imported, we do not want it to start doing work. During import,
    we don’t want the module to open files, read data, do computations, or produce
    output. All of this work is something that can only happen when the module is
    run as the main program.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 当导入模块时，我们不希望它开始执行工作。在导入过程中，我们不希望模块打开文件、读取数据、进行计算或产生输出。所有这些工作都是在模块作为主程序运行时才能发生的事情。
- en: The original cells of the notebook or script statements are now part of the
    body of the main() function, so the script will work properly. It will, however,
    it will also be in a form that can be tested. It can also be integrated into a
    larger and more sophisticated application.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 笔记本或脚本语句的原始单元格现在成为 main() 函数的主体，因此脚本将正常工作。然而，它也将以可以测试的形式存在。它还可以集成到更大、更复杂的应用程序中。
- en: 13.5.4 There’s more...
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.5.4 更多内容...
- en: 'When starting the conversion to an application, the main() function is often
    quite lengthy. There are two ways to make the processing clear:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始将代码转换为应用程序时，main() 函数通常相当长。有两种方法可以使处理过程更清晰：
- en: Large, prominent billboard comments
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显著的公告牌注释
- en: Refactoring to create a number of smaller functions
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过重构创建多个较小的函数
- en: 'We might start with a script that has comments like these:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能从一个具有如下注释的脚本开始：
- en: '[PRE40]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The In[n]: comments are provided by JupyterLab to identify the cells in a notebook.
    We can create billboard comments like these:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 'In[n]: 注释由 JupyterLab 提供，用于识别笔记本中的单元格。我们可以创建类似这样的公告牌注释：'
- en: '[PRE41]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This is less than ideal. It’s an acceptable temporary measure, but these steps
    should be proper functions, each with a docstring and test cases. Billboard comments
    are traditional in languages that don’t have proper docstrings and lack documentation
    generators that exploit the docstrings.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不理想。这是一个可接受的临时措施，但这些步骤应该是适当的函数，每个函数都有一个文档字符串和测试用例。在那些没有适当文档字符串且缺乏利用文档字符串的文档生成器的语言中，公告牌注释是传统的。
- en: Python has docstrings and several tools – like Sphinx – to create documentation
    from the docstrings.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: Python 有文档字符串和几个工具——如 Sphinx——可以从文档字符串创建文档。
- en: 13.5.5 See also
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.5.5 相关内容
- en: See the [Using argparse to get command-line input](ch010.xhtml#x1-3490004) recipe
    in Chapter [6](ch010.xhtml#x1-3300006), for background on using argparse to get
    inputs from a user.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关使用argparse从用户获取输入的背景信息，请参阅第[6](ch010.xhtml#x1-3300006)章中的[使用argparse获取命令行输入](ch010.xhtml#x1-3490004)配方。
- en: See [Using TOML for configuration files](ch017.xhtml#x1-7230002), [Using Python
    for configuration files](ch017.xhtml#x1-7290003), and [Using a class as a namespace
    for configuration](ch017.xhtml#x1-7350004) in this chapter for recipes related
    to configuration files.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章中，请参阅[使用TOML配置文件](ch017.xhtml#x1-7230002)、[使用Python配置文件](ch017.xhtml#x1-7290003)和[使用类作为配置命名空间](ch017.xhtml#x1-7350004)的相关配方。
- en: The [Using logging for control and audit output](ch017.xhtml#x1-7470006) recipe
    later in this chapter looks at logging.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章后面的[使用日志记录进行控制和审计输出](ch017.xhtml#x1-7470006)配方探讨了日志记录。
- en: In the [Combining two applications into one](ch018.xhtml#x1-7590001) recipe
    in Chapter [14](ch018.xhtml#x1-75800014), we’ll look at ways to combine applications
    that follow this design pattern.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第[14](ch018.xhtml#x1-75800014)章的[将两个应用程序合并为一个](ch018.xhtml#x1-7590001)配方中，我们将探讨遵循此设计模式的应用程序组合方法。
- en: The details of testing and integration are covered in separate chapters. See
    Chapter [15](ch019_split_000.xhtml#x1-79400015) for details on creating tests.
    See Chapter [14](ch018.xhtml#x1-75800014) for details on combining applications.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试和集成的详细信息在其他章节中介绍。有关创建测试的详细信息，请参阅第[15](ch019_split_000.xhtml#x1-79400015)章。有关组合应用程序的详细信息，请参阅第[14](ch018.xhtml#x1-75800014)章。
- en: 13.6 Using logging for control and audit output
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 13.6 使用日志记录进行控制和审计输出
- en: 'When we consider an application, we can decompose the overall computation into
    three distinct aspects:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们考虑一个应用程序时，我们可以将整体计算分解为三个不同的方面：
- en: Gathering input
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收集输入
- en: The essential processing that transforms the input into the output
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将输入转换为输出的基本处理过程
- en: Producing output
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成输出
- en: 'There are several different kinds of output that applications produce:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序会产生几种不同的输出：
- en: The main output that helps a user make a decision or take action. In some cases,
    this might be a JSON-formatted document downloaded by a web server. It might be
    a more complicated collection of documents that – together – will create a PDF
    file.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主要输出有助于用户做出决策或采取行动。在某些情况下，这可能是通过Web服务器下载的JSON格式文档。它可能是一组更复杂的文档，这些文档一起创建一个PDF文件。
- en: Control information that confirms that the program worked completely and correctly.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确认程序完全且正确运行的控件信息。
- en: Audit summaries that can be used to track the history of state changes in a
    persistent databases.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以用来跟踪持久数据库中状态变化历史的审计摘要。
- en: Any error messages that indicate why the application didn’t work.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何指示应用程序为何无法工作的错误消息。
- en: It’s less than optimal to lump all of these various aspects into print() requests
    that write to standard output. Indeed, it can lead to confusion because too many
    different outputs can be interleaved in a single stream.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些不同的方面都合并到写入标准输出的print()请求中并不是最佳选择。实际上，这可能会导致混淆，因为太多的不同输出可能会在单个流中交错。
- en: The OS provides each running process with two output files, standard output
    and standard error. These are visible in Python through the sys module with the
    names sys.stdout and sys.stderr. By default, the print() function writes to the
    sys.stdout file. We can change the target file and write the control, audit, and
    error messages to sys.stderr. This is an important step in the right direction.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统为每个运行进程提供两个输出文件，标准输出和标准错误。这些在Python中通过sys模块的sys.stdout和sys.stderr名称可见。默认情况下，print()函数写入sys.stdout文件。我们可以更改目标文件，并将控制、审计和错误消息写入sys.stderr。这是正确方向上的一个重要步骤。
- en: Python also offers the logging package, which can be used to direct the ancillary
    output to a separate file (and/or other output channels, such as a database).
    It can also be used to format and filter that additional output.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: Python还提供了日志记录包，可以用来将辅助输出导向一个单独的文件（以及/或其他输出通道，如数据库）。它还可以用来格式化和过滤额外的输出。
- en: In this recipe, we’ll look at good ways to use the logging module.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将探讨使用日志模块的好方法。
- en: 13.6.1 Getting ready
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.6.1 准备工作
- en: One approach to meeting a variety of output needs is to create multiple loggers,
    each with a different intent. It’s common to name loggers around the module or
    class associated with the logger. We can also name loggers around an overall purpose,
    like audit or control.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 满足各种输出需求的一种方法是创建多个记录器，每个记录器具有不同的意图。通常，记录器的命名与记录器关联的模块或类相关。我们也可以围绕审计或控制等整体目的命名记录器。
- en: The names of loggers form a hierarchy, punctuated by .. The root logger is the
    parent of all loggers and has a name of "". This suggests that we can have families
    of loggers focused on particular classes, modules, or features.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 记录器的名称构成一个层次结构，由..分隔。根记录器是所有记录器的父级，名称为""。这表明我们可以有专注于特定类、模块或功能的记录器家族。
- en: 'A set of top-level loggers can include a number of separate focus areas, including:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 一组顶级记录器可以包括多个不同的关注领域，包括：
- en: error will preface all loggers for warnings and errors.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误将为警告和错误的所有记录器添加前缀。
- en: debug will preface all loggers for debugging messages.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试将为调试消息的所有记录器添加前缀。
- en: audit will name loggers with counts and totals used to confirm that data was
    processed fully.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审计将命名带有计数和总计的记录器，用于确认数据已被完全处理。
- en: control will name loggers that provide information about when the application
    was run, the environment, configuration files, and command-line argument values.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制将命名提供有关应用程序运行时间、环境、配置文件和命令行参数值的记录器。
- en: In most cases, it is helpful to have errors and debugging in a single logger.
    In other cases – for example, a web server – the request error response log should
    be separate from any internal error or debugging log.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，将错误和调试放在单个记录器中是有帮助的。在其他情况下——例如，一个网络服务器——请求错误响应日志应与任何内部错误或调试日志分开。
- en: A complicated application might have several loggers with names like audit.input
    and audit.output to show the counts of data consumed and the counts of data produced.
    Keeping these separate can help focus attention on problems with data providers.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 一个复杂的应用程序可能包含几个名为audit.input和audit.output的记录器，以显示消耗的数据计数和生成数据的计数。将这些记录器分开可以帮助关注数据提供者的问题。
- en: 'A severity level serves as a kind of filter for each logger. The severity levels
    defined in the logging package include the following:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 严重程度级别为每个记录器提供了一种过滤机制。在日志包中定义的严重程度级别包括以下内容：
- en: 'DEBUG: These messages are not generally shown since their intent is to support
    debugging. Above, we suggested this is a distinct variety of debugging. We suggest
    an application create a logging debugger, and use ordinary INFO messages for the
    debugging entries.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 调试：这些消息通常不会显示，因为它们的目的是支持调试。上面，我们建议这是一种独特的调试类型。我们建议应用程序创建一个日志调试器，并使用普通的INFO消息进行调试条目。
- en: 'INFO: These messages provide information on the normal, happy-path processing.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 信息：这些消息提供了有关正常、愉快的处理过程的信息。
- en: 'WARNING: These messages indicate that processing may be compromised in some
    way. The most sensible use case for a warning is when functions or classes have
    been deprecated: they still work, but they should be replaced.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：这些消息表明处理可能以某种方式受损。警告的最合理用例是当函数或类已被弃用时：它们仍然工作，但应该被替换。
- en: 'ERROR: Processing is invalid and the output is incorrect or incomplete. In
    the case of a long-running server, an individual request may have problems, but
    the server as a whole can continue to operate.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 错误：处理无效，输出不正确或不完整。在长时间运行的服务器的情况下，单个请求可能存在问题，但服务器整体可以继续运行。
- en: 'CRITICAL: A more severe level of error. Generally, this is used by long-running
    servers where the server itself can no longer operate and is about to crash.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 严重：更严重的错误级别。通常，这用于长时间运行的服务器，其中服务器本身无法继续运行，即将崩溃。
- en: Each logger has method names that are similar to the severity levels. We use
    the info() method to write a message with the INFO severity level.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 每个记录器都有与严重程度级别相似的方法名称。我们使用info()方法以INFO严重程度级别写入消息。
- en: For error handling, the severity levels are mostly appropriate. A debugging
    logger, however, often produces volumes of data that need to be kept separate.
    Further, any audit and control output doesn’t seem to have a severity level. The
    severity level seems to be focused only on error logging. For this reason, it
    seems to be better to have distinct logs with names like debug.some_function.
    We can then configure debugging by enabling or disabling the output from these
    loggers, and configure the severity level to be INFO.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 对于错误处理，严重级别大多是合适的。然而，调试日志记录器通常会生成大量需要单独保留的数据。此外，任何审计和控制输出似乎没有严重级别。严重级别似乎仅关注错误日志记录。因此，似乎更好的是具有如debug.some_function之类的名称的独立日志。然后我们可以通过启用或禁用这些日志记录器的输出以及配置严重级别为INFO来配置调试。
- en: 13.6.2 How to do it...
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.6.2 如何实现...
- en: We’ll look at logging in a class as well as a function in two mini-recipes.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在两个迷你食谱中查看类和函数中的日志记录。
- en: Logging in a class
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在类中记录日志
- en: Be sure the logging module is imported.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保已导入日志记录模块。
- en: 'In the __init__() method, include the following to create an error and debug
    loggers:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在__init__()方法中，包括以下内容以创建错误和调试日志记录器：
- en: '[PRE42]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In any method that might require future debugging, use the debug logger’s methods
    to write details to the log. While f-strings can be used to write log messages,
    they involve a bit of overhead to interpolate values into the text. Using the
    logger’s formatting options and separate argument values involves slightly less
    computation when the configuration silences the logger’s output:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在任何可能需要未来调试的方法中，使用调试日志记录器的函数将详细信息写入日志。虽然可以使用f-string来编写日志消息，但它们涉及将值插入文本的一些开销。当配置静默日志记录器的输出时，使用日志记录器的格式化选项和单独的参数值涉及的计算量略少：
- en: '[PRE43]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In a few key places, include overall status messages. These are often in the
    overall application control classes:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在几个关键位置，包含整体状态消息。这些通常在整体应用程序控制类中：
- en: '[PRE44]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Logging in a function
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在函数中记录日志
- en: Be sure the logging module is imported.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保已导入日志记录模块。
- en: 'For larger and more complicated functions, it makes sense to include the logger
    inside the function:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于更大和更复杂的函数，将日志记录器包含在函数内部是有意义的：
- en: '[PRE45]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Because the loggers are cached, only the first request to get_logger() involves
    any significant overhead. All subsequent requests are dictionary lookups.
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于日志记录器被缓存，第一次调用get_logger()时才会涉及任何显著的开销。所有后续请求都是字典查找。
- en: 'For smaller functions, it can make sense to have a globally defined logger.
    This can help to reduce visual clutter within a function’s body:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于较小的函数，全局定义日志记录器是有意义的。这有助于减少函数体内的视觉混乱：
- en: '[PRE46]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Note that without any further configuration, no output will be produced. This
    is because the default severity level for each logger will be WARNING, which means
    the handler will not show INFO- or DEBUG-level messages..
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果没有进一步的配置，将不会产生任何输出。这是因为每个日志记录器的默认严重级别将是WARNING，这意味着处理程序将不会显示INFO-或DEBUG级别的消息。
- en: 13.6.3 How it works...
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.6.3 它是如何工作的...
- en: 'There are three parts to introducing logging into an application:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 引入日志记录到应用程序中有三个部分：
- en: Creating Logger objects with the getLogger() function.
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用getLogger()函数创建Logger对象。
- en: Placing log messages near important state changes with one of the methods similar
    to info() or error() for each logger.
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用类似于info()或error()的每个日志记录器的方法之一，将日志消息放置在重要的状态变化附近。
- en: Configuring the logging system as a whole when the application is run. This
    is essential for seeing output from the loggers. We’ll look at this in the There’s
    more... section of this recipe.
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当应用程序运行时，整体配置日志系统。这对于查看日志记录器的输出至关重要。我们将在本食谱的There’s more...部分中探讨这一点。
- en: 'Creating loggers can be done in a variety of ways. A common approach is to
    create one logger with the same name as the module:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 创建日志记录器可以通过多种方式完成。一种常见的方法是创建一个与模块同名的日志记录器：
- en: '[PRE47]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: For the top-level main script, this will have the name __main__. For imported
    modules, the name will match the module name.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 对于顶级主脚本，这将具有__main__的名称。对于导入的模块，名称将与模块名称匹配。
- en: In more complex applications, there could be a variety of loggers serving a
    variety of purposes. In these cases, simply naming a logger after a module may
    not provide the required level of flexibility.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在更复杂的应用程序中，可能有各种日志记录器服务于各种目的。在这些情况下，仅仅将日志记录器命名为模块名称可能不足以提供所需级别的灵活性。
- en: It’s also possible to use the logging module itself as the root logger. This
    means a module can use the logging.info() function, for example. This isn’t recommended
    because the root logger is anonymous, and we sacrifice the possibility of using
    the logger name as an important source of information.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用日志模块本身作为根记录器。这意味着一个模块可以使用 logging.info() 函数，例如。这不推荐，因为根记录器是匿名的，我们牺牲了使用记录器名称作为重要信息来源的可能性。
- en: This recipe suggests naming loggers based on the audience or use case. The topmost
    name – for example, debug. – will distinguish the audience or purpose for the
    log. This can make it easy to route all loggers under a given parent to a specific
    handler.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方建议根据受众或用例命名记录器。最顶层的名称——例如，debug.——将区分日志的受众或目的。这可以使将给定父记录器下的所有记录器路由到特定处理器变得容易。
- en: It’s helpful to associate logging messages with the important state changes
    made by the code.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 将日志消息与代码执行的重要状态变化相关联是有帮助的。
- en: The third aspect of logging is configuring the loggers so that they route the
    requests to the appropriate destination. By default, with no configuration at
    all, the logger instances will quietly ignore the various messages being created.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 记录的第三个方面是配置记录器，以便它们将请求路由到适当的目的地。默认情况下，如果没有进行任何配置，记录器实例将默默地忽略正在创建的各种消息。
- en: 'With a minimal configuration, we can see all of the log events on the console.
    This can be done with the following:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 使用最小配置，我们可以在控制台上看到所有日志事件。这可以通过以下方式完成：
- en: '[PRE48]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 13.6.4 There’s more...
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.6.4 更多内容...
- en: 'In order to route the different loggers to different destinations, we’ll need
    a more sophisticated configuration. Often, this goes beyond what we can build
    with the basicConfig() function. We’ll need to use the logging.config module and
    the dictConfig() function. This can provide a complete set of configuration options.
    The easiest way to use this function is to write the configuration in TOML:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将不同的记录器路由到不同的目的地，我们需要更复杂的配置。通常，这超出了我们使用 basicConfig() 函数所能构建的内容。我们需要使用 logging.config
    模块和 dictConfig() 函数。这可以提供完整的配置选项。使用此函数的最简单方法是使用 TOML 编写配置：
- en: '[PRE49]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Here are some key points in this TOML configuration:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 TOML 配置中，以下是一些关键点：
- en: The value of the version key must be 1\. This is required.
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本键的值必须是 1。这是必需的。
- en: 'The values in the formatters table define the log formats available. If a formatter
    is not specified, a built-in formatter will display the message body only:'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 格式化程序表中的值定义了可用的日志格式。如果没有指定格式化程序，内置的格式化程序将只显示消息正文：
- en: The default formatter defined in the example mirrors the format created by the
    basicConfig() function. This includes the message severity level and the logger
    name.
  id: totrans-340
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例中定义的默认格式化程序与 basicConfig() 函数创建的格式相匹配。这包括消息严重级别和记录器名称。
- en: The new timestamp formatter defined in the example is a more complex format
    that includes the date-time stamp for the record. To make the file easier to parse,
    a column separator of // was used.
  id: totrans-341
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例中定义的新日期时间戳格式化程序是一个更复杂的格式，它包括记录的日期时间戳。为了使文件更容易解析，使用了 // 作为列分隔符。
- en: 'The handlers table defines the handlers available for loggers to use:'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理器表定义了记录器可用的处理器：
- en: The console handler writes to the sys.stderr stream and uses default formatter.
    The text starting "ext://..." is how a configuration file can refer to objects
    defined in the Python environment – in this case, the sys.stderr value from the
    sys module.
  id: totrans-343
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制台处理器写入 sys.stderr 流，并使用默认格式化程序。以 "ext://..." 开头的文本是配置文件如何引用在 Python 环境中定义的对象的方式——在这种情况下，来自
    sys 模块的 sys.stderr 值。
- en: The file handler uses the FileHandler class to write to a file. The default
    mode for opening the file is a, which will append to any existing log file. The
    configuration specifies the timestamp formatter that will be used for the file.
  id: totrans-344
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件处理器使用 FileHandler 类将内容写入文件。打开文件的默认模式是 a，这将追加到任何现有的日志文件。配置指定了用于文件的日期时间戳格式化程序。
- en: The loggers table provides a configuration for two specific named loggers that
    the application will use. Any logger name that begins with overview_stats.detail
    will be handled only by the console handler. Any logger name that begins with
    overview_stats.write will go to both the file handler and the console handler.
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录器表为应用将使用的两个特定命名的记录器提供了配置。任何以 overview_stats.detail 开头的记录器名称将由控制台处理器处理。任何以
    overview_stats.write 开头的记录器名称将同时发送到文件处理器和控制台处理器。
- en: The special root key defines the top-level logger. Within an application, it
    has a name of "" (empty string) when referred to in code. Within the configuration
    file, it has the key root.
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特殊的根键定义了顶级记录器。在代码中引用时，它有一个名为 ""（空字符串）的名称。在配置文件中，它有根键。
- en: Setting the severity level on the root logger will set the level used to show
    – or hide – messages for all of the children of this logger. This will show messages
    with the severity INFO or higher, which includes warnings, errors, and severe
    errors.
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在根记录器上设置严重性级别将设置用于显示或隐藏此记录器所有子记录器消息的级别。这将显示严重性为 INFO 或更高的消息，包括警告、错误和严重错误。
- en: 'Assuming the contents of this file are present in a variable named config_toml,
    the configuration to wrap the main() function will look like this:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 假设这个文件的内容存储在一个名为 config_toml 的变量中，包裹 main() 函数的配置将看起来像这样：
- en: '[PRE50]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This will start the logging in a known state. It will do the processing of the
    application. It will finalize all of the logging buffers and properly close any
    files.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动日志记录到一个已知的状态。它将处理应用程序。它将最终化所有的日志缓冲区，并正确关闭任何文件。
- en: 13.6.5 See also
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.6.5 参考信息
- en: See the [Designing scripts for composition](ch017.xhtml#x1-7410005) recipe earlier
    in this chapter for the complementary part of this application.
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章前面的[设计用于组合的脚本](ch017.xhtml#x1-7410005)配方中查看，以了解此应用的补充部分。
- en: See the [Using TOML for configuration files](ch017.xhtml#x1-7230002) recipe
    in this chapter for more on parsing TOML documents.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章中查看[使用 TOML 作为配置文件](ch017.xhtml#x1-7230002)的配方，了解更多关于解析 TOML 文档的信息。
- en: Join our community Discord space
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的社区 Discord 空间
- en: 'Join our Python Discord workspace to discuss and find out more about the book:
    [https://packt.link/dHrHU](https://packt.link/dHrHU)'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的 Python Discord 工作空间，讨论并了解更多关于这本书的信息：[https://packt.link/dHrHU](https://packt.link/dHrHU)
- en: '![PIC](img/file1.png)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file1.png)'
