- en: Python for Network Engineers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we are now familiar with how to write a program using the concepts used in
    programming languages, as well as best practices, now let's dig deep into writing
    an actual Python program or script. Keeping the primary focus on how to write
    a program in Python, we will also see how to write the same program in PowerShell,
    since there might be times where we would need to use PowerShell to achieve the
    results that we are looking for. We will cover various aspects of creating a program
    with some explanations of each of the statements and provide some tips and tricks
    to get through those tricky situations.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Python interpreter and data types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing Python scripts using conditional loops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing new modules/libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing arguments from command line for scripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Netmiko to interact with network devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multithreading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python interpreter and data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An interpreter, as the name suggests, is used to interpret instructions so that
    they are understandable by others. In our case, it is used to convert our Python
    language to a machine-understandable format that governs the flow of instructions
    that we gave to the machine.
  prefs: []
  type: TYPE_NORMAL
- en: It is also used to convert the set of values and messages given by a machine
    to a human-readable format in order to give us insights into how our program is
    being executed.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned in [Chapter 1](864fa562-ce4b-4b1f-a418-f91c2ac56f1f.xhtml), *Fundamental
    Concepts*, the interpreter that we are focusing on is Python 3.6\. I will be using
    it on the Windows platform, but the site has clear instructions on how to download
    and install the same on other OS like Unix or Linux machines. Once we install
    it by downloading it from the Python community  which can be found at URL [https://www.python.org/downloads](https://www.python.org/downloads),
    we can simply click on the setup file to install it. From the installation directory
    we just need to invoke `python.exe`, which will invoke the Python interpreter.
  prefs: []
  type: TYPE_NORMAL
- en: In order to call Python from anywhere in your Command Prompt, just add the Python
    installation folder in your PATH variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example: `set path=%path%;C:\python36`. This is going to add the
    Python36 path in the current path. Once this is done, `python.exe` can be called
    from anywhere in the Command Prompt.'
  prefs: []
  type: TYPE_NORMAL
- en: Once we invoke the interpreter, the first step to take is to create a variable
    and assign a value to it.
  prefs: []
  type: TYPE_NORMAL
- en: Python, as with any other programming language, supports various data types
    for the variables. A data type typically defines the type of value that can be
    stored in a variable, but Python and PowerShell have the ability to auto-evaluate
    the type of variable based upon the value. Python supports a large number of data
    types, but typically in our daily usage we refer to native data types multiple
    times.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python data type supports:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Numbers**: These are integer types, such as 1, 2, 100, and 1,000.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**String**: These are single or multiple characters and possibly every letter
    of ASCII, such as Python, network, age123, and India. Additionally, a string needs
    to be stored inside a double quote (`"`) or a single quote (`''`) to specify that
    a value is a string. Hence, `1` and `''1''` would be interpreted differently by
    Python.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Boolean**: This can be either a true or a false value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Byte**: These are typically binary values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lists**: These are an ordered sequence of values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tuples**: These are similar to lists, but the values or length cannot be
    altered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sets**: These are similar to lists, but not ordered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dictionary** or **hash** **values**: These are key-value pairs, like a telephone
    directory in which one primary value (name) is attached with both phone numbers
    and addresses.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An example on data types is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c2474970-452c-46e0-b805-55f593a095d6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we can see in the preceding example, we declared the variables with various
    values, and based upon the value, Python automatically interprets the specific
    data type. If we just type the variable name again, it prints out the value stored
    in the variable based upon its data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, the following example specifies other native data types:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/67d39b74-ca58-4e21-881e-a2592fe25836.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Additionally, to see the data type we can use the `type()` function, which
    returns the type of a variable based upon the value we gave. The variable is passed
    as an argument to the `type()` function to get the data type value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/034db3f3-17cb-44ed-8d5a-57fddeea6b8d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A PowerShell example of the same Python code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: There are operations, such as addition (`+`), for specific variables with particular
    data types. We have to be sure what types of variable we are adding. If we have
    an incompatible data type variable being added to another one, Python would throw
    an error stating the reason.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here in the following code, we see the result of adding two string variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6cd58d98-458f-41c4-9183-d08529901ace.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Similarly, observe the difference if we use the same addition on integer variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ddcd7f1c-857a-4917-bc41-eb6872f455de.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As mentioned, let''s see what happens when we try to add a string and an integer
    variable together:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/10dc9f9f-7ee2-4592-9ef8-dad80e6403d2.png)'
  prefs: []
  type: TYPE_IMG
- en: The error clearly specifies that we cannot add two different data types because
    the interpreter cannot recognize which data type needs to be assigned to the mixed
    value variable.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, if necessary, we can convert the values from one data type to another
    by calling specific functions that convert the data type to another. For example,
    `int("1")` will convert the string value 1 to integer value 1, or `str(1)` will
    convert the integer value 1 to the string value 1.
  prefs: []
  type: TYPE_NORMAL
- en: We will be extensively using the various data types depending upon the logic
    and requirements of the scripts, and also, if necessary, converting one data type
    to another to achieve certain results.
  prefs: []
  type: TYPE_NORMAL
- en: Conditions and loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Conditions are checked using a left and right value comparison. The evaluation
    returns either true or false, and a specific action is performed depending on
    the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are certain condition operators that are used to evaluate the left and
    right value comparisons:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operators** | **Meaning** |'
  prefs: []
  type: TYPE_TB
- en: '| `==` | If both values are equal |'
  prefs: []
  type: TYPE_TB
- en: '| `!=` | If both values are NOT equal |'
  prefs: []
  type: TYPE_TB
- en: '| `>` | If the left value is greater than the right value |'
  prefs: []
  type: TYPE_TB
- en: '| `<` | If the left value is smaller than the right value |'
  prefs: []
  type: TYPE_TB
- en: '| `>=` | If the left value is greater than or equal to the right value |'
  prefs: []
  type: TYPE_TB
- en: '| `<=` | If the left value is lesser than or equal to the right value |'
  prefs: []
  type: TYPE_TB
- en: '| `in` | If the left value is part of the right value |'
  prefs: []
  type: TYPE_TB
- en: 'An example of the condition evaluation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eaf5ab12-2d1b-4b85-a714-f3999aa28d03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, we are checking whether `2>3` (2 is greater that 3). Of course,
    this would result in false, so the action in the `else` section is executed. If
    we reverse the check, `3>2`, then the output would have been `left value is greater`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding example, we used the `if` condition block, which consists
    of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Notice the indentation, which is compulsory in Python. If we had not intended
    it, Python would not interpret what action to execute in which condition, and
    hence would have thrown an error of incorrect indentation.
  prefs: []
  type: TYPE_NORMAL
- en: Nested and multiple conditions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes we need to check multiple conditions in a single `if` condition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d3f16bcc-36f0-4ac8-8008-d1d459ac3155.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, we are checking the range of the marks. The flow of the program is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Assign a value of `85` to the `marks` variable. If `marks` is less than or equal
    to `45`, print `Grade C`, else if `marks` is greater than `45` and less than equal
    to `75`, print `Grade B`, else if `marks` is greater than `75`, print `Grade A`,
    else if none of the preceding conditions match, then print `Unable to determine`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The PowerShell sample code for the preceding Python task is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, here is an example of a nested condition (note the indentation that
    differentiates it from the earlier example of multiple conditions):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/de31a5bc-0ed1-4d3f-86d0-60f80aafb500.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we can see in the condition, the internal conditions will only be executed
    if its parent condition evaluates to true. If there is a false, the corresponding
    `else` action will be taken. In the example, if the `car_details` variable contains
    `Car`, contains `blue`, and it contains `sedan`, only then will the action `I
    will buy this car` be performed. If any of those conditions are not met, the relevant
    else action will be performed.
  prefs: []
  type: TYPE_NORMAL
- en: Loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A loop is used to repeat a set of instructions until a specific condition is
    fulfilled. There are two common ways of creating a loop in Python, which are discussed
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: For next loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This type of loop checks for a condition and repeats the instructions inside
    the loop until the condition is met:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s an example of printing numbers from 1 to 10 in a for loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/02d90031-e8fd-4810-bfcc-36b8a0552521.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, we use a built-in `range(starting value, max value)` function,
    which specifies the loop to repeat from the starting value until the incremental
    value reaches the maximum value. In this case, the variable `x` is incremented
    by 1 and in each loop, the value is printed out. This is repeated until the value
    of `x` reaches `10`, where the `for` loop terminates.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a similar way, we can also iterate through the items in a given list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2defea05-0fb5-4f17-aa98-c432036f90de.png)'
  prefs: []
  type: TYPE_IMG
- en: 'PowerShell sample for the preceding Python code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that the values are assigned to the countries variable as a
    list. The `for` loop now iterates through each item in the list, and the print
    statement adds the string value to another string value and prints the result. This
    loop is repeated until all the items in the list are printed.
  prefs: []
  type: TYPE_NORMAL
- en: 'There might be times when we do not want to parse through an entire `for` loop.
    To break from the loop while it is iterating, we use a `break` statement. Here''s
    an example in which we want to stop printing after `UK` in the `country` list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: While loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`While` loop is different from `for` loop, as no new variable is needed in
    this loop, and any current variable can be used to perform the tasks inside the
    `while` loop. An example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/a39d5bde-5e97-44ff-865b-ca5221817d1f.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is similar to `for`, but in this case the actions are performed first,
    and then the condition is checked. In the preceding example, the value of `x`
    is printed first, and we repeat the same set of instructions until the value of
    `x` reaches `10` or greater. Once the `if` condition is met, we break out of the
    loop. If we do not specify a `break` condition, we will go into an infinite loop
    with a increment of 1 for each `x` value.
  prefs: []
  type: TYPE_NORMAL
- en: Writing Python scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are now familiar with the basic concepts of Python. Now we will write an
    actual program or script in Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ask for the input of a country name, and check whether the last character of
    the country is a vowel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/be66c59e-ff2b-4145-88ea-a1c92005b60c.png)'
  prefs: []
  type: TYPE_IMG
- en: We ask for the input of a country name. The `input()` method is used to get
    an input from the user. The value entered is in the string format, and in our
    case the `countryname` variable has been assigned the input value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the next line, `countryname.lower()` specifies that the input that we receive
    needs to converted into all lowercase and stored in the same `countryname` variable.
    This effectively will have the same value that we entered earlier but in lowercase.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the next line, `countryname.strip()[-1]` specifies two actions in one statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`countryname.strip()` ensures that the variable has all the leading and trailing
    extra values removed, such as new line or tab characters.'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: Once we get the clean variable, remove the last character of the string, which
    in our case is the last character of the country name. The `-1` denotes the character
    from right to left or end to start, whereas `+1` would denote from left to right.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Once we have the last character stored in the `lastcharacter` variable, all
    that is needed is a nested condition check and, based upon the result, print the
    value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To save this program, we need to save this file as `somename.py`, which will
    specify that this program needs to be executed in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The PowerShell sample code for the preceding Python task is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Python is very strict in terms of indentation. As we can see in the example,
    if we change the indentations or tabs even by a space, Python will spit out an
    error stating the indentation is not correct and the compilation will fail. This
    will result in an error and unless the indentation is fixed, the execution will
    not be performed.
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For any recurring set of instructions, we can define a function. In other words,
    a function is a closed set of instructions to perform a specific logic or task.
    Depending upon the input provided, a function has the ability to return the results
    or parse the input with specific instructions to get results without any return
    values.
  prefs: []
  type: TYPE_NORMAL
- en: A function is defined by the `def` keyword, which specifies that we need to
    define a function and provide a set of instructions related to that function.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this task we will print the greater of two input numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/4571fb2a-3fbf-48bb-96ff-88a7f8fbd78f.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we can see in the preceding output, the first time we call the `checkgreaternumber(2,4)`
    function, the function prints the greater value as `4`, and the second time we
    call the function with different numbers, the function prints the greater value
    as `3`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The PowerShell sample code for the preceding task is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We can rewrite the same function, but rather than printing the value inside
    the function, it should return the greater number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this case, as we can see, the function returns the value, and the result
    is returned on the line where the function was called. In this case, as it was
    called inside the `print` function, it evaluates the input and returns the value,
    which also gets printed out inside the same `print` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Another important aspect of a function is the default values that we can provide
    in a function. Sometimes we need to write functions that might take multiple,
    say 4, 5, or more, values as inputs. Since it becomes hard to know what values
    we need and in which order for the function, we can ensure that the default value
    is taken into consideration if any value is not provided when calling that specific
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the code execution is given as:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1754e6c1-c7d9-4ab7-b3e5-e291d27f051e.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we can see in the preceding output, we specified the default value of `number2`
    as `5`. Now, as we can see in the first call to the function, we only give the
    value `3`. Now, as the function needs two inputs or parameters, but we provided
    only one, the second value for the function is taken from the default one, which
    is `5` in this case. Hence, a comparison will be done between `3` and `5` to get
    the greater number.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the second call to the function, a similar call is made with `6`, and since
    no other value was provided, the comparison was between `6` and `5`, and result
    returned was the greater value, which is `6`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the third call, we provide both values, which overrides any default value,
    so a comparison was done between `1` and `4`. The result was evaluated and the
    output of `4` was returned.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Another important consideration is the localization of a variable in a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5121cf2b-ada9-4b82-89c4-614b8d454e78.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding output, we define a variable named as `globalval` with a value
    of `6`. In the `checkglobalvalue` function, we just return the value of the `globalvalvariable`, which
    prints a value of `6` as we call the first `print` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second `print` function just prints the value of the same variable, which
    also prints `6`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, in the third `print` function, `localvariablevalue`, we call the same `globalval`,
    but give it a value of `8` and return the value of `globalval`. In the print value
    of local, it prints the result as value 8\. It is not assumed that the `globalval`
    variable has a value of `8` now. But, as we can see in the last `print` function,
    it still prints a value of `6`, when we call the `print` function to print the
    value of `globalval`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This clearly shows that any variable inside a function is locally effective,
    or is localized, but does not have any impact on any variables outside the function.
    We need to use the `global` command to reference the global variable and remove
    the localization impact of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the same example before using the `global` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6d0972af-9161-44b9-9abb-590e9e129527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As can we see in the preceding output, if we change the value of the `globalval`
    global variable inside the `localvariablevalue` function, we see the effect on
    the global variable with a new value of `8`.
  prefs: []
  type: TYPE_NORMAL
- en: Passing arguments from the command line
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes it is necessary to pass arguments to the script from the command line.
    This is generally needed when we need to perform some quick actions in our script,
    rather than the script asking us for the inputs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following lines of code where we pass two numbers as arguments
    to scripts, and print the sum of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run this script, say it''s saved as `checkargs.py`, and execute it
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The output returned is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The key here is the import of the `sys` module, which is a predefined module
    in Python to handle any system-related tasks of Python. The values that we pass
    as arguments are stored in `sys.argv[1]` onwards, since `sys.argv[0]` is the name
    of actual script being run. In this case, `sys.argv[0]` will be `checkargs.py`,
    `sys.argv[1]` will be `5`, and `sys.argv[2]` will be `6`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The PowerShell code for the preceding task is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The arguments passed in a Python script are in string format, so we need to
    explicitly convert them to the right type for the expected output. In the preceding
    script, if we had not converted it to the integer type by using the `int()` function,
    then the output would have been `56` instead of `int(5)` + `int(6)` = `11`.
  prefs: []
  type: TYPE_NORMAL
- en: Python modules and packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Because Python is the most popular open source coding language, there are many
    developers who contribute their expertise by creating specific modules and sharing
    them for others to use. These modules are a specific set of functions or instructions
    that are used to perform specialized tasks and can be called easily in our programs.
    The modules can be easily called using the `import` command inside the scripts.
    Python has many built-in modules that are directly called using `import`, but
    for specialized modules, an external installation is needed. Luckily, Python provides
    a very easy way to download and install these modules.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, let's install a module named `Netmiko` that can help us work
    on logging into network devices more efficiently. Python provides a well-documented
    reference for each of the modules, and for our module, the documentation can be
    found at [https://pypi.python.org/pypi/netmiko. ](https://pypi.python.org/pypi/netmiko)For
    installation, all we have to do is go into the folder from the command line where
    `python.exe` is installed or is present. There is a sub folder in that location
    called `scripts`.
  prefs: []
  type: TYPE_NORMAL
- en: Inside that folder, we have two options that can be used for installing modules,
    `easy_install.exe` or `pip.exe`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Installing the library for Python, can be done in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax of `easy_install` is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The syntax of `pip install` is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Once we install the required module, we need to restart Python by closing all
    open sessions and invoking IDLE again so the modules can be loaded. More information
    on modules can be gathered from [https://docs.python.org/2/tutorial/modules.html.](https://docs.python.org/2/tutorial/modules.html)
  prefs: []
  type: TYPE_NORMAL
- en: Multithreading for parallel processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we are now focusing on writing our scripts efficiently, a major aspect of
    this is how efficiently, quickly, and correctly we fetch the information. When
    we use the `for` loop, we parse through each item one by one, which is fine if
    we get results quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if each item in a `for` loop is a router from which we need to get the
    output of show version, and if each router takes around 10 seconds to log in,
    gather the output, and log out, and we have around 30 routers that we need to
    get this information from, we would need 10*30 = 300 seconds for the program to
    complete the execution. If we are looking for more advanced or complex calculations
    on each output, which might take up to a minute, then it will take 30 minutes
    for just 30 routers.
  prefs: []
  type: TYPE_NORMAL
- en: This starts becoming very inefficient when our complexity and scalability grows.
    To help with this, we need to add parallelism to our programs. What this simply
    means is, we log in simultaneously on all 30 routers, and perform the same task
    to fetch the output at the same time. Effectively, this means that we now get
    the output on all  30 routers in 10 seconds, because we have 30 parallel threads
    being called.
  prefs: []
  type: TYPE_NORMAL
- en: A thread is nothing but another instance of the same function being called,
    and calling it 30 times means we are invoking 30 threads at the same time to perform
    the same tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the multi-threading code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f806c994-8e32-4a82-90e9-68d1d06f0c12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we can see in the preceding example, we created two functions, named `checksequential`
    and `checkparallel`, to print the system's date time. The `datetime` module is
    used to get the system's date time in this case. In the `for` loop, a sequential
    run was done that shows the increment time in the output when the function was
    called.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the threading, we use a blank array named `threads`. Each of the instances
    that is created has a unique thread number or value, which is stored in this empty
    thread array each time the `checkparallel` method is spawned. This unique number
    or reference for each thread identifies each thread as and when its executed.
    The `start()` method is used to get the thread to perform the function called
    in the thread.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The last loop is important in the thread. What it signifies is that the program
    will wait for all the threads to complete before moving forward. The `join()`
    method specifies that until all the threads are complete, the program will not
    proceed to the next step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, as we can see in the output of the thread, some of the timestamps are the
    same, which means that all those instances were invoked and executed at the same
    time in parallel rather than sequentially.
  prefs: []
  type: TYPE_NORMAL
- en: The output in the program is not in order for parallel threads, because the
    moment any thread is completed, the output is printed, irrespective of the order.
    This is different to sequential execution, since parallel threads do not wait
    for any previous thread to complete before executing another. So, any thread that
    completes will print its value and end.
  prefs: []
  type: TYPE_NORMAL
- en: 'PowerShell sample code for the preceding task is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Using Netmiko for SSH and network device interaction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Netmiko ([https://github.com/ktbyers/netmiko](https://github.com/ktbyers/netmiko))
    is a library in Python that is used extensively an interaction with network devices.
    This is a multi-vendor library with support for Cisco IOS, NXOS, firewalls, and
    many other devices. The underlying library of this is Paramiko, which is again
    used extensively for SSH into various devices.
  prefs: []
  type: TYPE_NORMAL
- en: Netmiko extends the Paramiko ability of SSH to add enhancements, such as going
    into configuration mode in network routers, sending commands, receiving output
    based upon the commands, adding enhancements to wait for certain commands to finish
    executing, and also taking care of yes/no prompts during command execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of a simple script to log in to the router and show the
    version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the execution of code against a router is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a66c311b-136d-4147-b78f-10eb7cfbc53d.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As we can see in the sample code, we call the `ConnectHandler` function from
    the Netmiko library, which takes four inputs (`platform type`, `IP address of
    device`, `username`, and `password`):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Netmiko works with a variety of vendors. Some of the supported platform types
    and their abbreviations to be called in Netmiko are:'
  prefs: []
  type: TYPE_NORMAL
- en: '''a10'': A10SSH,'
  prefs: []
  type: TYPE_NORMAL
- en: '''accedian'': AccedianSSH,'
  prefs: []
  type: TYPE_NORMAL
- en: '''alcatel_aos'': AlcatelAosSSH,'
  prefs: []
  type: TYPE_NORMAL
- en: '''alcatel_sros'': AlcatelSrosSSH,'
  prefs: []
  type: TYPE_NORMAL
- en: '''arista_eos'': AristaSSH,'
  prefs: []
  type: TYPE_NORMAL
- en: '''aruba_os'': ArubaSSH,'
  prefs: []
  type: TYPE_NORMAL
- en: '''avaya_ers'': AvayaErsSSH,'
  prefs: []
  type: TYPE_NORMAL
- en: '''avaya_vsp'': AvayaVspSSH,'
  prefs: []
  type: TYPE_NORMAL
- en: '''brocade_fastiron'': BrocadeFastironSSH,'
  prefs: []
  type: TYPE_NORMAL
- en: '''brocade_netiron'': BrocadeNetironSSH,'
  prefs: []
  type: TYPE_NORMAL
- en: '''brocade_nos'': BrocadeNosSSH,'
  prefs: []
  type: TYPE_NORMAL
- en: '''brocade_vdx'': BrocadeNosSSH,'
  prefs: []
  type: TYPE_NORMAL
- en: '''brocade_vyos'': VyOSSSH,'
  prefs: []
  type: TYPE_NORMAL
- en: '''checkpoint_gaia'': CheckPointGaiaSSH,'
  prefs: []
  type: TYPE_NORMAL
- en: '''ciena_saos'': CienaSaosSSH,'
  prefs: []
  type: TYPE_NORMAL
- en: '''cisco_asa'': CiscoAsaSSH,'
  prefs: []
  type: TYPE_NORMAL
- en: '**''cisco_ios'': CiscoIosBase**,'
  prefs: []
  type: TYPE_NORMAL
- en: '''cisco_nxos'': CiscoNxosSSH,'
  prefs: []
  type: TYPE_NORMAL
- en: '''cisco_s300'': CiscoS300SSH,'
  prefs: []
  type: TYPE_NORMAL
- en: '''cisco_tp'': CiscoTpTcCeSSH,'
  prefs: []
  type: TYPE_NORMAL
- en: '''cisco_wlc'': CiscoWlcSSH,'
  prefs: []
  type: TYPE_NORMAL
- en: '''cisco_xe'': CiscoIosBase,'
  prefs: []
  type: TYPE_NORMAL
- en: '''cisco_xr'': CiscoXrSSH,'
  prefs: []
  type: TYPE_NORMAL
- en: '''dell_force10'': DellForce10SSH,'
  prefs: []
  type: TYPE_NORMAL
- en: '''dell_powerconnect'': DellPowerConnectSSH,'
  prefs: []
  type: TYPE_NORMAL
- en: '''eltex'': EltexSSH,'
  prefs: []
  type: TYPE_NORMAL
- en: '''enterasys'': EnterasysSSH,'
  prefs: []
  type: TYPE_NORMAL
- en: '''extreme'': ExtremeSSH,'
  prefs: []
  type: TYPE_NORMAL
- en: '''extreme_wing'': ExtremeWingSSH,'
  prefs: []
  type: TYPE_NORMAL
- en: '''f5_ltm'': F5LtmSSH,'
  prefs: []
  type: TYPE_NORMAL
- en: '''fortinet'': FortinetSSH,'
  prefs: []
  type: TYPE_NORMAL
- en: '''generic_termserver'': TerminalServerSSH,'
  prefs: []
  type: TYPE_NORMAL
- en: '''hp_comware'': HPComwareSSH,'
  prefs: []
  type: TYPE_NORMAL
- en: '''hp_procurve'': HPProcurveSSH,'
  prefs: []
  type: TYPE_NORMAL
- en: '''huawei'': HuaweiSSH,'
  prefs: []
  type: TYPE_NORMAL
- en: '''juniper'': JuniperSSH,'
  prefs: []
  type: TYPE_NORMAL
- en: '''juniper_junos'': JuniperSSH,'
  prefs: []
  type: TYPE_NORMAL
- en: '''linux'': LinuxSSH,'
  prefs: []
  type: TYPE_NORMAL
- en: '''mellanox_ssh'': MellanoxSSH,'
  prefs: []
  type: TYPE_NORMAL
- en: '''mrv_optiswitch'': MrvOptiswitchSSH,'
  prefs: []
  type: TYPE_NORMAL
- en: '''ovs_linux'': OvsLinuxSSH,'
  prefs: []
  type: TYPE_NORMAL
- en: '''paloalto_panos'': PaloAltoPanosSSH,'
  prefs: []
  type: TYPE_NORMAL
- en: '''pluribus'': PluribusSSH,'
  prefs: []
  type: TYPE_NORMAL
- en: '''quanta_mesh'': QuantaMeshSSH,'
  prefs: []
  type: TYPE_NORMAL
- en: '''ubiquiti_edge'': UbiquitiEdgeSSH,'
  prefs: []
  type: TYPE_NORMAL
- en: '''vyatta_vyos'': VyOSSSH,'
  prefs: []
  type: TYPE_NORMAL
- en: '''vyos'': VyOSSSH,'
  prefs: []
  type: TYPE_NORMAL
- en: Depending upon the selection of the platform type, Netmiko can understand the
    returned prompt and the correct way to SSH to the specific device. Once the connection
    is made, we can send commands to the device using the `send` method.
  prefs: []
  type: TYPE_NORMAL
- en: Once we get the return value, the value stored in the `output` variable is displayed,
    which is the string output of the command that we sent to the device. The last
    line, which uses the `disconnect` function, ensures that the connection is terminated
    cleanly once we are done with our task.
  prefs: []
  type: TYPE_NORMAL
- en: 'For configuration (example: We need to provide a description to the router
    interface `FastEthernet 0/0`), we use Netmiko as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the execution of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/135a58fa-bf71-45c9-992e-875816852d6e.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, for `config push` we do not have to perform any additional configs
    but just specify the commands in the same order as we will send them manually
    to the router in a list, and pass that list as an argument to the `send_config_set`
    function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The output in `Before config push` is a simple output of the `FastEthernet0/0` interface,
    but the output under `After config push` is now with the description that we configured
    using the list of commands.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a similar way, we can pass multiple commands to the router, and Netmiko will
    go into configuration mode, write those commands to the router, and exit config
    mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to save the configuration, we use the following command after the
    `send_config_set` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the router writes the newly pushed config in memory.
  prefs: []
  type: TYPE_NORMAL
- en: Network automation use case
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have now interacted with multiple sections of Python and device interaction,
    let's create a use case to incorporate what we have learned so far. The use case
    is as follows**:**
  prefs: []
  type: TYPE_NORMAL
- en: 'Log into the router and fetch some information:'
  prefs: []
  type: TYPE_NORMAL
- en: '`task1()`: Show the version, show the IP in brief, show the clock, and show
    the configured usernames on the router.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`task2()`: Create another username on the `test` router with the password `test`
    and check whether we can log in successfully with the newly created username.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`task3()`: Log in with the newly created username `test`, and delete all the
    other usernames from the `running-config`. Once this is done, return all the current
    usernames configured on the router to confirm whether only the `test` username
    is configured on the router.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s build a script to tackle these tasks one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, the three tasks given are defined as three different functions:'
  prefs: []
  type: TYPE_NORMAL
- en: The first line indicates that we have imported the Netmiko library, and in the
    second line we are connecting to our `test` router with the Cisco credentials.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `task1()` function, we are fetching the outputs of all show commands.
    Additionally, since we do not want to expose the passwords of the current usernames
    we have added an extra logic wherein the returned output for `show running-config
    | in username` will be parsed by each line for every username, and each line will
    be split by a space character `" "`. Also, since the Cisco device returns the
    actual username in the second position in the output (for example, username `test`
    privilege 15 secret 5 *)*, we print the value of the second item after we split
    the output string, which is our actual username.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here''s the output for the `task1()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/51c0ad39-caeb-4baa-bba0-c6b95c760bfe.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the `task2()` method, we are going to create a username `test` with the password
    `test`, and authenticate with the new username. We have added a `try:` exception
    block in this method, which checks for any errors/exceptions for all the statements
    in the `try:` section, and if there are any exceptions, rather than breaking the
    script, it runs the code that is given in the exception section (under the `except:`
    keyword). If there are no errors, it continues with the statements in the `try:`
    section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here''s the output for `task2()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/62f5c790-3c76-4fd4-a2d5-1c61b2744d35.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see that we now have two usernames configured, and the router is also
    now successfully responding to authentication with the `test` username.
  prefs: []
  type: TYPE_NORMAL
- en: In `task3()` function, this will first fetch all the usernames that are in `running-config`,
    and if there are any usernames that are not `test`, it will create a dynamic command
    with no username `<username>` and send it to the router. Once it is done with
    all the usernames, it will go ahead and recheck and list out all the usernames
    not on the router. A success criteria is only the configured username as `test`
    should be available on the router.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here''s the output of `task3()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/44b7d3eb-4dda-4bf2-b055-a5a1e81e3d54.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The result of `task3()` is the result of all configured usernames, which in
    this case is now only test.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned some advanced techniques for writing scripts by
    using functions, conditions, and loops; we covered multi-threading our scripts
    for faster and parallel execution, we got familiar with using Netmiko to interact
    with network devices, and looked at a real-world example of achieving a certain
    set of tasks using a single script.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will focus on automation tasks using web. We will also discuss
    how to call Python scripts from the web and perform tasks using web framework.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, there will be a basic introduction to creating your own API so
    that others can use it for specific tasks.
  prefs: []
  type: TYPE_NORMAL
