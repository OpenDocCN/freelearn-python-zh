<html><head></head><body>
		<div><h1 id="_idParaDest-905" class="chapter-number"><a id="_idTextAnchor1117"/>21</h1>
			<h1 id="_idParaDest-906"><a id="_idTextAnchor1118"/>Performance Optimization</h1>
			<p>With the help of the Odoo framework, you can develop large and complex applications. Good performance is key to the success of any project. In this chapter, we will explore the patterns and tools you need to optimize performance. You will also learn about the debugging techniques used to find the root cause of a performance issue.</p>
			<p>In this chapter, we will cover the following recipes:</p>
			<ul>
				<li>The prefetching pattern for recordsets</li>
				<li>The in-memory cache – <code>ormcache</code></li>
				<li>Generating differently sized images</li>
				<li>Accessing grouped data</li>
				<li>Creating or writing multiple records</li>
				<li>Accessing records through database queries</li>
				<li>Profiling Python code</li>
			</ul>
			<h1 id="_idParaDest-907"><a id="_idTextAnchor1119"/>The prefetching pattern for recordsets</h1>
			<p>When you <a id="_idIndexMarker1515"/>access data from a recordset, it makes a <a id="_idIndexMarker1516"/>query in the database. If you have a recordset with multiple records, fetching records on it can make a system slow because of the multiple SQL queries. In this recipe, we will explore how you can use the prefetching pattern to solve this issue. By following the prefetching pattern, you can reduce the number of queries needed, which will improve performance and make your system faster.</p>
			<h2 id="_idParaDest-908"><a id="_idTextAnchor1120"/>How to do it…</h2>
			<p>Take a look at the following code; it is a normal <code>compute</code> method. In this method, <code>self</code> is a recordset of multiple records. When you iterate directly on the recordset, prefetching works perfectly:</p>
			<pre class="source-code">
# Correct prefetching
def compute_method(self):
    for rec in self:
        print(rec.name)</pre>			<p>However, in some <a id="_idIndexMarker1517"/>cases, prefetching becomes more complex, such as when fetching data with the <code>browse</code> method. In the following example, we browse <a id="_idIndexMarker1518"/>records one by one in the <code>for</code> loop. This will not use prefetching efficiently, and it will execute more queries than usual:</p>
			<pre class="source-code">
# Incorrect prefetching
def some_action(self):
    record_ids = []
    self.env.cr.execute("some query to fetch record id")
    for rec in self.env.cr.fetchall():
        record = self.env['res.partner'].browse(rec[0])
        print(record.name)</pre>			<p>By passing a list of IDs to the <code>browse</code> method, you can create a recordset of multiple records. If you perform operations on this recordset, prefetching works perfectly fine:</p>
			<pre class="source-code">
# Correct prefetching
def some_action(self):
    record_ids = []
    self.env.cr.execute("some query to fetch record id")
    record_ids = [ rec[0] for rec in self.env.cr.fetchall() ]
    recordset = self.env['res.partner'].browse(record_ids)
    for record_id in recordset:
        print(record.name)</pre>			<p>This way, you will not lose the prefetching feature, and data will be fetched in a single SQL query.</p>
			<h2 id="_idParaDest-909"><a id="_idTextAnchor1121"/>How it works...</h2>
			<p>When you work with multiple recordsets, prefetching helps reduce the number of SQL queries. It does <a id="_idIndexMarker1519"/>this by fetching all of the data at once. Usually, prefetching <a id="_idIndexMarker1520"/>works automatically in Odoo, but you lose this feature in certain circumstances, such as when you split records, as depicted in the following example:</p>
			<pre class="source-code">
recs = [r for r in recordset r.id not in [1,2,4,10]]</pre>			<p>The preceding code given will split the recordset into parts, so you cannot take advantage of prefetching.</p>
			<p>Using prefetching correctly <a id="_idIndexMarker1521"/>can significantly improve the performance of <strong class="bold">Object-Relational Mapping</strong> (<strong class="bold">ORM</strong>). Let’s explore how prefetching works under the hood.</p>
			<p>When you iterate on a recordset through a <code>for</code> loop and access the value of a field in the first iteration, the prefetching process starts its magic. Instead of fetching data for the current record in the iteration, prefetching will fetch the data for all of the records. The logic behind this is that if you access a field in a <code>for</code> loop, you are likely to fetch that data for the next record in the iteration as well. In the first iteration of the <code>for</code> loop, prefetching will fetch the data for all of the recordsets and keep it in the cache. In the next iteration of the <code>for</code> loop, data will be served from this cache, instead of making a new SQL query. This will reduce the query count from <code>O(n)</code> to <code>O(1)</code>.</p>
			<p>Let’s suppose the recordset has 10 records. When you are in the first loop and access the <code>name</code> field of the record, it will fetch the data for all 10 records. This is not only the case for the <code>name</code> field; it will also fetch all the fields for those 10 records. In the subsequent <code>for</code> loop iterations, the data will be served from the cache. This will reduce the number of queries from 10 to 1:</p>
			<pre class="source-code">
for record in recordset: # recordset with 10 records
    record.name # Prefetch data of all 10 records in the first loop
    record.email # data of email will be served from the cache.</pre>			<p>Note that the prefetching will fetch the value of all of the fields (except the <code>*2many</code> fields), even if those fields are not used in the body of the <code>for</code> loop. This is because the extra columns only have a minor impact on performance compared to the extra queries for each column.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Sometimes, prefetched fields could reduce performance. In these cases, you can disable prefetching by passing <code>False</code> into the <code>prefetch_fields</code> context, as follows: <code>recordset.with_context(prefetch_fields=False)</code>.</p>
			<p>The prefetch <a id="_idIndexMarker1522"/>mechanism uses the environment cache to <a id="_idIndexMarker1523"/>store and retrieve record values. This means that once the records are fetched from the database, all subsequent calls for fields will be served from the environment cache. You can access the environment cache using the <code>env.cache</code> attribute. To invalidate the cache, you can use the <code>invalidate_cache()</code> method of the environment.</p>
			<h2 id="_idParaDest-910"><a id="_idTextAnchor1122"/>There’s more...</h2>
			<p>If you split recordsets, the ORM will generate a new recordset with a new prefetch context. Performing operations on such recordsets will only prefetch the data for the respective records. If you want to prefetch all the records after <code>prefetch</code>, you can do this by passing the <a id="_idIndexMarker1524"/>prefetch record IDs to the <code>with_prefetch()</code> method. In the following example, we split the recordset into two parts. Here, we passed a common prefetch context in both recordsets, so when you fetch the data from one of them, ORM will fetch the data for the other and put the data in the cache for future use:</p>
			<pre class="source-code">
recordset = ... # assume recordset has 10 records.
recordset1 = recordset[:5].with_prefetch(recordset._ids)
recordset2 = recordset[5:].with_prefetch(recordset._ids)
self.env.cr.execute("select id from sale_order limit 10")
record_ids = [rec[0] for rec in self.env.cr.fetchall()]
recordset = self.env['sale.order'].browse(record_ids)
recordset1 = recordset[:5]
for rec in recordset1:
   print(rec.name)  # Prefetch name of all 5 records in the first loop
   print(rec.attention)  # Prefetch attention of all 5 records in the first loop
recordset2 = recordset[5:].with_prefetch(recordset._ids)
for rec in recordset1:
   print(rec.name)  # Prefetch name of all 10 records in the first loop
   print(rec.attention)  # Prefetch attention of all 10 records in the first loop</pre>			<p>The prefetch <a id="_idIndexMarker1525"/>context is not limited to splitting recordsets. You can also use the <code>with_prefetch()</code> method to have a common prefetch context between multiple recordsets. This means that when you fetch data from one record, it will fetch data for all other recordsets, too.</p>
			<h1 id="_idParaDest-911"><a id="_idTextAnchor1123"/>The in-memory cache – ormcache</h1>
			<p>The Odoo framework <a id="_idIndexMarker1526"/>provides the <code>ormcache</code> decorator to manage the in-memory cache. In this recipe, we will explore how you can manage the cache for your functions.</p>
			<h2 id="_idParaDest-912"><a id="_idTextAnchor1124"/>How to do it...</h2>
			<p>The classes of this ORM cache are available at <code>/odoo/tools/cache.py</code>. In order to use these in any file, you will need to import them as follows:</p>
			<pre class="source-code">
from odoo import tools</pre>			<p>After importing the classes, you can use the ORM cache decorators. Odoo provides different types of in-memory cache decorators. We’ll take a look at each of these in the following subsections.</p>
			<h3>ormcache</h3>
			<p>This one is the simplest <a id="_idIndexMarker1527"/>and most used cache decorator. You need to pass the parameter name upon which the method’s output depends. The following is an example method with the <code>ormcache</code> decorator:</p>
			<pre class="source-code">
@tools.ormcache('mode')
def fetch_mode_data(self, mode):
    # some calculations
    return result</pre>			<p>When you call this method for the first time, it will be executed, and the result will be returned. <code>ormcache</code> will store this result based on the value of the <code>mode</code> parameter. When you call the method again with the same <code>mode</code> value, the result will be served from the cache without executing the actual method.</p>
			<p>Sometimes, your method’s result depends on the environment attributes. In these cases, you can declare the method as follows:</p>
			<pre class="source-code">
@tools.ormcache('self.env.uid', 'mode')
def fetch_data(self, mode):
    # some calculations
    return result</pre>			<p>The method given in this example will store the cache based on the environment user and the value of the <code>mode</code> parameter.</p>
			<h3>ormcache_context</h3>
			<p>This cache <a id="_idIndexMarker1528"/>works similarly to <code>ormcache</code>, except that it depends on the parameters plus the value in the context. In this cache’s decorator, you need to pass the parameter name and a list of context keys. For example, if your method’s output depends on the <code>lang</code> and <code>website_id</code> keys in the context, you can use <code>ormcache_context</code>:</p>
			<pre class="source-code">
@tools.ormcache_context('mode', keys=('website_id','lang'))
def fetch_data(self, mode):
    # some calculations
    return result</pre>			<p>The cache in <a id="_idIndexMarker1529"/>the preceding example will depend on the <code>mode</code> argument and the values of <code>context</code>.</p>
			<h3>ormcache_multi</h3>
			<p>Some methods carry out an operation on multiple records or IDs. If you want to add a cache to these <a id="_idIndexMarker1530"/>kinds of methods, you can use the <code>ormcache_multi</code> decorator. You need to pass the <code>multi</code> parameter, and during the method call, ORM will generate the cache keys by iterating on this parameter. In this method, you will need to return the result in the dictionary format with an element of the <code>multi</code> parameter as a key. Take a look at the following example:</p>
			<pre class="source-code">
@tools.ormcache_multi('mode', multi='ids')
def fetch_data(self, mode, ids):
    result = {}
    for i in ids:
        data = ... # some calculation based on ids
        result[i] = data
    return result</pre>			<p>Suppose we called the preceding method with <code>[1,2,3]</code> as the IDs. The method will return a result in the <code>{1:... , 2:..., 3:... }</code> format. ORM will cache the result based on these keys. If you make another call with <code>[1,2,3,4,5]</code> as the IDs, your method will receive <code>[4, 5]</code> as the <code>ID</code> parameter, so the method will carry out the operations for the <code>4</code> and <code>5</code> IDs, and the rest of the result will be served from the cache.</p>
			<h2 id="_idParaDest-913"><a id="_idTextAnchor1125"/>How it works...</h2>
			<p>The ORM cache keeps the cache in the dictionary format (the cache lookup). The keys of this cache will be generated based on the signature of the decorated method, and the values will be <a id="_idIndexMarker1531"/>the result. Put simply, when you call the method with the <code>x, y</code> parameters and the result of the method is <code>x+y</code>, the cache lookup will be <code>{(x, y): x+y}</code>. This means that the next time you call this method with the same parameters, the result will be served directly from this cache. This saves computation time and makes the response faster.</p>
			<p>The ORM cache is an in-memory cache, so it is stored in RAM and occupies memory. Do not use <code>ormcache</code> to serve large data, such as images or files.</p>
			<p class="callout-heading">Warning</p>
			<p class="callout">Methods using this decorator should never return a recordset. If they do, they will generate <code>psycopg2.OperationalError</code> because the underlying cursor of the recordset is closed.</p>
			<p>You should use the ORM cache on pure functions. A pure function is a method that always returns the same result for the same arguments. The output of these methods only depends on the arguments, so they return the same result. If this is not the case, you need to manually clear the cache when you perform operations that make the cache’s state invalid. To clear the cache, call the <code>clear_caches()</code> method:</p>
			<pre class="source-code">
self.env[model_name].clear_caches()</pre>			<p>Once you have cleared the cache, the next call to the method will execute the method and store the result in the cache, and all subsequent method calls with the same parameter will be served from the cache.</p>
			<h2 id="_idParaDest-914"><a id="_idTextAnchor1126"/>There’s more...</h2>
			<p>The ORM <a id="_idIndexMarker1532"/>cache is the <code>SIGUSR1</code> signal to the Odoo process:</p>
			<pre class="console">
kill -SIGUSR1 &lt;pid&gt;
kill -SIGUSR1 496</pre>			<p>Here, <code>496</code> is the process ID. After executing the command, you will see the status of the ORM cache in the logs:</p>
			<pre class="console">
&gt; 2023-10-18 09:22:49,350 496 INFO odoo-book-17.0 odoo.tools.cache:      1 entries,     31 hit,      1 miss,      0 err, 96.9% ratio, for ir.actions.act_window._existing
&gt; 2023-10-18 09:22:49,350 496 INFO odoo-book-17.0 odoo.tools.cache:      1 entries,      1 hit,      1 miss,      0 err, 50.0% ratio, for ir.actions.actions.get_bindings
&gt; 2023-10-18 09:22:49,350 496 INFO odoo-book-17.0 odoo.tools.cache:      4 entries,      1 hit,      9 miss,      0 err, 10.0% ratio, for ir.config_parameter._get_param</pre>			<p>The percentage <a id="_idIndexMarker1533"/>in the cache is the hit-to-miss ratio. It’s the success ratio of the result being found in the cache. If the cache’s hit-to-miss ratio is too low, you should remove the ORM cache from the method.</p>
			<h1 id="_idParaDest-915"><a id="_idTextAnchor1127"/>Generating images in different size</h1>
			<p>Large images can be troublesome for any website. They increase the size of web pages and consequently make <a id="_idIndexMarker1534"/>them slower as a result. This leads to bad SEO rankings and visitor loss. In this recipe, we will explore how you can create images of different sizes; by using the right images, you can reduce the web page size and improve the page loading time.</p>
			<h2 id="_idParaDest-916"><a id="_idTextAnchor1128"/>How to do it...</h2>
			<p>You will need to inherit <code>image.mixin</code> in your model. Here is how you can add <code>image.mixin</code> to your model:</p>
			<pre class="source-code">
class HostelStudent(models.Model):
    _name = "hostel.student"
    _description = "Hostel Student Information"
    _inherit = ["image.mixin"]</pre>			<p>The mixin will automatically add five new fields to the hostel student model to store images of different sizes. See the <em class="italic">How it works…</em> section to learn about all five fields.</p>
			<h2 id="_idParaDest-917"><a id="_idTextAnchor1129"/>How it works...</h2>
			<p>The <code>image.mixin</code> instance will automatically add five new binary fields to the model. Each field <a id="_idIndexMarker1535"/>stores images with a different resolution. Here is a list of the fields and their resolutions:</p>
			<ul>
				<li><code>image_1920</code>: 1,920x1,920</li>
				<li><code>image_1024</code>: 1,024x1,024</li>
				<li><code>image_512</code>: 512x1,512</li>
				<li><code>image_256</code>: 256x256</li>
				<li><code>image_128</code>: 128x128</li>
			</ul>
			<p>Of all the fields given here, only <code>image_1920</code> is editable. The other image fields are read-only and update automatically when you change the <code>image_1920</code> field. So, in the backend form view of your model, you need to use the <code>image_1920</code> field to allow the user to upload images. However, by doing so, we load large <code>image_1920</code> images in the form view. However, there is a way to improve performance by using <code>image_1920</code> images in the form view but displaying smaller images. For instance, we can utilize the <code>image_1920</code> field but display an <code>image_128</code> field. To do this, you can use the following syntax:</p>
			<pre class="source-code">
&lt;field name="image_1920" widget="image"
       options="{'preview_image': 'image_128'}" /&gt;</pre>			<p>Once you have saved the image to the field, Odoo will automatically resize the image and store it in the respective field. The form view will display the converted <code>image_128</code>, as we use it as <code>preview_image</code>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <code>image.mixin</code> model is <code>AbstractModel</code>, so its table is not present in the database. You need to inherit it in your model in order to use it.</p>
			<p>With this <code>image.mixin</code>, you can store an image with a maximum resolution of 1,920x1,920. If you <a id="_idIndexMarker1536"/>save an image with a resolution higher than 1,920x1,920, Odoo will reduce it to 1,920x1,920. While doing so, Odoo will also preserve the resolution of the image, avoiding any distortion. As an example, if you upload an image with a 2,400x1,600 resolution, the <code>image_1920</code> field will have a resolution of 1,920x1,280.</p>
			<h2 id="_idParaDest-918"><a id="_idTextAnchor1130"/>There’s more...</h2>
			<p>With <code>image.mixin</code>, you can get <a id="_idIndexMarker1537"/>images with certain resolutions, but what if you want to use an image with another resolution? To do so, you can use a binary wrapper field image, as shown in the following example:</p>
			<pre class="source-code">
image_1500 = fields.Image("Image 1500", max_width=1500, max_height=1500)</pre>			<p>This will create a new <code>image_1500</code> field, and storing the image will resize it to 1,500x1,500 resolution. Note that this is not part of <code>image.mixin</code>. It just reduces the image to 1,500x1,500, so you need to add this field in the form view; editing it will not make changes to the other image fields in <code>image.mixin</code>. If you want to link it with an existing <code>image.mixin</code> field, add the <code>related="image_1920"</code> attribute to the field definition.</p>
			<h1 id="_idParaDest-919"><a id="_idTextAnchor1131"/>Accessing grouped data</h1>
			<p>When you want <a id="_idIndexMarker1538"/>data for statistics, you often need it in a grouped form, such as a monthly sales report, or a report that shows sales per customer. It is time-consuming to search records and group them manually. In this recipe, we will explore how you can use the <code>read_group()</code> method to access grouped data.</p>
			<h2 id="_idParaDest-920"><a id="_idTextAnchor1132"/>How to do it...</h2>
			<p>Perform the following steps.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <code>read_group()</code> method <a id="_idIndexMarker1539"/>is widely used for statistics and smart stat buttons.</p>
			<ol>
				<li>Let’s assume <a id="_idIndexMarker1540"/>that you want to show the number of sales orders on the partner form. This can be done by searching sales orders for a customer and then counting the length:<pre class="source-code">
# in res.partner model
so_count = fields.Integer(compute='_compute_so_count', string='Sale order count')
def _compute_so_count(self):
    sale_orders = self.env['sale.order'].search(domain=[('partner_id', 'in', self.ids)])
    for partner in self:
        partner.so_count = len(sale_orders.filtered(lambda so: so.partner_id.id == partner.id))</pre><p class="list-inset">The previous example will work, but not optimally. When you display the <code>so_count</code> field on the tree view, it will fetch and filter sales orders for all the partners in a list. With this small amount of data, the <code>read_group()</code> method won›t make much difference, but as the amount of data grows, it could be a problem. To fix this issue, you can use the <code>read_group</code> method.</p></li>				<li>The following example will do the same as the preceding one, but it only consumes one SQL query, even for large datasets:<pre class="source-code">
# in res.partner model
so_count = fields.Integer(compute='_compute_so_count', string='Sale order count')
def _compute_so_count(self):
    sale_data = self.env['sale.order'].read_group(
        domain=[('partner_id', 'in', self.ids)],
        fields=['partner_id'], groupby=['partner_id'])
    mapped_data = dict([(m['partner_id'][0], m['partner_id_count']) for m in sale_data])
    for partner in self:
        partner.so_count = mapped_data[partner.id]</pre></li>			</ol>
			<p>The previous <a id="_idIndexMarker1541"/>code snippet is optimized, as it obtains the sales order count directly via SQL’s <code>GROUP </code><code>BY</code> feature.</p>
			<h2 id="_idParaDest-921"><a id="_idTextAnchor1133"/>How it works...</h2>
			<p>The <code>read_group()</code> method internally uses the <code>GROUP BY</code> feature of SQL. This makes the <code>read_group</code> method faster, even if you have large datasets. Internally, the Odoo web client uses this method in the charts and the grouped tree view. You can tweak the behavior of the <code>read_group</code> method by using different arguments.</p>
			<p>Let’s explore the signature of the <code>read_group</code> method:</p>
			<pre class="source-code">
def read_group(self, domain, fields, groupby, offset=0, limit=None, orderby=False, lazy=True):</pre>			<p>The different parameters available for the <code>read_group</code> method are as follows:</p>
			<ul>
				<li><code>domain</code>: This is used <a id="_idIndexMarker1542"/>to filter records. This will be the search criteria for the <code>read_group</code> method.</li>
				<li><code>fields</code>: This is a <a id="_idIndexMarker1543"/>list of the fields to fetch with the grouping. Note that the fields mentioned here should be in the <code>groupby</code> parameter, unless you use some aggregate functions. The <code>read_group</code> method supports the SQL aggregate functions. Let›s say you want to get the average order amount per customer. If so, you can use <code>read_group</code> as follows:<pre class="source-code">
self.env['sale.order'].read_group([], ['partner_id', 'amount_total:avg'], ['partner_id'])</pre><p class="list-inset">If you want <a id="_idIndexMarker1544"/>to access the same field twice but with a different aggregate function, the syntax is a little different. You need to pass the field name as <code>alias:agg(field_name)</code>. This example will give you the total and average number of orders per customer:</p><pre class="source-code">self.env['sale.order'].read_group([], ['partner_id', 'total:sum(amount_total)', 'avg_total:avg(amount_total)'], ['partner_id'])</pre></li>				<li><code>groupby</code>: This parameter will be a list of fields by which the records are grouped. It lets you group records <a id="_idIndexMarker1545"/>based on multiple fields. To do this, you will need to pass a list of fields. For example, if you want to group the sales orders by customer and order state, you can pass <code>['partner_id ', 'state']</code> in this parameter.</li>
				<li><code>offset</code>: This parameter is used for pagination. If you want to skip a few records, you can use this parameter.</li>
				<li><code>limit</code>: This parameter is used for pagination; it indicates the maximum number of records to fetch.</li>
				<li><code>lazy</code>: This parameter accepts Boolean values. By default, its value is <code>True</code>. If this parameter is <code>True</code>, the results are grouped only by the first field in the <code>groupby</code> parameter. You will get the remaining <code>groupby</code> parameters and the domain in the <code>__context</code> and <code>__domain</code> keys in the result. If the value of this parameter is set to <code>False</code>, it will group the data by all fields in the <code>groupby</code> parameter.</li>
			</ul>
			<h2 id="_idParaDest-922"><a id="_idTextAnchor1134"/>There’s more...</h2>
			<p>Grouping by date fields can be complicated because it is possible to group records based on days, weeks, quarters, months, or years. You can change the grouping behavior of the date field by passing <code>groupby_function</code> after <code>:</code> in the <code>groupby</code> parameter. If you want to group the monthly total of the sales orders, you can use the <code>read_group</code> method:</p>
			<pre class="source-code">
self.env['sale.order'].read_group([], ['total:sum(amount_total)'], ['order_date:month'])</pre>			<p>The possible options for date grouping are <code>day</code>, <code>week</code>, <code>month</code>, <code>quarter</code>, and <code>year</code>.</p>
			<h2 id="_idParaDest-923"><a id="_idTextAnchor1135"/>See also</h2>
			<p>Refer to the <a id="_idIndexMarker1546"/>documentation if you want to learn more about PostgreSQL aggregate functions: <a href="https://www.postgresql.org/docs/current/functions-aggregate.html">https://www.postgresql.org/docs/current/functions-aggregate.html</a>.</p>
			<h1 id="_idParaDest-924"><a id="_idTextAnchor1136"/>Creating or writing multiple records</h1>
			<p>If you are new <a id="_idIndexMarker1547"/>to Odoo development, you might execute <a id="_idIndexMarker1548"/>multiple queries to write or create multiple records. In this recipe, we will look at how to create and write records in batches.</p>
			<h2 id="_idParaDest-925"><a id="_idTextAnchor1137"/>How to do it...</h2>
			<p>Creating multiple records and writing on multiple records work differently under the hood. Let’s see each of these records one by one.</p>
			<h3>Creating multiple records</h3>
			<p>Odoo supports creating records in batches. If you are creating a single record, simply pass a dictionary with the field values. To create records in a batch, you just need to pass a list of these dictionaries instead of a single dictionary. The following example creates three room records in a single <code>create</code> call:</p>
			<pre class="source-code">
vals = [{
    'name': "Room A-101",
    'room_no': 101,
    'floor_no': 1,
    'student_per_room': 2,
}, {
    'name': "Room A-102",
    'room_no': 102,
    'floor_no': 1,
    'student_per_room': 3,
}, {
    'name': "Room B-201",
    'room_no': 201,
    'floor_no': 2,
    'student_per_room': 3,
}]
self.env['hostel.room'].create(vals)</pre>			<p>This code snippet <a id="_idIndexMarker1549"/>will create the records for three new books.</p>
			<h3>Writing on multiple records</h3>
			<p>When working with multiple versions of Odoo, it’s important to understand how the write method <a id="_idIndexMarker1550"/>behaves. In this case, it adopts a delayed approach for updates, meaning it doesn’t immediately write data to the database. Instead, Odoo only writes the data to the database when necessary or when the <code>flush()</code> method is called.</p>
			<p>Here are two examples of the <code>write</code> method:</p>
			<pre class="source-code">
# Example 1
data = {...}
for record in recordset:
    record.write(data)
# Example 2
data = {...}
recordset.write(data)</pre>			<p>If you are using <a id="_idIndexMarker1551"/>Odoo v13 or above, then there will not be any issues regarding performance. However, if you are using an older version, the second example will be much faster than the first one because the first example will execute a SQL query in each iteration.</p>
			<h2 id="_idParaDest-926"><a id="_idTextAnchor1138"/>How it works...</h2>
			<p>In order to create multiple records in a batch, you need to pass value dictionaries in the form of a list to create new records. This will automatically manage batch-creating the records. When you create records in a batch, doing so internally will insert a query for each record. This means that creating records in a batch is not done in a single query. However, this doesn’t mean that creating records in batches does not improve performance. The performance gain is achieved through batch-calculating computing fields.</p>
			<p>Things work differently for the <code>write</code> method. Most things are handled automatically by the framework. For instance, if you write the same data on all records, the database will be updated with only one <code>UPDATE</code> query. The framework will even handle it if you update the same record again and again in the same transaction, as follows:</p>
			<pre class="source-code">
recordset.name= 'Admin'
recordset.email= 'admin@example.com'
recordset.name= 'Administrator'
recordset.email= 'admin-2@example.com'</pre>			<p>In the previous code snippet, only one query will be executed for <code>write</code>, with the final values of <code>name=Administrator</code> and <code>email=admin-2@example.com</code>. This does not have a bad impact on performance, as the assigned values are in the cache and written later in a single query.</p>
			<p>Things are <a id="_idIndexMarker1552"/>different if you use the <code>flush()</code> method in between, as shown <a id="_idIndexMarker1553"/>in the following example:</p>
			<pre class="source-code">
recordset.name= 'Admin'
recordset.email= 'admin@example.com'
recordset.flush()
recordset.name= 'Administrator'
recordset.email= 'admin-2@example.com'</pre>			<p>The <code>flush()</code> method updates <a id="_idIndexMarker1554"/>the values from the cache to the database. So, in the previous example, two <code>UPDATE</code> queries will be executed – one with data before the flush and another with data after the flush.</p>
			<h2 id="_idParaDest-927"><a id="_idTextAnchor1139"/>There’s more...</h2>
			<p>If you are using an older version, then writing a single value will execute the <code>UPDATE</code> query immediately. Check the following examples to explore the correct usage of the <code>write</code> operation for an older version of Odoo:</p>
			<pre class="source-code">
# incorrect usage
recordset.name= 'Admin'
recordset.email= 'admin@example.com'
# correct usage
recordset.write({'name': 'Admin', 'email'= 'admin@example.com'})</pre>			<p>Here, in the first example, we have two <code>UPDATE</code> queries, while the second example will only take one <code>UPDATE</code> query.</p>
			<h1 id="_idParaDest-928"><a id="_idTextAnchor1140"/>Accessing records through database queries</h1>
			<p>Odoo ORM has limited methods, and sometimes, it is difficult to fetch certain data from ORM. In <a id="_idIndexMarker1555"/>these cases, you can fetch data <a id="_idIndexMarker1556"/>in the desired format, and you need to perform an operation on the data to get a certain result. Due to this, it becomes slower. To handle these special cases, you can execute SQL queries in the database. In this recipe, we will explore how you can run SQL queries from Odoo.</p>
			<h2 id="_idParaDest-929"><a id="_idTextAnchor1141"/>How to do it...</h2>
			<p>You can perform database queries using the <code>self._cr.execute</code> method:</p>
			<ol>
				<li>Add the following code:<pre class="source-code">
self.flush()
self._cr.execute("SELECT id, name, room_no, floor_no  FROM hostel_room WHERE name ilike %s", ('%Room A-%',))
data = self._cr.fetchall()
print(data)</pre><p class="list-inset">Here is the output:</p><pre class="source-code"><code>dictfetchall()</code> method. Take a look at the following example:<pre class="source-code">
self.flush()
self._cr.execute("SELECT id, name, room_no, floor_no  FROM hostel_room WHERE name ilike %s", ('%Room A-%',))
data = self._cr.dictfetchall()
print(data)</pre><p class="list-inset">Here is the output:</p><pre class="source-code"><strong class="bold">[{'id': 4, 'name': 'Room A-101', 'room_no': 101, 'floor_no': 1}, {'id': 5, 'name': 'Room A-103', 'room_no': 103, 'floor_no': 1}, {'id': 6, 'name': 'Room A-201', 'room_no': 201, 'floor_no': 2}]</strong></pre></li>			</ol>
			<p>If you want to fetch only a single record, you can use the <code>fetchone()</code> and <code>dictfetchone()</code> methods. These methods work like <code>fetchall()</code> and <code>dictfetchall()</code>, but they only return a single record, and you need to call the <code>fetchone()</code> and <code>dictfetchone()</code> methods multiple times if you want to fetch multiple records.</p>
			<h2 id="_idParaDest-930"><a id="_idTextAnchor1142"/>How it works...</h2>
			<p>There are <a id="_idIndexMarker1557"/>two ways to access the database cursor <a id="_idIndexMarker1558"/>from the recordset – one is from the recordset itself, such as <code>self._cr</code>, and the other is from the environment (in particular, <code>self.env.cr</code>). This cursor is used to execute database queries. In the preceding example, we saw how you can fetch data through raw queries. The table name is the name of the model after replacing <code>.</code> with <code>_</code>, so the <code>hostel.room</code> model becomes <code>hostel_room</code>.</p>
			<p>Note that we used <code>self.flush()</code> before executing a query. The reason behind this is that Odoo uses the cache excessively, and the database might not have the correct values. <code>self.flush()</code> will push all the delayed updates to the database and conduct all the dependent computations as well, and you will then get correct values from the database. The <code>flush()</code> method also supports a few parameters that help you control what is flushed in the database. The parameters are as follows:</p>
			<ul>
				<li>The <code>fname</code> parameter needs a list of fields that you want to flush to the database</li>
				<li>The <code>records</code> parameter needs a recordset, and it is used if you want to flush certain records only</li>
			</ul>
			<p>If you are executing <code>INSERT</code> or <code>UPDATE</code> queries, you will also need to execute <code>flush()</code> after executing the query because the ORM might not be aware of the change you made, and it might have cached records.</p>
			<p>You need to consider a few things before you execute raw queries. Only use raw queries when you have no other choice. By executing raw queries, you bypass the ORM layers. Therefore, you also bypass security rules and the ORM’s performance advantages. Sometimes, wrongly built queries can introduce SQL injection vulnerabilities. Consider the following example, in which the queries could allow an attacker to perform SQL injection:</p>
			<pre class="source-code">
# very bad, SQL injection possible
self.env.cr.execute('SELECT id, name FROM hostel_room WHERE name ilike + search_keyword + ';')
# good
self.env.cr.execute('SELECT id, name FROM hostel_room WHERE name ilike %s ';', (search_keyword,))</pre>			<p>Don’t use the <a id="_idIndexMarker1559"/>string format function either; it will also <a id="_idIndexMarker1560"/>allow an attacker to perform SQL injection. Using SQL queries makes your code harder to read and understand for other developers, so avoid using them wherever possible.</p>
			<p class="callout-heading">Information</p>
			<p class="callout">A lot of Odoo developers believe that executing SQL queries makes operations faster, as it bypasses the ORM layer. This is not completely true, however; it depends on the use case. In most operations, ORM performs better and faster than <code>RAW</code> queries because data is served from the recordset cache.</p>
			<h2 id="_idParaDest-931"><a id="_idTextAnchor1143"/>There’s more...</h2>
			<p>Operations made in one transaction are only committed at the end of it. If an error occurs in the ORM, the transaction is rolled back. If you have made an <code>INSERT</code> or <code>UPDATE</code> query and you want to make it permanent, you can use <code>self._cr.commit()</code> to commit the changes.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Note that using <code>commit()</code> can be dangerous because it can put records in an inconsistent state. An error <a id="_idIndexMarker1561"/>in the ORM can cause incomplete rollbacks, so only use <code>commit()</code> if you are completely sure of what you›re doing.</p>
			<p>If you use the <code>commit()</code> method, then there›s no need to use <code>flush()</code> afterward. The <code>commit()</code> method flushes the environment internally.</p>
			<h1 id="_idParaDest-932"><a id="_idTextAnchor1144"/>Profiling</h1>
			<p>Sometimes, you will be unable to pinpoint the cause of an issue. This is especially true of performance issues. Odoo provides some built-in profiling tools that help you find the real cause of an issue.</p>
			<p>Profiling is about <a id="_idIndexMarker1562"/>analyzing the execution of a program and measuring aggregated data. These data can be the elapsed time for each function, the executed SQL queries, and so on.</p>
			<p>While profiling does not improve the performance of a program by itself, it can prove very helpful in finding performance issues and identifying which part of the program is responsible for them.</p>
			<p>Code profiling in Odoo can help you identify performance and optimize your code. It is a technique used to analyze the code execution time, complexity of the program, and memory usage of an application.</p>
			<p>By using profiling techniques in Odoo, you can improve the overall performance and user experience of your ap<a id="_idTextAnchor1145"/>plication, making it faster and more efficient.</p>
			<h2 id="_idParaDest-933"><a id="_idTextAnchor1146"/>Enabling the profiler</h2>
			<p>The profiler can <a id="_idIndexMarker1563"/>either be enabled from the user interface, which is the easiest way to do so but only allows you to profile web requests, or from Python code:</p>
			<ol>
				<li>Enable developer mode.</li>
				<li>The profiler must be enabled globally on the database. This can be done in two ways:<ul><li>Open the developer mode tools, and then toggle the <strong class="bold">Enable profiling</strong> button. A wizard <a id="_idIndexMarker1564"/>suggests a set of expiry times for the profiling. Click on <strong class="bold">Enable profiling</strong> to enable the profiler globally.</li></ul></li>
			</ol>
			<div><div><img src="img/B20997_21_01.jpg" alt="Figure 21.1 – Enabling Profiling"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 21.1 – Enabling Profiling</p>
			<div><div><img src="img/B20997_21_02.jpg" alt="Figure 21.2 – Disabling profiling"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 21.2 – Disabling profiling</p>
			<ul>
				<li>Go to <strong class="bold">Settings</strong> | <strong class="bold">General Settings</strong> | <strong class="bold">Performance</strong> and set the des<a id="_idTextAnchor1147"/>ired time for <a id="_idIndexMarker1565"/>the field Enable profiling field.</li>
			</ul>
			<h3>Analyzing the results</h3>
			<p>To browse <a id="_idIndexMarker1566"/>the profiling results, make sure that the profiler is enabled globally on the database, then open the developer mode tools, and click on the button in the top-right corner of the profiling section. A list view of the <code>ir.profile</code> records grouped by profiling session will open.</p>
			<div><div><img src="img/B20997_21_03.jpg" alt="" role="presentation"/>
				</div>
			</div>
			<p>Each record <a id="_idIndexMarker1567"/>has a clickable link that opens the speedscope results in a new tab.</p>
			<div><div><img src="img/B20997_21_04.jpg" alt="" role="presentation"/>
				</div>
			</div>
			<p>Speedscope falls out of the scope of this documentation, but there are a lot of tools to try out – search, highlight of similar frames, zoom on frame, timeline, left heavy, sandwich view, and so on.</p>
			<p>Depending on <a id="_idIndexMarker1568"/>the profiling options that were activated, Odoo generates different view modes that you can access from the top menu.</p>
			<div><div><img src="img/B20997_21_05.jpg" alt="" role="presentation"/>
				</div>
			</div>
			<div><div><img src="img/B20997_21_06.jpg" alt="" role="presentation"/>
				</div>
			</div>
			<ul>
				<li><strong class="bold">Combined</strong>: The <strong class="bold">Combined</strong> view displays all of the SQL queries and traces that have been integrated together.</li>
				<li><strong class="bold">Combined no context</strong>: The <strong class="bold">Combined no context </strong>view produces the same results but disregards the stored execution context, performance/profiling/enable&gt;.</li>
				<li><strong class="bold">sql (no gap)</strong>: The <strong class="bold">sql (no gap)</strong> view displays all SQL queries as if they were done sequentially, without any Python logic. This is solely beneficial for SQL optimization.</li>
				<li><strong class="bold">sql (density)</strong>: Only  the SQL queries are displayed in the <strong class="bold">sql (no density)</strong> view, with space between them. This can help you discover areas where numerous tiny queries could be batch-processed <a id="_idIndexMarker1569"/>and determine whether the issue is with the Python or SQL code.</li>
				<li><strong class="bold">frames</strong>: Only the periodic collector’s results are displayed in the <strong class="bold">frames</strong> view.</li>
			</ul>
			<p class="callout-heading">Note</p>
			<p class="callout">Despite the profiler’s lightweight design, it can still affect performance, particularly when utilizing the <code>Sync</code> collector. Rem<a id="_idTextAnchor1148"/>ember that when you examine the speedscope data.</p>
			<h3>Collectors</h3>
			<p>Every collector <a id="_idIndexMarker1570"/>has a unique format and method to gather profiling data. Through their specific toggle button in the developer mode tools, or from Python code using their key or class, each can be independently enabled from the user interface.</p>
			<p>There are <a id="_idIndexMarker1571"/>currently four collectors available in Odoo:</p>
			<ul>
				<li><code>SQLColle<a id="_idTextAnchor1149"/>ctor</code></li>
				<li><code>PeriodicCollector</code></li>
				<li><code>QwebCollector</code></li>
				<li><code>SyncCollector</code></li>
			</ul>
			<h3>SQLCollector</h3>
			<p>All SQL queries <a id="_idIndexMarker1572"/>made to the database in the current thread (for all cursors) are saved by the <code>SQL</code> collector, together with the stack trace. Using the collector on a <a id="_idIndexMarker1573"/>large number of tiny queries could affect execution time and other profilers, since the overhead of the collector is added to the thread that is examined for each query.</p>
			<p>Debugging query counts and adding data to the <code>Periodic</code> collector in the combined speedscope view are two particularly helpful uses for it:</p>
			<pre class="source-code">
class SQLCollector(Collector):
   """
   Saves all executed queries in the curren<a id="_idTextAnchor1150"/>t thread with the call stack.
   """
   name = 'sql'</pre>			<h4>The Periodic collector</h4>
			<p>This collector <a id="_idIndexMarker1574"/>runs in a separate thread and saves the stack <a id="_idIndexMarker1575"/>trace of the analyzed thread at every interval. The interval (by default, 10 ms) can be defined through the <strong class="bold">Interval</strong> option in the user interface or the interval parameter in Python code.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Memory problems will arise when profiling lengthy queries if the interval is set extremely low. The interval will lose information on brief function executions if it is set extremely high.</p>
			<p>Because of its <a id="_idIndexMarker1576"/>distinct thread, it should have relatively little effect on <a id="_idIndexMarker1577"/>execution time, making it one of the finest ways to assess performance:</p>
			<pre class="source-code">
class PeriodicCollector(Collector):
   """
   Record execution frames asynchronously at most every `interval` seconds.
   :param interval (float): time to wait in seco<a id="_idTextAnchor1151"/>nds between two samples.
   """
   name = 'traces_async'</pre>			<h4>The Qweb collector</h4>
			<p>The Python <a id="_idIndexMarker1578"/>execution time and queries for each directive are reduced by this collector. With the SQL collector, the overhead may be significant <a id="_idIndexMarker1579"/>when a large number of tiny instructions are executed. In terms of data collected, the results differ from those of other collectors, and a custom widget can be used to examine them from the <code>ir.profile</code> form view.</p>
			<p>It is most helpful when trying to maximize views:</p>
			<pre class="source-code">
class QwebCollector(Collector):
   """
   Record qw<a id="_idTextAnchor1152"/>eb execution with directive trace.
   """
   name = 'qweb'</pre>			<h4>The Sync collector</h4>
			<p>Performance is <a id="_idIndexMarker1580"/>significantly impacted by this collector, since it operates on a single thread and saves the stack for each function call and return.</p>
			<p>Debugging and <a id="_idIndexMarker1581"/>comprehending intricate flows, as well as tracking their execution within the code, can be helpful. However, due to the significant overhead, performance analysis is not advised to use it:</p>
			<pre class="source-code">
class SyncCollector(Collector):
   """
   Record complete execution synchronously.
   Note that --limit-memory-hard may need to be i<a id="_idTextAnchor1153"/>ncreased when launching Odoo.
   """
   name = 'traces_sync'</pre>			<h3>Performance pitfalls</h3>
			<ul>
				<li>Be careful with randomness. Multiple executions may lead to different results – for example , a garbage collector being triggered during execution.</li>
				<li>Be careful <a id="_idIndexMarker1582"/>with blocking calls. In some cases, an external <code>c_call</code> may take some time before releasing the GIL, thus leading to unexpected long frames with the Periodic collector. This should be detected by the profiler and given a warning. It is possible to trigger the profiler manually before such calls if needed.</li>
				<li>Pay attention to the cache. Profiling before the view/assets/… are in a cache can lead to different results.</li>
				<li>Be aware of the profiler’s overhead. The SQL collector’s overhead can be important when many small queries are executed. Profiling is practical to spot a problem, but you may want to disable the profiler to measure a code change’s real impact.</li>
				<li>Profiling results can be memory-intensive. In some cases (e.g., profiling an install or a long request), you can <a id="_idIndexMarker1583"/>reach the memory limit, especially when rendering the speedscope results, which can lead to an HTTP 500 error. In this case, you may need to start the server with a higher memory limit – <code>--</code><code>limit-memory-hard $((8*1024**3)).</code></li>
			</ul>
		</div>
	</body></html>