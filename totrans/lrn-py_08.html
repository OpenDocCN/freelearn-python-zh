<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch08"/>Chapter 8. The Edges – GUIs and Scripts</h1></div></div></div><div><table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tr><td valign="top"> </td><td valign="top"><p><em>"A user interface is like a joke. If you have to explain it, it's not that good."</em></p></td><td valign="top"> </td></tr><tr><td valign="top"> </td><td colspan="2" align="right" valign="top" style="text-align: center">--<em>Martin LeBlanc</em></td></tr></table></div><p>In this chapter, we're going to work on a project together. We're going to prepare a very simple HTML page with a few images, and then we're going to scrape it, in order to save those images.</p><p>We're going to write a script to do this, which will allow us to talk about a few concepts that I'd like to run by you. We're also going to add a few options to save images based on their format, and to choose the way we save them. And, when we're done with the script, we're going to write a GUI application that does basically the same thing, thus killing two birds with one stone. Having only one project to explain will allow me to show a wider range of topics in this chapter.</p><div><div><h3 class="title"><a id="note51"/>Note</h3><p>A <strong>graphical user interface</strong> (<strong>GUI</strong>) is a type of interface that allows the user to interact <a id="id554" class="indexterm"/>with an electronic device through graphical icons, buttons and widgets, as opposed to text-based or command-line interfaces, which require commands or text to be typed on the keyboard. In a nutshell, any browser, any office suite such as LibreOffice, and, in general, anything that pops up when you click on an icon, is a GUI application.</p></div></div><p>So, if you haven't already done so, this would be the perfect time to start a console and position yourself in a folder called <code class="literal">ch8</code> in the root of your project for this book. Within that folder, we'll create two Python modules (<code class="literal">scrape.py</code> and <code class="literal">guiscrape.py</code>) and one standard folder (<code class="literal">simple_server</code>). Within <code class="literal">simple_server</code>, we'll write our HTML page (<code class="literal">index.html</code>) in<code class="literal"> simple_server</code>. Images will be stored in <code class="literal">ch8/simple_server/img</code>. The structure in <code class="literal">ch8</code> should look like this:</p><div><pre class="programlisting">
<strong>$ tree -A</strong>
<strong>.</strong>
<strong>├── guiscrape.py</strong>
<strong>├── scrape.py</strong>
<strong>└── simple_server</strong>
<strong>    ├── img</strong>
<strong>    │   ├── owl-alcohol.png</strong>
<strong>    │   ├── owl-book.png</strong>
<strong>    │   ├── owl-books.png</strong>
<strong>    │   ├── owl-ebook.jpg</strong>
<strong>    │   └── owl-rose.jpeg</strong>
<strong>    ├── index.html</strong>
<strong>    └── serve.sh</strong>
</pre></div><p>If you're using either Linux or Mac, you can do what I do and put the code to start the HTTP server in a <code class="literal">serve.sh</code> file. On Windows, you'll probably want to use a batch file.</p><p>The HTML page we're going to scrape has the following structure:</p><p>
<code class="literal">simple_server/index.html</code>
</p><div><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;&lt;title&gt;Cool Owls!&lt;/title&gt;&lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Welcome to my owl gallery&lt;/h1&gt;
    &lt;div&gt;
      &lt;img src="img/strong>" height="128" /&gt;
      &lt;img src="img/strong>" height="128" /&gt;
      &lt;img src="img/strong>" height="128" /&gt;
      &lt;img src="img/strong>" height="128" /&gt;
      &lt;img src="img/strong>" height="128" /&gt;
    &lt;/div&gt;
    &lt;p&gt;Do you like my owls?&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre></div><p>It's an extremely simple page, so let's just note that we have five images, three of which are PNGs and two are JPGs (note that even though they are both JPGs, one ends with <code class="literal">.jpg</code> and the other with <code class="literal">.jpeg</code>, which are both valid extensions for this format).</p><p>So, Python gives you a very simple HTTP server for free that you can start with the following command (in the <code class="literal">simple_server</code> folder):</p><div><pre class="programlisting">
<strong>$ python -m http.server 8000</strong>
<strong>Serving HTTP on 0.0.0.0 port 8000 ...</strong>
<strong>127.0.0.1 - - [31/Aug/2015 16:11:10] "GET / HTTP/1.1" 200 -</strong>
</pre></div><p>The last line is the log you get when you access <code class="literal">http://localhost:8000</code>, where our beautiful page will be served. Alternatively, you can put that command in a file called <code class="literal">serve.sh</code>, and just run that with this command (make sure it's executable):</p><div><pre class="programlisting">
<strong>$ ./serve.sh</strong>
</pre></div><p>It will have the same effect. If you have the code for this book, your page should look something like this:</p><div><img src="img/4715_08_01.jpg" alt="The Edges – GUIs and Scripts"/></div><p>Feel free to use any other set of images, as long as you use at least one PNG and one JPG, and that<a id="id555" class="indexterm"/> in the <code class="literal">src</code> tag you use relative paths, not absolute. I got those lovely owls from <a class="ulink" href="https://openclipart.org/">https://openclipart.org/</a>.</p><div><div><div><div><h1 class="title"><a id="ch08lvl1sec68"/>First approach – scripting</h1></div></div></div><p>Now, let's <a id="id556" class="indexterm"/>start writing the script. I'll go through the source in three steps: imports first, then<a id="id557" class="indexterm"/> the argument parsing logic, and finally the business logic.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec97"/>The imports</h2></div></div></div><p>
<code class="literal">scrape.py (Imports)</code>
</p><div><pre class="programlisting">import argparse
import base64
import json
import os
from bs4 import BeautifulSoup
import requests</pre></div><p>Going through them from the top, you can see that we'll need to parse the arguments. which we'll<a id="id558" class="indexterm"/> feed to the script itself (<code class="literal">argparse</code>). We will need the <code class="literal">base64</code> library to save the images within a JSON file (<code class="literal">base64</code> and <code class="literal">json</code>), and we'll need to open files for writing (<code class="literal">os</code>). Finally, we'll need <code class="literal">BeautifulSoup</code> for scraping the web page easily, and <code class="literal">requests</code> to fetch its content. <code class="literal">requests</code> is an extremely popular library for performing HTTP requests, built to avoid the difficulties and quirks of using the standard library <code class="literal">urllib</code> module. It's based on the fast <code class="literal">urllib3</code> third-party library.</p><div><div><h3 class="title"><a id="note52"/>Note</h3><p>We will explore the HTTP protocol and <code class="literal">requests</code> mechanism in <a class="link" href="ch10.html" title="Chapter 10. Web Development Done Right">Chapter 10</a>, <em>Web Development Done Right</em> so, for now, let's just (simplistically) say that we perform an HTTP request to fetch the content of a web page. We can do it programmatically using a library such as <code class="literal">requests</code>, and it's more or less the equivalent of typing a URL in your browser and pressing <em>Enter</em> (the browser then fetches the content of a web page and also displays it to you).</p></div></div><p>Of all these imports, only the last two don't belong to the Python standard library, but they are so widely used throughout the world that I dare not exclude them in this book. Make sure you have them installed:</p><div><pre class="programlisting">
<strong>$ pip freeze | egrep -i "soup|requests"</strong>
<strong>beautifulsoup4==4.4.0</strong>
<strong>requests==2.7.0</strong>
</pre></div><p>Of course, the version numbers might be different for you. If they're not installed, use this command to do so:</p><div><pre class="programlisting">
<strong>$ pip install beautifulsoup4 requests</strong>
</pre></div><p>At this point, the only thing that I reckon might confuse you is the <code class="literal">base64/json</code> couple, so allow me to spend a few words on that.</p><p>As we saw in the previous chapter, JSON is one of the most popular formats for data exchange between applications. It's also widely used for other purposes too, for example, to save data in a file. In our script, we're going to offer the user the ability to save images as image files, or as a JSON single file. Within the JSON, we'll put a dictionary with keys as the images names and values as their content. The only issue is that saving images in the binary format is tricky, and this is where the <code class="literal">base64</code> library comes to the rescue. <strong>Base64</strong> is a very<a id="id559" class="indexterm"/> popular binary-to-text encoding scheme that represents binary data in an ASCII string format by translating it into a radix-64 representation.</p><div><div><h3 class="title"><a id="note53"/>Note</h3><p>The <strong>radix-64</strong> representation uses the letters <em>A</em>-<em>Z</em>, <em>a</em>-<em>z</em>, and the digits <em>0</em>-<em>9</em>, plus the two <a id="id560" class="indexterm"/>symbols <em>+</em> and <em>/</em> for a grand total of 64 symbols altogether. Therefore, not surprisingly, the Base64 alphabet is made up of these 64 symbols.</p></div></div><p>If you think<a id="id561" class="indexterm"/> you have never used it, think again. Every time you send an email with an image attached to it, the image gets encoded with Base64 before the email is sent. On the recipient side, images are automatically decoded into their original binary format so that the email client can display them.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec98"/>Parsing arguments</h2></div></div></div><p>Now that<a id="id562" class="indexterm"/> the technicalities are out of the way, let's see the second section of our script (it should be at the end of the <code class="literal">scrape.py</code> module).</p><p>
<code class="literal">scrape.py (Argument parsing and scraper triggering)</code>
</p><div><pre class="programlisting">if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description='Scrape a webpage.')
    parser.add_argument(
        '-t',
        '--type',
        choices=['all', 'png', 'jpg'],
        default='all',
        help='The image type we want to scrape.')
    parser.add_argument(
        '-f',
        '--format',
        choices=['img', 'json'],
        default='img',
        help='The format images are saved to.')
    parser.add_argument(
        'url',
        help='The URL we want to scrape for images.')
    args = parser.parse_args()
    scrape(args.url, args.format, args.type)</pre></div><p>Look at that first line; it is a very common idiom when it comes to scripting. According to the official Python documentation, the string <code class="literal">'__main__'</code> is the name of the scope in which top-level code executes. A module's <code class="literal">__name__</code> is set equal to <code class="literal">'__main__'</code> when read from standard input, a script, or from an interactive prompt.</p><p>Therefore, if you put the execution logic under that <code class="literal">if</code>, the result is that you will be able to use the module as a library should you need to import any of the functions or objects defined in it, because when importing it from another module, <code class="literal">__name__</code> won't be <code class="literal">'__main__'</code>. On the other hand, when you run the script directly, like we're going to, <code class="literal">__name__</code> will be <code class="literal">'__main__'</code>, so the execution logic will run.</p><p>The first thing we do then is define our parser. I would recommend using the standard library module, <code class="literal">argparse</code>, which is simple enough and quite powerful. There are other options out there, but in this case, <code class="literal">argparse</code> will provide us with all we need.</p><p>We <a id="id563" class="indexterm"/>want to feed our script three different data: the type of images we want to save, the format in which we want to save them, and the URL for the page to be scraped.</p><p>The type can be PNG, JPG or both (default), while the format can be either image or JSON, image being the default. URL is the only mandatory argument.</p><p>So, we add the <code class="literal">-t</code> option, allowing also the long version <code class="literal">--type</code>. The choices are <code class="literal">'all'</code>, <code class="literal">'png'</code>, and <code class="literal">'jpg'</code>. We set the default to <code class="literal">'all'</code> and we add a help message.</p><p>We do a similar procedure for the <code class="literal">format</code> argument allowing both the short and long syntax (<code class="literal">-f</code> and <code class="literal">--format</code>), and finally we add the <code class="literal">url</code> argument, which is the only one that is specified differently so that it won't be treated as an option, but rather as a positional argument.</p><p>In order to parse all the arguments, all we need is <code class="literal">parser.parse_args()</code>. Very simple, isn't it?</p><p>The last line is where we trigger the actual logic, by calling the <code class="literal">scrape</code> function, passing all the arguments we just parsed. We will see its definition shortly.</p><p>The nice thing about <code class="literal">argparse</code> is that if you call the script by passing <code class="literal">-h</code>, it will print a nice <strong>usage text</strong> for you automatically. Let's try it out:</p><div><pre class="programlisting">
<strong>$ python scrape.py -h</strong>
<strong>usage: scrape.py [-h] [-t {all,png,jpg}] [-f {img,json}] url</strong>
</pre></div><div><pre class="programlisting">
<strong>Scrape a webpage.</strong>

<strong>positional arguments:</strong>
<strong>  url                   The URL we want to scrape for images.</strong>

<strong>optional arguments:</strong>
<strong>  -h, --help            show this help message and exit</strong>
<strong>  -t {all,png,jpg}, --type {all,png,jpg}</strong>
<strong>                        The image type we want to scrape.</strong>
<strong>  -f {img,json}, --format {img,json}</strong>
<strong>                        The format images are saved to.</strong>
</pre></div><p>If you think about it, the one true advantage of this is that we just need to specify the arguments and we don't have to worry about the usage text, which means we won't have to keep it in sync with the arguments' definition every time we change something. This is precious.</p><p>Here's a few <a id="id564" class="indexterm"/>different ways to call our <code class="literal">scrape.py</code> script, which demonstrate that <code class="literal">type</code> and <code class="literal">format</code> are optional, and how you can use the short and long syntax to use them:</p><div><pre class="programlisting">
<strong>$ python scrape.py http://localhost:8000</strong>
<strong>$ python scrape.py -t png http://localhost:8000</strong>
<strong>$ python scrape.py --type=jpg -f json http://localhost:8000</strong>
</pre></div><p>The first one is using default values for <code class="literal">type</code> and <code class="literal">format</code>. The second one will save only PNG images, and the third one will save only JPGs, but in JSON format.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec99"/>The business logic</h2></div></div></div><p>Now that <a id="id565" class="indexterm"/>we've seen the scaffolding, let's dive deep into the actual logic (if it looks intimidating don't worry; we'll go through it together). Within the script, this logic lies after the imports and before the parsing (before the <code class="literal">if __name__</code> clause):</p><p>
<code class="literal">scrape.py (Business logic)</code>
</p><div><pre class="programlisting">def scrape(url, format_, type_):
    try:
        page = requests.get(url)
    except requests.RequestException as rex:
        print(str(rex))
    else:
        soup = BeautifulSoup(page.content, 'html.parser')
        images = _fetch_images(soup, url)
        images = _filter_images(images, type_)
        _save(images, format_)

def _fetch_images(soup, base_url):
    images = []
    for img in soup.findAll('img'):
        src = img.get('src')
        img_url = (
            '{base_url}/{src}'.format(
                base_url=base_url, src=src))
        name = img_url.split('/')[-1]
        images.append(dict(name=name, url=img_url))
    return images

def _filter_images(images, type_):
    if type_ == 'all':
        return images
    ext_map = {
        'png': ['.png'],
        'jpg': ['.jpg', '.jpeg'],
    }
    return [
        img for img in images
        if _matches_extension(img['name'], ext_map[type_])
    ]

def _matches_extension(filename, extension_list):
    name, extension = os.path.splitext(filename.lower())
    return extension in extension_list

def _save(images, format_):
    if images:
        if format_ == 'img':
            _save_images(images)
        else:
            _save_json(images)
        print('Done')
    else:
        print('No images to save.')

def _save_images(images):
    for img in images:
        img_data = requests.get(img['url']).content
        with open(img['name'], 'wb') as f:
            f.write(img_data)

def _save_json(images):
    data = {}
    for img in images:
        img_data = requests.get(img['url']).content
        b64_img_data = base64.b64encode(img_data)
        str_img_data = b64_img_data.decode('utf-8')
        data[img['name']] = str_img_data

    with open('images.json', 'w') as ijson:
        ijson.write(json.dumps(data))</pre></div><p>Let's start <a id="id566" class="indexterm"/>with the <code class="literal">scrape</code> function. The first thing it does is fetch the page at the given <code class="literal">url</code> argument. Whatever error may happen while doing this, we trap it in the <code class="literal">RequestException rex</code> and we print it. The <code class="literal">RequestException</code> is the base exception class for all the exceptions in the <code class="literal">requests</code> library.</p><p>However, if things go well, and we have a page back from the <code class="literal">GET</code> request, then we can proceed (<code class="literal">else</code> branch) and feed its content to the <code class="literal">BeautifulSoup</code> parser. The <code class="literal">BeautifulSoup</code> library allows us to parse a web page in no time, without having to write all the logic that would be needed to find all the images in a page, which we really don't want to do. It's not as easy as it seems, and reinventing the wheel is never good. To fetch images, we use the <code class="literal">_fetch_images</code> function and we filter them with <code class="literal">_filter_images</code>. Finally, we call <code class="literal">_save</code> with the result.</p><p>Splitting the code into different functions with meaningful names allows us to read it more easily. Even if you haven't seen the logic of the <code class="literal">_fetch_images</code>, <code class="literal">_filter_images,</code> and <code class="literal">_save</code> functions, it's not hard to predict what they do, right?</p><p>
<code class="literal">_fetch_images</code> takes a <code class="literal">BeautifulSoup</code> object and a base URL. All it does is looping through all of the images found on the page and filling in the <code class="literal">'name'</code> and <code class="literal">'url'</code> information about them in a dictionary (one per image). All dictionaries are added to the <code class="literal">images</code> list, which is returned at the end.</p><p>There is some trickery going on when we get the name of an image. What we do is split the <code class="literal">img_url</code> (<code class="literal">http://localhost:8000/img/my_image_name.png</code>) string using <code class="literal">'/'</code> as a separator, and we take the last item as the image name. There is a more robust way of doing this, but for this example it would be overkill. If you want to see the details of each step, try to break this logic down into smaller steps, and print the result of each of them to help yourself understand.</p><p>Towards the end of the book, I'll show you another technique to debug in a much more efficient way.</p><p>Anyway, by just adding <code class="literal">print(images)</code> at the end of the <code class="literal">_fetch_images</code> function, we get this:</p><div><pre class="programlisting">
<strong>[{'url': 'http://localhost:8000/img/owl-alcohol.png', 'name': 'owl-alcohol.png'}, {'url': 'http://localhost:8000/img/owl-book.png', 'name': 'owl-book.png'}, ...]</strong>
</pre></div><p>I truncated the result for brevity. You can see each dictionary has a <code class="literal">'url'</code> and <code class="literal">'name'</code> key/value pair, which we can use to fetch, identify and save our images as we like. At this point, I hear you asking what would happen if the images on the page were specified with an absolute path instead of a relative one, right? Good question!</p><p>The answer is that the script will fail to download them because this logic expects relative paths. I was about to add a bit of logic to solve this issue when I thought that, at this stage, it would be a nice exercise for you to do it, so I'll leave it up to you to fix it.</p><div><div><h3 class="title"><a id="tip17"/>Tip</h3><p>Hint: inspect the start of that <code class="literal">src</code> variable. If it starts with <code class="literal">'http'</code>, then it's probably an absolute path.</p></div></div><p>I hope the <a id="id567" class="indexterm"/>body of the <code class="literal">_filter_images</code> function is interesting to you. I wanted to show you how to check on multiple extensions by using a mapping technique.</p><p>In this function, if <code class="literal">type_</code> is <code class="literal">'all'</code>, then no filtering is required, so we just return all the images. On the other hand, when <code class="literal">type_</code> is not <code class="literal">'all'</code>, we get the allowed extensions from the <code class="literal">ext_map</code> dictionary, and use it to filter the images in the list comprehension that ends the function body. You can see that by using another helper function, <code class="literal">_matches_extension</code>, I have made the list comprehension simpler and more readable.</p><p>All <code class="literal">_matches_extension</code> does is split the name of the image getting its extension and checking whether it is within the list of allowed ones. Can you find one micro improvement (speed-wise) that could be done to this function?</p><p>I'm sure that you're wondering why I have collected all the images in the list and then removed them, instead of checking whether I wanted to save them before adding them to the list. The first reason is that I needed <code class="literal">_fetch_images</code> in the GUI app as it is now. A second reason is that combining, fetching, and filtering would produce a longer and a bit more complicated function, and I'm trying to keep the complexity level down. A third reason is that this could be a nice exercise for you to do. Feels like we're pairing here...</p><p>Let's keep going through the code and inspect the <code class="literal">_save</code> function. You can see that, when <code class="literal">images</code> isn't empty, this basically acts as a dispatcher. We either call <code class="literal">_save_images</code> or <code class="literal">_save_json</code>, depending on which information is stored in the <code class="literal">format_</code> variable.</p><p>We are almost done. Let's jump to <code class="literal">_save_images</code>. We loop on the <code class="literal">images</code> list and for each dictionary we find there we perform a <code class="literal">GET</code> request on the image URL and save its content in a file, which we name as the image itself. The one important thing to note here is how we save that file.</p><p>We use a <strong>context manager</strong>, represented by the keyword <code class="literal">with</code>, to do that. Python's <code class="literal">with</code> statement<a id="id568" class="indexterm"/> supports the concept of a runtime context defined by a context manager. This is implemented using a pair of methods (<code class="literal">contextmanager.__enter__()</code> and <code class="literal">contextmanager.__exit__(exc_type, exc_val, exc_tb)</code>) that allow user-defined classes to define a runtime context that is entered before the statement body is executed and exited when the statement ends.</p><p>In our case, using a context manager, in conjunction with the open function, gives us the guarantee that if anything bad were to happen while writing that file, the resources involved in the process will be cleaned up and released properly regardless of the error. Have you ever tried to delete a file on Windows, only to be presented with an alert that tells you that you cannot delete the file because there is another process that is holding on to it? We're avoiding that sort of very annoying thing.</p><p>When we open a file, we get a handler for it and, no matter what happens, we want to be sure we release it when we're done with the file. A context manager is the tool we need to make sure of that.</p><p>Finally, let's<a id="id569" class="indexterm"/> now step into the <code class="literal">_save_json</code> function. It's very similar to the previous one. We basically fill in the <code class="literal">data</code> dictionary. The image name is the <em>key</em>, and the Base64 representation of its binary content is the <em>value</em>. When we're done populating our dictionary, we use the <code class="literal">json</code> library to dump it in the <code class="literal">images.json</code> file. I'll give you a small preview of that:</p><p>
<code class="literal">images.json (truncated)</code>
</p><div><pre class="programlisting">
<strong>{</strong>
<strong>  "owl-ebook.jpg": "/9j/4AAQSkZJRgABAQEAMQAxAAD/2wBDAAEBAQ...</strong>
<strong>  "owl-book.png": "iVBORw0KGgoAAAANSUhEUgAAASwAAAEbCAYAAAB...</strong>
<strong>  "owl-books.png": "iVBORw0KGgoAAAANSUhEUgAAASwAAAElCAYAAA...</strong>
<strong>  "owl-alcohol.png": "iVBORw0KGgoAAAANSUhEUgAAASwAAAEICAYA...</strong>
<strong>  "owl-rose.jpeg": "/9j/4AAQSkZJRgABAQEANAA0AAD/2wBDAAEBAQ...</strong>
<strong>}</strong>
</pre></div><p>And that's it! Now, before proceeding to the next section, make sure you play with this script and understand well how it works. Try and modify something, print out intermediate results, add a new argument or functionality, or scramble the logic. We're going to migrate it into a GUI application now, which will add a layer of complexity simply because we'll have to build the GUI interface, so it's important that you're well acquainted with the business logic: it will allow you to concentrate on the rest of the code.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec69"/>Second approach – a GUI application</h1></div></div></div><p>There <a id="id570" class="indexterm"/>are several libraries to write GUI applications in Python. The<a id="id571" class="indexterm"/> most famous ones are <strong>tkinter</strong>, <strong>wxPython</strong>, <strong>PyGTK</strong>, and <strong>PyQt</strong>. They <a id="id572" class="indexterm"/>all offer a wide range of tools and widgets that you can<a id="id573" class="indexterm"/> use <a id="id574" class="indexterm"/>to compose a GUI application.</p><p>The one I'm going to use for the rest of this chapter is tkinter. <strong>tkinter</strong> stands for <strong>Tk interface</strong> and it <a id="id575" class="indexterm"/>is the standard Python interface to the Tk GUI toolkit. Both Tk and tkinter are available on most Unix platforms, Mac OS X, as well as on Windows systems.</p><p>Let's make sure that <code class="literal">tkinter</code> is installed properly on your system by running this command:</p><div><pre class="programlisting">
<strong>$ python -m tkinter</strong>
</pre></div><p>It should open a dialog window demonstrating a simple <code class="literal">Tk</code> interface. If you can see that, then we're good to go. However, if it doesn't work, please search for <code class="literal">tkinter</code> in the Python official documentation. You will find several links to resources that will help you get up and running with it.</p><p>We're <a id="id576" class="indexterm"/>going to make a very simple GUI application that basically mimics the behavior of the script we saw in the first part of this chapter. We won't add the ability to save JPGs or PNGs singularly, but after you've gone through this chapter, you should be able to play with the code and put that feature back in by yourself.</p><p>So, this is what we're aiming for:</p><div><img src="img/4715_08_02.jpg" alt="Second approach – a GUI application"/></div><p>Gorgeous, isn't it? As you can see, it's a very simple interface (this is how it should look on Ubuntu). There is a frame (that is, a container) for the <strong>URL</strong> field and the <strong>Fetch info</strong> button, another frame for the <strong>Listbox</strong> to hold the image names and the radio button to control the way we save them, and finally there is a <strong>Scrape!</strong> button at the bottom. We also have a status bar, which shows us some information.</p><p>In order to get this layout, we could just place all the widgets on a root window, but that would make the layout logic quite messy and unnecessarily complicated. So, instead, we will divide the space using frames and place the widgets in those frames. This way we will achieve a much nicer result. So, this is the draft for the layout:</p><div><img src="img/4715_08_03.jpg" alt="Second approach – a GUI application"/></div><p>We have <a id="id577" class="indexterm"/>a <strong>Root Window</strong>, which is the main window of the application. We divide it into two rows, the first one in which we place the <strong>Main Frame</strong>, and the second one in which we place the <strong>Status Frame</strong> (which will hold the status bar). The <strong>Main Frame</strong> is subsequently divided into three rows itself. In the first one we place the <strong>URL Frame</strong>, which holds the <strong>URL</strong> widgets. In the second one we place the <strong>Img Frame</strong>, which will hold the <strong>Listbox</strong> and the <strong>Radio Frame</strong>, which will host a label and the radio button widgets. And finally a third one, which will just hold the <strong>Scrape</strong> button.</p><p>In order to lay out frames and widgets, we will use a layout manager called <em>grid</em>, that simply divides up the space into rows and columns, as in a matrix.</p><p>Now, all the code I'm going to write comes from the <code class="literal">guiscrape.py</code> module, so I won't repeat its name for each snippet, to save space. The module is logically divided into three sections, not unlike the script version: imports, layout logic, and business logic. We're going to analyze them line<a id="id578" class="indexterm"/> by line, in three chunks.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec100"/>The imports</h2></div></div></div><div><pre class="programlisting">from tkinter import *
from tkinter import ttk, filedialog, messagebox
import base64
import json
import os
from bs4 import BeautifulSoup
import requests</pre></div><p>We're already<a id="id579" class="indexterm"/> familiar with most of these. The interesting bit here is those first two lines. The first one is quite common practice, although it is bad practice in Python to import using the <em>star syntax.</em> You can incur in name collisions and, if the module is too big, importing everything would be expensive.</p><p>After that, we import <code class="literal">ttk</code>, <code class="literal">filedialog</code>, and <code class="literal">messagebox</code> explicitly, following the conventional approach used with this library. <code class="literal">ttk</code> is the new set of styled widgets. They behave basically like the old ones, but are capable of drawing themselves correctly according to the style your OS is set on, which is nice.</p><p>The rest of the imports is what we need in order to carry out the task you know well by now. Note that there is nothing we need to install with <code class="literal">pip</code> in this second part, we already have everything we need.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec101"/>The layout logic</h2></div></div></div><p>I'm going<a id="id580" class="indexterm"/> to paste it chunk by chunk so that I can explain it easily to you. You'll see how all those pieces we talked about in the layout draft are arranged and glued together. What I'm about to paste, as we did in the script before, is the final part of the <code class="literal">guiscrape.py</code> module. We'll leave the middle part, the business logic, for last.</p><div><pre class="programlisting">if __name__ == "__main__":
    _root = Tk()
    _root.title('Scrape app')</pre></div><p>As you know by now, we only want to execute the logic when the module is run directly, so that first line shouldn't surprise you.</p><p>In the last two lines. we set up the main window, which is an instance of the <code class="literal">Tk</code> class. We instantiate it and give it a title. Note that I use the prepending underscore technique for all the names of the <code class="literal">tkinter</code> objects, in order to avoid potential collisions with names in the business logic. I just find it cleaner like this, but you're allowed to disagree.</p><div><pre class="programlisting">    _mainframe = ttk.Frame(_root, padding='5 5 5 5')
    _mainframe.grid(row=0, column=0, sticky=(E, W, N, S))</pre></div><p>Here, we set up the <strong>Main Frame</strong>. It's a <code class="literal">ttk.Frame</code> instance. We set <code class="literal">_root</code> as its parent, and give it some padding. The <code class="literal">padding</code> is a measure in pixels of how much space should be inserted between the inner content and the borders in order to let our layout breathe a little, otherwise we have the <em>sardine effect</em>, where widgets are packed too tightly.</p><p>The second line is much more interesting. We place this <code class="literal">_mainframe</code> on the first row (<code class="literal">0</code>) and first column (<code class="literal">0</code>) of the parent object (<code class="literal">_root</code>). We also say that this frame needs to extend<a id="id581" class="indexterm"/> itself in each direction by using the <code class="literal">sticky</code> argument with all four cardinal directions. If you're wondering where they came from, it's the <code class="literal">from tkinter import *</code> magic that brought them to us.</p><div><pre class="programlisting">    _url_frame = ttk.LabelFrame(
        _mainframe, text='URL', padding='5 5 5 5')
    _url_frame.grid(row=0, column=0, sticky=(E, W))
    _url_frame.columnconfigure(0, weight=1)
    _url_frame.rowconfigure(0, weight=1)</pre></div><p>Next, we start by placing the <strong>URL Frame</strong> down. This time, the parent object is <code class="literal">_mainframe</code>, as you will recall from our draft. This is not just a simple <code class="literal">Frame</code>, but it's actually a <code class="literal">LabelFrame</code>, which means we can set the text argument and expect a rectangle to be drawn around it, with the content of the text argument written in the top-left part of it (check out the previous picture if it helps). We position this frame at (0, 0), and say that it should expand to the left and to the right. We don't need the other two directions.</p><p>Finally, we use <code class="literal">rowconfigure</code> and <code class="literal">columnconfigure</code> to make sure it behaves correctly, should it need to resize. This is just a formality in our present layout.</p><div><pre class="programlisting">    _url = StringVar()
    _url.set('http://localhost:8000')
    _url_entry = ttk.Entry(
        _url_frame, width=40, textvariable=_url)
    _url_entry.grid(row=0, column=0, sticky=(E, W, S, N), padx=5)
    _fetch_btn = ttk.Button(
        _url_frame, text='Fetch info', command=fetch_url)
    _fetch_btn.grid(row=0, column=1, sticky=W, padx=5)</pre></div><p>Here, we have the code to lay out the URL textbox and the <code class="literal">_fetch</code> button. A textbox in this environment is called <code class="literal">Entry</code>. We instantiate it as usual, setting <code class="literal">_url_frame</code> as its parent and giving it a width. Also, and this is the most interesting part, we set the <code class="literal">textvariable</code> argument to be <code class="literal">_url</code>. <code class="literal">_url</code> is a <code class="literal">StringVar</code>, which is an object that is now connected to <code class="literal">Entry</code> and will be used to manipulate its content. Therefore, we don't modify the text in the <code class="literal">_url_entry</code> instance directly, but by accessing <code class="literal">_url</code>. In this case, we call the <code class="literal">set</code> method on it to set the initial value to the URL of our local web page.</p><p>We position <code class="literal">_url_entry</code> at (0, 0), setting all four cardinal directions for it to stick to, and we also set a bit of extra padding on the left and right edges by using <code class="literal">padx</code>, which adds padding on the x-axis (horizontal). On the other hand, <code class="literal">pady</code> takes care of the vertical direction.</p><p>By now, you should get that every time you call the <code class="literal">.grid</code> method on an object, we're basically telling the grid layout manager to place that object somewhere, according to rules that we specify as arguments in the <code class="literal">grid()</code> call.</p><p>Similarly, we set up and place the <code class="literal">_fetch</code> button. The only interesting parameter is <code class="literal">command=fetch_url</code>. This means that when we click this button, we actually call the <code class="literal">fetch_url</code> function. This<a id="id582" class="indexterm"/> technique is called <strong>callback</strong>.</p><div><pre class="programlisting">    _img_frame = ttk.LabelFrame(
        _mainframe, text='Content', padding='9 0 0 0')
    _img_frame.grid(row=1, column=0, sticky=(N, S, E, W))</pre></div><p>This is what <a id="id583" class="indexterm"/>we called <strong>Img Frame</strong> in the layout draft. It is placed on the second row of its parent <code class="literal">_mainframe</code>. It will hold the <code class="literal">Listbox</code> and the <strong>Radio Frame</strong>.</p><div><pre class="programlisting">    _images = StringVar()
    _img_listbox = Listbox(
        _img_frame, listvariable=_images, height=6, width=25)
    _img_listbox.grid(row=0, column=0, sticky=(E, W), pady=5)
    _scrollbar = ttk.Scrollbar(
        _img_frame, orient=VERTICAL, command=_img_listbox.yview)
    _scrollbar.grid(row=0, column=1, sticky=(S, N), pady=6)
    _img_listbox.configure(yscrollcommand=_scrollbar.set)</pre></div><p>This is probably the most interesting bit of the whole layout logic. As we did with the <code class="literal">_url_entry</code>, we need to drive the contents of <code class="literal">Listbox</code> by tying it to a variable <code class="literal">_images</code>. We set up <code class="literal">Listbox</code> so that <code class="literal">_img_frame</code> is its parent, and <code class="literal">_images</code> is the variable it's tied to. We also pass some dimensions.</p><p>The interesting bit comes from the <code class="literal">_scrollbar</code> instance. Note that, when we instantiate it, we set its command to <code class="literal">_img_listbox.yview</code>. This is the first half of the contract between a <code class="literal">Listbox</code> and a <code class="literal">Scrollbar</code>. The other half is provided by the <code class="literal">_img_listbox.configure</code> method, which sets the <code class="literal">yscrollcommand=_scrollbar.set</code>.</p><p>By providing this reciprocal bond, when we scroll on <code class="literal">Listbox</code>, the <code class="literal">Scrollbar</code> will move accordingly and vice-versa, when we operate the <code class="literal">Scrollbar</code>, the Listbox will scroll accordingly.</p><div><pre class="programlisting">    _radio_frame = ttk.Frame(_img_frame)
    _radio_frame.grid(row=0, column=2, sticky=(N, S, W, E))</pre></div><p>We place the <strong>Radio Frame</strong>, ready to be populated. Note that the <code class="literal">Listbox</code> is occupying (0, 0) on <code class="literal">_img_frame</code>, the <code class="literal">Scrollbar</code> (0, 1) and therefore <code class="literal">_radio_frame</code> will go in (0, 2).</p><div><pre class="programlisting">    _choice_lbl = ttk.Label(
        _radio_frame, text="Choose how to save images")
    _choice_lbl.grid(row=0, column=0, padx=5, pady=5)
    _save_method = StringVar()
    _save_method.set('img')
    _img_only_radio = ttk.Radiobutton(
        _radio_frame, text='As Images', variable=_save_method,
        value='img')
    _img_only_radio.grid(
        row=1, column=0, padx=5, pady=2, sticky=W)
    _img_only_radio.configure(state='normal')
    _json_radio = ttk.Radiobutton(
        _radio_frame, text='As JSON', variable=_save_method,
        value='json')
    _json_radio.grid(row=2, column=0, padx=5, pady=2, sticky=W)</pre></div><p>Firstly, we<a id="id584" class="indexterm"/> place the label, and we give it some padding. Note that the label and radio buttons are children of <code class="literal">_radio_frame</code>.</p><p>As for the <code class="literal">Entry</code> and <code class="literal">Listbox</code> objects, the <code class="literal">Radiobutton</code> is also driven by a bond to an external variable, which I called <code class="literal">_save_method</code>. Each <code class="literal">Radiobutton</code> instance sets a value argument, and by checking the value on <code class="literal">_save_method</code>, we know which button is selected.</p><div><pre class="programlisting">    _scrape_btn = ttk.Button(
        _mainframe, text='Scrape!', command=save)
    _scrape_btn.grid(row=2, column=0, sticky=E, pady=5)</pre></div><p>On the third row of <code class="literal">_mainframe</code> we place the <strong>Scrape</strong> button. Its <code class="literal">command</code> is <code class="literal">save</code>, which saves the images to be listed in <code class="literal">Listbox</code>, after we have successfully parsed a web page.</p><div><pre class="programlisting">    _status_frame = ttk.Frame(
        _root, relief='sunken', padding='2 2 2 2')
    _status_frame.grid(row=1, column=0, sticky=(E, W, S))
    _status_msg = StringVar()
    _status_msg.set('Type a URL to start scraping...')
    _status = ttk.Label(
        _status_frame, textvariable=_status_msg, anchor=W)
    _status.grid(row=0, column=0, sticky=(E, W))</pre></div><p>We end the layout section by placing down the status frame, which is a simple <code class="literal">ttk.Frame</code>. To give it a little status bar effect, we set its <code class="literal">relief</code> property to <code class="literal">'sunken'</code> and give it a uniform padding of 2 pixels. It needs to stick to the <code class="literal">_root</code> window left, right and bottom parts, so we set its <code class="literal">sticky</code> attribute to <code class="literal">(E, W, S)</code>.</p><p>We then place a label in it and, this time, we tie it to a <code class="literal">StringVar</code> object, because we will have to modify it every time we want to update the status bar text. You should be acquainted to this technique by now.</p><p>Finally, on the last line, we run the application by calling the <code class="literal">mainloop</code> method on the <code class="literal">Tk</code> instance.</p><div><pre class="programlisting">
<strong>    _root.mainloop()</strong>
</pre></div><p>Please remember that all these instructions are placed under the <code class="literal">if __name__ == "__main__":</code> clause in the original script.</p><p>As you <a id="id585" class="indexterm"/>can see, the code to design our GUI application is not hard. Granted, at the beginning you have to play around a little bit. Not everything will work out perfectly at the first attempt, but I promise you it's very easy and you can find plenty of tutorials on the web. Let's now get to the interesting bit, the business logic.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec102"/>The business logic</h2></div></div></div><p>We'll <a id="id586" class="indexterm"/>analyze the business logic of the GUI application<a id="id587" class="indexterm"/> in three chunks. There is the fetching logic, the saving logic, and the alerting logic.</p><div><div><div><div><h3 class="title"><a id="ch08lvl3sec25"/>Fetching the web page</h3></div></div></div><div><pre class="programlisting">config = {}

def fetch_url():
    url = _url.get()
    config['images'] = []
    _images.set(())   # initialized as an empty tuple
    try:
        page = requests.get(url)
    except requests.RequestException as rex:
        _sb(str(rex))
    else:
        soup = BeautifulSoup(page.content, 'html.parser')
        images = fetch_images(soup, url)
        if images:
            _images.set(tuple(img['name'] for img in images))
            _sb('Images found: {}'.format(len(images)))
        else:
            _sb('No images found')
        config['images'] = images

def fetch_images(soup, base_url):
    images = []
    for img in soup.findAll('img'):
        src = img.get('src')
        img_url = (
            '{base_url}/{src}'.format(base_url=base_url, src=src))
        name = img_url.split('/')[-1]
        images.append(dict(name=name, url=img_url))
    return images</pre></div><p>First of all, let me explain that <code class="literal">config</code> dictionary. We need some way of passing data between the GUI application and the business logic. Now, instead of polluting the global namespace with many different variables, my personal preference is to have a single dictionary <a id="id588" class="indexterm"/>that holds all the objects we need to pass back and forth, so that the global namespace isn't be clogged up with all those names, and we have one single, clean, easy way of knowing where all the objects that are needed by our application are.</p><p>In this simple example, we'll just populate the <code class="literal">config</code> dictionary with the images we fetch from the page, but I wanted to show you the technique so that you have at least an example. This technique comes from my experience with JavaScript. When you code a web page, you very often import several different libraries. If each of these cluttered the global namespace with all sorts of variables, there would be severe issues in making everything work, because of name clashes and variable overriding. They make the coder's life a living hell.</p><p>So, it's much better to try and leave the global namespace as clean as we can. In this case, I find that using one <code class="literal">config</code> variable is more than acceptable.</p><p>The <code class="literal">fetch_url</code> function is quite similar to what we did in the script. Firstly, we get the <code class="literal">url</code> value by calling <code class="literal">_url.get()</code>. Remember that the <code class="literal">_url</code> object is a <code class="literal">StringVar</code> instance that is tied to the <code class="literal">_url_entry</code> object, which is an <code class="literal">Entry</code>. The text field you see on the GUI is the <code class="literal">Entry</code>, but the text behind the scenes is the value of the <code class="literal">StringVar</code> object.</p><p>By calling <code class="literal">get()</code> on <code class="literal">_url</code>, we get the value of the text which is displayed in <code class="literal">_url_entry</code>.</p><p>The next step is to prepare <code class="literal">config['images']</code> to be an empty list, and to empty the <code class="literal">_images</code> variable, which is tied to <code class="literal">_img_listbox</code>. This, of course, has the effect of cleaning up all the items in <code class="literal">_img_listbox</code>.</p><p>After this preparation step, we can try to fetch the page, using the same <code class="literal">try/except</code> logic we adopted in the script at the beginning of the chapter.</p><p>The one difference is in the action we take if things go wrong. We call <code class="literal">_sb(str(rex))</code>. <code class="literal">_sb</code> is a helper function whose code we'll see shortly. Basically, it sets the text in the status bar for us. Not a good name, right? I had to explain its behavior to you: food for thought.</p><p>If we can fetch the page, then we create the <code class="literal">soup</code> instance, and fetch the images from it. The logic of <code class="literal">fetch_images</code> is exactly the same as the one explained before, so I won't repeat myself here.</p><p>If we have images, using a quick tuple comprehension (which is actually a generator expression fed to a tuple constructor) we feed the <code class="literal">_images</code> <code class="literal">StringVar</code> and this has the effect of populating our <code class="literal">_img_listbox</code> with all the image names. Finally, we update the status bar.</p><p>If there <a id="id589" class="indexterm"/>were no images, we still update the status bar, and at the end of the function, regardless of how many images were found, we update <code class="literal">config['images']</code> to hold the <code class="literal">images</code> list. In this way, we'll be able to access the images from other functions by inspecting <code class="literal">config['images']</code> without having to pass that list around.</p></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec26"/>Saving the images</h3></div></div></div><p>The<a id="id590" class="indexterm"/> logic to save the images is pretty straightforward. Here it is:</p><div><pre class="programlisting">def save():
    if not config.get('images'):
        _alert('No images to save')
        return

    if _save_method.get() == 'img':
        dirname = filedialog.askdirectory(mustexist=True)
        _save_images(dirname)
    else:
        filename = filedialog.asksaveasfilename(
            initialfile='images.json',
            filetypes=[('JSON', '.json')])
        _save_json(filename)

def _save_images(dirname):
    if dirname and config.get('images'):
        for img in config['images']:
            img_data = requests.get(img['url']).content
            filename = os.path.join(dirname, img['name'])
            with open(filename, 'wb') as f:
                f.write(img_data)
        _alert('Done')

def _save_json(filename):
    if filename and config.get('images'):
        data = {}
        for img in config['images']:
            img_data = requests.get(img['url']).content
            b64_img_data = base64.b64encode(img_data)
            str_img_data = b64_img_data.decode('utf-8')
            data[img['name']] = str_img_data

        with open(filename, 'w') as ijson:
            ijson.write(json.dumps(data))
        _alert('Done')</pre></div><p>When<a id="id591" class="indexterm"/> the user clicks the <strong>Scrape</strong> button, the <code class="literal">save</code> function is called using the callback mechanism.</p><p>The first thing that this function does is check whether there are actually any images to be saved. If not, it alerts the user about it, using another helper function, <code class="literal">_alert</code>, whose code we'll see shortly. No further action is performed if there are no images.</p><p>On the other hand, if the <code class="literal">config['images']</code> list is not empty, <code class="literal">save</code> acts as a dispatcher, and it calls <code class="literal">_save_images</code> or <code class="literal">_save_json</code>, according to which value is held by <code class="literal">_same_method</code>. Remember, this variable is tied to the radio buttons, therefore we expect its value to be either <code class="literal">'img'</code> or <code class="literal">'json'</code>.</p><p>This dispatcher is a bit different from the one in the script. According to which method we have selected, a different action must be taken.</p><p>If we want to save the images as images, we need to ask the user to choose a directory. We do this by calling <code class="literal">filedialog.askdirectory</code> and assigning the result of the call to the variable <code class="literal">dirname</code>. This opens up a nice dialog window that asks us to choose a directory. The directory we choose must exist, as specified by the way we call the method. This is done so that we don't have to write code to deal with a potentially missing directory when saving the files.</p><p>Here's how this dialog should look on Ubuntu:</p><div><img src="img/4715_08_04.jpg" alt="Saving the images"/></div><p>If we<a id="id592" class="indexterm"/> cancel the operation, <code class="literal">dirname</code> will be set to <code class="literal">None</code>.</p><p>Before finishing analyzing the logic in <code class="literal">save</code>, let's quickly go through <code class="literal">_save_images</code>.</p><p>It's very similar to the version we had in the script so just note that, at the beginning, in order to be sure that we actually have something to do, we check on both <code class="literal">dirname</code> and the presence of at least one image in <code class="literal">config['images']</code>.</p><p>If that's the case, it means we have at least one image to save and the path for it, so we can proceed. The logic to save the images has already been explained. The one thing we do differently this time is to join the directory (which means the complete path) to the image name, by means of <code class="literal">os.path.join</code>. In the <code class="literal">os.path</code> module there's plenty of useful methods to work with paths and filenames.</p><p>At the end of <code class="literal">_save_images</code>, if we saved at least one image, we alert the user that we're done.</p><p>Let's go back now to the other branch in <code class="literal">save</code>. This branch is executed when the user selects the <strong>As JSON</strong> radio button before pressing the <strong>Scrape</strong> button. In this case, we want to <a id="id593" class="indexterm"/>save a file; therefore, we cannot just ask for a directory. We want to give the user the ability to choose a filename as well. Hence, we fire up a different dialog: <code class="literal">filedialog.asksaveasfilename</code>.</p><p>We pass an initial filename, which is proposed to the user with the ability to change it if they don't like it. Moreover, because we're saving a JSON file, we're forcing the user to use the correct extension by passing the <code class="literal">filetypes</code> argument. It is a list with any number of 2-tuples <em>(description, extension)</em> that runs the logic of the dialog.</p><p>Here's how this dialog should look on Ubuntu:</p><div><img src="img/4715_08_05.jpg" alt="Saving the images"/></div><p>Once we have chosen a place and a filename, we can proceed with the saving logic, which is the same as it was in the previous script. We create a JSON object from a Python <a id="id594" class="indexterm"/>dictionary (<code class="literal">data</code>) that we populate with key/value pairs made by the <code class="literal">images</code> name and Base64 encoded content.</p><p>In <code class="literal">_save_json</code> as well, we have a little check at the beginning that makes sure that we don't proceed unless we have a file name and at least one image to save.</p><p>This ensures that if the user presses the <strong>Cancel</strong> button, nothing bad happens.</p></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec27"/>Alerting the user</h3></div></div></div><p>Finally, let's<a id="id595" class="indexterm"/> see the alerting logic. It's extremely simple.</p><div><pre class="programlisting">def _sb(msg):
    _status_msg.set(msg)

def _alert(msg):
    messagebox.showinfo(message=msg)</pre></div><p>That's it! To change the status bar message all we need to do is to access <code class="literal">_status_msg</code> <code class="literal">StringVar</code>, as it's tied to the <code class="literal">_status</code> label.</p><p>On the other hand, if we want to show the user a more visible message, we can fire up a message box. Here's how it should look on Ubuntu:</p><div><img src="img/4715_08_06.jpg" alt="Alerting the user"/></div><p>The <code class="literal">messagebox</code> object can also be used to warn the user (<code class="literal">messagebox.showwarning</code>) or to <a id="id596" class="indexterm"/>signal an error (<code class="literal">messagebox.showerror</code>). But it can also be used to provide dialogs that ask us if we're sure that we want to proceed or if we really want to delete that file, and so on.</p><p>If you inspect <code class="literal">messagebox</code> by simply printing out what <code class="literal">dir(messagebox)</code> returns, you'll find methods like <code class="literal">askokcancel</code>, <code class="literal">askquestion</code>, <code class="literal">askretrycancel</code>, <code class="literal">askyesno</code>, and <code class="literal">askyesnocancel</code>, as well as a set of constants to verify the response of the user, such as <code class="literal">CANCEL</code>, <code class="literal">NO</code>, <code class="literal">OK</code>, <code class="literal">OKCANCEL</code>, <code class="literal">YES</code>, <code class="literal">YESNOCANCEL</code>, and so on. You can compare these to the user's choice so that you know what the next action to execute when the dialog closes.</p></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec103"/>How to improve the application?</h2></div></div></div><p>Now<a id="id597" class="indexterm"/> that you're accustomed to the fundamentals of designing a GUI application, I'd like to give you some suggestions on how to make ours better.</p><p>We can start from the code quality. Do you think this code is good enough, or would you improve it? If so, how? I would test it, and make sure it's robust and caters for all the various scenarios that a user might create by clicking around on the application. I would also make sure the behavior is what I would expect when the website we're scraping is down for any reason.</p><p>Another thing that we could improve is the naming. I have prudently named all the components with a leading underscore, both to highlight their somewhat "private" nature, and to avoid having name clashes with the underlying objects they are linked to. But in retrospect, many of those components could use a better name, so it's really up to you to refactor until you find the form that suits you best. You could start by giving a better name to the <code class="literal">_sb</code> function!</p><p>For what concerns the user interface, you could try and resize the main application. See what happens? The whole content stays exactly where it is. Empty space is added if you expand, or the whole widgets set disappears gradually if you shrink. This behavior isn't exactly nice, therefore one quick solution could be to make the root window fixed (that is, unable to resize).</p><p>Another thing that you could do to improve the application is to add the same functionality we had in the script, to save only PNGs or JPGs. In order to do this, you could place a combo box somewhere, with three values: All, PNGs, JPGs, or something similar. The user should be able to select one of those options before saving the files.</p><p>Even better, you could change the declaration of <code class="literal">Listbox</code> so that it's possible to select multiple images at the same time, and only the selected ones will be saved. If you manage to do this (it's not as hard as it seems, believe me), then you should consider presenting the <code class="literal">Listbox</code> a bit better, maybe providing alternating background colors for the rows.</p><p>Another<a id="id598" class="indexterm"/> nice thing you could add is a button that opens up a dialog to select a file. The file must be one of the JSON files the application can produce. Once selected, you could run some logic to reconstruct the images from their Base64-encoded version. The logic to do this is very simple, so here's an example:</p><div><pre class="programlisting">with open('images.json', 'r') as f:
    data = json.loads(f.read())

for (name, b64val) in data.items():
    with open(name, 'wb') as f:
        f.write(base64.b64decode(b64val))</pre></div><p>As you can see, we need to open <code class="literal">images.json</code> in read mode, and grab the <code class="literal">data</code> dictionary. Once we have it, we can loop through its items, and save each image with the Base64 decoded content. I'll leave it up to you to tie this logic to a button in the application.</p><p>Another cool feature that you could add is the ability to open up a preview pane that shows any image you select from the <code class="literal">Listbox</code>, so that the user can take a peek at the images before deciding to save them.</p><p>Finally, one last suggestion for this application is to add a menu. Maybe even a simple menu with <strong>File</strong> and <strong>?</strong> to provide the usual <strong>Help</strong> or <strong>About</strong>. Just for fun. Adding menus is not that complicated; you can add text, keyboard shortcuts, images, and so on.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec70"/>Where do we go from here?</h1></div></div></div><p>If you are interested in digging deeper into the world of GUIs, then I'd like to offer you the following suggestions.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec104"/>The tkinter.tix module</h2></div></div></div><p>Exploring <code class="literal">tkinter</code> and its themed widget set, <code class="literal">tkinter.ttk</code>, will take you some time. There's<a id="id599" class="indexterm"/> much to learn and play with. Another interesting module to explore, when you'll be familiar with this technology, is <code class="literal">tkinter.tix</code>.</p><p>The <code class="literal">tkinter.tix</code> (<strong>Tk Interface Extension</strong>) module provides an additional very rich set of widgets. The <a id="id600" class="indexterm"/>need for them stems from the fact that the widgets in the standard <code class="literal">Tk</code> library are far from complete.</p><p>The <code class="literal">tkinter.tix</code> library allows us to solve this problem by providing widgets like HList, ComboBox, Control (or SpinBox), and various scrollable widgets. Altogether, there are more than 40 widgets. They allow you to introduce different interaction techniques and paradigms into your applications, thus improving their quality and usability.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec105"/>The turtle module</h2></div></div></div><p>The <code class="literal">turtle</code> module is an extended reimplementation of the eponymous module from the Python<a id="id601" class="indexterm"/> standard distribution up to version Python 2.5. It's a very popular way to introduce children to programming.</p><p>It's based on the idea of an imaginary turtle starting at (0, 0) in the Cartesian plane. You can programmatically command the turtle to move forward and backwards, rotate, and so on. and by combining together all the possible moves, all sorts of intricate shapes and images can be drawn.</p><p>It's definitely worth checking out, if only to see something different.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec106"/>wxPython, PyQt, and PyGTK</h2></div></div></div><p>After <a id="id602" class="indexterm"/>you have explored the vastness of the <code class="literal">tkinter</code> realm, I'd suggest you <a id="id603" class="indexterm"/>to <a id="id604" class="indexterm"/>explore other GUI libraries: <strong>wxPython</strong>, <strong>PyQt</strong>, and <strong>PyGTK</strong>. You may find out one of these works better for you, or it makes easier for you to code the application you need.</p><p>I believe that coders can realize their ideas only when they are conscious about what tools they have available. If your toolset is too narrow, your ideas may seem impossible or extremely hard to realize, and they risk remaining exactly what they are, just ideas.</p><p>Of course, the technological spectrum today is humongous, so knowing everything is not possible; therefore, when you are about to learn a new technology or a new subject, my suggestion is to grow your knowledge by exploring breadth first.</p><p>Investigate <a id="id605" class="indexterm"/>several things not too deeply, and then go deep with the <a id="id606" class="indexterm"/>one or the few that looked most promising. This way you'll be able to be<a id="id607" class="indexterm"/> productive with at least one tool, and when the tool no longer fits your needs, you'll know where to dig deeper, thanks to your previous exploration.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec107"/>The principle of least astonishment</h2></div></div></div><p>When <a id="id608" class="indexterm"/>designing an interface, there are many different things to bear in mind. One of them, which for me is the most important, is the law or <strong>principle of least astonishment</strong>. It basically states that if in your design a necessary feature has a high astonishing factor, it may be necessary to redesign your application. To give you one example, when you're used to working with Windows, where the buttons to minimize, maximize and close a window are on the top-right corner, it's quite hard to work on Linux, where they are at the top-left corner. You'll find yourself constantly going to the top-right corner only to discover once more that the buttons are on the other side.</p><p>If a certain button has become so important in applications that it's now placed in a precise location by designers, please don't innovate. Just follow the convention. Users will only become frustrated when they have to waste time looking for a button that is not where it's supposed to be.</p><p>The disregard for this rule is the reason why I cannot work with products like Jira. It takes me minutes to do simple things that should require seconds.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec108"/>Threading considerations</h2></div></div></div><p>This<a id="id609" class="indexterm"/> topic is beyond the scope of an introductory book like this, but I do <a id="id610" class="indexterm"/>want to mention it. In a nutshell, a <strong>thread</strong> of execution is the smallest sequence of programmed instructions that can be managed independently by a <strong>scheduler</strong>. The <a id="id611" class="indexterm"/>reason we have the perception that modern computers can do many things at the same time is not only due to the fact that they have multiple processors. They also subdivide the work in different threads, which are then worked on in sequence. If their lifecycle is sufficiently short, threads can be worked on in one single go, but typically, what happens is that the OS works on a thread for a little time, then switches to another one, then to another one, then back to the first one, and so on. The order in which they are worked on depends on different factors. The end result is that, because computers are extremely fast in doing this switching, we perceive many things happening at the same time.</p><p>If you are coding a GUI application that needs to perform a long running operation when a button is clicked, you will see that your application will probably freeze until the operation <a id="id612" class="indexterm"/>has been carried out. In order to avoid this, and maintain the application's responsiveness, you may need to run that time-expensive operation in a different thread so that the OS will be able to dedicate a little bit of time to the GUI every now and then, to keep it responsive.</p><p>Threads are an advanced topic, especially in Python. Gain a good grasp of the fundamentals first, and then have fun exploring them!</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec71"/>Summary</h1></div></div></div><p>In this chapter, we worked on a project together. We have written a script that scrapes a very simple web page and accepts optional commands that alter its behavior in doing so. We also coded a GUI application to do the same thing by clicking buttons instead of typing on a console. I hope you enjoyed reading it and following along as much as I enjoyed writing it.</p><p>We saw many different concepts like context managers, working with files, performing HTTP requests, and we've talked about guidelines for usability and design.</p><p>I have only been able to scratch the surface, but hopefully, you have a good starting point from which to expand your exploration.</p><p>Throughout the chapter, I have pointed you in several different ways on how to improve the application, and I have challenged you with a few exercises and questions. I hope you have taken the time to play with those ideas. One can learn a lot just by playing around with fun applications like the one we've coded together.</p><p>In the next chapter, we're going to talk about data science, or at least about the tools that a Python programmer has when it comes to facing this subject.</p></div></body></html>