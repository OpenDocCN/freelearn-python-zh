<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;Talking to Bots"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Talking to Bots</h1></div></div></div><p>Wow, bots?! Really? Will I learn to build bots for fun or my business use case? Yes, of course this chapter takes you to the brand new world of bots with Python.
</p><p>In this chapter, we will cover the following recipes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Building a moody Telegram bot</li><li class="listitem" style="list-style-type: disc">Different types of bots: stateless, stateful, and smart</li><li class="listitem" style="list-style-type: disc">A smart bot with artificial intelligence</li><li class="listitem" style="list-style-type: disc">Automating business processes with bots</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec67"/>Introduction</h1></div></div></div><p>The last couple of decades have been an age of digital transformation and automation. Most businesses today prefer an online sales model rather than the traditional brick-and-mortar way of selling products.</p><p>Websites have not only helped companies increase their reach, but have also made it cheaper (no fixed costs such as rentals) for them to sell their products. A responsive <span class="strong"><strong>graphical user interface</strong></span> (<span class="strong"><strong>GUI</strong></span>), combined with the power of real-time technologies, has made the process of selling easier; now executives can just chat with potential customers and guide them to buy products, increasing conversions.</p><p>With advancements in <span class="strong"><strong>artificial intelligence</strong></span> (<span class="strong"><strong>AI</strong></span>) and language processing techniques, businesses are slowly but steadily adopting conversational interfaces to automate their processes. A conversational user interface refers to an interface that has free-form text for natural languages. With conversational interfaces and natural language processing techniques, businesses feel that a machine can respond to certain customer queries by analyzing the context. These machines, in today's world, are referred to as <span class="strong"><strong>chatbots</strong></span>.</p><p>In this chapter, you will learn about the different types of bots, look at how to develop simple chatbots, and learn about how bots can be used to automate business processes. Also, note that when we refer to bots in this chapter, we're talking about chatbots or text-based bots.</p><div class="section" title="What are bots?"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec190"/>What are bots?</h2></div></div></div><p>OK, let's take a simple example. Say you want to order a pizza from <span class="strong"><strong>Pizza Hut</strong></span> for an evening get-together with friends this coming weekend. Usually, you'd go to the Pizza Hut website, spend time looking for a certain type of pizza or that particular topping you like, and place an order. More often than not, you already know what you want to order; then the question really is, why take the pain to look for it on the Pizza Hut website?</p><p>Worry no more! Just log in to <span class="strong"><strong>Facebook</strong></span> and use the Facebook Messenger chatbot to buy what you need from Pizza Hut. Not just this, the chatbot will also keep you posted on the latest offers and updates from Pizza Hut. So a chatbot can give you the same experience of visiting a website from your favorite social networking platform. Look at <a class="ulink" href="http://blog.pizzahut.com/press-center/pizza-hut-announces-new-social-ordering-platform/">http://blog.pizzahut.com/press-center/pizza-hut-announces-new-social-ordering-platform/</a> for the announcement <a class="ulink" href="http://blog.pizzahut.com/press-center/pizza-hut-announces-new-social-ordering-platform/">Pizza Hut</a> made regarding collaborating with Facebook Messenger.</p><p>You may say, "Yes, we understand the use case, but what exactly is a chatbot?"</p><p>A chatbot is a service powered by rules and AI that you, as a customer, interact with via a chat (text) interface. Bots carry out semi-intelligent or mundane tasks and run them as software applications. Chatbots can provide you with multiple services and can run on social platforms such as <span class="strong"><strong>Facebook</strong></span>, <span class="strong"><strong>Telegram</strong></span>, <span class="strong"><strong>Slack</strong></span>, and many more. Chatbots are still in active research and are an emerging computer science field.</p></div><div class="section" title="How do bots work?"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec191"/>How do bots work?</h2></div></div></div><p>Based on what we have discussed so far, you might be thinking, "How these bots function? How do they understand human words or sentiments? How do they understand the context?" So here's the answer. There are typically two types of chatbots:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Bots that work on a rule engine</strong></span>: This type of bot understands certain words or commands (so to speak) and has very limited behavior. It is pretty straightforward: if <span class="emphasis"><em>x</em></span> is the input, then <span class="emphasis"><em>y</em></span> should be the output. They're very useful in cases where there are fixed sets of questions or when questions act as queries. For example, the CNN chatbot helps you get the top stories for that moment, and furthermore, you have the luxury of asking the bot about the top stories on certain topics, such as <span class="strong"><strong>politics</strong></span> or <span class="strong"><strong>business</strong></span>. (Great! Then why should I even go to the CNN website?) Look at some of the screenshots that I took from my Facebook Messenger app regarding my interaction with the CNN chatbot. The first screen asks you to click on <span class="strong"><strong>GET </strong></span><span class="strong"><strong>STARTED</strong></span>, and when you do this, the bot takes you to the next screen where it gives you an option to look at the top stories:<p>
</p><div class="mediaobject"><img alt="How do bots work?" src="graphics/image_09_0011.jpg"/></div><p>
</p><p>When you click on <span class="strong"><strong>TOP </strong></span>
<span class="strong"><strong>STORIES</strong></span>, it shows you the <span class="strong"><strong>Yahoo!</strong></span> story and asks you whether you're interested in certain topics, politics for example:</p><p>
</p><div class="mediaobject"><img alt="How do bots work?" src="graphics/image_09_0012.jpg"/></div><p>
</p></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>A smart bot that works on machine learning</strong></span>: Smart bots use AI and sentiment analysis to understand the context of a conversation and respond to language semantics. They are hence applicable to sophisticated use cases, such as purchasing products or answering customer support queries. What's more, these bots can learn from past interactions. Amazing, isn't it?</li></ul></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note23"/>Note</h3><p>Sentiment analysis is also referred to as opinion mining and aims at identifying and extracting subjective information from the available text and determining the emotion of the writer, taking care of the contextual properties of the text.</p></div></div></div><div class="section" title="Why bots now?"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec192"/>Why bots now?</h2></div></div></div><p>You may ask, "The world has been talking about machine learning for a while now and the chat feature has been around a long time now, so why are bots becoming so relevant now?" That's because of the following reasons:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Usage patterns</strong></span>: Companies have figured out that users tend to spend more time on chats than on social media platforms or websites. Hence, businesses can engage with users in better ways via a chat platform.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Cost-effective</strong></span>: No need for humans--sounds like no cost at all! Businesses are taking advantage of bots to automate processes, such as customer service, without human resource investments.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Scale</strong></span>: It's easy to reach out to millions of users through Facebook or Telegram, which act as distribution channels for bots. This way, businesses can target as many potential customers as possible without looking at the human costs involved.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Efficient technology</strong></span>: Growth in AI or <span class="strong"><strong>Natural Language Processing</strong></span> (<span class="strong"><strong>NLP</strong></span>) has made it even easier to plug algorithms into these bots. Algorithms can, or will, mature over time, and they will serve customers even better.</li></ul></div><p>OK, great! Now that we understand bots and their utility much better, let's get our hands dirty and develop our own bot.</p></div></div></div>
<div class="section" title="Building a moody Telegram bot"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec68"/>Building a moody Telegram bot</h1></div></div></div><p>Before we start developing a bot, we should be clear about our objectives: what is my bot going to do? We take a simple example of creating a bot that would respond with an emoji based on the user's mood. It's a moody bot for the simple reason that it represents the mood of the user. Sounds like an interesting use case? Let's go for it!</p><p>In this recipe, we shall use the <code class="literal">python-telegram-bot</code> (<a class="ulink" href="https://github.com/python-telegram-bot/">https://github.com/python-telegram-bot/</a>) library to develop a Telegram bot. So, let's get started by first installing the <code class="literal">python-telegram-bot</code> module with our favorite utility, namely python <code class="literal">pip</code>:</p><pre class="programlisting">
<span class="strong"><strong>(bots)chetans-MacBookPro:ch09 Chetan$ pip install python-telegram-bot --upgrade &#13;
 &#13;
Collecting python-telegram-bot &#13;
  Downloading python_telegram_bot-5.1.0-py2.py3-none-any.whl (134kB) &#13;
    100% |████████████████████████████████| 135kB 681kB/s  &#13;
Collecting certifi (from python-telegram-bot) &#13;
  Downloading certifi-2016.8.31-py2.py3-none-any.whl (379kB) &#13;
    100% |████████████████████████████████| 380kB 612kB/s  &#13;
Collecting future&gt;=0.15.2 (from python-telegram-bot) &#13;
  Downloading future-0.15.2.tar.gz (1.6MB) &#13;
    100% |████████████████████████████████| 1.6MB 251kB/s  &#13;
Collecting urllib3&gt;=1.10 (from python-telegram-bot) &#13;
  Downloading urllib3-1.17-py2.py3-none-any.whl (101kB) &#13;
    100% |████████████████████████████████| 102kB 1.2MB/s  &#13;
Building wheels for collected packages: future &#13;
  Running setup.py bdist_wheel for future &#13;
  Stored in directory: /Users/chetan/Library/Caches/pip/wheels/11/c5/d2/ad287de27d0f0d646f119dcffb921f4e63df128f28ab0a1bda &#13;
Successfully built future &#13;
Installing collected packages: certifi, future, urllib3, python-telegram-bot &#13;
Successfully installed certifi-2016.8.31 future-0.15.2 python-telegram-bot-5.1.0 urllib3-1.17</strong></span>
</pre><p>We also install the <code class="literal">emoji</code> (<a class="ulink" href="https://github.com/carpedm20/emoji">https://github.com/carpedm20/emoji</a>) library to work with emoji icons so that we can return appropriate expressions to the user based on their mood:</p><pre class="programlisting">
<span class="strong"><strong>(bots)chetans-MacBookPro:ch09 Chetan$ pip install emoji --upgrade &#13;
 &#13;
Collecting emoji &#13;
  Downloading emoji-0.3.9.tar.gz &#13;
Building wheels for collected packages: emoji &#13;
  Running setup.py bdist_wheel for emoji &#13;
  Stored in directory: /Users/chetan/Library/Caches/pip/wheels/94/fc/67/441fb0ca2ed262d6db44d9ac2dfc953e421f57730004dff44d &#13;
Successfully built emoji &#13;
Installing collected packages: emoji &#13;
Successfully installed emoji-0.3.9</strong></span>
</pre><p>Have you installed the modules already? Cool! Let's move ahead.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec193"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">To develop a bot of your own, first download the Telegram app on your mobile. Sign up for an account and verify your number. Assuming you have done this, congrats! You are one step closer to creating a Telegram bot.</li><li class="listitem">Now, the next thing you need to do to register your bot is to contact another bot called <span class="strong"><strong>BotFather</strong></span>. On your Telegram app, search for <span class="strong"><strong>BotFather</strong></span> and click on it to start a conversation with it (or him?). This is how it will look:<p>
</p><div class="mediaobject"><img alt="How to do it..." src="graphics/image_09_004-1.jpg"/></div><p>
</p></li><li class="listitem">Once you start the conversation with <span class="strong"><strong>BotFather</strong></span>, follow the steps and use commands such as <code class="literal">/newbot</code> or <code class="literal">/enable</code> to configure your bot. Follow the steps carefully and you'll create a new bot. The following screenshot will guide you through the process of creating a new bot:<p>
</p><div class="mediaobject"><img alt="How to do it..." src="graphics/image_09_005-1.jpg"/></div><p>
</p></li><li class="listitem">When you create a new bot, you'll get a token specific to your bot. Keep this handy and safe with you; do not share it with anybody. The following screenshot shows how <span class="strong"><strong>BotFather</strong></span> works and how the token looks:<p>
</p><div class="mediaobject"><img alt="How to do it..." src="graphics/image_09_006-1.jpg"/></div><p>
</p></li><li class="listitem">Nice! So you have created your own bot. But the bot is not functional and doesn't do anything spectacular yet. Let's make it do some cool stuff like we planned at the beginning of the recipe. Create a file called <code class="literal">bot.py</code> and copy the following code to it. Also, make sure you change the <span class="strong"><strong>token</strong></span> to your bot's token ID:<pre class="programlisting">        import logging &#13;
        from telegram import InlineKeyboardButton, &#13;
          InlineKeyboardMarkup &#13;
        from telegram.ext import Updater,  &#13;
          CommandHandler, CallbackQueryHandler &#13;
        import emoji &#13;
 &#13;
        logging.basicConfig(format='%(asctime)s  &#13;
          - %(name)s - %(levelname)s - %(message)s', &#13;
        level=logging.INFO) &#13;
 &#13;
 &#13;
        def start(bot, update): &#13;
            keyboard = [ &#13;
                [InlineKeyboardButton("Happy", callback_data='1'), &#13;
                InlineKeyboardButton("Whatever", callback_data='2')], &#13;
                [InlineKeyboardButton("Sad", callback_data='3')]] &#13;
 &#13;
            reply_markup = InlineKeyboardMarkup(keyboard) &#13;
 &#13;
            update.message.reply_text('Hey there!  &#13;
              How do you feel today?', reply_markup=reply_markup) &#13;
 &#13;
 &#13;
        def button(bot, update): &#13;
            query = update.callback_query &#13;
        if query.data == "1": &#13;
                em = emoji.emojize(':smile:', use_aliases=True) &#13;
                bot.editMessageText(text="Oh wow! %s " % em, &#13;
        chat_id=query.message.chat_id, &#13;
        message_id=query.message.message_id) &#13;
 &#13;
        if query.data == "2": &#13;
                em = emoji.emojize(':expressionless:', use_aliases=True) &#13;
                bot.editMessageText(text="Does it matter? %s " % em, &#13;
        chat_id=query.message.chat_id, &#13;
        message_id=query.message.message_id) &#13;
 &#13;
 &#13;
        if query.data == "3": &#13;
            em = emoji.emojize(':disappointed:', use_aliases=True) &#13;
            bot.editMessageText(text="Oh man! %s " % em, &#13;
        chat_id=query.message.chat_id, &#13;
        message_id=query.message.message_id) &#13;
 &#13;
        def help(bot, update): &#13;
            update.message.reply_text("Use /start to test this bot.") &#13;
 &#13;
 &#13;
        def error(bot, update, error): &#13;
            logging.warning('Update "%s" caused error "%s"' % (update,&#13;
            error)) &#13;
 &#13;
 &#13;
        # Create the Updater and pass it your bot's token. &#13;
        updater = Updater('Token') &#13;
 &#13;
        updater.dispatcher.add_handler( &#13;
          CommandHandler('start', start)) &#13;
        updater.dispatcher.add_handler( &#13;
          CallbackQueryHandler(button)) &#13;
        updater.dispatcher.add_handler( &#13;
          CommandHandler('help', help)) &#13;
        updater.dispatcher.add_error_handler(error) &#13;
 &#13;
        # Start the Bot &#13;
        updater.start_polling() &#13;
 &#13;
        # Run the bot until the user presses Ctrl-C  &#13;
          or the process receives SIGINT, &#13;
        # SIGTERM or SIGABRT &#13;
        updater.idle() &#13;
</pre></li><li class="listitem">OK, cool! We have now added the required functionality to our bot and we expect it to run well. But how do we test it? First, run the Python file with the following command:<pre class="programlisting">
<span class="strong"><strong>python bot.py</strong></span>
</pre></li><li class="listitem">We then search for our bot and start a conversation with it. In my case, the bot is called <span class="strong"><strong>Chetbot</strong></span>, and I started a conversation with it using the standard <code class="literal">/start</code> command:<p>
</p><div class="mediaobject"><img alt="How to do it..." src="graphics/image_09_007-2.jpg"/></div><p>
</p></li><li class="listitem">In the preceding screenshot, when I started the conversation with my bot, it asked me about my mood for the day and gave me three options. The three options were <span class="strong"><strong>Happy</strong></span>, <span class="strong"><strong>Whatever</strong></span>, and <span class="strong"><strong>Sad</strong></span>.</li><li class="listitem">That's neat! But what happens when I click on one of these options? Voila! It returns me my mood for the day with an emoticon. Awesome!<p>
</p><div class="mediaobject"><img alt="How to do it..." src="graphics/image_09_008-1.jpg"/></div><p>
</p></li><li class="listitem">Observe that if I have to start the conversation again, I would need to reenter the <code class="literal">/start</code> command to converse with the bot. In the following screenshot, the bot recognizes the start command and asks me my mood again. Neat, huh?<p>
</p><div class="mediaobject"><img alt="How to do it..." src="graphics/image_09_009-2.jpg"/></div><p>
</p></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec194"/>How it works...</h2></div></div></div><p>The <code class="literal">python-telegram-bot</code> module works on standard event-driven philosophy. A bot can be considered as a single-threaded event loop, which keeps polling for events. An event loop is also registered with command handlers, also referred to as dispatchers. As soon as an event gets triggered, a callback handles the event and returns the desired response to the user.</p><p>In the preceding code snippet, we registered two command handlers: <code class="literal">start()</code> and <code class="literal">help()</code>. The <code class="literal">start()</code> method gets called when a user starts the conversation with the bot (the <code class="literal">/start</code> command) or asks for help (the <code class="literal">/help</code> command).</p><p>We have also added a callback query handler with <code class="literal">button()</code> as the callback method; this gets invoked when the user responds to the bot's options.</p><p>So, initially, the bot is running, waiting for an input. When a user says <code class="literal">/start</code>, the request is dispatched to the <code class="literal">start()</code> method, which in turn asks the user <span class="strong"><strong>Hey there! How do you feel today?</strong></span> and presents an inline keyboard with three options: <span class="strong"><strong>Happy</strong></span>, <span class="strong"><strong>Whatever</strong></span>, or <span class="strong"><strong>Sad</strong></span>.</p><p>When the user selects either of the options, an event gets generated, which is handled by the callback method <code class="literal">button()</code>. The callback has preloaded data that acts according to the option that is chosen. Based on the choice made by the user, the bot sends back the right emotion to the user. Emoticons are retuned to the user with the help of the <code class="literal">emoji</code> library that has all the expressions implemented.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec195"/>There's more...</h2></div></div></div><p>Cool! Have you created your own bot already? Can you think of other simple examples where Telegram bots will be useful? There are many Python modules using which you can develop bots with Telegram, such as <code class="literal">telepot</code> (<a class="ulink" href="https://github.com/nickoala/telepot">https://github.com/nickoala/telepot</a>) or <code class="literal">twx.botapi</code> (<a class="ulink" href="https://github.com/datamachine/twx.botapi">https://github.com/datamachine/twx.botapi</a>); both are good. You can use either one of them to get your bot up and running. Why not try them and see what they have to offer?</p></div></div>
<div class="section" title="Different types of bots"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec69"/>Different types of bots</h1></div></div></div><p>Taking confidence from having built a bot ourselves, let's take a step forward and look at how bots can be classified.</p><p>The bot we developed in the last recipe can be tagged unintelligent. By unintelligent, I mean it questioned the user, and based on the option, responded with an emoji. But when the user says <code class="literal">/start</code> again, the bot asked the same question. Not helpful, is it?</p><p>How about a scenario where the bot would remember your previous choice and try to motivate you with some nice articles or places you can go to within the city? Just to change your mood? How about actually increasing the happiness quotient?</p><p>To put the preceding discussion in perspective, bots can be classified into three different categories based on the implementation:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Stateless </strong></span><span class="strong"><strong>bots</strong></span>: These can also be referred to as don't-remember-anything bots. They don't persist information; that is, for them, every interaction is a new session, and they treat every question in isolation. For example, a news bot can keep returning updates on the latest stories or return the top stories in the <span class="emphasis"><em>politics</em></span> category all the time; however, if it doesn't remember the state of the conversation, it will be deemed stateless and will not be considered useful. Most bots built today come under this category, because of which the value offered by them is very limited.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Stateful </strong></span><span class="strong"><strong>bots</strong></span>: We discussed the news bot in the preceding point. What if the news bot remembers the news category of the user's interest and accordingly recommends more stories from the past, which the user may find interesting to read? Yeah, now we're talking business. This way, we keep the user engaged with the bot for a longer period of time.<p>Such bots keep track of the user's identity and also persist information of the current and previous sessions. For example, these bots may store the news categories searched today and from the past, and can then recommend users news feeds that match the searched categories.</p><p>Such bots are useful, but they are not smart; they don't understand context and language semantics.</p></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Smart </strong></span><span class="strong"><strong>bots</strong></span>: Smart bots have many batteries plugged in. They use machine learning, understand language semantics, and can build predictive algorithms based on the data they have.<p>Let's take the famous example of diaper and beer. It is said that if you analyze the pattern of purchase, there is a high correlation between the purchase of beer and that of the diaper, which means a person who buys a diaper more or less definitely buys beer. Smart bots can persist data and come up with such patterns that will result in meaningful insights into conversations. Let's take another example of language semantics. Think about the phrase "<span class="emphasis"><em>filthy awesome</em></span>"; now filthy, means dirty and awesome is a very positive word. Smart bots will understand these phrases and can comprehend the users' context much better.</p></li></ul></div><p>Based on the preceding categorization, it's up to us to decide what kind of bot we need to develop for a particular use case. Smart bots are often needed in cases where interaction is far more humane and involved, as in the case of customer support, but imagine the productivity gains a business can harness by using smart bots.</p></div>
<div class="section" title="A smart bot with artificial intelligence"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec70"/>A smart bot with artificial intelligence</h1></div></div></div><p>With the knowledge of different types of bots in the previous section, let's try to write a bot that uses artificial intelligence and sentiment analysis in Python. But before that, let's understand both these fields in brief.</p><p>
<span class="strong"><strong>Artificial intelligence</strong></span> (<span class="strong"><strong>AI</strong></span>) is an area of computer science that emphasizes on the creation of machines that can react like humans. Essentially, artificial intelligence relates to machines that perceive its context and take an action relevant to the content in order to maximize the chances of success. For instance, a machine can take decisions based on certain rules and a certain context to maximize the results of the decision.</p><p>
<span class="strong"><strong>Sentiment analysis</strong></span>, on the other hand, is about identifying and categorizing a piece of text to determine whether the opinion or attitude of the person involved is positive, neutral, or negative to a product or event. It refers to the use of natural language processing algorithms to perform text analysis and extract subjective information, or the sentiment, of the content.</p><p>I think, by now, you must have already started thinking of how AI and sentiment analysis can be used in our bots for various needs. In this recipe, let's build a smart bot with these technologies.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note24"/>Note</h3><p>Smart bots can be built on multiple technologies, such as predictive intelligence, AI, NLP, and more; however, it's completely up to you to decide which technology you need to use to meet your objectives. Also, bots don't need to be on the Web or an app; they can be simple CLI-based bots. A web UI, CLI, or a mobile app can be used as a distributor for a bot, but it is not a necessity to build a bot.</p></div></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec196"/>Getting ready</h2></div></div></div><p>To include AI in our bot, we will use a well-known Python module called <code class="literal">aiml</code>. <span class="strong"><strong>AIML</strong></span> stands for <span class="strong"><strong>Artificial Intelligence Markup Language</strong></span>, but it's essentially an XML file. AIML is a form of XML that defines the rules for matching patterns and determining responses. So, let's get started by installing the <code class="literal">aiml</code> module:</p><pre class="programlisting">
<span class="strong"><strong>chetans-MacBookPro:ch09 Chetan$ source bots/bin/activate &#13;
(bots)chetans-MacBookPro:ch09 Chetan$  &#13;
(bots)chetans-MacBookPro:ch09 Chetan$ pip install aiml &#13;
 &#13;
Collecting aiml &#13;
Installing collected packages: aiml &#13;
Successfully installed aiml-0.8.6</strong></span>
</pre></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec197"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">As step 1, we start by creating the AIML file. Go to your favorite editor and create an AIML file, just like a normal XML file, with the following content:<pre class="programlisting">        &lt;aiml version="1.0.1" encoding="UTF-8"&gt; &#13;
        &lt;!-chat.aiml à &#13;
 &#13;
          &lt;category&gt; &#13;
            &lt;pattern&gt;HELLO&lt;/pattern&gt; &#13;
            &lt;template&gt; &#13;
                Hi, hello! &#13;
            &lt;/template&gt; &#13;
          &lt;/category&gt; &#13;
 &#13;
          &lt;category&gt; &#13;
            &lt;pattern&gt;WHO ARE *&lt;/pattern&gt; &#13;
            &lt;template&gt; &#13;
              &lt;random&gt; &#13;
                &lt;li&gt;I'm a bot!&lt;/li&gt; &#13;
                &lt;li&gt;Bad guy!&lt;/li&gt; &#13;
                &lt;li&gt;My name is superman!&lt;/li&gt; &#13;
              &lt;/random&gt; &#13;
            &lt;/template&gt; &#13;
          &lt;/category&gt; &#13;
 &#13;
          &lt;category&gt; &#13;
            &lt;pattern&gt;AWESOME *&lt;/pattern&gt; &#13;
            &lt;template&gt; &#13;
                You're nice too! J &#13;
            &lt;/template&gt; &#13;
          &lt;/category&gt; &#13;
 &#13;
        &lt;/aiml&gt; &#13;
</pre></li><li class="listitem">Next, we create a startup XML file that will load the AIML file; this will also load the artificial intelligence we added to the preceding AIML file. Let's call this file <code class="literal">init.xml</code>:<pre class="programlisting">        &lt;aiml version="1.0.1" encoding="UTF-8"&gt;&#13;
            &lt;!-- init.xml --&gt;&#13;
&#13;
            &lt;!-- Category is an atomic AIML unit --&gt;&#13;
            &lt;category&gt;&#13;
&#13;
                &lt;!-- Pattern to match in user input --&gt;&#13;
                &lt;!-- If user enters "LOAD AIML B" --&gt;&#13;
                &lt;pattern&gt;LOAD AIML B&lt;/pattern&gt;&#13;
&#13;
                &lt;!-- Template is the response to the pattern --&gt;&#13;
                &lt;!-- This learn an aiml file --&gt;&#13;
                &lt;template&gt;&#13;
                    &lt;learn&gt;chat.aiml&lt;/learn&gt;&#13;
                    &lt;!-- You can add more aiml files here --&gt;&#13;
                    &lt;!--&lt;learn&gt;more_aiml.aiml&lt;/learn&gt;--&gt;&#13;
                &lt;/template&gt;&#13;
&#13;
            &lt;/category&gt;&#13;
&#13;
        &lt;/aiml&gt; &#13;
</pre></li><li class="listitem">Now let's develop the Python code to run our chatbot. The following code does exactly what we need. We call this file <code class="literal">aibot.py</code>:<pre class="programlisting">        import aiml &#13;
 &#13;
        # Create the kernel and learn AIML files &#13;
        kernel = aiml.Kernel() &#13;
        kernel.learn("init.xml") &#13;
        kernel.respond("load aiml b") &#13;
 &#13;
        # Press CTRL-C to break this loop &#13;
        while True: &#13;
            print kernel.respond(raw_input("Enter your message &gt;&gt;")) &#13;
</pre></li><li class="listitem">If we run this bot with the <code class="literal">python aibot.py</code> command, it presents an input screen, waiting for a user's input. Look at the following screenshot to see how it works:<p>
</p><div class="mediaobject"><img alt="How to do it..." src="graphics/image_09_010-1.jpg"/></div><p>
</p></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec198"/>How it works...</h2></div></div></div><p>The preceding Python code mimics a typical bot built on AI. When we run the Python code, <code class="literal">amil.Kernel()</code> will load the AI kernel.</p><p>Once the kernel is loaded, <code class="literal">kernel.learn()</code> will call the start up <code class="literal">xml</code> file. The AIML rule engine is loaded when the <code class="literal">load aiml b</code> command is sent to the kernel.</p><p>Once the engine is loaded into the kernel, we are free to chat with the bot.</p><p>In the preceding screenshot, when we say <span class="strong"><strong>hello</strong></span>, the bot understands it (from the <code class="literal">chat.aiml</code> file) and responds to it with <span class="strong"><strong>Hi, hello!</strong></span>, which is configured in <code class="literal">chat.aiml</code>.</p><p>In the second case, the AI bot matches the pattern <code class="literal">WHO ARE *</code> when <span class="strong"><strong>who are you?</strong></span> is asked by the user; the pattern is again defined in <code class="literal">chat.aiml</code>.</p><p>If you observe, the <code class="literal">WHO ARE *</code> pattern is configured for multiple responses in the <code class="literal">chat.aiml</code> file, so the bot, at runtime, chooses a random response and returns <span class="strong"><strong>My name is superman!</strong></span>.</p></div></div>
<div class="section" title="Automating business processes with bots"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec71"/>Automating business processes with bots</h1></div></div></div><p>So far in this chapter, you have learned what bots are, how they are built, and a few simple use cases where bots can be used. Let's see how we can solve Jay's problem with the knowledge we have developed so far and maybe learn more about building bots.</p><p>Jay is a marketing manager at a famous book publishing company, <span class="emphasis"><em>MyBooks</em></span>. His task is to come up with book promotion e-mails. He feels that the promotional e-mails he sends are too generic and are not targeted to the readers effectively. For instance, an e-mail on the Python learning path may not encourage a Java developer to spend money. He thinks he can do a much better job if he understands the interests of the audience and makes his interaction more relevant; the reader would be much more inclined to buy the book this way. He also feels that a lot of readers (potential buyers) are on Facebook, but they are not currently being reached out to by the publishing house. Can we help Jay here?</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec199"/>Getting ready</h2></div></div></div><p>Yes, let's help Jay by developing a fantastic bot for him. If you look into Jay's problem, he needs to understand the audience (in this case, the readers who would be interested in buying a book) and suggest them books based on their interest. So, our bot should be smart enough to get the relevant information from the readers.</p><p>Also, since the readers are already on Facebook, we can create a MyBooks Facebook page and build a Facebook Messenger bot so that the readers can be contacted. Let's see how to do this.</p><p>Before we get into building the bot, let's install a few Python modules that will be needed for this exercise. We install the <code class="literal">flask</code> and <code class="literal">requests</code> module using the Python<code class="literal"> pip</code>:</p><pre class="programlisting">
<span class="strong"><strong>(bots)chetans-MacBookPro:ch09 Chetan$ pip install flask &#13;
 &#13;
Collecting flask &#13;
  Using cached Flask-0.11.1-py2.py3-none-any.whl &#13;
Collecting click&gt;=2.0 (from flask) &#13;
Collecting itsdangerous&gt;=0.21 (from flask) &#13;
Collecting Werkzeug&gt;=0.7 (from flask) &#13;
  Downloading Werkzeug-0.11.11-py2.py3-none-any.whl (306kB) &#13;
    100% |████████████████████████████████| 307kB 1.4MB/s  &#13;
Collecting Jinja2&gt;=2.4 (from flask) &#13;
  Using cached Jinja2-2.8-py2.py3-none-any.whl &#13;
Collecting MarkupSafe (from Jinja2&gt;=2.4-&gt;flask) &#13;
Installing collected packages: click, itsdangerous, Werkzeug, MarkupSafe, Jinja2, flask &#13;
Successfully installed Jinja2-2.8 MarkupSafe-0.23 Werkzeug-0.11.11 click-6.6 flask-0.11.1 itsdangerous-0.24 &#13;
 &#13;
(bots)chetans-MacBookPro:ch09 Chetan$ pip install requests &#13;
 &#13;
Collecting requests &#13;
  Using cached requests-2.11.1-py2.py3-none-any.whl &#13;
Installing collected packages: requests &#13;
Successfully installed requests-2.11.1</strong></span>
</pre></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec200"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">To develop a Facebook Messenger bot, first create a Facebook account (who doesn't have a Facebook account?). Log in to your account and go to <a class="ulink" href="https://www.facebook.com/pages/create/">https://www.facebook.com/pages/create/</a> to create a new page.</li><li class="listitem">In our case, since we're building a page for MyBook's company, we can call our page <span class="strong"><strong>MyBooks</strong></span> and choose an appropriate organization type, which is <span class="strong"><strong>Media/news company</strong></span>. This is how the page will look:<p>
</p><div class="mediaobject"><img alt="How to do it..." src="graphics/B05370_08_new.jpg"/></div><p>
</p></li><li class="listitem">The second step in creating the Facebook page is to fill out the other details requested by Facebook, as shown in the following screenshot. We have given a nice description to our page: <code class="literal">Get updates on our latest books</code>:<p>
</p><div class="mediaobject"><img alt="How to do it..." src="graphics/image_09_012-1.jpg"/></div><p>
</p></li><li class="listitem">We have filled in all the details for Jay, and the MyBooks Facebook page is ready and looks smashing:<p>
</p><div class="mediaobject"><img alt="How to do it..." src="graphics/image_09_013-1.jpg"/></div><p>
</p><p>Now, that's a good start. Readers will start following this page, but we really need to add the ability for our readers to converse via a Facebook page; we do this with a Facebook Messenger bot. So let's go ahead and work on this aspect of our solution.</p></li><li class="listitem">To create a Facebook Messenger bot, we need a Facebook app. We will create an app by navigating to <a class="ulink" href="https://developers.facebook.com/quickstarts/?platform=web">https://developers.facebook.com/quickstarts/?platform=web</a> and clicking on <span class="strong"><strong>Skip and Create App ID</strong></span>, as shown in the following screenshot:<p>
</p><div class="mediaobject"><img alt="How to do it..." src="graphics/image_09_014-1.jpg"/></div><p>
</p></li><li class="listitem">We now fill out the required details and push the <span class="strong"><strong>Create App ID</strong></span> button to create the app. The following screenshot shows the details we added to create an app:<p>
</p><div class="mediaobject"><img alt="How to do it..." src="graphics/image_09_015-1.jpg"/></div><p>
</p></li><li class="listitem">As soon as we fill out the details and click on <span class="strong"><strong>Create App ID</strong></span>, a new app gets created for us. This Facebook app is for our bot. We see the app ID on the top-right section of our page, but to get associated with the bot, we scroll down and click on <span class="strong"><strong>Get </strong></span><span class="strong"><strong>Started</strong></span> in the <span class="strong"><strong>Messenger</strong></span> section:<p>
</p><div class="mediaobject"><img alt="How to do it..." src="graphics/image_09_016-1.jpg"/></div><p>
</p></li><li class="listitem">To let the bot access Messenger, we will generate <span class="strong"><strong>Page Access Token</strong></span>, like in the following screenshot.<div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="tip25"/>Tip</h3><p>Keep this token safe with you and don't share it with anyone.</p></div></div></li><li class="listitem">This token is used to respond to the readers who initiate a conversation with the bot from the <span class="strong"><strong>MyBooks</strong></span> Facebook page:<p>
</p><div class="mediaobject"><img alt="How to do it..." src="graphics/image_09_017-1.jpg"/></div><p>
</p></li><li class="listitem">OK, there's one last thing pending. We also need to receive messages from the readers; only then can we respond to them. For this, we go to the <span class="strong"><strong>Webhooks</strong></span> section and add a few settings:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Callback URL</strong></span>: This is a link to our server where we receive messages from our readers via the Facebook page</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Verification Token</strong></span>: Any set of characters can be used here, say <code class="literal">token</code></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Subscription Fields</strong></span>: We choose <span class="strong"><strong>messages</strong></span> as subscription fields for our bot (this can be changed later)</li></ul></div><p>As you see, we need to have a callback URL. This will be used by Facebook to verify whether our callback URL is set up fine. For this, we create a Flask server and configure the route to be used for <span class="strong"><strong>Callback URL</strong></span>. The following code creates a route called <code class="literal">/bot</code> that is used as <span class="strong"><strong>Callback URL</strong></span> for verification:</p><pre class="programlisting">        from flask import Flask &#13;
        from flask import request &#13;
        import sys, requests, json, os &#13;
 &#13;
        app = Flask(__name__) &#13;
 &#13;
        @app.route("/bot/", methods=['GET', 'POST']) &#13;
        def hello(): &#13;
        if request.method == 'GET': &#13;
        return request.args.get('hub.challenge') &#13;
</pre><p>If we run the server on port 5000 and also use <code class="literal">ngrok</code> to run on the same port, we get a callback URL that can be placed in the <span class="strong"><strong>Webhook</strong></span> settings. This is how callback URL looks:</p><p>
</p><div class="mediaobject"><img alt="How to do it..." src="graphics/image_09_018-1.jpg"/></div><p>
</p><p>The settings can be verified and saved by clicking on the button, as shown in the following screenshot:</p><p>
</p><div class="mediaobject"><img alt="How to do it..." src="graphics/image_09_019-1.jpg"/></div><p>
</p><p>When we verify and save the settings, a <code class="literal">GET</code> request is sent to our Flask server with the <code class="literal">hub.challenge</code> code. We return this code to Facebook from the <code class="literal">flask</code> route and verify the <span class="strong"><strong>Webhook</strong></span> setting:</p><pre class="programlisting">
<span class="strong"><strong>        /Users/chetan/book/ch09/bots/bin/python  &#13;
        /Users/chetan/book/ch09/bookbot.py &#13;
         * Running on http://127.0.0.1:5000/ &#13;
          (Press CTRL+C to quit) &#13;
 &#13;
        127.0.0.1 - - [01/Oct/2016 10:17:43] "GET  &#13;
        /bot/?hub.mode=subscribe&amp;hub &#13;
        .challenge=1742124657&amp;hub.verify_token= &#13;
        token HTTP/1.1" 200 -</strong></span>
</pre><p>For the bot to work fine we also need to make sure that the Facebook page allows certain events like reading or echoing messages. We enable these settings in the <span class="strong"><strong>Webhooks</strong></span> section:</p><p>
</p><div class="mediaobject"><img alt="How to do it..." src="graphics/image_09_020-1.jpg"/></div><p>
</p></li><li class="listitem">Cool! So now we're ready with a <span class="strong"><strong>Webhook</strong></span> to receive messages from readers and also have an access token to respond to users. If you realize, <span class="strong"><strong>Webhook</strong></span> is going to be our bot server! Let's just go ahead and make our bot do smarter things. The following code will make our bot do all the great things that Jay needs:<pre class="programlisting">        from flask import Flask &#13;
        from flask import request &#13;
        import requests, json&#13;
 &#13;
 &#13;
        app = Flask(__name__) &#13;
 &#13;
        def send_weburl(payload, recipient_id): &#13;
            headers = { &#13;
               "Content-Type": "application/json" &#13;
            } &#13;
            token = { &#13;
               "access_token": &#13;
               "TOKEN" &#13;
             } &#13;
 &#13;
        if payload == 'Python': &#13;
          data = json.dumps({ &#13;
            "recipient": { &#13;
              "id": recipient_id &#13;
            }, &#13;
            "message":{ &#13;
              "attachment":{ &#13;
                "type":"template", &#13;
                "payload":{ &#13;
                  "template_type":"generic", &#13;
                  "elements":[ &#13;
                  { &#13;
                    "title":"Learn Python Design Patterns: Chetan&#13;
                    Giridhar", &#13;
                    "item_url":"https://www.amazon.com/Learning-Python-&#13;
                    Design-Patterns-Second/dp/178588803X", &#13;
                    "image_url":"https://images-na.ssl-images-&#13;
                    amazon.com/images/I/51bNOsKpItL._SX404_BO1,&#13;
                    204,203,200_.jpg", &#13;
                    "subtitle":"Python Book for software architects and&#13;
                    developers", &#13;
                    "buttons":[ &#13;
                    { &#13;
                      "type":"web_url", &#13;
                      "url":"https://www.amazon.com/Learning-Python-&#13;
                      Design-Patterns-Second/dp/178588803X", &#13;
                      "title":"Buy", &#13;
                      "webview_height_ratio":"full" &#13;
                    } &#13;
                    ] &#13;
                  } &#13;
                  ] &#13;
              } &#13;
            } &#13;
            } &#13;
          }) &#13;
 &#13;
        if payload == 'Java': &#13;
          data = json.dumps({ &#13;
            "recipient": { &#13;
              "id": recipient_id &#13;
            }, &#13;
            "message":{ &#13;
              "attachment":{ &#13;
              "type":"template", &#13;
              "payload":{ &#13;
                "template_type":"generic", &#13;
                "elements":[ &#13;
                { &#13;
                  "title":"RESTful Java Patterns and Best &#13;
                  Practices: Bhakti Mehta", &#13;
                  "item_url":"https://www.amazon.com/RESTful-Java-&#13;
                  Patterns-Best-Practices/dp/1783287969", &#13;
                  "image_url":"https://images-na.ssl-images-&#13;
                  amazon.com/images/I/51YnSP6uqeL._SX403_BO1,&#13;
                  204,203,200_.jpg", &#13;
                  "subtitle":"Python Book for software architects and &#13;
                  developers", &#13;
                  "buttons":[ &#13;
                    { &#13;
                      "type":"web_url", &#13;
                      "url":"https://www.amazon.com/RESTful-Java-&#13;
                      Patterns-Best-Practices/dp/1783287969", &#13;
                      "title":"Buy", &#13;
                      "webview_height_ratio":"full" &#13;
                    } &#13;
                  ] &#13;
                } &#13;
                ] &#13;
              } &#13;
              } &#13;
            } &#13;
          }) &#13;
 &#13;
        r = requests.post("https://graph.facebook.com/v2.6/me/messages", &#13;
        params=token, headers=headers, data=data) &#13;
 &#13;
        def send_postback(recipient_id): &#13;
          headers = { &#13;
            "Content-Type": "application/json" &#13;
          } &#13;
          token = { &#13;
            "access_token": &#13;
              "TOKEN" &#13;
          } &#13;
 &#13;
        data = json.dumps({ &#13;
          "recipient": { &#13;
            "id": recipient_id &#13;
          }, &#13;
          "message": { &#13;
            "attachment": { &#13;
              "type": "template", &#13;
              "payload": { &#13;
                "template_type": "button", &#13;
                "text": "Hey there, Welcome to MyBooks.  &#13;
                What are you interested in?", &#13;
                "buttons": [ &#13;
                { &#13;
                  "type":"postback", &#13;
                  "title":"Java", &#13;
                  "payload":"Java" &#13;
                }, &#13;
                { &#13;
                  "type":"postback", &#13;
                  "title":"Python", &#13;
                  "payload":"Python" &#13;
                } &#13;
                ] &#13;
              } &#13;
            } &#13;
          } &#13;
        }) &#13;
 &#13;
        r = requests.post("https://graph.facebook.com/v2.6/me/messages", &#13;
        params=token, headers=headers, data=data) &#13;
 &#13;
 &#13;
        @app.route("/bot/", methods=['GET', 'POST']) &#13;
        def hello(): &#13;
          print request.data &#13;
        if request.method == 'GET': &#13;
          return request.args.get('hub.challenge') &#13;
 &#13;
        data = request.get_json() &#13;
        if data["object"] == "page": &#13;
          for entry in data["entry"]: &#13;
            for messaging_event in entry["messaging"]: &#13;
              if messaging_event.get("postback"): &#13;
                sender_id = messaging_event["sender"]["id"] &#13;
                payload = messaging_event["postback"]["payload"] &#13;
                send_weburl(payload, sender_id) &#13;
 &#13;
              if messaging_event.get("message"):  # readers send us a&#13;
              message &#13;
                sender_id = messaging_event["sender"]["id"] &#13;
                send_postback(sender_id) &#13;
  &#13;
                return "ok", 200 &#13;
 &#13;
               if __name__ == "__main__": &#13;
                 app.run() &#13;
</pre></li><li class="listitem">We run the preceding Flask server to activate our bot. Now, let's see how the bot works by navigating to the Facebook page. On the Facebook page, if we click on <span class="strong"><strong>Message</strong></span>, we can start chatting with the bot on the <span class="strong"><strong>MyBooks</strong></span> page:<p>
</p><div class="mediaobject"><img alt="How to do it..." src="graphics/image_09_021.jpg"/></div><p>
</p></li><li class="listitem">Let's start the conversation with the bot using a simple <code class="literal">Hi</code> message. The bot responds to us with a question about whether we'd like information on Python or Java books. Nice!<p>
</p><div class="mediaobject"><img alt="How to do it..." src="graphics/image_09_022-1.jpg"/></div><p>
</p></li><li class="listitem">Now, if we click on <span class="strong"><strong>Python</strong></span>, the bot recommends an architectural book written in Python and encourages the readers to buy it. This also happens when the reader clicks on <span class="strong"><strong>Java</strong></span>. See the following screenshot:<p>
</p><div class="mediaobject"><img alt="How to do it..." src="graphics/image_09_023.jpg"/></div><p>
</p><p>The following screenshot demonstrates a Java example where the <span class="emphasis"><em>RESTful Java Patterns and Best Practices</em></span> book is recommended when the user selects <span class="strong"><strong>Java</strong></span>:</p><p>
</p><div class="mediaobject"><img alt="How to do it..." src="graphics/image_09_024.jpg"/></div><p>
</p></li><li class="listitem">Cool, right? This is what Jay needed. So, when the readers arrive at the <span class="strong"><strong>MyBooks</strong></span> page, they get to talk to the bot and the bot recommends them a book based on their interest. Since the suggestion made by the bot is much more relevant to the reader, compared to a generic promotional e-mail, the chances of the reader buying a book are higher. Awesome!</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec201"/>How it works...</h2></div></div></div><p>We first created a Facebook page for Jay's publishing house: MyBooks. We then associated a Facebook Messenger bot with this page and got <span class="strong"><strong>Access Token</strong></span> to send the message back to the readers who chat with the bot. We also set up <span class="strong"><strong>Webhooks</strong></span> so that our bot would receive messages from the readers and use <span class="strong"><strong>Access Token</strong></span> to post messages back to them. Here, <span class="strong"><strong>Webhook</strong></span> is the brains behind the bot.</p><p>When the reader reaches the <span class="strong"><strong>MyBooks</strong></span> page, they click on <span class="strong"><strong>Messenger</strong></span> to start a conversation with the bot. When he or she says <code class="literal">Hi</code>, HTTP's <code class="literal">POST</code> request is sent to the <span class="strong"><strong>Webhook </strong></span>
<a class="ulink" href="https://2d7d823f.ngrok.io/bot/">
<code class="literal">https://2d7d823f.ngrok.io/bot/</code>
</a> with the message.</p><p>The bot reads the message from the reader and sends a <span class="emphasis"><em>generic template</em></span> message to the reader with <code class="literal">postback</code> options. The bot sends this message using Facebook's Graph APIs.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note26"/>Note</h3><p>Facebook has template messages for sending <code class="literal">postback</code> messages, buttons, images, URLs, and audio/video media files.</p></div></div><p>When the reader chooses <span class="strong"><strong>Python</strong></span>, the bot receives this message and, based on the payload, returns the image of the book along with the URL so users can buy it. Users can then click on <span class="strong"><strong>Buy</strong></span> to go to the book's URL and buy the book from there, exactly what Jay hoped for!</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec202"/>There's more...</h2></div></div></div><p>In this chapter, we build bots based on CLI, Web UI, and mobile apps. The bots can reside on other chat systems, such as Slack, which has a nice set of APIs. You may want to try writing one. If you do write one, send me the pointers; I would love to try them out.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note27"/>Note</h3><p>You can reach out to me on Twitter or send me a direct message and I will get back to you.</p></div></div></div></div></body></html>