<html><head></head><body>
        

                            
                    <h1 class="header-title">Introduction to the Basics of RESTful Architecture</h1>
                
            
            
                
<p class="mce-root">A web service is a software service or a software functionality provided by one set of computing devices to another set of computing devices. These devices communicate using established or standardized communication protocols through the <strong>World Wide Web</strong> (<strong>WWW</strong>).</p>
<p>This chapter intends to refresh your understanding of a few fundamental concepts of the web and its architecture, and the way it is evolving, hoping to lay a firm foundation for RESTful service designs and applications. The following topics are covered in this chapter:</p>
<ul>
<li>A brief history of the WWW and its evolution</li>
<li>WWW layers and architecture</li>
<li>Web API development models and REST-based service communication</li>
<li>A brief introduction to service-oriented architecture</li>
<li>Resource-oriented architecture principles and characteristics</li>
<li>Introduction to REST</li>
<li>REST constraints</li>
<li>RESTful qualifiers</li>
<li>REST architecture goals</li>
</ul>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Technical requirements</h1>
                
            
            
                
<p>As this book deals with intermediate to advanced topics of RESTful design patterns, we expect you to have a good understanding of web service concepts and their unique functions. As mentioned earlier, this chapter is an attempt to refresh your understanding of various fundamental concepts of the WWW, its evolution, and the types of web services it offers, so there are no formal technical requirements for this chapter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Evolution of web technologies</h1>
                
            
            
                
<p>Generally, the aim of this book is to provide more elaborate RESTful patterns; however, this section intends to give you a quick introduction to web services and their evolution since the early 1990s, giving you exciting facts about Web 1.0 through to Web 3.0, and then moving on to details about <strong>service-oriented architecture</strong> (<strong>SOA</strong>) and <strong>resource-oriented architecture</strong> (<strong>ROA</strong>).</p>
<p>As you are aware, today's web is a universe in itself, with a massive amount of interlinked web-based apps, images, videos, photos, and various interactive content. Which web technologies have made this possible, where did it start, how has it evolved over time, and how does it enable web app developers to develop amazing and interactive web experiences?</p>
<p>The following diagram provides a brief overview of the <strong>WWW</strong> and its evolution over time. Please note that each web version has its enabling technologies mentioned in the corresponding box:</p>
<p class="mce-root"/>
<div><img src="img/edc4e212-cfcd-48d2-9854-1ee91cb46f20.png" style="width:49.50em;height:33.75em;"/></div>
<p>Let's discuss <strong>Web 3.0</strong> more and focus on web services and their evolution as part of the third generation.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Learning about Web 3.0</h1>
                
            
            
                
<p>The following sections focus on Web 3.0 and the evolution and history of web services.</p>
<p>Web 3.0 is generally referred to as executing semantic web, or read-write-execute web. Web 3.0 decentralizes services such as search, social media, and chat applications that are dependent on a single organization to function. Semantic and web services are the primary constituents of Web 3.0.</p>
<p class="mce-root"/>
<p>The following diagram depicts layers of typical Web 3.0 constructs. The semantic web layers are <strong>Static Web</strong>, <strong>Translations</strong>, and <strong>Rich Internet Applications</strong> (<strong>RIA</strong>) or <strong>Rich Web</strong> built on top of the internet:</p>
<div><img src="img/b53c03ab-9a12-4416-bace-8c50a0940505.png" style="width:36.33em;height:21.75em;"/></div>
<p>The layered structure of Web 3.0</p>
<p>This data-driven web adjusts according to the user's searches, for instance, if a user searches for architecture patterns, the advertisements shown are more relevant to architecture and patterns; it even remembers your last search and combines the last searched queries as well. Interesting isn't it?</p>
<p>What you see in the following diagram is a Web 3.0 stack, with various building blocks as URI, Unicode representations, syntax (XML/JSON), RDFS taxonomies, and so on; they constitute a Web 3.0 stack:</p>
<p class="mce-root"/>
<div><img src="img/734504ea-6241-4d82-a09d-1b2ed8e47508.png" style="width:38.17em;height:30.83em;"/></div>
<p>Web 3.0 stack (Ref: <a href="https://www.w3.org/DesignIssues">https://www.w3.org/DesignIssues/w3.org </a>)</p>
<p>Let's move on to the web service architecture, the specifications, and the communication protocols, as they are the fundamentals before we move to ROA, SOA, and <strong>Representational State Transfer</strong> (<strong>REST</strong>) or RESTful services.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Learning about web service architecture</h1>
                
            
            
                
<p>Web services are a method of communication between two computing devices over a network, and the communication happens in standardized ways (and specifications) for the integration of heterogeneous web applications using XML/JSON, SOAP, WSDL, and UDDI. XML/JSON is the data format that provides metadata for the data that it contains; SOAP is used to transfer data; WSDL is used for defining available services to be consumed, and UDDI will have the list of services available.</p>
<p><strong>Web services architecture</strong> (<strong>WSA</strong>) mandates the presence of certain characteristics, and suggests a few optional ones, when developing any web service.</p>
<p>WSA consists of three significant roles, as you can see in the following diagram, and they are as follow:</p>
<ul>
<li><strong>Service Provider</strong></li>
<li><strong>Service Consumer</strong></li>
<li><strong>Service Broker</strong></li>
</ul>
<p>This is shown in the following diagram:</p>
<div><img src="img/4d66be7e-0052-4982-b678-3e19000d81ef.png" style="width:18.33em;height:15.08em;"/></div>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The <strong>Service Requestor</strong> finds the <strong>Service Provider</strong> through <strong>UDDI</strong>, and contacts the provider using the <strong>Simple Object Access Protocol</strong> (<strong>SOAP</strong>). The <strong>Service Provider</strong> then validates the service request and responds to the requestor with XML/JSON as a service response.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Discussing the web API</h1>
                
            
            
                
<p>So far, we have discussed the fundamentals of the client-server/web services paradigm, and the way they communicate with standard protocols; however, we are yet to touch upon REST-based communication and after all, that's what this book is about. This section will cover the introduction of web APIs, and how a web API is a development model for web services. The communication between the devices is REST-based. RESTful APIs do not use/require XML- based web service protocols, such as SOAP or WSDL, to support their interfaces, but they use simplified representations instead.</p>
<p>The following diagram depicts the web <strong>API</strong> and their simplified representations as the client side and the server side are exposed to each other through high-level interfaces:</p>
<div><img src="img/b4daea8e-1bdc-4025-bf83-6f5317999d5c.png" style="width:42.58em;height:14.92em;"/></div>
<p>So the web <strong>API,</strong> as shown in the preceding diagram, is available on both the client side and the server side. The client-side interfaces are generally exposed as JavaScript or browser plugins, and the server-side interfaces are generally exposed through the web as JSON/XML. Some of the key terminologies that we will come across concerning web APIs are endpoint, <strong>uniform resource identifier</strong> (<strong>URI</strong>), and resources.</p>
<p>The web API is an <strong>application programming interface</strong> (<strong>API</strong>) for <em>either</em> a web server or for a web browser. So, Web API is a concept or methodology for accessing any API (available over the web) through the HTTP protocol. There are many categories of APIs, SOAP, XML-RPC, JSON-RPC, REST, and so on. APIs can be developed with any programming language such as Java, .NET, and many more.</p>
<p>So now you have got an idea of what is a Web API is and where REST API development fits into the Web API landscape, let's move on and see more details of SOA, ROA, REST, RESTful APIs, and their key constituents in the following sections.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Learning about service-oriented architecture</h1>
                
            
            
                
<p>Service-oriented architecture is an architectural style of web services. It defines some standards and lays down best approaches to design and develop a web service. Any web service is the logical representation of repeatable business activities that have a specified outcome, such as retrieving a weather report for a particular city, accessing stock prices for a given stock, updating a record to an inventory service, and so on. SOA is self-contained, and also provides guidelines to combine a service with other services as well. Another fact about SOA is that it is a black box (or abstract) to the service consumer who consumes it.</p>
<p class="mce-root"/>
<p>In short, SOA is essentially a collection of services, those services communicate with each other, and a service is an operation or a function that is well defined, self-contained, and independent of other service contexts and states. Services are applications hosted on application servers and interact with other applications through interfaces.</p>
<p>SOA is not a technology or a programming language; it's a set of principles, procedures, and methodologies to develop a software application.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Learning about resource-oriented architecture</h1>
                
            
            
                
<p>Resource-oriented architecture is a foundation of the semantic web (please refer to the <em>Web 3.0</em> section of this chapter). The idea of ROA is to use basic, well-understood, and well-known web technologies (HTTP, URI, and XML) along with the core design principles.</p>
<p>As we all know, the primary focus of web services is to connect information systems, and ROA defines a structural design or set of guidelines to support and implement interactions within any connected resources. Any business entity can be represented as a resource, and it can be made accessible through a URI.</p>
<p>For example, in an organization's human resource system, each employee is an entity, and salary, employee details, and profiles are associations (descriptors) of that entity.</p>
<p>The following is a quick comparison table for object-oriented and resource-oriented concepts, and it gives a quick insight as to what ROA is:</p>
<p class="mce-root"/>
<table border="1" class="MsoTableGrid" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>Objects in object-oriented architecture</strong></p>
</td>
<td>
<p><strong>Resources in ROA</strong></p>
</td>
</tr>
<tr>
<td>
<p>Every entity is defined as an object</p>
</td>
<td>
<p>Entities are services</p>
</td>
</tr>
<tr>
<td>
<p>An object has attributes and actions</p>
</td>
<td>
<p>A service has descriptions and contracts</p>
</td>
</tr>
<tr>
<td>
<p>Objects need to maintain state to interact</p>
</td>
<td>
<p>Interacts over the network with a defined location or address</p>
</td>
</tr>
</tbody>
</table>


            

            
        
    

        

                            
                    <h1 class="header-title">Resource-oriented design</h1>
                
            
            
                
<p>The resource-oriented design section intends to walk you through the ROA design guidelines, design principles, and characteristics, along with its properties as well. Having introduced ROA properties, we will look at REST architecture in subsequent sections.</p>
<p class="mce-root"/>
<p>ROA-based web services describe a self-discoverable entity, and modeling is based on its logical form (unlike services, as they are based on the technical form).</p>
<p>Let's look at the basic blocks of ROA such as resources, representations, and so on in the following diagram:</p>
<div><img src="img/f716574d-a35a-4c2d-acad-b460d819b94f.png" style="width:30.42em;height:18.75em;"/></div>
<p>The blocks in the preceding diagram represent the typical structure of ROA and give an idea of how resources are consumed by the service consumers.</p>
<p>Let's briefly consider the concepts and properties of ROA, as follows:</p>
<ul>
<li><strong>Resource providers</strong>: Resource providers expose the resources for the service consumers to invoke the services with HTTP methods. Microsoft Azure and Amazon AWS are simple examples of resource providers.</li>
<li><strong>Resource</strong>: A resource is an explicit reference to an entity that can be identified and assigned and, most importantly, referenced as a resource. Some examples of resources could be servers, devices, web pages, JavaScript, or the latest version of software, the latest defect in software, a directory or list of information about an organization, and so on.</li>
<li><strong>Resource name</strong>: The resource name is the unique name or identification for the resource. So, no two resources can point to the same data. For instance, the latest version of software is 2.0.9.</li>
<li><strong>Resource representation</strong>: Resource representation is the useful information about the current state of a resource, specified with a specific format, in a specific language.</li>
<li><strong>Resource link and connectedness</strong>: Represents (linkage) another resource or the resource itself. Connectedness is all about how reliable and relevant the resource's links are.</li>
<li><strong>Resource interface</strong>: The resource interface is an interface for accessing the resource and handling its state.</li>
<li><strong>Addressability</strong>: Addressability is exposing datasets or functionalities as a resource, and the addressability of a resource happens through URIs.</li>
<li><strong>Statelessness</strong>: Statelessness is maintaining the isolation and independence of client and server states. Every request from the client should be self-contained.</li>
<li><strong>The uniform interface</strong>: Every service needs to use the HTTP interface the same way, such as <kbd>GET</kbd>, <kbd>POST</kbd>, <kbd>PUT</kbd>, <kbd>DELETE</kbd>, and so on. The uniform interface simply means using some common nomenclature that is interpreted the same way across the web. For example, <kbd>GET</kbd> does mean get (read) something.</li>
</ul>
<p>The following table summarizes the HTTP operations that can be used to implement an ROA-based web service:</p>
<table border="1" class="MsoTableGrid" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>HTTP operation</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>GET</kbd></p>
</td>
<td>
<p>Read the resource representations</p>
</td>
</tr>
<tr>
<td>
<p><kbd>PUT</kbd></p>
</td>
<td>
<p>Create a new resource</p>
</td>
</tr>
<tr>
<td>
<p><kbd>DELETE</kbd></p>
</td>
<td>
<p>Delete the resource (optionally linked resource as well)</p>
</td>
</tr>
<tr>
<td>
<p><kbd>POST</kbd></p>
</td>
<td>
<p>Modify the resource</p>
</td>
</tr>
<tr>
<td>
<p><kbd>HEAD</kbd></p>
</td>
<td>
<p>Meta information of the resource</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>The preceding table shows the HTTP methods to implement ROA.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The benefits of ROA</h1>
                
            
            
                
<p>The following are the benefits of ROA:</p>
<ul>
<li><strong>Independent of client contracts</strong>: Free from interface agreements/contract formulations, that is, no need to formulate the contact as the entire web is based on HTTP operations.</li>
<li><strong>Explicit state</strong>: As the resource itself represents states, servers won't receive unknown application specific payloads; the server does not have to keep track of the client who called the server, and also the client doesn't need to know which server it has talked to.</li>
<li><strong>Scalability and performance</strong>: Scalability with ROA is shown by characteristics such as no contract boundaries, explicit states, and freeing up the clients from the server's stickiness(session). The performance improvement regarding response time for the ROA caching, load-balancing, indexing, and searching play a significant role in improving performance.</li>
</ul>
<p>A process of creating an affinity between a client and a specific server by a load balancer is called <strong>session stickiness</strong>. <br/>
<br/>
A contract or agreement is fundamentally a collection of metadata that defines many aspects of an underlying software program.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Beginning with REST</h1>
                
            
            
                
<p>So far, we have looked at ROA and a set of guidelines, such as statelessness, resources, addressability, uniform resources, and so on. Those guidelines are the fundamental implementation of REST architecture. As this book is all about RESTful patterns, we are going to explore more about the REST architectural style in this section.</p>
<p>The REST concepts were submitted as a PhD dissertation by Roy Fielding. The fundamental principle of REST is to use the <strong>HTTP</strong> protocol for data communication (between distributed hypermedia systems), and it revolves around the concept of resources where each and every component considered as a resource, and those resources are accessed by the common interfaces using <strong>HTTP</strong> methods:</p>
<div><img src="img/7d73d789-a00e-4d47-8ccb-dd4bdcb431d0.png" style="width:40.17em;height:17.25em;"/></div>
<p>An example implementation of an ROA/REST service</p>
<p>The preceding diagram shows you where REST stands in the ROA architecture and how it can be accessed by different consumers.</p>
<p>REST is an architectural style and not a programming language or technology. It provides guidelines for distributed systems to communicate directly using the existing principles and protocols of the web to create web services and APIs, without the need for SOAP or any other sophisticated protocols.  </p>
<p>The REST architecture is simple and provides access to resources so that the REST client accesses and renders the resources on the client side. In REST style,URI or Global IDs helps to identify each resource. As you know REST uses several resources representations to represent its type such as XML, JSON, Text, images and so on.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">REST architecture style constraints</h1>
                
            
            
                
<p>There are design rules that are applied to establish the different characteristics of the REST architectural style, which are referred to as REST constraints:</p>
<div><img src="img/894615f0-631a-4b3a-a38b-7b4d5750e9ea.png"/></div>
<p>REST architectural style constraints</p>
<p>The preceding diagram depicts REST constraints in a typical web/internet-based application. The following are the REST constraints:</p>
<ul>
<li>Client-server</li>
<li>Statelessness</li>
<li>Cacheable</li>
<li>Uniform interface</li>
<li>Layered systems</li>
<li>Code on demand</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Beginning with client-server</h1>
                
            
            
                
<p>The client-server architecture or model helps in the separation of concerns between the user interface and data storage:</p>
<div><img src="img/b5b024be-6070-4979-be88-294d0e1831f0.png" style="width:44.83em;height:32.00em;"/></div>
<p>The client and server </p>
<p>Let's discuss the client and server in the context of ROA as follows:</p>
<ul>
<li><strong>Client</strong>: It is the component that is the requestor of a service and sends requests for various types of services to the server</li>
<li><strong>Server</strong>: It is the component that is the service provider and continuously provides services to the client as per the requests </li>
</ul>
<p>Clients and servers typically comprise distributed systems that communicate over a network.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The client in client-server architecture</h1>
                
            
            
                
<p>There is no upper bound on the number of clients that can be serviced by a single server. It is also not mandatory that the client and server should reside in separate systems. Both client and server can reside in the same system, based on the hardware configuration of the system and the type of functionality or service provided by the server. The communication between client and server happens through the exchange of messages using a request-response pattern. The client basically sends a request for a service, and the server returns a response. This request-response pattern of communication is an excellent example of inter-process communication. For this communication to happen efficiently, it is necessary to have a well-defined communication protocol that lays down the rules of communication, such as the format of request messages, response messages, error handling, and so on. All communication protocols that are used for client-server communication work in the application layer of the protocol stack. To further streamline the process of client-server communication, the server sometimes implements a specific API that can be used by the client for accessing any specific service from the server.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The service in client-server architecture</h1>
                
            
            
                
<p>The term service used in the context of client-server architecture refers to the abstraction of a resource. The resource could be of any type and based on the one provided by the server (service); the server is named accordingly. For example, if the server provides web pages, it is called a <strong>web server</strong>, and if the server provides files, it is called a <strong>file server</strong>, and so on. A server can receive requests from any number of clients at a specific point in time. But any server will have its own limitations about its processing capabilities. Often, it becomes necessary for a server to prioritize the incoming requests and service them as per their priority. The scheduling system present in the server helps the server with the assignment of priorities.</p>
<p>Client-server benefits are in addition to separation of concerns and help with the following:</p>
<ul>
<li>Improving the portability of the user interface</li>
<li>Improving scalability by simplifying server implementations</li>
<li>Developing with standalone, independent testable components</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Understanding statelessness</h1>
                
            
            
                
<p>The statelessness constraint helps services to be more scalable and reliable. Statelessness, in the REST context, means that all the client requests to the server carry all the information as explicit (stated), so that the server understands the requests, treats them as independent, and those client requests keep the server independent of any stored contexts. Keeping the session state within the client is important to manage this constraint in the services.</p>
<p>The following diagram shows the <strong>Service Consumer</strong> (client) and the <strong>Service States</strong> are independent and managed within the client and server respectively:</p>
<div><img src="img/8a9d71d7-0c74-4ecd-be48-40ab48c13250.png" style="width:42.83em;height:23.00em;"/></div>
<p>Statelessness (managing states independently)</p>
<p>The statelessness constraint imposes significant restrictions on the kind of communications allowed between services and consumers, to achieves its design goals. The following are the restrictions to achieve statelessness:</p>
<ul>
<li>It is the complete responsibility of the client to store and handle all the application states and the related information on the client side.</li>
<li>The client is responsible for sending any state information to the server whenever it's needed.</li>
<li>No session stickiness or session affinity on the server for the calling request (client).</li>
<li>The server also needs to include any necessary information that the client may need to create a state on its side.</li>
<li>HTTP interactions involve two kinds of states, application state and resource state, and statelessness applies to both. Let's see how the statelessness constraint is handled in each state:
<ul>
<li><strong>Application state:</strong> The data that is stored on the server side and helps to identify the incoming client request, using the previous interaction details with current context information</li>
<li><strong>Resource state:</strong> This is referred to as a resource representation, and it is independent of the client (the client doesn't need to know this state unless it is available as response is needed), and this is the current state of the server at any given point in time</li>
</ul>
</li>
</ul>
<p>The statelessness constraint of REST applies to the application state, that is, being free only on the application state and nothing to do with resource state. Twitter's API is the best example of a stateless service <kbd>(GET: https://api.twitter.com/1.1/direct_messages.json?since_id=xxx&amp;amp;count=x)</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Advantages and disadvantages of statelessness</h1>
                
            
            
                
<p>The following are some advantages of statelessness:</p>
<ul>
<li>As the server does not need to manage any session, deploying the services to any number of servers is possible, and so scalability will never be a problem</li>
<li>No states equals less complexity; no session (state) synchronize logic to handle at the server side</li>
<li>As the service calls (requests) can be cached by the underlying application, the statelessness constraint brings down the server's response time, that is, it improves performance with regard to response time</li>
<li>Seamless integration/implementation with HTTP protocols is possible as HTTP is itself a stateless protocol</li>
<li>Improves visibility as each request is its own resource and can be treated as an independent request</li>
<li>Improves reliability as it can recover from partial failures</li>
</ul>
<p>The following are some disadvantages of statelessness:</p>
<ul>
<li>Increase per-interaction overhead</li>
<li>Each request of webservices needs to get additional information so that it get parsed (interpreted) so that the server understands the client state from the incoming request and takes care of the client / server sessions if needed</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Caching constraint in REST</h1>
                
            
            
                
<p><strong>Caching</strong> is the ability to store frequently accessed data (a response in this context) to serve the client requests, and never having to generate the same response more than once until it needs to be. Well-managed caching eliminates partial or complete client-server interactions and still serves the client with the expected response. Obviously, caching brings scalability and also performance benefits with faster response times and reduced server load.</p>
<p>As you can see in the next diagram, the service consumer (<strong>Client</strong>) receives the response from the cache and not from the server itself, and a few other responses are directly from the server as well. So, caching helps with the partial or complete elimination of some interactions between the service consumers and so helps to improve efficiency and performance (reduced latency time in response):</p>
<div><img src="img/6e67959d-f479-4edd-8a23-eb490f82590b.png" style="width:30.17em;height:26.17em;"/></div>
<p>There are different caching strategies or mechanisms available, such as browser caches, proxy caches, and gateway caches (reverse-proxy), and there are several ways that we can control the cache behavior, such as through pragma, expiration tags, and so on. The following table gives a glimpse of the various cache control headers one use to can fine-tune cache behaviors:</p>
<table border="1" class="MsoTableGrid" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>Headers</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
<td>
<p><strong>Samples</strong></p>
</td>
</tr>
<tr>
<td>
<p>Expires</p>
</td>
<td>
<p>Header attribute to represent date/time after which the response is considered stale</p>
</td>
<td>
<p>Expires: Fri, 12 Jan 2018 18:00:09 GMT</p>
</td>
</tr>
<tr>
<td>
<p>Cache-control</p>
</td>
<td>
<p>A  header that defines various directives (for both requests and responses) that are followed by caching mechanisms</p>
</td>
<td>
<p><kbd>Max age=4500</kbd>, cache-extension</p>
</td>
</tr>
<tr>
<td>
<p>E-Tag</p>
</td>
<td>
<p>Unique identifier for server resource states</p>
</td>
<td>
<p>ETag:<kbd>uqv2309u324klm</kbd></p>
</td>
</tr>
<tr>
<td>
<p>Last-modified</p>
</td>
<td>
<p>Response header helps to identify the time the response was generated</p>
</td>
<td>
<p>Last-modified: Fri, 12 Jan 2018 18:00:09 GMT</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>For more about cache-control directives. Please refer to <a href="https://tools.ietf.org/html/rfc2616#section-14.9">https://tools.ietf.org/html/rfc2616#section-14.9</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Benefits of caching</h1>
                
            
            
                
<p>Obviously, there are a lot of benefits to caching frequently accessed data, and the following are the significant ones:</p>
<ul>
<li>Reduced bandwidth</li>
<li>Reduced latency (faster response time)</li>
<li>Reduced load on the server</li>
<li>Hide network failures and serve a client with the response</li>
</ul>
<p>The cache constraint builds upon the client-server and stateless ones, with the requirement that responses are implicitly or explicitly labeled as cacheable or non-cacheable.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Understanding the uniform interface</h1>
                
            
            
                
<p>As we mentioned earlier in the uniform interface section as part of ROA, REST-based services can use the HTTP interface, such as <kbd>GET</kbd>, <kbd>POST</kbd>, <kbd>PUT</kbd>, <kbd>DELETE</kbd>, and so on, to maintain uniformity across the web. The intention of a uniform interface is to retain some common vocabulary across the internet. For example, <kbd>GET</kbd> does mean to get (read) something from the server. The services can independently evolve as their interfaces simplify and decouple the architecture, and the uniform interface brings a uniform vocabulary to those resources as well. The following diagram depicts the combination of <strong>HTTP Methods</strong> and the <strong>Resource Names</strong> for <strong>Uniform Interfaces</strong>:</p>
<div><img src="img/d1473845-d354-476f-96d3-a1cb33edbad8.png" style="width:45.08em;height:8.42em;"/></div>
<p>There are four guiding principles suggested by Fielding that constitute the necessary constraints to satisfy the uniform interface, and they are as follows:</p>
<ul>
<li>Identification of resources</li>
<li>Manipulation of resources</li>
<li>Self-descriptive messages</li>
<li>Hypermedia as the engine of application state</li>
</ul>
<p>We will see each constraint in detail in the following sections.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Identification of resources</h1>
                
            
            
                
<p>As we have seen in earlier sections, a resource represents a named entity in a web application, and it is usually a <strong>Uniform Resource Locator</strong> (<strong>URL</strong>). So, an entity can be identified and assigned as a resource by an explicit reference to it.</p>
<p>A URL in a web application is usually a link, and it is in fact a URI. For example, a home page URI, <a href="https://developer.twitter.com">https://developer.twitter.com</a>, uniquely identifies the concept of a specific website's root resource. In REST constraints, the URIs we use are described as follows:</p>
<ul>
<li>The semantics of the mapping of the URI to a resource must not change. For instance, Twitter's <a href="https://developer.twitter.com/en/docs/tweets/post-and-engage/api-reference/get-statuses-retweets-id">https://api.twitter.com/1.1/statuses/retweets/:id.json</a> as a URI may never change, and of course the contents or values will keep improving, according to the latest updates.</li>
<li>Resource identification is independent of its values so two resources could point to the same data at some point, but they are not the same resource.</li>
<li>For example, URI 1, <a href="https://api.twitter.com/1.1/statuses/retweets/:id.json" target="_blank">https://api.twitter.com/1.1/statuses/retweets/:id.json</a>, returns a collection up to 100 of the most recent retweets of a tweet (specified by the ID).</li>
<li>The other URI 2, <a href="https://developer.twitter.com/en/docs/tweets/post-and-engage/api-reference/get-statuses-retweeters-ids">https://api.twitter.com/1.1/statuses/retweeters/ids.json</a>, <a href="https://developer.twitter.com/en/docs/tweets/post-and-engage/api-reference/get-statuses-retweeters-ids">responds with a collection of 100 user IDs (maximum) belonging to users who have retweeted the tweet (specified by the ID parameter)</a>.<a href="https://developer.twitter.com/en/docs/tweets/post-and-engage/api-reference/get-statuses-retweeters-ids"/></li>
</ul>
<p>The second method offers similar data to the first method (statuses/retweets) and may produce the same results or combinations, but both methods certainly represent a different resource.</p>
<ul>
<li>URIs bring benefits such as only one way to access a resource, dynamic media types for resource responses (serve the media type at the time it is requested) with the help of the Accept headers, and clients accessing those dynamic resources do not need to change any identifiers if any change is made in the response content type.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Manipulation of resources</h1>
                
            
            
                
<p>Resources, once identified, can be returned by the server in a different format, such as JSON, XML, HTML, PNG,  SVG, and so on. These formats are a representation of the identified resources, and the client will understand the list of possible well-defined formats or media types (also called <strong>Multipurpose Internet Mail Extension</strong> (<strong>MIME</strong>)) from the headers.</p>
<p>The resource's representation is manipulated or processed by clients. The application needs to support more than one representation of the same resource and the same URI; in other words, the same exact resource is represented by different clients in different ways.</p>
<p>Let's take an example; a document might be represented as JSON to an automated program, but as HTML to a web browser. The purpose of these representations is to provide a way to interact with the resource, and so the clients can indicate the intended representations they wish to receive.</p>
<p class="mce-root"/>
<p>The preceding conceptual distinction allows the resource to be represented in different ways without changing its identifiers. It is possible with the HTTP header (Accept) getting passed to the server by the clients in each request. The resources are updated or added by sending representations from the client by the RESTful application. The following diagram is a sample representation format, captured for a sample request from my Postman tool:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img src="img/baddf899-562a-437b-8ed5-553548562a7f.png" style="width:14.17em;height:14.50em;"/></p>
<p class="mce-root"/>
<p class="mce-root">So, the decoupling of the resource's representation from the URI is one of the crucial aspects of REST.</p>
<p>The following list shows various content-type representation formats (as headers) that one can use in the request or response:</p>
<ul>
<li>Text/HTML, text/CSS, text/JavaScript</li>
<li>Application/XML, application/JSON, application/x-www-form-urlencoded </li>
<li>Image (SVG, JPG, PNG, and so on)</li>
</ul>
<div><strong>Postman</strong> is a tool that helps us to interact with REST APIs. It offers a very friendly user interface that can quickly test the APIs by constructing requests and reading responses. <a href="adb6e30f-4e7f-49d7-bf62-7dddebd4afc5.xhtml">Chapter 6</a>, <em>RESTful Services API Testing and Security</em> of this book provides more information about the Postman tool and its wider abilities to test RESTful APIs.</div>


            

            
        
    

        

                            
                    <h1 class="header-title">Self-descriptive messages</h1>
                
            
            
                
<p>A client's request and server's response are messages; those messages should be stateless and self-descriptive. They can have a body and metadata. RESTful applications operate on the notion of constrained message types (<kbd>GET</kbd>, <kbd>HEAD</kbd>, <kbd>OPTIONS</kbd>, <kbd>PUT</kbd>, <kbd>POST</kbd>, and <kbd>DELETE</kbd>) and they are fully understood by both the server and the client.</p>
<p class="mce-root"/>
<p>A resource's desired state can be represented within a client's request message. A resource's current state may be embodied within the response message that comes back from a server. As an example, a wiki page editor client may use a request message to transfer a representation that suggests a page update (new state) for a server-managed web page (resource). It is up to the server to accept or deny the client's request.</p>
<p>Self-descriptive messages may include metadata to convey additional details regarding the resource state, the representation format and size, and even the message itself. An HTTP message provides headers for organizing the various types of metadata into uniform fields. The following diagram depicts a sample request and its headers, and the server response for the same request along with its headers:</p>
<div><img src="img/dba3d5a4-86a9-4508-bb00-01c5553a305f.png"/></div>
<p>So a self-descriptive message in REST style is all about not maintaining state between client and server, and needs to carry enough information about itself or explain with explicit states. So in the following table, you can see the self-descriptive messages with examples:</p>
<table border="1" class="MsoTableGrid" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>Resource</strong></p>
</td>
<td>
<p><kbd>GET</kbd></p>
</td>
<td>
<p><kbd>PUT</kbd></p>
</td>
<td>
<p><kbd>POST</kbd></p>
</td>
<td>
<p><kbd>DELETE</kbd></p>
</td>
</tr>
<tr>
<td>
<p><br/>
<kbd>booktitles.com/resources</kbd></p>
</td>
<td>
<p>Get all resources belonging to the collection</p>
</td>
<td>
<p>Replace with another collection</p>
</td>
<td>
<p>Create the collection</p>
</td>
<td>
<p>Delete the whole collection</p>
</td>
</tr>
<tr>
<td>
<p><br/>
<kbd>booktitles.com/resources/title18</kbd></p>
</td>
<td>
<p>Lookup for title 18</p>
</td>
<td>
<p>Modify title 18</p>
</td>
<td>
<p>Create new resource as title 18</p>
</td>
<td>
<p>Delete title 18</p>
</td>
</tr>
</tbody>
</table>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Hypermedia as the Engine of Application State</h1>
                
            
            
                
<p><strong>Hypermedia as the Engine of Application State</strong> (<strong>HATEOAS</strong>) is one of the most critical constraints; without addressing it, services cannot be termed RESTful services. However, before we get into the details of HATEOAS, let's get a brief idea about the <strong>Richardson Maturity Model</strong> (<strong>RMM</strong>) as it is an essential reference and serves as a guide to any RESTful services to follow the HATEOAS constraints.</p>
<p>The RMM is a model developed by Leonard Richardson, and it breaks down the principal elements of the REST approach to <strong>Resources</strong>, <strong>HTTP Verbs</strong>, and <strong>Hypermedia Controls</strong>. The following diagram depicts the RMM's four levels, and those levels are used to grade the APIs; that is, the better the API adheres to these constraints, the higher the scores are:</p>
<div><img src="img/0be91c7a-d407-4a44-8139-bdd53eccdd89.png" style="width:36.33em;height:31.83em;"/></div>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p>So, an API is fully qualified to be a RESTful API only when it scores <strong>Level-3</strong>. We will see more guidelines for how APIs can be RESTful APIs later in this chapter. However, now you know why we touched on the RMM here before we move on to HATEOAS.</p>
<p>Once the client gets the initial response to its resource request from the server, it should be able to move to the next application state by picking up hyperlinks from the same received response.</p>
<p>Let's take an example to explain the preceding statement. Say a client will <kbd>POST</kbd> a representation of a new <kbd>TODO</kbd> item to the server, then the state of the Task Manager application will change by growing the list of the <kbd>TODO</kbd> item and both <kbd>POST</kbd> and <kbd>GET</kbd> are accomplished via hypermedia links.</p>
<p>Resource representations are shared by sending self-descriptive messages to any identified resources. Then, they change the state of the application, and the client with the received hypermedia links will move to the next application state.</p>
<p>In an HTML browser, <kbd>GET</kbd> methods are accomplished by clicking on anchor tags (<kbd>&lt;a&gt;</kbd>) that have an HREF attribute, and HREF contains a resource URI. <kbd>POST</kbd> methods are achieved by pressing the Submit button within a <kbd>&lt;form&gt;</kbd> tag that has an action URI attribute. The anchor (<kbd>&lt;a&gt;</kbd>) and form (<kbd>&lt;form&gt;</kbd>) tag elements were sent to the client as part of the representation of the client requested resource.</p>
<p>The web contracts (sharing representations) are expressed regarding media types; a client that calls the service would know the media types and how to process the content as well. So the application enables the server to inform the client of possible ways to change its application state via hypermedia.</p>
<p>Some media types work well (in harmony) with the web, and they are called <strong>hypermedia</strong> formats. The formats that host URIs and links are hypermedia formats.</p>
<p>Plain old XML is not hypermedia-friendly as it doesn't carry the links and protocols.</p>
<p class="mce-root"/>
<p>The following diagram depicts a sample JSON response from a server without and then <strong>With HATEOAS</strong> (with links and HREFs):</p>
<div><img src="img/1c9713f8-a8c6-4124-9115-652915fd92a5.png"/></div>
<p>Before we conclude this section, let's have a recap of HATEOAS:</p>
<ul>
<li>HATEOAS means an application state representation (resource) that includes links to related resources. The absence or presence of a link on a page is an essential part of the resource's current state and so is essential for the RESTful APIs.</li>
<li>A URI is a differentiator of REST architectural style, and defining the URIs is really critical, as it will be around for a very long time. So it is crucial to evaluate the links (when they change), keeping their future in mind, or put it in a simpler way, the <em>URI should stay the same regardless of the many changes its representations go through</em>. There is an interesting read about this at <a href="https://www.w3.org/Provider/Style/URI.html.en">https://www.w3.org/Provider/Style/URI.html.en</a>; it supports this point in great detail, and we encourage you to have a look.</li>
</ul>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Layered systems</h1>
                
            
            
                
<p>In general, a layered system consists of layers with different units of functionality. The essential characteristics of layered systems are that a Layer communicates by means of pre-defined interfaces and communicate only with the layer above or layer below, and the layers above rely on the layers below to it to perform its functions. Layers can be added, removed, modified, or reordered as the architecture evolves. Consider the following diagram of layers:</p>
<div><img src="img/afb40908-19e7-428c-adae-2bd8a2ba2b12.png" style="width:27.75em;height:19.00em;"/></div>
<p>So, let's start with an example. The REST style allows services to make use of a layered system architecture where we deploy the REST APIs on server A, store data on server B, and authenticate with server C. The client calling the REST API doesn't have any knowledge of the servers the services use:</p>
<div><img src="img/f3969d73-0cab-4fb3-aa1d-3fd5b1769ec4.png" style="width:42.25em;height:16.42em;"/></div>
<p>The REST architectural style suggests services can consist of multiple architectural layers. The layers will have published service contracts or intermediaries. The logic within a given layer cannot have knowledge beyond the immediate layers above or below it within the solution hierarchy.</p>
<p>Intermediaries are the layers present between the client and the server and can be added or removed, more importantly, without changing the interfaces between components.</p>
<p>The intermediaries have the following properties:</p>
<ul>
<li>Intermediaries can be event-driven middleware components to establish processing layers between consumers and services</li>
<li>They can be proxies (selected by the client to provide interfaces with data translation services, enhanced performance, or security protections)</li>
<li>They can be gateways as well (chosen by the server or the network, and used for data translation, security enforcement, and performance enhancements)</li>
</ul>
<p>A client may not be able to tell whether it is connected to the services directly with the server endpoint, or to an intermediary before reaching the actual server. Intermediary servers help to attain improved system scalability by having load balancers and shared caches. Layers may also enforce security policies for their calling clients.</p>
<p>It would be helpful for us to understand a few applications of layered systems (design), so let's look at the following points:</p>
<ul>
<li>Enables the service clients to invoke the services; the service that is called by the client doesn't reveal any information about other services it's using to process the client requests. In other words, the service consumer (client) only knows about the service it directly calls and doesn't know about other services consumed by the called service to process its requests.</li>
<li>The messages between the client and the server are processed by intermediaries helping to free the clients from the runtime message processing logic and making them unaware of how those messages are processed in other layers as well.</li>
<li>It's very critical for stability and scalability to add or remove layers in the layered system without any changes to the service consumers.</li>
<li>Request and response messages won't divulge any details to the recipients about which layer the message comes from.</li>
</ul>
<p>While layered systems bring additional latency and overhead as a drawback, there are trade-offs that are the benefits of layers and layered system designs, as follows:</p>
<ul>
<li>Encapsulates legacy services</li>
<li>Introduces intermediaries</li>
<li>Limits system complexity</li>
<li>Improves scalability</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Code on demand</h1>
                
            
            
                
<p>In distributed computing, <strong>code on demand</strong> (<strong>COD</strong>) is any technology that enables the server to send the software code to the clients to be executed on the client computer upon request from the client's software. Some well-known examples of the COD paradigm on the web are Java applets, the Adobe ActionScript language for the Flash player, and JavaScript.</p>
<p>The following can also be called the advantages of COD:</p>
<ul>
<li>COD is the optional constraint of REST and intends to allow business logic within the client web browser, applets, JavaScript, and ActionScript (Flash). I think video on demand sites are good examples of COD, as the video data files are downloaded and played according to the client system's specifications.</li>
<li>Only one optional constraint according to REST architectural style and it is COD. COD allow it clients to be flexible because the server that decides how specific items need to be handled on the client side. For instance, with COD, a client may download action scripts such as JavaScript, Applets (not widely used these days), Flex scripts to encrypt the client-server communication, so the underlying servers won’t aware of any specific encryption methods used in the process.</li>
<li>COD can also be applied to services and service consumers. For instance, service design can enable the servers to dynamically defer some portions of logic to the service client programs. This approach of delaying code execution to the client side is justifiable when service logic can be executed by the consumer more efficiently or effectively.</li>
<li>RESTful applications may very well be able to utilize clients that support COD. For instance, web browsers can allow servers to return scripts or links that can be executed at the client side. This sort of additional code execution helps to expand the capabilities of the client, without needing the user to install new client software.</li>
<li>In the COD style, a client component has access to a set of resources, but not the know-how of how to process them. It sends a request to a remote server for the code representing that know-how, receives that code, and executes it locally.</li>
</ul>
<p>However, the down side of using COD is reduces the visibility of the underlying API, and not every API prefers these kind of flexibility.</p>
<p>COD is classified as optional; architectures that do not use this feature can still be considered RESTful.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">RESTful service mandates</h1>
                
            
            
                
<p>In one of the online discussion forums, Roy Fielding recorded his frustration about a service that claims to be RESTful, but that service is a mere HTTP-based interface. The service was not fulfilling all the necessary REST architecture constraints. He even said that if the Engine of Application State (and hence the API) is not being driven by hypertext, then it <em>cannot</em> be RESTful and <em>cannot</em> be a REST API<em>.</em></p>
<p>With that said, any services that need to be termed RESTful must strictly adhere to the mandatory REST architecture constraints. Those constraints are design rules that are applied to establish the distinct characteristics of the REST architectural style.</p>
<p>Roy, the founder of the REST style, enforces the following REST constraints as mandatory for any web service to be qualified as RESTful. These mandatory constraints are as follows:</p>
<ul>
<li>Client-server</li>
<li>Statelessness</li>
<li>Cache</li>
<li>Interface/uniform contract</li>
<li>Layered system</li>
<li>The optional REST constraint is COD (architectures that do not use this feature can still be considered RESTful)</li>
</ul>
<p>Each constraint is a predetermined design decision and will have positive and negative influences on the services. However, these constraints are meant to provide a better architecture that resembles the web (perhaps positive impacts balanced with negative consequences).</p>
<p>There may be a need for potential trade-offs when deviating from REST constraints. Ensure those trade-offs don't weaken or eliminate the mandated constraints. If so, that architecture may no longer conform to REST, or in other words, the services (architecture) are not RESTful.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Architectural goals of REST</h1>
                
            
            
                
<p>The REST architectural style brings a set of properties that help to establish the design goals that are embedded in the application of REST constraints. These properties are as follows:</p>
<ul>
<li>Performance</li>
<li>Scalability</li>
<li>Simplicity</li>
<li>Modifiability</li>
<li>Visibility</li>
<li>Portability</li>
<li>Reliability</li>
<li>Testability</li>
</ul>
<p>The preceding properties signify a target state of software architecture and fundamental qualities of the WWW. Adhering to REST constraints in design decisions helps to achieve the preceding listed goals, and, of course, these properties can be further improved with more design decisions that are not necessarily parts of REST. However, as quoted in the <em>RESTful services mandate</em> section, a web service, to be called a RESTful service, should adhere to the RESTful constraints.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>Let's summarize what we have covered in this chapter and what we can take away in the context of the REST architectural style. We started with a brief history of the evolution of the World Wide Web, its layers, and its architecture. Then we moved on to the web API, a development model for web services, and how REST-based services communicate with existing web protocols with simplified representations.</p>
<p>We looked briefly at SOA and also in more detail at ROA. We covered the purpose of ROA (to use simplified, well-understood and well-known web technologies along with core design principles), its principles, and its characteristics as well. After setting the ground with ROA, we got introduced to the concept of REST; the mandatory constraints of REST architecture, such as client-server, statelessness, cacheable, uniform interface, and layered systems; and also the optional code on demand constraints.</p>
<p>As part of a uniform interface, we learned its four guiding principles, which are the identification of resources, manipulation of resources, self-descriptive messages, and HATEOAS, and we also touched upon the importance of the RMM to get a foundation for building RESTful services.</p>
<p>This chapter described in detail the five mandatory constraints and how in Roy's view they define an architectural style as RESTful. It is critical to understand what makes REST RESTful and what does not.</p>
<p>We concluded this chapter with a quick introduction to the software architecture properties of the WWW, and how REST constraints help to achieve the architecture goals of REST, such as performance, scalability, and simplicity.</p>
<p>I hope you have enjoyed this chapter. In the next chapter, we will learn about API design strategies, such as self-service enablement, resource collaboration, and how to address security and scalability concerns along with RESTful API guidelines and constituents.</p>


            

            
        
    </body></html>