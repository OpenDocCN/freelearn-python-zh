<html><head></head><body><div class="chapter" title="Chapter&#xA0;1.&#xA0;Getting Started with the Robot Framework"><div class="titlepage"><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Getting Started with the Robot Framework</h1></div></div></div><p>In this chapter we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Definition and need for acceptance testing</li><li class="listitem" style="list-style-type: disc">Introduction and a brief history of the Robot Framework</li><li class="listitem" style="list-style-type: disc">Components of the Robot Framework</li><li class="listitem" style="list-style-type: disc">Various installation methods</li><li class="listitem" style="list-style-type: disc">Different installation environments</li><li class="listitem" style="list-style-type: disc">Creation and execution of a sample project</li><li class="listitem" style="list-style-type: disc">Brief description of the generated files</li></ul></div><p>This book introduces you to the <a id="id0" class="indexterm"/>Robot Framework, which is a Python-based, keyword-driven, and acceptance test automation framework. It is very flexible and easy to use and extend according to your intentions. Built to provide acceptance test regardless of the platform size and scope of the software to be tested, also known as System Under Test (SUT<a id="id1" class="indexterm"/>), it is an ideal software tool to structure and manage different tests as part of a comprehensive test suite. Since this tool utilizes and manages the tests as well as deals with the software under test, it is beneficial for both testers and developers alike. Today, with the rise of versatile software tools and greater emphasis on test-driven development, the line between tester and developer has become blurred. To learn and use this tool effectively, you will have to put yourself in the shoes of both tester as well as a developer. The Python and/or ports into Java and .Net framework such as, Jython and Ironpython are also required.</p><p>As with any other physical creation, software is built with an aim of directly or indirectly changing our lives to solve a task or desire of someone. However, programming is an abstract science that is not dependent upon its end-user's desires, commonly referred to as garbage in – garbage out. A difference between the created software and its expected behavior by its user determines its implementation by the user. Thus, the end user must accept the software that is intended to be sold to him. However, the user often does not wants to be involved in the finer details and just needs to get the things done as he envisages with each<a id="id2" class="indexterm"/> iteration of the software. In order to perform this, the interactions that the end user does with the software is needed to be verified beforehand, which has led to creation of testing especially designed to perform this process of testing and verification. This process is known as<a id="id3" class="indexterm"/> acceptance testing. However, as the software grows, more and more, acceptance tests come up that give rise to a sense of chaos as upon failure of a test, proper context is not easily identified.</p><p>As the scale and complexity of software has grown up, so has the need for its quality assurance. Manual tests often are quite easy to set up, but they give diminishing returns of scale and are only feasible up to an extent, where a tester can manually work through different scenarios and identify bugs and errors in time without affecting the delivery schedule of the resultant product.</p><div class="section" title="The need for acceptance testing"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec08"/>The need for acceptance testing</h1></div></div></div><p>For tests that are large in size<a id="id4" class="indexterm"/> or complexity, a structured approach can help you to pinpoint the errors, which arise while testing for the system is carried out under test's acceptance. Increase in the development speed and efficiency as well as create accountability for various features of the software are also taken into consideration. These benefits can be summarized as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Pinpoint application failure</li><li class="listitem" style="list-style-type: disc">Reduced error rate</li><li class="listitem" style="list-style-type: disc">Provide automation and reusability</li><li class="listitem" style="list-style-type: disc">Create a test audit trail</li></ul></div><div class="section" title="Pinpoint application failure"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec07"/>Pinpoint application failure</h2></div></div></div><p>Through testing, it is <a id="id5" class="indexterm"/>possible for you to identify complete or partial failures as well as identify bottlenecks in performance that might have slipped during development or in other forms of testing.</p></div><div class="section" title="Reducing the error rate"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec08"/>Reducing the error rate</h2></div></div></div><p>Through automation, the predetermined steps involved to run the program can be performed exactly as desired with no<a id="id6" class="indexterm"/> interference as well as no extra or erroneous user interactions. This is different from monkey testing as in acceptance testing; only the happy path scenario is to be dealt with.</p></div><div class="section" title="Providing automation and re-use"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec09"/>Providing automation and re-use</h2></div></div></div><p>Testers or any other human resources are expensive than computation cycles. So it is best to automate the repetitive tasks,<a id="id7" class="indexterm"/> which will also reduce time that is normally spent in typing, clicking, and digesting the user interface as well by the test user. Furthermore, test can be reused or iterated over, which reduces the amount of tests while making sure that the complete acceptance testing remains while you can focus on other problems.</p></div><div class="section" title="Creating the a test audit trail"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec10"/>Creating the a test audit trail</h2></div></div></div><p>By keeping a record of various<a id="id8" class="indexterm"/> test results, you can gather interesting facts about acceptance testing such as how much of the system under test is covered under acceptance tests as well as how many failures were reported. This can be useful in changing management as well as re-engineering/modernization of the existing software.</p></div></div></div>
<div class="section" title="What is the Robot Framework?"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec09"/>What is the Robot Framework?</h1></div></div></div><p>The Robot Framework <a id="id9" class="indexterm"/>is an open source, general purpose test automation framework used for acceptance testing and streamlines it into mainstream development, giving rise to the concept of <span class="strong"><strong>acceptance test driven development</strong></span> (<span class="strong"><strong>ATDD</strong></span>). <a id="id10" class="indexterm"/>While commercial and in-house automated testing tools have been used traditionally to provide this kind of test automation. It suffers from the problem of reinventing the wheel and vendor lock-in as well as lack of flexibility to use tests with different software and under different circumstances. It stands out from other tools used for the same purpose by working on easy-to-use tabular test files that provide different approaches towards test creation. As different projects require acceptance testing in various ways, there is a need to make tests flexible, as the Robot Framework is flexible and extensible enough for handling these scenarios.</p><p>It is the extensible nature of the tool that makes it so versatile that it can be adjusted into different scenarios and used with different software backend. While it is most popularly used with selenium as a website automation tool, it can also be used with image-based testing software like<a id="id11" class="indexterm"/> <span class="strong"><strong>sikuli</strong></span> and also with software that require remote access over multiple machines while only running the tests over a given machine. All of these can be made easily available through creation of custom libraries, which link up the Robot Framework configuration code keywords with tasks associated with whatever software the Robot Framework is using. On the other hand, the output that the framework produces can also be used in multiple ways, first of which is the HTML report and log file that not only produces a XUnit styled output, but also contains test operations in detail while signifying the execution order and test hierarchy of entire tests. This contrasts with the optional <code class="literal">.xml</code> generation that can be useful in further manipulation of the processes. One such example is creation of customized programs that use the information obtained by running tests to create a wide variety of results. Another example is the log files' subsequent use in continuous delivery environments that can allow a build to continue<a id="id12" class="indexterm"/> or fail based on all the individual acceptance tests which are in use.</p><p>It was created by <span class="emphasis"><em>Pekka Klärck</em></span> as part of his master's thesis (<a class="ulink" href="http://http://eliga.fi/Thesis-Pekka-Laukkanen.pdf">http://eliga.fi/Thesis-Pekka-Laukkanen.pdf</a>) and was developed within Nokia Siemens Networks in 2005. Its second version has been open sourced under Apache License, Version 2 since 2008 and has an active community of volunteers. It is available at <a class="ulink" href="http://code.google.com/p/robotframework">http://code.google.com/p/robotframework</a>.</p></div>
<div class="section" title="The Robot Framework ecosystem"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec10"/>The Robot Framework ecosystem</h1></div></div></div><p>The following diagram<a id="id13" class="indexterm"/> presents a conceptual, high-level overview of the framework, and offers an insight <a id="id14" class="indexterm"/>into various components involved:</p><div class="mediaobject"><img src="graphics/3033_01_01.jpg" alt="The Robot Framework ecosystem"/></div><p>This can be explained broadly as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Tests &amp; Test Data</strong></span>: This is the <a id="id15" class="indexterm"/>configuration of the tests, the closest to what most testers of the framework will be. It comprises test and data files and folders as well as the contents of those which dictate the test execution.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Test Results</strong></span>: These are the<a id="id16" class="indexterm"/> end products of the tests, which are used to determine the results of tests as well as logs that can be used to assess various portions of the test.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Robot Framework</strong></span>: This is<a id="id17" class="indexterm"/> the core framework that performs the actual heavy lifting to get things done.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Test tool driver</strong></span>: This provides communication between the framework and the actual tools in place. It<a id="id18" class="indexterm"/> can be custom-tailored to meet specific requirements by the testing tool in place.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Testing Tool</strong></span>: This is the actual<a id="id19" class="indexterm"/> software that is used to perform acceptance testing.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>End Application (System under test)</strong></span>: This is the<a id="id20" class="indexterm"/> actual software that is to be tested for <a id="id21" class="indexterm"/>usability for its acceptance by the client or the end user.</li></ul></div></div>
<div class="section" title="Installing and setting up the Robot Framework"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Installing and setting up the Robot Framework</h1></div></div></div><p>The current version of the Robot Framework requires Python 2.7 for setup.</p><p>As of now, only pybot script gets created<a id="id22" class="indexterm"/> from a Python environment. In case of other environments, only the corresponding execution script gets created. If you happen to have multiple environments, then installation of different scripts is also possible. This differs from the previous versions where on installation, both pybot and jybot scripts were installed.</p><p>For custom<a id="id23" class="indexterm"/> installation, you will require Python, Jython, or Ironpython pre-installed; and environment <code class="literal">PATH</code> variable set correctly as the Robot Framework will use the first Python binary available on <code class="literal">PATH</code> or the exact library if supplied with the python command. You can verify this from the command line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sumit@darkstar066:~$ python --version </strong></span>
<span class="strong"><strong>Python 2.7.4 </strong></span>
<span class="strong"><strong>sumit@darkstar066:~$ jython --version </strong></span>
<span class="strong"><strong>Jython 2.5.2 </strong></span>
<span class="strong"><strong>sumit@darkstar066:~$ </strong></span>
</pre></div><p>On the project downloads page, there are various options, listed here under the following self-explanatory headings.</p><div class="section" title="Source installation"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec11"/>Source installation</h2></div></div></div><p>To use the source, you can either download the zip containing sources or clone the project using mercurial hg clone: <a class="ulink" href="https://code.google.com/p/robotframework">https://code.google.com/p/robotframework</a>.</p><p>This will clone the project in the current directory and then you can either straightaway install the project, or make<a id="id24" class="indexterm"/> some modifications for customizing the framework.</p><p>Now go to the folder where source is checked out/unzipped and perform the following commands based upon the environment present:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>python setup.py install</strong></span>
</pre></div><p>The preceding command installs the Python based version with pybot and rebot runner scripts.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>jython setup.py install</strong></span>
</pre></div><p>The preceding command installs the Jython based version, with jybot and jyrebot scripts.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>ipy setup.py install</strong></span>
</pre></div><p>The preceding<a id="id25" class="indexterm"/> command installs the Ironpython based runtime with ipybot and ipyrebot scripts.</p><p>If you see this folder, along with standard <code class="literal">setup.py,</code> there is another file, <code class="literal">install.py</code>, that can be used to install (it is the similar as installation from <code class="literal">setup.py</code>), reinstall, or uninstall the framework that can be used as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>python install.py in    [Installation]</strong></span>
<span class="strong"><strong>python install.py un    [Uninstallation]</strong></span>
<span class="strong"><strong>python install.py re    [Re-Installation]</strong></span>
</pre></div><p>To install with Jython or IronPython, replace <code class="literal">python</code> with <code class="literal">jython</code> or <code class="literal">ipy</code> respectively in the command. You may have to use <code class="literal">sudo/run</code> console as administrator if you run into any authentication errors, depending upon the user privileges.</p><div class="mediaobject"><img src="graphics/3033_01_02.jpg" alt="Source installation"/><div class="caption"><p>Installing from source with python</p></div></div></div><div class="section" title="One-click graphical installer"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec12"/>One-click graphical installer</h2></div></div></div><p>If you happen to be running Windows XP (32-bit), than you will want to use the one-click installer that installs the<a id="id26" class="indexterm"/> Robot Framework as well as Python and optionally, Jython and sets the paths without requiring any intervention. Other graphical installers for windows also exist in 32 and 64 bit versions.</p></div><div class="section" title="Java environment installation"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec13"/>Java environment installation</h2></div></div></div><p>You can use<a id="id27" class="indexterm"/> the standalone jar that contains a bundled Jython as well as the framework. You just need to have Java installed on your system to execute the runnable jar for its installation.</p><p>In this method, instead of a command, the jar file is executed:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>java -jar robotframework.jar run [options] data_sources</strong></span>
</pre></div></div><div class="section" title="The Python package installation"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec14"/>The Python package installation</h2></div></div></div><p>The pip install<a id="id28" class="indexterm"/> mechanism only requires, you to have the Python and package managers such as <code class="literal">easy_install</code> or <code class="literal">pip</code> installed on your computer. To install this, you just have to type <code class="literal">pip install robotframework</code> or <code class="literal">easy_install robotframework</code> from the command prompt and the Python based Robot Framework gets installed.</p><p>Note that, for Python to run correctly, you'll need <code class="literal">elementtree</code> module as the default one is already broken.</p><p>The user can install more than one environment simultaneously on a computer and use the specified commands separately without affecting either of the installations.</p></div></div>
<div class="section" title="Support for different runtimes"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec12"/>Support for different runtimes</h1></div></div></div><p>The Robot Framework not only works on the native python (<code class="literal">CPython/pypy</code> installations ), but also supports Java and .NET based runtimes in the form of Jython and ironpython respectively. While there are some features that are exclusive to native Python-or Jython-based Robot Framework installations, most of the functionality is equivalent on all the runtimes.<a id="id29" class="indexterm"/> As people might have different OS and application software a stack setup according to their needs or desires, so they can integrate this tool in their existing runtime without requiring a separate runtime.</p><p>Based upon the installer environment used, the Robot Framework will create appropriate startup and post-processing scripts:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Environment</p>
</th><th style="text-align: left" valign="bottom">
<p>Startup command</p>
</th><th style="text-align: left" valign="bottom">
<p>Post-processing command</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Python</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">pybot</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">rebot</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Jython</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">jybot</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">jyrebot</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Iron Python</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">ipybot</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">ipyrebot</code>
</p>
</td></tr></tbody></table></div><p>In addition to these commands used in starting the execution, the Robot Framework can directly be started through the <code class="literal">robot.run</code> module itself if the standard Robot Framework is installed. <a id="id30" class="indexterm"/>This can also be used instead of the standard commands as the commands also call the module internally. The module can be called if the Python command in use is the one that has the Robot Framework installed:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>python -m robot.run</strong></span>
<span class="strong"><strong>jython .../run.py</strong></span>
<span class="strong"><strong>ipy -m robot.run</strong></span>
</pre></div><p>This is handy if the Robot Framework is called by some the Python script. Instead of executing the scripts separately, you can call the framework from inside the same program easily.</p><p>The post processing command is useful to recreate test executions in the long run. After the test has been executed, you can save the XML file generated as output without saving any other file. To recreate the report and log files again in future, the <code class="literal">rebot</code> command can be used which takes the XML file as an argument and results in the generation of the log and report files without recalling or running the actual tests again.</p><div class="section" title="Command details"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec15"/>Command details</h2></div></div></div><p>The <code class="literal">Pybot</code> command <a id="id31" class="indexterm"/>provides the following major options:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Options</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">-N --name &lt;name&gt;</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Sets the name of topmost test suite in the test hierarchy—thereby effectively customizes those areas.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">-D --doc &lt;documentation&gt;</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Sets the<a id="id32" class="indexterm"/> documentation of the top level test suite.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">-M --metadata [name:value]</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Sets the metadata of the top level test suite.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">-G --settag &lt;tagname&gt;</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Sets the given tag to all executed test cases.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">-t --test name</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Selects the test cases available by performing a pattern match against them.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">-s --suite name</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Selects <a id="id33" class="indexterm"/>the specified test suite by its name and also allows for the test reports to have the desired name instead of the name picked up by file/folder name.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">-i --include tag</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Selects a test for execution on the basis of its tag name.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">-e --exclude tag</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Opposite <a id="id34" class="indexterm"/>of include tag.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">-R --runfailed output</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Selected failed tests of earlier test runs have another goal.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">-c --critical tag</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Tests having this tag are considered critical (default for all tests).</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">-n --noncritical tag</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Tests having this tag are overridden to be of non-critical type.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">-v --variable name:value</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Set variables in tests, only scalar variables(${}) are supported.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">-V --variablefile path</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Specify explicitly the file that contains variables.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">-d --output dir</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Specify the desired directory where resultant files are placed.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">-o --output file</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The generated XML output file.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">-l --log file</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The generated HTML log file.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">-r --report file</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The generated HTML log file.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">-x --xunit file</code>
</p>
</td><td style="text-align: left" valign="top">
<p>xUnit compatible result file (not created by default).</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">-b --debugginge rake</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Debug file written during the execution(not created by default).</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">-T --timestampoutputs</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Adds timestamp and provides a custom title to all output files.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">-L --Loglevel</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Threshold level for logging and logging and test order customization.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">-W --monitorwidth</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Specify the width of monitor output.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">-C --monitotcolors</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Specify whether to use color on console or not.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">-K --monitormarkers</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Specify test success on console for each test that passes.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">-P  --pythonpath path</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Additional locations to search test libraries from.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">-E -escape what</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Specify escape characters in console with common representation.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">-A --argumentfile path</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Specify a text file to read more arguments in tests.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">-h -? --help</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Prints detailed help for the command.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">--version</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Prints<a id="id35" class="indexterm"/> the version of the installed Robot Framework.</p>
</td></tr></tbody></table></div></div></div>
<div class="section" title="A small exercise"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec13"/>A small exercise</h1></div></div></div><p>To demonstrate the Robot Framework, <a id="id36" class="indexterm"/>we will create a simple dummy application as follows:.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a folder named <code class="literal">simpleapp</code>, this will serve as the application root folder.</li><li class="listitem">Inside this, create a folder named <code class="literal">testsuites</code>, this will contain all the test configuration files.</li><li class="listitem">Within the <code class="literal">testsuites</code> folder create a file, <code class="literal">Test_Case_1.txt</code>, with the following contents:<div class="informalexample"><pre class="programlisting">***Test Cases***

First Test Action  log  this is a basic test</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note02"/>Note</h3><p>Note that there are two spaces before and after the log keyword.</p></div></div></li><li class="listitem">Now run the project by calling Pybot script and passing the <code class="literal">testsuites</code> folder as an argument. You should get something similar to the following screenshot:<div class="mediaobject"><img src="graphics/3033_01_03.jpg" alt="A small exercise"/></div></li></ol></div><p>This confirms that the project has run successfully. You can view the results and log from generated<a id="id37" class="indexterm"/> HTML pages and perform future calculations over the data by using the XML file.</p><p>As we used a simple log statement, you get a logged message in the out log, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/3033_01_04.jpg" alt="A small exercise"/></div><p>The generated XML is also easy-to-read (as shown in the following screenshot), which can then be used by<a id="id38" class="indexterm"/> any other external tool as an input parameter—thereby reducing the human intervention between different stages of testing if this process is also automated.</p><div class="mediaobject"><img src="graphics/3033_01_05.jpg" alt="A small exercise"/></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec14"/>Summary</h1></div></div></div><p>In this chapter, we studied the need for acceptance test-driven development and how can we use the Robot Framework to achieve it. Various methods of installation were discussed over the supported platforms namely Python and its ported equivalents in form of Jython and Ironpython. We then proceed with exploring various commands that are available to perform various tasks as well as their possibilities. Later we created and run a basic test over the Robot Framework that validated the correctness of our setup. Lastly we examined the output files generated to get a look and feel of the framework.</p><p>Now that the basics have been covered, it is time for us to learn about the syntax, the different available actions, and different files involved in the Robot Framework project; which will enable us to write tests with various formats and be aware of the various options that are allowable in tests.</p></div></body></html>