- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building the Frontend of the Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you explored how to build your FastAPI backend and
    connect to MongoDB. This will be used by a React frontend that you will be building
    in this chapter. The application will be simple and feature-rich and, most importantly,
    will allow you to see the parts of the stack working together.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will build the frontend of a full-stack FARM application.
    You will learn how to set up a React Vite application and install and set up React
    Router, as well as various ways of loading content. The application will enable
    authenticated users to insert new items (cars), while there will be several pages
    for displaying cars.
  prefs: []
  type: TYPE_NORMAL
- en: You will develop a website that will list used cars for sale and allow only
    logged-in users to post new car ads. You will begin by creating a React application
    with Vite, then you will lay out the page structure with React Router and gradually
    introduce features such as authentication, protected pages, and data loading.
    After this chapter, you will be able to comfortably leverage React Router for
    your **single-page-applications** (**SPAs**) and use the powerful **React Hook
    Form** (**RHF**) for granular form control.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new React application using Vite
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the React Router for SPA page navigation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing data with data loaders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to RHF and Zod for data validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authentication and authorization with the Context API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protecting routes and displaying data with React Router pages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The technical requirements for this chapter are similar to the ones listed
    in [*Chapter 4*](B22406_04.xhtml#_idTextAnchor071)*, Getting Started with FastAPI*.
    You will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Node version 18.14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A good code editor, such as Visual Studio Code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Node package manager
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Vite React application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section you will scaffold a Vite React application and set up Tailwind
    CSS for styling. This procedure has already been covered in [*Chapter 5*](B22406_05.xhtml#_idTextAnchor090),
    *Setting Up a React workflow,*, so you can refer to it. Make sure to complete
    the brief tutorial in [*Chapter 5*](B22406_05.xhtml#_idTextAnchor090), as the
    following guide is heavily based on the concepts presented therein.
  prefs: []
  type: TYPE_NORMAL
- en: 'You are going to use the `create vite` command with the Node package manager
    to create your project through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your terminal client in a project directory containing the previously
    created backend folder, and issue the following command for creating a Vite React
    project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, change the directory to the newly created `frontend-app` folder and install
    the dependencies and Tailwind:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initialize the Tailwind configuration—the following command creates a blank
    Tailwind configuration file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, configure the generated `tailwind.config.js` and React’s `index.css`
    files according to the latest documentation at [https://tailwindcss.com/docs/guides/vite](https://tailwindcss.com/docs/guides/vite).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Your index.css should now include only the Tailwind imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To test that Tailwind has been properly configured, change the `App.jsx` file
    and start the development server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: When you refresh your app, you should see a white page with the text **Cars
    FARM**.
  prefs: []
  type: TYPE_NORMAL
- en: After setting up a functional React application and Tailwind, it is time to
    introduce probably the most important third-party React package—React Router.
  prefs: []
  type: TYPE_NORMAL
- en: React Router
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Up to this point, all of your components have fit onto a single page because
    you were building SPAs. To enable your application to display completely different
    pages based on the provided route, you will use a package called React Router—the
    de facto standard when it comes to page routing in React.
  prefs: []
  type: TYPE_NORMAL
- en: While there are some very good and robust alternatives, such as TanStack Router
    ([https://tanstack.com/router/](https://tanstack.com/router/)), React Router is
    widely adopted, and getting to know its basic mechanisms will greatly benefit
    you, as a developer, as you are bound to run into code based on it.
  prefs: []
  type: TYPE_NORMAL
- en: Version 6.4 of React Router has some major changes while retaining previous
    basic principles, which you will use to build your frontend. However, as of May
    2024, even more drastic changes have been announced—**React Remix**, an entire
    full-stack framework (with functionalities comparable to Next.js), which is based
    on React Router, and React Router itself should be merged into a single project.
    In this section, you will learn about the most important components that will
    allow you to create a single-page experience without page reloading or having
    knowledge of React Router 6.4, which will be very useful later, as it is the most
    widely adopted React routing solution.
  prefs: []
  type: TYPE_NORMAL
- en: The basic underlying principle of React Router is to listen to URL path changes
    (such as `/about` or `/login`) and conditionally display components in a layout.
    The displayed components can be thought of as “pages,” while the layout keeps
    some parts of the pages that should always be displayed—such as a footer and navigation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before looking at React Router, review the pages that you will have in your
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/`) path'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/cars`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/cars/car_id`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/login`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**An “insert new car” page**: This will provide a form for the authenticated
    user only'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For simplicity, you will not include a registration route (since there will
    only be a couple of authenticated employees) and there will not be a deleting
    or updating functionality on the frontend. In the following section, you will
    install and configure React Router and make it the basis of your application.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and setting up React Router
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: React Router is just a Node.js package, so the installation process is easy.
    The setting up of the router inside the application, however, includes lots of
    features and different options. You will be using the most powerful and recommended
    data router, which provides data loading and is the suggested option by the React
    Router team.
  prefs: []
  type: TYPE_NORMAL
- en: 'Working with the router generally involves two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Using one of the provided methods for generating the desired routes ([https://reactrouter.com/en/main/routers/picking-a-router](https://reactrouter.com/en/main/routers/picking-a-router)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating components, often called `Login.jsx` and `Home.jsx`. Additionally,
    you will almost always create one or more layouts that will contain common components
    such as the navigation or the footer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, you will perform the steps necessary to install React Router into your
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step, as with any third-party package, is to install the `router`
    package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The version number corresponds to the latest version at the time of writing,
    so you can reproduce the exact functionality.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this chapter, the CSS styling of the application will intentionally be kept
    to a bare minimum—just enough to distinguish between components.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Start by creating a new directory called `/pages` inside the `/src` folder and
    scaffolding all your pages. The page names will be `Home`, `Cars`, `Login`, `NewCar`,
    `NotFound`, and `SingleCar`, all with the `.jsx` extensions and you will perform
    the scaffolding of these other pages the same way as the `Home.jsx` page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The first component, located at `/src/pages/Home.jsx`, will look like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Although they are often referred to as pages when speaking about React Router,
    these pages are nothing more than regular React components. The distinction, and
    the fact that they are often grouped together in a directory called `pages`, is
    based purely on the fact that these components correspond to the pages structure
    of a SPA and are generally not meant to be reused elsewhere.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After scaffolding the desired pages, implement the router. This procedure consists
    of creating the router and inserting it into a top-level React component. You
    will use the `App.jsx` component, which loads and inserts the entire React application
    in the DOM.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since version 6.4, React Router has introduced the possibility of fetching data
    before the route (or page) that needs the said data is loaded, through simple
    functions called `createBrowserRouter` ([https://reactrouter.com/en/main/routers/create-browser-router](https://reactrouter.com/en/main/routers/create-browser-router))
    since it is *the recommended router for all React Router web projects*, as stated
    in the documentation.
  prefs: []
  type: TYPE_NORMAL
- en: After selecting `createBrowserRouter` as the desired method of creating the
    router, it is time to integrate it into your application.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating the router with the application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the following steps, you will integrate the router into your application,
    create a `Layout` component, and plug in the components (pages) that will be loaded
    on each defined URI:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To properly configure the router, you will need another component—the `Layout`
    component—in which the previously created pages will be rendered. Inside the `/src`
    folder, create a `/layouts` folder and create a `RootLayout.jsx` file inside it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The React router that you will be using and the one that supports data loading
    is based on three imports from the `react-router-dom` package: `createBrowserRouter`,
    `createRoutesFromElements`, and `Route`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open the `App.jsx` file and import the packages and the previously created
    pages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, continuing with the same `App.jsx` file, hook up the router created from
    the elements that you just imported and defined:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There are a few important things to note in the preceding code. After creating
    the router, you invoked the React Router function called `createRoutesFromElements`,
    which creates the actual routes. A route is used to define an individual path
    that corresponds and maps to a component; it can be a self-closing tag (such as
    the ones used for the pages) or it can enclose other routes—such as the home page
    path, which in turn corresponds to `RootLayout`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you start the React server again and visit the page `http://localhost:5173`,
    you will see only the text `RootLayout`. Try navigating to any of the routes defined
    in the router: `/cars`, `/cars/333`, or `/login`. You will see the same `RootLayout`
    text, but if you enter a path that is not defined, such as `/about`, React will
    inform you that the page doesn’t exist with a message similar to this: `Unexpected
    Application Error! 404` `Not Found`.'
  prefs: []
  type: TYPE_NORMAL
- en: This means that the router is indeed working; it is not set up to handle cases
    in which the user navigates to an undefined route and it does not display the
    contents of the pages. Now you will fix both problems.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the layout and the NotFound page
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to work properly, the router needs a place to display the content
    of pages— remember that “pages” are just React components. Now you will create
    `Layout.jsx` and also handle cases in which a user hits a URI that doesn’t exist,
    resulting in a `Page Not` `Found` error:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a new page in the `/src/pages` directory and name it `NotFound.jsx`,
    with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, create a catch-all route that will display the *Not Found* page in cases
    where the path doesn’t match any defined route. Remember that the order of routes
    is important—React Router will attempt to match routes sequentially, so it makes
    sense to use the `*` symbol to catch all previously undefined routes and associate
    them with the `NotFound` component.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the `App.jsx` file to display the `NotFound` route as the last route
    in the `RootLayout` route:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: All the other pages are nested. You will need to modify `RootLayout` (which
    will always be loaded, even for non-existing routes!) and provide the `Outlet`
    component for rendering page-specific components.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open `RootLayout.jsx` and modify it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the `Outlet` component now in place, you have achieved routing. If you
    try to navigate to the pages defined in the router, you should see the page update
    with the component content, in which the layout is displayed as before, but the
    `Outlet` component changes and displays the content of the page selected in the
    URL.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The whole point of using the router is to achieve navigation through “pages”
    without having to reload the page.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, to finalize the `RootLayout` component, you will update the component
    and add some links, using the provided `NavLink` component from React Router:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now you have a simple navigation in place and the `NotFound` page loads when
    needed. The router also provides navigation history, so the browser’s back and
    forward buttons are functional. The app styling is intentionally minimalistic
    and used only to underline the different components.
  prefs: []
  type: TYPE_NORMAL
- en: So far, you have only one layout, but there could potentially be more—one for
    the cars list page and the individual car pages—embedded into the main layout.
    Just like APIRouters from FastAPI, React routes and layouts can be nested. React
    Router’s nesting is a powerful feature that enables the construction of layered
    websites that load or update only the necessary components.
  prefs: []
  type: TYPE_NORMAL
- en: After having set up the React Router, let’s explore an important feature that
    is available only when using data routers, such as the one you used—data loaders—special
    functions that allow developers to access data in a more efficient way.
  prefs: []
  type: TYPE_NORMAL
- en: React Router loaders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Loaders are simply functions that can provide data to the route before it loads
    ([https://reactrouter.com/en/main/route/loader](https://reactrouter.com/en/main/route/loader))
    through a simple React hook.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to use some data, first create a new `.env` file and add the address
    of your Python backend:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If you restart the server now, Vite will be able to pick up the address in your
    code and the URI will be available at `import.meta.env.VITE_API_URL`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn more about how Vite handles environment variables, head over to their
    documentation: [https://vitejs.dev/guide/env-and-mode](https://vitejs.dev/guide/env-and-mode).'
  prefs: []
  type: TYPE_NORMAL
- en: Now you will learn how React Router manages data loading and prefetching. Perform
    the following steps to load data from your backend into the React application
    and learn how to use the powerful and simple `useLoader` Hook.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, work on the `/src/pages/Cars.jsx` component to see how data loaders
    can help you manage component data:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `src/components` folder and inside, create a simple static React component
    in the `CarCard.jsx` file for displaying a single car:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the `Card` component out of the way, you can now see how the data loader
    works.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Loaders are functions that provide data to the components in the router before
    they are rendered. These functions are usually defined and exported from the same
    component, although this is not mandatory.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open `Cars.jsx` and update it accordingly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The component imports `useLoaderData`—a custom hook provided by React Router
    whose sole purpose is to provide the data from the loader function to the component
    that needs it. This paradigm is at the heart of React Remix and similar to some
    Next.js functionalities, so it is useful to get acquainted with. The `useLoader`
    function will contain the data from the server, usually in JSON format.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, export the `carsLoader` function as well in the same file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: These two pieces—the component and the function—are not connected. This connection
    must happen in the router and allow preloading of data at the router level.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you will connect the component and the loader through the router. Open
    the `App.jsx` file and modify the code by providing the loader argument to the
    `/``cars` route:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the loader now in place, you are ready to test your `/cars` page, which
    should be displaying the cars saved in the collection so far.
  prefs: []
  type: TYPE_NORMAL
- en: The next few sections will explore the implementation of another piece of functionality
    that you will likely encounter in every React (or Next.js, or web development
    in general) project—handling forms with React with RHF. You will implement the
    login functionality with the help of the most popular third-party package for
    handling forms with React, and also perform data validation with the Zod package.
  prefs: []
  type: TYPE_NORMAL
- en: React Hook Form and Zod
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many ways of handling forms with React, and one of the most common
    patterns was shown in [*Chapter 5*](B22406_05.xhtml#_idTextAnchor090), *Setting
    Up a React Workflow*. State variables are created with the `useState` Hook, the
    form is prevented from submitting and is intercepted, and, finally, the data is
    passed through JSON or as form data. While this workflow is acceptable when working
    with simple data and a couple of fields, it can quickly become difficult to manage
    in cases where you have to keep track of dozens of fields, their constraints,
    and their possible states.
  prefs: []
  type: TYPE_NORMAL
- en: RHF is a mature project with a thriving community and is distinguished from
    other similar libraries by its speed, minimal amount of rendering, and deep integration
    with the most popular data validation libraries for TypeScript and JavaScript,
    such as Zod and Yup. In this case, you will learn the basics of Zod.
  prefs: []
  type: TYPE_NORMAL
- en: Performing data validation with Zod
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The JavaScript and TypeScript ecosystem currently has several validation libraries—with
    Zod and Yup arguably being the most popular ones. Zod is a TypeScript-first schema
    declaration and validation library that provides data validation of data structures.
    Zod provides a simple and intuitive object-based syntax for creating complex validation
    rules for objects and values in JavaScript applications and greatly facilitates
    the process of ensuring data integrity across the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic idea of these packages is to provide them with a prototype of the
    desired data structure and to perform a validation of the data against said defined
    data structure:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, install the package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Since the version number at the time of writing and used in the book’s repository
    is 7.51.5, use the preceding command if you want to reproduce the exact code from
    the repository.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the `Login.jsx` component and make it display `LoginForm`, which you
    will create shortly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, the `/src/components/LoginForm.jsx` file will contain all the form functionality
    as well as the data validation with Zod:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The component begins with the imports—the `useForm` hook and Zod, as well as
    the Zod resolver for integration with the form hook. Data validation in Zod is
    similar to how it is in Pydantic—you define an object and set the desired properties
    on various fields. In this case, we set that the username and password is between
    4 and 10 characters long, but Zod allows for some very complex validation, as
    you can see on their website ([https://zod.dev/](https://zod.dev/)).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `useForm` Hook provides several useful functions:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`register` is used to register single-form fields with the hook'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`handleSubmit` is the function that will be called upon submission'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`formState` contains different information about the form state ([https://react-hook-form.com/docs/useform/formstate](https://react-hook-form.com/docs/useform/formstate))'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, set up the `form` Hook:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this case, you will only track the errors (tied to the validation defined
    previously with Zod), but this object tracks much more. In your code, you’ll just
    output the data to the console once it is validated.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, build the form’s JSX and add some styling to see what’s happening:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <div className=”mb-4”>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <label htmlFor=”username” className=”block
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: text-gray-700 text-sm font-bold mb-2”>
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Username
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: </label>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <input id=”username” type=”text”
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: placeholder=”Username” required
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '{...register(‘username’)}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: className=”shadow appearance-none border
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: rounded w-full py-2 px-3 text-gray-700
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: leading-tight focus:outline-none
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: focus:shadow-outline”/>
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '{errors.username && <p className=”text-red-500'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: text-xs italic”>{errors.username.message}</p>}
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: </div>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The highlighted parts of the code are the registration of the fields with the
    `useForm` Hook—a way of letting the form know which fields to expect and the errors
    (if they are present) that are related to their respective fields.
  prefs: []
  type: TYPE_NORMAL
- en: This way, the fields are registered to the hook form through this spread operator
    syntax. Since the errors provided by the form are bound to the fields, take this
    opportunity and show them next to the fields that report errors for a more pleasing
    user experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rest of the component is intuitive and covers the `password` field and
    the `submit` button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The complete code from the book is available in the book repository.
  prefs: []
  type: TYPE_NORMAL
- en: The form is now ready and is handled completely by the hook form with a Zod
    validation. If you try to input data that doesn’t meet the validation criteria
    (username or password shorter than four characters, for instance) you will get
    an error message next to the fields. After setting up the form for logging in,
    you will create an authentication context that will allow the user to stay logged
    in. The authentication process—the creation of a React context and storing the
    JWT—will be very similar to the one covered in [*Chapter 6*](B22406_06.xhtml#_idTextAnchor105),
    *Authentication and Authorization*, so this next section only covers and highlights
    the important parts of the code.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication context and storing the JWT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, you will use your brand-new form, powered by RHF, and connect
    it to the Context API. The procedure for defining a React Context API was covered
    in detail in [*Chapter 4*](B22406_04.xhtml#_idTextAnchor071), *Getting Started
    with FastAPI* and in this chapter, you will apply that knowledge and create a
    similar context for keeping track of the authentication state of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new folder in the `/src` directory and name it `contexts`. Inside
    this folder, create a new file called `AuthContext.jsx` and create the provider:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The context that you are creating is rather simple and contains a couple of
    state variables and setters that will be needed for the authentication flow: the
    username (whose presence or absence thereof will indicate whether the user is
    authenticated), the JWT, and a helper message that, in this case, is only useful
    for debugging and illustration.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The initial values are set to `null` and a generic message through the `useState`
    hook—the username is set to `null`, the JWT to an empty string, and the message
    to `Please log in`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, add a `useEffect` hook that will fire once the context is loaded or when
    the page is reloaded:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The first part of the `useEffect` hook checks whether there is a JWT present
    in the local storage. If it is present, the `useEffect` hook performs an API call
    to the FastAPI server to determine whether the JWT is able to return a valid user:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the token is invalid or it has been tampered with or has expired, the `useEffect`
    hook removes it from local storage, sets the context state variables to `null`,
    and sets an appropriate message to the users:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To sum it up, the `useEffect` hook performs a cycle. First, it checks for the
    local storage and if it doesn’t find a JWT, it deletes the JWT from the context,
    sets the username to `null`, and prompts the user to log in. The same result is
    obtained if the API call to the `/me` route, with the existing JWT, does not yield
    a valid username. This means that the token is present, but invalid or expired.
    If the JWT is indeed present and it can be used in order to obtain a valid username,
    the username is then set and the JWT is stored in the *Context*. Since the dependency
    array is empty, this hook will run only once on the first render.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the login functionality
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The login function will reside again inside the context for simplicity, although
    it could be in a separate file. Following is the login flow:'
  prefs: []
  type: TYPE_NORMAL
- en: The user provides their username and password.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A fetch call to the backend is performed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the response has an HTTP status of `200` and the JWT is returned, `localStorage`
    is set, as well as the context, and the user is authenticated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the response doesn’t return an HTTP status of `200`, it means that the login
    information was not accepted and, in that case, both the JWT and the username
    values are set to `null` in the context and effectively invalidated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To implement the login functionality, perform these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the `login` function needs to call the login API route with the provided
    username and password. Paste the following code into the end of the `AuthContext.jsx`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, depending on the response, the function will set the state variables
    in the context accordingly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The logic is similar to the one applied in the `useEffect` hook—if a valid user
    is found, the context state variables (username and JWT) are set; otherwise, they
    are set to `null`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The final part is just the `logout` function and the returning of the context
    provider. The following `logout` function is defined inside `AuthProvider`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At this point you have accomplished quite a lot: you have set up the context,
    defined the login and logout functions, and created the context provider. Now,
    to facilitate the use of the context, you will create a simple custom React hook,
    based on the `useContext` built-in hook.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom hook for accessing the context
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With the Context API set up, you can now proceed and create a `useAuth.jsx`
    file inside a new folder, `/src/hooks`, which will allow easy access to the context
    from various places:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `useAuth.jsx` file inside the new folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `useAuth` hook contains an error message in case the hook is accessed outside
    of the context—but your context will enclose the entire application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The final step in using a React context is to wrap the components that will
    need to access it; in your case, this will be `App.jsx`—the root component.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open the `App.jsx` file and wrap the only component that it is currently returning—
    `RouterProvider`—inside `AuthProvider`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, display the context data and the state variables inside the `RootLayout`
    component that currently hosts all of your pages. This is a useful debugging technique
    while working with React Context API; you do not need to switch to and from the
    developer tools constantly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open `RootLayout.jsx` and edit the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: const RootLayout = () => {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: const {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: user,
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: message,
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: logout
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '} = useAuth()'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return (
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <div className=” bg-blue-200 min-h-screen p-2”>
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <h2>RootLayout</h2>
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <p className=”text-red-500 p-2 border”>
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '{message}'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: </p>
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '<p>Username: {user}</p>'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <header className=”p-3 w-full”>
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <nav className=”flex flex-row justify-between
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: mx-auto”>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <div className=”flex flex-row space-x-3”>
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <NavLink to=”/”>Home</NavLink>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <NavLink to=”/cars”>Cars</NavLink>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '{user ? <>'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <NavLink to=”/new-car”>New Car</NavLink>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <button onClick={logout}>Logout</button>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '</> : <>'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <NavLink to=”/login”>Login</NavLink>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: </>}
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: </div>
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: </nav>
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: </header>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <main className=”p-8 flex flex-col flex-1
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: bg-white “>
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <Outlet />
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: </main>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: </div>
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: export default RootLayout
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The application is rather simple, but it showcases the login/logout process
    well. As an exercise, you could easily implement the registration page—the API
    endpoint already exists and you should create the logic for handling the register
    form.
  prefs: []
  type: TYPE_NORMAL
- en: The following section will focus on completing some more functionality—the route
    for inserting new cars is still reachable for users who are not logged in and
    the form doesn’t exist yet. Now you will secure the resource creation endpoint
    and create protected pages with React Router.
  prefs: []
  type: TYPE_NORMAL
- en: Protecting routes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Protected routes are routes and pages that are not accessible to everyone—they
    usually require the user to be logged in or to have certain privileges (admin
    or creator). There are many ways of protecting routes in React Router. One popular
    pattern is through high-order components—they are wrapper components that wrap
    routes that require a logged-in user. The new React Router and its `Outlet` component
    allow you to easily implement gate logic and redirect the user if they need to
    be authorized.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a basic component that checks for the presence of a user (through the
    username). If the user is present, the component will use an `Outlet` component
    to let the wrapped routes make their way to the browser; otherwise, a redirect
    to the login page will ensue:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new component in the `/src/components` folder and name it `AuthRequired.jsx`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The logic is simple; the component ensures you perform the JWT presence check.
    It then acts like a semaphore or a simple IF construct that checks for a condition—if
    a JWT is present, the `Outlet` component will show the enclosed components (in
    our case only one: the `NewCar` page), and if not, React Router’s `Navigate` component
    is used for programmatic navigation to the home page.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This simple solution will not force the authenticated user to be redirected
    to the home page if they reload a protected page, since the `useEffect` hook in
    `Layout.jsx` will detect whether the JWT is invalid only after the component loads.
    If the JWT is indeed invalid, the `useEffect` hook will invalidate the JWT, thus
    triggering the redirect.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, update the `App.jsx` component, import the `AuthRequired` component, and
    enclose the `NewCar` page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You have learned how to protect routes that need authentication. Now, you will
    build another form to insert data about new cars and upload images (one image
    per car, to be precise) to Cloudinary through FastAPI.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the page for inserting new cars
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The page for inserting new cars into the collection—the `NewCar.jsx` component—is
    protected and can be accessed only by authenticated users. In this section, you
    will build a more complex form and gradually modularize the code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, update the `NewCar.jsx` page and add a `CarForm` component, which you
    will build shortly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, create this component in the `/src/components` folder. In this folder,
    create a new file and name it `CarForm.jsx`. Before starting to code the form,
    quickly review what type of data the form needs to collect and send to the API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Brand**: A string'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Make**: A string'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Year**: An integer'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Price**: An integer'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Km**: An integer'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cm3**: An integer'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Picture**: A file object'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It would be rather tedious and repetitive to create each field in the form as
    an individual input and just copy and paste everything across the file. Instead,
    you can abstract the input field and make it a reusable component. This component
    will need to accept some props, such as a name and type (number or string), and
    RHF can register it and associate an error, if any, to said field. So, before
    starting the form, create another component that will be reused as many times
    as needed and that will significantly facilitate the process of creating and updating
    the form should you need to add even more fields later—in a real-life scenario,
    cars can have hundreds of fields.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a new file in the `/src/components` folder and name it `InputField.jsx`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The field component is simple, yet useful—it abstracts all the functionality
    and even adds some styling.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, go back to the `CarForm` file and start with the imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You are going to use Zod again for data validation, so add a schema—it should
    ideally match the Pydantic validation rules on the backend for consistency:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The Zod schema syntax is rather intuitive, though there might be some aspects
    that need caution—numbers need to be coerced, as HTML forms send strings by default,
    and files can be validated through handy functions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, start the actual form component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `useNavigate` hook is used to navigate away from the page once the submission
    is complete, while `useForm` is similar to the one used for logging users in.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a simple JavaScript array containing the data about the fields that
    are needed for the form:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With this array, the form code becomes much more manageable. Look at the `onSubmit`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Suddenly, the `onSubmit` function is much more succinct—it loops over the array
    and adds the fields to the `formData` object. Keep in mind that the `file` field
    is special—it is an array and you want only the first element, that is, the picture.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To complete the `onSubmit` function, you need to make the `POST` request to
    the API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The fetch call is simple. After you get the result back, you can apply custom
    logic. In this case, you JSONify—render the error object as a JSON string and
    set the message to show it—if the error is coming from the server.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, the JSX is trivial, thanks to your `InputField` component and `formArray`,
    while you also use the submitting value from the `useForm` hook:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The submit button is now reused as a submission indicator—it displays a different
    message while submitting and is also disabled to prevent multiple requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Building a page to update cars would be very similar to the previous endpoint—RHF
    plays extremely well with initial or default data that can be populated from an
    existing object, and you can also play with the online form builder: [https://react-hook-form.com/form-builder](https://react-hook-form.com/form-builder).
    Deleting cars is also relatively simple as the request needs only to be authenticated
    and contains the car ID.'
  prefs: []
  type: TYPE_NORMAL
- en: You have now built a car creation page, which can be extended in numerous ways.
    You have learned how to modularize your React code and how to provide meaningful
    messages and logic to your application, depending on the data flow to and from
    the server. Now you will build a page for displaying single cars and use loaders
    again.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying single cars
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that you have created the pages for displaying multiple items (cars), authenticating,
    and creating new items, create an individual car page and see how React Router
    deals with parameters in the URL:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `SingleCar.jsx` file and introduce the `useLoaderData` hook, already
    used for preloading data on the cars page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To save space, we reused the `CarCard` function to display data about the car.
    However, in a realistic scenario, this page would contain possibly an image gallery,
    much more data, maybe some comments or notes, and so on. The goal here, however,
    is just to show another way of creating the loader function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open the `App.jsx` file that currently hosts the router and update the `cars/:id`
    route, bearing in mind that the colon denotes a parameter, in this case, the string
    version of the `ObjectId` component of the car in the MongoDB collection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'There are just two changes in the route: the `loader` function, which is supplied
    as a part of an async function that takes in the parameter ID, and `errorElement`.
    The `NotFound` component will be displayed, in case the `loader` function encounters
    an error while fetching the data. Here, again, you reuse an existing element,
    but it could be customized.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The final piece of the puzzle is the `fetchCarData.js` file, which is located
    in the `/src/utils` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `async` function just performs a single API call to retrieve the data related
    to an individual entity and, in case of an error, `errorElement` will be triggered.
  prefs: []
  type: TYPE_NORMAL
- en: Loader functions are extremely handy. By preloading data, they enable the user
    to have a much better user experience and the application feels faster.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you created a React application using a modern Vite setup and
    implemented the basic functionality—creating new resources and, listing and displaying
    cars. This chapter also served as a refresher for you on the basic React hooks,
    such as `useState` and `useEffect`, and the Context API. You also learned the
    basics of React Router with its powerful loader functions. In this chapter, you
    created two forms using RHF and learned how to manage various steps and states
    involved with the use of your API.
  prefs: []
  type: TYPE_NORMAL
- en: The following chapter will explore Next.js version 14—the most powerful and
    feature-rich React.js-based full-stack framework.
  prefs: []
  type: TYPE_NORMAL
