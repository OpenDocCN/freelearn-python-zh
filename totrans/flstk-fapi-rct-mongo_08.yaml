- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Building the Frontend of the Application
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建应用程序的前端
- en: In the previous chapter, you explored how to build your FastAPI backend and
    connect to MongoDB. This will be used by a React frontend that you will be building
    in this chapter. The application will be simple and feature-rich and, most importantly,
    will allow you to see the parts of the stack working together.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，您探讨了如何构建您的FastAPI后端并连接到MongoDB。这将用于本章中您将构建的React前端。该应用程序将简单且功能丰富，最重要的是，它将允许您看到堆栈的各个部分协同工作。
- en: In this chapter, you will build the frontend of a full-stack FARM application.
    You will learn how to set up a React Vite application and install and set up React
    Router, as well as various ways of loading content. The application will enable
    authenticated users to insert new items (cars), while there will be several pages
    for displaying cars.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将构建一个全栈FARM应用程序的前端。您将学习如何设置React Vite应用程序并安装和设置React Router，以及加载内容的各种方法。该应用程序将允许认证用户插入新项目（汽车），同时将有多页用于显示汽车。
- en: You will develop a website that will list used cars for sale and allow only
    logged-in users to post new car ads. You will begin by creating a React application
    with Vite, then you will lay out the page structure with React Router and gradually
    introduce features such as authentication, protected pages, and data loading.
    After this chapter, you will be able to comfortably leverage React Router for
    your **single-page-applications** (**SPAs**) and use the powerful **React Hook
    Form** (**RHF**) for granular form control.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 您将开发一个网站，该网站将列出待售的二手车，并且只允许登录用户发布新的汽车广告。您将首先使用Vite创建一个React应用程序，然后使用React Router布局页面结构，并逐步引入认证、受保护页面和数据加载等功能。在本章之后，您将能够轻松地利用React
    Router为您的**单页应用程序**（**SPAs**）提供支持，并使用强大的**React Hook Form**（**RHF**）进行细粒度表单控制。
- en: 'This chapter will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Creating a new React application using Vite
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Vite创建新的React应用程序
- en: Setting up the React Router for SPA page navigation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置React Router以进行SPA页面导航
- en: Managing data with data loaders
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数据加载器管理数据
- en: Introduction to RHF and Zod for data validation
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RHF和Zod的数据验证简介
- en: Authentication and authorization with the Context API
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Context API进行认证和授权
- en: Protecting routes and displaying data with React Router pages
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用React Router页面保护路由和显示数据
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The technical requirements for this chapter are similar to the ones listed
    in [*Chapter 4*](B22406_04.xhtml#_idTextAnchor071)*, Getting Started with FastAPI*.
    You will need the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的技术要求与[*第4章*](B22406_04.xhtml#_idTextAnchor071)*，*使用FastAPI入门*中列出的类似。您需要以下内容：
- en: Node version 18.14
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node版本18.14
- en: A good code editor, such as Visual Studio Code
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个好的代码编辑器，例如Visual Studio Code
- en: The Node package manager
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点包管理器
- en: Creating a Vite React application
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Vite React应用程序
- en: In this section you will scaffold a Vite React application and set up Tailwind
    CSS for styling. This procedure has already been covered in [*Chapter 5*](B22406_05.xhtml#_idTextAnchor090),
    *Setting Up a React workflow,*, so you can refer to it. Make sure to complete
    the brief tutorial in [*Chapter 5*](B22406_05.xhtml#_idTextAnchor090), as the
    following guide is heavily based on the concepts presented therein.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将构建Vite React应用程序并设置Tailwind CSS进行样式化。此过程已在[*第5章*](B22406_05.xhtml#_idTextAnchor090)，*设置React工作流程*中介绍，您可以参考它。请确保完成[*第5章*](B22406_05.xhtml#_idTextAnchor090)中的简要教程，因为以下指南在很大程度上基于其中介绍的概念。
- en: 'You are going to use the `create vite` command with the Node package manager
    to create your project through the following steps:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您将使用`create vite`命令与Node包管理器通过以下步骤创建您的项目：
- en: 'Open your terminal client in a project directory containing the previously
    created backend folder, and issue the following command for creating a Vite React
    project:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在包含先前创建的后端文件夹的项目目录中打开您的终端客户端，并执行以下命令以创建Vite React项目：
- en: '[PRE0]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, change the directory to the newly created `frontend-app` folder and install
    the dependencies and Tailwind:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将目录更改为新创建的`frontend-app`文件夹，并安装依赖项和Tailwind：
- en: '[PRE1]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Initialize the Tailwind configuration—the following command creates a blank
    Tailwind configuration file:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化Tailwind配置——以下命令创建一个空的Tailwind配置文件：
- en: '[PRE2]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Finally, configure the generated `tailwind.config.js` and React’s `index.css`
    files according to the latest documentation at [https://tailwindcss.com/docs/guides/vite](https://tailwindcss.com/docs/guides/vite).
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，根据最新的文档配置生成的 `tailwind.config.js` 和 React 的 `index.css` 文件，文档地址为 [https://tailwindcss.com/docs/guides/vite](https://tailwindcss.com/docs/guides/vite)。
- en: 'Your index.css should now include only the Tailwind imports:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 `index.css` 应现在只包含 Tailwind 的导入：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To test that Tailwind has been properly configured, change the `App.jsx` file
    and start the development server:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试 Tailwind 是否已正确配置，修改 `App.jsx` 文件并启动开发服务器：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When you refresh your app, you should see a white page with the text **Cars
    FARM**.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当您刷新应用程序时，您应该看到一个带有文本 **Cars FARM** 的白色页面。
- en: After setting up a functional React application and Tailwind, it is time to
    introduce probably the most important third-party React package—React Router.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好一个功能性的 React 应用程序和 Tailwind 之后，是时候介绍可能最重要的第三方 React 包——React Router。
- en: React Router
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: React Router
- en: Up to this point, all of your components have fit onto a single page because
    you were building SPAs. To enable your application to display completely different
    pages based on the provided route, you will use a package called React Router—the
    de facto standard when it comes to page routing in React.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，由于您正在构建单页应用（SPA），所有组件都适合在单个页面上。为了使您的应用程序能够根据提供的路由显示完全不同的页面，您将使用一个名为 React
    Router 的包——在 React 中进行页面路由的事实标准。
- en: While there are some very good and robust alternatives, such as TanStack Router
    ([https://tanstack.com/router/](https://tanstack.com/router/)), React Router is
    widely adopted, and getting to know its basic mechanisms will greatly benefit
    you, as a developer, as you are bound to run into code based on it.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有一些非常好且健壮的替代方案，例如 TanStack Router ([https://tanstack.com/router/](https://tanstack.com/router/))，但
    React Router 被广泛采用，了解其基本机制将极大地帮助您，作为一名开发者，因为您很可能会遇到基于它的代码。
- en: Version 6.4 of React Router has some major changes while retaining previous
    basic principles, which you will use to build your frontend. However, as of May
    2024, even more drastic changes have been announced—**React Remix**, an entire
    full-stack framework (with functionalities comparable to Next.js), which is based
    on React Router, and React Router itself should be merged into a single project.
    In this section, you will learn about the most important components that will
    allow you to create a single-page experience without page reloading or having
    knowledge of React Router 6.4, which will be very useful later, as it is the most
    widely adopted React routing solution.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: React Router 的第 6.4 版本有一些重大变化，同时保留了之前的基本原则，您将使用这些原则来构建您的前端。然而，截至 2024 年 5 月，还宣布了更多激进的变化——**React
    Remix**，这是一个完整的全栈框架（具有与 Next.js 相当的功能），它基于 React Router，而 React Router 本身应该合并到一个单一的项目中。在本节中，您将了解最重要的组件，这些组件将允许您创建单页体验，无需页面重新加载或了解
    React Router 6.4，这在以后将非常有用，因为它是最广泛采用的 React 路由解决方案。
- en: The basic underlying principle of React Router is to listen to URL path changes
    (such as `/about` or `/login`) and conditionally display components in a layout.
    The displayed components can be thought of as “pages,” while the layout keeps
    some parts of the pages that should always be displayed—such as a footer and navigation.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: React Router 的基本底层原理是监听 URL 路径变化（如 `/about` 或 `/login`），并根据条件在布局中显示组件。显示的组件可以被视为“页面”，而布局则保留了一些始终应显示的页面部分——例如页脚和导航。
- en: 'Before looking at React Router, review the pages that you will have in your
    application:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看 React Router 之前，请回顾一下您应用程序中的页面：
- en: '`/`) path'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/`) 路径'
- en: '`/cars`)'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/cars`)'
- en: '`/cars/car_id`)'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/cars/car_id`)'
- en: '`/login`)'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/login`)'
- en: '**An “insert new car” page**: This will provide a form for the authenticated
    user only'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**“插入新车辆”页面**：这将只为认证用户提供表单'
- en: For simplicity, you will not include a registration route (since there will
    only be a couple of authenticated employees) and there will not be a deleting
    or updating functionality on the frontend. In the following section, you will
    install and configure React Router and make it the basis of your application.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，您将不包括注册路由（因为只有几个认证员工），前端也不会有删除或更新功能。在下一节中，您将安装和配置 React Router，并将其作为您应用程序的基础。
- en: Installing and setting up React Router
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装和设置 React Router
- en: React Router is just a Node.js package, so the installation process is easy.
    The setting up of the router inside the application, however, includes lots of
    features and different options. You will be using the most powerful and recommended
    data router, which provides data loading and is the suggested option by the React
    Router team.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: React Router 只是一个 Node.js 包，因此安装过程很简单。然而，在应用程序内部设置路由器包括许多功能和不同选项。你将使用最强大且推荐的带数据路由器，它提供数据加载，并且是
    React Router 团队建议的选项。
- en: 'Working with the router generally involves two steps:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 使用路由器通常涉及两个步骤：
- en: Using one of the provided methods for generating the desired routes ([https://reactrouter.com/en/main/routers/picking-a-router](https://reactrouter.com/en/main/routers/picking-a-router)).
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用提供的生成所需路线的方法之一（[https://reactrouter.com/en/main/routers/picking-a-router](https://reactrouter.com/en/main/routers/picking-a-router)）。
- en: Creating components, often called `Login.jsx` and `Home.jsx`. Additionally,
    you will almost always create one or more layouts that will contain common components
    such as the navigation or the footer.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建组件，通常被称为 `Login.jsx` 和 `Home.jsx`。此外，你几乎总是会创建一个或多个布局，这些布局将包含如导航或页脚等常见组件。
- en: 'Now, you will perform the steps necessary to install React Router into your
    application:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将执行安装 React Router 到你的应用程序中所需的步骤：
- en: 'The first step, as with any third-party package, is to install the `router`
    package:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步，与任何第三方包一样，是安装 `router` 包：
- en: '[PRE5]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The version number corresponds to the latest version at the time of writing,
    so you can reproduce the exact functionality.
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 版本号对应于写作时的最新版本，因此你可以重现确切的功能。
- en: In this chapter, the CSS styling of the application will intentionally be kept
    to a bare minimum—just enough to distinguish between components.
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在本章中，应用程序的 CSS 样式将被有意保持到最小——仅足以区分组件。
- en: Start by creating a new directory called `/pages` inside the `/src` folder and
    scaffolding all your pages. The page names will be `Home`, `Cars`, `Login`, `NewCar`,
    `NotFound`, and `SingleCar`, all with the `.jsx` extensions and you will perform
    the scaffolding of these other pages the same way as the `Home.jsx` page.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在 `/src` 文件夹内创建一个名为 `/pages` 的新目录，并搭建所有你的页面。页面名称将是 `Home`、`Cars`、`Login`、`NewCar`、`NotFound`
    和 `SingleCar`，所有这些都有 `.jsx` 扩展名，你将以与 `Home.jsx` 页面相同的方式搭建这些其他页面。
- en: 'The first component, located at `/src/pages/Home.jsx`, will look like this:'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 位于 `/src/pages/Home.jsx` 的第一个组件将看起来像这样：
- en: '[PRE6]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Although they are often referred to as pages when speaking about React Router,
    these pages are nothing more than regular React components. The distinction, and
    the fact that they are often grouped together in a directory called `pages`, is
    based purely on the fact that these components correspond to the pages structure
    of a SPA and are generally not meant to be reused elsewhere.
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 虽然在讨论 React Router 时，它们通常被称为页面，但这些页面实际上不过是普通的 React 组件。这种区别，以及它们通常被组织在名为 `pages`
    的目录中，纯粹是基于这些组件对应于单页应用（SPA）的页面结构，并且通常不打算在其他地方重用。
- en: After scaffolding the desired pages, implement the router. This procedure consists
    of creating the router and inserting it into a top-level React component. You
    will use the `App.jsx` component, which loads and inserts the entire React application
    in the DOM.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在搭建好所需的页面后，实现路由器。此过程包括创建路由器并将其插入到顶级 React 组件中。你将使用 `App.jsx` 组件，该组件加载并插入整个 React
    应用程序到 DOM 中。
- en: Since version 6.4, React Router has introduced the possibility of fetching data
    before the route (or page) that needs the said data is loaded, through simple
    functions called `createBrowserRouter` ([https://reactrouter.com/en/main/routers/create-browser-router](https://reactrouter.com/en/main/routers/create-browser-router))
    since it is *the recommended router for all React Router web projects*, as stated
    in the documentation.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 自从 6.4 版本以来，React Router 引入了在需要数据的路由（或页面）加载之前获取数据的功能，通过简单的函数 `createBrowserRouter`
    实现（[https://reactrouter.com/en/main/routers/create-browser-router](https://reactrouter.com/en/main/routers/create-browser-router)），因为它如文档所述，是所有
    React Router 网络项目的推荐路由器。
- en: After selecting `createBrowserRouter` as the desired method of creating the
    router, it is time to integrate it into your application.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择 `createBrowserRouter` 作为创建路由器的所需方法后，是时候将其集成到你的应用程序中了。
- en: Integrating the router with the application
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将路由器与应用程序集成
- en: 'In the following steps, you will integrate the router into your application,
    create a `Layout` component, and plug in the components (pages) that will be loaded
    on each defined URI:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下步骤中，你将集成路由器到你的应用程序中，创建一个 `Layout` 组件，并将组件（页面）连接到每个定义的 URI：
- en: 'To properly configure the router, you will need another component—the `Layout`
    component—in which the previously created pages will be rendered. Inside the `/src`
    folder, create a `/layouts` folder and create a `RootLayout.jsx` file inside it:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了正确配置路由器，你需要另一个组件——`Layout` 组件，在其中将渲染之前创建的页面。在 `/src` 文件夹内，创建一个 `/layouts`
    文件夹，并在其中创建一个 `RootLayout.jsx` 文件：
- en: '[PRE7]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The React router that you will be using and the one that supports data loading
    is based on three imports from the `react-router-dom` package: `createBrowserRouter`,
    `createRoutesFromElements`, and `Route`.'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你将要使用的 React 路由器以及支持数据加载的路由器基于 `react-router-dom` 包中的三个导入：`createBrowserRouter`、`createRoutesFromElements`
    和 `Route`。
- en: 'Open the `App.jsx` file and import the packages and the previously created
    pages:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `App.jsx` 文件并导入包和之前创建的页面：
- en: '[PRE8]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, continuing with the same `App.jsx` file, hook up the router created from
    the elements that you just imported and defined:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，继续使用相同的 `App.jsx` 文件，将你刚刚导入并定义的元素创建的路由连接起来：
- en: '[PRE9]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: There are a few important things to note in the preceding code. After creating
    the router, you invoked the React Router function called `createRoutesFromElements`,
    which creates the actual routes. A route is used to define an individual path
    that corresponds and maps to a component; it can be a self-closing tag (such as
    the ones used for the pages) or it can enclose other routes—such as the home page
    path, which in turn corresponds to `RootLayout`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，有几个重要的事项需要注意。在创建路由器后，你调用了名为 `createRoutesFromElements` 的 React Router
    函数，该函数创建了实际的路线。路由用于定义与组件对应和映射的单独路径；它可以是一个自闭合标签（如用于页面的那些），或者它可以包含其他路由——例如主页路径，它反过来对应于
    `RootLayout`。
- en: 'If you start the React server again and visit the page `http://localhost:5173`,
    you will see only the text `RootLayout`. Try navigating to any of the routes defined
    in the router: `/cars`, `/cars/333`, or `/login`. You will see the same `RootLayout`
    text, but if you enter a path that is not defined, such as `/about`, React will
    inform you that the page doesn’t exist with a message similar to this: `Unexpected
    Application Error! 404` `Not Found`.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你再次启动 React 服务器并访问页面 `http://localhost:5173`，你将只会看到文本 `RootLayout`。尝试导航到路由器中定义的任何路由：`/cars`、`/cars/333`
    或 `/login`。你将看到相同的 `RootLayout` 文本，但如果你输入一个未定义的路径，例如 `/about`，React 将会显示一个类似于以下的消息来告知页面不存在：`意外应用程序错误！404
    找不到`。
- en: This means that the router is indeed working; it is not set up to handle cases
    in which the user navigates to an undefined route and it does not display the
    contents of the pages. Now you will fix both problems.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着路由器确实在运行；它没有设置为处理用户导航到未定义路由的情况，并且不会显示页面内容。现在你将修复这两个问题。
- en: Creating the layout and the NotFound page
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建布局和未找到页面
- en: 'In order to work properly, the router needs a place to display the content
    of pages— remember that “pages” are just React components. Now you will create
    `Layout.jsx` and also handle cases in which a user hits a URI that doesn’t exist,
    resulting in a `Page Not` `Found` error:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正常工作，路由器需要一个地方来显示页面内容——记住，“页面”只是 React 组件。现在你将创建 `Layout.jsx` 并处理用户访问不存在的
    URI 导致的 `页面未找到` 错误的情况：
- en: 'First, create a new page in the `/src/pages` directory and name it `NotFound.jsx`,
    with the following content:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在 `/src/pages` 目录下创建一个新页面，命名为 `NotFound.jsx`，内容如下：
- en: '[PRE10]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, create a catch-all route that will display the *Not Found* page in cases
    where the path doesn’t match any defined route. Remember that the order of routes
    is important—React Router will attempt to match routes sequentially, so it makes
    sense to use the `*` symbol to catch all previously undefined routes and associate
    them with the `NotFound` component.
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，创建一个通配符路由，当路径不匹配任何定义的路由时，将显示 `Not Found` 页面。记住路由的顺序很重要——React Router 将按顺序尝试匹配路由，因此使用
    `*` 符号来捕获所有之前未定义的路由并将它们与 `NotFound` 组件关联是有意义的。
- en: 'Update the `App.jsx` file to display the `NotFound` route as the last route
    in the `RootLayout` route:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `App.jsx` 文件，将 `NotFound` 路由作为 `RootLayout` 路由中的最后一个路由显示：
- en: '[PRE11]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: All the other pages are nested. You will need to modify `RootLayout` (which
    will always be loaded, even for non-existing routes!) and provide the `Outlet`
    component for rendering page-specific components.
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 所有其他页面都是嵌套的。你需要修改 `RootLayout`（即使对于非现有路由也会始终加载！）并为渲染特定页面组件提供 `Outlet` 组件。
- en: 'Open `RootLayout.jsx` and modify it:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `RootLayout.jsx` 并进行修改：
- en: '[PRE12]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: With the `Outlet` component now in place, you have achieved routing. If you
    try to navigate to the pages defined in the router, you should see the page update
    with the component content, in which the layout is displayed as before, but the
    `Outlet` component changes and displays the content of the page selected in the
    URL.
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在已经有了 `Outlet` 组件，你已经实现了路由。如果你尝试导航到路由器中定义的页面，你应该会看到页面更新，其中布局如之前所示，但 `Outlet`
    组件会改变并显示 URL 中选择的页面内容。
- en: The whole point of using the router is to achieve navigation through “pages”
    without having to reload the page.
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用路由器的整个目的是通过“页面”进行导航，而无需重新加载页面。
- en: 'Now, to finalize the `RootLayout` component, you will update the component
    and add some links, using the provided `NavLink` component from React Router:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为了最终完成 `RootLayout` 组件，你将更新组件并添加一些链接，使用提供的 React Router 的 `NavLink` 组件：
- en: '[PRE13]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now you have a simple navigation in place and the `NotFound` page loads when
    needed. The router also provides navigation history, so the browser’s back and
    forward buttons are functional. The app styling is intentionally minimalistic
    and used only to underline the different components.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经实现了简单的导航，并且当需要时 `NotFound` 页面会加载。路由器还提供了导航历史，因此浏览器的后退和前进按钮是可用的。应用样式故意简约，仅用于强调不同的组件。
- en: So far, you have only one layout, but there could potentially be more—one for
    the cars list page and the individual car pages—embedded into the main layout.
    Just like APIRouters from FastAPI, React routes and layouts can be nested. React
    Router’s nesting is a powerful feature that enables the construction of layered
    websites that load or update only the necessary components.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你只有一个布局，但可能还有更多——一个是汽车列表页面和单个汽车页面——嵌入到主布局中。就像 FastAPI 中的 APIRouters 一样，React
    路由和布局可以嵌套。React Router 的嵌套是一个强大的功能，它能够构建只加载或更新必要组件的分层网站。
- en: After having set up the React Router, let’s explore an important feature that
    is available only when using data routers, such as the one you used—data loaders—special
    functions that allow developers to access data in a more efficient way.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好 React Router 之后，让我们探索一个仅在使用数据路由时才可用的重要功能，例如你使用的——数据加载器——允许开发者以更有效的方式访问数据的特殊函数。
- en: React Router loaders
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: React Router 加载器
- en: Loaders are simply functions that can provide data to the route before it loads
    ([https://reactrouter.com/en/main/route/loader](https://reactrouter.com/en/main/route/loader))
    through a simple React hook.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 加载器是简单的函数，可以在路由加载之前提供数据（[https://reactrouter.com/en/main/route/loader](https://reactrouter.com/en/main/route/loader)）通过一个简单的
    React 钩子。
- en: 'In order to use some data, first create a new `.env` file and add the address
    of your Python backend:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用一些数据，首先创建一个新的 `.env` 文件，并添加你 Python 后端的地址：
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If you restart the server now, Vite will be able to pick up the address in your
    code and the URI will be available at `import.meta.env.VITE_API_URL`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在重启服务器，Vite 将能够获取你代码中的地址，URI 将在 `import.meta.env.VITE_API_URL` 中可用。
- en: Note
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'To learn more about how Vite handles environment variables, head over to their
    documentation: [https://vitejs.dev/guide/env-and-mode](https://vitejs.dev/guide/env-and-mode).'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于 Vite 如何处理环境变量的信息，请查看他们的文档：[https://vitejs.dev/guide/env-and-mode](https://vitejs.dev/guide/env-and-mode)。
- en: Now you will learn how React Router manages data loading and prefetching. Perform
    the following steps to load data from your backend into the React application
    and learn how to use the powerful and simple `useLoader` Hook.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将学习 React Router 如何管理数据加载和预取。执行以下步骤，将后端数据加载到 React 应用程序中，并学习如何使用强大且简单的 `useLoader`
    钩子。
- en: 'First, work on the `/src/pages/Cars.jsx` component to see how data loaders
    can help you manage component data:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，处理 `/src/pages/Cars.jsx` 组件，看看数据加载器如何帮助你管理组件数据：
- en: 'Create a `src/components` folder and inside, create a simple static React component
    in the `CarCard.jsx` file for displaying a single car:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `src/components` 文件夹，并在其中创建一个简单的静态 React 组件，名为 `CarCard.jsx`，用于显示单个汽车：
- en: '[PRE15]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: With the `Card` component out of the way, you can now see how the data loader
    works.
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在处理完 `Card` 组件后，你现在可以查看数据加载器是如何工作的。
- en: Loaders are functions that provide data to the components in the router before
    they are rendered. These functions are usually defined and exported from the same
    component, although this is not mandatory.
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 加载器是函数，在组件渲染之前向路由器中的组件提供数据。这些函数通常由同一组件定义和导出，尽管这不是强制性的。
- en: 'Open `Cars.jsx` and update it accordingly:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Cars.jsx` 并相应地更新它：
- en: '[PRE16]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The component imports `useLoaderData`—a custom hook provided by React Router
    whose sole purpose is to provide the data from the loader function to the component
    that needs it. This paradigm is at the heart of React Remix and similar to some
    Next.js functionalities, so it is useful to get acquainted with. The `useLoader`
    function will contain the data from the server, usually in JSON format.
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 组件导入 `useLoaderData`——这是 React Router 提供的一个自定义钩子，其唯一目的是将加载函数的数据提供给需要它的组件。这种范式是
    React Remix 的核心，类似于一些 Next.js 功能，因此了解它是有用的。`useLoader` 函数将包含来自服务器的数据，通常以 JSON
    格式。
- en: 'Now, export the `carsLoader` function as well in the same file:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在同一文件中也将 `carsLoader` 函数导出：
- en: '[PRE17]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: These two pieces—the component and the function—are not connected. This connection
    must happen in the router and allow preloading of data at the router level.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个部分——组件和函数——尚未连接。这种连接必须在路由器中发生，并允许在路由器级别预加载数据。
- en: 'Now you will connect the component and the loader through the router. Open
    the `App.jsx` file and modify the code by providing the loader argument to the
    `/``cars` route:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你将通过路由器将组件和加载器连接起来。打开 `App.jsx` 文件，通过向 `/cars` 路由提供加载器参数来修改代码：
- en: '[PRE18]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: With the loader now in place, you are ready to test your `/cars` page, which
    should be displaying the cars saved in the collection so far.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在加载函数已经就位，你可以测试你的 `/cars` 页面了，它应该显示到目前为止保存的汽车集合。
- en: The next few sections will explore the implementation of another piece of functionality
    that you will likely encounter in every React (or Next.js, or web development
    in general) project—handling forms with React with RHF. You will implement the
    login functionality with the help of the most popular third-party package for
    handling forms with React, and also perform data validation with the Zod package.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几节将探讨实现你在每个 React（或 Next.js，或一般意义上的 web 开发）项目中都可能遇到的功能——使用 RHF 处理表单。你将借助处理
    React 表单最流行的第三方包来实现登录功能，并使用 Zod 包进行数据验证。
- en: React Hook Form and Zod
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React Hook Form 和 Zod
- en: There are many ways of handling forms with React, and one of the most common
    patterns was shown in [*Chapter 5*](B22406_05.xhtml#_idTextAnchor090), *Setting
    Up a React Workflow*. State variables are created with the `useState` Hook, the
    form is prevented from submitting and is intercepted, and, finally, the data is
    passed through JSON or as form data. While this workflow is acceptable when working
    with simple data and a couple of fields, it can quickly become difficult to manage
    in cases where you have to keep track of dozens of fields, their constraints,
    and their possible states.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 处理 React 表单有许多方法，其中最常见的一种模式在第 [*第 5 章*](B22406_05.xhtml#_idTextAnchor090) 中展示，即
    *设置 React 工作流程*。状态变量使用 `useState` 钩子创建，表单提交被阻止并拦截，最后数据通过 JSON 或表单数据传递。当处理简单数据和少量字段时，这种工作流程是可以接受的，但在需要跟踪数十个字段、它们的约束和可能状态的情况下，它很快就会变得难以管理。
- en: RHF is a mature project with a thriving community and is distinguished from
    other similar libraries by its speed, minimal amount of rendering, and deep integration
    with the most popular data validation libraries for TypeScript and JavaScript,
    such as Zod and Yup. In this case, you will learn the basics of Zod.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: RHF 是一个成熟的项目，拥有繁荣的社区，它与其他类似库的区别在于其速度、渲染量最小以及与 TypeScript 和 JavaScript 中最受欢迎的数据验证库（如
    Zod 和 Yup）的深度集成。在这种情况下，你将学习 Zod 的基础知识。
- en: Performing data validation with Zod
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Zod 进行数据验证
- en: The JavaScript and TypeScript ecosystem currently has several validation libraries—with
    Zod and Yup arguably being the most popular ones. Zod is a TypeScript-first schema
    declaration and validation library that provides data validation of data structures.
    Zod provides a simple and intuitive object-based syntax for creating complex validation
    rules for objects and values in JavaScript applications and greatly facilitates
    the process of ensuring data integrity across the application.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，JavaScript 和 TypeScript 生态系统中有几个验证库——Zod 和 Yup 可能是最受欢迎的。Zod 是一个以 TypeScript
    为首的架构声明和验证库，它提供了数据结构的验证。Zod 为 JavaScript 应用程序中的对象和值提供了简单直观的对象语法，以创建复杂的验证规则，并极大地简化了确保应用程序数据完整性的过程。
- en: 'The basic idea of these packages is to provide them with a prototype of the
    desired data structure and to perform a validation of the data against said defined
    data structure:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这些包的基本思想是提供所需数据结构的原型，并对数据与定义的数据结构进行验证：
- en: 'First, install the package:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，安装该包：
- en: '[PRE19]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Since the version number at the time of writing and used in the book’s repository
    is 7.51.5, use the preceding command if you want to reproduce the exact code from
    the repository.
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于撰写本文时和书中仓库中使用的版本号是 7.51.5，如果你想重现仓库中的确切代码，请使用前面的命令。
- en: 'Update the `Login.jsx` component and make it display `LoginForm`, which you
    will create shortly:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `Login.jsx` 组件，使其显示 `LoginForm`，你将在稍后创建它：
- en: '[PRE20]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, the `/src/components/LoginForm.jsx` file will contain all the form functionality
    as well as the data validation with Zod:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，`/src/components/LoginForm.jsx` 文件将包含所有表单功能以及使用 Zod 的数据验证：
- en: '[PRE21]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The component begins with the imports—the `useForm` hook and Zod, as well as
    the Zod resolver for integration with the form hook. Data validation in Zod is
    similar to how it is in Pydantic—you define an object and set the desired properties
    on various fields. In this case, we set that the username and password is between
    4 and 10 characters long, but Zod allows for some very complex validation, as
    you can see on their website ([https://zod.dev/](https://zod.dev/)).
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 组件开始于导入——`useForm` 钩子、Zod 以及与表单钩子集成的 Zod 解析器。在 Zod 中的数据验证类似于 Pydantic 中的方式——你定义一个对象，并在各个字段上设置所需的属性。在这种情况下，我们设置用户名和密码长度在
    4 到 10 个字符之间，但 Zod 允许进行一些非常复杂的验证，正如你可以在他们的网站上看到的那样（[https://zod.dev/](https://zod.dev/))。
- en: 'The `useForm` Hook provides several useful functions:'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`useForm` 钩子提供了几个有用的函数：'
- en: '`register` is used to register single-form fields with the hook'
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`register` 用于使用钩子注册单个表单字段'
- en: '`handleSubmit` is the function that will be called upon submission'
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`handleSubmit` 是提交时将被调用的函数'
- en: '`formState` contains different information about the form state ([https://react-hook-form.com/docs/useform/formstate](https://react-hook-form.com/docs/useform/formstate))'
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`formState` 包含有关表单状态的不同信息（[https://react-hook-form.com/docs/useform/formstate](https://react-hook-form.com/docs/useform/formstate)）'
- en: 'Now, set up the `form` Hook:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，设置 `form` 钩子：
- en: '[PRE22]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this case, you will only track the errors (tied to the validation defined
    previously with Zod), but this object tracks much more. In your code, you’ll just
    output the data to the console once it is validated.
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这种情况下，你将只跟踪错误（与之前用 Zod 定义的验证相关），但这个对象跟踪的内容要多得多。在你的代码中，一旦验证通过，你只需将数据输出到控制台即可。
- en: 'Now, build the form’s JSX and add some styling to see what’s happening:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，构建表单的 JSX 并添加一些样式以查看发生了什么：
- en: '[PRE23]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: <div className=”mb-4”>
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<div className=”mb-4”>`'
- en: <label htmlFor=”username” className=”block
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<label htmlFor=”username” className=”block`'
- en: text-gray-700 text-sm font-bold mb-2”>
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`text-gray-700 text-sm font-bold mb-2”>'
- en: Username
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 用户名
- en: </label>
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<label>`'
- en: <input id=”username” type=”text”
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<input id=”username” type=”text”`'
- en: placeholder=”Username” required
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`placeholder=”Username” required`'
- en: '{...register(‘username’)}'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`{...register(‘username’)}`'
- en: className=”shadow appearance-none border
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`className=”shadow appearance-none border`'
- en: rounded w-full py-2 px-3 text-gray-700
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`rounded w-full py-2 px-3 text-gray-700`'
- en: leading-tight focus:outline-none
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`leading-tight focus:outline-none`'
- en: focus:shadow-outline”/>
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`focus:shadow-outline”/>'
- en: '{errors.username && <p className=”text-red-500'
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`{errors.username && <p className=”text-red-500'
- en: text-xs italic”>{errors.username.message}</p>}
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`text-xs italic”>{errors.username.message}</p>}'
- en: </div>
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: </div>
- en: '[PRE24]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The highlighted parts of the code are the registration of the fields with the
    `useForm` Hook—a way of letting the form know which fields to expect and the errors
    (if they are present) that are related to their respective fields.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中突出显示的部分是使用 `useForm` 钩子注册字段——这是让表单知道预期哪些字段以及与各自字段相关的错误（如果有的话）的一种方式。
- en: This way, the fields are registered to the hook form through this spread operator
    syntax. Since the errors provided by the form are bound to the fields, take this
    opportunity and show them next to the fields that report errors for a more pleasing
    user experience.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，字段通过这个扩展运算符语法注册到钩子表单中。由于表单提供的错误绑定到字段上，利用这个机会，将它们显示在报告错误的字段旁边，以提供更好的用户体验。
- en: 'The rest of the component is intuitive and covers the `password` field and
    the `submit` button:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 组件的其余部分直观易懂，涵盖了`密码`字段和`提交`按钮：
- en: '[PRE25]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The complete code from the book is available in the book repository.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 书中的完整代码可在书库中找到。
- en: The form is now ready and is handled completely by the hook form with a Zod
    validation. If you try to input data that doesn’t meet the validation criteria
    (username or password shorter than four characters, for instance) you will get
    an error message next to the fields. After setting up the form for logging in,
    you will create an authentication context that will allow the user to stay logged
    in. The authentication process—the creation of a React context and storing the
    JWT—will be very similar to the one covered in [*Chapter 6*](B22406_06.xhtml#_idTextAnchor105),
    *Authentication and Authorization*, so this next section only covers and highlights
    the important parts of the code.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 表单现在已准备就绪，并由带有Zod验证的钩子表单完全处理。如果您尝试输入不符合验证标准的数据（例如用户名或密码少于四个字符），您将在字段旁边收到错误消息。在设置登录表单后，您将创建一个认证上下文，允许用户保持登录状态。认证过程——创建React上下文和存储JWT——将与[*第6章*](B22406_06.xhtml#_idTextAnchor105)“认证和授权”中介绍的过程非常相似，因此下一节仅涵盖并突出代码中的重要部分。
- en: Authentication context and storing the JWT
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 认证上下文和存储JWT
- en: 'In this section, you will use your brand-new form, powered by RHF, and connect
    it to the Context API. The procedure for defining a React Context API was covered
    in detail in [*Chapter 4*](B22406_04.xhtml#_idTextAnchor071), *Getting Started
    with FastAPI* and in this chapter, you will apply that knowledge and create a
    similar context for keeping track of the authentication state of the application:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将使用由RHF提供动力的全新表单，并将其连接到上下文API。定义React Context API的流程在[*第4章*](B22406_04.xhtml#_idTextAnchor071)“FastAPI入门”中进行了详细说明，本章中，您将应用这些知识并创建一个类似上下文来跟踪应用程序的认证状态：
- en: 'Create a new folder in the `/src` directory and name it `contexts`. Inside
    this folder, create a new file called `AuthContext.jsx` and create the provider:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`/src`目录中创建一个新的文件夹，命名为`contexts`。在此文件夹内，创建一个名为`AuthContext.jsx`的新文件，并创建提供者：
- en: '[PRE26]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The context that you are creating is rather simple and contains a couple of
    state variables and setters that will be needed for the authentication flow: the
    username (whose presence or absence thereof will indicate whether the user is
    authenticated), the JWT, and a helper message that, in this case, is only useful
    for debugging and illustration.'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您正在创建的上下文相当简单，包含一些状态变量和设置器，这些变量和设置器将用于认证流程：用户名（其存在或不存在将指示用户是否已认证）、JWT以及一个辅助消息，在这种情况下，它仅用于调试和说明。
- en: The initial values are set to `null` and a generic message through the `useState`
    hook—the username is set to `null`, the JWT to an empty string, and the message
    to `Please log in`.
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 初始值通过`useState`钩子设置为`null`和通用消息——用户名设置为`null`，JWT设置为空字符串，消息设置为“请登录”。
- en: 'Next, add a `useEffect` hook that will fire once the context is loaded or when
    the page is reloaded:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加一个`useEffect`钩子，它将在上下文加载或页面重新加载时触发：
- en: '[PRE27]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The first part of the `useEffect` hook checks whether there is a JWT present
    in the local storage. If it is present, the `useEffect` hook performs an API call
    to the FastAPI server to determine whether the JWT is able to return a valid user:'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`useEffect`钩子的第一部分检查本地存储中是否存在JWT。如果存在，`useEffect`钩子将对FastAPI服务器执行API调用，以确定JWT是否能够返回有效的用户：'
- en: '[PRE28]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If the token is invalid or it has been tampered with or has expired, the `useEffect`
    hook removes it from local storage, sets the context state variables to `null`,
    and sets an appropriate message to the users:'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果令牌无效或被篡改或已过期，`useEffect`钩子将其从本地存储中删除，将上下文状态变量设置为`null`，并设置适当的消息给用户：
- en: '[PRE29]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: To sum it up, the `useEffect` hook performs a cycle. First, it checks for the
    local storage and if it doesn’t find a JWT, it deletes the JWT from the context,
    sets the username to `null`, and prompts the user to log in. The same result is
    obtained if the API call to the `/me` route, with the existing JWT, does not yield
    a valid username. This means that the token is present, but invalid or expired.
    If the JWT is indeed present and it can be used in order to obtain a valid username,
    the username is then set and the JWT is stored in the *Context*. Since the dependency
    array is empty, this hook will run only once on the first render.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，`useEffect`钩子执行了一个周期。首先，它检查本地存储，如果没有找到JWT，它将从上下文中删除JWT，将用户名设置为`null`，并提示用户登录。如果使用现有JWT对`/me`路由的API调用没有返回有效的用户名，也会得到相同的结果。这意味着令牌存在，但无效或已过期。如果JWT确实存在并且可以用来获取有效的用户名，那么将设置用户名并将JWT存储在*上下文*中。由于依赖项数组为空，此钩子将在第一次渲染时只运行一次。
- en: Implementing the login functionality
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现登录功能
- en: 'The login function will reside again inside the context for simplicity, although
    it could be in a separate file. Following is the login flow:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，登录函数将再次位于上下文中，尽管它也可以在单独的文件中。以下为登录流程：
- en: The user provides their username and password.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户提供他们的用户名和密码。
- en: A fetch call to the backend is performed.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行了对后端的fetch调用。
- en: If the response has an HTTP status of `200` and the JWT is returned, `localStorage`
    is set, as well as the context, and the user is authenticated.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果响应具有HTTP状态`200`并且返回了JWT，则`localStorage`和上下文都会被设置，用户被认证。
- en: If the response doesn’t return an HTTP status of `200`, it means that the login
    information was not accepted and, in that case, both the JWT and the username
    values are set to `null` in the context and effectively invalidated.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果响应没有返回HTTP状态`200`，这意味着登录信息未被接受，在这种情况下，上下文中的JWT和用户名值都被设置为`null`，从而有效失效。
- en: 'To implement the login functionality, perform these steps:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现登录功能，执行以下步骤：
- en: 'First, the `login` function needs to call the login API route with the provided
    username and password. Paste the following code into the end of the `AuthContext.jsx`
    file:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，`login`函数需要调用带有提供的用户名和密码的登录API路由。将以下代码粘贴到`AuthContext.jsx`文件的末尾：
- en: '[PRE30]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, depending on the response, the function will set the state variables
    in the context accordingly:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，根据响应，函数将相应地设置上下文中的状态变量：
- en: '[PRE31]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The logic is similar to the one applied in the `useEffect` hook—if a valid user
    is found, the context state variables (username and JWT) are set; otherwise, they
    are set to `null`.
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 逻辑与`useEffect`钩子中应用的方法类似——如果找到有效的用户，上下文状态变量（用户名和JWT）将被设置；否则，它们将被设置为`null`。
- en: 'The final part is just the `logout` function and the returning of the context
    provider. The following `logout` function is defined inside `AuthProvider`:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后的部分只是`logout`函数和上下文提供者的返回。下面的`logout`函数是在`AuthProvider`内部定义的：
- en: '[PRE32]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'At this point you have accomplished quite a lot: you have set up the context,
    defined the login and logout functions, and created the context provider. Now,
    to facilitate the use of the context, you will create a simple custom React hook,
    based on the `useContext` built-in hook.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经完成了相当多的事情：你设置了上下文，定义了登录和注销函数，并创建了上下文提供者。现在，为了方便使用上下文，你将创建一个简单的自定义React钩子，基于内置的`useContext`钩子。
- en: Creating a custom hook for accessing the context
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建用于访问上下文的自定义钩子
- en: 'With the Context API set up, you can now proceed and create a `useAuth.jsx`
    file inside a new folder, `/src/hooks`, which will allow easy access to the context
    from various places:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好Context API之后，你现在可以继续创建一个位于新文件夹`/src/hooks`中的`useAuth.jsx`文件，这将允许从各个地方轻松访问上下文：
- en: 'Create the `useAuth.jsx` file inside the new folder:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新文件夹中创建`useAuth.jsx`文件：
- en: '[PRE33]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `useAuth` hook contains an error message in case the hook is accessed outside
    of the context—but your context will enclose the entire application.
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果钩子不在上下文中访问，`useAuth`钩子将包含一个错误消息——但你的上下文将包围整个应用程序。
- en: The final step in using a React context is to wrap the components that will
    need to access it; in your case, this will be `App.jsx`—the root component.
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用React上下文的最后一步是将需要访问它的组件包裹起来；在你的情况下，这将涉及`App.jsx`——根组件。
- en: 'Open the `App.jsx` file and wrap the only component that it is currently returning—
    `RouterProvider`—inside `AuthProvider`:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`App.jsx`文件，并将当前返回的唯一组件`RouterProvider`包裹在`AuthProvider`内部：
- en: '[PRE34]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Finally, display the context data and the state variables inside the `RootLayout`
    component that currently hosts all of your pages. This is a useful debugging technique
    while working with React Context API; you do not need to switch to and from the
    developer tools constantly.
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，在当前托管所有页面的`RootLayout`组件中显示上下文数据和状态变量。这是在使用React Context API时的一种有用的调试技术；你不需要频繁地在开发者工具之间切换。
- en: 'Open `RootLayout.jsx` and edit the file:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`RootLayout.jsx`并编辑文件：
- en: '[PRE35]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: const RootLayout = () => {
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: const RootLayout = () => {
- en: const {
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: const {
- en: user,
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: user,
- en: message,
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 消息，
- en: logout
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: logout
- en: '} = useAuth()'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '} = useAuth()'
- en: return (
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: return (
- en: <div className=” bg-blue-200 min-h-screen p-2”>
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <div className=” bg-blue-200 min-h-screen p-2”>
- en: <h2>RootLayout</h2>
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <h2>根布局</h2>
- en: <p className=”text-red-500 p-2 border”>
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <p className=”text-red-500 p-2 border”>
- en: '{message}'
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{message}'
- en: </p>
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: </p>
- en: '<p>Username: {user}</p>'
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '<p>用户名: {user}</p>'
- en: <header className=”p-3 w-full”>
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <header className=”p-3 w-full”>
- en: <nav className=”flex flex-row justify-between
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <nav className=”flex flex-row justify-between
- en: mx-auto”>
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: mx-auto”>
- en: <div className=”flex flex-row space-x-3”>
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <div className=”flex flex-row space-x-3”>
- en: <NavLink to=”/”>Home</NavLink>
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <NavLink to=”/”>主页</NavLink>
- en: <NavLink to=”/cars”>Cars</NavLink>
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <NavLink to=”/cars”>汽车</NavLink>
- en: '{user ? <>'
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{user ? <>'
- en: <NavLink to=”/new-car”>New Car</NavLink>
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <NavLink to=”/new-car”>新车</NavLink>
- en: <button onClick={logout}>Logout</button>
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <button onClick={logout}>登出</button>
- en: '</> : <>'
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '</> : <>'
- en: <NavLink to=”/login”>Login</NavLink>
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <NavLink to=”/login”>登录</NavLink>
- en: </>}
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: </>}
- en: </div>
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: </div>
- en: </nav>
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: </nav>
- en: </header>
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: </header>
- en: <main className=”p-8 flex flex-col flex-1
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <main className=”p-8 flex flex-col flex-1
- en: bg-white “>
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: bg-white “>
- en: <Outlet />
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <Outlet />
- en: </main>
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: </main>
- en: </div>
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: </div>
- en: )
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: )
- en: '}'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: export default RootLayout
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: export default RootLayout
- en: '[PRE36]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The application is rather simple, but it showcases the login/logout process
    well. As an exercise, you could easily implement the registration page—the API
    endpoint already exists and you should create the logic for handling the register
    form.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序相当简单，但很好地展示了登录/登出过程。作为一个练习，你可以轻松实现注册页面——API端点已经存在，你应该创建处理注册表单的逻辑。
- en: The following section will focus on completing some more functionality—the route
    for inserting new cars is still reachable for users who are not logged in and
    the form doesn’t exist yet. Now you will secure the resource creation endpoint
    and create protected pages with React Router.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分将专注于完成一些更多功能——插入新车的路由对于未登录的用户仍然可访问，而且表单还不存在。现在你将保护资源创建端点，并使用React Router创建受保护页面。
- en: Protecting routes
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保护路由
- en: Protected routes are routes and pages that are not accessible to everyone—they
    usually require the user to be logged in or to have certain privileges (admin
    or creator). There are many ways of protecting routes in React Router. One popular
    pattern is through high-order components—they are wrapper components that wrap
    routes that require a logged-in user. The new React Router and its `Outlet` component
    allow you to easily implement gate logic and redirect the user if they need to
    be authorized.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 受保护的路由是所有人无法访问的路由和页面——它们通常要求用户登录或拥有某些权限（管理员或创建者）。在React Router中有很多种保护路由的方法。一种流行的模式是通过高阶组件——它们是包裹需要登录用户的路由的包装组件。新的React
    Router及其`Outlet`组件允许你轻松实现门控逻辑，并在需要授权时重定向用户。
- en: 'Create a basic component that checks for the presence of a user (through the
    username). If the user is present, the component will use an `Outlet` component
    to let the wrapped routes make their way to the browser; otherwise, a redirect
    to the login page will ensue:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个基本的组件，用于检查用户的存在（通过用户名）。如果用户存在，该组件将使用`Outlet`组件让被包裹的路由到达浏览器；否则，将重定向到登录页面：
- en: 'Create a new component in the `/src/components` folder and name it `AuthRequired.jsx`:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`/src/components`文件夹中创建一个新的组件，命名为`AuthRequired.jsx`：
- en: '[PRE37]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The logic is simple; the component ensures you perform the JWT presence check.
    It then acts like a semaphore or a simple IF construct that checks for a condition—if
    a JWT is present, the `Outlet` component will show the enclosed components (in
    our case only one: the `NewCar` page), and if not, React Router’s `Navigate` component
    is used for programmatic navigation to the home page.'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 逻辑很简单；该组件确保你执行JWT存在性检查。然后它像一个信号量或简单的IF结构，检查条件——如果JWT存在，`Outlet`组件将显示封装的组件（在我们的例子中只有一个：`NewCar`页面），如果不存在，则使用React
    Router的`Navigate`组件进行程序性导航到主页。
- en: This simple solution will not force the authenticated user to be redirected
    to the home page if they reload a protected page, since the `useEffect` hook in
    `Layout.jsx` will detect whether the JWT is invalid only after the component loads.
    If the JWT is indeed invalid, the `useEffect` hook will invalidate the JWT, thus
    triggering the redirect.
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, update the `App.jsx` component, import the `AuthRequired` component, and
    enclose the `NewCar` page:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: You have learned how to protect routes that need authentication. Now, you will
    build another form to insert data about new cars and upload images (one image
    per car, to be precise) to Cloudinary through FastAPI.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Creating the page for inserting new cars
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The page for inserting new cars into the collection—the `NewCar.jsx` component—is
    protected and can be accessed only by authenticated users. In this section, you
    will build a more complex form and gradually modularize the code:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 'First, update the `NewCar.jsx` page and add a `CarForm` component, which you
    will build shortly:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, create this component in the `/src/components` folder. In this folder,
    create a new file and name it `CarForm.jsx`. Before starting to code the form,
    quickly review what type of data the form needs to collect and send to the API:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Brand**: A string'
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Make**: A string'
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Year**: An integer'
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Price**: An integer'
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Km**: An integer'
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cm3**: An integer'
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Picture**: A file object'
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It would be rather tedious and repetitive to create each field in the form as
    an individual input and just copy and paste everything across the file. Instead,
    you can abstract the input field and make it a reusable component. This component
    will need to accept some props, such as a name and type (number or string), and
    RHF can register it and associate an error, if any, to said field. So, before
    starting the form, create another component that will be reused as many times
    as needed and that will significantly facilitate the process of creating and updating
    the form should you need to add even more fields later—in a real-life scenario,
    cars can have hundreds of fields.
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a new file in the `/src/components` folder and name it `InputField.jsx`:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The field component is simple, yet useful—it abstracts all the functionality
    and even adds some styling.
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, go back to the `CarForm` file and start with the imports:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You are going to use Zod again for data validation, so add a schema—it should
    ideally match the Pydantic validation rules on the backend for consistency:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The Zod schema syntax is rather intuitive, though there might be some aspects
    that need caution—numbers need to be coerced, as HTML forms send strings by default,
    and files can be validated through handy functions.
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, start the actual form component:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `useNavigate` hook is used to navigate away from the page once the submission
    is complete, while `useForm` is similar to the one used for logging users in.
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a simple JavaScript array containing the data about the fields that
    are needed for the form:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个简单的JavaScript数组，包含表单所需的字段数据：
- en: '[PRE44]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'With this array, the form code becomes much more manageable. Look at the `onSubmit`
    function:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用这个数组，表单代码变得更加易于管理。看看`onSubmit`函数：
- en: '[PRE45]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Suddenly, the `onSubmit` function is much more succinct—it loops over the array
    and adds the fields to the `formData` object. Keep in mind that the `file` field
    is special—it is an array and you want only the first element, that is, the picture.
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 突然，`onSubmit`函数变得更加简洁——它遍历数组并将字段添加到`formData`对象中。记住，`file`字段是特殊的——它是一个数组，你只想获取第一个元素，即图片。
- en: 'To complete the `onSubmit` function, you need to make the `POST` request to
    the API:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成`onSubmit`函数，你需要向API发送`POST`请求：
- en: '[PRE46]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The fetch call is simple. After you get the result back, you can apply custom
    logic. In this case, you JSONify—render the error object as a JSON string and
    set the message to show it—if the error is coming from the server.
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 获取调用很简单。在你得到结果后，你可以应用自定义逻辑。在这种情况下，你将JSON化——将错误对象渲染为JSON字符串，并将消息设置为显示它，如果错误来自服务器。
- en: 'Finally, the JSX is trivial, thanks to your `InputField` component and `formArray`,
    while you also use the submitting value from the `useForm` hook:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，由于你的`InputField`组件和`formArray`，JSX变得非常简单，同时你也使用了`useForm`钩子中的提交值：
- en: '[PRE47]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The submit button is now reused as a submission indicator—it displays a different
    message while submitting and is also disabled to prevent multiple requests.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 提交按钮现在被重用作为提交指示器——在提交时显示不同的消息，并且也被禁用以防止多次请求。
- en: 'Building a page to update cars would be very similar to the previous endpoint—RHF
    plays extremely well with initial or default data that can be populated from an
    existing object, and you can also play with the online form builder: [https://react-hook-form.com/form-builder](https://react-hook-form.com/form-builder).
    Deleting cars is also relatively simple as the request needs only to be authenticated
    and contains the car ID.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个用于更新汽车的页面将与之前的端点非常相似——RHF与可以从现有对象中填充的初始或默认数据配合得非常好，你还可以使用在线表单构建器：[https://react-hook-form.com/form-builder](https://react-hook-form.com/form-builder)。删除汽车也相对简单，因为请求只需要认证并包含汽车ID。
- en: You have now built a car creation page, which can be extended in numerous ways.
    You have learned how to modularize your React code and how to provide meaningful
    messages and logic to your application, depending on the data flow to and from
    the server. Now you will build a page for displaying single cars and use loaders
    again.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经创建了一个汽车创作页面，它可以以多种方式扩展。你已经学会了如何模块化你的React代码，以及如何根据数据流向和从服务器提供有意义的信息和逻辑给你的应用程序。现在你将创建一个用于显示单个汽车的页面，并再次使用加载器。
- en: Displaying single cars
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示单个汽车
- en: 'Now that you have created the pages for displaying multiple items (cars), authenticating,
    and creating new items, create an individual car page and see how React Router
    deals with parameters in the URL:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经创建了用于显示多个项目（汽车）、认证和创建新项目的页面，创建一个单独的汽车页面，看看React Router是如何处理URL中的参数的：
- en: 'Edit the `SingleCar.jsx` file and introduce the `useLoaderData` hook, already
    used for preloading data on the cars page:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`SingleCar.jsx`文件，并引入`useLoaderData`钩子，它已经在汽车页面中用于预加载数据：
- en: '[PRE48]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: To save space, we reused the `CarCard` function to display data about the car.
    However, in a realistic scenario, this page would contain possibly an image gallery,
    much more data, maybe some comments or notes, and so on. The goal here, however,
    is just to show another way of creating the loader function.
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了节省空间，我们重用了`CarCard`函数来显示汽车的数据。然而，在现实场景中，这个页面可能包含一个图片库、更多的数据，也许还有一些评论或笔记等等。但在这里的目标只是展示创建加载器函数的另一种方式。
- en: 'Open the `App.jsx` file that currently hosts the router and update the `cars/:id`
    route, bearing in mind that the colon denotes a parameter, in this case, the string
    version of the `ObjectId` component of the car in the MongoDB collection:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开当前托管路由器的`App.jsx`文件，并更新`cars/:id`路由，记住冒号表示一个参数，在这种情况下，是MongoDB集合中汽车`ObjectId`组件的字符串版本：
- en: '[PRE49]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'There are just two changes in the route: the `loader` function, which is supplied
    as a part of an async function that takes in the parameter ID, and `errorElement`.
    The `NotFound` component will be displayed, in case the `loader` function encounters
    an error while fetching the data. Here, again, you reuse an existing element,
    but it could be customized.'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 路线上只有两个变化：一个是`loader`函数，它是作为异步函数的一部分提供的，该函数接收参数ID，另一个是`errorElement`。如果`loader`函数在获取数据时遇到错误，将显示`NotFound`组件。在这里，你再次重用了一个现有元素，但它可以进行定制。
- en: 'The final piece of the puzzle is the `fetchCarData.js` file, which is located
    in the `/src/utils` folder:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一部分是位于`/src/utils`文件夹中的`fetchCarData.js`文件：
- en: '[PRE50]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The `async` function just performs a single API call to retrieve the data related
    to an individual entity and, in case of an error, `errorElement` will be triggered.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`async`函数仅执行单个API调用以检索与单个实体相关的数据，如果发生错误，将触发`errorElement`。'
- en: Loader functions are extremely handy. By preloading data, they enable the user
    to have a much better user experience and the application feels faster.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 加载函数非常实用。通过预加载数据，它们使用户拥有更好的用户体验，应用程序感觉更快。
- en: Summary
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you created a React application using a modern Vite setup and
    implemented the basic functionality—creating new resources and, listing and displaying
    cars. This chapter also served as a refresher for you on the basic React hooks,
    such as `useState` and `useEffect`, and the Context API. You also learned the
    basics of React Router with its powerful loader functions. In this chapter, you
    created two forms using RHF and learned how to manage various steps and states
    involved with the use of your API.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你使用现代Vite设置创建了一个React应用程序，并实现了基本功能——创建新资源、列出和显示汽车。本章还对你关于基本React钩子，如`useState`和`useEffect`，以及Context
    API进行了复习。你还学习了React Router的基本知识，包括其强大的加载函数。在本章中，你创建了两个表单，使用RHF并学习了如何管理API使用过程中涉及的各种步骤和状态。
- en: The following chapter will explore Next.js version 14—the most powerful and
    feature-rich React.js-based full-stack framework.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将探讨Next.js 14版本——这是最强大且功能丰富的基于React.js的全栈框架。
