["```py\nclass Report:\n    def __init__(self, content):\n        self.content = content\n    def generate(self):\n        print(f\"Report content: {self.content}\")\n    def save_to_file(self, filename):\n        with open(filename, 'w') as file:\n            file.write(self.content)\n```", "```py\n    class Report:\n        def __init__(self, content: str):\n            self.content: str = content\n        def generate(self):\n            print(f\"Report content: {self.content}\")\n    ```", "```py\n    class ReportSaver:\n        def __init__(self, report: Report):\n            self.report: Report = report\n        def save_to_file(self, filename: str):\n            with open(filename, 'w') as file:\n                file.write(self.report.content)\n    ```", "```py\n    if __name__ == \"__main__\":\n        report_content = \"This is the content.\"\n        report = Report(report_content)\n        report.generate()\n        report_saver = ReportSaver(report)\n        report_saver.save_to_file(\"report.txt\")\n    ```", "```py\nclass Report:\n    def __init__(self, content: str):\n        self.content: str = content\n    def generate(self):\n        print(f\"Report content: {self.content}\")\nclass ReportSaver:\n    def __init__(self, report: Report):\n        self.report: Report = report\n    def save_to_file(self, filename: str):\n        with open(filename, \"w\") as file:\n            file.write(self.report.content)\nif __name__ == \"__main__\":\n    report_content = \"This is the content.\"\n    report = Report(report_content)\n    report.generate()\n    report_saver = ReportSaver(report)\n    report_saver.save_to_file(\"report.txt\")\n```", "```py\npython ch02/srp.py\n```", "```py\nreport.txt file has been created. So, everything works as expected.\n\t\t\tAs you can see, by following the SRP, you can achieve cleaner, more maintainable, and adaptable code, which contributes to the overall quality and longevity of your software projects.\n\t\t\tOCP\n\t\t\tThe OCP is another fundamental principle in software design. It emphasizes that software entities, such as classes and modules, should be open for extension but closed for modification. What does that mean? It means that once a software entity is defined and implemented, it should not be changed to add new functionality. Instead, the entity should be extended through inheritance or interfaces to accommodate new requirements and behaviors.\n\t\t\tWhen thinking about this principle and if you have some experience writing code for non-trivial programs, you can see how it makes sense, since modifying an entity introduces a risk of breaking some other part of the code base relying on it.\n\t\t\tThe OCP provides a robust foundation for building flexible and maintainable software systems. It allows developers to introduce new features or behaviors without altering the existing code base. By adhering to the OCP, you can minimize the risk of introducing bugs or unintended side effects when making changes to your software.\n\t\t\tAn example of design following the OCP\n\t\t\tConsider a `Rectangle` class defined for rectangle shapes. Let’s say we add a way to calculate the area of different shapes, maybe by using a function. The hypothetical code for the definition of both the class and the function could look like the following:\n\n```", "```py\n\n\t\t\tNote\n\t\t\tThis code is not in the example code files. It is a hypothetical idea to start with in our thinking, and not the code you would end up using. Keep reading.\n\t\t\tGiven that code, if we want to add more shapes, we have to modify the `calculate_area` function. That is not ideal as we will keep coming back to change that code and that means more time testing things to avoid bugs.\n\t\t\tAs we aim to become good at writing maintainable code, let’s see how we could improve that code by adhering to the OCP, while extending it to support another type of shape, the circle (using a `Circle` class):\n\n\t\t\t\t1.  Start by importing what we will need:\n\n    ```", "```py\n\n    \t\t\t\t2.  Define a `Shape` protocol for an interface providing a method for the shape’s area:\n\n    ```", "```py\n\n\t\t\tNote\n\t\t\tRefer to [*Chapter 1*](B21896_01.xhtml#_idTextAnchor017), *Foundational Design Principles*, to understand Python’s `Protocol` concept and technique.\n\n\t\t\t\t1.  Define the `Rectangle` class, which conforms to the `Shape` protocol:\n\n    ```", "```py\n\n    \t\t\t\t2.  Also define the `Circle` class, which also conforms to the `Shape` protocol:\n\n    ```", "```py\n\n    \t\t\t\t3.  Implement the `calculate_area` function in such a way that adding a new shape won’t require us to modify it:\n\n    ```", "```py\n\n    \t\t\t\t4.  Add some code for testing the `calculate_area` function on the two types of shape objects:\n\n    ```", "```py\n\n\t\t\tThe following is the complete code for this example, saved in the `ch02/ocp.py` file:\n\n```", "```py\n\n\t\t\tTo see the result of this code, run the following command:\n\n```", "```py\n\n\t\t\tYou should get the following output:\n\n```", "```py\nclass Bird:\n    def fly(self):\n        print(\"I can fly\")\nclass Penguin(Bird):\n    def fly(self):\n        print(\"I can't fly\")\n```", "```py\ndef make_bird_fly(bird):\n    bird.fly()\n```", "```py\n    class Bird:\n        def move(self):\n            print(\"I'm moving\")\n    ```", "```py\n    class FlyingBird(Bird):\n        def move(self):\n            print(\"I'm flying\")\n    class FlightlessBird(Bird):\n        def move(self):\n            print(\"I'm walking\")\n    ```", "```py\n    def make_bird_move(bird):\n        bird.move()\n    ```", "```py\n    if __name__ == \"__main__\":\n        generic_bird = Bird()\n        eagle = FlyingBird()\n        penguin = FlightlessBird()\n        make_bird_move(generic_bird)\n        make_bird_move(eagle)\n        make_bird_move(penguin)\n    ```", "```py\nclass Bird:\n    def move(self):\n        print(\"I'm moving\")\nclass FlyingBird(Bird):\n    def move(self):\n        print(\"I'm flying\")\nclass FlightlessBird(Bird):\n    def move(self):\n        print(\"I'm walking\")\ndef make_bird_move(bird):\n    bird.move()\nif __name__ == \"__main__\":\n    generic_bird = Bird()\n    eagle = FlyingBird()\n    penguin = FlightlessBird()\n    make_bird_move(generic_bird)\n    make_bird_move(eagle)\n    make_bird_move(penguin)\n```", "```py\npython ch02/lsp.py\n```", "```py\nI'm moving\nI'm flying\nBird class with a Penguin class or with an Eagle class; that is, each object moves whether it is an instance of a Bird class or an instance of a subclass. And that result was possible thanks to following the LSP.\n\t\t\tThis example demonstrates that all subclasses (`FlyingBird` and `FlightlessBird`) can be used in place of their superclass (`Bird`) without disrupting the expected behavior of the program. This conforms to the LSP.\n\t\t\tISP\n\t\t\tThe ISP advocates for designing smaller, more specific interfaces rather than broad, general-purpose ones. This principle states that a class should not be forced to implement interfaces it does not use. In the context of Python, this implies that a class shouldn’t be forced to inherit and implement methods that are irrelevant to its purpose.\n\t\t\tThe ISP suggests that when designing software, one should avoid creating large, monolithic interfaces. Instead, the focus should be on creating smaller, more focused interfaces. This allows classes to only inherit or implement what they need, ensuring that each class only contains relevant and necessary methods.\n\t\t\tFollowing this principle helps us build software with modularity, code readability and maintainability qualities, reduced side effects, and software that benefits from easier refactoring and testing, among other things.\n\t\t\tAn example of design following the ISP\n\t\t\tLet’s consider an `AllInOnePrinter` class that implements functionalities for printing, scanning, and faxing documents. The definition for that class would look like the following:\n\n```", "```py\n\n\t\t\tIf we wanted to introduce a specialized `SimplePrinter` class that only prints, it would have to implement or inherit the `scan_document` and `fax_document` methods (even though it only prints). That is not ideal.\n\t\t\tTo adhere to the ISP, we can create a separate interface for each functionality so that each class implements only the interfaces it needs.\n\t\t\tNote about interfaces\n\t\t\tRefer to the presentation in [*Chapter 1*](B21896_01.xhtml#_idTextAnchor017), *Foundational Design Principles*, of the **program to interfaces, not implementations principle**, to understand the importance of interfaces and the techniques we use in Python to define them (abstract base classes, protocols, etc.). In particular, here is the situation where protocols are the natural answer, that is, they help define small interfaces where each interface is created for doing only one thing.\n\n\t\t\t\t1.  Let’s start by defining the three interfaces:\n\n    ```", "```py\n\n    \t\t\t\t2.  Then, we keep the `AllInOnePrinter` class, which already implements the interfaces:\n\n    ```", "```py\n\n    \t\t\t\t3.  We add the `SimplePrinter` class, implementing the `Printer` interface, as follows:\n\n    ```", "```py\n\n    \t\t\t\t4.  We also add a function that, when passed an object that implements the `Printer` interface, calls the right method on it to do the printing:\n\n    ```", "```py\n\n    \t\t\t\t5.  Finally, we add code for testing the classes and the implemented interfaces:\n\n    ```", "```py\n\n\t\t\tHere is the complete code for this new design (`ch02/isp.py`):\n\n```", "```py\n\n\t\t\tTo test this code, run the following command:\n\n```", "```py\n\n\t\t\tYou will get the following output:\n\n```", "```py\n\n\t\t\tBecause of the new design, each class only needs to implement the methods relevant to its behavior. This illustrates the ISP.\n\t\t\tDIP\n\t\t\tThe DIP advocates that high-level modules should not depend directly on low-level modules. Instead, both should depend on abstractions or interfaces. By doing so, you decouple the high-level components from the details of the low-level components.\n\t\t\tThis principle allows for the reduction of the coupling between different parts of the system you are building, making it more maintainable and extendable, as we will see in an example.\n\t\t\tFollowing the DIP brings loose coupling within a system because it encourages the use of interfaces as intermediaries between different parts of the system. When high-level modules depend on interfaces, they remain isolated from the specific implementations of low-level modules. This separation of concerns enhances maintainability and extensibility.\n\t\t\tIn essence, the DIP is closely linked to the loose coupling principle, which was covered in [*Chapter 1*](B21896_01.xhtml#_idTextAnchor017), *Foundational Design Principles*, by promoting a design where components interact through interfaces rather than concrete implementations. This reduces the interdependencies between modules, making it easier to modify or extend one part of the system without affecting others.\n\t\t\tAn example of design following the ISP\n\t\t\tConsider a `Notification` class responsible for sending notifications via email, using an `Email` class. The code for both classes would look like the following:\n\n```", "```py\n\n\t\t\tNote about the code\n\t\t\tThis is not yet the final version of the example.\n\t\t\tCurrently, the high-level `Notification` class is dependent on the low-level `Email` class, and that is not ideal. To adhere to the DIP, we can introduce an abstraction, with a new code, as follows:\n\n\t\t\t\t1.  Define a `MessageSender` interface:\n\n    ```", "```py\n\n    \t\t\t\t2.  Define the `Email` class, which implements the `MessageSender` interface, as follows:\n\n    ```", "```py\n\n    \t\t\t\t3.  Define the `Notification` class, which also implements the `MessageSender` interface, and has an object that implements `MessageSender` stored in its `sender` attribute, for handling the actual message sending. The code for that definition is as follows:\n\n    ```", "```py\n\n    \t\t\t\t4.  Finally, add some code for testing the design:\n\n    ```", "```py\n\n\t\t\tThe complete code for the implementation we just proposed is as follows (`ch02/dip.py`):\n\n```", "```py\n\n\t\t\tTo test the code, run the following command:\n\n```", "```py\n\n\t\t\tYou should get the following output:\n\n```", "```py\n\n```", "```py\n\n```"]