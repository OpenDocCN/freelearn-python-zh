<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Basic Function Definitions</h1></div></div></div><p>Mathematically, a function is a mapping of values in a domain to values in a range. Functions like sine or cosine map values from a domain of angles to a range of real values between -1 and +1. The details of the mapping are summarized in the name, domain, and range. We'll use this function concept as a way to package our Python programming into something that allows us to summarize the implementation details using a name.</p><p>We'll look at how to define and evaluate Python functions. In this chapter, we'll focus on Python functions that simply return Python objects as the range of values. In <a class="link" href="ch08.html" title="Chapter 8. More Advanced Functions">Chapter 8</a>, <em>More Advanced Functions</em>, we'll look at generator functions; these are iterators, which are used with a <code class="literal">for</code> loop to produce sequences of values.</p><p>Python functions offer optional parameters as well as a mixture of positional and keyword parameters. This allows us to define a single function which has a number of variant signatures, allowing considerable flexibility in how the function is used.</p><div><div><div><div><h1 class="title"><a id="ch07lvl1sec61"/>Looking at the five kinds of callables</h1></div></div></div><p>Python<a class="indexterm" id="id402"/> offers five variations on the theme of a function. Each of these is a kind of callable object: we can call the object with argument values and it returns a result. Here's how we'll organize our exploration:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Basic functions created with the <code class="literal">def</code> statement are the subject of this chapter.</li><li class="listitem" style="list-style-type: disc">Lambda forms are a function definition reduced to parameters and an expression; this is also a topic within this chapter.</li><li class="listitem" style="list-style-type: disc">Generator functions and the yield statement are something we'll look at in <a class="link" href="ch08.html" title="Chapter 8. More Advanced Functions">Chapter 8</a>, <em>More Advanced Functions</em>. These functions are iterators which can provide multiple results.</li><li class="listitem" style="list-style-type: disc">Function wrappers for class methods are something we'll look at in <a class="link" href="ch11.html" title="Chapter 11. Class Definitions">Chapter 11</a>, <em>Class Definitions</em>. These are built-in functions which leverage features of a class. A function like <code class="literal">len()</code> is implemented by the <code class="literal">__len__()</code> method of a collection.</li><li class="listitem" style="list-style-type: disc">Callable objects are also part of <a class="link" href="ch11.html" title="Chapter 11. Class Definitions">Chapter 11</a>, <em>Class Definitions</em>. These are classes which include the <code class="literal">__call__()</code> method so that an instance of the class behaves like a basic function created with the <code class="literal">def</code> statement.</li></ul></div><p>All<a class="indexterm" id="id403"/> of these are variations on a common theme. They are ways to package some functionality so that it has a name, input parameters, and a result. This allows us to decompose large, complex programs into smaller, easier-to-understand functions.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec62"/>Defining functions with positional parameters</h1></div></div></div><p>The <a class="indexterm" id="id404"/>essential Python function definition is built with the <code class="literal">def</code> statement. We provide a name, the names of the parameters, and an indented suite of statements that is the body of the function. The <code class="literal">return</code> statement provides the range of values.</p><p>The syntax looks like this:</p><div><pre class="programlisting">def prod(sequence):
    p= 1
    for item in sequence:p *= item
    return p</pre></div><p>We've defined a name, <code class="literal">prod</code>, and provided a list of only one parameter, <code class="literal">sequence</code>. The body of the function includes three statements: assignment, <code class="literal">for</code>, and <code class="literal">return</code>. The expression in the <code class="literal">return</code> statement provides the resulting value.</p><p>This fits the mathematical idea of a function reasonably well. The domain of values is any numeric sequence, the range will be a value of the a type which reflects the data types in the sequence.</p><p>We evaluate a function by simply using the name and a specific value for the argument in an expression:</p><div><pre class="programlisting">&gt;&gt;&gt; prod([1,2,3,4])
24
&gt;&gt;&gt; prod(range(1,6))
120</pre></div><p>In the first example, we provided a simple list display, <code class="literal">[1, 2, 3, 4]</code>, as an argument. This was assigned to the parameter of the function, <code class="literal">sequence</code>. The evaluation of the function returned the product of that sequential collection of items.</p><p>In the second example, we provided a <code class="literal">range()</code> object as the argument to the <code class="literal">prod()</code> function. This argument value is assigned to the parameter of the function. When used with <a class="indexterm" id="id405"/>a <code class="literal">for</code> loop, the range object behaves like a sequence collection, and a product is computed and returned.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec64"/>Defining multiple parameters</h2></div></div></div><p>Python offers us a variety <a class="indexterm" id="id406"/>of ways to assign values to parameters. In the simplest case, the argument values are assigned to the parameters based on position. Here's a function with two positional parameters:</p><div><pre class="programlisting">def main_sail_area(boom, mast):
    return (boom*mast)/1.8</pre></div><p>We've defined a function that requires the length of the sail's boom, usually called the "E" dimension, and the height of the mast along which the sail is rigged, usually called the "P" dimension. Given these two numbers, and an assumption about the curvature of the sail, we return the approximate sail area.</p><p>We can evaluate this function providing the two positional parameters for boom length and mast height.</p><div><pre class="programlisting">&gt;&gt;&gt; main_sail_area(15, 45)
375.0</pre></div><p>We can define a function with any number of parameters. A function with a large number of parameters will tend to push the edge of the envelope on comprehensibility. A good function should have a tidy summary that makes it possible to understand the function's purpose without having to struggle with too many details.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec65"/>Using the return statement</h2></div></div></div><p>The <code class="literal">return</code> statement has two purposes: it ends the function's execution, and it can optionally <a class="indexterm" id="id407"/>provide the result value for the function. The <code class="literal">return</code> statement is optional. This leads to three use cases:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">No <code class="literal">return</code> statement: The function finishes at the end of the suite of statements. The return value is <code class="literal">None</code>.</li><li class="listitem" style="list-style-type: disc">A <code class="literal">return</code> statement with no expression: The function finishes when the <code class="literal">return</code> statement is executed, the result is <code class="literal">None</code>.</li><li class="listitem" style="list-style-type: disc">A <code class="literal">return</code> statement with an expression: The function finishes when the <code class="literal">return</code> statement is executed, the value of the expression is the result. A <code class="literal">return</code> statement with a list of expressions creates a <code class="literal">tuple</code>, suitable for multiple assignment.</li></ul></div><p>Here's a function with no <code class="literal">return</code> statement:</p><div><pre class="programlisting">def boat_summary(name, rig, sails):
    print( "Boat {0}, {1} rig, {2:.0f} sq. ft.".format(
        name, rig, sum(sails))
    )</pre></div><p>This<a class="indexterm" id="id408"/> function consists of a single expression statement that uses the <code class="literal">print()</code> function. There's no explicit <code class="literal">return</code> so the default return value will be <code class="literal">None</code>.</p><p>It's common to use a <code class="literal">return</code> statement to finish early when an exception condition has been met, otherwise you execute the rest of the suite of statements in the function definition. It looks like this:</p><div><pre class="programlisting">def mean_diff(data_sequence):
    s0, s1 = 0, 0
    for item in data_sequence:
        s0 += 1
        s1 += item
    if s0 &lt; 2:
        return
    m= s1/s0
    for item in data_sequence:
       print(item, abs(item-m))</pre></div><p>This function expects a collection of data. It will compute two values from that collection: <code class="literal">s0</code> and <code class="literal">s1</code>. The <code class="literal">s0</code> value will be a count of items, the <code class="literal">s1</code> value will be the sum of the items. If the count is too small, the function simply returns. If the count is large enough, then additional processing is done: the values are printed along with the absolute difference between the value and the average.</p><p>There's no <code class="literal">return</code> statement at the end of the suite of statements, since this is not required. Using a <code class="literal">return</code> statement in the middle of a function allows us to avoid deeply-nested <code class="literal">if</code> statements.</p><p>Note that the variables <code class="literal">s0</code>, <code class="literal">s1</code>, and <code class="literal">m</code>, are created in a local namespace that only exists while the function is being evaluated. Once the function is finished, the local namespace is removed, the reference counts are decremented and the interim objects are cleaned up. We'll look at additional details in the <em>Working with namespaces</em> section later in this chapter.</p><p>The built-in function <code class="literal">divmod()</code> returns two results. We often use multiple assignments like this: <code class="literal">q, r = divmod(n, 16)</code>; it will assign the two results to two variables, <code class="literal">q</code> and <code class="literal">r</code>. We can write a function that returns multiple values by including multiple expressions on the <code class="literal">return</code> statement.</p><p>In the <em>Mutable and immutable argument values</em> section, we'll show a function that has multiple return values.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec66"/>Evaluating a function with positional or keyword arguments</h2></div></div></div><p>Python <a class="indexterm" id="id409"/>allows us to provide argument<a class="indexterm" id="id410"/> values with explicit parameter names. When we provide a name, it's called a keyword argument. For example, the <code class="literal">boat_summary()</code> function in the previous section can be used in a number of different ways.</p><p>We can provide the argument values positionally, like this:</p><div><pre class="programlisting">&gt;&gt;&gt; sails =  [358.3, 192.5, 379.75, 200.0]
&gt;&gt;&gt; boat_summary("Red Ranger", "ketch", sails)</pre></div><p>The arguments are assigned to the parameter variables of <code class="literal">name</code>, <code class="literal">rig</code>, and <code class="literal">sails</code> based on their position.</p><p>We can, as an alternative, do something like this:</p><div><pre class="programlisting">&gt;&gt;&gt; boat_summary(sails=sails, rig="ketch", name="Red Ranger" )</pre></div><p>This example provides all three arguments with keywords. Note that the position doesn't matter when providing keyword arguments. The keyword arguments must be provided <em>after</em> any positional arguments, but the order among the keyword arguments doesn't matter, since they are assigned to parameters by name.</p><p>We can use a mixture of positional and keyword arguments. For this to work, Python uses two rules to map argument values to a function's parameters:</p><div><ol class="orderedlist arabic"><li class="listitem">Match all positional arguments to parameters from left-to-right.</li><li class="listitem">Match all keyword parameters by name.</li></ol></div><p>There are several additional rules to handle duplicates and default values—which include optional parameters—described later, in the section called <em>Defining optional parameters via default values</em>.</p><p>In order for these rules to work properly, we must provide all positional parameters first, and then we can provide any keyword parameters after the positional parameters. We can't provide two values for the same parameter via position as well as keyword. Nor, for that matter, can we provide a keyword twice.</p><p>Here's a good example and a bad example:</p><div><pre class="programlisting">&gt;&gt;&gt; boat_summary("Red Ranger", sails=sails, rig="ketch")
&gt;&gt;&gt; boat_summary("Red Ranger", sails=sails, rig="ketch", name="Red Ranger")</pre></div><p>In the first example, the <code class="literal">name</code> parameter is matched positionally. The <code class="literal">sails</code> and <code class="literal">rig</code> parameters were matched by keyword.</p><p>In<a class="indexterm" id="id411"/> the second example, there are both <a class="indexterm" id="id412"/>positional and keyword values for the <code class="literal">name</code> variable. This will raise a <code class="literal">TypeError</code> exception.</p><p>Because of this, it's very important to choose parameter variable names wisely. A good choice of parameter name can make keyword argument function evaluation very clear.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec67"/>Writing a function's docstring</h2></div></div></div><p>In order<a class="indexterm" id="id413"/> to save space, we haven't provided many examples of functions with docstrings. We'll address docstrings in detail in <a class="link" href="ch14.html" title="Chapter 14. Fit and Finish – Unit Testing, Packaging, and Documentation">Chapter 14</a>, <em>Fit and Finish – Unit Testing, Packaging, and Documentation</em>. For now, we need to be aware that every function should, at the very least, have a summary. The summary is included as a triple-quoted string that must be the very first expression in the suite of statements of the function.</p><p>A function with a docstring looks like this:</p><div><pre class="programlisting">def jib(foot, height):
    """
    jib(foot,height) -&gt; area of given jib sail.

    &gt;&gt;&gt; jib(12,40)
    240.0
    """
    return (foot*height)/2</pre></div><p>This particular triple-quoted string serves two purposes. First, it summarizes what the function does. We can read this when we look at the source file. We can also see this when we use <code class="literal">help(jib)</code>.</p><p>The second purpose for this docstring is a way to provide a concrete example of how the function is used. The examples always look like they are simply copied from a REPL session and pasted into the docstring comment.</p><p>These REPL-formatted examples are located by using the <code class="literal">doctest</code> tool. After locating the examples, this tool can run the code to confirm that it works as advertised. All of the examples in this book were tested using <code class="literal">doctest</code>. While the details of testing are part of <a class="link" href="ch14.html" title="Chapter 14. Fit and Finish – Unit Testing, Packaging, and Documentation">Chapter 14</a>, <em>Fit and Finish – Unit Testing, Packaging, and Documentation</em>, it's important to consider writing docstrings in every function.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec63"/>Mutable and immutable argument values</h1></div></div></div><p>In some programming languages, there are multiple function evaluation strategies, including <a class="indexterm" id="id414"/>call-by-value and call-by-reference. In call-by-value semantics, copies of argument values are assigned to the parameter variables<a class="indexterm" id="id415"/> in a function. In call-by-reference semantics, a reference to a variable is used in the function. This means that an assignment statement inside a function could replace the value of a variable outside the function. Neither of these types of semantics apply to Python.</p><p>Python uses a mechanism named "call-by-sharing" or "call-by-object". A function is given a reference to the original object. If that object is mutable, the function can mutate the object. The function cannot, however, assign to variables outside the function via the parameter variables. The function shares the objects, not the variables to which the objects are assigned.</p><p>One of the most important consequences is that the body of a function can assign new values to parameter variables without having any impact on the original arguments which are passed to a function. The parameter variables are strictly local to the function.</p><p>Here's a function that assigns new values to the parameter variable:</p><div><pre class="programlisting">def get_data(input_string):
    input_string= input_string.strip()
    input_string, _, _ = input_string.partition("#")
    input_string= input_string.rstrip()
    name, _, value = input_string.partition('=')
    return name, value</pre></div><p>This function evaluates the <code class="literal">strip()</code> method of the <code class="literal">input_string</code> variable and assigns the resulting string to the parameter variable. It applies the <code class="literal">partition()</code> method to the new value of the <code class="literal">input_string</code> variable and assigns one of the three resulting strings to the parameter variable. It then returns this string object, assigning it to the parameter variable yet again.</p><p>None of the assignment statements to the <code class="literal">input_string</code> parameter variable have any effect on any variables outside the function. When a function is evaluated, a separate namespace is used for the parameters and other local variables.</p><p>Another consequence of the way Python works is that when we provide mutable objects as arguments, these objects can be updated by methods evaluated inside a function. The function's parameter variables will be references to the original mutable objects, and we can evaluate methods like the <code class="literal">remove()</code> or <code class="literal">pop()</code> functions that change the referenced object.</p><p>Here's a function which updates a <code class="literal">list</code> argument by removing selected values:</p><div><pre class="programlisting">def remove_mod(some_list, modulus):
    for item in some_list[:]:
        if item % modulus == 0:
            some_list.remove(item)</pre></div><p>This<a class="indexterm" id="id416"/> function expects a mutable object like a list, named <code class="literal">some_list</code>, and a value, named <code class="literal">modulus</code>. The function makes a temporary copy<a class="indexterm" id="id417"/> of the argument value using <code class="literal">some_list[:]</code>. For each value in this copy that is a multiple of the <code class="literal">modulus</code> value, we'll remove that copy from the original <code class="literal">some_list</code> object. This will mutate the original object.</p><p>When we evaluate this function, it looks like this:</p><div><pre class="programlisting">&gt;&gt;&gt; data= list(range(10))
&gt;&gt;&gt; remove_mod(data, 5)
&gt;&gt;&gt; remove_mod(data, 7)
&gt;&gt;&gt; data
[1, 2, 3, 4, 6, 8, 9]</pre></div><p>We've created a simple list and assigned it to the <code class="literal">data</code> variable. This object referred to by the <code class="literal">data</code> variable was mutated by the <code class="literal">remove_mod()</code> function. All multiples of five and seven were discarded from the sequence.</p><p>In this function, we need to create a temporary copy of the input <code class="literal">list</code> object before we can start removing values. If we try to iterate through a <code class="literal">list</code> while simultaneously removing items from that <code class="literal">list</code>, we'll get results that don't appear correct. It helps to have the original values separate from the mutating <code class="literal">list</code>.</p><p>A function can create variables in the global namespace, and other non-local namespaces, by making special arrangements. This is done with the <code class="literal">global</code> and <code class="literal">nonlocal</code> statements shown in the <em>Working with namespaces</em> section.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec64"/>Defining optional parameters via default values</h1></div></div></div><p>Python<a class="indexterm" id="id418"/> lets us provide a default value for a parameter. Parameters with default values are optional. The standard library is full of functions with optional parameters. One example is the <code class="literal">int()</code> function. We can use <code class="literal">int("48897")</code> to convert a string to an integer, assuming that the string represents a number in base 10. We can use <code class="literal">int("48897", 16)</code> to explicitly state that the string should be treated as a hexadecimal value. The default value for the <code class="literal">base</code> parameter is 10.</p><p>Remember that we can use keyword arguments for a function. This means that we might want to write something like this: <code class="literal">int("48897", base=16)</code>, to make it abundantly clear what the second argument to the <code class="literal">int()</code> function is being used for.</p><p>Earlier, we listed two rules for matching argument values to parameters. When we introduce default values, we add two more rules.</p><div><ol class="orderedlist arabic"><li class="listitem">Match all positional arguments to parameters from left-to-right.</li><li class="listitem">Match all keyword parameters. In case of already-assigned positional parameters, raise a <code class="literal">TypeError</code> exception.</li><li class="listitem">Set default values for any missing parameters.</li><li class="listitem">In case there are parameters with no values, raise a <code class="literal">TypeError</code> exception.<div><div><h3 class="title"><a id="note04"/>Note</h3><p>Note: This is not the final set of rules; there are a few more features to cover.</p></div></div></li></ol></div><p>One<a class="indexterm" id="id419"/> important consequence of these rules is that the required parameters—those without default values—must be defined first. Parameters with default values must be defined last. The "required parameters first, optional parameters last" rule assures us that the positional matching process works.</p><p>We provide the default value in the function definition. Here's an example:</p><div><pre class="programlisting">import random
def dice(n=2, sides=6):
    return [random.randint(1,sides) for i in range(n)]</pre></div><p>We've imported the <code class="literal">random</code> module so that we can use the <code class="literal">random.randint()</code> function. Our <code class="literal">dice()</code> function has two parameters, both of which have default values. The <code class="literal">n</code> parameter, if not provided, will have a value of 2. The <code class="literal">sides</code> parameter, if omitted, will have a value of 6.</p><p>The body of this function is a list comprehension: it uses a generator expression to build a list of individual values. We'll look at generator expressions in detail in <a class="link" href="ch08.html" title="Chapter 8. More Advanced Functions">Chapter 8</a>, <em>More Advanced Functions</em>. For now, we can observe that it uses the <code class="literal">random.randint(1,sides)</code> function to generate numbers between 1 and the value of the <code class="literal">sides</code> parameter. The comprehension includes a <code class="literal">for</code> clause that iterates through <code class="literal">n</code> values.</p><p>We can use this function in a number of different ways. Here are some examples:</p><div><pre class="programlisting">&gt;&gt;&gt; dice()
[6, 6]
&gt;&gt;&gt; dice(6)
[3, 6, 2, 2, 1, 5]
&gt;&gt;&gt; dice(4, sides=4)
[3, 3, 4, 3]</pre></div><p>The first example relies on default values to emulate the pair of dice commonly used in casino games like Craps. The second example uses six dice, typical for games like 10,000 (sometimes called Zilch or Crap Out.). The third example uses four four-sided dice, typical of games that use a variety of polyhedral dice.</p><div><div><h3 class="title"><a id="note05"/>Note</h3><p>A<a class="indexterm" id="id420"/> note on testing: in order to provide repeatable unit tests for functions that involve the <code class="literal">random</code> module, we've set a specific seed value using <code class="literal">random.seed("test")</code>.</p></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec68"/>A warning about mutable default values</h2></div></div></div><p>Here's a <a class="indexterm" id="id421"/>pathological example. This shows a very bad programming practice; it's a mistake that many Python programmers make when they first start working with default values.</p><p>This is a very bad idea:</p><div><pre class="programlisting">def more_dice(n, collection=[]):
    for i in range(n):
        collection.append(random.randint(1,6))
    return collection</pre></div><p>We've defined a simple function with only two parameter variables, <code class="literal">n</code> and <code class="literal">collection</code>. The collection has a default value of an empty list. (Spoiler alert: this will turn out to be a mistake.) The function will append a number of simulated six-sided dice to the given collection.</p><p>The function returns a value as well as mutating an argument. This means that we'll see the <code class="literal">return</code> value printed when we use this function in the REPL.</p><p>We can use this for games like Yacht, also called Generala or Poker Dice. A player has a "hand" of dice from which we'll remove dice and append new dice rolls.</p><p>One use case is to create a <code class="literal">list</code> object and use this as an argument to the <code class="literal">more_dice()</code> function. This <code class="literal">list</code> object would get updated nicely. Here's how that would work:</p><div><pre class="programlisting">&gt;&gt;&gt; hand1= []
&gt;&gt;&gt; more_dice(5, hand1)
[6, 6, 3, 6, 2]
&gt;&gt;&gt; hand1
[6, 6, 3, 6, 2]</pre></div><p>We've created an empty <code class="literal">list</code> and assigned it to the <code class="literal">hand</code> variable. We provided this sequence object to the <code class="literal">more_dice()</code> function to have five values appended to the <code class="literal">hand</code> object. This gave us an initial roll of three sixes, a three, and a two. We can remove the two and three from the <code class="literal">hand1</code> object; we can reuse it with <code class="literal">more_dice(2, hand1)</code> to put two more dice into the hand.</p><p>We can use another empty sequence as an argument to deal a second hand. Except for the results, it's otherwise identical to the first example:</p><div><pre class="programlisting">&gt;&gt;&gt; hand2= []
&gt;&gt;&gt; more_dice(5, hand2)
[5, 4, 2, 2, 5]
&gt;&gt;&gt; hand2
[5, 4, 2, 2, 5]</pre></div><p>Everything<a class="indexterm" id="id422"/> seems to work properly. This is because we're providing an explicit argument for the collection parameter. Each of the hand objects is a distinct, empty <code class="literal">list</code>. Let's try to use the default value for the <code class="literal">collection</code> parameter.</p><p>In this third example, we won't provide an argument, but rely on the default sequence returned by the <code class="literal">more_dice()</code> function:</p><div><pre class="programlisting">&gt;&gt;&gt; hand1= more_dice(5)
&gt;&gt;&gt; hand1
[6, 6, 3, 6, 2]
&gt;&gt;&gt; hand2= more_dice(5)
&gt;&gt;&gt; hand2
[6, 6, 6, 2, 1, 5, 4, 2, 2, 5]</pre></div><p>Wait. What just happened? How is this possible?</p><p>As a hint, we'll need to search through the code for an object with a hidden, shared state. Earlier, we noted that a default <code class="literal">list</code> object would be a problem. This hidden <code class="literal">list</code> object is getting reused.</p><p>What happens is this:</p><div><ol class="orderedlist arabic"><li class="listitem">When the <code class="literal">def</code> statement is executed, the expressions that define the parameter defaults are evaluated. This means that a single mutable <code class="literal">list</code> object is created as the default object for the <code class="literal">collection</code> parameter.</li><li class="listitem">When the <code class="literal">more_dice()</code> function is evaluated without an argument for the <code class="literal">collection</code> parameter, the one-and-only mutable <code class="literal">list</code> object is used as the default object. What's important is that a single mutable object is being reused. If, at any point, we update this object, that mutation applies to all shared uses of the object. Since it's returned by the function, this single <code class="literal">list</code> could be assigned to several variables.</li><li class="listitem">When the <code class="literal">more_dice()</code> function is evaluated a second time without an argument for the <code class="literal">collection</code> parameter, the mutated <code class="literal">list</code> object is re-used as the default.</li></ol></div><p>From this, we can see that a mutable object is a terrible choice of a default value.</p><p>Generally, we have to do something like this:</p><div><pre class="programlisting">def more_dice_good(n, collection=None):
    if collection is None:
        collection = []
    for i in range(n):
        collection.append(random.randint(1,6))
    return collection</pre></div><p>This<a class="indexterm" id="id423"/> function uses an immutable and easily-recognized default value of <code class="literal">None</code>. If no argument value is provided for the <code class="literal">collection</code> variable, it will be set to <code class="literal">None</code>. We can replace the <code class="literal">None</code> value with a brand new <code class="literal">list</code> object created when the function is evaluated. We can then update this new <code class="literal">list</code> object, confident that we're not corrupting any mutable default object which is being reused.</p><div><div><h3 class="title"><a id="tip19"/>Tip</h3><p>Don't use a mutable object as a default value for a parameter.</p><p>Avoid <code class="literal">list</code>, <code class="literal">dict</code>, <code class="literal">set</code>, and any other mutable type, as default parameter values. Use <code class="literal">None</code> as a default; replace the <code class="literal">None</code> with a new, empty mutable object.</p><p>You've been warned.</p></div></div><p>This can lead to mistakes. It's a consequence of the way that function definition works and call-by-sharing semantics.</p><p>It's possible to exploit this intentionally: we can use a mutable default value as a cache to retain values, creating functions which have hysteresis. A callable object may be a better way to implement functions with an internal cache or buffer. See <a class="link" href="ch11.html" title="Chapter 11. Class Definitions">Chapter 11</a>, <em>Class Definitions</em>, for more information.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec65"/>Using the "everything else" notations of * and **</h1></div></div></div><p>Python<a class="indexterm" id="id424"/> offers even more flexibility in how we can define positional <a class="indexterm" id="id425"/>and keyword parameters for a function. The examples we've seen are all limited to a fixed and finite collection of argument values. Python allows us to write functions that have an essentially unlimited number of positional as well as keyword argument values.</p><p>Python will create a <code class="literal">tuple</code> of all unmatched positional parameters. It will also create a dictionary of all unmatched keyword parameters. This allows us to write functions that can be used like this:</p><div><pre class="programlisting">&gt;&gt;&gt; prod2(1, 2, 3, 4)
24</pre></div><p>This function accepts an arbitrary number of positional arguments. Compare this with the <code class="literal">prod()</code> function shown previously. Our previous example required a single sequence object, and we had to use that function as follows:</p><div><pre class="programlisting">&gt;&gt;&gt; prod([1, 2, 3, 4])
24</pre></div><p>The <code class="literal">prod2()</code> function will create a product of all argument values. Since the <code class="literal">prod2()</code> function <a class="indexterm" id="id426"/>can work with an unlimited collection of positional arguments, this leads to slightly simpler syntax for this function.</p><p>In order to<a class="indexterm" id="id427"/> write a function with an unlimited number of positional arguments, we must provide one parameter which has a <code class="literal">*</code> prefix. It looks like this:</p><div><pre class="programlisting">def prod2(*args):
    p= 1
    for item in args:
        p *= item
    return p</pre></div><p>The definition of <code class="literal">prod2()</code> has all positional arguments assigned to the <code class="literal">*</code> prefix parameter, <code class="literal">*args</code>. The value of the <code class="literal">args</code> parameter is a tuple of the argument values.</p><p>Here's a function which uses a mixture of positional and keyword parameters:</p><div><pre class="programlisting">def boat_summary2(name, rig, **sails):
    print("Boat {0}, {1} rig, {2:.0f} sq. ft.".format(
name, rig, sum(sails.values())))</pre></div><p>This function will accept two arguments, <code class="literal">name</code> and <code class="literal">rig</code>. These can be supplied by position or by keyword. Any additional keyword parameters—other than <code class="literal">name</code> and <code class="literal">rig</code>—are collected into a dictionary and assigned to the <code class="literal">sails</code> parameter. The <code class="literal">sails.values()</code> expression extracts just the values from the <code class="literal">sails</code> dictionary; these are added together to write the final summary line.</p><p>Here's one of many ways that we can use this function:</p><div><pre class="programlisting">&gt;&gt;&gt; boat_summary2("Red Ranger", rig="ketch",
...     main=358.3, mizzen=192.5, yankee=379.75, staysl=200 )</pre></div><p>We've provided the first argument value by position; this will be assigned to the first positional parameter, <code class="literal">name</code>. We've provided one of the defined parameters using a keyword argument, <code class="literal">rig</code>. The remaining keyword arguments are collected into a dictionary and assigned to the parameter named <code class="literal">sails</code>.</p><p>The <code class="literal">sails</code> dictionary will be assigned a value similar to this:</p><div><pre class="programlisting">{'main': 358.3, 'mizzen': 192.5, 'yankee': 379.75, 'staysl': 200}</pre></div><p>We can use any dictionary processing on this mapping since it's a proper <code class="literal">dict</code> object.</p><p>Earlier, we provided four rules for matching argument values with parameters. Here is a more complete set of rules for matching argument values with function parameters:</p><div><ol class="orderedlist arabic"><li class="listitem">Match all positional arguments to parameters from left-to-right.</li><li class="listitem">If there are more positional arguments than parameter names:<div><ol class="orderedlist arabic"><li class="listitem">If there's a parameter name with a <code class="literal">*</code> prefix, assign a <code class="literal">tuple</code> of remaining values to the prefixed parameter.</li><li class="listitem">If there's no parameter with the <code class="literal">*</code> prefix, raise a <code class="literal">TypeError</code> exception.</li></ol></div></li><li class="listitem">Match<a class="indexterm" id="id428"/> all keyword parameters. In case of already-assigned <a class="indexterm" id="id429"/>positional parameters, raise a <code class="literal">TypeError</code> exception.</li><li class="listitem">If there are more keyword arguments than parameter names:<div><ol class="orderedlist arabic"><li class="listitem">If there's a parameter name with a <code class="literal">**</code> prefix, assign <code class="literal">dict</code> of remaining keywords and values to the prefixed parameter.</li><li class="listitem">If there's no parameter with the <code class="literal">**</code> prefix, raise a <code class="literal">TypeError</code> exception.</li></ol></div></li><li class="listitem">Apply default values to missing parameters.</li><li class="listitem">In case of parameters which still have no values, raise a <code class="literal">TypeError</code> exception.</li></ol></div><p>A consequence of these rules is that, at most, only one parameter can have a <code class="literal">*</code> prefix; similarly, at most, only one parameter can have a <code class="literal">**</code> prefix. These special cases must be given after all of the other parameters. The <code class="literal">*</code> prefix variable will be assigned an empty tuple if there are no surplus positional parameters. The <code class="literal">**</code> prefix variable will be assigned an empty dictionary if there no surplus keyword parameters.</p><p>When invoking a function, we must provide positional argument values first. We can provide keyword argument values in any order.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec69"/>Using sequences and dictionaries to fill in *args and *kw</h2></div></div></div><p>The <code class="literal">prod2()</code> function, shown earlier, expects individual values which are collected into a <a class="indexterm" id="id430"/>single <code class="literal">*args</code> tuple. If we invoke the function <a class="indexterm" id="id431"/>with <code class="literal">prod2(1, 2, 3, 4, 5)</code>, then a tuple built<a class="indexterm" id="id432"/> from the five positional parameters<a class="indexterm" id="id433"/> is assigned to the <code class="literal">args</code> parameter.</p><p>What if we want to provide a list to the <code class="literal">prod2()</code> function? How can we, in effect, write <code class="literal">prod2(some_list[0], some_list[1], some_list[2], … )</code>?</p><p>When we call a function using <code class="literal">prod2(*some_sequence)</code>, then the values of the given argument sequence are matched to positional parameters. Item zero from the argument sequence becomes the first positional parameter. Item one from the sequence becomes the second parameter, and so on. Each item is assigned until they're all used up. If there are extra argument values, and the function was defined with a parameter using a <code class="literal">*</code> prefix, the extra argument values are assigned to the <code class="literal">*</code> prefix parameter.</p><p>Because of this, we can use <code class="literal">prod2(*range(1, 10))</code> easily. This is effectively <code class="literal">prod2(1, 2, 3, 4, 5, …, 9)</code>. Since all of the positional argument values are assigned to the <code class="literal">*</code>-prefix <code class="literal">args</code> variable, we can use this function with individual values, like this: <code class="literal">prod2(1, 2, 3, 4)</code>. We can provide a sequence of values, like this: <code class="literal">prod2(*sequence)</code>.</p><p>We have<a class="indexterm" id="id434"/> a similar technique for providing a dictionary<a class="indexterm" id="id435"/> of keyword arguments to a function. We<a class="indexterm" id="id436"/> can do this:</p><div><pre class="programlisting">&gt;&gt;&gt; rr_args = dict(
...    name="Red Ranger", rig="ketch",
...    main=358.3, mizzen=192.5, yankee=379.75, staysl=200
... )
&gt;&gt;&gt; boat_summary2(**rr_args)
Boat Red Ranger, ketch rig, 1131 sq. ft.</pre></div><p>We've <a class="indexterm" id="id437"/>created a dictionary with all of the arguments defined via their keywords. This uses a handy feature of the <code class="literal">dict()</code> function where all of the keyword arguments are used to build a dictionary object. We assigned that dictionary to the <code class="literal">rr_args</code> variable. When we invoked the <code class="literal">boat_summary2()</code> function, we used the <code class="literal">**rr_args</code> parameter to force each key and value in the <code class="literal">rr_args</code> dictionary to be matched against parameters to the function. This means that the values associated with the <code class="literal">name</code> and <code class="literal">rig</code> keys in the dictionary will be matched with the <code class="literal">name</code> and <code class="literal">rig</code> parameters. All other keys in the dictionary will be assigned the <code class="literal">sails</code> parameter.</p><p>These techniques allow us to build function arguments dynamically. This gives us tremendous flexibility in how we define and use Python functions.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec66"/>Nested function definitions</h1></div></div></div><p>We can<a class="indexterm" id="id438"/> include anything inside a function definition, even another function definition. When we look at decorators in <a class="link" href="ch13.html" title="Chapter 13. Metaprogramming and Decorators">Chapter 13</a>, <em>Metaprogramming and Decorators</em>, we'll see cases of a function which includes a nested function definition.</p><p>We can include <code class="literal">import</code> statements within a function definition. An <code class="literal">import</code> statement is only really executed once. There's a global collection of imported modules. The name, however, would be localized to the function doing the import.</p><p>The general advice is given in the <em>Zen of Python</em> poem by Tim Peters:</p><div><blockquote class="blockquote"><p><em>Flat is better than nested.</em></p></blockquote></div><p>We'll generally strive to have functions defined in a relatively simple, flat sequence. We'll avoid<a class="indexterm" id="id439"/> nesting unless it's truly required, as it is when creating decorators.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec67"/>Working with namespaces</h1></div></div></div><p>When a<a class="indexterm" id="id440"/> function is evaluated, Python creates a local namespace. The parameter variables are created in this local namespace when the argument values (or default values) are assigned. Any variables that are created in the suite of statements in the function's body are also created in this local namespace.</p><p>As we noted in <a class="link" href="ch04.html" title="Chapter 4. Variables, Assignment and Scoping Rules">Chapter 4</a>, <em>Variables, Assignment and Scoping Rules</em>, each object has a reference counter. An object provided as an argument to a function will have the reference count incremented during the execution of the function's suite of statements.</p><p>When the function finishes—either because of an explicit <code class="literal">return</code> statement or the implicit return at the end of the suite—the namespace is removed. This will decrement the number of references to the argument objects.</p><p>When we evaluate an expression like <code class="literal">more_dice_good(2, hand)</code>, the literal integer <code class="literal">2</code> will be assigned to the <code class="literal">n</code> parameter variable. Its reference count will be one during the execution of the function. The object assigned to the <code class="literal">hand</code> variable will be assigned to the <code class="literal">collection</code> parameter. This object will have a reference count of two during the execution of the function.</p><p>When the function exits, the namespace is removed, which removes the two parameter variables. The literal <code class="literal">2</code> object, assigned to the <code class="literal">n</code> variable, will wind up with a reference count of zero, and that <code class="literal">int</code> object can be removed from memory. The object assigned to the <code class="literal">collection</code> variable will have its reference count decreased from two to one; it will not be removed from memory. This object will still be assigned to the <code class="literal">hand</code> variable, and can continue to be used elsewhere.</p><p>This use of a local namespace allows us to freely assign objects to parameters without having the objects overwritten or removed from memory. It also allows us to freely create intermediate variables within the body of a function, secure in the knowledge that the variable will not overwrite some other variable used elsewhere in the script.</p><p>When we reference a variable, Python looks in two places for the variable. It looks first in the local namespace. If the variable isn't found, Python then searches the global namespace.</p><p>When we import a module, like <code class="literal">random</code>, we generally write <code class="literal">import</code> at the beginning of our script so that the module is imported into the global namespace. This means that a function which uses <code class="literal">random.randint()</code> will first check the local namespace for <code class="literal">random</code>; failing to find that, it will check the global namespace and find the imported module.</p><p>This fallback to the global namespace allows us to reuse imported modules, function definitions, and class definitions freely within a script file. We can also—to an extent—share global variables. The default behavior is that we can read the values of global variables, but we can't easily update them.</p><p>If we <a class="indexterm" id="id441"/>write <code class="literal">global_variable = global_variable + 1</code> in a function, we can fetch the value of a global variable named <code class="literal">global_variable</code>. The assignment, however, will create a new variable in the local namespace with the name <code class="literal">global_variable</code>. The actual global variable will remain untouched.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec70"/>Assigning a global variable</h2></div></div></div><p>What if<a class="indexterm" id="id442"/> we want to assign values to a variable which has not been provided as an argument? We can write a function which will update global variables. This can lead to confusing programs because several functions may share common states via the global variable.</p><p>To create names in the global namespace instead of a local namespace, we use the <code class="literal">global</code> statement. This identifies the variables which must be found in the global namespace instead of the local namespace. Here's a function which updates a global variable:</p><div><pre class="programlisting">import random
def roll_dice_count_7():
    global sevens
    d= random.randint(1,6), random.randint(1,6)
    if d[0] + d[1] == 7:
        sevens += 1
    return d</pre></div><p>We've defined a function and used the <code class="literal">global</code> statement to state that the variable named <code class="literal">sevens</code> will be found in the global namespace. We've created two random numbers, and assigned the pair to a local variable, <code class="literal">d</code>. This variable will be created in the local namespace, and won't conflict with any other variables defined in other namespaces.</p><p>Each time the pair of dice total seven, the global variable is updated. This is a side effect that can be confusing. It must be documented explicitly, and it requires some careful unit testing.</p><p>The two built-in functions, <code class="literal">globals()</code> and <code class="literal">locals()</code>, can help clarify the variables available when this function is being evaluated. If we add a <code class="literal">print()</code> function right before the <code class="literal">return</code> statement, we'll see results (with some details elided) like this:</p><div><pre class="programlisting">globals={'__cached__': None,
'__loader__': &lt;_frozen_importlib.SourceFileLoader object at 0x100623750&gt;,
'sevens': 20,
'__name__': '__main__',
'__file__': '…',
… etc.
    'roll_dice_count_7': &lt;function roll_dice_count_7 at 0x10216e710&gt;,
    'random': &lt;module 'random' from '...'&gt;}
locals={'d': (2, 1)}</pre></div><p>The <code class="literal">globals</code> function<a class="indexterm" id="id443"/> includes variables like <code class="literal">sevens</code>, it includes the random module, and the <code class="literal">roll_dice_count_7</code> function. It includes some system variables: <code class="literal">like __cached__</code>, <code class="literal">__loader__</code>, <code class="literal">__name__</code>, and <code class="literal">__file__</code>.</p><p>The <code class="literal">locals</code> function includes the local variable <code class="literal">d</code> and nothing more.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec71"/>Assigning a non-local variable</h2></div></div></div><p>When <a class="indexterm" id="id444"/>one function is defined inside another function, the outer function can contain variables which are neither local to the inner function nor global. We call these non-local variables. There are situations where we might want to set a variable which is part of an enclosing function.</p><p>Nested function definitions are most commonly used when defining decorators. We'll look at this in <a class="link" href="ch13.html" title="Chapter 13. Metaprogramming and Decorators">Chapter 13</a>, <em>Metaprogramming and Decorators</em>.</p><p>Here's a contrived example of nested functions and a non-local shared variable:</p><div><pre class="programlisting">def roll_nl(n=2, d=6):
    def dice():
        nonlocal total
        points= tuple(random.randint(1,d) for _ in range(n))
        total = sum(points)
        return points
    total= 0
    dice()
    return total</pre></div><p>We've defined a function, <code class="literal">roll_nl()</code>, which will simulate rolls of dice. The function's body includes a nested function definition, <code class="literal">dice()</code>. The rest of the body creates the variable <code class="literal">total</code>, evaluates the internal <code class="literal">dice()</code> function, and returns the value of the <code class="literal">total</code> variable.</p><p>How did the <code class="literal">total</code> variable get set to anything other than zero? It isn't updated in the body of the <code class="literal">roll_nl()</code> function.</p><p>Within the nested <code class="literal">dice()</code> function, there's a nonlocal reference to a variable named <code class="literal">total</code>. This variable must exist in an outer namespace, but not necessarily the global namespace. The <code class="literal">dice()</code> function creates a <code class="literal">tuple</code> object with the values of <code class="literal">n</code> dice. This expression builds a tuple from the result of a generator function. It updates the nonlocal <code class="literal">total</code> variable the sum of the <code class="literal">points</code> tuple. The <code class="literal">nonlocal</code> statement assures us that the <code class="literal">total</code> variable<a class="indexterm" id="id445"/> is part of the container for the <code class="literal">dice()</code> function. The return value of the <code class="literal">dice()</code> function is the tuple of dice, a value this isn't really used.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec68"/>Defining lambdas</h1></div></div></div><p>A lambda<a class="indexterm" id="id446"/> form is a degenerate kind of function. A lambda doesn't even have a name: it has only parameters and a single expression. We create a lambda by providing the parameter names and the expression. It looks like this:</p><div><pre class="programlisting">lambda x: x[0]+x[1]</pre></div><p>This kind of thing is helpful in the context of Python's higher-order functions. We often use lambdas with <code class="literal">max()</code>, <code class="literal">min()</code>, <code class="literal">sorted()</code>, <code class="literal">map()</code>, <code class="literal">filter()</code>, or <code class="literal">list.sort()</code>. Here's a simple example:</p><div><pre class="programlisting">&gt;&gt;&gt; colors = [
... (255,160,137),
... (143, 80,157),
... (255,255,255),
... (162,173,208),
... (255, 67,164),
... ]
&gt;&gt;&gt; sorted(colors)
[(143, 80, 157), (162, 173, 208), (255, 67, 164),
  (255, 160, 137), (255, 255, 255)]
&gt;&gt;&gt; sorted(colors,
...     key= lambda rgb: (rgb[0]+rgb[1]+rgb[2])/3)
[(143, 80, 157), (255, 67, 164), (162, 173, 208),
  (255, 160, 137), (255, 255, 255)]</pre></div><p>We've created a simple list object which has four RGB color values. If we use the <code class="literal">sorted()</code> function on this list, the colors are sorted into order by the red component value. If the red components are equal, then the green component is used. In the rare case that the red and green components are equal the blue component is used.</p><p>If we want colors sorted by brightness, we can't simply sort by red, green, and blue. The perception of brightness is subtle and a number of formulae approximate the phenomena. We've picked just one, which is to average the RGB values. This formula doesn't take into account the fact that our eyes are more sensitive to green.</p><p>The <code class="literal">sorted()</code> function accepts a second parameter, <code class="literal">key</code>, which we've provided as a keyword argument in the second example. Rather than write a complete function definition that would only really embody a single expression, we've packaged the expression, <code class="literal">(rgb[0]+rgb[1]+rgb[2])/3</code>, as a lambda.</p><p>The syntax <code class="literal">lambda rgb: (rgb[0]+rgb[1]+rgb[2])/3</code> is equivalent to the following function definition.</p><div><pre class="programlisting">def brightness(rgb):
    return (rgb[0]+rgb[1]+rgb[2])/3</pre></div><p>The lambda is<a class="indexterm" id="id447"/> more compact. If we only need this expression in one place, a reusable function may not be appropriate. A lambda is an easy way to provide a simple expression with minimal overhead. If we think we need to write complex lambdas—more than a simple expression—or we need to reuse a lambda, then we should consider using a proper function.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec69"/>Writing additional function annotations</h1></div></div></div><p>The <strong>Python Enhancement Proposal</strong> (<strong>PEP</strong>) number 3107 specifies additional annotations<a class="indexterm" id="id448"/> which can be applied to a function<a class="indexterm" id="id449"/> definition. Additionally, PEPs 482, 483, and 484 cover some related ideas.</p><p>This is important only because Python has some optional syntax that we may see. In Python 3.5, there may be additional tools for the type of information provided in this optional syntax. The annotated code can look like this:</p><div><pre class="programlisting">def roller( n: int, d: int = 6 ) -&gt; tuple:
    return tuple(random.randint(1,d) for _ in range(n))</pre></div><p>This function includes additional <code class="literal">: expression</code> annotations after each parameter. It also includes a <code class="literal">-&gt; expression</code> annotation to show the return type of the function. All of the annotation expressions in this example are the names of built-in types.</p><p>In order to describe more complex structures, an additional typing module can offer the tools for defining a more exact <code class="literal">Tuple[int, …]</code> as the return type for this function. This is an exciting development that may avoid certain kinds of bugs.</p><p>These annotations are legal Python3 syntax. They have no formally-defined semantics, which means that they are optional. There are some enhancement projects that are working on leveraging these optional annotations and creating tools that can use the information provided there. It's rarely used, but perfectly legal.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec70"/>Summary</h1></div></div></div><p>We've looked at a number of Python features for function definition. We've looked at how we define the name, and the parameters to a function, providing default values to make parameters optional. We've also looked at how we can provide arguments to a function: we can provide arguments by position, or by using the parameter variable name as a keyword. We can evaluate <code class="literal">function(*args)</code> to map a sequence of values to parameters by position. We can also evaluate <code class="literal">function(**kw)</code> to map a dictionary of values to parameters by name. And, of course, we can combine these two techniques.</p><p>We've looked at how functions return values via the <code class="literal">return</code> statement. We've also looked at functions which don't return a value. Technically, they return a value of <code class="literal">None</code>, which the rest of the Python programming ignores.</p><p>We've looked at the all-important issue of attempting to use a mutable object as a default value in a function definition. Most of the time, a mutable object as a default is going to create problems.</p><p>In addition to the basics of function definition, we looked at how local variables are assigned to temporary namespaces. We also looked at how we can use the <code class="literal">global</code> statement to create variables in the global namespace. We also looked at how a nested function definition can manipulate variables that are nonlocal to the nested function, but not properly global to the container function.</p><p>In <a class="link" href="ch08.html" title="Chapter 8. More Advanced Functions">Chapter 8</a>, <em>More Advanced Functions</em>, we'll look at generator expressions and functions. These are functions which are iterable, and work cooperatively with the <code class="literal">for</code> loop to handle collections and sequences of data.</p></div></body></html>