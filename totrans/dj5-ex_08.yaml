- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Building an Online Shop
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建在线商店
- en: In the previous chapter, you created a follow system and built a user activity
    stream. You also learned how Django signals work and integrated Redis into your
    project to count image views.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你创建了一个关注系统并构建了用户活动流。你还学习了Django信号的工作原理，并将Redis集成到你的项目中以统计图片浏览量。
- en: In this chapter, you will start a new Django project that consists of a fully
    featured online shop. This chapter and the following two chapters will show you
    how to build the essential functionalities of an e-commerce platform. Your online
    shop will enable clients to browse products, add them to the cart, apply discount
    codes, go through the checkout process, pay with a credit card, and obtain an
    invoice. You will also implement a recommendation engine to recommend products
    to your customers, and you will use internationalization to offer your site in
    multiple languages.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '在本章中，你将启动一个新的Django项目，该项目包含一个功能齐全的在线商店。本章和接下来的两章将向你展示如何构建电子商务平台的基本功能。你的在线商店将使客户能够浏览产品，将它们添加到购物车，应用折扣代码，完成结账流程，使用信用卡支付，并获得发票。你还将实现一个推荐引擎向你的客户推荐产品，并使用国际化将你的网站提供多种语言。 '
- en: 'In this chapter, you will learn how to:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何：
- en: Create a product catalog
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建产品目录
- en: Build a shopping cart using Django sessions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Django会话构建购物车
- en: Create custom template context processors
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义模板上下文处理器
- en: Manage customer orders
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理客户订单
- en: Configure Celery in your project with RabbitMQ as a message broker
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的项目中配置Celery使用RabbitMQ作为消息代理
- en: Send asynchronous notifications to customers using Celery
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Celery向客户发送异步通知
- en: Monitor Celery using Flower
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Flower监控Celery
- en: Functional overview
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能概述
- en: '*Figure 8.1* shows a representation of the views, templates, and main functionalities
    that will be built in this chapter:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8.1*展示了本章将要构建的视图、模板和主要功能：'
- en: '![](img/B21088_08_01.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图8.1](img/B21088_08_01.png)'
- en: 'Figure 8.1: Diagram of functionalities built in Chapter 8'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1：第8章中构建的功能图
- en: In this chapter, you will implement the `product_list` view to list all products
    and the `product_detail` view to display a single product. You will allow filtering
    products by category in the `product_list` view using the `category_slug` parameter.
    You will implement a shopping cart using sessions and you will build the `cart_detail`
    view to display the cart items. You will create the `cart_add` view to add products
    to the cart and update quantities, and the `cart_remove` view to remove products
    from the cart. You will implement the `cart` template context processor to display
    the number of cart items and total cost on the site header. You will also create
    the `order_create` view to place orders, and you will use Celery to implement
    the `order_created` asynchronous task that sends out an email confirmation to
    clients when they place an order. This chapter will provide you with the knowledge
    to implement user sessions in your application and show you how to work with asynchronous
    tasks. Both are very common use cases that you can apply to almost any project.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将实现`product_list`视图以列出所有产品，以及`product_detail`视图以显示单个产品。你将在`product_list`视图中使用`category_slug`参数允许按类别过滤产品。你将使用会话实现购物车，并构建`cart_detail`视图以显示购物车项目。你将创建`cart_add`视图以向购物车添加产品并更新数量，以及`cart_remove`视图以从购物车中删除产品。你将实现`cart`模板上下文处理器以在网站页眉上显示购物车项目数量和总成本。你还将创建`order_create`视图以放置订单，并使用Celery实现`order_created`异步任务，在客户下单时向他们发送电子邮件确认。本章将为你提供在应用程序中实现用户会话的知识，并展示如何处理异步任务。这两者都是非常常见的用例，你可以将它们应用到几乎任何项目中。
- en: The source code for this chapter can be found at [https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter08](https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter08).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可以在[https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter08](https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter08)找到。
- en: All Python modules used in this chapter are included in the `requirements.txt`
    file in the source code that comes along with this chapter. You can follow the
    instructions to install each Python module below or you can install all requirements
    at once with the command `python` `-m` `pip` `install` `-r` `requirements.txt`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的所有Python模块都包含在本章源代码中的`requirements.txt`文件中。你可以按照以下说明安装每个Python模块，或者你可以使用命令`python
    -m pip install -r requirements.txt`一次性安装所有需求。
- en: Creating an online shop project
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建在线商店项目
- en: 'Let’s start with a new Django project to build an online shop. Your users will
    be able to browse through a product catalog and add products to a shopping cart.
    Finally, they will be able to check out the cart and place an order. This chapter
    will cover the following functionalities of an online shop:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个新的Django项目开始，构建一个在线商店。您的用户将能够浏览产品目录并将产品添加到购物车。最后，他们可以结账并下单。本章将涵盖以下在线商店的功能：
- en: Creating the product catalog models, adding them to the administration site,
    and building the basic views to display the catalog
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建产品目录模型，将它们添加到管理站点，并构建基本视图以显示目录
- en: Building a shopping cart system using Django sessions to allow users to keep
    selected products while they browse the site
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Django会话构建购物车系统，允许用户在浏览网站时保留所选产品
- en: Creating the form and functionality to place orders on the site
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建表单和功能，以便在网站上放置订单
- en: Sending an asynchronous email confirmation to users when they place an order
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户下单时，发送异步电子邮件确认给用户
- en: 'Open a shell and use the following command to create a new virtual environment
    for this project within the `env/` directory:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 打开shell并使用以下命令在`env/`目录内为该项目创建一个新的虚拟环境：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you are using Linux or macOS, run the following command to activate your
    virtual environment:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用Linux或macOS，请运行以下命令以激活您的虚拟环境：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you are using Windows, use the following command instead:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用Windows，请使用以下命令代替：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The shell prompt will display your active virtual environment, as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 壳提示将显示您的活动虚拟环境，如下所示：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Install Django in your virtual environment with the following command:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令在虚拟环境中安装Django：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Start a new project called `myshop` with an application called `shop` by opening
    a shell and running the following command:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 通过打开shell并运行以下命令来启动一个名为`myshop`的新项目，其中包含一个名为`shop`的应用程序：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The initial project structure has been created. Use the following commands
    to get into your project directory and create a new application named `shop`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 初始项目结构已创建。使用以下命令进入您的项目目录并创建一个名为`shop`的新应用程序：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Edit `settings.py` and add the following line highlighted in bold to the `INSTALLED_APPS`
    list:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`settings.py`并在`INSTALLED_APPS`列表中添加以下加粗的行：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Your application is now active for this project. Let’s define the models for
    the product catalog.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用程序现在已为此项目激活。让我们定义产品目录的模型。
- en: Creating product catalog models
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建产品目录模型
- en: The catalog of your shop will consist of products that are organized into different
    categories. Each product will have a name, an optional description, an optional
    image, a price, and its availability.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 您的商店目录将由组织成不同类别的产品组成。每个产品将有一个名称、可选的描述、可选的图片、价格和其可用性。
- en: 'Edit the `models.py` file of the `shop` application that you just created and
    add the following code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑您刚刚创建的`shop`应用程序的`models.py`文件，并添加以下代码：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: These are the `Category` and `Product` models. The `Category` model consists
    of a `name` field and a unique `slug` field (`unique` implies the creation of
    an index). In the `Meta` class of the `Category` model, we have defined an index
    for the `name` field.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是`Category`和`Product`模型。`Category`模型由一个`name`字段和一个唯一的`slug`字段组成（`unique`意味着创建一个索引）。在`Category`模型的`Meta`类中，我们为`name`字段定义了一个索引。
- en: 'The `Product` model fields are as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`Product`模型字段如下：'
- en: '`category`: A `ForeignKey` to the `Category` model. This is a one-to-many relationship:
    a product belongs to one category and a category contains multiple products.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`category`：到`Category`模型的`ForeignKey`。这是一个一对一的关系：一个产品属于一个类别，一个类别包含多个产品。'
- en: '`name`: The name of the product.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`：产品的名称。'
- en: '`slug`: The slug for this product to build beautiful URLs.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`slug`：用于构建美观URL的此产品的slug。'
- en: '`image`: An optional product image.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`image`：可选的产品图片。'
- en: '`description`: An optional description of the product.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`description`：产品的可选描述。'
- en: '`price`: This field uses Python’s `decimal.Decimal` type to store a fixed-precision
    decimal number. The maximum number of digits (including the decimal places) is
    set using the `max_digits` attribute and decimal places with the `decimal_places`
    attribute.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`price`：此字段使用Python的`decimal.Decimal`类型来存储一个固定精度的十进制数。最大数字数（包括小数点）是通过`max_digits`属性设置的，小数位数是通过`decimal_places`属性设置的。'
- en: '`available`: A Boolean value that indicates whether the product is available
    or not. It will be used to enable/disable the product in the catalog.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`available`：一个布尔值，表示产品是否可用。它将用于在目录中启用/禁用产品。'
- en: '`created`: This field stores when the object was created.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`created`：此字段存储对象的创建时间。'
- en: '`updated`: This field stores when the object was last updated.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`updated`：此字段存储对象最后更新的时间。'
- en: For the `price` field, we use `DecimalField` instead of `FloatField` to avoid
    rounding issues.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `price` 字段，我们使用 `DecimalField` 而不是 `FloatField` 来避免四舍五入问题。
- en: Always use `DecimalField` to store monetary amounts. `FloatField` uses Python’s
    `float` type internally, whereas `DecimalField` uses Python’s `Decimal` type.
    By using the `Decimal` type, you will avoid `float` rounding issues.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 总是使用 `DecimalField` 来存储货币金额。`FloatField` 在内部使用 Python 的 `float` 类型，而 `DecimalField`
    使用 Python 的 `Decimal` 类型。通过使用 `Decimal` 类型，你可以避免 `float` 四舍五入的问题。
- en: In the `Meta` class of the `Product` model, we have defined a multiple-field
    index for the `id` and `slug` fields. Both fields are indexed together to improve
    performance for queries that utilize the two fields.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Product` 模型的 `Meta` 类中，我们为 `id` 和 `slug` 字段定义了一个多字段索引。这两个字段一起索引以提高使用这两个字段的查询性能。
- en: We plan to query products by both `id` and `slug`. We have added an index for
    the `name` field and an index for the `created` field. We have used a hyphen before
    the field name to define the index in descending order.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们计划通过 `id` 和 `slug` 两个字段查询产品。我们为 `name` 字段添加了一个索引，并为 `created` 字段添加了一个索引。我们在字段名前使用了一个连字符来定义降序索引。
- en: '*Figure 8.2* shows the two data models you have created:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8.2* 展示了你创建的两个数据模型：'
- en: '![Diagram  Description automatically generated](img/B21088_08_02.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图描述自动生成](img/B21088_08_02.png)'
- en: 'Figure 8.2: Models for the product catalog'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2：产品目录的模型
- en: In *Figure 8.2*, you can see the different fields of the data models and the
    one-to-many relationship between the `Category` and the `Product` models.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图8.2* 中，你可以看到数据模型的不同字段以及 `Category` 和 `Product` 模型之间的一对多关系。
- en: 'These models will result in the following database tables displayed in *Figure
    8.3*:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模型将导致 *图8.3* 中显示的以下数据库表：
- en: '![A picture containing diagram  Description automatically generated](img/B21088_08_03.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![包含图的图片描述自动生成](img/B21088_08_03.png)'
- en: 'Figure 8.3: Database tables for the product catalog models'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3：产品目录模型的数据表
- en: The one-to-many relationship between both tables is defined with the `category_id`
    field in the `shop_product` table, which is used to store the ID of the related
    `Category` for each `Product` object.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 两个表之间的一对多关系是通过 `shop_product` 表中的 `category_id` 字段定义的，该字段用于存储每个 `Product` 对象相关联的
    `Category` 的 ID。
- en: 'Let’s create the initial database migrations for the `shop` application. Since
    you are going to deal with images in your models, you will need to install the
    Pillow library. Remember that in *Chapter 4*, *Building a Social Website*, you
    learned how to install the Pillow library to manage images. Open the shell and
    install `Pillow` with the following command:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为 `shop` 应用程序创建初始的数据库迁移。由于你将在模型中处理图像，你需要安装 Pillow 库。记住，在 *第4章*，*构建社交网站* 中，你学习了如何安装
    Pillow 库来管理图像。打开 shell 并使用以下命令安装 `Pillow`：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now run the next command to create initial migrations for your project:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行下一个命令来为你的项目创建初始迁移：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You will see the following output:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到以下输出：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Run the next command to sync the database:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 运行下一个命令来同步数据库：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You will see output that includes the following line:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到包含以下行的输出：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The database is now synced with your models.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库现在与你的模型同步了。
- en: Registering catalog models on the administration site
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在管理站点注册目录模型
- en: 'Let’s add your models to the administration site so that you can easily manage
    categories and products. Edit the `admin.py` file of the `shop` application and
    add the following code to it:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加你的模型到管理站点，这样你可以轻松地管理类别和产品。编辑 `shop` 应用的 `admin.py` 文件，并向其中添加以下代码：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Remember that you use the `prepopulated_fields` attribute to specify fields
    where the value is automatically set using the value of other fields. As you have
    seen before, this is convenient for generating slugs.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，你使用 `prepopulated_fields` 属性来指定值自动使用其他字段的值来设置的字段。正如你之前看到的，这对于生成 slugs 很方便。
- en: You use the `list_editable` attribute in the `ProductAdmin` class to set the
    fields that can be edited from the list display page of the administration site.
    This will allow you to edit multiple rows at once. Any field in `list_editable`
    must also be listed in the `list_display` attribute since only the fields displayed
    can be edited.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 您在`ProductAdmin`类中使用`list_editable`属性来设置可以从管理网站的列表显示页面编辑的字段。这将允许您一次性编辑多行。`list_editable`中的任何字段也必须在`list_display`属性中列出，因为只有显示的字段可以编辑。
- en: 'Now create a superuser for your site using the following command:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用以下命令为您网站创建一个超级用户：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Enter the desired username, email, and password. Run the development server
    with the following command:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 输入所需的用户名、电子邮件和密码。使用以下命令运行开发服务器：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Open `http://127.0.0.1:8000/admin/shop/product/add/` in your browser and log
    in with the user that you just created. Add a new category and product using the
    administration interface. The **Add product** form should look as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的浏览器中打开`http://127.0.0.1:8000/admin/shop/product/add/`并使用您刚刚创建的用户登录。使用管理界面添加一个新的类别和产品。**添加产品**表单应如下所示：
- en: '![](img/B21088_08_04.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21088_08_04.png)'
- en: 'Figure 8.4: The product creation form'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4：产品创建表单
- en: 'Click on the **SAVE** button. The product change list page of the administration
    page will then look like this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**保存**按钮。此时，管理页面的产品更改列表页面将看起来如下：
- en: '![](img/B21088_08_05.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21088_08_05.png)'
- en: 'Figure 8.5: The product change list page'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5：产品更改列表页面
- en: Building catalog views
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建目录视图
- en: 'In order to display the product catalog, you need to create a view to list
    all the products or filter products by a given category. Edit the `views.py` file
    of the `shop` application and add the following code highlighted in bold:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示产品目录，您需要创建一个视图来列出所有产品或根据给定的类别过滤产品。编辑`shop`应用的`views.py`文件，并添加以下加粗代码：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding code, you filter the `QuerySet` with `available=True` to retrieve
    only available products. You use an optional `category_slug` parameter to optionally
    filter products by a given category.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，您使用`available=True`过滤`QuerySet`以仅检索可用的产品。您使用可选的`category_slug`参数以可选方式根据给定的类别过滤产品。
- en: 'You also need a view to retrieve and display a single product. Add the following
    view to the `views.py` file:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要一个视图来检索和显示单个产品。将以下视图添加到`views.py`文件中：
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `product_detail` view expects the `id` and `slug` parameters in order to
    retrieve the `Product` instance. You can get this instance just through the ID
    since it’s a unique attribute. However, you include the slug in the URL to build
    SEO-friendly URLs for products.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`product_detail`视图期望`id`和`slug`参数以便检索`Product`实例。由于它是一个唯一属性，您可以通过ID直接获取此实例。然而，您在URL中包含slug以构建对产品友好的SEO
    URL。'
- en: 'After building the product list and detail views, you have to define URL patterns
    for them. Create a new file inside the `shop` application directory and name it
    `urls.py`. Add the following code to it:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建产品列表和详细视图之后，您必须为它们定义URL模式。在`shop`应用目录内创建一个新文件，并将其命名为`urls.py`。向其中添加以下代码：
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'These are the URL patterns for your product catalog. You have defined two different
    URL patterns for the `product_list` view: a pattern named `product_list`, which
    calls the `product_list` view without any parameters, and a pattern named `product_list_by_category`,
    which provides a `category_slug` parameter to the view for filtering products
    according to a given category. You added a pattern for the `product_detail` view,
    which passes the `id` and `slug` parameters to the view in order to retrieve a
    specific product.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是您产品目录的URL模式。您为`product_list`视图定义了两个不同的URL模式：一个名为`product_list`的模式，它调用不带任何参数的`product_list`视图，以及一个名为`product_list_by_category`的模式，它为视图提供一个`category_slug`参数以根据给定的类别过滤产品。您还添加了一个`product_detail`视图的模式，该模式将`id`和`slug`参数传递给视图以检索特定产品。
- en: 'Edit the `urls.py` file of the `myshop` project to make it look like this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`myshop`项目的`urls.py`文件，使其看起来如下所示：
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the main URL patterns of the project, you include URLs for the `shop` application
    under a custom namespace named `shop`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目的URL主模式中，您在名为`shop`的自定义命名空间下包含`shop`应用的URL。
- en: 'Next, edit the `models.py` file of the `shop` application, import the `reverse()`
    function, and add a `get_absolute_url()` method to the `Category` and `Product`
    models, as follows. The new code is highlighted in bold:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，编辑`shop`应用的`models.py`文件，导入`reverse()`函数，并为`Category`和`Product`模型添加一个`get_absolute_url()`方法，如下所示。新的代码已加粗：
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As you already know, `get_absolute_url()` is the convention to retrieve the
    URL for a given object. Here, you use the URL patterns that you just defined in
    the `urls.py` file.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所知，`get_absolute_url()` 是检索给定对象 URL 的约定。在这里，您使用在 `urls.py` 文件中刚刚定义的 URL 模式。
- en: Creating catalog templates
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建目录模板
- en: 'Now you need to create templates for the product list and detail views. Create
    the following directory and file structure inside the `shop` application directory:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您需要在产品列表和详情视图创建模板。在 `shop` 应用程序目录内创建以下目录和文件结构：
- en: '[PRE22]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You need to define a base template and then extend it in the product list and
    detail templates. Edit the `shop/base.html` template and add the following code
    to it:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要定义一个基本模板，然后在产品列表和详情模板中扩展它。编辑 `shop/base.html` 模板，并向其中添加以下代码：
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This is the base template that you will use for your shop. In order to include
    the CSS styles and images that are used by the templates, you need to copy the
    static files that accompany this chapter, which are located in the `static/` directory
    of the `shop` application. Copy them to the same location in your project. You
    can find the contents of the directory at [https://github.com/PacktPublishing/Django-5-by-Example/tree/main/Chapter08/myshop/shop/static](https://github.com/PacktPublishing/Django-5-by-Example/tree/main/Chapter08/myshop/shop/static).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您将用于商店的基本模板。为了包含模板使用的 CSS 样式和图像，您需要复制本章附带的静态文件，这些文件位于 `shop` 应用程序的 `static/`
    目录中。将它们复制到项目中的同一位置。您可以在 [https://github.com/PacktPublishing/Django-5-by-Example/tree/main/Chapter08/myshop/shop/static](https://github.com/PacktPublishing/Django-5-by-Example/tree/main/Chapter08/myshop/shop/static)
    找到目录的内容。
- en: 'Edit the `shop/product/list.html` template and add the following code to it:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑 `shop/product/list.html` 模板，并向其中添加以下代码：
- en: '[PRE24]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Make sure that no template tag is split across multiple lines.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 确保没有模板标签被拆分到多行。
- en: This is the product list template. It extends the `shop/base.html` template
    and uses the `categories` context variable to display all the categories in a
    sidebar, and `products` to display the products of the current page. The same
    template is used for both listing all available products and listing products
    filtered by category. Since the `image` field of the `Product` model can be blank,
    you need to provide a default image for the products that don’t have an image.
    The image is located in your static files directory with the relative path `img/no_image.png`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这是产品列表模板。它扩展了 `shop/base.html` 模板，并使用 `categories` 上下文变量在侧边栏中显示所有类别，以及 `products`
    来显示当前页面的产品。相同的模板用于列出所有可用的产品和按类别过滤的产品。由于 `Product` 模型的 `image` 字段可能为空，您需要为没有图像的产品提供一个默认图像。该图像位于您的静态文件目录中，相对路径为
    `img/no_image.png`。
- en: Since you are using `ImageField` to store product images, you need the development
    server to serve uploaded image files.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您正在使用 `ImageField` 存储产品图像，您需要开发服务器来提供上传的图像文件。
- en: 'Edit the `settings.py` file of `myshop` and add the following settings:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑 `myshop` 的 `settings.py` 文件，并添加以下设置：
- en: '[PRE25]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`MEDIA_URL` is the base URL that serves media files uploaded by users. `MEDIA_ROOT`
    is the local path where these files reside, which you build by dynamically prepending
    the `BASE_DIR` variable.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`MEDIA_URL` 是为用户上传的媒体文件提供服务的基准 URL。`MEDIA_ROOT` 是这些文件所在的本地路径，您通过动态地将 `BASE_DIR`
    变量前置来构建它。'
- en: 'For Django to serve the uploaded media files using the development server,
    edit the main `urls.py` file of `myshop` and add the following code highlighted
    in bold:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让 Django 使用开发服务器提供上传的媒体文件，编辑 `myshop` 的主 `urls.py` 文件，并添加以下加粗代码：
- en: '[PRE26]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Remember that you only serve static files this way during development. In a
    production environment, you should never serve static files with Django; the Django
    development server doesn’t serve static files in an efficient manner. *Chapter
    17*, *Going Live*, will teach you how to serve static files in a production environment.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，您只在开发期间以这种方式提供静态文件。在生产环境中，您永远不应该使用 Django 提供静态文件；Django 开发服务器以低效的方式提供静态文件。第
    17 章，“上线”，将教您如何在生产环境中提供静态文件。
- en: 'Run the development server with the following command:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令运行开发服务器：
- en: '[PRE27]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Add a couple of products to your shop using the administration site and open
    `http://127.0.0.1:8000/` in your browser. You will see the product list page,
    which will look similar to this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用管理站点添加一些产品到您的商店，并在浏览器中打开 `http://127.0.0.1:8000/`。您将看到产品列表页面，其外观将类似于以下：
- en: '![Graphical user interface, website  Description automatically generated](img/B21088_08_06.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，网站，自动生成的描述](img/B21088_08_06.png)'
- en: 'Figure 8.6: The product list page'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6：产品列表页面
- en: 'Credits for images in this chapter:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 本章图片的版权：
- en: '*Green tea*: Photo by Jia Ye on Unsplash'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*绿茶*：由Jia Ye在Unsplash上的照片'
- en: '*Red tea*: Photo by Manki Kim on Unsplash'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*红茶*：由Manki Kim在Unsplash上的照片'
- en: '*Tea powder*: Photo by Phuong Nguyen on Unsplash'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*茶粉*：由Phuong Nguyen在Unsplash上的照片'
- en: 'If you create a product using the administration site and don’t upload an image
    for it, the default `no_image.png` image will be displayed instead:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用管理站点创建产品而没有为其上传图片，将显示默认的`no_image.png`图片：
- en: '![](img/B21088_08_07.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21088_08_07.png)'
- en: 'Figure 8.7: The product list displaying a default image for products that have
    no image'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7：显示默认图片的产品列表，这些产品没有图片
- en: 'Edit the `shop/product/detail.html` template and add the following code to
    it:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`shop/product/detail.html`模板，并向其中添加以下代码：
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the preceding code, you call the `get_absolute_url()` method on the related
    category object to display the available products that belong to the same category.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，您在相关类别对象上调用`get_absolute_url()`方法来显示属于同一类别的可用产品。
- en: 'Now open `http://127.0.0.1:8000/` in your browser and click on any product
    to see the product detail page. It will look as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在您的浏览器中打开`http://127.0.0.1:8000/`，并点击任何产品以查看产品详情页面。它看起来如下所示：
- en: '![Graphical user interface, text, application  Description automatically generated](img/B21088_08_08.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序，自动生成的描述](img/B21088_08_08.png)'
- en: 'Figure 8.8: The product detail page'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8：产品详情页面
- en: You have now created a basic product catalog. Next, you will implement a shopping
    cart that allows users to add any product to it while browsing the online shop.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已创建了一个基本的产品目录。接下来，您将实现一个购物车，允许用户在浏览在线商店时添加任何产品。
- en: Building a shopping cart
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建购物车
- en: After building the product catalog, the next step is to create a shopping cart
    so that users can pick the products that they want to purchase. A shopping cart
    allows users to select products and set the amount they want to order, and then
    store this information temporarily while they browse the site until they eventually
    place an order. The cart has to be persisted in the session so that the cart items
    are maintained during a user’s visit.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建产品目录之后，下一步是创建购物车，以便用户可以选择他们想要购买的产品。购物车允许用户选择产品并设置他们想要订购的数量，然后在浏览网站期间暂时存储此信息，直到他们最终下订单。购物车必须保持在会话中，以便在用户访问期间保持购物车项目。
- en: You will use Django’s session framework to persist the cart. The cart will be
    kept in the session until it finishes or the user checks out the cart. You will
    also need to build additional Django models for the cart and its items.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 您将使用Django的会话框架来持久化购物车。购物车将保持在会话中，直到完成或用户结账购物车。您还需要为购物车及其项目构建额外的Django模型。
- en: Using Django sessions
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Django会话
- en: Django provides a session framework that supports anonymous and user sessions.
    The session framework allows you to store arbitrary data for each visitor. Session
    data is stored on the server side, and cookies contain the session ID unless you
    use the cookie-based session engine. The session middleware manages the sending
    and receiving of cookies. The default session engine stores session data in the
    database, but you can choose other session engines.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Django提供了一个支持匿名和用户会话的会话框架。会话框架允许您为每个访客存储任意数据。会话数据存储在服务器端，除非您使用基于cookie的会话引擎，否则cookie包含会话ID。会话中间件管理cookie的发送和接收。默认会话引擎将会话数据存储在数据库中，但您可以选择其他会话引擎。
- en: To use sessions, you have to make sure that the `MIDDLEWARE` setting of your
    project contains `django.contrib.sessions.middleware.SessionMiddleware`. This
    middleware manages sessions. It’s added by default to the `MIDDLEWARE` setting
    when you create a new project using the `startproject` command.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用会话，您必须确保项目的`MIDDLEWARE`设置包含`django.contrib.sessions.middleware.SessionMiddleware`。此中间件管理会话。当您使用`startproject`命令创建新项目时，它默认添加到`MIDDLEWARE`设置中。
- en: 'The session middleware makes the current session available in the `request`
    object. You can access the current session using `request.session`, treating it
    like a Python dictionary to store and retrieve session data. The `session` dictionary
    accepts any Python object by default that can be serialized to JSON. You can set
    a variable in the session like this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 会话中间件使当前会话在`request`对象中可用。您可以使用`request.session`访问当前会话，将其视为Python字典来存储和检索会话数据。默认情况下，`session`字典接受任何可以序列化为JSON的Python对象。您可以这样在会话中设置变量：
- en: '[PRE29]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You can retrieve a session key as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以按照以下方式检索会话键：
- en: '[PRE30]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You can delete a key you previously stored in the session as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以按照以下方式删除之前存储在会话中的键：
- en: '[PRE31]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: When users log in to the site, their anonymous session is lost, and a new session
    is created for authenticated users. If you store items in an anonymous session
    that you need to keep after the user logs in, you will have to copy the old session
    data into the new session. You can do this by retrieving the session data before
    you log in the user using the `login()` function of the Django authentication
    system and storing it in the session after that.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户登录到网站时，他们的匿名会话会丢失，并为认证用户创建一个新的会话。如果您在匿名会话中存储了在用户登录后需要保留的项目，您必须将旧会话数据复制到新会话中。您可以通过在Django认证系统的`login()`函数登录用户之前检索会话数据，并在之后将其存储在会话中来实现这一点。
- en: Session settings
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 会话设置
- en: There are several settings you can use to configure sessions for your project.
    The most important is `SESSION_ENGINE`. This setting allows you to set the place
    where sessions are stored. By default, Django stores sessions in the database
    using the `Session` model of the `django.contrib.sessions` application.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用几个设置来配置项目的会话。其中最重要的是`SESSION_ENGINE`。此设置允许您设置会话存储的位置。默认情况下，Django使用`django.contrib.sessions`应用程序的`Session`模型在数据库中存储会话。
- en: 'Django offers the following options for storing session data:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Django为存储会话数据提供了以下选项：
- en: '**Database sessions**: Session data is stored in the database. This is the
    default session engine.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据库会话**：会话数据存储在数据库中。这是默认的会话引擎。'
- en: '**File-based sessions**: Session data is stored in the filesystem.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于文件的会话**：会话数据存储在文件系统中。'
- en: '**Cached sessions**: Session data is stored in a cache backend. You can specify
    cache backends using the `CACHES` setting. Storing session data in a cache system
    provides the best performance.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓存会话**：会话数据存储在缓存后端中。您可以使用`CACHES`设置指定缓存后端。在缓存系统中存储会话数据提供了最佳性能。'
- en: '**Cached database sessions**: Session data is stored in a write-through cache
    and database. Reads only use the database if the data is not already in the cache.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓存数据库会话**：会话数据存储在写入缓存和数据库中。如果数据不在缓存中，则只使用数据库进行读取。'
- en: '**Cookie-based sessions**: Session data is stored in the cookies that are sent
    to the browser.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于cookie的会话**：会话数据存储在发送到浏览器的cookie中。'
- en: For better performance use a cache-based session engine. Django supports Memcached
    out of the box and you can find third-party cache backends for Redis and other
    cache systems.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好的性能，请使用基于缓存的会话引擎。Django默认支持Memcached，您可以在Redis和其他缓存系统中找到第三方缓存后端。
- en: 'You can customize sessions with specific settings. Here are some of the important
    session-related settings:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用特定的设置来自定义会话。以下是一些重要的与会话相关的设置：
- en: '`SESSION_COOKIE_AGE`: The duration of session cookies in seconds. The default
    value is `1209600` (two weeks).'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SESSION_COOKIE_AGE`：会话cookie的持续时间（以秒为单位）。默认值为`1209600`（两周）。'
- en: '`SESSION_COOKIE_DOMAIN`: The domain used for session cookies. Set this to `mydomain.com`
    to enable cross-domain cookies or use `None` for a standard domain cookie.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SESSION_COOKIE_DOMAIN`：用于会话cookie的域名。将其设置为`mydomain.com`以启用跨域cookie，或使用`None`以使用标准域名cookie。'
- en: '`SESSION_COOKIE_HTTPONLY`: Whether to use the `HttpOnly` flag on the session
    cookie. If this is set to `True`, client-side JavaScript will not be able to access
    the session cookie. The default value is `True` for increased security against
    user session hijacking.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SESSION_COOKIE_HTTPONLY`：是否在会话cookie上使用`HttpOnly`标志。如果设置为`True`，客户端JavaScript将无法访问会话cookie。默认值为`True`，以提高对用户会话劫持的安全性。'
- en: '`SESSION_COOKIE_SECURE`: A Boolean indicating that the cookie should only be
    sent if the connection is an HTTPS connection. The default value is `False`.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SESSION_COOKIE_SECURE`：一个布尔值，表示只有在连接是HTTPS连接时才发送cookie。默认值为`False`。'
- en: '`SESSION_EXPIRE_AT_BROWSER_CLOSE`: A Boolean indicating that the session has
    to expire when the browser is closed. The default value is `False`.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SESSION_EXPIRE_AT_BROWSER_CLOSE`：一个布尔值，表示会话必须在浏览器关闭时过期。默认值为`False`。'
- en: '`SESSION_SAVE_EVERY_REQUEST`: A Boolean that, if `True`, will save the session
    to the database on every request. The session expiration is also updated each
    time it’s saved. The default value is `False`.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SESSION_SAVE_EVERY_REQUEST`：一个布尔值，如果为`True`，则在每个请求上都将会话保存到数据库中。每次保存时，会话过期时间也会更新。默认值为`False`。'
- en: You can see all the session settings and their default values at [https://docs.djangoproject.com/en/5.0/ref/settings/#sessions](https://docs.djangoproject.com/en/5.0/ref/settings/#sessions).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://docs.djangoproject.com/en/5.0/ref/settings/#sessions](https://docs.djangoproject.com/en/5.0/ref/settings/#sessions)中查看所有会话设置及其默认值。
- en: Session expiration
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 会话过期
- en: You can choose to use browser-length sessions or persistent sessions using the
    `SESSION_EXPIRE_AT_BROWSER_CLOSE` setting. This is set to `False` by default,
    forcing the session duration to the value stored in the `SESSION_COOKIE_AGE` setting.
    If you set `SESSION_EXPIRE_AT_BROWSER_CLOSE` to `True`, the session will expire
    when the user closes the browser, and the `SESSION_COOKIE_AGE` setting will not
    have any effect.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以选择使用浏览器长度会话或使用`SESSION_EXPIRE_AT_BROWSER_CLOSE`设置来使用持久会话。默认情况下，此设置为`False`，强制会话持续时间等于`SESSION_COOKIE_AGE`设置中存储的值。如果您将`SESSION_EXPIRE_AT_BROWSER_CLOSE`设置为`True`，则当用户关闭浏览器时，会话将过期，并且`SESSION_COOKIE_AGE`设置将没有任何效果。
- en: You can use the `set_expiry()` method of `request.session` to overwrite the
    duration of the current session.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`request.session`的`set_expiry()`方法来覆盖当前会话的持续时间。
- en: Storing shopping carts in sessions
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在会话中存储购物车
- en: 'You need to create a simple structure that can be serialized to JSON for storing
    cart items in a session. The cart has to include the following data for each item
    contained in it:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要创建一个简单的结构，可以序列化为JSON，以便在会话中存储购物车项目。购物车必须包含以下数据，对于其中包含的每个项目：
- en: The ID of a `Product` instance
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Product`实例的ID'
- en: The quantity selected for the product
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为产品选择数量
- en: The unit price for the product
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品的单价
- en: Since product prices may vary, let’s take the approach of storing the product’s
    price along with the product itself when it’s added to the cart. By doing so,
    you use the current price of the product when users add it to their cart, no matter
    whether the product’s price is changed afterward. This means that the price that
    the item has when the client adds it to the cart is maintained for that client
    in the session until checkout is completed or the session finishes.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 由于产品价格可能不同，让我们在将产品添加到购物车时，将产品的价格与其本身一起存储。这样做，无论产品价格之后是否更改，用户添加到购物车时都使用产品的当前价格。这意味着当客户端将项目添加到购物车时，该项目的价格在会话中保持不变，直到结账完成或会话结束。
- en: 'Next, you have to build functionality to create shopping carts and associate
    them with sessions. This has to work as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您必须构建创建购物车并将其与会话关联的功能。这必须按照以下方式工作：
- en: When a cart is needed, you check whether a custom session key is set. If no
    cart is set in the session, you create a new cart and save it in the cart session
    key.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当需要购物车时，您需要检查是否设置了自定义会话密钥。如果会话中没有设置购物车，您将创建一个新的购物车并将其保存在购物车会话密钥中。
- en: For successive requests, you perform the same check and get the cart items from
    the cart session key. You retrieve the cart items from the session and their related
    `Product` objects from the database.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于后续请求，您将执行相同的检查，并从购物车会话密钥中获取购物车项目。您从会话中检索购物车项目及其相关的`Product`对象从数据库中。
- en: 'Edit the `settings.py` file of your project and add the following setting to
    it:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑您项目的`settings.py`文件，并添加以下设置：
- en: '[PRE32]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This is the key that you are going to use to store the cart in the user session.
    Since Django sessions are managed per visitor, you can use the same cart session
    key for all sessions.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您将要用来在用户会话中存储购物车的密钥。由于Django会话是按访客管理的，因此您可以为所有会话使用相同的购物车会话密钥。
- en: 'Let’s create an application for managing shopping carts. Open the terminal
    and create a new application, running the following command from the project directory:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个用于管理购物车的应用程序。打开终端，在项目目录中创建一个新的应用程序，运行以下命令：
- en: '[PRE33]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then, edit the `settings.py` file of your project and add the new application
    to the `INSTALLED_APPS` setting with the following line highlighted in bold:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，编辑您项目的`settings.py`文件，并将新应用程序添加到`INSTALLED_APPS`设置中，以下行以粗体突出显示：
- en: '[PRE34]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Create a new file inside the `cart` application directory and name it `cart.py`.
    Add the following code to it:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在`cart`应用程序目录内创建一个新文件，并将其命名为`cart.py`。将以下代码添加到其中：
- en: '[PRE35]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This is the `Cart` class that will allow you to manage the shopping cart. You
    require the cart to be initialized with a `request` object. You store the current
    session using `self.session = request.session` to make it accessible to the other
    methods of the `Cart` class.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个允许您管理购物车的`Cart`类。您需要将购物车初始化为一个`request`对象。您使用`self.session = request.session`来存储当前会话，以便其他`Cart`类的方法可以访问它。
- en: First, you try to get the cart from the current session using `self.session.get(settings.CART_SESSION_ID)`.
    If no cart is present in the session, you create an empty cart by setting an empty
    dictionary in the session.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您尝试使用`self.session.get(settings.CART_SESSION_ID)`从当前会话中获取购物车。如果没有购物车存在于会话中，您通过在会话中设置空字典来创建一个空购物车。
- en: You will build your `cart` dictionary with product IDs as keys, and for each
    product key, a dictionary will be a value that includes quantity and price. By
    doing this, you can guarantee that a product will not be added more than once
    to the cart. This way, you can also simplify retrieving cart items.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 您将使用产品ID作为键来构建您的`cart`字典，对于每个产品键，一个包含数量和价格的字典将作为值。通过这种方式，您可以保证产品不会添加到购物车中超过一次。这样，您也可以简化检索购物车项目。
- en: 'Let’s create a method to add products to the cart or update their quantity.
    Add the following `add()` and `save()` methods to the `Cart` class:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个方法来向购物车添加产品或更新它们的数量。将以下`add()`和`save()`方法添加到`Cart`类中：
- en: '[PRE36]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `add()` method takes the following parameters as input:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`add()`方法接受以下参数作为输入：'
- en: '`product`: The `product` instance to add or update in the cart.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`product`：要添加或更新到购物车中的`product`实例。'
- en: '`quantity`: An optional integer with the product quantity. This defaults to
    `1`.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`quantity`：一个可选的整数，表示产品数量。默认为`1`。'
- en: '`override_quantity`: A Boolean that indicates whether the quantity needs to
    be overridden with the given quantity (`True`) or whether the new quantity has
    to be added to the existing quantity (`False`).'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`override_quantity`：一个布尔值，表示是否需要用给定的数量覆盖数量（`True`）或是否需要将新数量添加到现有数量（`False`）。'
- en: You use the product ID as a key in the cart’s content dictionary. You convert
    the product ID into a string because Django uses JSON to serialize session data,
    and JSON only allows string key names. The product ID is the key, and the value
    that you persist is a dictionary with quantity and price figures for the product.
    The product’s price is converted from decimal into a string to serialize it. Finally,
    you call the `save()` method to save the cart in the session.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 您使用产品ID作为购物车内容字典中的键。您将产品ID转换为字符串，因为Django使用JSON序列化会话数据，而JSON只允许字符串键名。产品ID是键，您持久化的值是一个包含产品数量和价格的字典。将产品的价格从十进制转换为字符串以进行序列化。最后，您调用`save()`方法来保存会话中的购物车。
- en: The `save()` method marks the session as modified using `session.modified =
    True`. This tells Django that the session has changed and needs to be saved.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`save()`方法使用`session.modified = True`标记会话为已修改。这告诉Django会话已更改，需要保存。'
- en: 'You also need a method for removing products from the cart. Add the following
    method to the `Cart` class:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要一个从购物车中删除产品的方法。将以下方法添加到`Cart`类中：
- en: '[PRE37]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `remove()` method removes a given product from the `cart` dictionary and
    calls the `save()` method to update the cart in the session.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`remove()`方法从`cart`字典中删除指定的产品，并调用`save()`方法来更新会话中的购物车。'
- en: 'You will have to iterate through the items contained in the cart and access
    the related `Product` instances. To do so, you can define an `__iter__()` method
    in your class. Add the following method to the `Cart` class:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 您将不得不遍历购物车中的项目并访问相关的`Product`实例。为此，您可以在类中定义一个`__iter__()`方法。将以下方法添加到`Cart`类中：
- en: '[PRE38]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In the `__iter__()` method, you retrieve the `Product` instances that are present
    in the cart to include them in the cart items. You copy the current cart in the
    `cart` variable and add the `Product` instances to it. Finally, you iterate over
    the cart items, converting each item’s price back into decimal, and adding a `total_price`
    attribute to each item. This `__iter__()` method will allow you to easily iterate
    over the items in the cart in views and templates.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在`__iter__()`方法中，您检索购物车中存在的`Product`实例以将它们包含在购物车商品中。您将当前购物车复制到`cart`变量中，并将`Product`实例添加到其中。最后，您遍历购物车商品，将每个商品的价格转换回十进制，并为每个商品添加一个`total_price`属性。此`__iter__()`方法将允许您轻松地在视图和模板中遍历购物车中的商品。
- en: You also need a way to return the total number of items in the cart. When the
    `len()` function is executed on an object, Python calls its `__len__()` method
    to retrieve its length. Next, you are going to define a custom `__len__()` method
    to return the total number of items stored in the cart.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要一种方法来返回购物车中商品的总数。当`len()`函数在一个对象上执行时，Python会调用其`__len__()`方法来获取其长度。接下来，您将定义一个自定义的`__len__()`方法来返回存储在购物车中的商品总数。
- en: 'Add the following `__len__()` method to the `Cart` class:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下`__len__()`方法添加到`Cart`类中：
- en: '[PRE39]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: You return the sum of the quantities of all the cart items.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 您返回购物车中所有商品数量的总和。
- en: 'Add the following method to calculate the total cost of the items in the cart:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下方法以计算购物车中商品的总成本：
- en: '[PRE40]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Finally, add a method to clear the cart session:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，添加一个清除购物车会话的方法：
- en: '[PRE41]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Your `Cart` class is now ready to manage shopping carts.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 您的`Cart`类现在已准备好管理购物车。
- en: Creating shopping cart views
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建购物车视图
- en: 'Now that you have a `Cart` class to manage the cart, you need to create the
    views to add, update, or remove items from it. You need to create the following
    views:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您有一个`Cart`类来管理购物车，您需要创建添加、更新或从其中删除商品的视图。您需要创建以下视图：
- en: A view to add or update items in the cart that can handle current and new quantities
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个视图，用于添加或更新购物车中的商品，可以处理当前和新数量
- en: A view to remove items from the cart
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于从购物车中删除商品的视图
- en: A view to display cart items and totals
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于显示购物车商品和总计的视图
- en: Adding items to the cart
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加商品到购物车
- en: 'To add items to the cart, you need a form that allows the user to select a
    quantity. Create a `forms.py` file inside the `cart` application directory and
    add the following code to it:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加商品到购物车，您需要一个允许用户选择数量的表单。在`cart`应用目录内创建一个`forms.py`文件，并将以下代码添加到其中：
- en: '[PRE42]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'You will use this form to add products to the cart. Your `CartAddProductForm`
    class contains the following two fields:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 您将使用此表单添加产品到购物车。您的`CartAddProductForm`类包含以下两个字段：
- en: '`quantity`: This allows the user to select a quantity between 1 and 20\. You
    use a `TypedChoiceField` field with `coerce=int` to convert the input into an
    integer.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`数量`: 这允许用户在1到20之间选择数量。您使用带有`coerce=int`的`TypedChoiceField`字段将输入转换为整数。'
- en: '`override`: This allows you to indicate whether the quantity has to be added
    to any existing quantity in the cart for this product (`False`) or whether the
    existing quantity has to be overridden with the given quantity (`True`). You use
    a `HiddenInput` widget for this field since you don’t want to display it to the
    user.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`覆盖`: 这允许您指示是否需要将数量添加到购物车中此产品的任何现有数量（`False`）或是否需要用给定的数量覆盖现有数量（`True`）。您使用`HiddenInput`小部件为此字段，因为您不希望将其显示给用户。'
- en: 'Let’s create a view for adding items to the cart. Edit the `views.py` file
    of the `cart` application and add the following code highlighted in bold:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个用于添加商品的视图。编辑`cart`应用的`views.py`文件，并添加以下加粗代码：
- en: '[PRE43]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This is the view for adding products to the cart or updating quantities for
    existing products. You use the `require_POST` decorator to allow only `POST` requests.
    The view receives the product ID as a parameter. You retrieve the `Product` instance
    with the given ID and validate `CartAddProductForm`. If the form is valid, you
    either add or update the product in the cart. The view redirects to the `cart_detail`
    URL, which will display the contents of the cart. You are going to create the
    `cart_detail` view shortly.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这是用于添加产品到购物车或更新现有产品数量的视图。您使用`require_POST`装饰器仅允许`POST`请求。视图接收产品ID作为参数。您使用给定的ID检索`Product`实例并验证`CartAddProductForm`。如果表单有效，您将添加或更新购物车中的产品。视图将重定向到`cart_detail`
    URL，该URL将显示购物车的商品。您将很快创建`cart_detail`视图。
- en: 'You also need a view to remove items from the cart. Add the following code
    to the `views.py` file of the `cart` application:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要一个视图来从购物车中删除项目。将以下代码添加到`cart`应用程序的`views.py`文件中：
- en: '[PRE44]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `cart_remove` view receives the product ID as a parameter. You use the `require_POST`
    decorator to allow only `POST` requests. You retrieve the `Product` instance with
    the given ID and remove the product from the cart. Then, you redirect the user
    to the `cart_detail` URL.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`cart_remove`视图接收产品ID作为参数。您使用`require_POST`装饰器只允许`POST`请求。您使用给定的ID检索`Product`实例并将其从购物车中删除。然后，您将用户重定向到`cart_detail`
    URL。'
- en: 'Finally, you need a view to display the cart and its items. Add the following
    view to the `views.py` file of the `cart` application:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您需要一个视图来显示购物车及其项目。将以下视图添加到`cart`应用程序的`views.py`文件中：
- en: '[PRE45]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `cart_detail` view gets the current cart to display it.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`cart_detail`视图获取当前购物车以显示它。'
- en: 'You have created views to add items to the cart, update quantities, remove
    items from the cart, and display the cart’s contents. Let’s add URL patterns for
    these views. Create a new file inside the `cart` application directory and name
    it `urls.py`. Add the following URL patterns to it:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 您已创建了添加项目到购物车、更新数量、从购物车中删除项目和显示购物车内容等的视图。让我们为这些视图添加URL模式。在`cart`应用程序目录内创建一个新文件，并将其命名为`urls.py`。向其中添加以下URL模式：
- en: '[PRE46]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Edit the main `urls.py` file of the `myshop` project and add the following
    URL pattern highlighted in bold to include the cart URLs:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`myshop`项目的主体`urls.py`文件，并添加以下突出显示的URL模式以包含购物车URL：
- en: '[PRE47]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Make sure that you include this URL pattern before the `shop.urls` pattern since
    it’s more restrictive than the latter.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在`shop.urls`模式之前包含此URL模式，因为它比后者更严格。
- en: Building a template to display the cart
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建一个模板来显示购物车
- en: The `cart_add` and `cart_remove` views don’t render any templates, but you need
    to create a template for the `cart_detail` view to display cart items and totals.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`cart_add`和`cart_remove`视图不渲染任何模板，但您需要为`cart_detail`视图创建一个模板来显示购物车项目和总计。'
- en: 'Create the following file structure inside the `cart` application directory:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在`cart`应用程序目录内创建以下文件结构：
- en: '[PRE48]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Edit the `cart/detail.html` template and add the following code to it:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`cart/detail.html`模板，并向其中添加以下代码：
- en: '[PRE49]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Make sure that no template tag is split across multiple lines.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 确保没有模板标签被拆分到多行中。
- en: This is the template that is used to display the cart’s contents. It contains
    a table with the items stored in the current cart. You allow users to change the
    quantity of the selected products using a form that is posted to the `cart_add`
    view. You also allow users to remove items from the cart by providing a **Remove**
    button for each of them. Finally, you use an HTML form with an `action` attribute
    that points to the `cart_remove` URL including the product ID.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这是用于显示购物车内容的模板。它包含一个表格，其中存储了当前购物车中的项目。您允许用户通过提交到`cart_add`视图的表单来更改所选产品的数量。您还允许用户通过为每个项目提供一个**删除**按钮来从购物车中删除项目。最后，您使用一个具有指向包含产品ID的`cart_remove`
    URL的`action`属性的HTML表单。
- en: Adding products to the cart
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加产品到购物车
- en: 'Now you need to add an **Add to cart** button to the product detail page. Edit
    the `views.py` file of the `shop` application and add `CartAddProductForm` to
    the `product_detail` view, as follows:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您需要在产品详情页添加一个**添加到购物车**按钮。编辑`shop`应用程序的`views.py`文件，并将`CartAddProductForm`添加到`product_detail`视图中，如下所示：
- en: '[PRE50]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Edit the `shop/product/detail.html` template of the `shop` application and
    add the following form to the product price, as follows. New lines are highlighted
    in bold:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`shop/product/detail.html`模板，并将以下表单添加到产品价格处，如下所示。新行以粗体突出显示：
- en: '[PRE51]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Run the development server with the following command:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令运行开发服务器：
- en: '[PRE52]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now open `http://127.0.0.1:8000/` in your browser and navigate to a product’s
    detail page. It will contain a form to choose a quantity before adding the product
    to the cart. The page will look like this:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在您的浏览器中打开`http://127.0.0.1:8000/`并导航到产品详情页。它将包含一个表单，在将产品添加到购物车之前选择数量。页面看起来如下所示：
- en: '![Graphical user interface, application  Description automatically generated](img/B21088_08_09.png)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序描述自动生成](img/B21088_08_09.png)'
- en: 'Figure 8.9: The product detail page, including the Add to cart button'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9：产品详情页，包括添加到购物车按钮
- en: 'Choose a quantity and click on the **Add to cart** button. The form is submitted
    to the `cart_add` view via `POST`. The view adds the product to the cart in the
    session, including its current price and the selected quantity. Then, it redirects
    the user to the cart detail page, which will look like *Figure 8.10*:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 选择数量并点击**加入购物车**按钮。表单通过`POST`提交到`cart_add`视图。视图将产品添加到会话中的购物车，包括其当前价格和所选数量。然后，它将用户重定向到购物车详情页面，其外观将类似于*图8.10*：
- en: '![Graphical user interface, timeline  Description automatically generated with
    medium confidence](img/B21088_08_10.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，时间线描述自动生成，中等置信度](img/B21088_08_10.png)'
- en: 'Figure 8.10: The cart detail page'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.10：购物车详情页面
- en: Updating product quantities in the cart
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新购物车中的产品数量
- en: When users see the cart, they might want to change product quantities before
    placing an order. You are going to allow users to change quantities from the cart
    detail page.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户看到购物车时，他们可能在下单前想要更改产品数量。您将允许用户从购物车详情页面更改数量。
- en: 'Edit the `views.py` file of the `cart` application and add the following lines
    highlighted in bold to the `cart_detail` view:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`cart`应用程序的`views.py`文件，并将以下加粗行添加到`cart_detail`视图中：
- en: '[PRE53]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: You create an instance of `CartAddProductForm` for each item in the cart to
    allow changing product quantities. You initialize the form with the current item
    quantity and set the `override` field to `True` so that when you submit the form
    to the `cart_add` view, the current quantity is replaced with the new one.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 您为购物车中的每个项目创建一个`CartAddProductForm`实例，以便更改产品数量。您使用当前项目数量初始化表单，并将`override`字段设置为`True`，这样当您将表单提交给`cart_add`视图时，当前数量将被新数量替换。
- en: 'Now edit the `cart/detail.html` template of the `cart` application and find
    the following line:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在编辑`cart/detail.html`模板中的`cart`应用程序，并找到以下行：
- en: '[PRE54]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Replace the previous line with the following code:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面的行替换为以下代码：
- en: '[PRE55]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Run the development server with the following command:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令运行开发服务器：
- en: '[PRE56]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Open `http://127.0.0.1:8000/cart/` in your browser.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的浏览器中打开`http://127.0.0.1:8000/cart/`。
- en: 'You will see a form to edit the quantity for each cart item, as follows:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到一个用于编辑每个购物车项目数量的表单，如下所示：
- en: '![Graphical user interface, website  Description automatically generated](img/B21088_08_11.png)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，网站描述自动生成](img/B21088_08_11.png)'
- en: 'Figure 8.11: The cart detail page, including the form to update product quantities'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.11：购物车详情页面，包括更新产品数量的表单
- en: Change the quantity of an item and click on the **Update** button to test the
    new functionality. You can also remove an item from the cart by clicking the **Remove**
    button.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 更改项目数量并点击**更新**按钮以测试新功能。您也可以通过点击**删除**按钮从购物车中移除项目。
- en: Creating a context processor for the current cart
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为当前购物车创建上下文处理器
- en: You might have noticed that the message **Your cart is empty** is displayed
    in the header of the site, even when the cart contains items. You should display
    the total number of items in the cart and the total cost instead. Since this has
    to be displayed on all pages, you need to build a context processor to include
    the current cart in the request context, regardless of the view that processes
    the request.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，即使在购物车包含项目时，网站标题中也会显示消息**您的购物车为空**。您应该显示购物车中的项目总数和总成本。由于这需要在所有页面上显示，您需要构建一个上下文处理器，以便将当前购物车包含在请求上下文中，无论处理请求的视图是什么。
- en: Context processors
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 上下文处理器
- en: A context processor is a Python function that takes the `request` object as
    an argument and returns a dictionary that gets added to the request context. Context
    processors come in handy when you need to make something available globally to
    all templates.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文处理器是一个Python函数，它接受`request`对象作为参数，并返回一个字典，该字典被添加到请求上下文中。当您需要将某些内容全局提供给所有模板时，上下文处理器非常有用。
- en: 'By default, when you create a new project using the `startproject` command,
    your project contains the following template context processors in the `context_processors`
    option inside the `TEMPLATES` setting:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当您使用`startproject`命令创建新项目时，您的项目在`TEMPLATES`设置中的`context_processors`选项中包含以下模板上下文处理器：
- en: '`django.template.context_processors.debug`: This sets the Boolean `debug` and
    `sql_queries` variables in the context, representing the list of SQL queries executed
    in the request.'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`django.template.context_processors.debug`：此操作在上下文中设置布尔`debug`和`sql_queries`变量，代表在请求中执行的SQL查询列表。'
- en: '`django.template.context_processors.request`: This sets the `request` variable
    in the context.'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`django.template.context_processors.request`: 这将在上下文中设置`request`变量。'
- en: '`django.contrib.auth.context_processors.auth`: This sets the `user` variable
    in the request.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`django.contrib.auth.context_processors.auth`: 这将在请求中设置`user`变量。'
- en: '`django.contrib.messages.context_processors.messages`: This sets a `messages`
    variable in the context containing all the messages that have been generated using
    the messages framework.'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`django.contrib.messages.context_processors.messages`: 这将在上下文中设置一个`messages`变量，包含使用消息框架生成的所有消息。'
- en: Django also enables `django.template.context_processors.csrf` to avoid **cross-site
    request forgery** (**CSRF**) attacks. This context processor is not present in
    the settings, but it is always enabled and can’t be turned off for security reasons.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: Django还启用了`django.template.context_processors.csrf`以避免**跨站请求伪造**（**CSRF**）攻击。此上下文处理器在设置中不存在，但它始终启用，出于安全原因无法关闭。
- en: You can see the list of all built-in context processors at [https://docs.djangoproject.com/en/5.0/ref/templates/api/#built-in-template-context-processors](https://docs.djangoproject.com/en/5.0/ref/templates/api/#built-in-template-context-processors).
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://docs.djangoproject.com/en/5.0/ref/templates/api/#built-in-template-context-processors](https://docs.djangoproject.com/en/5.0/ref/templates/api/#built-in-template-context-processors)查看所有内置的上下文处理器的列表。
- en: Setting the cart in the request context
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在请求上下文中设置购物车
- en: Let’s create a context processor to set the current cart in the request context.
    With it, you will be able to access the cart in any template.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个上下文处理器来设置请求上下文中的当前购物车。有了它，您将能够在任何模板中访问购物车。
- en: 'Create a new file inside the `cart` application directory and name it `context_processors.py`.
    Context processors can reside anywhere in your code but creating them here will
    keep your code well organized. Add the following code to the file:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在`cart`应用程序目录内创建一个新文件，并将其命名为`context_processors.py`。上下文处理器可以存在于代码的任何位置，但在这里创建它们将有助于保持代码的整洁。将以下代码添加到文件中：
- en: '[PRE57]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: In your context processor, you instantiate the cart using the `request` object
    and make it available for the templates as a variable named `cart`.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的上下文处理器中，您使用`request`对象实例化购物车，并将其作为名为`cart`的变量提供给模板。
- en: 'Edit the `settings.py` file of your project and add `cart.context_processors.cart`
    to the `context_processors` option inside the `TEMPLATES` setting, as follows.
    The new line is highlighted in bold:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑您项目的`settings.py`文件，并将`cart.context_processors.cart`添加到`TEMPLATES`设置中的`context_processors`选项中，如下所示。新行以粗体突出显示：
- en: '[PRE58]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The `cart` context processor will be executed every time a template is rendered
    using Django’s `RequestContext`. The `cart` variable will be set in the context
    of your templates. You can read more about `RequestContext` at [https://docs.djangoproject.com/en/5.0/ref/templates/api/#django.template.RequestContext](https://docs.djangoproject.com/en/5.0/ref/templates/api/#django.template.RequestContext).
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 每次使用Django的`RequestContext`渲染模板时，都会执行`cart`上下文处理器。`cart`变量将设置在模板的上下文中。您可以在[https://docs.djangoproject.com/en/5.0/ref/templates/api/#django.template.RequestContext](https://docs.djangoproject.com/en/5.0/ref/templates/api/#django.template.RequestContext)中了解更多关于`RequestContext`的信息。
- en: Context processors are executed in all the requests that use `RequestContext`.
    You might want to create a custom template tag instead of a context processor
    if your functionality is not needed in all templates, especially if it involves
    database queries.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文处理器在所有使用`RequestContext`的请求中执行。如果您不需要在所有模板中使用功能，尤其是如果它涉及数据库查询，您可能想创建一个自定义模板标签而不是上下文处理器。
- en: 'Next, edit the `shop/base.html` template of the `shop` application and find
    the following lines:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，编辑`shop/base.html`模板，这是`shop`应用程序的一部分，并找到以下行：
- en: '[PRE59]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Replace the previous lines with the following code:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面的行替换为以下代码：
- en: '[PRE60]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Restart the development server with the following command:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令重新启动开发服务器：
- en: '[PRE61]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Open `http://127.0.0.1:8000/` in your browser and add some products to the cart.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的浏览器中打开`http://127.0.0.1:8000/`并添加一些产品到购物车。
- en: 'In the header of the website, you can now see the total number of items in
    the cart and the total cost, as follows:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在网站页眉中，您现在可以看到购物车中的项目总数和总金额，如下所示：
- en: '![Graphical user interface, website  Description automatically generated](img/B21088_08_12.png)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，网站描述自动生成](img/B21088_08_12.png)'
- en: 'Figure 8.12: The site header displaying the current items in the cart'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.12：显示购物车中当前项目的网站页眉
- en: Congratulations! You have completed the shopping cart functionality. This is
    a significant milestone in your online shop project. Next, you are going to create
    the functionality to register customer orders, which is another foundational element
    of any e-commerce platform.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您已完成了购物车功能。这是您的在线商店项目中的一个重要里程碑。接下来，您将创建注册客户订单的功能，这是任何电子商务平台的基础元素之一。
- en: Registering customer orders
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册客户订单
- en: When a shopping cart is checked out, you need to save an order in the database.
    Orders will contain information about customers and the products they are buying.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 当购物车结账时，您需要在数据库中保存一个订单。订单将包含有关客户和他们购买的产品信息。
- en: 'Create a new application for managing customer orders using the following command:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令创建用于管理客户订单的新应用：
- en: '[PRE62]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Edit the `settings.py` file of your project and add the new application to
    the `INSTALLED_APPS` setting, as follows:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑您项目的`settings.py`文件，并将新应用添加到`INSTALLED_APPS`设置中，如下所示：
- en: '[PRE63]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: You have activated the `orders` application.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 您已激活`orders`应用。
- en: Creating order models
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建订单模型
- en: 'You will need a model to store the order details and a second model to store
    items bought, including their price and quantity. Edit the `models.py` file of
    the `orders` application and add the following code to it:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要一个模型来存储订单详情，以及第二个模型来存储购买的项目，包括它们的单价和数量。编辑`orders`应用的`models.py`文件，并向其中添加以下代码：
- en: '[PRE64]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The order model contains several fields to store customer information and a
    `paid` Boolean field, which defaults to `False`. Later on, you are going to use
    this field to differentiate between paid and unpaid orders. We have also defined
    a `get_total_cost()` method to obtain the total cost of the items bought in this
    order.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 订单模型包含几个字段以存储客户信息，以及一个默认为`False`的`paid`布尔字段。稍后，您将使用此字段来区分已付款和未付款的订单。我们还定义了一个`get_total_cost()`方法来获取此订单中购买项目的总成本。
- en: The `OrderItem` model allows you to store the product, quantity, and price paid
    for each item. We have defined a `get_cost()` method that returns the cost of
    the item by multiplying the item price with the quantity. In the `product` field,
    we use the string `'shop.Product'` with the format `app.Model`, which is another
    way to point to related models and also a good method to avoid circular imports.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '`OrderItem`模型允许您存储每个项目的产品、数量和支付的金额。我们定义了一个`get_cost()`方法，通过将项目价格乘以数量来返回项目的成本。在`product`字段中，我们使用字符串`''shop.Product''`，格式为`app.Model`，这是指向相关模型的另一种方式，也是一种避免循环导入的好方法。'
- en: 'Run the next command to create initial migrations for the `orders` application:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令为`orders`应用创建初始迁移：
- en: '[PRE65]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'You will see output similar to the following:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到类似以下输出的内容：
- en: '[PRE66]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Run the following command to apply the new migration:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以应用新的迁移：
- en: '[PRE67]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'You will see the following output:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到以下输出：
- en: '[PRE68]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Your order models are now synced to the database.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 您的订单模型现在已同步到数据库中。
- en: Including order models in the administration site
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将订单模型包含在管理站点中
- en: 'Let’s add the order models to the administration site. Edit the `admin.py`
    file of the `orders` application and add the following code highlighted in bold:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将订单模型添加到管理站点。编辑`orders`应用的`admin.py`文件，并添加以下加粗代码：
- en: '[PRE69]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: You use a `ModelInline` class for the `OrderItem` model to include it as an
    *inline* in the `OrderAdmin` class. An inline allows you to include a model on
    the same edit page as its related model.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 您使用`ModelInline`类为`OrderItem`模型，将其作为*内联*包含在`OrderAdmin`类中。内联允许您将模型包含在其相关模型相同的编辑页面上。
- en: 'Run the development server with the following command:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令运行开发服务器：
- en: '[PRE70]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Open `http://127.0.0.1:8000/admin/orders/order/add/` in your browser. You will
    see the following page:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的浏览器中打开`http://127.0.0.1:8000/admin/orders/order/add/`。您将看到以下页面：
- en: '![](img/B21088_08_13.png)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21088_08_13.png)'
- en: 'Figure 8.13: The Add order form, including OrderItemInline'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.13：包含OrderItemInline的添加订单表单
- en: Creating customer orders
  id: totrans-347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建客户订单
- en: 'You will use the order models that you created to persist the items contained
    in the shopping cart when the user finally places an order. A new order will be
    created following these steps:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 您将使用创建的订单模型来持久化购物车中包含的项目，当用户最终下订单时。创建新订单的步骤如下：
- en: Present a user with an order form to fill in their data.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向用户展示一个订单表单以填写他们的数据。
- en: Create a new `Order` instance with the data entered, and create an associated
    `OrderItem` instance for each item in the cart.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用输入的数据创建一个新的`Order`实例，并为购物车中的每个项目创建一个相关的`OrderItem`实例。
- en: Clear all the cart’s contents and redirect the user to a success page.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清空购物车的所有内容并将用户重定向到成功页面。
- en: 'First, you need a form to enter the order details. Create a new file inside
    the `orders` application directory and name it `forms.py`. Add the following code
    to it:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要一个表单来输入订单详情。在`orders`应用目录内创建一个新文件，命名为`forms.py`。向其中添加以下代码：
- en: '[PRE71]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'This is the form that you are going to use to create new `Order` objects. Now
    you need a view to handle the form and create a new order. Edit the `views.py`
    file of the `orders` application and add the following code highlighted in bold:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您将要用来创建新`Order`对象的表单。现在您需要一个视图来处理表单并创建新订单。编辑`orders`应用的`views.py`文件并添加以下加粗的代码：
- en: '[PRE72]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'In the `order_create` view, you obtain the current cart from the session with
    `cart = Cart(request)`. Depending on the request method, you perform the following
    tasks:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在`order_create`视图中，您使用`cart = Cart(request)`从会话中获取当前购物车。根据请求方法，您执行以下任务：
- en: '**GET request**: Instantiates the `OrderCreateForm` form and renders the `orders/order/create.html`
    template.'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GET请求**：实例化`OrderCreateForm`表单并渲染`orders/order/create.html`模板。'
- en: '**POST request**: Validates the data sent in the request. If the data is valid,
    you create a new order in the database using `order = form.save()`. You iterate
    over the cart items and create an `OrderItem` for each of them. Finally, you clear
    the cart’s contents and render the template `orders/order/created.html`.'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**POST请求**：验证请求中发送的数据。如果数据有效，您将使用`order = form.save()`在数据库中创建一个新的订单。您遍历购物车项目并为每个项目创建一个`OrderItem`。最后，您清除购物车的所有内容并渲染模板`orders/order/created.html`。'
- en: 'Create a new file inside the `orders` application directory and name it `urls.py`.
    Add the following code to it:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在`orders`应用目录内创建一个新文件，命名为`urls.py`。向其中添加以下代码：
- en: '[PRE73]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: This is the URL pattern for the `order_create` view.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`order_create`视图的URL模式。
- en: 'Edit the `urls.py` file of `myshop` and include the following pattern. Remember
    to place it before the `shop.urls` pattern, as follows. The new line is highlighted
    in bold:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`myshop`的`urls.py`文件并包含以下模式。请记住将其放在`shop.urls`模式之前，如下所示。新行已加粗：
- en: '[PRE74]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Edit the `cart/detail.html` template of the `cart` application and find this
    line:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`cart/detail.html`模板的`cart`应用并找到以下行：
- en: '[PRE75]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Add the `order_create` URL to the `href` HTML attribute, as follows:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 将`order_create` URL添加到`href` HTML属性中，如下所示：
- en: '[PRE76]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Users can now navigate from the cart detail page to the order form.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 用户现在可以从购物车详情页面导航到订单表单。
- en: 'You still need to define templates for creating orders. Create the following
    file structure inside the `orders` application directory:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要定义创建订单的模板。在`orders`应用目录内创建以下文件结构：
- en: '[PRE77]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Edit the `orders/order/create.html` template and add the following code:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`orders/order/create.html`模板并添加以下代码：
- en: '[PRE78]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: This template displays the cart items, including totals and the form to place
    an order.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 此模板显示购物车项目，包括总计和下订单的表单。
- en: 'Edit the `orders/order/created.html` template and add the following code:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`orders/order/created.html`模板并添加以下代码：
- en: '[PRE79]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: This is the template that you render when the order is successfully created.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 这是订单成功创建时渲染的模板。
- en: 'Start the web development server to load new files. Open `http://127.0.0.1:8000/`
    in your browser, add a couple of products to the cart, and continue to the checkout
    page. You will see the following form:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 启动Web开发服务器以加载新文件。在浏览器中打开`http://127.0.0.1:8000/`，向购物车添加几个产品，然后继续到结账页面。您将看到以下表单：
- en: '![Graphical user interface, application  Description automatically generated](img/B21088_08_14.png)'
  id: totrans-378
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序描述自动生成](img/B21088_08_14.png)'
- en: 'Figure 8.14: The order creation page, including the chart checkout form and
    order details'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.14：订单创建页面，包括图表结账表单和订单详情
- en: 'Fill in the form with valid data and click on the **Place order** button. The
    order will be created, and you will see a success page like this:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 使用有效数据填写表单并点击**下订单**按钮。订单将被创建，您将看到如下成功页面：
- en: '![A picture containing text  Description automatically generated](img/B21088_08_15.png)'
  id: totrans-381
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本的图片，描述自动生成](img/B21088_08_15.png)'
- en: 'Figure 8.15: The order created template displaying the order number'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.15：显示订单号的订单创建模板
- en: The order has been registered and the cart has been cleared.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 订单已注册，购物车已清空。
- en: You might have noticed that the message **Your cart is empty** is displayed
    in the header when an order is completed. This is because the cart has been cleared.
    We can easily avoid this message for views that have an `order` object in the
    template context.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `shop/base.html` template of the `shop` application and replace the
    following line highlighted in bold:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The message **Your cart is empty** will not be displayed anymore when an order
    is created.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: 'Now open the administration site at `http://127.0.0.1:8000/admin/orders/order/`.
    You will see that the order has been successfully created, like this:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_08_16.png)'
  id: totrans-389
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.16: The order change list section of the administration site, including
    the order created'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: You have implemented the order system. Now you will learn how to create asynchronous
    tasks to send confirmation emails to users when they place an order.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: Creating asynchronous tasks
  id: totrans-392
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When receiving an HTTP request, you need to return a response to the user as
    quickly as possible. Remember that in *Chapter 7*, *Tracking User Actions*, you
    used the Django Debug Toolbar to check the time for the different phases of the
    request/response cycle and the execution time for the SQL queries performed.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: Every task executed during the course of the request/response cycle adds up
    to the total response time. Long-running tasks can seriously slow down the server
    response. How do we return a fast response to the user while still completing
    time-consuming tasks? We can do it with asynchronous execution.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: Working with asynchronous tasks
  id: totrans-395
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can offload work from the request/response cycle by executing certain tasks
    in the background. For example, a video-sharing platform allows users to upload
    videos but requires a long time to transcode uploaded videos. When the user uploads
    a video, the site might return a response informing them that the transcoding
    will start soon and start transcoding the video asynchronously. Another example
    is sending emails to users. If your site sends email notifications from a view,
    the **Simple Mail Transfer Protocol** (**SMTP**) connection might fail or slow
    down the response. By sending the email asynchronously, you avoid blocking the
    code execution.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous execution is especially relevant for data-intensive, resource-intensive,
    and time-consuming processes or processes subject to failure, which might require
    a retry policy.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: Workers, message queues, and message brokers
  id: totrans-398
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While your web server processes requests and returns responses, you need a second
    task-based server, named **worker**, to process the asynchronous tasks. One or
    multiple workers can be running and executing tasks in the background. These workers
    can access the database, process files, send emails, and so on. Workers can even
    queue future tasks, all while keeping the main web server free to process HTTP
    requests.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: To tell the workers what tasks to execute, we need to send **messages**. We
    communicate with brokers by adding messages to a **message queue**, which is basically
    a **first in, first out** (**FIFO**) data structure. When a broker becomes available,
    it takes the first message from the queue and starts executing the corresponding
    task. When finished, the broker takes the next message from the queue and executes
    the corresponding task. Brokers become idle when the message queue is empty. When
    using multiple brokers, each broker takes the first available message in order
    when they become available. The queue ensures that each broker only gets one task
    at a time and that no task is processed by more than one worker.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 8.17* shows how a message queue works:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: '![Shape  Description automatically generated with medium confidence](img/B21088_08_17.png)'
  id: totrans-402
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.17: Asynchronous execution using a message queue and workers'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: A producer sends a message to the queue, and the worker(s) consumes the messages
    on a first-come, first-served basis; the first message added to the message queue
    is the first message to be processed by the worker(s).
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: In order to manage the message queue, we need a **message broker**. The message
    broker is used to translate messages to a formal messaging protocol and manage
    message queues for multiple receivers. It provides reliable storage and guaranteed
    message delivery. The message broker allows us to create message queues, route
    messages, distribute messages among workers, and so on.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: To implement asynchronous tasks in your project, you will use Celery for managing
    task queues and RabbitMQ as the message broker Celery employs. Both technologies
    will be introduced in the following section.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: Using Django with Celery and RabbitMQ
  id: totrans-407
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Celery is a distributed task queue that can process vast amounts of messages.
    We will use Celery to define asynchronous tasks as Python functions within our
    Django applications. We will run Celery workers that will listen to the message
    broker to get new messages to process asynchronous tasks.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: Using Celery, not only can you create asynchronous tasks easily and let them
    be executed by workers as soon as possible but you can also schedule them to run
    at a specific time. You can find the Celery documentation at [https://docs.celeryq.dev/en/stable/index.html](https://docs.celeryq.dev/en/stable/index.html).
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: Celery communicates via messages and requires a message broker to mediate between
    clients and workers. There are several options for a message broker for Celery,
    including key/value stores such as Redis, or an actual message broker such as
    RabbitMQ.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: RabbitMQ is the most widely deployed message broker. It supports multiple messaging
    protocols, such as the **Advanced Message Queuing Protocol** (**AMQP**), and it
    is the recommended message worker for Celery. RabbitMQ is lightweight, easy to
    deploy, and can be configured for scalability and high availability.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 8.18* shows how we will use Django, Celery, and RabbitMQ to execute
    asynchronous tasks:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: '![A picture containing diagram  Description automatically generated](img/B21088_08_18.png)'
  id: totrans-413
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.18: Architecture for asynchronous tasks with Django, RabbitMQ, and
    Celery'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: Installing Celery
  id: totrans-415
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s install Celery and integrate it into the project. Install Celery via
    `pip` using the following command:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: You can find an introduction to Celery at [https://docs.celeryq.dev/en/stable/getting-started/introduction.html](https://docs.celeryq.dev/en/stable/getting-started/introduction.html).
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: Installing RabbitMQ
  id: totrans-419
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The RabbitMQ community provides a Docker image that makes it very easy to deploy
    a RabbitMQ server with a standard configuration. Remember that you learned how
    to install Docker in *Chapter 3*, *Extending Your Blog Application*.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: 'After installing Docker on your machine, you can easily pull the RabbitMQ Docker
    image by running the following command from the shell:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: This will download the RabbitMQ Docker image to your local machine. You can
    find information about the official RabbitMQ Docker image at [https://hub.docker.com/_/rabbitmq](https://hub.docker.com/_/rabbitmq).
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: If you want to install RabbitMQ natively on your machine instead of using Docker,
    you will find detailed installation guides for different operating systems at
    [https://www.rabbitmq.com/download.html](https://www.rabbitmq.com/download.html).
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following command in the shell to start the RabbitMQ server with
    Docker:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: With this command, we are telling RabbitMQ to run on port `5672`, and we are
    running its web-based management user interface on port `15672`.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: 'You will see output that includes the following lines:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: RabbitMQ is running on port `5672` and ready to receive messages.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: Accessing RabbitMQ’s management interface
  id: totrans-431
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Open `http://127.0.0.1:15672/` in your browser. You will see the login screen
    for the management UI of RabbitMQ. It will look like this:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application, email  Description automatically
    generated](img/B21088_08_19.png)'
  id: totrans-433
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.19: The RabbitMQ management UI login screen'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter `guest` as both the username and the password and click on **Login**.
    You will see the following screen:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_08_20.png)'
  id: totrans-436
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.20: The RabbitMQ management UI dashboard'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: This is the default admin user for RabbitMQ. On this screen, you can monitor
    the current activity for RabbitMQ. You can see that there is one node running
    with no connections or queues registered.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: If you use RabbitMQ in a production environment, you will need to create a new
    admin user and remove the default `guest` user. You can do that in the **Admin**
    section of the management UI.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: Now we will add Celery to the project. Then, we will run Celery and test the
    connection to RabbitMQ.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: Adding Celery to your project
  id: totrans-441
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You have to provide a configuration for the Celery instance. Create a new file
    next to the `settings.py` file of `myshop` and name it `celery.py`. This file
    will contain the Celery configuration for your project. Add the following code
    to it:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'In this code, you do the following:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: You set the `DJANGO_SETTINGS_MODULE` variable for the Celery command-line program.
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You create an instance of the application with `app = Celery('myshop')`.
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You load any custom configuration from your project settings using the `config_from_object()`
    method. The `namespace` attribute specifies the prefix that Celery-related settings
    will have in your `settings.py` file. By setting the `CELERY` namespace, all Celery
    settings need to include the `CELERY_` prefix in their name (for example, `CELERY_BROKER_URL`).
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, you tell Celery to auto-discover asynchronous tasks for your applications.
    Celery will look for a `tasks.py` file in each application directory of applications
    added to `INSTALLED_APPS` in order to load asynchronous tasks defined in it.
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You need to import the `celery` module in the `__init__.py` file of your project
    to ensure it is loaded when Django starts.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `myshop/__init__.py` file and add the following code to it:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: You have added Celery to the Django project, and you can now start using it.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: Running a Celery worker
  id: totrans-453
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A Celery worker is a process that handles bookkeeping features like sending/receiving
    queue messages, registering tasks, killing hung tasks, tracking status, and so
    on. A worker instance can consume from any number of message queues.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: 'Open another shell and start a Celery worker from your project directory, using
    the following command:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: The Celery worker is now running and ready to process tasks. Let’s check if
    there is a connection between Celery and RabbitMQ.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `http://127.0.0.1:15672/` in your browser to access the RabbitMQ management
    UI. You will now see a graph under **Queued messages** and another graph under
    **Message rates**, as in *Figure 8.21*:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_08_21.png)'
  id: totrans-459
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.21: The RabbitMQ management dashboard displaying connections and queues'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, there are no queued messages as we haven’t sent any messages to the
    message queue yet. The graph under **Message rates** should update every five
    seconds; you can see the refresh rate at the top right of the screen. This time,
    both **Connections** and **Queues** should display a number higher than zero.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: Now we can start programming asynchronous tasks.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: The `CELERY_ALWAYS_EAGER` setting allows you to execute tasks locally in a synchronous
    manner instead of sending them to the queue. This is useful for running unit tests
    or executing the application in your local environment without running Celery.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: Adding asynchronous tasks to your application
  id: totrans-464
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s send a confirmation email to the user whenever an order is placed in the
    online shop. We will implement sending the email in a Python function and register
    it as a task with Celery. Then, we will add it to the `order_create` view to execute
    the task asynchronously.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: When the `order_create` view is executed, Celery will send the message to a
    message queue managed by RabbitMQ and then a Celery broker will execute the asynchronous
    task that we defined with a Python function.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: The convention for easy task discovery by Celery is to define asynchronous tasks
    for your application in a `tasks` module within the application directory.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file inside the `orders` application and name it `tasks.py`. This
    is the place where Celery will look for asynchronous tasks. Add the following
    code to it:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: We have defined the `order_created` task by using the `@shared_task` decorator.
    As you can see, a Celery task is just a Python function decorated with `@shared_task`.
    The `order_created` task function receives an `order_id` parameter. It’s always
    recommended to only pass IDs to task functions and retrieve objects from the database
    when the task is executed. By doing so, we avoid accessing outdated information
    since the data in the database might have changed while the task was queued. We
    have used the `send_mail()` function provided by Django to send an email notification
    to the user who placed the order.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: 'You learned how to configure Django to use your SMTP server in *Chapter 2*,
    *Enhancing Your Blog with Advanced Features*. If you don’t want to set up email
    settings, you can tell Django to write emails to the console by adding the following
    setting to the `settings.py` file:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Use asynchronous tasks not only for time-consuming processes but also for other
    processes that do not take so much time to be executed but that are subject to
    connection failures or require a retry policy.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you have to add the task to your `order_create` view. Edit the `views.py`
    file of the `orders` application, import the task, and call the `order_created`
    asynchronous task after clearing the cart, as follows:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: You call the `delay()` method of the task to execute it asynchronously. The
    task will be added to the message queue and executed by the Celery worker as soon
    as possible.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure RabbitMQ is running. Then, stop the Celery worker process and start
    it again with the following command:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The Celery worker has now registered the task. In another shell, start the
    development server from the project directory with the following command:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Open `http://127.0.0.1:8000/` in your browser, add some products to your shopping
    cart, and complete an order. In the shell where you started the Celery worker,
    you will see output similar to the following:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: The `order_created` task has been executed and an email notification for the
    order has been sent. If you are using the email backend `console.EmailBackend`,
    no email is sent but you should see the rendered text of the email in the output
    of the console.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring Celery with Flower
  id: totrans-484
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Besides the RabbitMQ management UI, you can use other tools to monitor the asynchronous
    tasks that are executed with Celery. Flower is a useful web-based tool for monitoring
    Celery. You can find the documentation for Flower at [https://flower.readthedocs.io/](https://flower.readthedocs.io/).
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: 'Install Flower using the following command:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Once installed, you can launch Flower by running the following command in a
    new shell from your project directory:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Open `http://localhost:5555/` in your browser. You will be able to see the
    active Celery workers and asynchronous task statistics. The screen should look
    as follows:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_08_22.png)'
  id: totrans-491
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.22: The Flower dashboard'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: You will see an active worker whose name starts with **celery@** and whose status
    is **Online**.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the worker’s name and then click on the **Queues** tab. You will see
    the following screen:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_08_23.png)'
  id: totrans-495
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.23: Flower – Worker Celery task queues'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: Here you can see the active queue named **celery**. This is the active queue
    consumer connected to the message broker.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the **Tasks** tab. You will see the following screen:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_08_24.png)'
  id: totrans-499
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.24: Flower – Worker Celery tasks'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: Here you can see the tasks that have been processed and the number of times
    that they have been executed. You should see the `order_created` task and the
    total times that it has been executed. This number might vary depending on how
    many orders you have placed.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: Open `http://localhost:8000/` in your browser. Add some items to the cart and
    then complete the checkout process.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `http://localhost:5555/` in your browser. Flower has registered the task
    as processed. You should now see `1` under **Processed** and `1` under **Succeeded**
    as well:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_08_25.png)'
  id: totrans-504
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.25: Flower – Celery workers'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: 'Under **Tasks**, you can see additional details about each task registered
    with Celery:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_08_26.png)'
  id: totrans-507
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.26: Flower – Celery tasks'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: 'Flower should never be deployed openly in a production environment without
    security. Let’s add authentication to the Flower instance. Stop Flower using *Ctrl
    + C*, and restart it with the `--basic-auth` option by executing the following
    command:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Replace `user` and `pwd` with your desired username and password. Open `http://localhost:5555/`
    in your browser. The browser will now prompt you for credentials, as shown in
    *Figure 8.27*:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_08_27.png)'
  id: totrans-512
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.27: Basic authentication required to access Flower'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: Flower provides other authentication options, such as Google, GitHub, or Okta
    OAuth. You can read more about Flower’s authentication methods at [https://flower.readthedocs.io/en/latest/auth.html](https://flower.readthedocs.io/en/latest/auth.html).
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-515
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you created a basic e-commerce application. You made a product
    catalog and built a shopping cart using sessions. You implemented a custom context
    processor to make the cart available to all templates and created a form for placing
    orders. You also learned how to implement asynchronous tasks using Celery and
    RabbitMQ. Having completed this chapter, you now understand the foundational elements
    of building an e-commerce platform with Django, including managing products, processing
    orders, and handling asynchronous tasks. You are now also capable of developing
    projects that efficiently process user transactions and scale to handle complex
    background operations seamlessly.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will discover how to integrate a payment gateway into
    your shop, add custom actions to the administration site, export data in CSV format,
    and generate PDF files dynamically.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: Additional resources
  id: totrans-518
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following resources provide additional information related to the topics
    covered in this chapter:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: Source code for this chapter – [https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter08](https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter08)
  id: totrans-520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static files for the project – [https://github.com/PacktPublishing/Django-5-by-Example/tree/main/Chapter08/myshop/shop/static](https://github.com/PacktPublishing/Django-5-by-Example/tree/main/Chapter08/myshop/shop/static
    )
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Django session settings – [https://docs.djangoproject.com/en/5.0/ref/settings/#sessions](https://docs.djangoproject.com/en/5.0/ref/settings/#sessions)
  id: totrans-522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Django built-in context processors – [https://docs.djangoproject.com/en/5.0/ref/templates/api/#built-in-template-context-processors](https://docs.djangoproject.com/en/5.0/ref/templates/api/#built-in-template-context-processors)
  id: totrans-523
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Information about `RequestContext` – [https://docs.djangoproject.com/en/5.0/ref/templates/api/#django.template.RequestContext](https://docs.djangoproject.com/en/5.0/ref/templates/api/#django.template.RequestContext)
  id: totrans-524
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Celery documentation – [https://docs.celeryq.dev/en/stable/index.html](https://docs.celeryq.dev/en/stable/index.html)
  id: totrans-525
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to Celery – [https://docs.celeryq.dev/en/stable/getting-started/introduction.html](https://docs.celeryq.dev/en/stable/getting-started/introduction.html)
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Official RabbitMQ Docker image – [https://hub.docker.com/_/rabbitmq](https://hub.docker.com/_/rabbitmq)
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RabbitMQ installation instructions – [https://www.rabbitmq.com/download.html](https://www.rabbitmq.com/download.html)
  id: totrans-528
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flower documentation – [https://flower.readthedocs.io/](https://flower.readthedocs.io/)
  id: totrans-529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flower authentication methods – [https://flower.readthedocs.io/en/latest/auth.html](https://flower.readthedocs.io/en/latest/auth.html)
  id: totrans-530
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Join us on Discord!
  id: totrans-531
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Read this book alongside other users, Django development experts, and the author
    himself. Ask questions, provide solutions to other readers, chat with the author
    via Ask Me Anything sessions, and much more.Scan the QR code or visit the link
    to join the community.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/Django5ByExample](https://packt.link/Django5ByExample)'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code287089408934129031.png)'
  id: totrans-534
  prefs: []
  type: TYPE_IMG
