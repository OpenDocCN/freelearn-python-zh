- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building an Online Shop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you created a follow system and built a user activity
    stream. You also learned how Django signals work and integrated Redis into your
    project to count image views.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will start a new Django project that consists of a fully
    featured online shop. This chapter and the following two chapters will show you
    how to build the essential functionalities of an e-commerce platform. Your online
    shop will enable clients to browse products, add them to the cart, apply discount
    codes, go through the checkout process, pay with a credit card, and obtain an
    invoice. You will also implement a recommendation engine to recommend products
    to your customers, and you will use internationalization to offer your site in
    multiple languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn how to:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a product catalog
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build a shopping cart using Django sessions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create custom template context processors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manage customer orders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure Celery in your project with RabbitMQ as a message broker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Send asynchronous notifications to customers using Celery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitor Celery using Flower
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Figure 8.1* shows a representation of the views, templates, and main functionalities
    that will be built in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_08_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.1: Diagram of functionalities built in Chapter 8'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will implement the `product_list` view to list all products
    and the `product_detail` view to display a single product. You will allow filtering
    products by category in the `product_list` view using the `category_slug` parameter.
    You will implement a shopping cart using sessions and you will build the `cart_detail`
    view to display the cart items. You will create the `cart_add` view to add products
    to the cart and update quantities, and the `cart_remove` view to remove products
    from the cart. You will implement the `cart` template context processor to display
    the number of cart items and total cost on the site header. You will also create
    the `order_create` view to place orders, and you will use Celery to implement
    the `order_created` asynchronous task that sends out an email confirmation to
    clients when they place an order. This chapter will provide you with the knowledge
    to implement user sessions in your application and show you how to work with asynchronous
    tasks. Both are very common use cases that you can apply to almost any project.
  prefs: []
  type: TYPE_NORMAL
- en: The source code for this chapter can be found at [https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter08](https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter08).
  prefs: []
  type: TYPE_NORMAL
- en: All Python modules used in this chapter are included in the `requirements.txt`
    file in the source code that comes along with this chapter. You can follow the
    instructions to install each Python module below or you can install all requirements
    at once with the command `python` `-m` `pip` `install` `-r` `requirements.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an online shop project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s start with a new Django project to build an online shop. Your users will
    be able to browse through a product catalog and add products to a shopping cart.
    Finally, they will be able to check out the cart and place an order. This chapter
    will cover the following functionalities of an online shop:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the product catalog models, adding them to the administration site,
    and building the basic views to display the catalog
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a shopping cart system using Django sessions to allow users to keep
    selected products while they browse the site
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the form and functionality to place orders on the site
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending an asynchronous email confirmation to users when they place an order
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Open a shell and use the following command to create a new virtual environment
    for this project within the `env/` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are using Linux or macOS, run the following command to activate your
    virtual environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are using Windows, use the following command instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The shell prompt will display your active virtual environment, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Install Django in your virtual environment with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Start a new project called `myshop` with an application called `shop` by opening
    a shell and running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The initial project structure has been created. Use the following commands
    to get into your project directory and create a new application named `shop`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit `settings.py` and add the following line highlighted in bold to the `INSTALLED_APPS`
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Your application is now active for this project. Let’s define the models for
    the product catalog.
  prefs: []
  type: TYPE_NORMAL
- en: Creating product catalog models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The catalog of your shop will consist of products that are organized into different
    categories. Each product will have a name, an optional description, an optional
    image, a price, and its availability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `models.py` file of the `shop` application that you just created and
    add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: These are the `Category` and `Product` models. The `Category` model consists
    of a `name` field and a unique `slug` field (`unique` implies the creation of
    an index). In the `Meta` class of the `Category` model, we have defined an index
    for the `name` field.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Product` model fields are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`category`: A `ForeignKey` to the `Category` model. This is a one-to-many relationship:
    a product belongs to one category and a category contains multiple products.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name`: The name of the product.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`slug`: The slug for this product to build beautiful URLs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`image`: An optional product image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`description`: An optional description of the product.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`price`: This field uses Python’s `decimal.Decimal` type to store a fixed-precision
    decimal number. The maximum number of digits (including the decimal places) is
    set using the `max_digits` attribute and decimal places with the `decimal_places`
    attribute.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`available`: A Boolean value that indicates whether the product is available
    or not. It will be used to enable/disable the product in the catalog.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`created`: This field stores when the object was created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`updated`: This field stores when the object was last updated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the `price` field, we use `DecimalField` instead of `FloatField` to avoid
    rounding issues.
  prefs: []
  type: TYPE_NORMAL
- en: Always use `DecimalField` to store monetary amounts. `FloatField` uses Python’s
    `float` type internally, whereas `DecimalField` uses Python’s `Decimal` type.
    By using the `Decimal` type, you will avoid `float` rounding issues.
  prefs: []
  type: TYPE_NORMAL
- en: In the `Meta` class of the `Product` model, we have defined a multiple-field
    index for the `id` and `slug` fields. Both fields are indexed together to improve
    performance for queries that utilize the two fields.
  prefs: []
  type: TYPE_NORMAL
- en: We plan to query products by both `id` and `slug`. We have added an index for
    the `name` field and an index for the `created` field. We have used a hyphen before
    the field name to define the index in descending order.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 8.2* shows the two data models you have created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B21088_08_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.2: Models for the product catalog'
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 8.2*, you can see the different fields of the data models and the
    one-to-many relationship between the `Category` and the `Product` models.
  prefs: []
  type: TYPE_NORMAL
- en: 'These models will result in the following database tables displayed in *Figure
    8.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A picture containing diagram  Description automatically generated](img/B21088_08_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.3: Database tables for the product catalog models'
  prefs: []
  type: TYPE_NORMAL
- en: The one-to-many relationship between both tables is defined with the `category_id`
    field in the `shop_product` table, which is used to store the ID of the related
    `Category` for each `Product` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create the initial database migrations for the `shop` application. Since
    you are going to deal with images in your models, you will need to install the
    Pillow library. Remember that in *Chapter 4*, *Building a Social Website*, you
    learned how to install the Pillow library to manage images. Open the shell and
    install `Pillow` with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now run the next command to create initial migrations for your project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the next command to sync the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see output that includes the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The database is now synced with your models.
  prefs: []
  type: TYPE_NORMAL
- en: Registering catalog models on the administration site
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s add your models to the administration site so that you can easily manage
    categories and products. Edit the `admin.py` file of the `shop` application and
    add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Remember that you use the `prepopulated_fields` attribute to specify fields
    where the value is automatically set using the value of other fields. As you have
    seen before, this is convenient for generating slugs.
  prefs: []
  type: TYPE_NORMAL
- en: You use the `list_editable` attribute in the `ProductAdmin` class to set the
    fields that can be edited from the list display page of the administration site.
    This will allow you to edit multiple rows at once. Any field in `list_editable`
    must also be listed in the `list_display` attribute since only the fields displayed
    can be edited.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now create a superuser for your site using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter the desired username, email, and password. Run the development server
    with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Open `http://127.0.0.1:8000/admin/shop/product/add/` in your browser and log
    in with the user that you just created. Add a new category and product using the
    administration interface. The **Add product** form should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_08_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.4: The product creation form'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the **SAVE** button. The product change list page of the administration
    page will then look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_08_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.5: The product change list page'
  prefs: []
  type: TYPE_NORMAL
- en: Building catalog views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to display the product catalog, you need to create a view to list
    all the products or filter products by a given category. Edit the `views.py` file
    of the `shop` application and add the following code highlighted in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, you filter the `QuerySet` with `available=True` to retrieve
    only available products. You use an optional `category_slug` parameter to optionally
    filter products by a given category.
  prefs: []
  type: TYPE_NORMAL
- en: 'You also need a view to retrieve and display a single product. Add the following
    view to the `views.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `product_detail` view expects the `id` and `slug` parameters in order to
    retrieve the `Product` instance. You can get this instance just through the ID
    since it’s a unique attribute. However, you include the slug in the URL to build
    SEO-friendly URLs for products.
  prefs: []
  type: TYPE_NORMAL
- en: 'After building the product list and detail views, you have to define URL patterns
    for them. Create a new file inside the `shop` application directory and name it
    `urls.py`. Add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'These are the URL patterns for your product catalog. You have defined two different
    URL patterns for the `product_list` view: a pattern named `product_list`, which
    calls the `product_list` view without any parameters, and a pattern named `product_list_by_category`,
    which provides a `category_slug` parameter to the view for filtering products
    according to a given category. You added a pattern for the `product_detail` view,
    which passes the `id` and `slug` parameters to the view in order to retrieve a
    specific product.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `urls.py` file of the `myshop` project to make it look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the main URL patterns of the project, you include URLs for the `shop` application
    under a custom namespace named `shop`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, edit the `models.py` file of the `shop` application, import the `reverse()`
    function, and add a `get_absolute_url()` method to the `Category` and `Product`
    models, as follows. The new code is highlighted in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As you already know, `get_absolute_url()` is the convention to retrieve the
    URL for a given object. Here, you use the URL patterns that you just defined in
    the `urls.py` file.
  prefs: []
  type: TYPE_NORMAL
- en: Creating catalog templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now you need to create templates for the product list and detail views. Create
    the following directory and file structure inside the `shop` application directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You need to define a base template and then extend it in the product list and
    detail templates. Edit the `shop/base.html` template and add the following code
    to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This is the base template that you will use for your shop. In order to include
    the CSS styles and images that are used by the templates, you need to copy the
    static files that accompany this chapter, which are located in the `static/` directory
    of the `shop` application. Copy them to the same location in your project. You
    can find the contents of the directory at [https://github.com/PacktPublishing/Django-5-by-Example/tree/main/Chapter08/myshop/shop/static](https://github.com/PacktPublishing/Django-5-by-Example/tree/main/Chapter08/myshop/shop/static).
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `shop/product/list.html` template and add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Make sure that no template tag is split across multiple lines.
  prefs: []
  type: TYPE_NORMAL
- en: This is the product list template. It extends the `shop/base.html` template
    and uses the `categories` context variable to display all the categories in a
    sidebar, and `products` to display the products of the current page. The same
    template is used for both listing all available products and listing products
    filtered by category. Since the `image` field of the `Product` model can be blank,
    you need to provide a default image for the products that don’t have an image.
    The image is located in your static files directory with the relative path `img/no_image.png`.
  prefs: []
  type: TYPE_NORMAL
- en: Since you are using `ImageField` to store product images, you need the development
    server to serve uploaded image files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `settings.py` file of `myshop` and add the following settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '`MEDIA_URL` is the base URL that serves media files uploaded by users. `MEDIA_ROOT`
    is the local path where these files reside, which you build by dynamically prepending
    the `BASE_DIR` variable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For Django to serve the uploaded media files using the development server,
    edit the main `urls.py` file of `myshop` and add the following code highlighted
    in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Remember that you only serve static files this way during development. In a
    production environment, you should never serve static files with Django; the Django
    development server doesn’t serve static files in an efficient manner. *Chapter
    17*, *Going Live*, will teach you how to serve static files in a production environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the development server with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a couple of products to your shop using the administration site and open
    `http://127.0.0.1:8000/` in your browser. You will see the product list page,
    which will look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, website  Description automatically generated](img/B21088_08_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.6: The product list page'
  prefs: []
  type: TYPE_NORMAL
- en: 'Credits for images in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Green tea*: Photo by Jia Ye on Unsplash'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Red tea*: Photo by Manki Kim on Unsplash'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Tea powder*: Photo by Phuong Nguyen on Unsplash'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you create a product using the administration site and don’t upload an image
    for it, the default `no_image.png` image will be displayed instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_08_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.7: The product list displaying a default image for products that have
    no image'
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `shop/product/detail.html` template and add the following code to
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, you call the `get_absolute_url()` method on the related
    category object to display the available products that belong to the same category.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now open `http://127.0.0.1:8000/` in your browser and click on any product
    to see the product detail page. It will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application  Description automatically generated](img/B21088_08_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.8: The product detail page'
  prefs: []
  type: TYPE_NORMAL
- en: You have now created a basic product catalog. Next, you will implement a shopping
    cart that allows users to add any product to it while browsing the online shop.
  prefs: []
  type: TYPE_NORMAL
- en: Building a shopping cart
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After building the product catalog, the next step is to create a shopping cart
    so that users can pick the products that they want to purchase. A shopping cart
    allows users to select products and set the amount they want to order, and then
    store this information temporarily while they browse the site until they eventually
    place an order. The cart has to be persisted in the session so that the cart items
    are maintained during a user’s visit.
  prefs: []
  type: TYPE_NORMAL
- en: You will use Django’s session framework to persist the cart. The cart will be
    kept in the session until it finishes or the user checks out the cart. You will
    also need to build additional Django models for the cart and its items.
  prefs: []
  type: TYPE_NORMAL
- en: Using Django sessions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Django provides a session framework that supports anonymous and user sessions.
    The session framework allows you to store arbitrary data for each visitor. Session
    data is stored on the server side, and cookies contain the session ID unless you
    use the cookie-based session engine. The session middleware manages the sending
    and receiving of cookies. The default session engine stores session data in the
    database, but you can choose other session engines.
  prefs: []
  type: TYPE_NORMAL
- en: To use sessions, you have to make sure that the `MIDDLEWARE` setting of your
    project contains `django.contrib.sessions.middleware.SessionMiddleware`. This
    middleware manages sessions. It’s added by default to the `MIDDLEWARE` setting
    when you create a new project using the `startproject` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'The session middleware makes the current session available in the `request`
    object. You can access the current session using `request.session`, treating it
    like a Python dictionary to store and retrieve session data. The `session` dictionary
    accepts any Python object by default that can be serialized to JSON. You can set
    a variable in the session like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'You can retrieve a session key as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'You can delete a key you previously stored in the session as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: When users log in to the site, their anonymous session is lost, and a new session
    is created for authenticated users. If you store items in an anonymous session
    that you need to keep after the user logs in, you will have to copy the old session
    data into the new session. You can do this by retrieving the session data before
    you log in the user using the `login()` function of the Django authentication
    system and storing it in the session after that.
  prefs: []
  type: TYPE_NORMAL
- en: Session settings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are several settings you can use to configure sessions for your project.
    The most important is `SESSION_ENGINE`. This setting allows you to set the place
    where sessions are stored. By default, Django stores sessions in the database
    using the `Session` model of the `django.contrib.sessions` application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Django offers the following options for storing session data:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Database sessions**: Session data is stored in the database. This is the
    default session engine.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**File-based sessions**: Session data is stored in the filesystem.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cached sessions**: Session data is stored in a cache backend. You can specify
    cache backends using the `CACHES` setting. Storing session data in a cache system
    provides the best performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cached database sessions**: Session data is stored in a write-through cache
    and database. Reads only use the database if the data is not already in the cache.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cookie-based sessions**: Session data is stored in the cookies that are sent
    to the browser.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For better performance use a cache-based session engine. Django supports Memcached
    out of the box and you can find third-party cache backends for Redis and other
    cache systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can customize sessions with specific settings. Here are some of the important
    session-related settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SESSION_COOKIE_AGE`: The duration of session cookies in seconds. The default
    value is `1209600` (two weeks).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SESSION_COOKIE_DOMAIN`: The domain used for session cookies. Set this to `mydomain.com`
    to enable cross-domain cookies or use `None` for a standard domain cookie.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SESSION_COOKIE_HTTPONLY`: Whether to use the `HttpOnly` flag on the session
    cookie. If this is set to `True`, client-side JavaScript will not be able to access
    the session cookie. The default value is `True` for increased security against
    user session hijacking.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SESSION_COOKIE_SECURE`: A Boolean indicating that the cookie should only be
    sent if the connection is an HTTPS connection. The default value is `False`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SESSION_EXPIRE_AT_BROWSER_CLOSE`: A Boolean indicating that the session has
    to expire when the browser is closed. The default value is `False`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SESSION_SAVE_EVERY_REQUEST`: A Boolean that, if `True`, will save the session
    to the database on every request. The session expiration is also updated each
    time it’s saved. The default value is `False`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can see all the session settings and their default values at [https://docs.djangoproject.com/en/5.0/ref/settings/#sessions](https://docs.djangoproject.com/en/5.0/ref/settings/#sessions).
  prefs: []
  type: TYPE_NORMAL
- en: Session expiration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can choose to use browser-length sessions or persistent sessions using the
    `SESSION_EXPIRE_AT_BROWSER_CLOSE` setting. This is set to `False` by default,
    forcing the session duration to the value stored in the `SESSION_COOKIE_AGE` setting.
    If you set `SESSION_EXPIRE_AT_BROWSER_CLOSE` to `True`, the session will expire
    when the user closes the browser, and the `SESSION_COOKIE_AGE` setting will not
    have any effect.
  prefs: []
  type: TYPE_NORMAL
- en: You can use the `set_expiry()` method of `request.session` to overwrite the
    duration of the current session.
  prefs: []
  type: TYPE_NORMAL
- en: Storing shopping carts in sessions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You need to create a simple structure that can be serialized to JSON for storing
    cart items in a session. The cart has to include the following data for each item
    contained in it:'
  prefs: []
  type: TYPE_NORMAL
- en: The ID of a `Product` instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The quantity selected for the product
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The unit price for the product
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since product prices may vary, let’s take the approach of storing the product’s
    price along with the product itself when it’s added to the cart. By doing so,
    you use the current price of the product when users add it to their cart, no matter
    whether the product’s price is changed afterward. This means that the price that
    the item has when the client adds it to the cart is maintained for that client
    in the session until checkout is completed or the session finishes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you have to build functionality to create shopping carts and associate
    them with sessions. This has to work as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: When a cart is needed, you check whether a custom session key is set. If no
    cart is set in the session, you create a new cart and save it in the cart session
    key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For successive requests, you perform the same check and get the cart items from
    the cart session key. You retrieve the cart items from the session and their related
    `Product` objects from the database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Edit the `settings.py` file of your project and add the following setting to
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This is the key that you are going to use to store the cart in the user session.
    Since Django sessions are managed per visitor, you can use the same cart session
    key for all sessions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create an application for managing shopping carts. Open the terminal
    and create a new application, running the following command from the project directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, edit the `settings.py` file of your project and add the new application
    to the `INSTALLED_APPS` setting with the following line highlighted in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new file inside the `cart` application directory and name it `cart.py`.
    Add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This is the `Cart` class that will allow you to manage the shopping cart. You
    require the cart to be initialized with a `request` object. You store the current
    session using `self.session = request.session` to make it accessible to the other
    methods of the `Cart` class.
  prefs: []
  type: TYPE_NORMAL
- en: First, you try to get the cart from the current session using `self.session.get(settings.CART_SESSION_ID)`.
    If no cart is present in the session, you create an empty cart by setting an empty
    dictionary in the session.
  prefs: []
  type: TYPE_NORMAL
- en: You will build your `cart` dictionary with product IDs as keys, and for each
    product key, a dictionary will be a value that includes quantity and price. By
    doing this, you can guarantee that a product will not be added more than once
    to the cart. This way, you can also simplify retrieving cart items.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a method to add products to the cart or update their quantity.
    Add the following `add()` and `save()` methods to the `Cart` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The `add()` method takes the following parameters as input:'
  prefs: []
  type: TYPE_NORMAL
- en: '`product`: The `product` instance to add or update in the cart.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`quantity`: An optional integer with the product quantity. This defaults to
    `1`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`override_quantity`: A Boolean that indicates whether the quantity needs to
    be overridden with the given quantity (`True`) or whether the new quantity has
    to be added to the existing quantity (`False`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You use the product ID as a key in the cart’s content dictionary. You convert
    the product ID into a string because Django uses JSON to serialize session data,
    and JSON only allows string key names. The product ID is the key, and the value
    that you persist is a dictionary with quantity and price figures for the product.
    The product’s price is converted from decimal into a string to serialize it. Finally,
    you call the `save()` method to save the cart in the session.
  prefs: []
  type: TYPE_NORMAL
- en: The `save()` method marks the session as modified using `session.modified =
    True`. This tells Django that the session has changed and needs to be saved.
  prefs: []
  type: TYPE_NORMAL
- en: 'You also need a method for removing products from the cart. Add the following
    method to the `Cart` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The `remove()` method removes a given product from the `cart` dictionary and
    calls the `save()` method to update the cart in the session.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will have to iterate through the items contained in the cart and access
    the related `Product` instances. To do so, you can define an `__iter__()` method
    in your class. Add the following method to the `Cart` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In the `__iter__()` method, you retrieve the `Product` instances that are present
    in the cart to include them in the cart items. You copy the current cart in the
    `cart` variable and add the `Product` instances to it. Finally, you iterate over
    the cart items, converting each item’s price back into decimal, and adding a `total_price`
    attribute to each item. This `__iter__()` method will allow you to easily iterate
    over the items in the cart in views and templates.
  prefs: []
  type: TYPE_NORMAL
- en: You also need a way to return the total number of items in the cart. When the
    `len()` function is executed on an object, Python calls its `__len__()` method
    to retrieve its length. Next, you are going to define a custom `__len__()` method
    to return the total number of items stored in the cart.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following `__len__()` method to the `Cart` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: You return the sum of the quantities of all the cart items.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following method to calculate the total cost of the items in the cart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, add a method to clear the cart session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Your `Cart` class is now ready to manage shopping carts.
  prefs: []
  type: TYPE_NORMAL
- en: Creating shopping cart views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that you have a `Cart` class to manage the cart, you need to create the
    views to add, update, or remove items from it. You need to create the following
    views:'
  prefs: []
  type: TYPE_NORMAL
- en: A view to add or update items in the cart that can handle current and new quantities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A view to remove items from the cart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A view to display cart items and totals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding items to the cart
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To add items to the cart, you need a form that allows the user to select a
    quantity. Create a `forms.py` file inside the `cart` application directory and
    add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'You will use this form to add products to the cart. Your `CartAddProductForm`
    class contains the following two fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`quantity`: This allows the user to select a quantity between 1 and 20\. You
    use a `TypedChoiceField` field with `coerce=int` to convert the input into an
    integer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`override`: This allows you to indicate whether the quantity has to be added
    to any existing quantity in the cart for this product (`False`) or whether the
    existing quantity has to be overridden with the given quantity (`True`). You use
    a `HiddenInput` widget for this field since you don’t want to display it to the
    user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s create a view for adding items to the cart. Edit the `views.py` file
    of the `cart` application and add the following code highlighted in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This is the view for adding products to the cart or updating quantities for
    existing products. You use the `require_POST` decorator to allow only `POST` requests.
    The view receives the product ID as a parameter. You retrieve the `Product` instance
    with the given ID and validate `CartAddProductForm`. If the form is valid, you
    either add or update the product in the cart. The view redirects to the `cart_detail`
    URL, which will display the contents of the cart. You are going to create the
    `cart_detail` view shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'You also need a view to remove items from the cart. Add the following code
    to the `views.py` file of the `cart` application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The `cart_remove` view receives the product ID as a parameter. You use the `require_POST`
    decorator to allow only `POST` requests. You retrieve the `Product` instance with
    the given ID and remove the product from the cart. Then, you redirect the user
    to the `cart_detail` URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you need a view to display the cart and its items. Add the following
    view to the `views.py` file of the `cart` application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The `cart_detail` view gets the current cart to display it.
  prefs: []
  type: TYPE_NORMAL
- en: 'You have created views to add items to the cart, update quantities, remove
    items from the cart, and display the cart’s contents. Let’s add URL patterns for
    these views. Create a new file inside the `cart` application directory and name
    it `urls.py`. Add the following URL patterns to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit the main `urls.py` file of the `myshop` project and add the following
    URL pattern highlighted in bold to include the cart URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Make sure that you include this URL pattern before the `shop.urls` pattern since
    it’s more restrictive than the latter.
  prefs: []
  type: TYPE_NORMAL
- en: Building a template to display the cart
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `cart_add` and `cart_remove` views don’t render any templates, but you need
    to create a template for the `cart_detail` view to display cart items and totals.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the following file structure inside the `cart` application directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit the `cart/detail.html` template and add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Make sure that no template tag is split across multiple lines.
  prefs: []
  type: TYPE_NORMAL
- en: This is the template that is used to display the cart’s contents. It contains
    a table with the items stored in the current cart. You allow users to change the
    quantity of the selected products using a form that is posted to the `cart_add`
    view. You also allow users to remove items from the cart by providing a **Remove**
    button for each of them. Finally, you use an HTML form with an `action` attribute
    that points to the `cart_remove` URL including the product ID.
  prefs: []
  type: TYPE_NORMAL
- en: Adding products to the cart
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now you need to add an **Add to cart** button to the product detail page. Edit
    the `views.py` file of the `shop` application and add `CartAddProductForm` to
    the `product_detail` view, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit the `shop/product/detail.html` template of the `shop` application and
    add the following form to the product price, as follows. New lines are highlighted
    in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the development server with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Now open `http://127.0.0.1:8000/` in your browser and navigate to a product’s
    detail page. It will contain a form to choose a quantity before adding the product
    to the cart. The page will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, application  Description automatically generated](img/B21088_08_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.9: The product detail page, including the Add to cart button'
  prefs: []
  type: TYPE_NORMAL
- en: 'Choose a quantity and click on the **Add to cart** button. The form is submitted
    to the `cart_add` view via `POST`. The view adds the product to the cart in the
    session, including its current price and the selected quantity. Then, it redirects
    the user to the cart detail page, which will look like *Figure 8.10*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, timeline  Description automatically generated with
    medium confidence](img/B21088_08_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.10: The cart detail page'
  prefs: []
  type: TYPE_NORMAL
- en: Updating product quantities in the cart
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When users see the cart, they might want to change product quantities before
    placing an order. You are going to allow users to change quantities from the cart
    detail page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `views.py` file of the `cart` application and add the following lines
    highlighted in bold to the `cart_detail` view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: You create an instance of `CartAddProductForm` for each item in the cart to
    allow changing product quantities. You initialize the form with the current item
    quantity and set the `override` field to `True` so that when you submit the form
    to the `cart_add` view, the current quantity is replaced with the new one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now edit the `cart/detail.html` template of the `cart` application and find
    the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the previous line with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the development server with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Open `http://127.0.0.1:8000/cart/` in your browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will see a form to edit the quantity for each cart item, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, website  Description automatically generated](img/B21088_08_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.11: The cart detail page, including the form to update product quantities'
  prefs: []
  type: TYPE_NORMAL
- en: Change the quantity of an item and click on the **Update** button to test the
    new functionality. You can also remove an item from the cart by clicking the **Remove**
    button.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a context processor for the current cart
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You might have noticed that the message **Your cart is empty** is displayed
    in the header of the site, even when the cart contains items. You should display
    the total number of items in the cart and the total cost instead. Since this has
    to be displayed on all pages, you need to build a context processor to include
    the current cart in the request context, regardless of the view that processes
    the request.
  prefs: []
  type: TYPE_NORMAL
- en: Context processors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A context processor is a Python function that takes the `request` object as
    an argument and returns a dictionary that gets added to the request context. Context
    processors come in handy when you need to make something available globally to
    all templates.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, when you create a new project using the `startproject` command,
    your project contains the following template context processors in the `context_processors`
    option inside the `TEMPLATES` setting:'
  prefs: []
  type: TYPE_NORMAL
- en: '`django.template.context_processors.debug`: This sets the Boolean `debug` and
    `sql_queries` variables in the context, representing the list of SQL queries executed
    in the request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`django.template.context_processors.request`: This sets the `request` variable
    in the context.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`django.contrib.auth.context_processors.auth`: This sets the `user` variable
    in the request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`django.contrib.messages.context_processors.messages`: This sets a `messages`
    variable in the context containing all the messages that have been generated using
    the messages framework.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Django also enables `django.template.context_processors.csrf` to avoid **cross-site
    request forgery** (**CSRF**) attacks. This context processor is not present in
    the settings, but it is always enabled and can’t be turned off for security reasons.
  prefs: []
  type: TYPE_NORMAL
- en: You can see the list of all built-in context processors at [https://docs.djangoproject.com/en/5.0/ref/templates/api/#built-in-template-context-processors](https://docs.djangoproject.com/en/5.0/ref/templates/api/#built-in-template-context-processors).
  prefs: []
  type: TYPE_NORMAL
- en: Setting the cart in the request context
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s create a context processor to set the current cart in the request context.
    With it, you will be able to access the cart in any template.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file inside the `cart` application directory and name it `context_processors.py`.
    Context processors can reside anywhere in your code but creating them here will
    keep your code well organized. Add the following code to the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: In your context processor, you instantiate the cart using the `request` object
    and make it available for the templates as a variable named `cart`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `settings.py` file of your project and add `cart.context_processors.cart`
    to the `context_processors` option inside the `TEMPLATES` setting, as follows.
    The new line is highlighted in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The `cart` context processor will be executed every time a template is rendered
    using Django’s `RequestContext`. The `cart` variable will be set in the context
    of your templates. You can read more about `RequestContext` at [https://docs.djangoproject.com/en/5.0/ref/templates/api/#django.template.RequestContext](https://docs.djangoproject.com/en/5.0/ref/templates/api/#django.template.RequestContext).
  prefs: []
  type: TYPE_NORMAL
- en: Context processors are executed in all the requests that use `RequestContext`.
    You might want to create a custom template tag instead of a context processor
    if your functionality is not needed in all templates, especially if it involves
    database queries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, edit the `shop/base.html` template of the `shop` application and find
    the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the previous lines with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Restart the development server with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Open `http://127.0.0.1:8000/` in your browser and add some products to the cart.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the header of the website, you can now see the total number of items in
    the cart and the total cost, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, website  Description automatically generated](img/B21088_08_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.12: The site header displaying the current items in the cart'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have completed the shopping cart functionality. This is
    a significant milestone in your online shop project. Next, you are going to create
    the functionality to register customer orders, which is another foundational element
    of any e-commerce platform.
  prefs: []
  type: TYPE_NORMAL
- en: Registering customer orders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a shopping cart is checked out, you need to save an order in the database.
    Orders will contain information about customers and the products they are buying.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new application for managing customer orders using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit the `settings.py` file of your project and add the new application to
    the `INSTALLED_APPS` setting, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: You have activated the `orders` application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating order models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You will need a model to store the order details and a second model to store
    items bought, including their price and quantity. Edit the `models.py` file of
    the `orders` application and add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The order model contains several fields to store customer information and a
    `paid` Boolean field, which defaults to `False`. Later on, you are going to use
    this field to differentiate between paid and unpaid orders. We have also defined
    a `get_total_cost()` method to obtain the total cost of the items bought in this
    order.
  prefs: []
  type: TYPE_NORMAL
- en: The `OrderItem` model allows you to store the product, quantity, and price paid
    for each item. We have defined a `get_cost()` method that returns the cost of
    the item by multiplying the item price with the quantity. In the `product` field,
    we use the string `'shop.Product'` with the format `app.Model`, which is another
    way to point to related models and also a good method to avoid circular imports.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the next command to create initial migrations for the `orders` application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command to apply the new migration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Your order models are now synced to the database.
  prefs: []
  type: TYPE_NORMAL
- en: Including order models in the administration site
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s add the order models to the administration site. Edit the `admin.py`
    file of the `orders` application and add the following code highlighted in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: You use a `ModelInline` class for the `OrderItem` model to include it as an
    *inline* in the `OrderAdmin` class. An inline allows you to include a model on
    the same edit page as its related model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the development server with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Open `http://127.0.0.1:8000/admin/orders/order/add/` in your browser. You will
    see the following page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_08_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.13: The Add order form, including OrderItemInline'
  prefs: []
  type: TYPE_NORMAL
- en: Creating customer orders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You will use the order models that you created to persist the items contained
    in the shopping cart when the user finally places an order. A new order will be
    created following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Present a user with an order form to fill in their data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new `Order` instance with the data entered, and create an associated
    `OrderItem` instance for each item in the cart.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Clear all the cart’s contents and redirect the user to a success page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, you need a form to enter the order details. Create a new file inside
    the `orders` application directory and name it `forms.py`. Add the following code
    to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the form that you are going to use to create new `Order` objects. Now
    you need a view to handle the form and create a new order. Edit the `views.py`
    file of the `orders` application and add the following code highlighted in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `order_create` view, you obtain the current cart from the session with
    `cart = Cart(request)`. Depending on the request method, you perform the following
    tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '**GET request**: Instantiates the `OrderCreateForm` form and renders the `orders/order/create.html`
    template.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**POST request**: Validates the data sent in the request. If the data is valid,
    you create a new order in the database using `order = form.save()`. You iterate
    over the cart items and create an `OrderItem` for each of them. Finally, you clear
    the cart’s contents and render the template `orders/order/created.html`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create a new file inside the `orders` application directory and name it `urls.py`.
    Add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: This is the URL pattern for the `order_create` view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `urls.py` file of `myshop` and include the following pattern. Remember
    to place it before the `shop.urls` pattern, as follows. The new line is highlighted
    in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit the `cart/detail.html` template of the `cart` application and find this
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the `order_create` URL to the `href` HTML attribute, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Users can now navigate from the cart detail page to the order form.
  prefs: []
  type: TYPE_NORMAL
- en: 'You still need to define templates for creating orders. Create the following
    file structure inside the `orders` application directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit the `orders/order/create.html` template and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: This template displays the cart items, including totals and the form to place
    an order.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `orders/order/created.html` template and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: This is the template that you render when the order is successfully created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start the web development server to load new files. Open `http://127.0.0.1:8000/`
    in your browser, add a couple of products to the cart, and continue to the checkout
    page. You will see the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, application  Description automatically generated](img/B21088_08_14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.14: The order creation page, including the chart checkout form and
    order details'
  prefs: []
  type: TYPE_NORMAL
- en: 'Fill in the form with valid data and click on the **Place order** button. The
    order will be created, and you will see a success page like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A picture containing text  Description automatically generated](img/B21088_08_15.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.15: The order created template displaying the order number'
  prefs: []
  type: TYPE_NORMAL
- en: The order has been registered and the cart has been cleared.
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed that the message **Your cart is empty** is displayed
    in the header when an order is completed. This is because the cart has been cleared.
    We can easily avoid this message for views that have an `order` object in the
    template context.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `shop/base.html` template of the `shop` application and replace the
    following line highlighted in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: The message **Your cart is empty** will not be displayed anymore when an order
    is created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now open the administration site at `http://127.0.0.1:8000/admin/orders/order/`.
    You will see that the order has been successfully created, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_08_16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.16: The order change list section of the administration site, including
    the order created'
  prefs: []
  type: TYPE_NORMAL
- en: You have implemented the order system. Now you will learn how to create asynchronous
    tasks to send confirmation emails to users when they place an order.
  prefs: []
  type: TYPE_NORMAL
- en: Creating asynchronous tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When receiving an HTTP request, you need to return a response to the user as
    quickly as possible. Remember that in *Chapter 7*, *Tracking User Actions*, you
    used the Django Debug Toolbar to check the time for the different phases of the
    request/response cycle and the execution time for the SQL queries performed.
  prefs: []
  type: TYPE_NORMAL
- en: Every task executed during the course of the request/response cycle adds up
    to the total response time. Long-running tasks can seriously slow down the server
    response. How do we return a fast response to the user while still completing
    time-consuming tasks? We can do it with asynchronous execution.
  prefs: []
  type: TYPE_NORMAL
- en: Working with asynchronous tasks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can offload work from the request/response cycle by executing certain tasks
    in the background. For example, a video-sharing platform allows users to upload
    videos but requires a long time to transcode uploaded videos. When the user uploads
    a video, the site might return a response informing them that the transcoding
    will start soon and start transcoding the video asynchronously. Another example
    is sending emails to users. If your site sends email notifications from a view,
    the **Simple Mail Transfer Protocol** (**SMTP**) connection might fail or slow
    down the response. By sending the email asynchronously, you avoid blocking the
    code execution.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous execution is especially relevant for data-intensive, resource-intensive,
    and time-consuming processes or processes subject to failure, which might require
    a retry policy.
  prefs: []
  type: TYPE_NORMAL
- en: Workers, message queues, and message brokers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While your web server processes requests and returns responses, you need a second
    task-based server, named **worker**, to process the asynchronous tasks. One or
    multiple workers can be running and executing tasks in the background. These workers
    can access the database, process files, send emails, and so on. Workers can even
    queue future tasks, all while keeping the main web server free to process HTTP
    requests.
  prefs: []
  type: TYPE_NORMAL
- en: To tell the workers what tasks to execute, we need to send **messages**. We
    communicate with brokers by adding messages to a **message queue**, which is basically
    a **first in, first out** (**FIFO**) data structure. When a broker becomes available,
    it takes the first message from the queue and starts executing the corresponding
    task. When finished, the broker takes the next message from the queue and executes
    the corresponding task. Brokers become idle when the message queue is empty. When
    using multiple brokers, each broker takes the first available message in order
    when they become available. The queue ensures that each broker only gets one task
    at a time and that no task is processed by more than one worker.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 8.17* shows how a message queue works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Shape  Description automatically generated with medium confidence](img/B21088_08_17.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.17: Asynchronous execution using a message queue and workers'
  prefs: []
  type: TYPE_NORMAL
- en: A producer sends a message to the queue, and the worker(s) consumes the messages
    on a first-come, first-served basis; the first message added to the message queue
    is the first message to be processed by the worker(s).
  prefs: []
  type: TYPE_NORMAL
- en: In order to manage the message queue, we need a **message broker**. The message
    broker is used to translate messages to a formal messaging protocol and manage
    message queues for multiple receivers. It provides reliable storage and guaranteed
    message delivery. The message broker allows us to create message queues, route
    messages, distribute messages among workers, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: To implement asynchronous tasks in your project, you will use Celery for managing
    task queues and RabbitMQ as the message broker Celery employs. Both technologies
    will be introduced in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Using Django with Celery and RabbitMQ
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Celery is a distributed task queue that can process vast amounts of messages.
    We will use Celery to define asynchronous tasks as Python functions within our
    Django applications. We will run Celery workers that will listen to the message
    broker to get new messages to process asynchronous tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Using Celery, not only can you create asynchronous tasks easily and let them
    be executed by workers as soon as possible but you can also schedule them to run
    at a specific time. You can find the Celery documentation at [https://docs.celeryq.dev/en/stable/index.html](https://docs.celeryq.dev/en/stable/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: Celery communicates via messages and requires a message broker to mediate between
    clients and workers. There are several options for a message broker for Celery,
    including key/value stores such as Redis, or an actual message broker such as
    RabbitMQ.
  prefs: []
  type: TYPE_NORMAL
- en: RabbitMQ is the most widely deployed message broker. It supports multiple messaging
    protocols, such as the **Advanced Message Queuing Protocol** (**AMQP**), and it
    is the recommended message worker for Celery. RabbitMQ is lightweight, easy to
    deploy, and can be configured for scalability and high availability.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 8.18* shows how we will use Django, Celery, and RabbitMQ to execute
    asynchronous tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A picture containing diagram  Description automatically generated](img/B21088_08_18.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.18: Architecture for asynchronous tasks with Django, RabbitMQ, and
    Celery'
  prefs: []
  type: TYPE_NORMAL
- en: Installing Celery
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s install Celery and integrate it into the project. Install Celery via
    `pip` using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: You can find an introduction to Celery at [https://docs.celeryq.dev/en/stable/getting-started/introduction.html](https://docs.celeryq.dev/en/stable/getting-started/introduction.html).
  prefs: []
  type: TYPE_NORMAL
- en: Installing RabbitMQ
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The RabbitMQ community provides a Docker image that makes it very easy to deploy
    a RabbitMQ server with a standard configuration. Remember that you learned how
    to install Docker in *Chapter 3*, *Extending Your Blog Application*.
  prefs: []
  type: TYPE_NORMAL
- en: 'After installing Docker on your machine, you can easily pull the RabbitMQ Docker
    image by running the following command from the shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: This will download the RabbitMQ Docker image to your local machine. You can
    find information about the official RabbitMQ Docker image at [https://hub.docker.com/_/rabbitmq](https://hub.docker.com/_/rabbitmq).
  prefs: []
  type: TYPE_NORMAL
- en: If you want to install RabbitMQ natively on your machine instead of using Docker,
    you will find detailed installation guides for different operating systems at
    [https://www.rabbitmq.com/download.html](https://www.rabbitmq.com/download.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following command in the shell to start the RabbitMQ server with
    Docker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: With this command, we are telling RabbitMQ to run on port `5672`, and we are
    running its web-based management user interface on port `15672`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will see output that includes the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: RabbitMQ is running on port `5672` and ready to receive messages.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing RabbitMQ’s management interface
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Open `http://127.0.0.1:15672/` in your browser. You will see the login screen
    for the management UI of RabbitMQ. It will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application, email  Description automatically
    generated](img/B21088_08_19.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.19: The RabbitMQ management UI login screen'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter `guest` as both the username and the password and click on **Login**.
    You will see the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_08_20.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.20: The RabbitMQ management UI dashboard'
  prefs: []
  type: TYPE_NORMAL
- en: This is the default admin user for RabbitMQ. On this screen, you can monitor
    the current activity for RabbitMQ. You can see that there is one node running
    with no connections or queues registered.
  prefs: []
  type: TYPE_NORMAL
- en: If you use RabbitMQ in a production environment, you will need to create a new
    admin user and remove the default `guest` user. You can do that in the **Admin**
    section of the management UI.
  prefs: []
  type: TYPE_NORMAL
- en: Now we will add Celery to the project. Then, we will run Celery and test the
    connection to RabbitMQ.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Celery to your project
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You have to provide a configuration for the Celery instance. Create a new file
    next to the `settings.py` file of `myshop` and name it `celery.py`. This file
    will contain the Celery configuration for your project. Add the following code
    to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, you do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: You set the `DJANGO_SETTINGS_MODULE` variable for the Celery command-line program.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You create an instance of the application with `app = Celery('myshop')`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You load any custom configuration from your project settings using the `config_from_object()`
    method. The `namespace` attribute specifies the prefix that Celery-related settings
    will have in your `settings.py` file. By setting the `CELERY` namespace, all Celery
    settings need to include the `CELERY_` prefix in their name (for example, `CELERY_BROKER_URL`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, you tell Celery to auto-discover asynchronous tasks for your applications.
    Celery will look for a `tasks.py` file in each application directory of applications
    added to `INSTALLED_APPS` in order to load asynchronous tasks defined in it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You need to import the `celery` module in the `__init__.py` file of your project
    to ensure it is loaded when Django starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `myshop/__init__.py` file and add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: You have added Celery to the Django project, and you can now start using it.
  prefs: []
  type: TYPE_NORMAL
- en: Running a Celery worker
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A Celery worker is a process that handles bookkeeping features like sending/receiving
    queue messages, registering tasks, killing hung tasks, tracking status, and so
    on. A worker instance can consume from any number of message queues.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open another shell and start a Celery worker from your project directory, using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: The Celery worker is now running and ready to process tasks. Let’s check if
    there is a connection between Celery and RabbitMQ.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `http://127.0.0.1:15672/` in your browser to access the RabbitMQ management
    UI. You will now see a graph under **Queued messages** and another graph under
    **Message rates**, as in *Figure 8.21*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_08_21.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.21: The RabbitMQ management dashboard displaying connections and queues'
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, there are no queued messages as we haven’t sent any messages to the
    message queue yet. The graph under **Message rates** should update every five
    seconds; you can see the refresh rate at the top right of the screen. This time,
    both **Connections** and **Queues** should display a number higher than zero.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can start programming asynchronous tasks.
  prefs: []
  type: TYPE_NORMAL
- en: The `CELERY_ALWAYS_EAGER` setting allows you to execute tasks locally in a synchronous
    manner instead of sending them to the queue. This is useful for running unit tests
    or executing the application in your local environment without running Celery.
  prefs: []
  type: TYPE_NORMAL
- en: Adding asynchronous tasks to your application
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s send a confirmation email to the user whenever an order is placed in the
    online shop. We will implement sending the email in a Python function and register
    it as a task with Celery. Then, we will add it to the `order_create` view to execute
    the task asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: When the `order_create` view is executed, Celery will send the message to a
    message queue managed by RabbitMQ and then a Celery broker will execute the asynchronous
    task that we defined with a Python function.
  prefs: []
  type: TYPE_NORMAL
- en: The convention for easy task discovery by Celery is to define asynchronous tasks
    for your application in a `tasks` module within the application directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file inside the `orders` application and name it `tasks.py`. This
    is the place where Celery will look for asynchronous tasks. Add the following
    code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: We have defined the `order_created` task by using the `@shared_task` decorator.
    As you can see, a Celery task is just a Python function decorated with `@shared_task`.
    The `order_created` task function receives an `order_id` parameter. It’s always
    recommended to only pass IDs to task functions and retrieve objects from the database
    when the task is executed. By doing so, we avoid accessing outdated information
    since the data in the database might have changed while the task was queued. We
    have used the `send_mail()` function provided by Django to send an email notification
    to the user who placed the order.
  prefs: []
  type: TYPE_NORMAL
- en: 'You learned how to configure Django to use your SMTP server in *Chapter 2*,
    *Enhancing Your Blog with Advanced Features*. If you don’t want to set up email
    settings, you can tell Django to write emails to the console by adding the following
    setting to the `settings.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Use asynchronous tasks not only for time-consuming processes but also for other
    processes that do not take so much time to be executed but that are subject to
    connection failures or require a retry policy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you have to add the task to your `order_create` view. Edit the `views.py`
    file of the `orders` application, import the task, and call the `order_created`
    asynchronous task after clearing the cart, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: You call the `delay()` method of the task to execute it asynchronously. The
    task will be added to the message queue and executed by the Celery worker as soon
    as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure RabbitMQ is running. Then, stop the Celery worker process and start
    it again with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'The Celery worker has now registered the task. In another shell, start the
    development server from the project directory with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Open `http://127.0.0.1:8000/` in your browser, add some products to your shopping
    cart, and complete an order. In the shell where you started the Celery worker,
    you will see output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: The `order_created` task has been executed and an email notification for the
    order has been sent. If you are using the email backend `console.EmailBackend`,
    no email is sent but you should see the rendered text of the email in the output
    of the console.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring Celery with Flower
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Besides the RabbitMQ management UI, you can use other tools to monitor the asynchronous
    tasks that are executed with Celery. Flower is a useful web-based tool for monitoring
    Celery. You can find the documentation for Flower at [https://flower.readthedocs.io/](https://flower.readthedocs.io/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Install Flower using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Once installed, you can launch Flower by running the following command in a
    new shell from your project directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Open `http://localhost:5555/` in your browser. You will be able to see the
    active Celery workers and asynchronous task statistics. The screen should look
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_08_22.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.22: The Flower dashboard'
  prefs: []
  type: TYPE_NORMAL
- en: You will see an active worker whose name starts with **celery@** and whose status
    is **Online**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the worker’s name and then click on the **Queues** tab. You will see
    the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_08_23.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.23: Flower – Worker Celery task queues'
  prefs: []
  type: TYPE_NORMAL
- en: Here you can see the active queue named **celery**. This is the active queue
    consumer connected to the message broker.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the **Tasks** tab. You will see the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_08_24.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.24: Flower – Worker Celery tasks'
  prefs: []
  type: TYPE_NORMAL
- en: Here you can see the tasks that have been processed and the number of times
    that they have been executed. You should see the `order_created` task and the
    total times that it has been executed. This number might vary depending on how
    many orders you have placed.
  prefs: []
  type: TYPE_NORMAL
- en: Open `http://localhost:8000/` in your browser. Add some items to the cart and
    then complete the checkout process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `http://localhost:5555/` in your browser. Flower has registered the task
    as processed. You should now see `1` under **Processed** and `1` under **Succeeded**
    as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_08_25.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.25: Flower – Celery workers'
  prefs: []
  type: TYPE_NORMAL
- en: 'Under **Tasks**, you can see additional details about each task registered
    with Celery:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_08_26.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.26: Flower – Celery tasks'
  prefs: []
  type: TYPE_NORMAL
- en: 'Flower should never be deployed openly in a production environment without
    security. Let’s add authentication to the Flower instance. Stop Flower using *Ctrl
    + C*, and restart it with the `--basic-auth` option by executing the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace `user` and `pwd` with your desired username and password. Open `http://localhost:5555/`
    in your browser. The browser will now prompt you for credentials, as shown in
    *Figure 8.27*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_08_27.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.27: Basic authentication required to access Flower'
  prefs: []
  type: TYPE_NORMAL
- en: Flower provides other authentication options, such as Google, GitHub, or Okta
    OAuth. You can read more about Flower’s authentication methods at [https://flower.readthedocs.io/en/latest/auth.html](https://flower.readthedocs.io/en/latest/auth.html).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you created a basic e-commerce application. You made a product
    catalog and built a shopping cart using sessions. You implemented a custom context
    processor to make the cart available to all templates and created a form for placing
    orders. You also learned how to implement asynchronous tasks using Celery and
    RabbitMQ. Having completed this chapter, you now understand the foundational elements
    of building an e-commerce platform with Django, including managing products, processing
    orders, and handling asynchronous tasks. You are now also capable of developing
    projects that efficiently process user transactions and scale to handle complex
    background operations seamlessly.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will discover how to integrate a payment gateway into
    your shop, add custom actions to the administration site, export data in CSV format,
    and generate PDF files dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: Additional resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following resources provide additional information related to the topics
    covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Source code for this chapter – [https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter08](https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter08)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static files for the project – [https://github.com/PacktPublishing/Django-5-by-Example/tree/main/Chapter08/myshop/shop/static](https://github.com/PacktPublishing/Django-5-by-Example/tree/main/Chapter08/myshop/shop/static
    )
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Django session settings – [https://docs.djangoproject.com/en/5.0/ref/settings/#sessions](https://docs.djangoproject.com/en/5.0/ref/settings/#sessions)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Django built-in context processors – [https://docs.djangoproject.com/en/5.0/ref/templates/api/#built-in-template-context-processors](https://docs.djangoproject.com/en/5.0/ref/templates/api/#built-in-template-context-processors)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Information about `RequestContext` – [https://docs.djangoproject.com/en/5.0/ref/templates/api/#django.template.RequestContext](https://docs.djangoproject.com/en/5.0/ref/templates/api/#django.template.RequestContext)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Celery documentation – [https://docs.celeryq.dev/en/stable/index.html](https://docs.celeryq.dev/en/stable/index.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to Celery – [https://docs.celeryq.dev/en/stable/getting-started/introduction.html](https://docs.celeryq.dev/en/stable/getting-started/introduction.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Official RabbitMQ Docker image – [https://hub.docker.com/_/rabbitmq](https://hub.docker.com/_/rabbitmq)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RabbitMQ installation instructions – [https://www.rabbitmq.com/download.html](https://www.rabbitmq.com/download.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flower documentation – [https://flower.readthedocs.io/](https://flower.readthedocs.io/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flower authentication methods – [https://flower.readthedocs.io/en/latest/auth.html](https://flower.readthedocs.io/en/latest/auth.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Join us on Discord!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Read this book alongside other users, Django development experts, and the author
    himself. Ask questions, provide solutions to other readers, chat with the author
    via Ask Me Anything sessions, and much more.Scan the QR code or visit the link
    to join the community.
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/Django5ByExample](https://packt.link/Django5ByExample)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code287089408934129031.png)'
  prefs: []
  type: TYPE_IMG
