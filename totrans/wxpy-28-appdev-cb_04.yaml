- en: Chapter 4. Advanced Building Blocks of a User Interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Listing data with a `ListCtrl`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Browsing files with the `CustomTreeCtrl`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a `VListBox`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StyledTextCtrl` using lexers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with tray icons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding tabs to a `Notebook`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `FlatNotebook`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scrolling with a `ScrolledPanel`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simplifying the `FoldPanelBar`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Displaying collections of data and managing complex window layouts are a task
    that most UI developers will be faced with at some point. wxPython provides a
    number of components to help developers meet the requirements of these more demanding
    interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: As the amount of controls and data that an application is required to display
    in its user interface increases, so does the task of efficiently managing available
    screen real estate. To fit this information into the available space requires
    the use of some more advanced controls and containers; so let's dive in and begin
    our exploration of some of the more advanced controls that wxPython has to offer.
  prefs: []
  type: TYPE_NORMAL
- en: Listing data with a ListCtrl
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ListCtrl` is a versatile control for displaying collections of text and/or
    images. The control supports many different display formats, although typically
    its most often-used display mode is the report mode. Report mode has a visual
    representation that is very similar to a grid or spreadsheet in that it can have
    multiple rows and columns with column headings. This recipe shows how to populate
    and retrieve data from a `ListCtrl` that was created in report mode.
  prefs: []
  type: TYPE_NORMAL
- en: '![Listing data with a ListCtrl](img/1780_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `ListCtrl` takes a little more set up than most basic controls, so we will
    start by creating a subclass that sets up the columns that we wish to have in
    the control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we will create an instance of our `ListCtrl` and put it on a `Panel`,
    and then use our `PopulateList` method to put some sample data into the control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Usually there tends to be a fair amount of set up with the `ListCtrl`, and due
    to this it is good to encapsulate the usage of the control in a specialized subclass
    instead of using it directly. We kept things pretty basic here in our `ListCtrl`
    class. We just used the `InsertColumn` method to set our list up with three columns.
    Then the `PopulateList` method was added for convenience, to allow the population
    of the `ListCtrl` from a Python list of data. It simply wraps the `Append` method
    of `ListCtrl`, which just takes an iterable that has a string for each column
    in the list.
  prefs: []
  type: TYPE_NORMAL
- en: The `MyPanel` class is there to show how to use the `ListCtrl` class that we
    created. First we populate it with some data by generating a list of tuples and
    calling our `PopulateList` method. To show how to retrieve data from the list,
    we created an event handler for `EVT_LIST_ITEM_SELECTED` which will be fired each
    time a new selection is made in the control. In order to retrieve a value from
    a `ListCtrl`, you need to know the row and column index of the cell that you wish
    to retrieve the data from, and then call `GetItem` with the row and column to
    get the `ListItem` object that represents that cell. Then the string value of
    the cell can be retrieved by calling the `GetText` method of `ListItem`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Depending on the style flags that are used to create a `ListCtrl`, it will behave
    in many different possible ways. Because of this, it is important to know some
    of the different style flags that can be used to create a `ListCtr`.
  prefs: []
  type: TYPE_NORMAL
- en: '| Style flags | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `LC_LIST` | In List mode, the control will calculate the columns automatically,
    so there is no need to call `InsertColumn`. It can be used to display strings
    and, optionally, small icons |'
  prefs: []
  type: TYPE_TB
- en: '| `LC_REPORT` | Single or multicolumn report view that can be shown with or
    without headers |'
  prefs: []
  type: TYPE_TB
- en: '| `LC_ICON` | Large icon view that can optionally have labels |'
  prefs: []
  type: TYPE_TB
- en: '| `LC_SMALL_ICON` | Small icon view that can optionally have labels |'
  prefs: []
  type: TYPE_TB
- en: '| `LC_EDIT_LABELS` | Allow the item labels to be editable by users |'
  prefs: []
  type: TYPE_TB
- en: '| `LC_NO_HEADER` | Hide the column headers (report mode) |'
  prefs: []
  type: TYPE_TB
- en: '| `LC_SORT_ASCENDING` | Sort items in ascending order (must provide a `SortItems`
    callback method) |'
  prefs: []
  type: TYPE_TB
- en: '| `LC_SORT_DESCENDING` | Sort items in descending order (must provide a `SortItems`
    callback method) |'
  prefs: []
  type: TYPE_TB
- en: '| `LC_HRULE` | Draw a horizontal line between rows (report mode) |'
  prefs: []
  type: TYPE_TB
- en: '| `LC_VRULE` | Draw a vertical line between columns (report mode) |'
  prefs: []
  type: TYPE_TB
- en: '| `LC_SINGLE_SEL` | Only allow a single item to be selected at a time (Default
    is to allow for multiple selections) |'
  prefs: []
  type: TYPE_TB
- en: '| `LC_VIRTUAL` | Fetch items to display in the list on demand (report mode)
    |'
  prefs: []
  type: TYPE_TB
- en: Virtual Mode
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When a `ListCtrl` is created in virtual mode (using the `LC_VIRTUAL` style flag),
    it does not store the data internally; instead it will instead ask for the data
    from a datasource when it needs to display it. This mode is useful when you have
    a very large set of data where preloading it in the control would present performance
    issues. To use a `ListCtrl` in virtual mode, you must call `SetItemCount` to tell
    the control how many rows of data there are, and override the `OnGetItemText`
    method to return the text for the `ListItem` when the control asks for it.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating a VListBox* recipe in this chapter is another example of a control
    for presenting data as a list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Browsing files with the CustomTreeCtrl
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `TreeCtrl` is a way of displaying hierarchical data in a user interface. The
    `CustomTreeCtrl` is a fully owner-drawn `TreeCtrl` that looks and functions much
    the same way as the default `TreeCtrl`, but that offers a number of additional
    features and customizability that the default native control cannot. This recipe
    shows how to make a custom file browser class by using the `CustomTreeCtrl`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create this custom `FileBrowser` control, we will use its constructor to
    set up the images to use for the folders and files in the tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following two event handlers are used to update which files are displayed
    when a node is expanded or collapsed in the tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following methods are added as an API for working with the control to add
    items and retrieve their on-disk paths:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With just a few lines of code here we have created a pretty useful little widget
    for displaying and working with the file system. Let's take a quick look at how
    it works.
  prefs: []
  type: TYPE_NORMAL
- en: In the classes constructor, we added a root node with the control's `AddRoot`
    method. A root node is a top-level node that has no other parent nodes above it.
    The first argument is the text that will be shown, the `image` argument specifies
    the default image for the `TreeItem`, and the `data` argument specifies any type
    of data associated with the item—in this case we are setting a string for the
    items path. We then called `SetItemHasChildren` for the item so that it will get
    a button next to it to allow it to be expanded. The last thing that we did in
    the constructor was to `Bind` the control to two events so that we can update
    the tree when one of its nodes is being expanded or collapsed.
  prefs: []
  type: TYPE_NORMAL
- en: Immediately before the node is going to be expanded our handler for `EVT_TREE_ITEM_EXPANDING`
    will be called. It is here where we find all the files and folders under a directory
    node, and then add them as children of that node by calling `AppendItem`, which
    works just like `AddRoot` but is used to add items to already-existing nodes in
    the tree.
  prefs: []
  type: TYPE_NORMAL
- en: Conversely when a node in the tree is going to be collapsed, our `EVT_TREE_ITEM_COLLAPED`
    event handler will be called. Here we simply call `DeleteChildren` in order to
    remove the children items from the node so that we can update them more easily
    the next time that the node is expanded. Otherwise, we would have to find what
    was different the next time it was expanded, and then remove the items that have
    been deleted and insert new items that may have been added to the directory.
  prefs: []
  type: TYPE_NORMAL
- en: The last two items in our class are for getting the file paths of the selected
    items, which—since we store the file path in each node—is simply just a matter
    of getting the data from each of the currently-selected `TreeItems` with a call
    to `GetPyData`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most of what we did in this recipe could actually also be replicated with the
    standard `TreeCtrl`. The difference is in the amount of extra customizability
    that the `CustomTreeCtrl` provides. Since it is a fully owner-drawn control, nearly
    all of the visible attributes of it can be customized. Following is a list of
    some of the functions that can be used to customize its appearance:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Functions | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `EnableSelectionGradient(bool)` | Use a gradient to draw the tree item selection
    rectangle. |'
  prefs: []
  type: TYPE_TB
- en: '| `EnableSelectionVista(bool)` | Use a nice rounded rectangle for the item
    selections similar to the native control seen in Windows Vista. |'
  prefs: []
  type: TYPE_TB
- en: '| `SetButtonsImageList(ImageList)` | Changes the expand/collapse buttons. `ImageList`
    should have four bitmaps for the following states, in this order: `Normal, Selected,
    Expanded`, and `Expanded Selected`. |'
  prefs: []
  type: TYPE_TB
- en: '| `SetConnectionPen(pen)` | Changes how the connection lines are drawn between
    items in the tree. Takes a `wx.Pen` object that will be used to draw the lines.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `SetBackgroundImage(bitmap)` | Allows for an image to be used as the control''s
    background. |'
  prefs: []
  type: TYPE_TB
- en: '| `SetBackgroundColour(colour)` | Used to change the color of the control''s
    background. |'
  prefs: []
  type: TYPE_TB
- en: Creating a VListBox
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `VListBox` control is much like a `ListBox` control, but it is virtual (it
    doesn't store the data internally) and allows for items to have variable row heights.
    It works by providing a number of virtual callback methods that you must override
    in a subclass in order to draw the items on demand. Because of this requirement
    to override pure virtual methods, the `VListBox` will always be subclassed. This
    recipe shows how to create a `VListBox` derived control that supports an icon
    and text in each of its items.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create our user list control, we just need to subclass a `VListBox` and
    override some of its callback methods to perform the necessary actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here is a screenshot of what the `UserListBox` looks like with some sample data
    in it.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/1780_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our custom `VListBox` control could be used in any kind of application that
    wants to display a list of users. The constructor takes a list of usernames and
    calls `SetItemCount` to tell the control how many items it needs to be able to
    display. We also loaded a bitmap to use in our list's items. This bitmap is available
    in the sample code that accompanies this topic.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main thing to take from this recipe is the three virtual callback methods
    that we overrode in order to draw the items in our control:'
  prefs: []
  type: TYPE_NORMAL
- en: The first required override is `OnMeasureItem`. This method will be called for
    each item in the list, and it needs to return the height of the item.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next method is `OnDrawSeparator`. This method is optional and can be used
    to draw a separator between each item in the control. It can also modify the `Rect`
    if necessary, so that when `OnDrawItem` is called it will know not to draw over
    the separator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The final method is `OnDrawItem`. This method is used to draw the actual item.
    For our control, we draw a bitmap and then position the users' name as a label
    to the right of it. That's all there is to it; pretty easy right.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a couple more methods available that can be useful in implementing
    a `VListBox` subclass. The following list describes these methods.
  prefs: []
  type: TYPE_NORMAL
- en: '| Methods | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `OnDrawItemBackground` | This method can be overridden, as `DrawItem` can,
    in order to draw a custom background for an item. The default base class does
    the reasonable thing of drawing the background of the selected item with the system
    default selection color. |'
  prefs: []
  type: TYPE_TB
- en: '| `IsSelected` | This method can be used to see if an item is selected or not,
    in case you want to change the way in which you draw the item in `OnDrawItem`,
    for example making the font bold. |'
  prefs: []
  type: TYPE_TB
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Understanding inheritance limitations* recipe in [Chapter 1](ch01.html
    "Chapter 1. Getting Started with wxPython"), *Getting Started with wxPython* contains
    an explanation about virtual methods in the C++ objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Listing data with a ListCtrl* recipe in this chapter is another example
    of a control for presenting data as a list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Screen drawing* recipe in [Chapter 8](ch08.html "Chapter 8. Drawing to
    the Screen"), *Drawing to the Screen*, discusses the usage of PaintEvents and
    Device Contexts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: StyledTextCtrl using lexers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `StyledTextCtrl` is an advanced text control class supplied by the `wx.stc`
    module. The class is a wrapping around the Scintilla source control editing component
    (see [http://www.scintilla.org)](http://www.scintilla.org)). The `StyledTextCtrl`
    is primarily intended for displaying and working with source code for various
    programming languages. It provides built-in syntax highlighting support for many
    different types of source code files, and is extendable to work with custom lexers.
    This recipe shows how to setup the control to perform source code highlighting
    using its built-in lexer for Python.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To get started, we will define a language-generic editor class that will manage
    all the common style settings so that we can easily create other classes that
    support different types of programming languages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now here we will derive a new class from our `CodeEditorBase` class that specializes
    the control for Python files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We created two classes: a base editor class and a specialized class for Python
    source files. Let''s first start by taking a look at the `CodeEditorBase` class.'
  prefs: []
  type: TYPE_NORMAL
- en: The `CodeEditorBase` sets up the basic functionality of the control, and is
    just there to encapsulate some of the common items, should we decide to add other
    specialized classes for different types of source files later on.
  prefs: []
  type: TYPE_NORMAL
- en: 'First and foremost, it initializes the basic window styles and provides font
    information. The `StyledTextCtrl` has a number of style specifications for styling
    different text in the buffer. These styles are specified using the `StyleSetSpec`
    method, which takes the style ID and style specification string as arguments.
    The style IDs that are generic to all lexers are identified with the `STC_STYLE_`
    prefix. The style specification string is formatted in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `ATTRIBUTE` and `VALUE` are replaced by any combination of the possible
    specifications in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Attributes | Possible values |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `fore` | Foreground color; can either be a color name (black) or hex color
    string (for example, `#000000)` |'
  prefs: []
  type: TYPE_TB
- en: '| `back` | Background color; can either be a color name (white) or hex color
    string (for example, `#FFFFFF)` |'
  prefs: []
  type: TYPE_TB
- en: '| `face` | A font face name (for example, `Monaco)` |'
  prefs: []
  type: TYPE_TB
- en: '| `size` | A point size for the font (for example, `10)` |'
  prefs: []
  type: TYPE_TB
- en: 'There is also support from some additional `MODIFER` attributes that don''t
    take a `VALUE` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Modifier | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `bold` | Makes the text bold |'
  prefs: []
  type: TYPE_TB
- en: '| `italic` | Italicizes the text |'
  prefs: []
  type: TYPE_TB
- en: '| `eol` | Extends the background style to the end of the current line |'
  prefs: []
  type: TYPE_TB
- en: '| `underline` | Underlines the text |'
  prefs: []
  type: TYPE_TB
- en: The `StyledTextCtrl` also supports special margins on the left-hand side of
    the buffer for displaying things such as line numbers, breakpoints, and code folding
    buttons. Our `CodeEditorBase` shows how to enable line numbers in the left-most
    margin with its `EnableLineNumbers` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our derived `PythonCodeEditor` class simply does the three basic things necessary
    to set up the proper lexer:'
  prefs: []
  type: TYPE_NORMAL
- en: First, it calls `SetLexer` to set the lexer mode. This method simply takes one
    of the `STC_LEX_FOO` values that are found in the `stc` module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Second, it sets up the keywords for the lexer. There is little documentation
    on what keyword sets are available for each lexer, so it is sometimes necessary
    to look at the Scintilla source code to see what keyword sets have been defined
    for each lexer. The Python lexer supports two keyword sets: one for language keywords
    and a second for user- defined keywords. The `SetKeywords` method takes two arguments:
    a keyword ID and a string of space-separated keywords to associate with that ID.
    Each keyword ID is associated with a Style ID for the given lexer. In this example,
    the keyword ID of zero is associated with the Style ID: `STC_P_WORD`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Third and finally, it sets all of the styling specifications for the lexer.
    This is done just as we did in our base class by calling `StyleSetSpec` for each
    lexer style specification ID that the lexer defines. A quick reference for what
    styles relate to what lexers can be found in the wxPython wiki ([http://wiki.wxpython.org/StyledTextCtrl%20Lexer%20Quick%20Reference](http://wiki.wxpython.org/StyledTextCtrl%20Lexer%20Quick%20Reference)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `StyledTextCtrl` is a big class that comes with a very large API. It has
    many additional features that we did not discuss here, such as pop-up lists for
    implementing auto-completion, clickable hotspots, code folding, and custom highlighting.
    Following are links to some references and documentation about the `StyledTextCtrl:`
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.yellowbrain.com/stc/index.html](http://www.yellowbrain.com/stc/index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.wxpython.org/docs/api/wx.stc.StyledTextCtrl-class.html](http://www.wxpython.org/docs/api/wx.stc.StyledTextCtrl-class.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://wiki.wxpython.org/StyledTextCtrl](http://wiki.wxpython.org/StyledTextCtrl)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Using the TextCtrl* recipe in [Chapter 3](ch03.html "Chapter 3. Basic Building
    Blocks of a User Interface"), *Basic Building Blocks of a User Interface* shows
    how to use the basic text control.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *StyledTextCtrl custom highlighting* recipe in [Chapter 10](ch10.html "Chapter 10. Creating
    Components and Extending Functionality"), *Creating Components and Extending Functionality*
    shows how to extend the `StyledTextCtrl` in order to perform custom text styling.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with tray icons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tray icons are UI components that integrate with the window manager's Task Bar
    (Windows / Linux) or Dock (OS X). They can be used for notifications and to provide
    a pop-up menu when the user clicks on the notification icon. This recipe shows
    how to create and use a tray icon through the use of the `TaskBarIcon` class.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create the icon bar for this recipe''s sample code, we create a subclass
    of `TaskBarIcon` that loads an image to use for its display, and that has handling
    for showing a `Menu` when it is clicked on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `TaskBarIcon` class is pretty easy and straightforward to use. All that
    needs to be done is to create an icon and call `SetIcon` to create the UI part
    of the object that will be shown in the system tray. Then we override the `CreatePopupMenu`
    method that the base class will call when the icon is clicked on, to create the
    menu. All that this method needs to do is create a `Menu` object and then return
    it; the `TaskBarIcon` class will take care of the rest. Finally, we added an event
    handler for `EVT_MENU` to handle the menu events from our pop-up menu.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `TaskBarIcon` class has a number of events associated with it, if you want
    to customize what different types of clicks do. Please see the following table
    for a list of available events and a description of when they are called.
  prefs: []
  type: TYPE_NORMAL
- en: '| Events | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `EVT_TASKBAR_CLICK` | Icon was clicked on by the mouse |'
  prefs: []
  type: TYPE_TB
- en: '| `EVT_TASKBAR_LEFT_DCLICK` | Left mouse button double clicked on the icon
    |'
  prefs: []
  type: TYPE_TB
- en: '| `EVT_TASKBAR_LEFT_DOWN` | Left mouse button clicked down on the icon |'
  prefs: []
  type: TYPE_TB
- en: '| `EVT_TASKBAR_LEFT_UP` | Left mouse button released on the icon |'
  prefs: []
  type: TYPE_TB
- en: '| `EVT_TASKBAR_MOVE` | The `TaskBarIcon` moved |'
  prefs: []
  type: TYPE_TB
- en: '| `EVT_TASKBAR_RIGHT_DCLICK` | Right mouse button double clicked on the icon
    |'
  prefs: []
  type: TYPE_TB
- en: '| `EVT_TASKBAR_RIGHT_DOWN` | Right mouse button clicked down on the icon |'
  prefs: []
  type: TYPE_TB
- en: '| `EVT_TASKBAR_RIGHT_UP` | Right mouse button released on the icon |'
  prefs: []
  type: TYPE_TB
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Adding Menus and MenuBars* recipe in [Chapter 3](ch03.html "Chapter 3. Basic
    Building Blocks of a User Interface"), *Basic Building Blocks of a User Interface*
    contains more examples of using and creating menus.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *How to use PopupMenus* recipe in [Chapter 3](ch03.html "Chapter 3. Basic
    Building Blocks of a User Interface"), *Basic Building Blocks of a User Interface*
    contains another example of creating a context menu.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding tabs to a Notebook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Notebook` class is a container control that is used to manage multiple
    panels through the use of tabs. When a tab is selected, the associated panel is
    shown and the previous one is hidden. This recipe shows how to use the default
    native `Notebook` class to create a tab-based user interface like the one shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding tabs to a Notebook](img/1780_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following example code snippet defines a `Notebook` class that has three
    tabs in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe just shows the fundamental basics of how to use the `Notebook`
    control. We simply created some window objects that we wish to put in the `Notebook`.
    In this case, we created three different objects: a `TextCtrl`, a `Panel`, and
    a `GenericDirCtrl`. The important thing to note is that the items that we wish
    to put in the `Notebook` must be children of the `Notebook`.'
  prefs: []
  type: TYPE_NORMAL
- en: The objects are then added to the `Notebook` by calling its `AddPage` method.
    This method takes a window object and a label to put on the tab as arguments.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The basic `Notebook` class doesn't offer too many more features beyond what
    was shown above. However, there are a few additional styles, and some events related
    to when tabs are selected. Included below are some quick references to these additional
    items.
  prefs: []
  type: TYPE_NORMAL
- en: Styles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following styles can be provided to the Notebook''s constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Style | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `NB_BOTTOM` | Put the tabs at the bottom of the control area |'
  prefs: []
  type: TYPE_TB
- en: '| `NB_FIXEDWIDTH` | All tabs are the same size (Windows only) |'
  prefs: []
  type: TYPE_TB
- en: '| `NB_LEFT` | Put the tabs on the left side of the control area |'
  prefs: []
  type: TYPE_TB
- en: '| `NB_MULTILINE` | Allow for multiple rows of tabs (Windows only) |'
  prefs: []
  type: TYPE_TB
- en: '| `NB_NOPAGETHEME` | Use a solid color for the tabs (Windows only) |'
  prefs: []
  type: TYPE_TB
- en: '| `NB_RIGHT` | Put the tabs on the right-hand side of the control area |'
  prefs: []
  type: TYPE_TB
- en: '| `NB_TOP` | Put the tabs at the top of the control area (Default) |'
  prefs: []
  type: TYPE_TB
- en: Events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Notebook emits the following events:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Event | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `EVT_NOTEBOOK_PAGE_CHANGING` | This event is fired when the Notebook is in
    the process of changing the page from one to another. Calling Veto on the event
    object will block the page from being changed. |'
  prefs: []
  type: TYPE_TB
- en: '| `EVT_NOTEBOOK_PAGE_CHANGED` | This event is fired when the selected page
    has been changed. |'
  prefs: []
  type: TYPE_TB
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Using the FlatNotebook* recipe in this chapter shows the usage of another
    type of tab control.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the FlatNotebook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `FlatNotebook` class is a custom `Notebook` implementation that provides
    a large array of features over the default `Notebook`. The additional features
    include such things as being able to have a close button on each tab, drag and
    drop tabs to different positions, and a number of different tab styles to change
    the look and feel of the control. This recipe will explore some of the extended
    functionality that this control provides.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As an example of how to use the `FlatNotebook`, we will define a subclass that
    has some specializations for displaying multiple `TextCtrls:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the following screenshot, we can see the above subclass in action, in a simple
    file editor application. The full source code for the below application is available
    with the code that accompanies this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/1780_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This little recipe demonstrates quite a few of the features that the `FlatNotebook`
    offers over the standard `Notebook` class. So let's break it down, section by
    section, starting with the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our subclass''s constructor we specified four style flags. The first, `FNB_DROPDOWN_TAB_LIST`,
    specifies that we want to have a drop-down list that shows all the open tabs.
    The drop-down list is the small down-arrow button: clicking on it will show a
    pop-up menu that allows one of the currently open tabs to be selected from the
    list. The second style flag, `FNB_FF2`, specifies that we want tabs that use the
    Firefox 2 tab renderer, which will draw tabs that look and feel similar to the
    ones in Firefox 2\. The third style flag, `FNB_SMART_TABS`, specifies that the
    *Ctrl + Tab* shortcut will pop up a dialog that shows the open tabs and allows
    them to be cycled through by pressing the *Tab* key. The fourth and final style
    flag that we used, `FNB_X_ON_TAB`, specifies that we want a close button to be
    shown on the active tab. This allows the user to dismiss a tab when this button
    is clicked on.'
  prefs: []
  type: TYPE_NORMAL
- en: In order to be able to show icons on the tabs, we also created and assigned
    an `ImageList` to the control. An `ImageList` is simply a container for holding
    `Bitmap` objects, and the control will use it for retrieving the bitmap data when
    it draws the tabs. The important point to notice is that we keep a reference to
    the object by assigning it to `self._imglst`; it is important to keep a reference
    to it so that it doesn't get garbage collected.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing that we did was `Bind` the control to the page closing event
    `EVT_FLATNOTEBOOK_PAGE_CLOSING`. In this example, we are expecting our pages to
    provide an `IsModified` method so that we can check for unsaved changes prior
    to closing the page, in order to give the user a chance to cancel closing the
    page.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Because the `FlatNotebook` is a pure Python class, it is more customizable
    than the basic `Notebook` class. Included below is a listing of the style flags
    that can be used to customize the appearance and behavior of the control:'
  prefs: []
  type: TYPE_NORMAL
- en: Style flags
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here is a list of the other style flags that are available that we didn''t
    already cover:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Style flags | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `FNB_ALLOW_FOREIGN_DND` | Allow tabs to be dragged and moved to and accepted
    from other `FlatNotebook` instances |'
  prefs: []
  type: TYPE_TB
- en: '| `FNB_BACKGROUND_GRADIENT` | Draw a gradient in the tabs background area |'
  prefs: []
  type: TYPE_TB
- en: '| `FNB_BOTTOM` | Place the tabs at the bottom of the control area |'
  prefs: []
  type: TYPE_TB
- en: '| `FNB_COLORFUL_TABS` | Use colorful tabs (VC8 style only) |'
  prefs: []
  type: TYPE_TB
- en: '| `FNB_DCLICK_CLOSES_TABS` | Allow double-clicks to close the active tab |'
  prefs: []
  type: TYPE_TB
- en: '| `FNB_DEFAULT_STYLE` | Combination of `FNB_MOUSE_MIDDLE_CLOSES_TABS` and `FNB_HIDE_ON_SINGLE_TAB`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `FNB_FANCY_TABS` | Use the `fancy` tab renderer for drawing the tabs |'
  prefs: []
  type: TYPE_TB
- en: '| `FNB_HIDE_ON_SINGLE_TAB` | Hide the tab container area when there is only
    one tab open |'
  prefs: []
  type: TYPE_TB
- en: '| `FNB_MOUSE_MIDDLE_CLOSES_TABS` | Allow middle mouse button clicks to close
    tabs |'
  prefs: []
  type: TYPE_TB
- en: '| `FNB_NODRAG` | Don''t allow tab drag and drop |'
  prefs: []
  type: TYPE_TB
- en: '| `FNB_NO_NAV_BUTTONS` | Don''t show the tab scroll buttons |'
  prefs: []
  type: TYPE_TB
- en: '| `FNB_NO_X_BUTTON` | Don''t show the **X** button on the right hand side of
    the tab container area |'
  prefs: []
  type: TYPE_TB
- en: '| `FNB_TABS_BORDER_SIMPLE` | Draw a thin border around the page |'
  prefs: []
  type: TYPE_TB
- en: '| `FNB_VC71` | Use Visual Studio 2003 style tabs |'
  prefs: []
  type: TYPE_TB
- en: '| `FNB_VC8` | Use Visual Studio 2005 style tabs |'
  prefs: []
  type: TYPE_TB
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Adding tabs to a Notebook* recipe in this chapter shows how to use the
    basic tab control.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scrolling with a ScrolledPanel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ScrolledPanel` class is a custom `Panel` class that has built in `ScrollBars`.
    This class is provided by the `scrolledpanel` module in `wx.lib`. By default,
    `Panels` do not have the ability to scroll when their contents overflow the windows
    given area. This recipe shows how to use the `ScrolledPanel`, by using it to create
    a custom image list widget.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To create our custom image viewer control that uses the `ScrolledPanel`, we
    will define this simple class that manages a list of `Bitmaps:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `ScrolledPanel` makes it pretty easy to work with `ScrollBars`, so let's
    take a quick look at how it works.
  prefs: []
  type: TYPE_NORMAL
- en: We created a simple class called `ImageListCtrl`. This control can be used for
    displaying a list of bitmaps. We derived our class from `ScrolledPanel` so that
    if it contains many images, the user will be able to scroll to see them all. The
    only special thing needed to use the `ScrolledPanel` is to call its `SetupScrolling`
    method when all of the panels' child controls have been added to its `Sizer`.
    Typically, this is done in the subclasses `__init__` method, but since our widget
    can add more `Bitmap` items at any time we need to call it after each `Bitmap`
    that is added in the `AppendBitmap` method.
  prefs: []
  type: TYPE_NORMAL
- en: The `SetupScrolling` method works by calculating the minimum size of the contents
    of the `Panel` and setting up the virtual size of the containment area for the
    `ScrollBar` objects to work with.
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying the FoldPanelBar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `FoldPanelBar` is a custom container class that allows multiple controls
    to be grouped together into `FoldPanelItem` controls that allow them to be expanded
    or contracted by clicking on its `CaptionBar`. The `FoldPanelBar` doesn't work
    with layouts based on a `Sizer` and as such its API can get a little cumbersome,
    because it requires you to add each control one by one and set its layout by using
    various flags. This recipe shows how to create a custom `FoldPanelBar` that works
    with `Panel` objects. This class will allow for you to modularize your code into
    `Panel` classes and then just add them to the `FoldPanelBar` instead of directly
    adding everything to the `FoldPanelBar` itself.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This custom `FoldPanelBar` class uses a factory approach to simplify and abstract
    the addition of a new `Panel` to the control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our subclass of `FoldPanelBar`, adds one new method to the class `AddPanel`.
    The `AddPanel` method is a simple wrapper around the `FoldPanelBar` control's
    `AddFoldPanel` and `AddFoldPanelWindow` methods. The `AddFoldPanel` method is
    used to create the `CaptionBar` and container for the controls and the `AddFoldPanelWindow`
    method is used to add a Window object to the `FoldPanel.`
  prefs: []
  type: TYPE_NORMAL
- en: Our `AddPanel` method takes a callable object as its first parameter. The callable
    must accept a "parent" argument and return a new window that is a child of that
    parent window when called. We do this because our panels need to be created as
    children of the `FoldPanelItem` that is returned by `AddFoldPanel`. This is an
    important point to remember when working with the `FoldPanelBar`. All of the controls
    that are added to it must be children of one of its `FoldPanelItems` and not children
    of the `FoldPanelBar` itself.
  prefs: []
  type: TYPE_NORMAL
- en: Since the `FoldPanelBar` internally works with a manual layout, we need to set
    an explicit size on each `Panel` as it is added. This is done by getting the best
    size from each Panel object's `GetBestSize` method.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `CaptionBar` of the `FoldPanelBar` can be customized by making a custom
    `CaptionBarStyle` object and passing it to the `AddFoldPanel` method. A `CaptionBarStyle`
    object has methods for changing the colors, fonts, and styles that the `CaptionBar`
    will use. The `AddFoldPanel` method also accepts an optional `foldIcons` argument,
    which accepts an `ImageList` object that must have two 16x16 pixel bitmaps in
    it. The first will be used for the button's expanded state and the second will
    be used for its collapsed state.
  prefs: []
  type: TYPE_NORMAL
