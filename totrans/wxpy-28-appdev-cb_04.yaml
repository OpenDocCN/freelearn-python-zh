- en: Chapter 4. Advanced Building Blocks of a User Interface
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章 用户界面的高级构建块
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Listing data with a `ListCtrl`
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ListCtrl`列出数据
- en: Browsing files with the `CustomTreeCtrl`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `CustomTreeCtrl` 浏览文件
- en: Creating a `VListBox`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个 `VListBox`
- en: '`StyledTextCtrl` using lexers'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用词法分析器创建 `StyledTextCtrl`
- en: Working with tray icons
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用托盘图标
- en: Adding tabs to a `Notebook`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向`笔记本`中添加标签页
- en: Using the `FlatNotebook`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`FlatNotebook`
- en: Scrolling with a `ScrolledPanel`
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ScrolledPanel`进行滚动
- en: Simplifying the `FoldPanelBar`
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简化 `FoldPanelBar`
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Displaying collections of data and managing complex window layouts are a task
    that most UI developers will be faced with at some point. wxPython provides a
    number of components to help developers meet the requirements of these more demanding
    interfaces.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 展示数据集合和管理复杂的窗口布局是大多数UI开发者迟早会遇到的任务。wxPython提供了一系列组件，以帮助开发者满足这些更高级界面的需求。
- en: As the amount of controls and data that an application is required to display
    in its user interface increases, so does the task of efficiently managing available
    screen real estate. To fit this information into the available space requires
    the use of some more advanced controls and containers; so let's dive in and begin
    our exploration of some of the more advanced controls that wxPython has to offer.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 随着应用程序在其用户界面中需要显示的控制和数据量增加，有效管理可用屏幕空间的任务也随之增加。要将这些信息适当地放入可用空间，需要使用一些更高级的控制和容器；因此，让我们深入探讨，开始我们对于wxPython所能提供的某些更高级控制器的探索之旅。
- en: Listing data with a ListCtrl
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ListCtrl列出数据
- en: The `ListCtrl` is a versatile control for displaying collections of text and/or
    images. The control supports many different display formats, although typically
    its most often-used display mode is the report mode. Report mode has a visual
    representation that is very similar to a grid or spreadsheet in that it can have
    multiple rows and columns with column headings. This recipe shows how to populate
    and retrieve data from a `ListCtrl` that was created in report mode.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListCtrl` 是一种用于显示文本和/或图像集合的多功能控件。该控件支持许多不同的显示格式，尽管通常其最常用的显示模式是报表模式。报表模式具有与网格或电子表格非常相似的视觉表示，因为它可以有多个行和列，以及列标题。本食谱展示了如何从在报表模式下创建的
    `ListCtrl` 中填充和检索数据。'
- en: '![Listing data with a ListCtrl](img/1780_04_01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![使用ListCtrl列出数据](img/1780_04_01.jpg)'
- en: How to do it...
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The `ListCtrl` takes a little more set up than most basic controls, so we will
    start by creating a subclass that sets up the columns that we wish to have in
    the control:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListCtrl` 的设置比大多数基本控件要复杂一些，因此我们将首先创建一个子类来设置我们希望在控件中拥有的列：'
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next we will create an instance of our `ListCtrl` and put it on a `Panel`,
    and then use our `PopulateList` method to put some sample data into the control:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将创建一个我们的`ListCtrl`实例，并将其放置在一个`Panel`上，然后使用我们的`PopulateList`方法将一些示例数据放入控件中：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How it works...
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Usually there tends to be a fair amount of set up with the `ListCtrl`, and due
    to this it is good to encapsulate the usage of the control in a specialized subclass
    instead of using it directly. We kept things pretty basic here in our `ListCtrl`
    class. We just used the `InsertColumn` method to set our list up with three columns.
    Then the `PopulateList` method was added for convenience, to allow the population
    of the `ListCtrl` from a Python list of data. It simply wraps the `Append` method
    of `ListCtrl`, which just takes an iterable that has a string for each column
    in the list.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 通常在使用`ListCtrl`时，需要进行相当多的设置，因此将控制器的使用封装在一个专门的子类中而不是直接使用它是个不错的选择。在我们的`ListCtrl`类中，我们保持了相当基础的设计。我们只是使用了`InsertColumn`方法来设置列表的三个列。然后为了方便，添加了`PopulateList`方法，允许从Python数据列表中填充`ListCtrl`。它简单地封装了`ListCtrl`的`Append`方法，该方法只需一个可迭代的字符串，每个字符串代表列表中的一个列。
- en: The `MyPanel` class is there to show how to use the `ListCtrl` class that we
    created. First we populate it with some data by generating a list of tuples and
    calling our `PopulateList` method. To show how to retrieve data from the list,
    we created an event handler for `EVT_LIST_ITEM_SELECTED` which will be fired each
    time a new selection is made in the control. In order to retrieve a value from
    a `ListCtrl`, you need to know the row and column index of the cell that you wish
    to retrieve the data from, and then call `GetItem` with the row and column to
    get the `ListItem` object that represents that cell. Then the string value of
    the cell can be retrieved by calling the `GetText` method of `ListItem`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyPanel` 类旨在展示如何使用我们创建的 `ListCtrl` 类。首先，我们通过生成一个元组列表并调用我们的 `PopulateList`
    方法来填充它。为了展示如何从列表中检索数据，我们创建了一个事件处理程序用于 `EVT_LIST_ITEM_SELECTED`，它将在控制中每次进行新选择时被触发。为了从
    `ListCtrl` 中检索一个值，你需要知道你希望从中检索数据的单元格的行和列索引，然后调用 `GetItem` 方法并传入行和列以获取表示该单元格的 `ListItem`
    对象。然后可以通过调用 `ListItem` 的 `GetText` 方法来检索单元格的字符串值。'
- en: There's more...
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Depending on the style flags that are used to create a `ListCtrl`, it will behave
    in many different possible ways. Because of this, it is important to know some
    of the different style flags that can be used to create a `ListCtr`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 根据用于创建 `ListCtrl` 的样式标志，它将以许多不同的可能方式表现。正因为如此，了解一些可以用于创建 `ListCtrl` 的不同样式标志是很重要的。
- en: '| Style flags | Description |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 样式标志 | 描述 |'
- en: '| --- | --- |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `LC_LIST` | In List mode, the control will calculate the columns automatically,
    so there is no need to call `InsertColumn`. It can be used to display strings
    and, optionally, small icons |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `LC_LIST` | 在列表模式下，控件将自动计算列，因此无需调用 `InsertColumn`。它可以用来显示字符串，以及可选的小图标 |'
- en: '| `LC_REPORT` | Single or multicolumn report view that can be shown with or
    without headers |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `LC_REPORT` | 单列或多列报表视图，可以带或不带标题显示 |'
- en: '| `LC_ICON` | Large icon view that can optionally have labels |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `LC_ICON` | 大图标视图，可选带有标签 |'
- en: '| `LC_SMALL_ICON` | Small icon view that can optionally have labels |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `LC_SMALL_ICON` | 可选带有标签的小图标视图 |'
- en: '| `LC_EDIT_LABELS` | Allow the item labels to be editable by users |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `LC_EDIT_LABELS` | 允许用户编辑项目标签 |'
- en: '| `LC_NO_HEADER` | Hide the column headers (report mode) |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `LC_NO_HEADER` | 隐藏列标题（报告模式） |'
- en: '| `LC_SORT_ASCENDING` | Sort items in ascending order (must provide a `SortItems`
    callback method) |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `LC_SORT_ASCENDING` | 按升序排序项目（必须提供`SortItems`回调方法） |'
- en: '| `LC_SORT_DESCENDING` | Sort items in descending order (must provide a `SortItems`
    callback method) |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `LC_SORT_DESCENDING` | 按降序排序项目（必须提供`SortItems`回调方法） |'
- en: '| `LC_HRULE` | Draw a horizontal line between rows (report mode) |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `LC_HRULE` | 在行之间绘制水平线（报告模式） |'
- en: '| `LC_VRULE` | Draw a vertical line between columns (report mode) |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `LC_VRULE` | 在列之间绘制垂直线（报告模式） |'
- en: '| `LC_SINGLE_SEL` | Only allow a single item to be selected at a time (Default
    is to allow for multiple selections) |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `LC_SINGLE_SEL` | 仅允许一次选择一个项目（默认允许多选） |'
- en: '| `LC_VIRTUAL` | Fetch items to display in the list on demand (report mode)
    |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `LC_VIRTUAL` | 按需获取用于在列表中显示的项目（报告模式） |'
- en: Virtual Mode
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 虚拟模式
- en: When a `ListCtrl` is created in virtual mode (using the `LC_VIRTUAL` style flag),
    it does not store the data internally; instead it will instead ask for the data
    from a datasource when it needs to display it. This mode is useful when you have
    a very large set of data where preloading it in the control would present performance
    issues. To use a `ListCtrl` in virtual mode, you must call `SetItemCount` to tell
    the control how many rows of data there are, and override the `OnGetItemText`
    method to return the text for the `ListItem` when the control asks for it.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当在虚拟模式下创建`ListCtrl`（使用`LC_VIRTUAL`样式标志）时，它不会内部存储数据；相反，当需要显示数据时，它会从数据源请求数据。这种模式在您拥有大量数据时非常有用，因为预先在控件中加载这些数据可能会引起性能问题。要使用虚拟模式的`ListCtrl`，您必须调用`SetItemCount`来告诉控件有多少行数据，并重写`OnGetItemText`方法，以便在控件请求时返回`ListItem`的文本。
- en: See also
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Creating a VListBox* recipe in this chapter is another example of a control
    for presenting data as a list.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中创建 *创建 VListBox* 菜单的示例是另一个用于以列表形式展示数据的控件示例。
- en: Browsing files with the CustomTreeCtrl
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CustomTreeCtrl浏览文件
- en: A `TreeCtrl` is a way of displaying hierarchical data in a user interface. The
    `CustomTreeCtrl` is a fully owner-drawn `TreeCtrl` that looks and functions much
    the same way as the default `TreeCtrl`, but that offers a number of additional
    features and customizability that the default native control cannot. This recipe
    shows how to make a custom file browser class by using the `CustomTreeCtrl`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`TreeCtrl` 是在用户界面中显示层次数据的一种方式。`CustomTreeCtrl` 是一个完全由所有者绘制的 `TreeCtrl`，其外观和功能与默认的
    `TreeCtrl` 几乎相同，但它提供了一些默认原生控件所不具备的额外功能和可定制性。本食谱展示了如何通过使用 `CustomTreeCtrl` 来创建一个自定义文件浏览器类。'
- en: How to do it...
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To create this custom `FileBrowser` control, we will use its constructor to
    set up the images to use for the folders and files in the tree:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建这个自定义的`FileBrowser`控件，我们将使用其构造函数来设置用于树中文件夹和文件的图片：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following two event handlers are used to update which files are displayed
    when a node is expanded or collapsed in the tree:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个事件处理器用于更新在树中节点展开或折叠时显示哪些文件：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following methods are added as an API for working with the control to add
    items and retrieve their on-disk paths:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法被添加为API，用于与控件一起添加项目并检索它们的磁盘路径：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works...
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: With just a few lines of code here we have created a pretty useful little widget
    for displaying and working with the file system. Let's take a quick look at how
    it works.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 只需几行代码，我们就创建了一个非常实用的迷你小工具，用于显示和操作文件系统。让我们快速了解一下它是如何工作的。
- en: In the classes constructor, we added a root node with the control's `AddRoot`
    method. A root node is a top-level node that has no other parent nodes above it.
    The first argument is the text that will be shown, the `image` argument specifies
    the default image for the `TreeItem`, and the `data` argument specifies any type
    of data associated with the item—in this case we are setting a string for the
    items path. We then called `SetItemHasChildren` for the item so that it will get
    a button next to it to allow it to be expanded. The last thing that we did in
    the constructor was to `Bind` the control to two events so that we can update
    the tree when one of its nodes is being expanded or collapsed.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在类的构造函数中，我们使用控制器的 `AddRoot` 方法添加了一个根节点。根节点是一个顶级节点，其上方没有其他父节点。第一个参数是要显示的文本，`image`
    参数指定了 `TreeItem` 的默认图像，而 `data` 参数指定了与项目关联的任何类型的数据——在这种情况下，我们为项目的路径设置了一个字符串。然后我们为该项目调用了
    `SetItemHasChildren` 方法，以便它旁边会显示一个按钮，允许它被展开。在构造函数中我们做的最后一件事是将控制器绑定到两个事件上，这样我们就可以在其中一个节点被展开或折叠时更新树。
- en: Immediately before the node is going to be expanded our handler for `EVT_TREE_ITEM_EXPANDING`
    will be called. It is here where we find all the files and folders under a directory
    node, and then add them as children of that node by calling `AppendItem`, which
    works just like `AddRoot` but is used to add items to already-existing nodes in
    the tree.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在节点即将展开之前，我们的`EVT_TREE_ITEM_EXPANDING`处理程序将被调用。正是在这里，我们找到目录节点下的所有文件和文件夹，然后通过调用`AppendItem`将它们作为该节点的子项添加，`AppendItem`的功能类似于`AddRoot`，但用于向树中已存在的节点添加项。
- en: Conversely when a node in the tree is going to be collapsed, our `EVT_TREE_ITEM_COLLAPED`
    event handler will be called. Here we simply call `DeleteChildren` in order to
    remove the children items from the node so that we can update them more easily
    the next time that the node is expanded. Otherwise, we would have to find what
    was different the next time it was expanded, and then remove the items that have
    been deleted and insert new items that may have been added to the directory.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，当树中的节点即将被折叠时，我们的`EVT_TREE_ITEM_COLLAPED`事件处理程序将被调用。在这里，我们只是简单地调用`DeleteChildren`来从节点中删除子项，这样我们就可以在节点下一次展开时更容易地更新它们。否则，我们下次展开时将不得不找出有什么不同，然后删除已删除的项，并插入可能已添加到目录中的新项。
- en: The last two items in our class are for getting the file paths of the selected
    items, which—since we store the file path in each node—is simply just a matter
    of getting the data from each of the currently-selected `TreeItems` with a call
    to `GetPyData`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们班级的最后两项是为了获取所选项目的文件路径，由于我们在每个节点中存储文件路径，所以这仅仅是一个通过调用`GetPyData`从当前选中的每个`TreeItems`获取数据的问题。
- en: There's more...
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Most of what we did in this recipe could actually also be replicated with the
    standard `TreeCtrl`. The difference is in the amount of extra customizability
    that the `CustomTreeCtrl` provides. Since it is a fully owner-drawn control, nearly
    all of the visible attributes of it can be customized. Following is a list of
    some of the functions that can be used to customize its appearance:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中我们做的绝大多数事情实际上也可以用标准的 `TreeCtrl` 来实现。区别在于 `CustomTreeCtrl` 提供的额外可定制性数量。由于它是一个完全由所有者绘制的控件，几乎所有的可见属性都可以进行定制。以下是可用于定制其外观的一些函数列表：
- en: '| Functions | Description |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `EnableSelectionGradient(bool)` | Use a gradient to draw the tree item selection
    rectangle. |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `EnableSelectionGradient(bool)` | 使用渐变来绘制树项选择矩形。 |'
- en: '| `EnableSelectionVista(bool)` | Use a nice rounded rectangle for the item
    selections similar to the native control seen in Windows Vista. |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `EnableSelectionVista(bool)` | 使用类似于Windows Vista中看到的原生控件的美观圆角矩形来进行项目选择。
    |'
- en: '| `SetButtonsImageList(ImageList)` | Changes the expand/collapse buttons. `ImageList`
    should have four bitmaps for the following states, in this order: `Normal, Selected,
    Expanded`, and `Expanded Selected`. |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `SetButtonsImageList(ImageList)` | 更改展开/折叠按钮。`ImageList` 应包含以下状态的四个位图，顺序如下：`正常，选中，展开`，以及`展开选中`。
    |'
- en: '| `SetConnectionPen(pen)` | Changes how the connection lines are drawn between
    items in the tree. Takes a `wx.Pen` object that will be used to draw the lines.
    |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `SetConnectionPen(pen)` | 改变树中项目之间连接线的绘制方式。接受一个用于绘制线的 `wx.Pen` 对象。 |'
- en: '| `SetBackgroundImage(bitmap)` | Allows for an image to be used as the control''s
    background. |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `SetBackgroundImage(bitmap)` | 允许使用图像作为控件背景。 |'
- en: '| `SetBackgroundColour(colour)` | Used to change the color of the control''s
    background. |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `SetBackgroundColour(colour)` | 用于更改控件背景颜色。 |'
- en: Creating a VListBox
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个 VListBox
- en: The `VListBox` control is much like a `ListBox` control, but it is virtual (it
    doesn't store the data internally) and allows for items to have variable row heights.
    It works by providing a number of virtual callback methods that you must override
    in a subclass in order to draw the items on demand. Because of this requirement
    to override pure virtual methods, the `VListBox` will always be subclassed. This
    recipe shows how to create a `VListBox` derived control that supports an icon
    and text in each of its items.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`VListBox` 控件与 `ListBox` 控件非常相似，但它却是虚拟的（它不内部存储数据）并且允许项目具有可变的行高。它通过提供一系列虚拟回调方法来实现，你必须在一个子类中重写这些方法以按需绘制项目。由于需要重写纯虚拟方法，`VListBox`
    将始终被派生。这个配方展示了如何创建一个派生的 `VListBox` 控件，它支持每个项目中的图标和文本。'
- en: How to do it...
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To create our user list control, we just need to subclass a `VListBox` and
    override some of its callback methods to perform the necessary actions:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建我们的用户列表控件，我们只需继承一个`VListBox`并重写其中的一些回调方法以执行必要的操作：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here is a screenshot of what the `UserListBox` looks like with some sample data
    in it.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`UserListBox`的截图，其中包含了一些示例数据。
- en: '![How to do it...](img/1780_04_02.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/1780_04_02.jpg)'
- en: How it works...
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Our custom `VListBox` control could be used in any kind of application that
    wants to display a list of users. The constructor takes a list of usernames and
    calls `SetItemCount` to tell the control how many items it needs to be able to
    display. We also loaded a bitmap to use in our list's items. This bitmap is available
    in the sample code that accompanies this topic.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的定制`VListBox`控件可以用于任何需要显示用户列表的应用程序。构造函数接收一个用户名列表并调用`SetItemCount`来告知控件需要显示的项目数量。我们还加载了一个位图，用于列表项中。此位图包含在伴随本主题的示例代码中。
- en: 'The main thing to take from this recipe is the three virtual callback methods
    that we overrode in order to draw the items in our control:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个菜谱中，我们需要掌握的是我们覆盖的三个虚拟回调方法，以便在我们的控件中绘制项目：
- en: The first required override is `OnMeasureItem`. This method will be called for
    each item in the list, and it needs to return the height of the item.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个需要重写的方法是 `OnMeasureItem`。这个方法将为列表中的每个项目被调用，并且需要返回项目的高度。
- en: The next method is `OnDrawSeparator`. This method is optional and can be used
    to draw a separator between each item in the control. It can also modify the `Rect`
    if necessary, so that when `OnDrawItem` is called it will know not to draw over
    the separator.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个方法是 `OnDrawSeparator`。此方法为可选，可用于在控件中的每个项目之间绘制分隔符。如有必要，它还可以修改 `Rect`，这样当调用
    `OnDrawItem` 时，它将知道不要在分隔符上绘制。
- en: The final method is `OnDrawItem`. This method is used to draw the actual item.
    For our control, we draw a bitmap and then position the users' name as a label
    to the right of it. That's all there is to it; pretty easy right.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终的方法是 `OnDrawItem`。这个方法用于绘制实际的项。对于我们的控件，我们绘制一个位图，然后将用户的姓名作为标签放置在其右侧。就是这样；很简单，对吧。
- en: There's more...
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are a couple more methods available that can be useful in implementing
    a `VListBox` subclass. The following list describes these methods.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种其他方法可供使用，这些方法在实现 `VListBox` 子类时可能很有用。以下列表描述了这些方法。
- en: '| Methods | Description |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `OnDrawItemBackground` | This method can be overridden, as `DrawItem` can,
    in order to draw a custom background for an item. The default base class does
    the reasonable thing of drawing the background of the selected item with the system
    default selection color. |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `OnDrawItemBackground` | 此方法可以像 `DrawItem` 一样被重写，以便为项目绘制自定义背景。默认基类会以系统默认选择颜色绘制选中项的背景。
    |'
- en: '| `IsSelected` | This method can be used to see if an item is selected or not,
    in case you want to change the way in which you draw the item in `OnDrawItem`,
    for example making the font bold. |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `IsSelected` | 此方法可用于查看项目是否被选中，如果你想在`OnDrawItem`中更改绘制项目的方式，例如使字体加粗。 |'
- en: See also
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Understanding inheritance limitations* recipe in [Chapter 1](ch01.html
    "Chapter 1. Getting Started with wxPython"), *Getting Started with wxPython* contains
    an explanation about virtual methods in the C++ objects.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第1章](ch01.html "第1章. wxPython入门")中的*理解继承限制*配方，*wxPython入门*包含了关于C++对象中虚方法的解释。'
- en: The *Listing data with a ListCtrl* recipe in this chapter is another example
    of a control for presenting data as a list.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中关于使用ListCtrl列表控件展示数据的示例，是另一种将数据以列表形式呈现的控件示例。
- en: The *Screen drawing* recipe in [Chapter 8](ch08.html "Chapter 8. Drawing to
    the Screen"), *Drawing to the Screen*, discusses the usage of PaintEvents and
    Device Contexts.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第8章](ch08.html "第8章。屏幕绘图")中的“*屏幕绘图*”配方，*《屏幕绘图》*，讨论了PaintEvents和设备上下文的使用。'
- en: StyledTextCtrl using lexers
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用词法分析器的样式文本控件
- en: The `StyledTextCtrl` is an advanced text control class supplied by the `wx.stc`
    module. The class is a wrapping around the Scintilla source control editing component
    (see [http://www.scintilla.org)](http://www.scintilla.org)). The `StyledTextCtrl`
    is primarily intended for displaying and working with source code for various
    programming languages. It provides built-in syntax highlighting support for many
    different types of source code files, and is extendable to work with custom lexers.
    This recipe shows how to setup the control to perform source code highlighting
    using its built-in lexer for Python.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`StyledTextCtrl` 是由 `wx.stc` 模块提供的先进文本控件类。该类是对 Scintilla 源代码编辑组件的封装（参见 [http://www.scintilla.org](http://www.scintilla.org)）。`StyledTextCtrl`
    主要用于显示和操作各种编程语言的源代码。它为许多不同类型的源代码文件提供了内置的语法高亮支持，并且可以扩展以使用自定义词法分析器。本菜谱展示了如何设置控件以使用其内置的词法分析器对
    Python 进行源代码高亮显示。'
- en: How to do it...
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To get started, we will define a language-generic editor class that will manage
    all the common style settings so that we can easily create other classes that
    support different types of programming languages:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们将定义一个通用的语言编辑器类，该类将管理所有常见的样式设置，以便我们能够轻松地创建支持不同类型编程语言的其它类：
- en: '[PRE6]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now here we will derive a new class from our `CodeEditorBase` class that specializes
    the control for Python files:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将从我们的`CodeEditorBase`类派生出一个新的类，该类专门用于处理Python文件：
- en: '[PRE7]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How it works...
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We created two classes: a base editor class and a specialized class for Python
    source files. Let''s first start by taking a look at the `CodeEditorBase` class.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了两个类：一个基础编辑器类和一个专门用于 Python 源文件的类。让我们首先看看 `CodeEditorBase` 类。
- en: The `CodeEditorBase` sets up the basic functionality of the control, and is
    just there to encapsulate some of the common items, should we decide to add other
    specialized classes for different types of source files later on.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`CodeEditorBase` 设置了控件的基本功能，它仅仅是为了封装一些常见的项目，如果我们决定稍后添加其他针对不同类型源文件的专用类，它就派上用场了。'
- en: 'First and foremost, it initializes the basic window styles and provides font
    information. The `StyledTextCtrl` has a number of style specifications for styling
    different text in the buffer. These styles are specified using the `StyleSetSpec`
    method, which takes the style ID and style specification string as arguments.
    The style IDs that are generic to all lexers are identified with the `STC_STYLE_`
    prefix. The style specification string is formatted in the following way:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 首要的是，它初始化基本的窗口样式并提供字体信息。`StyledTextCtrl` 为缓冲区中不同文本的样式提供了多种样式规范。这些样式是通过使用 `StyleSetSpec`
    方法来指定的，该方法接受样式 ID 和样式规范字符串作为参数。适用于所有词法分析器的通用样式 ID 以 `STC_STYLE_` 前缀标识。样式规范字符串的格式如下：
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here, `ATTRIBUTE` and `VALUE` are replaced by any combination of the possible
    specifications in the following table:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`ATTRIBUTE` 和 `VALUE` 可以替换为以下表格中可能规格的任何组合：
- en: '| Attributes | Possible values |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 可能的值 |'
- en: '| --- | --- |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `fore` | Foreground color; can either be a color name (black) or hex color
    string (for example, `#000000)` |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `fore` | 前景色；可以是颜色名称（黑色）或十六进制颜色字符串（例如，`#000000`） |'
- en: '| `back` | Background color; can either be a color name (white) or hex color
    string (for example, `#FFFFFF)` |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `back` | 背景颜色；可以是颜色名称（例如，白色）或十六进制颜色字符串（例如，`#FFFFFF`） |'
- en: '| `face` | A font face name (for example, `Monaco)` |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `face` | 一种字体名称（例如，`Monaco`） |'
- en: '| `size` | A point size for the font (for example, `10)` |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `size` | 字体的大小（例如，`10`） |'
- en: 'There is also support from some additional `MODIFER` attributes that don''t
    take a `VALUE` argument:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一些额外的 `MODIFER` 属性也支持不包含 `VALUE` 参数：
- en: '| Modifier | Description |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| 修饰符 | 描述 |'
- en: '| --- | --- |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `bold` | Makes the text bold |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| **粗体** | 使文本加粗 |'
- en: '| `italic` | Italicizes the text |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `斜体` | 斜体化文本 |'
- en: '| `eol` | Extends the background style to the end of the current line |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `eol` | 将背景样式扩展到当前行的末尾 |'
- en: '| `underline` | Underlines the text |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `underline` | 下划线文本 |'
- en: The `StyledTextCtrl` also supports special margins on the left-hand side of
    the buffer for displaying things such as line numbers, breakpoints, and code folding
    buttons. Our `CodeEditorBase` shows how to enable line numbers in the left-most
    margin with its `EnableLineNumbers` method.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`StyledTextCtrl` 还支持在缓冲区的左侧设置特殊边距，用于显示行号、断点和代码折叠按钮等。我们的 `CodeEditorBase` 通过其
    `EnableLineNumbers` 方法展示了如何在最左侧边距中启用行号。'
- en: 'Our derived `PythonCodeEditor` class simply does the three basic things necessary
    to set up the proper lexer:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们推导出的 `PythonCodeEditor` 类仅仅执行设置正确词法分析器所需的三个基本操作：
- en: First, it calls `SetLexer` to set the lexer mode. This method simply takes one
    of the `STC_LEX_FOO` values that are found in the `stc` module.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，它调用`SetLexer`来设置词法分析器模式。该方法简单地取自`stc`模块中找到的`STC_LEX_FOO`值之一。
- en: 'Second, it sets up the keywords for the lexer. There is little documentation
    on what keyword sets are available for each lexer, so it is sometimes necessary
    to look at the Scintilla source code to see what keyword sets have been defined
    for each lexer. The Python lexer supports two keyword sets: one for language keywords
    and a second for user- defined keywords. The `SetKeywords` method takes two arguments:
    a keyword ID and a string of space-separated keywords to associate with that ID.
    Each keyword ID is associated with a Style ID for the given lexer. In this example,
    the keyword ID of zero is associated with the Style ID: `STC_P_WORD`.'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其次，它为词法分析器设置了关键字。关于每个词法分析器可用的关键字集的文档很少，因此有时需要查看 Scintilla 源代码以查看为每个词法分析器定义了哪些关键字集。Python
    词法分析器支持两个关键字集：一个用于语言关键字，另一个用于用户定义的关键字。`SetKeywords` 方法接受两个参数：一个关键字 ID 和一个与该 ID
    关联的空格分隔的关键字字符串。每个关键字 ID 都与给定词法分析器的 Style ID 相关联。在这个例子中，关键字 ID 为零的关联 Style ID 是：`STC_P_WORD`。
- en: Third and finally, it sets all of the styling specifications for the lexer.
    This is done just as we did in our base class by calling `StyleSetSpec` for each
    lexer style specification ID that the lexer defines. A quick reference for what
    styles relate to what lexers can be found in the wxPython wiki ([http://wiki.wxpython.org/StyledTextCtrl%20Lexer%20Quick%20Reference](http://wiki.wxpython.org/StyledTextCtrl%20Lexer%20Quick%20Reference)).
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三点也是最后一点，它为所有的样式规范设置了lexer。这与我们在基类中所做的方式相同，通过为lexer定义的每个样式规范ID调用`StyleSetSpec`来实现。有关哪些样式与哪些lexer相关联的快速参考可以在wxPython
    wiki中找到（[http://wiki.wxpython.org/StyledTextCtrl%20Lexer%20Quick%20Reference](http://wiki.wxpython.org/StyledTextCtrl%20Lexer%20Quick%20Reference)）。
- en: There's more...
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `StyledTextCtrl` is a big class that comes with a very large API. It has
    many additional features that we did not discuss here, such as pop-up lists for
    implementing auto-completion, clickable hotspots, code folding, and custom highlighting.
    Following are links to some references and documentation about the `StyledTextCtrl:`
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`StyledTextCtrl` 是一个包含非常庞大 API 的大类。它具有许多在这里未讨论的附加功能，例如用于实现自动完成的弹出列表、可点击的热点、代码折叠和自定义高亮显示。以下是一些关于
    `StyledTextCtrl` 的参考资料和文档链接：'
- en: '[http://www.yellowbrain.com/stc/index.html](http://www.yellowbrain.com/stc/index.html)'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.yellowbrain.com/stc/index.html](http://www.yellowbrain.com/stc/index.html)'
- en: '[http://www.wxpython.org/docs/api/wx.stc.StyledTextCtrl-class.html](http://www.wxpython.org/docs/api/wx.stc.StyledTextCtrl-class.html)'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[wxPython文档中关于wx.stc.StyledTextCtrl类的API](http://www.wxpython.org/docs/api/wx.stc.StyledTextCtrl-class.html)'
- en: '[http://wiki.wxpython.org/StyledTextCtrl](http://wiki.wxpython.org/StyledTextCtrl)'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://wiki.wxpython.org/StyledTextCtrl](http://wiki.wxpython.org/StyledTextCtrl)'
- en: See also
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Using the TextCtrl* recipe in [Chapter 3](ch03.html "Chapter 3. Basic Building
    Blocks of a User Interface"), *Basic Building Blocks of a User Interface* shows
    how to use the basic text control.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第3章](ch03.html "第3章。用户界面基本构建块")中的*使用TextCtrl*配方，*用户界面基本构建块*展示了如何使用基本文本控件。'
- en: The *StyledTextCtrl custom highlighting* recipe in [Chapter 10](ch10.html "Chapter 10. Creating
    Components and Extending Functionality"), *Creating Components and Extending Functionality*
    shows how to extend the `StyledTextCtrl` in order to perform custom text styling.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第10章](ch10.html "第10章。创建组件和扩展功能")中的 *StyledTextCtrl自定义高亮* 菜单，*创建组件和扩展功能* 展示了如何扩展
    `StyledTextCtrl` 以执行自定义文本样式。'
- en: Working with tray icons
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用托盘图标
- en: Tray icons are UI components that integrate with the window manager's Task Bar
    (Windows / Linux) or Dock (OS X). They can be used for notifications and to provide
    a pop-up menu when the user clicks on the notification icon. This recipe shows
    how to create and use a tray icon through the use of the `TaskBarIcon` class.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 桌面图标是集成到窗口管理器的任务栏（Windows/Linux）或Dock（OS X）的UI组件。它们可用于通知，并在用户点击通知图标时提供弹出菜单。本食谱展示了如何通过使用`TaskBarIcon`类来创建和使用桌面图标。
- en: How to do it...
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To create the icon bar for this recipe''s sample code, we create a subclass
    of `TaskBarIcon` that loads an image to use for its display, and that has handling
    for showing a `Menu` when it is clicked on:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建此菜谱示例代码的图标栏，我们创建了一个`TaskBarIcon`的子类，该子类加载一个用于显示的图像，并且当点击时具有显示`Menu`的处理功能：
- en: '[PRE9]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How it works...
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `TaskBarIcon` class is pretty easy and straightforward to use. All that
    needs to be done is to create an icon and call `SetIcon` to create the UI part
    of the object that will be shown in the system tray. Then we override the `CreatePopupMenu`
    method that the base class will call when the icon is clicked on, to create the
    menu. All that this method needs to do is create a `Menu` object and then return
    it; the `TaskBarIcon` class will take care of the rest. Finally, we added an event
    handler for `EVT_MENU` to handle the menu events from our pop-up menu.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`TaskBarIcon` 类使用起来相当简单直接。需要做的只是创建一个图标，并调用 `SetIcon` 方法来创建将在系统托盘显示的对象的 UI 部分。然后我们重写
    `CreatePopupMenu` 方法，这个方法是在图标被点击时基类会调用的，以创建菜单。这个方法需要做的只是创建一个 `Menu` 对象，然后返回它；`TaskBarIcon`
    类会处理其余部分。最后，我们添加了一个 `EVT_MENU` 事件处理程序来处理来自我们的弹出菜单的菜单事件。'
- en: There's more...
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `TaskBarIcon` class has a number of events associated with it, if you want
    to customize what different types of clicks do. Please see the following table
    for a list of available events and a description of when they are called.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`TaskBarIcon` 类关联了许多事件，如果您想自定义不同类型点击的行为。请参阅以下表格以获取可用事件列表及其调用描述。'
- en: '| Events | Description |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| Events | 描述 |'
- en: '| --- | --- |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `EVT_TASKBAR_CLICK` | Icon was clicked on by the mouse |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `EVT_TASKBAR_CLICK` | 鼠标点击了图标 |'
- en: '| `EVT_TASKBAR_LEFT_DCLICK` | Left mouse button double clicked on the icon
    |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `EVT_TASKBAR_LEFT_DCLICK` | 左键双击任务栏图标 |'
- en: '| `EVT_TASKBAR_LEFT_DOWN` | Left mouse button clicked down on the icon |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `EVT_TASKBAR_LEFT_DOWN` | 左键点击图标按下 |'
- en: '| `EVT_TASKBAR_LEFT_UP` | Left mouse button released on the icon |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `EVT_TASKBAR_LEFT_UP` | 左键在图标上释放 |'
- en: '| `EVT_TASKBAR_MOVE` | The `TaskBarIcon` moved |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `EVT_TASKBAR_MOVE` | 任务栏图标已移动 |'
- en: '| `EVT_TASKBAR_RIGHT_DCLICK` | Right mouse button double clicked on the icon
    |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `EVT_TASKBAR_RIGHT_DCLICK` | 右键双击任务栏图标 |'
- en: '| `EVT_TASKBAR_RIGHT_DOWN` | Right mouse button clicked down on the icon |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `EVT_TASKBAR_RIGHT_DOWN` | 右键鼠标点击图标按下 |'
- en: '| `EVT_TASKBAR_RIGHT_UP` | Right mouse button released on the icon |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `EVT_TASKBAR_RIGHT_UP` | 右键鼠标在图标上释放 |'
- en: See also
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Adding Menus and MenuBars* recipe in [Chapter 3](ch03.html "Chapter 3. Basic
    Building Blocks of a User Interface"), *Basic Building Blocks of a User Interface*
    contains more examples of using and creating menus.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第3章](ch03.html "第3章。用户界面基本构建块")中的 *添加菜单和菜单栏* 菜谱，*用户界面基本构建块* 包含了更多使用和创建菜单的示例。'
- en: The *How to use PopupMenus* recipe in [Chapter 3](ch03.html "Chapter 3. Basic
    Building Blocks of a User Interface"), *Basic Building Blocks of a User Interface*
    contains another example of creating a context menu.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第3章](ch03.html "第3章。用户界面基本构建块")中的 *如何使用弹出菜单* 菜谱，*用户界面基本构建块* 包含了创建上下文菜单的另一个示例。'
- en: Adding tabs to a Notebook
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在笔记本中添加选项卡
- en: 'The `Notebook` class is a container control that is used to manage multiple
    panels through the use of tabs. When a tab is selected, the associated panel is
    shown and the previous one is hidden. This recipe shows how to use the default
    native `Notebook` class to create a tab-based user interface like the one shown
    in the following screenshot:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`Notebook`类是一个容器控件，用于通过标签页管理多个面板。当选择一个标签页时，相关的面板会显示，而之前的一个面板会被隐藏。本食谱展示了如何使用默认的原生`Notebook`类创建一个类似于以下截图所示的基于标签页的用户界面：'
- en: '![Adding tabs to a Notebook](img/1780_04_03.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![将标签添加到笔记本](img/1780_04_03.jpg)'
- en: How to do it...
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The following example code snippet defines a `Notebook` class that has three
    tabs in it:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例代码片段定义了一个包含三个标签页的`Notebook`类：
- en: '[PRE10]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How it works...
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'This recipe just shows the fundamental basics of how to use the `Notebook`
    control. We simply created some window objects that we wish to put in the `Notebook`.
    In this case, we created three different objects: a `TextCtrl`, a `Panel`, and
    a `GenericDirCtrl`. The important thing to note is that the items that we wish
    to put in the `Notebook` must be children of the `Notebook`.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例仅仅展示了如何使用`Notebook`控件的基本原理。我们简单地创建了一些我们希望放入`Notebook`中的窗口对象。在这种情况下，我们创建了三个不同的对象：一个`TextCtrl`，一个`Panel`和一个`GenericDirCtrl`。需要注意的是，我们希望放入`Notebook`中的项目必须是`Notebook`的子对象。
- en: The objects are then added to the `Notebook` by calling its `AddPage` method.
    This method takes a window object and a label to put on the tab as arguments.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将对象通过调用其`AddPage`方法添加到`Notebook`中。此方法接受一个窗口对象和一个标签作为参数。
- en: There's more...
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The basic `Notebook` class doesn't offer too many more features beyond what
    was shown above. However, there are a few additional styles, and some events related
    to when tabs are selected. Included below are some quick references to these additional
    items.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的`Notebook`类并没有提供太多超出上述展示的功能。然而，还有一些额外的样式，以及一些与选项卡选择相关的事件。以下是一些关于这些额外项目的快速参考。
- en: Styles
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 样式
- en: 'The following styles can be provided to the Notebook''s constructor:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Notebook 构造函数可以提供以下样式：
- en: '| Style | Description |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| 样式 | 描述 |'
- en: '| --- | --- |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `NB_BOTTOM` | Put the tabs at the bottom of the control area |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `NB_BOTTOM` | 将选项卡放置在控制区域的底部 |'
- en: '| `NB_FIXEDWIDTH` | All tabs are the same size (Windows only) |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `NB_FIXEDWIDTH` | 所有制表符大小相同（仅限Windows） |'
- en: '| `NB_LEFT` | Put the tabs on the left side of the control area |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `NB_LEFT` | 将选项卡放置在控制区域的左侧 |'
- en: '| `NB_MULTILINE` | Allow for multiple rows of tabs (Windows only) |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `NB_MULTILINE` | 允许多行制表符（仅限Windows） |'
- en: '| `NB_NOPAGETHEME` | Use a solid color for the tabs (Windows only) |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `NB_NOPAGETHEME` | 仅在 Windows 系统中使用纯色作为标签页颜色 |'
- en: '| `NB_RIGHT` | Put the tabs on the right-hand side of the control area |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `NB_RIGHT` | 将选项卡放置在控制区域的右侧 |'
- en: '| `NB_TOP` | Put the tabs at the top of the control area (Default) |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `NB_TOP` | 将选项卡置于控制区域顶部（默认） |'
- en: Events
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件
- en: 'The Notebook emits the following events:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 笔记本会发出以下事件：
- en: '| Event | Description |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| 事件 | 描述 |'
- en: '| --- | --- |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `EVT_NOTEBOOK_PAGE_CHANGING` | This event is fired when the Notebook is in
    the process of changing the page from one to another. Calling Veto on the event
    object will block the page from being changed. |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| `EVT_NOTEBOOK_PAGE_CHANGING` | 当笔记本正在从一个页面切换到另一个页面时，会触发此事件。在事件对象上调用Veto将阻止页面切换。
    |'
- en: '| `EVT_NOTEBOOK_PAGE_CHANGED` | This event is fired when the selected page
    has been changed. |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| `EVT_NOTEBOOK_PAGE_CHANGED` | 当选中的页面发生变化时，将触发此事件。 |'
- en: See also
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Using the FlatNotebook* recipe in this chapter shows the usage of another
    type of tab control.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中关于*使用FlatNotebook食谱*的部分展示了另一种类型标签控制的用法。
- en: Using the FlatNotebook
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 FlatNotebook
- en: The `FlatNotebook` class is a custom `Notebook` implementation that provides
    a large array of features over the default `Notebook`. The additional features
    include such things as being able to have a close button on each tab, drag and
    drop tabs to different positions, and a number of different tab styles to change
    the look and feel of the control. This recipe will explore some of the extended
    functionality that this control provides.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`FlatNotebook` 类是一个自定义的 `Notebook` 实现，它提供了比默认 `Notebook` 更多的功能。这些额外功能包括在每个标签页上拥有关闭按钮、拖放标签页到不同的位置，以及多种不同的标签页样式来改变控件的外观和感觉。本食谱将探索这个控件提供的部分扩展功能。'
- en: How to do it...
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: As an example of how to use the `FlatNotebook`, we will define a subclass that
    has some specializations for displaying multiple `TextCtrls:`
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 作为如何使用 `FlatNotebook` 的一个示例，我们将定义一个具有显示多个 `TextCtrls:` 特殊化的子类：
- en: '[PRE11]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the following screenshot, we can see the above subclass in action, in a simple
    file editor application. The full source code for the below application is available
    with the code that accompanies this recipe.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图里，我们可以看到上述子类在实际操作中的表现，在一个简单的文件编辑器应用中。下面应用的完整源代码以及与这个食谱一起提供的代码都可以获取。
- en: '![How to do it...](img/1780_04_04.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/1780_04_04.jpg)'
- en: How it works...
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This little recipe demonstrates quite a few of the features that the `FlatNotebook`
    offers over the standard `Notebook` class. So let's break it down, section by
    section, starting with the constructor.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这份小食谱展示了`FlatNotebook`相对于标准`Notebook`类提供的许多特性。因此，让我们逐节分析，从构造函数开始。
- en: 'In our subclass''s constructor we specified four style flags. The first, `FNB_DROPDOWN_TAB_LIST`,
    specifies that we want to have a drop-down list that shows all the open tabs.
    The drop-down list is the small down-arrow button: clicking on it will show a
    pop-up menu that allows one of the currently open tabs to be selected from the
    list. The second style flag, `FNB_FF2`, specifies that we want tabs that use the
    Firefox 2 tab renderer, which will draw tabs that look and feel similar to the
    ones in Firefox 2\. The third style flag, `FNB_SMART_TABS`, specifies that the
    *Ctrl + Tab* shortcut will pop up a dialog that shows the open tabs and allows
    them to be cycled through by pressing the *Tab* key. The fourth and final style
    flag that we used, `FNB_X_ON_TAB`, specifies that we want a close button to be
    shown on the active tab. This allows the user to dismiss a tab when this button
    is clicked on.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们子类的构造函数中，我们指定了四个样式标志。第一个，`FNB_DROPDOWN_TAB_LIST`，指定了我们想要一个下拉列表，显示所有打开的标签页。下拉列表是那个小向下箭头按钮：点击它将显示一个弹出菜单，允许从列表中选择当前打开的标签页之一。第二个样式标志，`FNB_FF2`，指定了我们想要使用Firefox
    2标签渲染器的标签页，这将绘制出看起来和感觉类似于Firefox 2中的标签页。第三个样式标志，`FNB_SMART_TABS`，指定了*Ctrl + Tab*快捷键将弹出一个对话框，显示打开的标签页，并允许通过按*Tab*键在它们之间循环。我们使用的第四个和最后一个样式标志，`FNB_X_ON_TAB`，指定了我们想要在活动标签页上显示一个关闭按钮。这允许用户在点击此按钮时关闭标签页。
- en: In order to be able to show icons on the tabs, we also created and assigned
    an `ImageList` to the control. An `ImageList` is simply a container for holding
    `Bitmap` objects, and the control will use it for retrieving the bitmap data when
    it draws the tabs. The important point to notice is that we keep a reference to
    the object by assigning it to `self._imglst`; it is important to keep a reference
    to it so that it doesn't get garbage collected.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够在标签上显示图标，我们还为该控件创建并分配了一个`ImageList`。`ImageList`简单来说是一个用于存放`Bitmap`对象的容器，控件在绘制标签时会使用它来检索位图数据。需要注意的是，我们通过将其分配给`self._imglst`来保留对该对象的引用；保留引用是很重要的，这样它就不会被垃圾回收。
- en: The last thing that we did was `Bind` the control to the page closing event
    `EVT_FLATNOTEBOOK_PAGE_CLOSING`. In this example, we are expecting our pages to
    provide an `IsModified` method so that we can check for unsaved changes prior
    to closing the page, in order to give the user a chance to cancel closing the
    page.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后做的是将控制与页面关闭事件`EVT_FLATNOTEBOOK_PAGE_CLOSING`绑定。在这个例子中，我们期望我们的页面提供一个`IsModified`方法，这样我们就可以在关闭页面之前检查是否有未保存的更改，以便给用户一个取消关闭页面的机会。
- en: There's more...
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Because the `FlatNotebook` is a pure Python class, it is more customizable
    than the basic `Notebook` class. Included below is a listing of the style flags
    that can be used to customize the appearance and behavior of the control:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`FlatNotebook`是一个纯Python类，所以它比基本的`Notebook`类更可定制。以下是可以用来定制控件外观和行为的样式标志列表：
- en: Style flags
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 样式标志
- en: 'Here is a list of the other style flags that are available that we didn''t
    already cover:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是其他可用的样式标志列表，我们之前还没有介绍过：
- en: '| Style flags | Description |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| 样式标志 | 描述 |'
- en: '| --- | --- |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `FNB_ALLOW_FOREIGN_DND` | Allow tabs to be dragged and moved to and accepted
    from other `FlatNotebook` instances |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| `FNB_ALLOW_FOREIGN_DND` | 允许标签被拖动并移动到其他 `FlatNotebook` 实例，并从其他实例接受标签 |'
- en: '| `FNB_BACKGROUND_GRADIENT` | Draw a gradient in the tabs background area |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| `FNB_BACKGROUND_GRADIENT` | 在标签页背景区域绘制渐变 |'
- en: '| `FNB_BOTTOM` | Place the tabs at the bottom of the control area |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| `FNB_BOTTOM` | 将选项卡放置在控制区域的底部 |'
- en: '| `FNB_COLORFUL_TABS` | Use colorful tabs (VC8 style only) |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| `FNB_COLORFUL_TABS` | 使用彩色标签（仅VC8样式） |'
- en: '| `FNB_DCLICK_CLOSES_TABS` | Allow double-clicks to close the active tab |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| `FNB_DCLICK_CLOSES_TABS` | 允许双击关闭活动标签 |'
- en: '| `FNB_DEFAULT_STYLE` | Combination of `FNB_MOUSE_MIDDLE_CLOSES_TABS` and `FNB_HIDE_ON_SINGLE_TAB`
    |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| `FNB_DEFAULT_STYLE` | `FNB_MOUSE_MIDDLE_CLOSES_TABS` 和 `FNB_HIDE_ON_SINGLE_TAB`
    的组合 |'
- en: '| `FNB_FANCY_TABS` | Use the `fancy` tab renderer for drawing the tabs |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| `FNB_FANCY_TABS` | 使用 `fancy` 标签渲染器来绘制标签 |'
- en: '| `FNB_HIDE_ON_SINGLE_TAB` | Hide the tab container area when there is only
    one tab open |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| `FNB_HIDE_ON_SINGLE_TAB` | 当只有一个标签打开时隐藏标签容器区域 |'
- en: '| `FNB_MOUSE_MIDDLE_CLOSES_TABS` | Allow middle mouse button clicks to close
    tabs |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| `FNB_MOUSE_MIDDLE_CLOSES_TABS` | 允许鼠标中键点击关闭标签 |'
- en: '| `FNB_NODRAG` | Don''t allow tab drag and drop |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| `FNB_NODRAG` | 不允许标签拖放 |'
- en: '| `FNB_NO_NAV_BUTTONS` | Don''t show the tab scroll buttons |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| `FNB_NO_NAV_BUTTONS` | 不显示标签滚动按钮 |'
- en: '| `FNB_NO_X_BUTTON` | Don''t show the **X** button on the right hand side of
    the tab container area |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| `FNB_NO_X_BUTTON` | 不要在标签容器区域的右侧显示**X**按钮 |'
- en: '| `FNB_TABS_BORDER_SIMPLE` | Draw a thin border around the page |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| `FNB_TABS_BORDER_SIMPLE` | 在页面周围绘制细边框 |'
- en: '| `FNB_VC71` | Use Visual Studio 2003 style tabs |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| `FNB_VC71` | 使用 Visual Studio 2003 风格的制表符 |'
- en: '| `FNB_VC8` | Use Visual Studio 2005 style tabs |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| `FNB_VC8` | 使用 Visual Studio 2005 风格的选项卡 |'
- en: See also
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Adding tabs to a Notebook* recipe in this chapter shows how to use the
    basic tab control.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中关于*添加标签页到笔记本*的配方展示了如何使用基本的标签控制功能。
- en: Scrolling with a ScrolledPanel
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ScrolledPanel进行滚动
- en: The `ScrolledPanel` class is a custom `Panel` class that has built in `ScrollBars`.
    This class is provided by the `scrolledpanel` module in `wx.lib`. By default,
    `Panels` do not have the ability to scroll when their contents overflow the windows
    given area. This recipe shows how to use the `ScrolledPanel`, by using it to create
    a custom image list widget.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`ScrolledPanel` 类是一个内置 `ScrollBars` 的自定义 `Panel` 类。这个类由 `wx.lib` 模块中的 `scrolledpanel`
    提供。默认情况下，`Panels` 在内容超出给定窗口区域时没有滚动能力。这个菜谱展示了如何使用 `ScrolledPanel`，通过它来创建一个自定义的图像列表小部件。'
- en: How to do it...
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: To create our custom image viewer control that uses the `ScrolledPanel`, we
    will define this simple class that manages a list of `Bitmaps:`
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建我们自定义的图像查看器控件，该控件使用`ScrolledPanel`，我们将定义这样一个简单的类来管理一系列`Bitmaps`：
- en: '[PRE12]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How it works...
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `ScrolledPanel` makes it pretty easy to work with `ScrollBars`, so let's
    take a quick look at how it works.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`ScrolledPanel` 使得与 `ScrollBars` 一起工作变得非常简单，所以让我们快速了解一下它是如何工作的。'
- en: We created a simple class called `ImageListCtrl`. This control can be used for
    displaying a list of bitmaps. We derived our class from `ScrolledPanel` so that
    if it contains many images, the user will be able to scroll to see them all. The
    only special thing needed to use the `ScrolledPanel` is to call its `SetupScrolling`
    method when all of the panels' child controls have been added to its `Sizer`.
    Typically, this is done in the subclasses `__init__` method, but since our widget
    can add more `Bitmap` items at any time we need to call it after each `Bitmap`
    that is added in the `AppendBitmap` method.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个简单的类，名为 `ImageListCtrl`。这个控件可以用来显示位图列表。我们从这个类派生出了 `ScrolledPanel`，这样如果包含很多图片，用户就可以滚动查看所有图片。使用
    `ScrolledPanel` 的唯一特殊之处在于，当所有面板的子控件都添加到其 `Sizer` 中时，需要调用它的 `SetupScrolling` 方法。通常，这会在子类的
    `__init__` 方法中完成，但由于我们的小部件可以在任何时候添加更多的 `Bitmap` 项目，因此我们需要在 `AppendBitmap` 方法中添加每个
    `Bitmap` 之后调用它。
- en: The `SetupScrolling` method works by calculating the minimum size of the contents
    of the `Panel` and setting up the virtual size of the containment area for the
    `ScrollBar` objects to work with.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetupScrolling` 方法通过计算 `Panel` 内容的最小尺寸，并为 `ScrollBar` 对象设置与之协同工作的虚拟区域大小来工作。'
- en: Simplifying the FoldPanelBar
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简化FoldPanelBar
- en: The `FoldPanelBar` is a custom container class that allows multiple controls
    to be grouped together into `FoldPanelItem` controls that allow them to be expanded
    or contracted by clicking on its `CaptionBar`. The `FoldPanelBar` doesn't work
    with layouts based on a `Sizer` and as such its API can get a little cumbersome,
    because it requires you to add each control one by one and set its layout by using
    various flags. This recipe shows how to create a custom `FoldPanelBar` that works
    with `Panel` objects. This class will allow for you to modularize your code into
    `Panel` classes and then just add them to the `FoldPanelBar` instead of directly
    adding everything to the `FoldPanelBar` itself.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`FoldPanelBar` 是一个自定义容器类，它允许将多个控件组合成 `FoldPanelItem` 控件，通过点击其 `CaptionBar`
    来展开或收缩。`FoldPanelBar` 不与基于 `Sizer` 的布局一起工作，因此其 API 可能会有些繁琐，因为它需要你逐个添加每个控件并使用各种标志来设置其布局。本菜谱展示了如何创建一个与
    `Panel` 对象一起工作的自定义 `FoldPanelBar`。这个类将允许你将代码模块化到 `Panel` 类中，然后只需将它们添加到 `FoldPanelBar`
    而不是直接将所有内容添加到 `FoldPanelBar` 本身。'
- en: How to do it...
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'This custom `FoldPanelBar` class uses a factory approach to simplify and abstract
    the addition of a new `Panel` to the control:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这个自定义的`FoldPanelBar`类采用工厂方法来简化并抽象化向控件添加新的`Panel`的过程：
- en: '[PRE13]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How it works...
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Our subclass of `FoldPanelBar`, adds one new method to the class `AddPanel`.
    The `AddPanel` method is a simple wrapper around the `FoldPanelBar` control's
    `AddFoldPanel` and `AddFoldPanelWindow` methods. The `AddFoldPanel` method is
    used to create the `CaptionBar` and container for the controls and the `AddFoldPanelWindow`
    method is used to add a Window object to the `FoldPanel.`
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对 `FoldPanelBar` 的子类添加了一个新的方法到 `AddPanel` 类。`AddPanel` 方法是对 `FoldPanelBar`
    控件的 `AddFoldPanel` 和 `AddFoldPanelWindow` 方法的简单封装。`AddFoldPanel` 方法用于创建控制件的 `CaptionBar`
    和容器，而 `AddFoldPanelWindow` 方法用于将一个窗口对象添加到 `FoldPanel`。
- en: Our `AddPanel` method takes a callable object as its first parameter. The callable
    must accept a "parent" argument and return a new window that is a child of that
    parent window when called. We do this because our panels need to be created as
    children of the `FoldPanelItem` that is returned by `AddFoldPanel`. This is an
    important point to remember when working with the `FoldPanelBar`. All of the controls
    that are added to it must be children of one of its `FoldPanelItems` and not children
    of the `FoldPanelBar` itself.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `AddPanel` 方法将其第一个参数接受为一个可调用对象。这个可调用对象必须接受一个 "parent" 参数，并在被调用时返回一个新窗口，该窗口是父窗口的子窗口。我们这样做是因为我们的面板需要作为
    `AddFoldPanel` 返回的 `FoldPanelItem` 的子窗口来创建。这是在使用 `FoldPanelBar` 时需要记住的一个重要点。添加到其中的所有控件都必须是其中一个
    `FoldPanelItems` 的子控件，而不是 `FoldPanelBar` 本身的子控件。
- en: Since the `FoldPanelBar` internally works with a manual layout, we need to set
    an explicit size on each `Panel` as it is added. This is done by getting the best
    size from each Panel object's `GetBestSize` method.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`FoldPanelBar`内部使用手动布局，因此在我们添加每个`Panel`时，需要为每个`Panel`设置一个显式的大小。这是通过获取每个`Panel`对象的`GetBestSize`方法的最佳大小来完成的。
- en: There's more...
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `CaptionBar` of the `FoldPanelBar` can be customized by making a custom
    `CaptionBarStyle` object and passing it to the `AddFoldPanel` method. A `CaptionBarStyle`
    object has methods for changing the colors, fonts, and styles that the `CaptionBar`
    will use. The `AddFoldPanel` method also accepts an optional `foldIcons` argument,
    which accepts an `ImageList` object that must have two 16x16 pixel bitmaps in
    it. The first will be used for the button's expanded state and the second will
    be used for its collapsed state.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`FoldPanelBar` 的 `CaptionBar` 可以通过创建一个自定义的 `CaptionBarStyle` 对象并将其传递给 `AddFoldPanel`
    方法来自定义。`CaptionBarStyle` 对象具有用于更改 `CaptionBar` 将使用的颜色、字体和样式的各种方法。`AddFoldPanel`
    方法还接受一个可选的 `foldIcons` 参数，该参数接受一个必须包含两个 16x16 像素位图的 `ImageList` 对象。第一个将被用于按钮的展开状态，第二个将被用于其折叠状态。'
