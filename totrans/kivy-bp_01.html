<html><head></head><body><div class="chapter" title="Chapter&#xA0;1.&#xA0;Building a Clock App"><div class="titlepage"><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Building a Clock App</h1></div></div></div><p>This book will walk you through the creation of nine little Kivy programs, each resembling a real-world use case for the Kivy framework. On many occasions, the framework will be utilized<a id="id0" class="indexterm"/> together with other Python modules fitting for the task at hand. We will see that Kivy provides a great deal of flexibility, allowing us to solve vastly different problems in a clean, concise manner.</p><p>Let's start small. In this chapter, we will build a simple Clock app, similar in concept to the built-in application found in both iOS and Android. In the first part of the chapter, we will create a non-interactive digital clock display and style it, giving our program an Android-ish flat look. We will also briefly discuss the event-driven program flow and a Kivy main loop, introducing timers used to perform recurring tasks, such as updating the screen every frame.</p><p>In the second part of this chapter, we will add a stopwatch display and controls, creating a fluid layout suitable for any screen size and orientation. A stopwatch, naturally, needs user interaction, which we are going to implement last.</p><p>The important topics introduced in this chapter are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <a id="id1" class="indexterm"/>basics of the Kivy language, a built-in <span class="strong"><strong>domain-specific language</strong></span> (<span class="strong"><strong>DSL</strong></span>) used to lay out widgets</li><li class="listitem" style="list-style-type: disc">Styling (and eventually subclassing) built-in Kivy components</li><li class="listitem" style="list-style-type: disc">Loading custom fonts and formatting text</li><li class="listitem" style="list-style-type: disc">Scheduling and listening to events</li></ul></div><p>Our finished program, depicted in the following screenshot, will only be about 60 lines long, split equally between a Python source code and a Kivy language (<code class="literal">.kv</code>) interface definition file.</p><div class="mediaobject"><img src="graphics/7849OS_01_01.jpg" alt="Building a Clock App"/><div class="caption"><p>The final look of the Clock app we're going to build.</p></div></div><div class="section" title="The starting point"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec10"/>The starting point</h1></div></div></div><p>Our "Hello, Kivy" example from the preface is a suitable starting point for this app. We just <a id="id2" class="indexterm"/>need to add a layout container, <code class="literal">BoxLayout</code>, so that we can fit more than one widget on the screen later.</p><p>This is the full source code at this point:</p><div class="informalexample"><pre class="programlisting"># File: main.py
from kivy.app import App

class ClockApp(App):
    pass

if __name__ == '__main__':
    ClockApp().run()

# File: clock.kv
BoxLayout:
    orientation: 'vertical'

    Label:
        text: '00:00:00'</pre></div><p>Right <a id="id3" class="indexterm"/>now, it looks and behaves exactly like the previously seen "Hello, world" app. A <code class="literal">BoxLayout</code> container allows two or more child widgets to coexist side by side, stacking either vertically or horizontally. Given just one nested widget, as in the preceding code, <code class="literal">BoxLayout</code> fills up all the available screen space with it and thus becomes practically unnoticeable (it's as if <code class="literal">Label</code> was a root widget instead, taking over the application window). We will review layouts in more detail later on.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note03"/>Note</h3><p>Note that <a id="id4" class="indexterm"/>while we may call the <code class="literal">main.py</code> file anything we want, the <code class="literal">clock.kv</code> file is autoloaded by Kivy, and therefore, has to be named after the application class. For example, if our app class is called <code class="literal">FooBarApp</code>, a corresponding <code class="literal">.kv</code> file should be named <code class="literal">foobar.kv</code> (the class name converted to lowercase and without the <code class="literal">-app</code> suffix). Closely following this naming convention allows us to avoid loading Kivy language files manually, which is unequivocally a good thing—less lines of code leading to the same result.</p></div></div></div></div>
<div class="section" title="Modern UI"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Modern UI</h1></div></div></div><p>At the <a id="id5" class="indexterm"/>time of writing this, the flat design paradigm is trending in the interface design field, systematically taking over every platform, be it Web, mobile, or desktop. Prominent examples of this paradigm shift in the wild are iOS 7 and later and Windows 8 and later. Internet companies followed suit with the "Material design principles" presented at Google I/O 2014 conference, along with many other HTML5 frameworks, including the well-established ones, for example, Bootstrap.</p><p>Conveniently, the flat design emphasizes content over presentation, omitting photo-realistic shadows and detailed textures in favor of plain colors and simple geometry. It is by all means simpler to create programmatically than the "old school" skeuomorphic design that tends to be visually rich and artistic.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note04"/>Note</h3><p>
<span class="strong"><strong>Skeuomorphism</strong></span> is <a id="id6" class="indexterm"/>a common approach to user interface design. It is characterized by applications visually imitating their real-world counterparts, for example, a Calculator app with the same button layout and look and feel as a cheap physical calculator. This may or may not help user experience (depending on who you ask).</p></div></div><p>Giving up visual details in favor of a simpler, more streamlined interface seems to be the direction everyone is going in today. On the other hand, it's naturally challenging to build a distinctive, memorable interface just from colored rectangles and such. This is why the flat design is typically synonymous with good typography; depending on the application, text is almost always a significant part of the UI, so we want it to look great.</p><div class="section" title="Design inspiration"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec13"/>Design inspiration</h2></div></div></div><p>Imitation is <a id="id7" class="indexterm"/>the sincerest form of flattery, and we will imitate the<a id="id8" class="indexterm"/> clock design from Android 4.1 Jelly Bean. The distinctive feature of this design is the font weight contrast. Until it was changed in version 4.4 KitKat, the default clock used to look like this:</p><div class="mediaobject"><img src="graphics/7849OS_01_02.jpg" alt="Design inspiration"/><div class="caption"><p>Clock in Jelly Bean flavor of Android, as seen on the lock screen.</p></div></div><p>The font used is Roboto, Google's Android font that superseded the Droid font family in Android 4.0 Ice Cream Sandwich.</p><p>Roboto is free for commercial use and available under the permissive Apache License. <a id="id9" class="indexterm"/>It can be downloaded from Google Fonts or from the excellent Font Squirrel library at <a class="ulink" href="http://www.fontsquirrel.com/fonts/roboto">http://www.fontsquirrel.com/fonts/roboto</a>.</p></div><div class="section" title="Loading custom fonts"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec14"/>Loading custom fonts</h2></div></div></div><p>When it <a id="id10" class="indexterm"/>comes to the typography, Kivy defaults to <a id="id11" class="indexterm"/>Droid Sans—Google's earlier font. It's easy to replace Droid with a custom font, as Kivy allows us to specify the <code class="literal">font_name</code> property for textual widgets (in this case, <code class="literal">Label</code>).</p><p>In the simplest case when we have just one font variant, it is possible to assign a <code class="literal">.ttf</code> filename directly in the definition of a widget:</p><div class="informalexample"><pre class="programlisting">Label:
    font_name: 'Lobster.ttf'</pre></div><p>For the aforementioned design, however, we want different font weights, so this approach won't cut it. The reason being, every variation of a font (for example, bold or italic) commonly lives in a separate file, and we can only assign one filename to the <code class="literal">font_name</code> property.</p><p>Our use <a id="id12" class="indexterm"/>case, involving more than one <code class="literal">.ttf</code> file, is<a id="id13" class="indexterm"/> better covered by a <code class="literal">LabelBase.register</code> static method. It accepts the following arguments (all optional), exemplified by the Roboto font family:</p><div class="informalexample"><pre class="programlisting"># In Python code
LabelBase.register(name="Roboto",
    <span class="strong"><strong>fn_regular</strong></span>="Roboto-Regular.ttf",
    <span class="strong"><strong>fn_bold</strong></span>="Roboto-Bold.ttf",
    <span class="strong"><strong>fn_italic</strong></span>="Roboto-Italic.ttf",
    <span class="strong"><strong>fn_bolditalic</strong></span>="Roboto-BoldItalic.ttf")</pre></div><p>After this invocation, it becomes possible to set the <code class="literal">font_name</code> property of a widget to the name of the previously registered font family, <code class="literal">Roboto</code> in this case.</p><p>This approach has two limitations to be aware of:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Kivy only accepts TrueType <code class="literal">.ttf</code> font files. If the fonts are packaged as OpenType <code class="literal">.otf</code> or a web font format such as <code class="literal">.woff</code>, you may need to convert <a id="id14" class="indexterm"/>them first. This can be easily done using the FontForge editor, which can be found at <a class="ulink" href="http://fontforge.org/">http://fontforge.org/</a>.</li><li class="listitem" style="list-style-type: disc">There is a maximum of four possible styles per font: normal, italic, bold, and bold italic. It's fine for older font families, such as Droid Sans, but many modern fonts include anywhere from 4 to over 20 styles with varying font weight and other features. Roboto, which we're going to use shortly, is available in at least 12 styles.</li></ul></div><div class="mediaobject"><img src="graphics/7849OS_01_03.jpg" alt="Loading custom fonts"/><div class="caption"><p>The six font weights of Roboto font</p></div></div><p>The second point forces us to choose which font styles we will use in our application as we can't just throw in all 12, which is a bad idea anyway as it would lead to a hefty increase in file size, up to 1.7 megabytes in the case of Roboto family.</p><p>For this particular app, we only need two styles: a lighter one (<code class="literal">Roboto-Thin.ttf</code>) and a heavier one (<code class="literal">Roboto-Medium.ttf</code>), which we assign to <code class="literal">fn_regular</code> and <code class="literal">fn_bold</code> respectively:</p><div class="informalexample"><pre class="programlisting">from kivy.core.text import LabelBase

LabelBase.register(name='Roboto',
                   fn_regular='Roboto-Thin.ttf',
                   fn_bold='Roboto-Medium.ttf')</pre></div><p>This code <a id="id15" class="indexterm"/>should be placed right after the <code class="literal">__name__ == '__main__'</code> line in <code class="literal">main.py</code>, as it needs to run before the interface is created from<a id="id16" class="indexterm"/> the Kivy language definition. By the time the app class is instantiated, it might already be too late to perform basic initialization like this. This is why we have to do it in advance.</p><p>Now that we have a custom font in place, all that's left is to assign it to our <code class="literal">Label</code> widget. This can be done with the help of the following code:</p><div class="informalexample"><pre class="programlisting"># In clock.kv
Label:
    text: '00:00:00'
    font_name: 'Roboto'
    font_size: 60</pre></div></div><div class="section" title="Formatting text"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec15"/>Formatting text</h2></div></div></div><p>The most <a id="id17" class="indexterm"/>popular and universally used markup language<a id="id18" class="indexterm"/> out there is undoubtedly HTML. Kivy, on the other hand, implements a variant of BBCode, a markup language once used to format posts on many message boards. Visible distinction from HTML is that BBCode uses square brackets as tag delimiters.</p><p>The <a id="id19" class="indexterm"/>following tags are available in Kivy:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>BBCode tag</p>
</th><th style="text-align: left" valign="bottom">
<p>Effect on text</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">[b]...[/b]</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<span class="strong"><strong>Bold</strong></span>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">[i]...[/i]</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<span class="emphasis"><em>Italic</em></span>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">[font=Lobster]...[/font]</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Change font</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">[color=#FF0000]...[/color]</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Set color with CSS-like syntax</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">[sub]...[/sub]</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Subscript (text below the line)</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">[sup]...[/sup]</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Superscript (text above the line)</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">[ref=name]...[/ref]</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Clickable zone, <code class="literal">&lt;a href="…"&gt;</code> in HTML</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">[anchor=name]</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Named location, <code class="literal">&lt;a name="…"&gt;</code> in HTML</p>
</td></tr></tbody></table></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip02"/>Tip</h3><p>This is by no means an exhaustive reference because Kivy is under active development and has probably undergone a number of releases since this text was written, adding new features and refining the existing functionality. Please refer to <a id="id20" class="indexterm"/>the Kivy documentation found on the official website (<a class="ulink" href="http://kivy.org">http://kivy.org</a>) for an up-to-date reference manual.</p></div></div><p>Let's return<a id="id21" class="indexterm"/> to our project. To achieve the desired formatting (hours in bold and the rest of the text in <code class="literal">fn_regular</code> thin font), we can use the <a id="id22" class="indexterm"/>following code:</p><div class="informalexample"><pre class="programlisting">Label:
    text: '[b]00[/b]:00:00'
    markup: True</pre></div><p>Kivy's BBCode flavor works only if we also set the <code class="literal">markup</code> property of a widget to <code class="literal">True</code>, as shown in the preceding code. Otherwise, you will literally see the string <code class="literal">[b]…[/b]</code> displayed on the screen, and that's clearly not desired.</p><p>Note that if we wanted to make the whole text bold, there is no need to enclose everything in <code class="literal">[b]…[/b]</code> tags; we could just set the <code class="literal">bold</code> property of the widget to <code class="literal">True</code>. The same applies to italic, color, font name, and size—pretty much everything can be configured globally to affect the whole widget without touching markup.</p></div><div class="section" title="Changing the background color"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec16"/>Changing the background color</h2></div></div></div><a id="id23" class="indexterm"/><p>In this section, we will adjust the window<a id="id24" class="indexterm"/> background color. Window background (the "clear color" of OpenGL renderer) is a property of a global <code class="literal">Window</code> object. In order to change it, we add this code right after the <code class="literal">__name__ == '__main__'</code> line in <code class="literal">main.py</code>:</p><div class="informalexample"><pre class="programlisting">from kivy.core.window import Window
from kivy.utils import get_color_from_hex

Window.clearcolor = get_color_from_hex('#101216')</pre></div><p>The <code class="literal">get_color_from_hex</code> function<a id="id25" class="indexterm"/> is not strictly required, but it's nice as it allows us to use CSS-style (<code class="literal">#RRGGBB</code>) colors instead of <code class="literal">(R, G, B)</code> tuples throughout our code. And using CSS colors is preferable for at least the following<a id="id26" class="indexterm"/> two reasons:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Less cognitive overhead when reading</strong></span>: The <code class="literal">#FF0080</code> value is immediately recognized as a color when you're familiar with this notation, while (255, 0, 128) is<a id="id27" class="indexterm"/> just a bunch of numbers that may be used differently depending on the context. The floating-point variant of <code class="literal">#FF0080</code>, (1.0, 0.0, 0.50196) is even worse.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Simple and unambiguous searching</strong></span>: A tuple can be arbitrarily formatted, while <a id="id28" class="indexterm"/>a CSS-like color notation<a id="id29" class="indexterm"/> is uniform, albeit case-insensitive. Performing a case-insensitive search in most text editors is very simple, as opposed to locating all instances of a given tuple inside a lengthy Python listing. The latter task can prove challenging and involve regular expressions, among other things, because the formatting of tuples doesn't have to be consistent.</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip03"/>Tip</h3><p>More<a id="id30" class="indexterm"/> information about the <code class="literal">#RRGGBB</code> color format can be found on Mozilla Developer Network at <a class="ulink" href="https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_started/Color">https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_started/Color</a>.</p></div></div><p>We will talk more about design-related features of Kivy later on. Meanwhile, let's make our application actually show the time.</p></div></div>
<div class="section" title="Making the clock tick"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec12"/>Making the clock tick</h1></div></div></div><p>UI <a id="id31" class="indexterm"/>frameworks are mostly event-driven, and Kivy is no exception. The distinction from the "usual" procedural code is simple—the event-driven code needs to return to the main loop often; otherwise, it will be unable to process events from a user (such as pointer movement, clicks, or window resize), and the interface will "freeze". If you're a longtime Microsoft Windows user, you are probably familiar with programs that are unresponsive and freeze very often. It is crucial to never let this happen in our apps.</p><p>Practically, this means that we can't just code an infinite loop like this in our program:</p><div class="informalexample"><pre class="programlisting"># Don't do this
while True:
    update_time()  # some function that displays time
    sleep(1)</pre></div><p>Technically, it might work, but the application's UI will stay in the "not responding" state until the application gets killed (forcefully stopped) by the user or an operating system. Instead of taking this faulty approach, we need to keep in mind that there is a main loop running inside Kivy, and we need to take advantage of it by utilizing events and timers.</p><p>Event-driven architecture also means that in many places, we will listen to events to respond to various conditions, be it user input, network events, or timeouts.</p><p>One of the common events that many programs listen to is <code class="literal">App.on_start</code>. A method with this <a id="id32" class="indexterm"/>name, if defined on the application class, will be called as soon as the app is fully initialized. Another good example of an event that we will find in many programs is <code class="literal">on_press</code>, which fires when the user clicks, taps, or otherwise interacts with a button.</p><p>Speaking of time and timers, we can easily schedule our code to run in the future using a built-in <code class="literal">Clock</code> class. It exposes the following static methods:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Clock.schedule_once</code>: Runs a function once <a id="id33" class="indexterm"/>after a timeout</li><li class="listitem" style="list-style-type: disc"><code class="literal">Clock.schedule_interval</code>: Runs a function<a id="id34" class="indexterm"/> periodically</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note05"/>Note</h3><p>Anyone with a JavaScript background will easily recognize these two functions. They are exactly like <code class="literal">window.setTimeout</code> and <code class="literal">window.setInterval</code> in JS. Indeed, the Kivy programming model is very similar to JavaScript even if the API looks completely different.</p></div></div><p>It's important to understand that all timed events that originate from <code class="literal">Clock</code> run as a part of Kivy's main event loop. This approach is not synonymous to threading, and scheduling a blocking function like this may prevent other events from being invoked in a timely manner, or at all.</p><div class="section" title="Updating the time on the screen"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec17"/>Updating the time on the screen</h2></div></div></div><p>To<a id="id35" class="indexterm"/> access the <code class="literal">Label</code> widget that holds time, we will give <a id="id36" class="indexterm"/>it a unique identifier (<code class="literal">id</code>). Later, we can easily look up <a id="id37" class="indexterm"/>widgets based on their <code class="literal">id</code> property—again, a concept which is very similar to web development.</p><p>Modify <code class="literal">clock.kv</code> by adding the following:</p><div class="informalexample"><pre class="programlisting">Label:
    id: time</pre></div><p>That's it! Now we can access this <code class="literal">Label</code> widget from our code directly using the <code class="literal">root.ids.time</code> notation (<code class="literal">root</code> in our case is <code class="literal">BoxLayout</code>).</p><p>Updates to the <code class="literal">ClockApp</code> class include the addition of a method to display time, <code class="literal">update_time</code>, which looks like this:</p><div class="informalexample"><pre class="programlisting">def update_time(self, nap):
    self.root.ids.time.text = strftime('[b]%H[/b]:%M:%S')</pre></div><p>Now let's schedule the update function to run once per second after the program starts:</p><div class="informalexample"><pre class="programlisting">def on_start(self):
    Clock.schedule_interval(self.update_time, 1)</pre></div><p>If we run the application right now, we'll see that the time displayed is being updated every second. To paraphrase Neil Armstrong, that is one small step for mankind, but a sizable<a id="id38" class="indexterm"/> leap for a Kivy beginner.</p><p>It's <a id="id39" class="indexterm"/>worth noting how the argument to <code class="literal">strftime</code> combines<a id="id40" class="indexterm"/> Kivy's BBCode-like tags described earlier with the function-specific C-style format directives. For the unfamiliar, here's a quick and incomplete reference on <code class="literal">strftime</code> formatting essentials:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Format string (case-sensitive)</p>
</th><th style="text-align: left" valign="bottom">
<p>Resulting output</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">%S</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Second<a id="id41" class="indexterm"/> as two digits, typically <code class="literal">00</code> to <code class="literal">59</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">%M</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Minute<a id="id42" class="indexterm"/> as two digits, <code class="literal">00</code> to <code class="literal">59</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">%H</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Hour <a id="id43" class="indexterm"/>as per 24-hour clock, <code class="literal">00</code> to <code class="literal">23</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">%I</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Hour <a id="id44" class="indexterm"/>as per 12-hour clock, <code class="literal">01</code> to <code class="literal">12</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">%d</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Day <a id="id45" class="indexterm"/>of <a id="id46" class="indexterm"/>the month, <code class="literal">01</code> to <code class="literal">31</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">%m</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Month (numeric), <code class="literal">01</code> to <code class="literal">12</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">%B</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Month (string), for <a id="id47" class="indexterm"/>example, <code class="literal">"October"</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">%Y</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Year <a id="id48" class="indexterm"/>as four digits, such as <code class="literal">2016</code>
</p>
</td></tr></tbody></table></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip04"/>Tip</h3><p>For the most complete and up-to-date documentation on displaying time, please refer<a id="id49" class="indexterm"/> to the official reference manual—in this case, Python standard library reference, located at <a class="ulink" href="https://docs.python.org/">https://docs.python.org/</a>.</p></div></div></div><div class="section" title="Binding widgets using properties"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec18"/>Binding widgets using properties</h2></div></div></div><p>Instead<a id="id50" class="indexterm"/> of hardcoding an ID for each widget <a id="id51" class="indexterm"/>that we need to access from Python code, we <a id="id52" class="indexterm"/>can also create a property and assign it <a id="id53" class="indexterm"/>in a Kivy language file. The motivation for doing so is mostly the <span class="strong"><strong>DRY</strong></span> principle and cleaner naming, at a cost of a few more lines of code.</p><p>Such a property can be defined as follows:</p><div class="informalexample"><pre class="programlisting"># In main.py
from kivy.properties import ObjectProperty
from kivy.uix.boxlayout import BoxLayout

class ClockLayout(BoxLayout):
    time_prop = ObjectProperty(None)</pre></div><p>In this<a id="id54" class="indexterm"/> code fragment, we make a new root widget <a id="id55" class="indexterm"/>class for our application based on <code class="literal">BoxLayout</code>. It has a custom property, <code class="literal">time_prop</code>, which is going to reference <code class="literal">Label</code> we need<a id="id56" class="indexterm"/> to address from Python code.</p><p>Additionally, in the Kivy language file, <code class="literal">clock.kv</code>, we have to bind this property to a corresponding <code class="literal">id</code>. Custom properties look and behave no different from the default ones and use exactly the same syntax:</p><div class="informalexample"><pre class="programlisting">ClockLayout:
    time_prop: time

    Label:
        id: time</pre></div><p>This code makes the <code class="literal">Label</code> widget accessible from the Python code without knowing the widget's ID, using the newly defined property, <code class="literal">root.time_prop.text = "demo"</code>.</p><p>The described approach is more portable than the previously shown one and it eliminates the need to keep widget identifiers from the Kivy language file in sync with the Python code, for example, when refactoring. Otherwise, the choice between relying on properties and accessing widgets from Python via <code class="literal">root.ids</code> is a matter of coding style.</p><p>Later in this book, we'll explore more advanced usage of Kivy properties, facilitating nearly effortless data binding.</p></div></div>
<div class="section" title="Layout basics"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec13"/>Layout basics</h1></div></div></div><p>To <a id="id57" class="indexterm"/>arrange widgets on the screen, Kivy provides a number of <code class="literal">Layout</code> classes. <code class="literal">Layout</code>, a subclass of <code class="literal">Widget</code>, serves as a container for other widgets. Every layout affects the positioning and size of its children in a unique way.</p><p>For this application, we won't need anything fancy, as the desired UI is pretty straightforward. This is what we're aiming to achieve:</p><div class="mediaobject"><img src="graphics/7849OS_01_04.jpg" alt="Layout basics"/><div class="caption"><p>A mockup layout of the finished Clock app interface.</p></div></div><p>To build this, we will use <code class="literal">BoxLayout</code>, which is basically a one-dimensional grid. We already have <code class="literal">BoxLayout</code> in our <code class="literal">clock.kv</code> file, but since it only has one child, it does not affect anything. A rectangular grid with one cell is really just that, a rectangle.</p><p>Kivy layouts almost always try to fill the screen, thus our application will adapt to any screen size and orientation changes automatically.</p><p>If we add another label to <code class="literal">BoxLayout</code>, it will take half the screen space, depending on the orientation: a vertical box layout grows from top to bottom, and horizontal from left to right.</p><p>You might have guessed that in order to create a row of buttons inside a vertical layout, we can just embed another, horizontal box layout into the first one. Layouts are widgets, so they can be nested in arbitrary and creative ways to build complex interfaces.</p><div class="section" title="Finalizing the layout"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec19"/>Finalizing the layout</h2></div></div></div><p>Stacking <a id="id58" class="indexterm"/>three widgets into <code class="literal">BoxLayout</code> normally makes every widget a third of the available size. Since we don't want buttons to be this big compared to clock displays, we can add a <code class="literal">height</code> property to the horizontal (inner) <code class="literal">BoxLayout</code> and set its vertical <code class="literal">size_hint</code> property to <code class="literal">None</code>.</p><p>The <code class="literal">size_hint</code> property<a id="id59" class="indexterm"/> is a tuple of two values, affecting the widget's width and height. We will discuss the impact that <code class="literal">size_hint</code> has on different layouts in the next few chapters; right now, let's just say that if we want to use absolute numbers for width or height, we have to set <code class="literal">size_hint</code> to <code class="literal">None</code> accordingly; otherwise, assigning size won't work as the widget will continue to compute its own size instead of using the values that we'll provide.</p><p>After updating the <code class="literal">clock.kv</code> file to account for stopwatch display and controls, it should look similar to the following (note the hierarchy of the layouts):</p><div class="informalexample"><pre class="programlisting">BoxLayout:
    orientation: 'vertical'

    Label:
        id: time
        text: '[b]00[/b]:00:00'
        font_name: 'Roboto'
        font_size: 60
        markup: True

    BoxLayout:
        height: 90
        orientation: 'horizontal'
        padding: 20
        spacing: 20
        size_hint: (1, None)

        Button:
            text: 'Start'
            font_name: 'Roboto'
            font_size: 25
            bold: True

        Button:
            text: 'Reset'
            font_name: 'Roboto'
            font_size: 25
            bold: True

    Label:
        id: stopwatch
        text: '00:00.[size=40]00[/size]'
        font_name: 'Roboto'
        font_size: 60
        markup: True</pre></div><p>If we run<a id="id60" class="indexterm"/> the code now, we'll notice that buttons don't fill all the available space inside <code class="literal">BoxLayout</code>. This effect is achieved using the <code class="literal">padding</code> and <code class="literal">spacing</code> properties of the layout. Padding acts very similar to CSS, pushing children (in our case, buttons) away from the edges of the layout, while spacing controls the distance between adjacent children. Both properties default to zero, aiming at maximum widget density.</p></div><div class="section" title="Reducing repetition"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec20"/>Reducing repetition</h2></div></div></div><p>This <a id="id61" class="indexterm"/>layout works but has one serious problem: the code is<a id="id62" class="indexterm"/> very repetitive. Every change we may want to make has to be done in a number of places throughout the file, and it's very easy to miss one of them and thus introduce an inconsistent change.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note06"/>Note</h3><p>To<a id="id63" class="indexterm"/> continue the analogy with the web platform, before <span class="strong"><strong>CSS</strong></span> (<span class="strong"><strong>Cascading Style Sheets</strong></span>) became universally available, style information was being written directly in tags that surround the text. It looked like this:</p><div class="informalexample"><pre class="programlisting">
<code class="literal">&lt;p&gt;&lt;font face="Helvetica"&gt;Part 1&lt;/font&gt;&lt;/p&gt;</code>
<code class="literal">&lt;p&gt;&lt;font face="Helvetica"&gt;Part 2&lt;/font&gt;&lt;/p&gt;</code>
</pre></div><p>Using this approach, changing any individual element's properties is easy, but adjusting the properties of the whole document's look requires an excessive amount of manual labor. If we wanted to change the font face to Times in the next version of the page, we would have to search and replace every occurrence of the word Helvetica while trying to make sure that we don't have this same word in the running text, as it may be occasionally replaced too.</p><p>With style sheets, on the other hand, we move all of the styling information to a CSS rule:</p><div class="informalexample"><pre class="programlisting">
<code class="literal">p {font-family: Helvetica}</code>
</pre></div><p>Now we have just one place to account for styling of every paragraph throughout the document; no more searching and replacing to change font or any other visual attribute, such as color or padding. Note that we still may slightly adjust a single element's properties:</p><div class="informalexample"><pre class="programlisting">
<code class="literal">&lt;p style="font-family: Times"&gt;Part 3&lt;/p&gt;</code>
</pre></div><p>So we haven't lost anything by implementing CSS, and there is practically no tradeoff; this explains why the adaptation of style sheets on the Internet was very fast (especially considering the scale) and overwhelmingly successful. CSS is being widely used to this day with no conceptual changes.</p></div></div><p>In Kivy, there is no need to use a different file for our aggregate styles or class rules, like it's usually done in web development. We just add to the <code class="literal">clock.kv</code> file a definition like the following, outside of <code class="literal">BoxLayout</code>:</p><div class="informalexample"><pre class="programlisting">&lt;Label&gt;:
    font_name: 'Roboto'
    font_size: 60
    markup: True</pre></div><p>This is a class rule; it acts similar to a CSS selector described in the previous information box. Every <code class="literal">Label</code> derives all the properties from the <code class="literal">&lt;Label&gt;</code> class rule. (Note the angle brackets.)</p><p>Now we<a id="id64" class="indexterm"/> can remove the <code class="literal">font_name</code>, <code class="literal">font_size</code>, and <code class="literal">markup</code> properties from each individual <code class="literal">Label</code>. As a general rule, always strive to move every <a id="id65" class="indexterm"/>repeated definition into a class. This is a well-known <a id="id66" class="indexterm"/>best practice called <span class="strong"><strong>don't repeat yourself</strong></span> (<span class="strong"><strong>DRY</strong></span>). Changes like the one shown in the previous code snippet may seem trivial in a toy project like this but will make our code much cleaner and more maintainable in a long run.</p><p>If we want to override a property of one of the widgets, just add it as usual. Immediate properties take precedence over those inherited from the class definition.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip05"/>Tip</h3><p>Keep in mind that a class definition is completely different from a widget defined in the same <code class="literal">.kv</code> file. While the syntax is largely the same, the class is just an abstract definition; on its own, it does not create a new widget. Thus, adding a class definition will not introduce any changes to the app if we don't use it later.</p></div></div><div class="section" title="Named classes"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec01"/>Named classes</h3></div></div></div><p>One<a id="id67" class="indexterm"/> obvious problem with the straightforward approach to classes<a id="id68" class="indexterm"/> described earlier is that we can only have one class named <code class="literal">Label</code>. As soon as we need two different sets of properties applied to the same kind of widget, we have to define our own custom classes for them. Additionally, overwriting the framework's built-in classes, such as <code class="literal">Label</code> or <code class="literal">Button</code>, may have undesired consequences throughout the application, for example, if another component is using the widget we've altered under the hood.</p><p>Fortunately, this is very simple to solve. Let's create a named class for buttons, <code class="literal">RobotoButton</code>:</p><div class="informalexample"><pre class="programlisting">&lt;RobotoButton@Button&gt;:
    font_name: 'Roboto'
    font_size: 25
    bold: True</pre></div><p>The part before the <code class="literal">@</code> symbol designates the new class name, followed by the widget type we're extending (in Python, we would say <code class="literal">class RobotoButton(Button):</code> instead). The resulting class can be then used in the Kivy language instead of the generic <code class="literal">Button</code> class:</p><div class="informalexample"><pre class="programlisting">RobotoButton:
    text: 'Start'</pre></div><p>The use <a id="id69" class="indexterm"/>of class rules allows us to reduce the number of recurrent<a id="id70" class="indexterm"/> lines in the <code class="literal">clock.kv</code> file, and also provide a consistent way of tweaking similar widgets using class definitions. Next, let's use this feature to customize all the buttons.</p></div></div></div>
<div class="section" title="Styling buttons"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec14"/>Styling buttons</h1></div></div></div><p>One <a id="id71" class="indexterm"/>of the darker corners of the flat UI paradigm is the look of clickable elements, like that of buttons; there is no universally accepted way of styling them.</p><p>For example, the Modern UI style (previously called Metro, as seen in Windows 8) is very radical, with clickable elements that look mostly like flat-colored rectangles with little or no distinctive graphical features. Other vendors, such as Apple, use vibrant gradients; there is a trend of also adding rounded corners, especially in web design since CSS3 provides a special-case syntax for just that. Subtle shadows, while considered heresy by some, aren't unheard of either.</p><p>Kivy is flexible in this regard. The framework does not impose any restrictions on visuals and provides a number of useful features to implement any design you like. One of the utilities that we will discuss next is 9-patch image scaling, which is used to style buttons and similar widgets that may have borders.</p><div class="section" title="9-patch scaling"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec21"/>9-patch scaling</h2></div></div></div><p>The <a id="id72" class="indexterm"/>motivation for a good scaling algorithm is simple: it's <a id="id73" class="indexterm"/>almost impossible to provide pixel-perfect graphics for every button, especially for the problematic ones that contain (varying amounts of) text. Scaling images uniformly is simple to implement but yields results that are mediocre at best, partly because of the aspect ratio distortion.</p><p>Non-uniform 9-patch scaling, on the other hand, produces uncompromising quality. The idea is to split the image into static and scalable parts. The following image is a hypothetical scalable button. The middle part (shown in yellow) is the working area, and everything else is a border:</p><div class="mediaobject"><img src="graphics/7849OS_01_05.jpg" alt="9-patch scaling"/></div><p>The<a id="id74" class="indexterm"/> red zones can be stretched in one dimension, while <a id="id75" class="indexterm"/>the blue zones (corners) are always left intact. This is evident from the following screenshot:</p><div class="mediaobject"><img src="graphics/7849OS_01_06.jpg" alt="9-patch scaling"/></div><p>Corners, shown in blue, are fully static and may contain virtually anything. Borders, shown in red, are scalable in one dimension (top and bottom sides can be stretched horizontally, and left and right sides can be stretched vertically). The only part of the image that will be uniformly resized is the inner rectangle, the working area, shown in yellow; it is therefore common to paint it with a flat color. It will also contain text that's assigned to the button, if any.</p></div><div class="section" title="Using 9-patch images"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec22"/>Using 9-patch images</h2></div></div></div><p>For<a id="id76" class="indexterm"/> this tutorial, we will use a simple flat button <a id="id77" class="indexterm"/>with a 1-pixel border. We can reuse this texture for all buttons or choose a different one, for example, for the Reset button. A button texture for the normal state with flat color and 1-pixel border is shown as follows:</p><div class="mediaobject"><img src="graphics/7849OS_01_07.jpg" alt="Using 9-patch images"/></div><p>The<a id="id78" class="indexterm"/> corresponding texture for the pressed state<a id="id79" class="indexterm"/>—an inversion of the preceding image—is shown as follows:</p><div class="mediaobject"><img src="graphics/7849OS_01_08.jpg" alt="Using 9-patch images"/></div><p>Now, to apply the 9-patch magic, we need to tell Kivy the size of borders that have limited scalability, as discussed previously (the image will be scaled uniformly by default). Let's revisit the <code class="literal">clock.kv</code> file and add the following properties:</p><div class="informalexample"><pre class="programlisting">&lt;RobotoButton@Button&gt;:
    background_normal: 'button_normal.png'
    background_down: 'button_down.png'
    border: (2, 2, 2, 2)</pre></div><p>The <code class="literal">border</code> property<a id="id80" class="indexterm"/> values are ordered just like in CSS: top, right, bottom, and left (that is, clockwise starting from the top). Unlike CSS, we can't supply just one value for all sides; at least in the current Kivy version (1.8), the notation <code class="literal">border: 2</code> results in error.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip06"/>Tip</h3><p>Probably the shortest way of setting all the borders to the same value is the Python syntax <code class="literal">border: [2] * 4</code>, which means take a list with a single element, <code class="literal">2</code>, and repeat it four times.</p></div></div><p>Also note<a id="id81" class="indexterm"/> that while the visible border is just one <a id="id82" class="indexterm"/>pixel wide, we're assigning the <code class="literal">border</code> property of customized buttons to <code class="literal">2</code>. This is due to the texture-stretching behavior of the renderer: if pixel colors from both sides of the "cut line" don't match, the result will be a gradient, and we want solid color.</p><p>In the class rules overview, we mentioned that the property declared on an instance of a widget takes precedence over the class rule's property with the same name. This can be used to selectively override <code class="literal">background_*</code>, <code class="literal">border</code> or any other attribute, for example, assigning another texture while reusing the border width definition:</p><div class="informalexample"><pre class="programlisting">RobotoButton:
    text: 'Reset'
    background_normal: 'red_button_normal.png'
    background_down: 'red_button_down.png'</pre></div><p>Now our buttons are stylized, but they still don't do anything. The next step towards our goal is making the stopwatch work.</p></div></div>
<div class="section" title="Counting time"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec15"/>Counting time</h1></div></div></div><p>Although<a id="id83" class="indexterm"/> both stopwatch and the regular clock ultimately just display time, they are completely different in terms of functionality. Wall clock is a strictly increasing monotonic function, while stopwatch time can be paused and reset, decreasing the counter. More practically, the difference is that the operating system readily exposes its internal wall clock to Python, both directly as a <code class="literal">datetime</code> object and transparently in the case of the <code class="literal">strftime()</code> function. The latter can be called without a <code class="literal">datetime</code> argument to format the current time, which is exactly what we need for a wall clock display.</p><p>For the task of creating a stopwatch, we will need to build our own, non-monotonic time counter first. This is easily achieved without using Python's time functions altogether, thanks to Kivy's <code class="literal">Clock.schedule_interval</code> event handler that accepts the time passed between calls as a parameter. This is just what the <code class="literal">nap</code> parameter does in the following code:</p><div class="informalexample"><pre class="programlisting">def on_start(self):
    Clock.schedule_interval(self.update, 0.016)

def update(self, nap):
    pass</pre></div><p>Time is measured in seconds, that is, if the app is running at 60 fps and calls our function<a id="id84" class="indexterm"/> every frame, the average nap will be <span class="emphasis"><em>60</em></span><sup><span class="emphasis"><em>−1</em></span></sup><span class="emphasis"><em>= 0.016(6)</em></span>.</p><p>With this parameter in place, keeping track of the time passed is simple and can be achieved with a simple increment:</p><div class="informalexample"><pre class="programlisting">class ClockApp(App):
    sw_seconds = 0

    def update(self, nap):
        self.sw_seconds += nap</pre></div><p>This timer we just created isn't, by definition, a stopwatch since right now, there is no way for the user to actually stop it. However, let's update the display with the incrementing time first so that we can see the effect of controls immediately when implementing them.</p><div class="section" title="Formatting the time for stopwatch"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec23"/>Formatting the time for stopwatch</h2></div></div></div><p>For the<a id="id85" class="indexterm"/> main time display, formatting is easy because <a id="id86" class="indexterm"/>the standard library function <code class="literal">strftime</code> provides us with a number of readily available primitives to convert a <code class="literal">datetime</code> object into a readable string representation, according to the provided format string.</p><p>This <a id="id87" class="indexterm"/>function has a number of limitations:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It only accepts Python <code class="literal">datetime</code> objects (while for the stopwatch, we only have a floating-point number of seconds passed, <code class="literal">sw_seconds</code>)</li><li class="listitem" style="list-style-type: disc">It has no formatting directive for a decimal fraction of seconds</li></ul></div><p>The former <code class="literal">datetime</code> limitation can be easily circumvented: we could cast our <code class="literal">sw_seconds</code> variable to <code class="literal">datetime</code>. But the latter deficiency makes this unnecessary, as we want to end our notation with fractions of a second (exact to 0.01 sec), so <code class="literal">strftime</code> formatting just won't cut it. Hence, we implement our own time formatting.</p><div class="section" title="Computing values"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec02"/>Computing values</h3></div></div></div><p>First, we <a id="id88" class="indexterm"/>need to compute the necessary values: minutes, seconds, and<a id="id89" class="indexterm"/> fractions of a second. The math is easy; here's the one-liner for minutes and seconds:</p><div class="informalexample"><pre class="programlisting">minutes, seconds = divmod(self.sw_seconds, 60)</pre></div><p>Note the use of the <code class="literal">divmod</code> function. This is a shorthand for the following:</p><div class="informalexample"><pre class="programlisting">minutes = self.sw_seconds / 60
seconds = self.sw_seconds % 60</pre></div><p>While being more concise, the <code class="literal">divmod</code> version should also perform better on most Python interpreters, as it performs the division just once. On today's machines, the floating-point division is quite effective, but if we run a whole lot of such operations every frame, like in a video game or simulation, the CPU time will quickly add up.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip07"/>Tip</h3><p>Generally, the author tends to disagree with the oft-chanted mantra about premature optimization being evil; many bad practices that lead to choppy and substandard performance can and should be easily avoided without compromising on code quality, and not doing so is by all means premature pessimization.</p></div></div><p>Also<a id="id90" class="indexterm"/> note that both <code class="literal">minutes</code> and <code class="literal">seconds</code> values are still <a id="id91" class="indexterm"/>floating-point, so we will need to convert them to integers before we print them: <code class="literal">int(minutes)</code> and <code class="literal">int(seconds)</code>.</p><p>Now all that's left is hundredths of seconds; we can compute them like this:</p><div class="informalexample"><pre class="programlisting">int(seconds * 100 % 100)</pre></div></div><div class="section" title="Putting a stopwatch in place"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec03"/>Putting a stopwatch in place</h3></div></div></div><p>We <a id="id92" class="indexterm"/>have all the values; let's join them together. Formatting<a id="id93" class="indexterm"/> strings in Python is quite a common task, and contrary to The Zen of Python commandment that reads, "There should be one—and preferably only one—obvious way to do it" (<a class="ulink" href="https://www.python.org/dev/peps/pep-0020/">https://www.python.org/dev/peps/pep-0020/</a>), there are several common idioms for string formatting. We will use one of the simplest, operator %, which is somewhat similar to the <code class="literal">sprintf()</code> function commonly found in other programming languages:</p><div class="informalexample"><pre class="programlisting">def update_time(self, nap):
    self.sw_seconds += nap
    minutes, seconds = divmod(self.sw_seconds, 60)
    self.root.ids.stopwatch.text = (
        '%02d:%02d.[size=40]%02d[/size]' %
        (int(minutes), int(seconds),
         int(seconds * 100 % 100)))</pre></div><p>Since we have fractions of a second now, the refresh frequency of 1 fps that we used earlier isn't sufficient anymore. Let's set it to 0 instead so that our <code class="literal">update_time</code> function will be called for every frame:</p><div class="informalexample"><pre class="programlisting">Clock.schedule_interval(self.update_time, 0)</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip08"/>Tip</h3><p>Today, most displays run at a refresh rate of 60 fps, while our value is exact to 1/100 sec, that is, changes 100 times per second. While we could have attempted to run our function at exactly 100 fps, there is absolutely no reason to do it: for users, it isn't possible to see the difference on commonly available hardware, as the display will still update no more than 60 times per second anyway.</p><p>That said, most of the time your code should work independently of a frame rate, as it relies on the user's hardware, and there is no way to predict what machine your application will end up on. Even today's smartphones have wildly different system specs and performance, let alone laptops and desktop computers.</p></div></div><p>And<a id="id94" class="indexterm"/> that's it; if we run the application now, we'll see an <a id="id95" class="indexterm"/>incrementing counter. It lacks interactivity yet, and this will be our next target.</p></div></div></div>
<div class="section" title="Stopwatch controls"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec16"/>Stopwatch controls</h1></div></div></div><p>Controlling<a id="id96" class="indexterm"/> the application by the means of button press events is very easy. All that we need to do for this to work is use the following code:</p><div class="informalexample"><pre class="programlisting">def start_stop(self):
    self.root.ids.start_stop.text = ('Start'
        if self.sw_started else 'Stop')
    self.sw_started = not self.sw_started

def reset(self):
    if self.sw_started:
        self.root.ids.start_stop.text = 'Start'
        self.sw_started = False
    self.sw_seconds = 0</pre></div><p>The first event handler is for the <span class="strong"><strong>Start</strong></span> and <span class="strong"><strong>Stop</strong></span> buttons. It changes the state (<code class="literal">sw_started</code>) and the button caption. The second handler reverts everything to the initial state.</p><p>We also need to add the state property to keep track of whether the stopwatch is running or paused:</p><div class="informalexample"><pre class="programlisting">class ClockApp(App):
    sw_started = False
    sw_seconds = 0

    def update_clock(self, nap):
        if self.sw_started:
            self.sw_seconds += nap</pre></div><p>We change the <code class="literal">update_clock</code> function so that it increments <code class="literal">sw_seconds</code> only if the stopwatch is started, that is, <code class="literal">sw_started</code> is set to <code class="literal">True</code>. Initially, the stopwatch isn't started.</p><p>In the <code class="literal">clock.kv</code> file, we bind these new methods to <code class="literal">on_press</code> events:</p><div class="informalexample"><pre class="programlisting">RobotoButton:
    id: start_stop
    text: 'Start'
    on_press: app.start_stop()

RobotoButton:
    id: reset
    text: 'Reset'
    on_press: app.reset()</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip09"/>Tip</h3><p>In <a id="id97" class="indexterm"/>Kivy language, we have several context-sensitive references at our disposal. They are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">self</code>: This<a id="id98" class="indexterm"/> always refers to the current widget;</li><li class="listitem" style="list-style-type: disc"><code class="literal">root</code>: This <a id="id99" class="indexterm"/>is the outermost widget of a given scope;</li><li class="listitem" style="list-style-type: disc"><code class="literal">app</code>: This is<a id="id100" class="indexterm"/> the application class instance.</li></ul></div></div></div><p>As you can see, implementing event handling for buttons isn't hard at all. At this point, our app provides interaction with the stopwatch, allowing the user to start, stop, and reset it. For the purposes of this tutorial, we're done.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec17"/>Summary</h1></div></div></div><p>In this chapter, we built a functional Kivy app, ready to be deployed to, for example, Google Play or another app store for public use. This requires a bit of extra work and the process of packaging is platform-specific, but the hardest part—programming—is over.</p><p>With the Clock app, we managed to showcase many areas of the Kivy application's development cycle without making the code unnecessarily lengthy or convoluted. Keeping the code short and concise is a major feature of the framework because it allows us to experiment and iterate quickly. Being able to implement new bits of functionality with very little old code getting in the way is invaluable. Kivy surely lives up to its description as a library for rapid application development.</p><p>One general principle that we will encounter throughout the book (and Kivy development at large) is that neither our program nor Kivy exist in the void; we always have the whole platform at our disposal, consisting of a rich Python standard library, a lot of other libraries available from the Python <span class="emphasis"><em>cheese shop</em></span>—the <span class="strong"><strong>Python Package Index</strong></span> (<span class="strong"><strong>PyPI</strong></span>) located at <a class="ulink" href="http://pypi.python.org">http://pypi.python.org</a>—and elsewhere, and the underlying operating system services.</p><p>We can also retool many web-development-oriented assets easily, reusing fonts, colors, and shapes from CSS frameworks, such as Bootstrap. And by all means take a look at Google's <span class="emphasis"><em>Material design principles</em></span>—this isn't just a collection of design assets, but a complete field guide that allows us to achieve a consistent and good-looking UI without sacrificing the identity or "personality" of our application.</p><p>This is, of course, only the beginning. Many features that were briefly discussed in this chapter will be explored more in-depth later in this book.</p></div></body></html>