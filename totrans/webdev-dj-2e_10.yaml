- en: 10\. Advanced Django Admin and Customizations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10. 高级Django管理及自定义
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter introduces you to advanced customizations to the **Django Admin**
    site so that you can tailor the appearance of the Django Admin dashboard to make
    it blend with the rest of your web project. You will see how new features and
    capabilities can be added to your web project's Django admin interface to make
    it substantially more powerful and useful for your project's goals. These customizations
    are driven by the addition of custom templates that help modify the look and feel
    of existing pages. These custom templates also add new views that can help extend
    the default functionalities of the Admin dashboard. Completing this chapter will
    equip you with skills that not only let you customize the interface, but also
    the functionality of your project's Django-based admin page.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向您介绍了对**Django管理**站点的高级自定义，以便您可以根据您的Web项目定制Django管理仪表板的外观，使其与您的Web项目融为一体。您将了解如何将新功能和能力添加到您的Web项目的Django管理界面，使其在实现项目目标方面更加强大和有用。这些自定义是通过添加自定义模板来实现的，这些模板有助于修改现有页面的外观和感觉。这些自定义模板还添加了新的视图，可以帮助扩展管理仪表板的默认功能。完成本章学习后，您将掌握不仅可以让您自定义界面，还可以自定义基于Django的项目管理页面的功能。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Let's say we want to customize the front page of a large organization's admin
    site. We want to show the health of the different systems in the organization
    and see any high-priority alerts that are active. If this were an internal website
    built on top of Django, we would need to customize it. Adding these kinds of functionalities
    will require the developers in the IT team to customize the default admin panel
    and create their own custom `AdminSite` module, which will render a different
    index page in comparison to what is provided by the default admin site. Fortunately,
    Django makes these kinds of customizations easy.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要自定义一个大组织管理站点的首页。我们希望展示组织内不同系统的健康状况，并查看任何活跃的高优先级警报。如果这是一个基于Django构建的内部网站，我们就需要对其进行自定义。添加这些类型的功能将需要IT团队的开发者自定义默认管理面板并创建他们自己的自定义`AdminSite`模块，这将渲染与默认管理站点提供的不同的索引页面。幸运的是，Django使这些类型的自定义变得容易。
- en: In this chapter, we will look at how we can leverage Django's framework and
    its extensibility to customize Django's default admin interface (as shown in *Figure
    10.1*). We'll not just learn how to make the interface more personal; we will
    also learn how we can control the different aspects of the admin site to make
    Django load a custom admin site instead of the one that ships with the default
    framework. Such customization can come in handy when we want to introduce features
    into the admin site that are not present by default.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何利用Django框架及其可扩展性来自定义Django的默认管理界面（如图*10.1*所示）。我们不仅将学习如何使界面更加个性化；我们还将学习如何控制管理站点的不同方面，使Django加载自定义管理站点而不是默认框架提供的那一个。当我们需要在管理站点中引入默认情况下不存在的功能时，这种自定义会非常有用。
- en: '![Figure 10.1: Default Django administration panel interface'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.1：默认Django管理面板界面'
- en: '](img/B15509_10_01.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15509_10_01.jpg)'
- en: 'Figure 10.1: Default Django administration panel interface'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1：默认Django管理面板界面
- en: This chapter builds upon the skills we practiced in *Chapter 4*, *Introduction
    to Django Admin*. Just to recap, we learned how to use the Django admin site to
    take control of the administration and authorization for our Bookr app. We also
    learned how to register models to read and edit their contents and also to customize
    Django's admin interface using the `admin.site` properties. Now, let's expand
    our knowledge further by taking a look at how we can start customizing the admin
    site by utilizing Django's `AdminSite` module to add powerful new functionalities
    to the admin portal of our web application.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '本章基于我们在*第4章*，“Django管理简介”中练习的技能。为了回顾，我们学习了如何使用Django管理站点来控制我们的Bookr应用的管理和授权。我们还学习了如何注册模型以读取和编辑其内容，以及如何使用`admin.site`属性来自定义Django的管理界面。现在，让我们通过查看如何利用Django的`AdminSite`模块来开始自定义管理站点，并添加到我们的Web应用管理门户中的强大新功能，来进一步扩展我们的知识。 '
- en: Customizing the Admin Site
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义管理站点
- en: Django as a web framework provides a lot of customization options for building
    web applications. We will be using this same freedom provided by Django when we
    are working on building the admin application for our project.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Django 作为 Web 框架，为构建 Web 应用提供了大量的自定义选项。当我们构建项目管理员应用时，我们将使用 Django 提供的相同自由度。
- en: In *Chapter 4*, *Introduction to Django Admin*, we looked at how we can use
    the `admin.site` properties to customize the elements of our Django's admin interface.
    But what if we require more control over how our admin site behaves? For example,
    let's say we wanted to use a custom template for the login page (or the logout
    page) to show to users whenever they visited the Bookr admin panel. In this case,
    the `admin.site` properties provided might not be enough, and we will need to
    build customizations that can extend the default admin site's behavior. Luckily,
    this can be easily achieved by extending the `AdminSite` class from Django's admin
    model. But before we jump into building our admin site, let's first understand
    how Django discovers admin files and how we can use this admin file discovery
    mechanism to build a new app inside Django that will act as our admin site app.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第 4 章*，*Django 管理员介绍* 中，我们探讨了如何使用 `admin.site` 属性来自定义 Django 管理界面的元素。但如果我们需要更多控制管理员站点的行为呢？例如，假设我们想要为登录页面（或注销页面）使用自定义模板，以便用户访问
    Bookr 管理面板时显示。在这种情况下，`admin.site` 提供的属性可能不够用，我们需要构建可以扩展默认管理员站点行为的自定义功能。幸运的是，通过扩展
    Django 管理模型中的 `AdminSite` 类，我们可以轻松实现这一点。但在我们开始构建管理员站点之前，让我们首先了解 Django 如何发现管理员文件以及我们如何利用这个管理员文件发现机制在
    Django 中构建一个新应用，该应用将作为我们的管理员站点应用。
- en: Discovering Admin Files in Django
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Django 中发现管理员文件
- en: 'When we build applications in our Django project, we use the `admin.py` file
    frequently to register our models or create `ModelAdmin` classes that customize
    our interactions with the models inside the admin interface. These `admin.py`
    files store and provide this information to our project''s admin interface. The
    discovery of these files is affected automatically by Django once we add `django.contrib.admin`
    to our `INSTALLED_APPS` section inside our `settings.py` file:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在 Django 项目中构建应用时，我们经常使用 `admin.py` 文件来注册我们的模型或创建自定义 `ModelAdmin` 类，以便在管理员界面中与模型进行交互。这些
    `admin.py` 文件存储并提供这些信息给我们的项目管理员界面。当我们把 `django.contrib.admin` 添加到 `settings.py`
    文件中的 `INSTALLED_APPS` 部分时，Django 会自动发现这些文件：
- en: '![Figure 10.2: Bookr application structure'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.2：Bookr 应用结构'
- en: '](img/B15509_10_02.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15509_10_02.jpg)'
- en: 'Figure 10.2: Bookr application structure'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.2：Bookr 应用结构
- en: As we can see in the preceding figure, we have an `admin.py` file under the
    `reviews` application directory that is used by Django to customize the admin
    site for Bookr.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，我们在 `reviews` 应用目录下有一个 `admin.py` 文件，Django 使用它来自定义 Bookr 的管理员站点。
- en: When the admin application gets added, it tries to find the `admin` module inside
    every app of the Django project we are working on and, if a module is found, it
    loads the contents from that module.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当管理员应用被添加时，它会尝试在我们正在工作的 Django 项目的每个应用中寻找 `admin` 模块，如果找到一个模块，它就会从该模块加载内容。
- en: Django's AdminSite Class
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Django 的 AdminSite 类
- en: Before we start customizing Django's admin site, we must understand how the
    default admin site is generated and handled by Django.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始自定义 Django 的管理员站点之前，我们必须了解默认管理员站点是如何由 Django 生成和处理的。
- en: To provide us with the default admin site, Django packages a module known as
    the `admin` module, which holds a class known as `AdminSite`. This class implements
    a lot of useful functionalities and intelligent defaults that the Django community
    thinks will be important for implementing a useful administration panel for most
    Django websites. The default `AdminSite` class provides a lot of inbuilt properties
    that not only control the look and feel of how the default admin site is rendered
    in the web browser, but also control the way we can interact with it and how a
    particular interaction will result in an action. Some of these defaults include
    the site template properties, such as text to be shown in the site header, text
    to show in the title bar of the web browser, integration with Django's `auth`
    module for authenticating to the admin site, and a host of other properties.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为我们提供默认的管理站点，Django打包了一个名为`admin`的模块，该模块包含一个名为`AdminSite`的类。这个类实现了很多有用的功能和一些智能默认设置，Django社区认为这些对于实现大多数Django网站的有用管理面板非常重要。默认的`AdminSite`类提供了很多内置属性，不仅控制了默认管理站点在浏览器中的外观和感觉，还控制了我们与之交互的方式以及特定交互将导致哪些操作。其中一些默认设置包括站点模板属性，如显示在站点标题中的文本、显示在浏览器标题栏中的文本、与Django的`auth`模块集成以验证管理站点，以及一系列其他属性。
- en: As we progress on our path to building a custom admin site for our Django web
    project, it is more than desirable to retain a lot of the useful functionalities
    that are already built into Django's `AdminSite` class. This is where the concepts
    of Python object-oriented programming come to our rescue.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们构建自定义Django网络项目的管理站点的道路上不断前进时，保留Django的`AdminSite`类中已经构建的许多有用功能是非常理想的。这正是Python面向对象编程概念帮助我们的时候。
- en: 'As we start to create our custom admin site, we will try to leverage the existing
    useful set of functionalities that are provided by Django''s default `AdminSite`
    class. For this, instead of building everything from scratch, we will work on
    creating a new child class that inherits from Django''s `AdminSite` class to leverage
    the existing set of functionalities and useful integration that Django already
    provides us with. This kind of approach allows us to focus on adding a new and
    useful set of functionalities to our custom admin site, rather than spending time
    on implementing the basic set of functionalities from scratch. For example, the
    following code snippet shows how we can create a child class of Django''s `AdminSite`
    class:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始创建自定义管理站点时，我们将尝试利用Django默认的`AdminSite`类提供的现有有用功能集。为此，我们不会从头开始构建一切，而是将致力于创建一个新的子类，该子类继承自Django的`AdminSite`类，以利用Django已经为我们提供的现有功能集和有用集成。这种方法的优点是，我们可以专注于向我们的自定义管理站点添加新的和有用的功能集，而不是花费时间从头实现基本功能集。例如，以下代码片段展示了我们如何创建Django的`AdminSite`类的子类：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To start working on our custom admin site for our web application, let's start
    by overriding some of the basic properties of Django's admin panel through the
    use of the custom `AdminSite` class we are going to work on.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始为我们网络应用构建自定义管理站点，让我们首先通过使用我们将要工作的自定义`AdminSite`类来覆盖Django管理面板的一些基本属性。
- en: Some of the properties that can be overridden include `site_header`, `site_title`,
    and others.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 可以覆盖的一些属性包括`site_header`、`site_title`等。
- en: Note
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When creating a custom admin site, we will have to register once again any `Model`
    and `ModelAdmin` classes that we might have registered using the default `admin.site`
    variable earlier. This happens because a custom admin site doesn't inherit the
    instance details from the default admin site provided by Django and so unless
    we re-register our `Model` and `ModelAdmin` interfaces, our custom admin site
    will not show them.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建一个自定义管理站点时，我们必须再次注册任何之前使用默认的`admin.site`变量注册的`Model`和`ModelAdmin`类。这是因为自定义管理站点不会从Django提供的默认管理站点继承实例详情，除非我们重新注册我们的`Model`和`ModelAdmin`接口，否则我们的自定义管理站点将不会显示它们。
- en: Now, with the knowledge of how Django discovers what to load into the admin
    interface and how we can start building our custom admin site, let's go ahead
    and try to create our custom admin app for Bookr, which extends the existing `admin`
    module provided by Django. In the exercise that follows, we are going to create
    a custom admin site interface for our Bookr application using Django's `AdminSite`
    class.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，了解了Django如何发现加载到管理界面中的内容以及我们如何开始构建自定义管理站点后，让我们继续尝试为Bookr创建自定义管理应用程序，该应用程序扩展了Django提供的现有`admin`模块。在接下来的练习中，我们将使用Django的`AdminSite`类为Bookr应用程序创建自定义管理站点界面。
- en: 'Exercise 10.01: Creating a Custom Admin Site for Bookr'
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习10.01：为Bookr创建自定义管理站点
- en: 'In this exercise, you will create a new application that extends the default
    Django admin site and allows you to customize the components of the interface.
    Consequently, you will customize the default title of Django''s admin panel. Once
    that is done, you will override the default value of Django''s `admin.site` property
    to point to your custom admin site:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将创建一个新的应用程序，该应用程序扩展了默认的Django管理站点，并允许您自定义界面的组件。因此，您将自定义Django管理面板的默认标题。完成此操作后，您将覆盖Django的`admin.site`属性的默认值，将其指向您自定义的管理站点：
- en: 'Before you can start working on your custom admin site, you first need to make
    sure that you are in the correct directory in your project from where you can
    run your Django application''s management commands. For this, use the Terminal
    or Windows Command Prompt to navigate to the `bookr` directory and then create
    a new application named `bookr_admin`, which is going to act as the admin site
    for Bookr, by running the following commands:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您开始工作于自定义管理站点之前，首先需要确保您位于项目中可以运行Django应用程序管理命令的正确目录。为此，使用终端或Windows命令提示符导航到`bookr`目录，然后运行以下命令创建一个名为`bookr_admin`的新应用程序，该应用程序将作为Bookr的管理站点：
- en: '[PRE1]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Once this command is executed successfully, you should have a new directory
    named `bookr_admin` inside your project.
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦这个命令成功执行，您应该在项目中有一个名为`bookr_admin`的新目录。
- en: 'Now, with the default structure configured, the next step is to create a new
    class named `BookrAdmin`, which will extend the `AdminSite` class provided by
    Django to inherit the properties of the default admin site. To do this, open the
    `admin.py` file under the `bookr_admin` directory inside PyCharm. Once the file
    is open, you will see that the file already has the following code snippet present
    inside it:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，默认结构配置完成后，下一步是创建一个名为`BookrAdmin`的新类，该类将扩展Django提供的`AdminSite`类以继承默认管理站点的属性。为此，打开PyCharm中`bookr_admin`目录下的`admin.py`文件。一旦文件打开，您将看到文件中已经存在以下代码片段：
- en: '[PRE2]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, keeping this `import` statement as is, starting from the next line, create
    a new class named `BookrAdmin`, which inherits from the `AdminSite` class provided
    by the `admin` module you imported earlier:'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，保持这个`import`语句不变，从下一行开始，创建一个名为`BookrAdmin`的新类，该类继承自您之前导入的`admin`模块提供的`AdminSite`类：
- en: '[PRE3]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Inside this new `BookrAdmin` class, override the default value for the `site_header`
    variable, which is responsible for rendering the site header in Django''s admin
    panel by setting the `site_header` property, as shown next:'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个新的`BookrAdmin`类内部，覆盖`site_header`变量的默认值，该变量负责在Django管理面板中渲染站点标题，通过设置`site_header`属性，如下所示：
- en: '[PRE4]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'With this, the custom admin site class is now defined. To use this class, you
    will first create an instance of this class. This can be done as follows:'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过这样，自定义管理站点类现在已经定义好了。要使用这个类，您首先需要创建这个类的实例。这可以通过以下方式完成：
- en: '[PRE5]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Save the file but don't close it yet; we'll revisit it in *step 6*. Next, let's
    edit the `urls.py` file in the `bookr` app.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件，但不要关闭它；我们将在第6步中再次访问它。接下来，让我们编辑`bookr`应用中的`urls.py`文件。
- en: 'With the custom class now defined, the next step is to modify the `urlpatterns`
    list to map the `/admin` endpoint in our project to the new `AdminSite` class
    you created. To do this, open the `urls.py` file under the `Bookr` project directory
    inside PyCharm and change the mapping of the `/admin` endpoint to point to our
    custom site:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在自定义类已经定义好了，下一步是修改`urlpatterns`列表，将我们项目中`/admin`端点映射到您创建的新`AdminSite`类。为此，打开PyCharm中`Bookr`项目目录下的`urls.py`文件，并将`/admin`端点的映射更改为指向我们的自定义站点：
- en: '[PRE6]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: path('admin/', admin_site.urls)
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`path(''admin/'', admin_site.urls)`'
- en: '[PRE7]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, with the configuration done, let''s run our admin app in the browser.
    For this, run the following command from the root of your project directory where
    the `manage.py` file is located:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，配置完成后，让我们在浏览器中运行我们的管理应用。为此，从包含 `manage.py` 文件的项目的根目录运行以下命令：
- en: '[PRE8]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, navigate to `http://localhost:8000/admin` (or `http://127.0.0.1:8000/admin`),
    which opens a page that resembles the following screenshot:'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，导航到 `http://localhost:8000/admin`（或 `http://127.0.0.1:8000/admin`），这将打开一个类似于以下截图的页面：
- en: '![Figure 10.3: Home page view for the custom Bookr admin site'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 10.3：自定义 Bookr 管理站点的首页视图'
- en: '](img/B15509_10_03.jpg)'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B15509_10_03.jpg)'
- en: 'Figure 10.3: Home page view for the custom Bookr admin site'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 10.3：自定义 Bookr 管理站点的首页视图
- en: In the preceding screenshot (*Figure 10.3*), you will see that Django displays
    the message, `You don't have permission to view or edit anything`. The issue of
    not having adequate permissions happens because, up till now, we have not registered
    any models with our custom `AdminSite` instance. The issue also applies to the
    `User and Groups` models that are shipped along with the Django `auth` module.
    So, let's make our custom admin site a bit more useful by registering the `User`
    model from Django's `auth` module.
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的截图（*图 10.3*）中，你会看到 Django 显示消息，“你没有权限查看或编辑任何内容”。没有足够权限的问题发生是因为，到目前为止，我们还没有将任何模型注册到我们的自定义
    `AdminSite` 实例中。这个问题也适用于与 Django `auth` 模块一起提供的 `User 和 Groups` 模型。因此，让我们通过从 Django
    的 `auth` 模块注册 `User` 模型，使我们的自定义管理站点更有用。
- en: 'To register the `User` model from Django''s `auth` module, open the `admin.py`
    file under the `bookr_admin` directory inside PyCharm, and add the following line
    at the top of the file:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要从 Django 的 `auth` 模块注册 `User` 模型，打开 PyCharm 中 `bookr_admin` 目录下的 `admin.py`
    文件，并在文件顶部添加以下行：
- en: '[PRE9]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'At the end of the file, use your `BookrAdmin` instance to register this model
    as follows:'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在文件末尾，使用您的 `BookrAdmin` 实例按以下方式注册此模型：
- en: '[PRE10]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'By now, your `admin.py` file should look like this:'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 到目前为止，您的 `admin.py` 文件应该看起来像这样：
- en: '[PRE11]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Once this is done, reload the web server and visit `http://localhost:8000/admin`.
    Now, you should be able to see the `User` model being displayed for editing inside
    the admin interface, as shown here:'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完成此操作后，重新加载网络服务器并访问 `http://localhost:8000/admin`。现在，你应该能够在管理界面中看到用于编辑的 `User`
    模型，如图所示：
- en: '![Figure 10.4: Home page view showing our registered models'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 10.4：显示我们在 Bookr 管理站点注册的模型的首页视图'
- en: on the Bookr Administration site
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 Bookr 管理站点
- en: '](img/B15509_10_04.jpg)'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B15509_10_04.jpg)'
- en: 'Figure 10.4: Home page view showing our registered models on the Bookr Administration
    site'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.4：显示我们在 Bookr 管理站点注册的模型的首页视图
- en: With this, we just created our admin site application, and we can also now validate
    the fact that the custom site has a different header—`Bookr Administration`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们刚刚创建了我们的管理站点应用，现在我们也可以验证自定义站点有一个不同的标题——“Bookr 管理”。
- en: Overriding the Default admin.site
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 覆盖默认的 admin.site
- en: In the previous section, after we created our own `AdminSite` application, we
    saw that we had to register models manually. This happens because most of the
    apps that we have built prior to our custom admin site still use the `admin.site`
    property to register their models and, if we want to use our `AdminSite` instance,
    we will have to update all those applications to use our instance, which can become
    cumbersome if there are a lot of applications inside a project.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，在我们创建自己的 `AdminSite` 应用程序之后，我们看到了我们必须手动注册模型。这是因为我们之前构建的大多数应用程序仍然使用 `admin.site`
    属性来注册它们的模型，如果我们想使用我们的 `AdminSite` 实例，我们必须更新所有这些应用程序以使用我们的实例，如果项目中有许多应用程序，这可能会变得很繁琐。
- en: Luckily, we can avoid this additional burden by overriding the default `admin.site`
    property. To do this, we first have to create a new `AdminConfig` class, which
    will override the default `admin.site` property for us, so that our application
    is marked as the default admin site and hence overrides the `admin.site` property
    inside our project. In the next exercise, we'll look at how we can map our custom
    admin site as a default admin site for an application.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们可以通过覆盖默认的 `admin.site` 属性来避免这个额外的负担。为此，我们首先必须创建一个新的 `AdminConfig` 类，它将为我们覆盖默认的
    `admin.site` 属性，使我们的应用程序被标记为默认管理站点，从而覆盖我们项目中的 `admin.site` 属性。在下一个练习中，我们将探讨如何将我们的自定义管理站点映射为应用程序的默认管理站点。
- en: 'Exercise 10.02: Overriding the Default Admin Site'
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 10.02：覆盖默认 Admin Site
- en: 'In this exercise, you will use the `AdminConfig` class to override the default
    admin site for your project such that you can keep on using the default `admin.site`
    variable to register models, override site properties, and more:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将使用 `AdminConfig` 类来覆盖您项目的默认管理站点，这样您就可以继续使用默认的 `admin.site` 变量来注册模型、覆盖站点属性等：
- en: 'Open the `admin.py` file under the `bookr_admin` directory and remove the import
    for the `User` model and the `BookrAdmin` instance creation, which you wrote in
    *step 6* of *Exercise 10.01*, *Creating a Custom Admin Site for Bookr*. Once this
    is done, the file contents should resemble the following:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `bookr_admin` 目录下的 `admin.py` 文件，并移除对 `User` 模型的导入以及 `BookrAdmin` 实例创建，这些是在
    *练习 10.01* 的 *步骤 6* 中编写的。完成此操作后，文件内容应类似于以下内容：
- en: '[PRE12]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You will then need to create an `AdminConfig` class for the custom admin site,
    such that Django recognizes the `BookrAdmin` class as an `AdminSite` and overrides
    the `admin.site` property. To do this, open up the `apps.py` file inside the `bookr_admin`
    directory and overwrite the contents of the file with the contents shown here:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您需要为自定义管理站点创建一个 `AdminConfig` 类，以便 Django 识别 `BookrAdmin` 类作为 `AdminSite` 并覆盖
    `admin.site` 属性。为此，打开 `bookr_admin` 目录中的 `apps.py` 文件，并用以下内容覆盖文件内容：
- en: '[PRE13]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this, we first imported the `AdminConfig` class from Django's `admin` module.
    This class is used to define the application that should be used as a default
    admin site, and also to override the default behavior of the Django admin site.
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在此，我们首先从 Django 的 `admin` 模块中导入了 `AdminConfig` 类。此类用于定义应用作默认管理站点的应用程序，并覆盖 Django
    管理站点的默认行为。
- en: 'For our use case, we created a class with the name `BookrAdminConfig`, which
    acts as a child class of Django''s `AdminConfig` class and overrides the `default_site`
    property to point to our `BookrAdmin` class, which is our custom admin site:'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于我们的用例，我们创建了一个名为 `BookrAdminConfig` 的类，它作为 Django 的 `AdminConfig` 类的子类，并覆盖了
    `default_site` 属性，将其指向我们的 `BookrAdmin` 类，即我们的自定义管理站点：
- en: '[PRE14]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Once this is done, we need to set our application as an admin application inside
    our `Bookr` project. To achieve this, open the `settings.py` file of the `Bookr`
    project and, under the `INSTALLED_APPS` section, replace `''reviews.apps.ReviewsAdminConfig''`
    with `''bookr_admin.apps.BookrAdminConfig''`. The `settings.py` file should look
    like this: [http://packt.live/3siv1lf](http://packt.live/3siv1lf).'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完成此操作后，我们需要在我们的 `Bookr` 项目中将我们的应用程序设置为管理应用程序。为此，打开 `Bookr` 项目的 `settings.py`
    文件，并在 `INSTALLED_APPS` 部分下，将 `'reviews.apps.ReviewsAdminConfig'` 替换为 `'bookr_admin.apps.BookrAdminConfig'`。`settings.py`
    文件应如下所示：[http://packt.live/3siv1lf](http://packt.live/3siv1lf)。
- en: 'With the application mapped as the admin application, the final step involves
    modifying the URL mapping such that the `''admin/''` endpoint uses the `admin.site`
    property to find the correct URL. For this, open the `urls.py` file under the
    bookr project. Consider the following entry in the `urlpatterns` list:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将应用程序映射为管理应用程序后，最后一步是修改 URL 映射，以便 `'admin/'` 端点使用 `admin.site` 属性来找到正确的 URL。为此，打开
    bookr 项目下的 `urls.py` 文件。考虑 `urlpatterns` 列表中的以下条目：
- en: '[PRE15]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Figure 10.5: Home page view of the custom Bookr Administration site'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.5：自定义 Bookr 管理站点的首页视图
- en: As you can see, once we override `admin.site` with our admin app, the models
    that were registered earlier using the `admin.site.register` property start to
    show up automatically.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，一旦我们用我们的管理应用覆盖了 `admin.site`，之前使用 `admin.site.register` 属性注册的模型就会自动显示出来。
- en: With this, we now have a custom base template, which we can now utilize to build
    the remainder of our Django admin customizations on. As we work through the chapter,
    we will discover some interesting customizations that allow us to make the admin
    dashboard an integrated part of our application.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们现在有一个自定义的基本模板，我们可以利用它来构建我们 Django 管理自定义的其余部分。随着我们通过本章的学习，我们将发现一些有趣的定制，使我们能够将管理仪表板集成到我们的应用程序中。
- en: Customizing Admin Site Text Using AdminSite Attributes
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 AdminSite 属性自定义管理站点文本
- en: 'Just as we can use the `admin.site` properties to customize the text for our
    Django application, we can also use the attributes exposed by the `AdminSite`
    class to customize these texts. In *Exercise 10.02*, *Overriding the Default Admin
    Site*, we took a look at updating the `site_header` property of the admin site.
    Similarly, there are many other properties we can modify. Some of the properties
    that can be overridden are described as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们可以使用`admin.site`属性来自定义Django应用程序的文本一样，我们也可以使用`AdminSite`类公开的属性来自定义这些文本。在*练习10.02*，*覆盖默认管理网站*中，我们查看更新了管理网站的`site_header`属性。同样，还有许多其他属性我们可以修改。以下是一些可以覆盖的属性描述如下：
- en: '`site_header`: Text to display at the top of every admin page (defaults to
    `Django Administration`).'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`site_header`: 在每个管理页面的顶部显示的文本（默认为`Django管理`）。'
- en: '`site_title`: Text to display in the title bar of the browser (defaults to
    `Django Admin Site`).'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`site_title`: 在浏览器标题栏中显示的文本（默认为`Django管理网站`）。'
- en: '`site_url`: The link to use for the `View Site` option (defaults to `/`). This
    is overridden when the site is running on a custom path and the redirection should
    take the user to the subpath directly.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`site_url`: 用于“查看网站”选项的链接（默认为`/`）。当网站在自定义路径上运行时，此设置会被覆盖，并且重定向应将用户直接带到子路径。'
- en: '`index_title`: This is the text that should be shown on the index page of the
    admin application (defaults to `Site administration`).'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index_title`: 这是应该在管理应用程序的索引页上显示的文本（默认为`站点管理`）。'
- en: Note
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on all the `adminsite` attributes, refer to the official
    Django documentation at [https://docs.djangoproject.com/en/3.1/ref/contrib/admin/#adminsite-attributes](https://docs.djangoproject.com/en/3.1/ref/contrib/admin/#adminsite-attributes).
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 关于所有`adminsite`属性的更多信息，请参阅官方Django文档[https://docs.djangoproject.com/en/3.1/ref/contrib/admin/#adminsite-attributes](https://docs.djangoproject.com/en/3.1/ref/contrib/admin/#adminsite-attributes)。
- en: 'If we want to override these attributes in our custom admin site, the process
    is very simple:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在自定义管理网站上覆盖这些属性，过程非常简单：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As we have seen in the examples so far, we have created a custom admin application
    for Bookr and then made it the default admin site for our project. An interesting
    question arises here. Since the properties that we have customized so far can
    also be customized by using the `admin.site` object directly, why should we create
    a custom admin application? Can't we just modify the `admin.site` properties?
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们迄今为止所看到的示例，我们已经为Bookr创建了一个自定义管理应用，并将其设置为项目的默认管理网站。这里出现了一个有趣的问题。由于我们迄今为止所自定义的属性也可以通过直接使用`admin.site`对象来自定义，为什么我们要创建一个自定义管理应用？我们难道不能直接修改`admin.site`的属性吗？
- en: 'As it turns out, there could be multiple reasons why someone would opt for
    a custom admin site; for example, they might want to change the layout of the
    default admin site to make it align with the overall layout of their application.
    This is quite common when creating a web application for a business where the
    homogeneity of the content is very important. Here is a short list of requirements
    that may compel a developer to go ahead and build a custom admin site as opposed
    to simply modifying the properties of the `admin.site` variable:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，有人选择自定义管理网站可能有多个原因；例如，他们可能想要更改默认管理网站的布局，以使其与应用程序的整体布局保持一致。这在创建一个对内容同质性要求很高的企业级Web应用时非常常见。以下是一个简短的列表，这些要求可能会促使开发者去构建一个自定义管理网站，而不是仅仅修改`admin.site`变量的属性：
- en: A need to override the index template for the admin interface
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要覆盖管理界面的索引模板
- en: A need to override the login or logout template
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要覆盖登录或注销模板
- en: A need to add a custom view to the admin interface
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要在管理界面中添加自定义视图
- en: Customizing Admin Site Templates
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义管理网站模板
- en: Just like some of the customizable common texts, such as `site_header` and `site_title`,
    that appear across the admin site, Django also allows us to customize the templates,
    which are used to render different pages inside the admin site by setting certain
    properties in the `AdminSite` class.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 就像一些可定制的通用文本，例如出现在管理网站上的`site_header`和`site_title`，Django 也允许我们通过在`AdminSite`类中设置某些属性来自定义模板，这些模板用于在管理网站内部渲染不同的页面。
- en: 'These customizations can include the modification of templates that are used
    to render the index page, login page, model data page, and more. These customizations
    can be easily done by leveraging the templating system provided by Django. For
    example, the following code snippet shows how we can add a new template to the
    Django admin dashboard:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这些自定义可以包括修改用于渲染索引页面、登录页面、模型数据页面等模板。这些自定义可以通过利用Django提供的模板系统轻松完成。例如，以下代码片段展示了我们如何向Django管理员仪表板添加一个新的模板：
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this custom template, there are a couple of important aspects that we need
    to understand.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个自定义模板中，有几个重要的方面我们需要理解。
- en: When customizing the existing Django admin dashboard by modifying how certain
    pages inside the dashboard appear or by adding a new set of pages to the dashboard,
    we might not want to write every single piece of HTML again from scratch to maintain
    the basic look and feel of the Django admin dashboard.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过修改仪表板内某些页面的外观或向仪表板添加一组新页面来自定义现有的Django管理员仪表板时，我们可能不想从头开始重新编写每个HTML片段以保持Django管理员仪表板的基本外观和感觉。
- en: Usually, while customizing the admin dashboard, we want to retain the layout
    in which Django organizes the different elements displayed on the dashboard such
    that we can focus on modifying parts of the page that matter to us. This basic
    layout of the page, along with the common page elements, such as the page header
    and page footer, are defined inside the Django admin's base template, which also
    acts as a master template for all the pages inside the default Django admin website.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在自定义管理员仪表板时，我们希望保留Django组织仪表板上显示的不同元素的布局，这样我们就可以专注于修改对我们重要的页面部分。这个页面的基本布局，以及常见的页面元素，如页面标题和页面页脚，都在Django管理员的基模板中定义，该模板还充当默认Django管理员网站内所有页面的主模板。
- en: 'To retain the way the common elements inside the Django admin pages are organized
    and rendered, we need to extend from this base template such that our custom template
    pages provide a user experience consistent with the other pages inside the Django
    admin dashboard. This can be done by using the template extension tags and extending
    the `base_site.html` template from the `admin` module provided by Django:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保留Django管理员页面内常见元素的组织和渲染方式，我们需要从这个基模板扩展，使得我们的自定义模板页面提供与Django管理员仪表板内其他页面一致的用户体验。这可以通过使用模板扩展标签并从Django提供的`admin`模块扩展`base_site.html`模板来完成：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Once this is done, the next part is to define our own content for the custom
    template. The `base_site.html` template provided by Django provides a block-based
    placeholder for developers to add their own content to the template. To add this
    content, a developer has to put the logic for their own custom elements for the
    page inside the `{% block content %}` tags. This essentially overrides any content
    defined by the `{% block content %}` tag inside the `base_site.html` template,
    following the concepts of template inheritance in Django.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作后，下一步是定义我们自己的自定义模板内容。Django提供的`base_site.html`模板提供了一个基于块的占位符，供开发者为模板添加自己的内容。要添加此内容，开发人员必须在`{%
    block content %}`标签内放置他们自己的页面自定义元素逻辑。这本质上覆盖了`base_site.html`模板内定义的任何`{% block
    content %}`标签内容，遵循Django模板继承的概念。
- en: Now, let's look at how we can customize the template, which is used to render
    the logout page, once the user clicks the Logout button in the admin panel.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们如何自定义用于渲染注销页面的模板，一旦用户在管理员面板中点击“注销”按钮。
- en: 'Exercise 10.03: Customizing the Logout Template for the Bookr Admin Site'
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习10.03：为Bookr管理员网站自定义注销模板
- en: In this exercise, you are going to customize the template that is used to render
    the logout page once the user clicks the `Logout` button on the admin site. Such
    overrides can come in handy in banking websites. Once a user clicks `Logout`,
    the bank might want to show the user a page with detailed instructions on how
    to make sure that their banking session is securely closed.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将自定义一个模板，该模板用于在用户点击管理员网站上的“注销”按钮后渲染注销页面。这种覆盖在银行网站上可能会很有用。一旦用户点击“注销”，银行可能希望向用户展示一个页面，其中包含有关如何确保其银行会话安全关闭的详细说明。
- en: Under the `templates` directory which you must have created in the earlier chapters,
    create another directory named `admin` which will be used for storing templates
    for your custom admin site.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你之前章节中必须创建的“templates”目录下，创建另一个名为“admin”的目录，该目录将用于存储你自定义管理员网站的模板。
- en: Note
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Before proceeding, make sure that the templates directory is added to the `DIRS`
    list in your `settings.py` file (under the `bookr/ project`).
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在继续之前，请确保将模板目录添加到你的`settings.py`文件中的`DIRS`列表（在`bookr/项目`下）。
- en: 'Now, with the directory structure setup complete, and Django configured to
    load the templates, the next step involves writing your custom logout template
    that you want to render. For this, let''s create a new file named `logout.html`
    under the `templates/admin` directory we created in *step 1* and add the following
    content to it:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，随着目录结构设置完成，并且Django配置为加载模板，下一步涉及编写你想要渲染的自定义注销模板。为此，让我们在*步骤1*中创建的`templates/admin`目录下创建一个名为`logout.html`的新文件，并将以下内容添加到其中：
- en: '[PRE19]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the preceding code snippet, we are doing a couple of things. First, for
    our custom logout template, we are going to use the same master layout as provided
    by the `django.contrib.admin` module. So, consider the following:'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们做了几件事情。首先，对于我们的自定义注销模板，我们将使用由`django.contrib.admin`模块提供的相同主布局。所以，考虑以下内容：
- en: '[PRE20]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: When we write this, Django tries to find and load the `admin/base_site.html`
    template inside the `templates` directory provided by the `django.contrib.admin`
    module.
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们编写这段代码时，Django会尝试在由`django.contrib.admin`模块提供的`templates`目录中查找并加载`admin/base_site.html`模板。
- en: 'Now, with our base template all set to be extended, the next thing we do is
    try to override the HTML of the content block by executing the following command:'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，随着我们的基础模板设置完毕，接下来我们要尝试通过执行以下命令来覆盖内容块的HTML：
- en: '[PRE21]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The values of `admin:index` and `site_url` are provided by the `AdminSite` class
    automatically, based on the settings we define.
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`admin:index`和`site_url`的值由`AdminSite`类自动提供，基于我们定义的设置。'
- en: 'Using the value for `admin:index` and `site_url`, we create our `Login Again`
    hyperlink, which, when clicked, will take the user back to the login form, and
    the `Go` `to` `Home` `Page` link, which will take the user back to the home page
    of the website. The file should look like this now: [http://packt.live/3oIGQPo](http://packt.live/3oIGQPo).'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用`admin:index`和`site_url`的值，我们创建了一个名为“再次登录”的超链接，当点击时，将用户带回到登录表单，以及一个“返回”主页的链接，这将带用户回到网站的主页。文件现在应该看起来像这样：[http://packt.live/3oIGQPo](http://packt.live/3oIGQPo)。
- en: 'Now, with the custom template defined, the next step is to make use of this
    custom template in our custom admin site. To do this, let''s open the `admin.py`
    file under the `bookr_admin` directory and add the following field as the final
    value in the `BookrAdmin` class:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，自定义模板已经定义好了，下一步就是在我们自定义的admin站点中使用这个自定义模板。为此，让我们打开位于`bookr_admin`目录下的`admin.py`文件，并将以下字段添加为`BookrAdmin`类的最后一个值：
- en: '[PRE22]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Save the file. It should look like this: [http://packt.live/3oHHsVz](http://packt.live/3oHHsVz).'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 保存文件。它应该看起来像这样：[http://packt.live/3oHHsVz](http://packt.live/3oHHsVz)。
- en: 'Once all the preceding steps are complete, let''s start our development server
    by running the following command:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦所有前面的步骤都完成，让我们通过运行以下命令来启动我们的开发服务器：
- en: '[PRE23]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Then, we navigate to `http://localhost:8000/admin`.
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，我们导航到`http://localhost:8000/admin`。
- en: 'Once you are there, try to do a login and then click `Logout`. Once you are
    logged out, you will see the following page rendered:'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦你到了那里，尝试登录然后点击“注销”。一旦你注销，你会看到以下页面呈现：
- en: '![Figure 10.6: Logout view rendered to users after clicking the Logout button'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图10.6：点击注销按钮后向用户呈现的注销视图]'
- en: '](img/B15509_10_06.jpg)'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B15509_10_06.jpg)'
- en: 'Figure 10.6: Logout view rendered to users after clicking the Logout button'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6：点击注销按钮后向用户呈现的注销视图
- en: With this, we have successfully overridden our first template. Similarly, we
    can also override other templates inside Django's admin panel, such as the templates
    for the index view and the login form.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们已经成功覆盖了我们的第一个模板。同样，我们也可以覆盖Django admin面板中的其他模板，例如索引视图和登录表单的模板。
- en: Adding Views to the Admin Site
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向Admin站点添加视图
- en: Just like general applications inside Django, which can have multiple views
    associated with them, Django allows developers to add custom views to the admin
    site as well. This allows the developer to increase the scope of what the admin
    site interface can do.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 就像Django内部的一般应用程序可以有多个与之关联的视图一样，Django允许开发者向admin站点添加自定义视图。这允许开发者扩展admin站点界面的功能范围。
- en: The ability to add your own views to the admin site provides a lot of extensibility
    to the admin panel of the website, which can be leveraged for several additional
    use cases. For example, as we discussed at the start of the chapter, an IT team
    of a big organization can add a custom view to the admin site, which can then
    be used to both monitor the health of the different IT systems in the organization
    and to provide the IT team with the ability to quickly look at any urgent alerts
    that need to be addressed.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 将自己的观点添加到管理站点的能力为网站的行政面板提供了很多可扩展性，这可以用于几个额外的用例。例如，正如我们在本章开头所讨论的，一个大组织的IT团队可以向管理站点添加一个自定义视图，然后可以使用它来监控组织内不同IT系统的健康状况，并为IT团队提供快速查看任何需要解决的紧急警报的能力。
- en: 'Now, the next question we need to answer is: *How can we add a custom view
    to the admin site?*'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要回答的下一个问题是：*我们如何向管理站点添加一个自定义视图？*
- en: As it turns out, adding a new view inside the admin template is quite easy and
    follows the same approach we used while creating views for our applications, though
    with some minor modifications. In the next section, we will look at how we can
    add a new view to our Django admin dashboard.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在管理模板中添加新视图相当简单，遵循了我们创建应用程序视图时使用的方法，尽管有一些小的修改。在下一节中，我们将探讨如何将新视图添加到我们的Django管理仪表板。
- en: Creating the View Function
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建视图函数
- en: The first step to adding a new view to the Django application is to create a
    view function that implements the logic to handle the view. In the previous chapters,
    we created the view functions inside a separate file known as `views.py`, which
    was used to hold all our method- and class-based views.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 向Django应用程序添加新视图的第一步是创建一个视图函数，该函数实现了处理视图的逻辑。在前面的章节中，我们在一个名为`views.py`的单独文件中创建了视图函数，该文件用于存放我们所有的基于方法和类的视图。
- en: 'When it comes to adding a new view to the Django admin dashboard, to create
    a new view, we need to define a new view function inside our custom `AdminSite`
    class. For example, to add a new view that renders a page showing the health of
    the different IT systems inside the organization, we can create a new view function
    named `system_health_dashboard()` inside our custom `AdminSite` class implementation,
    as shown in the following code snippet:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到向Django管理仪表板添加新视图时，为了创建新视图，我们需要在我们的自定义`AdminSite`类中定义一个新的视图函数。例如，为了添加一个渲染组织内不同IT系统健康状况的页面的新视图，我们可以在自定义`AdminSite`类实现中创建一个名为`system_health_dashboard()`的新视图函数，如下面的代码片段所示：
- en: '[PRE24]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Inside the view function, we can perform any operations we want in order to
    generate a view and finally use that response to render a template. Inside this
    view function, there are some important pieces of logic we need to make sure are
    implemented correctly.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在视图函数内部，我们可以执行任何我们想要的操作来生成视图，并最终使用该响应来渲染模板。在这个视图函数内部，有一些重要的逻辑我们需要确保正确实现。
- en: 'The first one is to set the `current_app` property for the `request` field
    inside the view function. This is required in order to allow Django''s URL resolver
    inside the templates to correctly resolve the view functions for an application.
    To set this value inside the custom view function we just created, we need to
    set the `current_app` property as shown in the following code snippet:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法是在视图函数内部为`request`字段的`current_app`属性设置值。这是为了允许Django的URL解析器在模板中正确解析应用程序的视图函数。为了在刚刚创建的自定义视图函数中设置此值，我们需要按照以下代码片段设置`current_app`属性：
- en: '[PRE25]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `self.name` field is automatically populated by Django''s `AdminSite` class
    and we don''t need to initialize it explicitly. With this, our minimal custom
    view implementation will appear as shown in the following code snippet:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`self.name`字段由Django的`AdminSite`类自动填充，我们不需要显式地初始化它。有了这个，我们的最小自定义视图实现将如以下代码片段所示：'
- en: '[PRE26]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Accessing Common Template Variables
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问常用模板变量
- en: When creating a custom view function, we might want access to the common template
    variables, such as `site_header` and `site_title`, in order to render them correctly
    in the template associated with our view function. As it turns out, this is quite
    easy to achieve with the use of the `each_context()` method provided by the `AdminSite`
    class.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建自定义视图函数时，我们可能希望访问常用的模板变量，例如`site_header`和`site_title`，以便在关联的视图函数模板中正确渲染它们。实际上，通过使用`AdminSite`类提供的`each_context()`方法，这相当容易实现。
- en: The `each_context()` method of the `AdminSite` class takes a single parameter,
    `request`, which is the current request context, and returns the template variables
    that are to be inserted in all the admin site templates.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`AdminSite` 类的 `each_context()` 方法接受一个单一参数 `request`，它是当前请求上下文，并返回要插入到所有管理站点模板中的模板变量。'
- en: 'For example, if we wanted to access the template variables inside our custom
    view function, we could implement code similar to the following code snippet:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想在自定义视图函数内部访问模板变量，我们可以实现类似于以下代码片段的代码：
- en: '[PRE27]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The value returned by the `each_context()` method is a dictionary containing
    the name of the variable and the associated value.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`each_context()` 方法返回的值是一个包含变量名称和相关值的字典。'
- en: Mapping URLs for the Custom View
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 映射自定义视图的 URL
- en: Once the view function is defined, the next step involves mapping this view
    function to a URL such that a user can access it or allow the other views to link
    to it. For the views defined inside `AdminSite`, this URL mapping to views is
    controlled by the `get_urls()` method implemented by the `AdminSite` class. The
    `get_urls()` method returns the `urlpatterns` list that maps to the `AdminSite`
    views.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了视图函数，下一步就是将该视图函数映射到一个 URL，以便用户可以访问它或允许其他视图链接到它。对于在 `AdminSite` 内定义的视图，这种
    URL 映射由 `AdminSite` 类实现的 `get_urls()` 方法控制。`get_urls()` 方法返回映射到 `AdminSite` 视图的
    `urlpatterns` 列表。
- en: 'If we would like to add a URL mapping for our custom view, the preferred approach
    includes overriding the implementation of `get_urls()` in our custom `AdminSite`
    class and adding the URL mapping there. This approach is demonstrated in the following
    code snippet:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要为我们的自定义视图添加 URL 映射，首选的方法是在我们的自定义 `AdminSite` 类中覆盖 `get_urls()` 的实现，并在那里添加
    URL 映射。以下代码片段展示了这种方法：
- en: '[PRE28]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `get_urls()` method is generally called automatically by Django and there
    is no need to perform any manual processing on it.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_urls()` 方法通常由 Django 自动调用，因此不需要对其进行任何手动处理。'
- en: Once this is done, the last step involves making sure that our custom admin
    view is only accessible through the admin site and non-admin users should not
    be able to access it. Let's take a look at how that can be achieved.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作后，最后一步是确保我们的自定义管理视图只能通过管理站点访问，并且非管理员用户不应能够访问它。让我们看看如何实现这一点。
- en: Restricting Custom Views to the Admin Site
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将自定义视图限制在管理站点
- en: If you followed all the previous sections thoroughly, you would now have a custom
    `AdminSite` view ready for use. However, there is a small glitch. This view is
    also directly accessible to any user who is not on the admin site.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细阅读了所有前面的部分，你现在应该有一个自定义的 `AdminSite` 视图可以使用了。然而，有一个小问题。这个视图也可以被任何不在管理站点上的用户直接访问。
- en: 'To ensure that such a situation does not arise, we need to restrict this view
    to the admin site. This can be achieved quite simply by wrapping our URL path
    inside the `admin_view()` call, as shown in the following code snippet:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保这种情况不会发生，我们需要将此视图限制在管理站点。这可以通过将我们的 URL 路径包裹在 `admin_view()` 调用中来实现，如下面的代码片段所示：
- en: '[PRE29]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `admin_view` function makes sure the path provided to it is restricted just
    to the admin dashboard and that no non-admin-privilege user can access it.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`admin_view` 函数确保传递给它的路径仅限于管理仪表板，并且没有非管理员权限的用户可以访问它。'
- en: Now, let's add a new custom view to our admin site.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为我们管理站点添加一个新的自定义视图。
- en: 'Exercise 10.04: Adding Custom Views to the Admin Site'
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 10.04：将自定义视图添加到管理站点
- en: 'In this exercise, you will add a custom view to the admin site, which will
    render a user profile and will show the user the options to modify their email
    or add a new profile picture. To build this custom view, follow the steps described:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将为管理站点添加一个自定义视图，该视图将渲染用户资料，并显示用户修改电子邮件或添加新个人照片的选项。要构建这个自定义视图，请遵循以下步骤描述：
- en: 'Open the `admin.py` file under the `bookr_admin` directory and add the following
    imports. These will be required to build our custom view inside the admin site
    application:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开位于 `bookr_admin` 目录下的 `admin.py` 文件，并添加以下导入。这些将用于在管理站点应用程序内部构建我们的自定义视图：
- en: '[PRE30]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Open the `admin.py` file under the `bookr_admin` directory and create a new
    method named `profile_view`, which takes in a `request` variable as its parameter,
    inside the `BookrAdmin` class:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开位于 `bookr_admin` 目录下的 `admin.py` 文件，并在 `BookrAdmin` 类中创建一个名为 `profile_view`
    的新方法，该方法接受一个 `request` 变量作为其参数：
- en: '[PRE31]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next, inside the method, get the name of the current application and set that
    in the `request` context. For this, you can use the `name` property of the class,
    which is auto-populated by Django. To get this property and set it in your `request`
    context, you need to add the following line:'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，在方法内部，获取当前应用程序的名称并将其设置在`request`上下文中。为此，你可以使用类的`name`属性，该属性由Django自动填充。要获取此属性并将其设置在您的`request`上下文中，您需要添加以下行：
- en: '[PRE32]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Once you have the application name populated to the request context, the next
    step is to fetch the template variables, which are required to render the contents,
    such as `site_title`, `site_header`, and more, in the admin templates. For this,
    leverage the `each_context()` method of the `AdminSite` class, which provides
    the dictionary of the admin site template variables from the class:'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦将应用程序名称填充到请求上下文中，下一步是获取模板变量，这些变量是渲染内容所必需的，例如`site_title`、`site_header`等，在管理模板中。为此，利用`AdminSite`类的`each_context()`方法，该方法从类中提供管理站点模板变量的字典：
- en: '[PRE33]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Once you have the data in place, the last step is to return a `TemplateResponse`
    object, which will render the custom profile template when someone visits the
    URL endpoint mapped to your custom view:'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦设置了数据，最后一步是返回一个`TemplateResponse`对象，当有人访问映射到您自定义视图的URL端点时，它将渲染自定义配置文件模板：
- en: '[PRE34]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'With the view function now created, the next step is to make `AdminSite` return
    the URLs mapping the view to a path inside `AdminSite`. To do this, you need to
    create a new method with the name `get_urls()`, which overrides the `AdminSite.get_urls()`
    method and returns the mapping of your new view. This can be done by first creating
    a new method named `get_urls()` inside the `BookrAdmin` class you have created
    for your custom admin site:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在已经创建了视图函数，下一步是让`AdminSite`返回将视图映射到`AdminSite`内部路径的URL映射。为此，您需要创建一个名为`get_urls()`的新方法，该方法覆盖了`AdminSite.get_urls()`方法并返回您新视图的映射。这可以通过首先在您为自定义管理站点创建的`BookrAdmin`类中创建一个名为`get_urls()`的新方法来完成：
- en: '[PRE35]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Inside this method, the first thing you need to do is to get the list of the
    URLs that are already mapped to the admin endpoint. This is a required step, otherwise,
    your custom admin site will not be able to load any results associated with the
    model editing pages, logout page, and so on, in case this mapping is lost. To
    get this mapping, call the `get_urls()` method of the base class from which the
    `BookrAdmin` class is derived:'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在此方法中，您需要做的第一件事是获取已映射到管理端点的URL列表。这是必需的步骤，否则，您的自定义管理站点将无法加载与模型编辑页面、注销页面等相关联的任何结果，如果这种映射丢失。要获取此映射，请调用从`BookrAdmin`类派生的基类的`get_urls()`方法：
- en: '[PRE36]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Once the URLs from the base class are captured, the next step is to create
    a list of URLs that map our custom view to a URL endpoint in the admin site. For
    this, we create a new list named `url_patterns` and map our `profile_view` method
    to the `admin_profile` endpoint. To do this, we use the `path` utility function
    from Django, which allows us to map the view function with a string-based API
    endpoint path:'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦捕获了基类的URL，下一步是创建一个URL列表，将我们的自定义视图映射到管理站点的URL端点。为此，我们创建一个名为`url_patterns`的新列表，并将我们的`profile_view`方法映射到`admin_profile`端点。为此，我们使用Django的`path`实用函数，该函数允许我们将视图函数与基于字符串的API端点路径映射：
- en: '[PRE37]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Save the `admin.py` file. It should look like this: [http://packt.live/38Jlyvz](http://packt.live/38Jlyvz).'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 保存`admin.py`文件。它应该看起来像这样：[http://packt.live/38Jlyvz](http://packt.live/38Jlyvz)。
- en: 'Now, with the `BookrAdmin` class configured for the new view, the next step
    is to create your template for the admin profile page. For this, create a new
    file named `admin_profile.html` under the `templates/admin` directory of your
    project root. Inside this file, first, add an `extend` tag to make sure that you
    are extending from the default `admin` template:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，已经为新的视图配置了`BookrAdmin`类，下一步是创建管理配置文件页面的模板。为此，在项目根目录下的`templates/admin`目录中创建一个名为`admin_profile.html`的新文件。在这个文件中，首先添加一个`extend`标签以确保您是从默认的`admin`模板扩展的：
- en: '[PRE38]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This step ensures that all of your admin template style sheets and HTML are
    available for use inside your custom view template. For example, without having
    this `extend` tag, your custom view will not show any specific content already
    mapped to your admin site, such as `site_header`, `site_title`, or any links to
    log out or go to another page.
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此步骤确保您的所有管理模板样式表和HTML都可以在自定义视图模板中使用。例如，如果没有这个`extend`标签，您的自定义视图将不会显示任何已映射到您的管理站点的特定内容，如`site_header`、`site_title`或任何注销或转到其他页面的链接。
- en: 'Once the extend tag is added, add a `block` tag and provide it with the value
    of content. This makes sure that the code you add between the pair of `{% block
    content %}…{% endblock %}` segments overrides whatever value is present in the
    `index.html` template that comes pre-packaged with the Django admin module:'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Inside the `block` tag, add the HTML required to render the profile view that
    was created in *step 2* of this exercise:'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The file should look like this: [http://packt.live/2MZhU8d](http://packt.live/2MZhU8d).'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, with the preceding steps complete, reload your application server by running
    `python manage.py runserver localhost:8000` and then visiting `http://localhost:8000/admin/admin_profile`.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When the page opens, you can expect to see something like the following screenshot:'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 10.7: Profile page view in the administration site'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15509_10_07.jpg)'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.7: Profile page view in the administration site'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: The view created so far will render just fine irrespective of whether the user
    is logged into the admin application.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: To make sure that this view is only accessible to the logged-in admins, you
    need to make a small modification inside your `get_urls()` method, which you defined
    in *step 3* of this exercise.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `get_urls()` method, modify the `url_patterns` list to look something
    like the one shown here:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In the preceding code, you wrapped your `profile_view` method inside the `admin_view()`
    method.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: The `AdminSite.admin_view()` method causes the view to be restricted to those
    users who are logged in. If a user who is currently not logged into the admin
    site tries to visit the URL directly, they will get redirected to the login page,
    and only in the event of a successful login will they be allowed to see the contents
    of our custom page.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: During this exercise, we leveraged our existing understanding of writing views
    for Django applications and merged it with the context of the `AdminSite` class
    to build a custom view for our admin dashboard. With this knowledge, we can now
    move on and add useful functionalities to our Django admin to supercharge its
    usefulness.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Passing Additional Keys to the Templates Using Template Variables
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Inside the admin site, the variable values passed to the templates are passed
    through the use of template variables. These template variables are prepared and
    returned by the `AdminSite.each_context()` method.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Now, if there is a value that you would like to pass to all the templates of
    your admin site, you can override the `AdminSite.each_context()` method and add
    the required fields to the `request` context. Let's look at an example to see
    how we can achieve this outcome.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the `username` field, which we passed to our `admin_profile` template
    earlier. If we want to pass it to every template inside our custom admin site,
    we first need to override the `each_context()` method inside our `BookrAdmin`
    class, as shown here:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `each_context()` method takes a single argument (we're not considering self
    here) of the `HTTPRequest` type, which it uses to evaluate certain other values.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`each_context()`方法接受一个单一参数（这里我们不考虑self），它使用该参数来评估某些其他值。'
- en: 'Now, inside our overridden `each_context()` method, we first make a call to
    the base class `each_context()` method so as to retrieve the `context` dictionary
    for the admin site:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们的重写`each_context()`方法中，我们首先调用基类`each_context()`方法，以便检索管理网站的`context`字典：
- en: '[PRE43]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Once that is done, the next thing we do is to add our `username` field to the
    `context` and set its value to the value of the `request.user.username` field:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作后，接下来要做的是将我们的`username`字段添加到`context`中，并将其值设置为`request.user.username`字段的值：
- en: '[PRE44]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Once this is done, the last thing that remains is to return this modified context.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作后，最后剩下的事情就是返回这个修改后的上下文。
- en: Now, whenever a template is rendered by our custom admin site, the template
    will be passed with this additional username variable.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当我们的自定义管理网站渲染模板时，模板将带有这个额外的用户名变量。
- en: 'Activity 10.01: Building a Custom Admin Dashboard with Built-In Search'
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动十点零一：使用内置搜索构建自定义管理仪表板
- en: In this activity, you will use the knowledge you gained about the different
    aspects of creating a custom admin site to build a custom admin dashboard for
    Bookr. Inside this dashboard, you will introduce the capability of allowing a
    user to search the books by using either the name of the book or by using the
    name of the book publisher and allowing the user to modify or delete these book
    records.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，您将使用您在创建自定义管理网站的不同方面获得的知识来为Bookr构建自定义管理仪表板。在这个仪表板中，您将引入允许用户通过书籍名称或书籍出版社的名称搜索书籍的能力，并允许用户修改或删除这些书籍记录。
- en: 'The following steps will help you build a custom admin dashboard and add the
    ability to search a book record by using the name of the publisher:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您构建自定义管理仪表板，并添加通过出版社名称搜索书籍记录的功能：
- en: Create a new application inside the Bookr project named `bookr_admin`, if not
    created already. This is going to store the logic for our custom admin site.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Bookr项目中创建一个新的应用，命名为`bookr_admin`，如果尚未创建。这将存储我们自定义管理网站的逻辑。
- en: Inside the `admin.py` file under the `bookr_admin` directory, create a new class,
    `BookrAdmin`, which inherits from the `AdminSite` class of Django's admin module.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`bookr_admin`目录下的`admin.py`文件中，创建一个新的类`BookrAdmin`，该类继承自Django管理模块的`AdminSite`类。
- en: Inside the newly created `BookrAdmin` class in *step 2*, add any customizations
    for the site title or any other branding component of the admin dashboard.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在*步骤2*中新建的`BookrAdmin`类中，添加对站点标题或其他管理仪表板品牌组件的任何自定义设置。
- en: Inside the `apps.py` file under the `bookr_admin` directory, create a new `BookrAdminConfig`
    class, and inside this new `BookrAdminConfig` class, set the default site attribute
    to the fully qualified module name for our custom admin site class, `BookrAdmin`.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`bookr_admin`目录下的`apps.py`文件中，创建一个新的`BookrAdminConfig`类，并在新的`BookrAdminConfig`类中，将默认站点属性设置为我们的自定义管理网站类`BookrAdmin`的完全限定模块名称。
- en: Inside the `settings.py` file of your Django project, add the fully qualified
    path of the `BookrAdminConfig` class created in *step 4* as the first installed application.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的Django项目的`settings.py`文件中，将创建于*步骤4*的`BookrAdminConfig`类的完全限定路径作为第一个安装的应用程序。
- en: To register the `Books` model from the `reviews` application inside Bookr, open
    the `admin.py` file inside the reviews directory and make sure that the Books
    model is registered to the admin site by using `admin.site.register(ModelClass)`.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在Bookr中注册来自`reviews`应用的`Books`模型，打开`reviews`目录下的`admin.py`文件，并确保使用`admin.site.register(ModelClass)`将Books模型注册到管理网站。
- en: To allow a search of the book according to the name of the publisher, inside
    the `admin.py` file of the `reviews` application, modify the `BookAdmin` class
    and add to it a property named `search_fields`, which contains `publisher_name`
    as a field.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了允许根据出版社名称搜索书籍，在`reviews`应用的`admin.py`文件中，修改`BookAdmin`类，并向其中添加一个名为`search_fields`的属性，该属性包含`publisher_name`字段。
- en: To get the publisher's name correctly for the `search_fields` property, introduce
    a new method named `get_publisher` inside the `BookAdmin` class, which will return
    the name field of the publisher from the `Book` model.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了正确获取`search_fields`属性的出版社名称，在`BookAdmin`类中引入一个新的方法`get_publisher`，该方法将从`Book`模型返回出版社的名称字段。
- en: Make sure that the `BookAdmin` class is registered as a Model admin class for
    the Book model inside our Django admin dashboard by using `admin.site.register(Book,
    BookModel)`.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保使用`admin.site.register(Book, BookModel)`在我们的Django管理仪表板中将`BookAdmin`类注册为书籍模型的模型管理类。
- en: 'After completing this activity, once you start the application server and visit
    `http://localhost:8000/admin` and navigate to the Book model, you should be able
    to search for books by using the publisher''s name and, in the event of a successful
    search, see a page that resembles the one shown in the following screenshot:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此活动后，一旦您启动应用程序服务器并访问 `http://localhost:8000/admin` 并导航到书籍模型，您应该能够通过使用出版社的名称来搜索书籍，在搜索成功的情况下，您将看到一个类似于以下截图所示的页面：
- en: '![Figure 10.8: Book editing page inside the Bookr administration dashboard'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.8：Bookr管理仪表板内的书籍编辑页面'
- en: '](img/B15509_10_08.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B15509_10_08.jpg]'
- en: 'Figure 10.8: Book editing page inside the Bookr administration dashboard'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.8：Bookr管理仪表板内的书籍编辑页面
- en: Note
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found at [http://packt.live/2Nh1NTJ](http://packt.live/2Nh1NTJ).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可以在[http://packt.live/2Nh1NTJ](http://packt.live/2Nh1NTJ)找到。
- en: Summary
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at how Django allows the customization of its admin
    site. It does so by providing easy-to-use properties for some of the more general
    parts of the site, such as title fields, headings, and home links. Beyond this,
    we learned how to build a custom admin site by leveraging the concepts of object-oriented
    programming in Python and creating a child class of `AdminSite`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了Django如何允许自定义其管理站点。它是通过为网站的一些更通用的部分提供易于使用的属性来实现的，例如标题字段、标题和主页链接。除此之外，我们还学习了如何通过利用Python面向对象编程的概念来创建`AdminSite`的子类来构建自定义管理站点。
- en: This functionality was further enhanced by implementing a custom template for
    the logout page. We also learned how we can supercharge our admin dashboard by
    adding a new set of views to allow enhanced usage of the dashboard.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现一个自定义的注销页面模板，我们进一步增强了此功能。我们还学习了如何通过添加一组新的视图来增强我们的管理仪表板。
- en: As we move on to the next chapter, we will build upon what we have learned so
    far by learning how to create our own custom tags and filters for templates. Furthermore,
    using class-based views, we will gain the ability to build our views in an object-oriented
    style.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们进入下一章，我们将通过学习如何为模板创建我们自己的自定义标签和过滤器来构建我们迄今为止所学的内容。此外，通过使用基于类的视图，我们将获得以面向对象风格构建视图的能力。
