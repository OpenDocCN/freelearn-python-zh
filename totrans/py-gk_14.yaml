- en: '*Chapter 10*: Using Python for Web Development and REST API'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A web application is a type of application that is hosted and run by a **web
    server** within an intranet or on the internet and accessed through a web browser
    on a client device. The use of web browsers as a client interface makes it convenient
    for users to access the applications from anywhere without installing any additional
    software on a local machine. This ease of access has contributed to the success
    and popularity of web applications for more than two decades. The use of web applications
    varies, from delivering static and dynamic content such as Wikipedia and newspapers,
    e-commerce, online games, social networking, training, multimedia content, surveys,
    and blogs, to complex **Enterprise Resource Planning** (**ERP**) applications.
  prefs: []
  type: TYPE_NORMAL
- en: Web applications are multi-tier by nature, typically three-tier applications.
    The three tiers are a UI, business logic, and database access. Therefore, developing
    web applications involves interacting with web servers for a UI, an **application
    server** for business logic, and database systems for persisting data. In the
    mobile applications era, the UI may be a mobile app that requires access to the
    business logic tier via a REST API. The availability of a REST API or any sort
    of web services interface has become a fundamental requirement for web applications.
    This chapter discusses how to use Python for building multi-tier web applications.
    There are several frameworks available in Python to develop web applications,
    but we selected **Flask** for our discussion in this chapter because of being
    feature-rich yet lightweight. Web applications are also termed *web apps* to differentiate
    them from mobile apps that are targeted at small devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning requirements for web development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing the Flask framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interacting with databases using Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a REST API using Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Case study: Building a web application using the REST API'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to use the Flask framework to develop
    web applications, interact with databases, and build a REST API or web services.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the technical requirements for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: You need to have Python 3.7 or later installed on your computer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python Flask library 2.x with its extensions installed on top of Python 3.7
    or later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sample code for this chapter can be found at [https://github.com/PacktPublishing/Python-for-Geeks/tree/master/Chapter10](https://github.com/PacktPublishing/Python-for-Geeks/tree/master/Chapter10).
  prefs: []
  type: TYPE_NORMAL
- en: We will start our discussion with key requirements of developing web applications
    and a REST API.
  prefs: []
  type: TYPE_NORMAL
- en: Learning requirements for web development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Developing a web application includes building UI, routing user requests or
    user actions to application endpoints, translating the user input data, writing
    business logic for user requests, interacting with the data layer to read or write
    data, and serving the results back to users. All these development components
    may require different platforms and sometimes even use different programming languages
    for implementation. In this section, we will understand the components and tools
    required for web development, starting with web application frameworks or web
    frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Web frameworks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Developing web applications from scratch is time-consuming and tedious. To make
    it convenient for web developers, web application frameworks were introduced in
    the very early days of web development. Web frameworks provide a set of libraries,
    directory structures, reusable components, and deployment tools. Web frameworks
    typically follow an architecture that enables developers to build complex applications
    in less time and in an optimized way.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several web frameworks available for Python: **Flask** and **Django**
    are the most popular. Both frameworks are free and open source. Flask is a lightweight
    framework and comes with standard functionalities that are required to build a
    web application, but it also allows additional libraries or extensions to use
    as they are needed. On the other hand, Django is a full stack framework that comes
    with all features out of the box without requiring additional libraries. Both
    approaches have merits and demerits, but in the end, we can develop any web application
    with any of these frameworks.'
  prefs: []
  type: TYPE_NORMAL
- en: Flask is considered a better choice if you want to have full control of your
    application with a choice of using external libraries as they fit. Flask is also
    a good fit when project requirements are changing very frequently. Django is suitable
    if you want to have all tools and libraries available to you out of the box and
    you want to focus only on implementing the business logic. Django is a good choice
    for large-scale projects, but can be overkill for simple projects. The learning
    curve for Django is steep and requires prior experience in web development. If
    you are staring at web development with Python for the first time, Flask is the
    way to go. Once you learn Flask, it is easy to adopt the Django framework for
    the next level of web projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'When building web applications or any UI applications, we often come across
    the term **Model View Controller** (**MVC**) design pattern. This is an architectural
    design pattern that divides an application into three layers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Model**: The model layer represents the data that is typically stored in
    a database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**View**: This layer is the UI with which users interact.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Controller**: The controller layer is designed to provide a logic to handle
    user interactions with the application through UI. For example, a user may want
    to create a new object or update an existing object. The logic of which UI (view)
    to present to the user for the create or update request with or without a model
    (data) is all implemented in the controller layer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flask does not provide direct support for MVC design patterns, but it can be
    implemented through programming. Django provides close enough implementation for
    MVC, but not fully. The controller in the Django framework is managed by Django
    itself and is not available for writing our own code in it. Django and many other
    web frameworks for Python follow the **Model View Template** (**MVT**) design
    pattern, which is like MVC except the template layer. The template layer in the
    MVT provides specially formatted templates to produce the expected UI with the
    capability to insert dynamic contents within HTML.
  prefs: []
  type: TYPE_NORMAL
- en: User interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A **UI** is the presentation layer of the application, and sometimes it is
    included as part of the web frameworks. But we are discussing it separately here
    to highlight key technologies and choices available for this layer. First and
    foremost, the user is interacting through a browser in **HyperText Markup Language**
    (**HTML**) and **Cascading Style Sheets** (**CSS**). We can build our interfaces
    by writing HTML and CSS directly, but it is tedious and not feasible for delivering
    dynamic content in a timely manner. There are a few technologies available to
    make our lives easier when building UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '**UI framework**: These are mainly HTML and CSS libraries to provide different
    classes (styles) for building UI. We still need to write or generate core HTML
    parts of UI, but without worrying about how to beautify our web pages. A popular
    example of a UI framework is **bootstrap**, which is built on top of CSS. It was
    introduced by Twitter for internal use, but was made open source later for anyone
    to use. **ReactJS** is another popular option, but this is more a library than
    a framework and was introduced by Facebook.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Template engine**: A template engine is another popular mechanism to produce
    web content dynamically. A template is more like a definition of the desired output
    that holds static data as well as placeholders for dynamic contents. The placeholders
    are tokenized strings that are replaced by values at runtime. The output can be
    any format, such as HTML, XML, JSON, or PDF. **Jinja2** is one of the most popular
    templating engines used with Python, and is also included with the Flask framework.
    Django comes with its own templating engine.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Client-side scripting**: A client-side script is a program that is downloaded
    from the web server and is executed by the client web browser. JavaScript is the
    most popular client-side scripting language. There are many JavaScript libraries
    available to make web development easier.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use more than one technology to develop web interfaces. In a typical
    web project, all three are used in different capacities.
  prefs: []
  type: TYPE_NORMAL
- en: Web server/application server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A web server is software that listens to client requests through HTTP and delivers
    content (such as web pages, scripts, images) as per the request type. The web
    server's fundamental job is to serve only static resources and is not capable
    of code execution.
  prefs: []
  type: TYPE_NORMAL
- en: The application server is more specific to a programming language. The main
    job of an application server is to provide access to the implementation of a business
    logic that is written using a programming language such as Python. For many production
    environments, the web server and application server are bundled as one software
    for ease of deployment. Flask comes with its own built-in web server, named **Werkzeug**,
    for the development phase, but this is not recommended for use in production.
    For production, we must use other options such as **Gunicorn**, **uWSGI**, and
    **GCP runtime engines**.
  prefs: []
  type: TYPE_NORMAL
- en: Database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is not a mandatory component, but it is almost essential for any interactive
    web application. Python offers several libraries to access commonly used database
    systems, such as **MySQL**, **MariaDB**, **PostgreSQL**, and **Oracle**. Python
    also comes equipped with a lightweight database server, **SQLite**.
  prefs: []
  type: TYPE_NORMAL
- en: Security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Security is fundamental for web applications, mainly because the target audience
    is typically internet users, and data privacy is the utmost requirement in such
    environments. **Secure Sockets Layer** (**SSL**) and the more recently introduced
    **Transport Layer Security** (**TLS**) are the minimum acceptable security standards
    to secure the transmission of data between clients and the server. The transport-level
    security requirements are typically handled at the web server or sometimes proxy
    server level. User-level security is the next fundamental requirement, with minimum
    username and password requirements. User security is application-level security
    and developers are mainly responsible for designing and implementing it.
  prefs: []
  type: TYPE_NORMAL
- en: API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The business logic layer in web applications can be consumed by additional clients.
    For example, a mobile app can use the same business logic for a limited or same
    set of features. For **Business to Business** (**B2B**) applications, a remote
    application can submit requests to the business logic layer directly. This is
    all possible if we expose standard interfaces such as a REST API for our business
    logic layer. In the current era, accessing the business logic layer through an
    API is a best practice to make the API ready from day one.
  prefs: []
  type: TYPE_NORMAL
- en: Documentation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Documentation is as important as writing programming code. This is especially
    true for APIs. When we say that we have an API for our application, the first
    question from API consumers is whether you can share API documentation with us.
    The best way to have API documentation is to use built-in tools that come or possibly
    integrate with our web framework. **Swagger** is a popular tool that is used to
    generate documentation automatically from the comments that are added at the time
    of coding.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have discussed key requirements of web development, we will deep
    dive into how to develop a web application using Flask in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the Flask framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flask is a micro web development framework for Python. The term *micro* indicates
    that the core of Flask is lightweight, but with the flexibility of being extensible.
    A simple example is interacting with a database system. Django comes with libraries
    required to interact with the most common databases. On the other hand, Flask
    allows the use of an extension as per the database type or as per the integration
    approach to achieve the same goal. Another philosophy of Flask is to use *convention
    over configuration*, which means that if we follow standard conventions of web
    development, we have to do less configuration. This makes Flask the best choice
    for beginners to learn web development with Python. We selected Flask for our
    web development, not only because of its ease-of-use capability, but also because
    it allows us to introduce different concepts in a stepwise approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will learn the following aspects of web applications using
    Flask:'
  prefs: []
  type: TYPE_NORMAL
- en: Building a basic web application with routing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling requests with different HTTP method types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering static and dynamic contents using Jinja2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extracting arguments from an HTTP request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interacting with database systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling errors and exceptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we start working with code examples to be used in the next sections,
    Flask 2.x needs to be installed in our virtual environment. We will start with
    a basic web application using Flask.
  prefs: []
  type: TYPE_NORMAL
- en: Building a basic application with routing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have already used Flask to build a sample application for GCP App Engine
    deployment in the last chapter, *Python Programming for the Cloud*. We will refresh
    our knowledge of using Flask to develop a simple web application. We will start
    with a code example to understand how a web application is built and how routing
    works in it. The complete code example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s analyze this code example step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: '`app` in our case) as a first step. The web server will pass all requests from
    clients to this application instance using a protocol known as a `app = Flask(__name__)`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is important to pass the module name as an argument to the `Flask` constructor.
    The Flask uses this argument to learn the location of the application, which becomes
    an input to determine the location of other files such as static resources, templates,
    and images. Using `__name__` is the convention (over configuration) to pass to
    the `Flask` constructor, and Flask takes care of the rest.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`app` instance, now it is the responsibility of the instance to execute a certain
    piece of code to handle the request. This piece of code, which is typically a
    Python function, is called `handler`. The good news is that each request is typically
    (not all the time) associated with a single URL, which makes it possible to define
    a mapping between a URL and a Python function. This URL to Python function mapping
    is called a route. In our code example, we selected a simple approach to define
    this mapping by using the `route` decorator. For example, the `/hello` URL is
    mapped to the `hello` function, and the `/greeting` URL is mapped to the `greeting`
    function. If we prefer to define all routes in one place, we can use `add_url_rule`
    with the app instance for all route definitions.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Handler function**: The handler function after processing the request has
    to send a response back to the client. A response can be a simple string with
    or without HTML, or it can be a complex web page that can be static or dynamic
    based on a template. In our code example, we returned a simple string for illustration
    purposes.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`app.run()` method, or by using the `flask run` command in a shell. When we
    start this web server, it looks for an `app.py` or `wsgi.py` module by default,
    and it will be loaded automatically with the server if we use the `app.py` name
    for our module file (again, convention over configuration). But if we are using
    a different name for our module (it is our case), we must set an environment variable,
    `FLASK_APP = <module name>`, which will be used by the web server to load the
    module.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you have created a Flask project using an IDE such as `http://localhost:5000/`
    and it is accessible only on your local machine by default. If we want to start
    the server using a different hostname and port, we can use the following command
    (or the equivalent Python statement):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`curl` commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that we have finished our discussion on the fundamentals of a Flask application,
    we will start exploring topics related to consuming the request and sending a
    dynamic response back to the clients.
  prefs: []
  type: TYPE_NORMAL
- en: Handling requests with different HTTP method types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: HTTP is based on a `GET`, `POST`, `PUT`, `DELETE`, `HEAD`, `PATCH`, and `OPTIONS`.
    `GET` and `POST` are the most frequently used HTTP methods, and so we will cover
    only these to illustrate our web development concepts.
  prefs: []
  type: TYPE_NORMAL
- en: 'But before discussing these two methods, it is also important to understand
    the two key components of HTTP, which are **HTTP request** and **HTTP response**.
    An HTTP request is divided into three parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Request line**: This line includes the HTTP method to be used, the URI of
    the request, and the HTTP protocol (version) to be used:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`:`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST` requests inside the body of the HTTP request. For a REST API, we can
    send data for `PUT` or `POST` requests within the body.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When we send an HTTP request to a web server, we will get an HTTP response
    as a result. The HTTP response will have similar parts to the HTTP request:'
  prefs: []
  type: TYPE_NORMAL
- en: '`200` or something in the range of `200-299` indicates success. Error codes
    are in the range of `400-499` for client-side errors, and in the range of `500-599`
    for server-side errors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Header**: Header fields are similar to the HTTP request header fields.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Body** (optional): Although optional, this is the key part of an HTTP response.
    This can include HTML pages for web applications or data in any other format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET` is used to send a request for a certain resource identified in the URL
    with the option to add a **query string** as part of the URL. The *?* is added
    in the URL to keep the query string separate from the base URL. For example, if
    we search for the word *Python* on Google, we will see a URL as follows in the
    browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.google.com/search?q=Python](https://www.google.com/search?q=Python)'
  prefs: []
  type: TYPE_NORMAL
- en: In this URL, `q=Python` is a query string. A query string is used to carry data
    in the form of key-value pairs. This approach of accessing resources is popular
    because of its simplicity but does have its limitations. The data in a query string
    is visible in the URL, which means we cannot send sensitive information such as
    a username and password as a query string. The length of the query string cannot
    be more than 255 characters. However, the `GET` method is in use for searching
    websites such as Google and YAHOO for reasons of simplicity. In the case of the
    `POST` method, the data is sent via the HTTP request body, which eliminates the
    limitations of the `GET` method. The data does not appear as part of the URL and
    there is no limit in terms of the data that we can send to the HTTP server. There
    is also no limit in terms of the data types supported using the `POST` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Flask provides a few convenient ways to identify whether a request is sent
    using `GET` or `POST` or is using any other method. In our next code example,
    we illustrate two approaches; the first approach uses the `route` decorator, with
    an exact list of the method types expected, and the second approach is using a
    decorator specific for the HTTP method type, such as the `get` decorator and the
    `post` decorator. The use of both approaches is illustrated in the next code example,
    followed by a detailed analysis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s discuss the three route definitions and corresponding functions in our
    sample code one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: In the first route definition (`@app.route('/submit', methods=['GET']))`, we
    used the `route` decorator for mapping a URL, with requests of the `GET` type
    to a Python function. With this decorator setting, our Python function will handle
    requests with the `GET` method just for the `/submit` URL.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the second route definition (`@app.post('/submit'))`, we used the `post`
    decorator and only specify the request URL with it. This is a simplified version
    of mapping a request with the `POST` method to a Python function. This new setting
    is equivalent to the first route definition, but with the `POST` method type in
    a simplified form. We can achieve the same for a `GET` method by using the `get`
    decorator.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the third route definition (`@app.route('/submit2', methods = ['GET', 'POST'])`),
    we mapped a single URL with requests using both the `POST` and `GET` methods to
    a single Python function. This is a convenient approach when we are expecting
    to handle any request method by using a single handler (Python function). Inside
    the Python function, we used the `method` attribute of the request object to identify
    whether the request is of the `GET` or `POST` type. Note that the request object
    is made available to our Flask app by the web server once we import the `request`
    package into our program. This approach gives flexibility for clients to submit
    requests using any one of the two methods using the same URL and, as a developer,
    we mapped them to a single Python function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can test this code example more conveniently through the `curl` utility
    because it will not be easy to submit a `POST` request without defining an HTML
    form. The following `curl` commands can be used to send HTTP requests to our web
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will discuss how to render a response from static pages and templates.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering static and dynamic contents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The static contents are important for a web application as they include CSS
    and JavaScript files. The static files can be served directly by the web server.
    Flask can also make this happen if we create a directory called `static` in our
    project and redirect the client to the static file location.
  prefs: []
  type: TYPE_NORMAL
- en: 'Dynamic contents can be created using Python, but it is tedious and requires
    quite an effort to maintain such a code in Python. The recommended approach is
    to use a template engine such as **Jinja2**. Flask comes with a Jinja2 library,
    so there is no additional library to install, nor do we need to add any additional
    configuration to set up Jinja2\. A sample code with two functions, one handling
    a request for static contents and the other for dynamic contents, is shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'For a better understanding of this sample code, we will highlight the key points:'
  prefs: []
  type: TYPE_NORMAL
- en: We import additional modules from Flask such as `url_for`, `redirect`, and `render_template`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the `/hello` route, we build a URL using the `url_for` function with the
    `static` directory and the name of the HTML file as arguments. We send the response,
    which is an instruction to the browser, to redirect the client to the URL of a
    static file location. The redirect instructions are indicated to the web browser
    by using a status code in the range of `300-399`, which is automatically set by
    Flask when we used the `redirect` function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the `/gtreeting` route, we render a Jinja template, `app3_d.html`, using
    the `render_template` function. We also passed a greeting message string as a
    value to a variable for the template. The greeting variable will be available
    to the Jinja template, as shown in the following template excerpt from the `app3_d.html`
    file:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This sample web application can be accessed using a web browser and using the
    `curl` utility. In the next section, we will discuss how to extract parameters
    from different types of requests.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting parameters from an HTTP request
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Web applications are different from websites because they are interactive with
    users and this is not possible without exchanging data between a client and a
    server. In this section, we will discuss how to extract data from a request. Depending
    on the type of HTTP method used, we will adopt a different approach. We will cover
    the following three types of requests as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Parameters as part of the request URL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parameters as query string with a `GET` request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parameters as HTML form data with a `POST` request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A sample code with three different routes to cover the three aforementioned
    request types is as follows. We are rendering a Jinja template (`app4.html`),
    which is the same as we used for the `app3_d.html` file, except the variable name
    is `name` instead of `greeting`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will discuss the parameter extraction approach for each case:'
  prefs: []
  type: TYPE_NORMAL
- en: For the first set of routes (`app.route`), we defined a route in a way that
    any text after `/hello/` is considered parameters with the request. We can set
    zero or one or two parameters, and our Python function is able to handle any combination
    and returns the name (which can be empty) to the template as a response. This
    approach is good for simple cases of parameter passing to the server program.
    This is a popular choice in REST API development to access a single resource instance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the second route (`app.get`), we are extracting query string parameters
    from the `args` dictionary object. We can fetch the parameter value either by
    using its name as a dictionary key or by using the `GET` method with the second
    argument as a default value. We used an empty string as a default value with the
    `GET` method. We showed both options, but we recommend using the `GET` method
    if you want to set a default value in case no parameter exists in the request.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the third route (`app.post`), parameters come as form data as part of the
    body of the HTTP request and we will be using form dictionary object to extract
    these parameters. Again, we used the parameter name as a dictionary key and also
    used the `GET` method for illustration purposes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To test these scenarios, we recommend using the `curl` utility, especially
    for `POST` requests. We tested the application with the following commands:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will discuss how to interact with a database in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with database systems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A full stack web application requires the persistence of structured data, so
    knowledge and experience of working with a database are prerequisites for web
    development. Python and Flask can integrate with most SQL or no-SQL database systems.
    Python itself comes with a lightweight SQLite database with the module name `sqlite3`.
    We will use SQLite because it does not require setting up a separate database
    server and works very well for small-scale applications. For production environments,
    we must use other database systems, such as MySQL or MariaDB, or PostgreSQL. To
    access and interact with a database system, we will use one of the Flask extensions,
    `Flask-SQLAlchemy`. The `Flask-SQLAlchemy` extension is based on the `SQLAlchemy`
    library of Python and makes the library available to our web application. The
    `SQLAlchemy` library provides an `SQLAlchemy` or a similar library to work with
    database systems.
  prefs: []
  type: TYPE_NORMAL
- en: To interact with any database system from our application, we need to create
    our Flask application instance as usual. The next step is to configure the application
    instance with the URL for our database location (a file in the case of SQLite3).
    Once the application instance is created, we will create a `SQLAlchemy` instance
    by passing it to the application instance. When using a database such as SQLite,
    we only have to initialize the database the first time. It can be initiated from
    a Python program, but we will not favor this approach so as to avoid the database
    reset every time we start our application. It is recommended to initialize the
    database one time only from a command line using the `SQLAlchemy` instance. We
    will discuss the exact steps of initializing the database after our code example.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate the use of the `SQLAlchemy` library with our web application,
    we will create a simple application to *add*, *list*, and *delete* student objects
    from a database table. Here is a sample code of the application to initialize
    the Flask application and the database instance (a `SQLAlchemy` instance) and
    also to create a `Model` object of the `Student` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Once we have created the `SQLAlchemy` instance, `db`, we can work with database
    objects. The beauty of an ORM library such as `SQLAlchemy` is that we can define
    a database schema, known as a `Student`, which is inherited from a base class,
    `db.Model`. In this model class, we defined the `id`, `name`, and `grade` attributes
    that will correspond to three columns in a database table, *Student*, in the `SQLite3`
    database instance. For each attribute, we defined its data type with the maximum
    length, whether it has a primary key, and whether it is nullable. These additional
    attribute definitions are important to configure the database tables in an optimized
    way.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code snippet, we will illustrate a Python function, `list_students`,
    for getting a list of student objects from the database. This function is mapped
    to the `/list` URL of our sample web application and it returns all `Student`
    objects from the database table by using the `all` method on the `query` instance
    (an attribute of the `db` instance). Note that the `query` instance and its methods
    are available from the base class, `db.Model`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next code snippet, we will write a function (`add_student`) to add students
    to the database table. This function is mapped to the `/add` URL and expects the
    student''s name and their grade passed as request parameters using the `GET` method.
    To add a new object to the database, we will create a new instance of the `Student`
    class with the requisite attribute values and then use the `db.Session` instance
    to add to the ORM layer by using the `add` function. The `add` function will not
    add the instance to the database by itself. We will use the `commit` method to
    push it to the database table. Once a new student is added to our database table,
    we redirect control to the `/list` URL. The reason we used a redirect to this
    URL is that we want to return the latest list of students after adding a new one
    and to reuse the `list_students` function, which we already implemented. The complete
    code for the `add_student` function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In the last part of this code example, we will write a Python function (`delete_student`)
    to delete a student from the database table. This function is mapped to the `/delete<int:id>`
    URL. Note that we are expecting the client to send the student ID (which we sent
    with a list of students using the `list` request). To delete a student, first,
    we query for the exact student instance by using the student ID. This is achieved
    by using the `filter_by` method on the `query` instance. Once we have the exact
    `Student` instance, we use the `delete` method of the `db.Session` instance and
    then commit the changes. As with the `add_student` function, we redirected the
    client to the `/list` URL to return an up-to-date list of students to our Jinja
    template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'To show a list of students in a browser, we created a simple Jinja template
    (`app5.html`). The `app5.html` template file will provide a list of students in
    a table format. It is important to note that we use a Jinja `for` loop to build
    the HTML table rows dynamically, as shown in the following Jinja template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Before starting this application, we should initialize the database schema
    as a one-time step. This can be done by using a Python program, but we have to
    make sure the code is executed only once or only when the database is not already
    initialized. A recommended approach is to do this step manually using the Python
    shell. In the Python shell, we can import the `db` instance from our application
    module and then use the `db.create_all` method to initialize the database as per
    the model classes defined in our program. Here are the sample commands to be used
    for our application for database initialization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: These commands will create a `student.db` file in the same directory where we
    have our program. To reset the database, we can either delete the `student.db`
    file and rerun the initialization commands, or we can use the `db.drop_all` method
    in the Python shell.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can test the application using the `curl` utility or through a browser using
    the following URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://localhost:5000/list`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http://localhost:5000/add?fname=John&Lee=asif&grade=9`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http://localhost:5000/delete/<id>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we will discuss how to handle errors in a Flask-based web application.
  prefs: []
  type: TYPE_NORMAL
- en: Handling errors and exceptions in web applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In all our code examples, we did not pay attention to how to deal with situations
    when a user enters an incorrect URL in their browser or sends a wrong set of arguments
    to our application. This was not a design intention, but the aim was to focus
    on the key components of web applications first. The beauty of web frameworks
    is that they typically support error handling by default. If any error occurs,
    an appropriate status code is returned automatically. The error codes are well
    defined as part of the HTTP protocol. For example, the error codes from `400`
    *to* `499` indicate errors with client requests, and the error codes from `500`
    *to* `599` indicate problems with the server while executing the request. A few
    commonly observed errors are summarized next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 10.1 – A commonly observed HTTP errors'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17189_10_Table_1.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 10.1 – A commonly observed HTTP errors
  prefs: []
  type: TYPE_NORMAL
- en: A complete list of HTTP status codes and errors is available at [https://httpstatuses.com/](https://httpstatuses.com/).
  prefs: []
  type: TYPE_NORMAL
- en: The Flask framework also comes with an error handling framework. While handling
    client requests, if our program breaks, a `500 Internal Server Error` is returned
    by default. If a client requests a URL that is not mapped to any Python function,
    Flask will return a `404 Not Found` error to the client. These different error
    types are implemented as subclasses of the `HTTPException` class, which is part
    of the Flask library.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to handle these errors or exceptions with a custom behavior or custom
    message, we can register our handler with the Flask application. Note that an
    error handler is a function in Flask that is only triggered when an error occurs,
    and we can associate a specific error or generic exception with our handlers.
    We build a sample code to illustrate the concept at a high level. First, we will
    illustrate a simple web application with two functions ( `hello` and `greeting`)
    for handling two URLs, as shown in the following sample code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'To handle the errors, we will register our handler against the app instance
    using the `errorHandler` decorator. For our sample code (shown next), we registered
    a `page_not_found` handler against error code `404` for the Flask application.
    For error code `500`, we registered an `internal_error` function as an error handler.
    In the end, we registered `generic_handler` for the `HTTPException` class. This
    generic handler will catch the error or exception other than `404` and `500`.
    A sample code with all three handlers is shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'For illustration purposes, we also wrote basic Jinja templates with custom
    messages; `error404.html`, `error500.html`, and `error.html`. The `error404.html`
    and `error500.html` templates are using the message that is hardcoded in the template.
    However, the `error.html` template expects the custom message coming from the
    web server. To test these sample applications, we will request the following through
    a browser or the `curl` utility:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET http://localhost:5000/`: We will expect a normal response in this case.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET http://localhost:5000/hello`: We will expect a `404` error as there is
    no Python function mapped to this URL and the Flask app will render an `error404.html`
    template.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET http://localhost:5000/greeting`: We will expect a `500` error because
    we try to divide a number by zero to raise the `ZeroDivisionError` error. Since
    this is a server-side error (`500`), it will trigger our `interna l_error` handler,
    which renders a generic `error500.html` template.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST http://localhost:5000/`: To emulate the role of a generic handler, we
    will send a request that triggers an error code other than `404` and `500`. This
    is easily possible by sending a `POST` request for a URL that is expecting a `GET`
    request and the server will raise a `405` error in this case (for an unsupported
    HTTP method). We have no error handler specific for error code 405 in our application,
    but we have registered a generic handler with `HTTPException`. This generic handler
    will handle this error and render a generic `error.html` template.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This concludes our discussion of using the Flask framework for web application
    development. Next, we will explore building a REST API using Flask extensions.
  prefs: []
  type: TYPE_NORMAL
- en: Building a REST API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**REST**, or **ReST**, is an acronym for **Representational State Transfer**,
    which is an architecture for client machines to request information about the
    resources that exist on a remote machine. **API** stands for **Application Programming
    Interface**, which is a set of rules and protocols for interacting with application
    software running on different machines. The interaction of different software
    entities is not a new requirement. In the last few decades, there have been many
    technologies proposed and invented to make software-level interactions seamless
    and convenient. A few noticeable technologies include **Remote Procedure Call**
    (**RPC**), **Remote Method Invocation** (**RMI**), CORBA, and SOAP web services.
    These technologies have limitations in terms of being tied to a certain programming
    language (for example, RMI) or tied to a proprietary transport mechanism, or using
    only a certain type of data format. These limitations have been almost entirely
    eliminated by the RESTful API, which is commonly known as the REST API.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The flexibility and simplicity of the HTTP protocol make it a favorable candidate
    to use as a transport mechanism for a REST API. Another advantage of using HTTP
    is that it allows several data formats for data exchange (such as text, XML, and
    JSON) and is not constrained to one format, such as how XML is the only format
    for SOAP-based APIs. The REST API is not tied to any one specific language, which
    makes it a de facto choice for building APIs for web interactions. An architectural
    view of a REST API call from a REST client to a REST server using HTTP is shown
    next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – REST API interaction between clients and a server'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17189_10_01_New.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.1 – REST API interaction between clients and a server
  prefs: []
  type: TYPE_NORMAL
- en: A REST API relies on HTTP requests and uses its native methods such as `GET`,
    `PUT`, `POST`, and `DELETE`. The use of the HTTP method simplifies the implementation
    of client-side and server-side software from an API design perspective. A REST
    API is developed keeping in mind the CRUD operations concept. `GET` for `Read`,
    `POST` for `Create`, `PUT` for `Update`, and `DELETE` for `Delete` operation.
  prefs: []
  type: TYPE_NORMAL
- en: When building a REST API with HTTP methods, we must be careful in choosing the
    correct method based on its idempotency capabilities. An operation is considered
    idempotent in mathematics if the operation is giving the same results even if
    it is repeated multiple times. From the rest API design perspective, the `POST`
    method is not idempotent, which means we have to make sure that the API clients
    are not initiating a `POST` request multiple times for the same set of data. The
    `GET`, `PUT`, and `DELETE` methods are idempotent, although it is quite possible
    to get a `404` error code if we try to delete the same resource the second time.
    However, this is acceptable behavior from an idempotence point of view.
  prefs: []
  type: TYPE_NORMAL
- en: Using Flask for a REST API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A REST API in Python can be built using different libraries and frameworks.
    The most popular frameworks for building a REST API are Django, Flask (using the
    **Flask-RESTful** extension), and **FastAPI**. Each of these frameworks has merits
    and demerits. Django is a suitable choice for building a REST API if the web application
    is also being built using Django. However, using Django only for API development
    would be overkill. The Flask-RESTful extension works seamlessly with a Flask web
    application. Both Django and Flask have strong community support, which is sometimes
    an important factor when selecting a library or a framework. FastAPI is considered
    the best in performance and is a good choice if the goal is only to build a REST
    API for your application. However, community support for FastAPI is not at the
    same level as we have for Django and Flask.
  prefs: []
  type: TYPE_NORMAL
- en: We selected a Flask RESTful extension for REST API development for the continuation
    of our discussion that we had started for the web application development. Note
    that we can build a simple web API using just Flask, and we have done this in
    the previous chapter when we developed a sample web service-based application
    for Google Cloud deployment. In this section, we will focus on using the REST
    architectural style in building the API. This means that we will use the HTTP
    method to perform an operation on a resource that will be represented by a Python
    object.
  prefs: []
  type: TYPE_NORMAL
- en: Important
  prefs: []
  type: TYPE_NORMAL
- en: Flask-RESTful support is unique in the way that it provides a convenient way
    to set the response code and response header as a part of return statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use Flask and the Flask-RESTful extension, we will be required to install
    the Flask-RESTful extension. We can install it in our virtual environment by using
    the following `pip` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Before discussing how to implement a REST API, it is beneficial to get familiar
    with a few terms and concepts related to API.
  prefs: []
  type: TYPE_NORMAL
- en: Resource
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A resource is a key element for a REST API, and this is powered by the Flask-RESTful
    extension. A resource object is defined by extending our class from the base `Resource`
    class, which is available from the Flask-RESTful extension library. The base `Resource`
    class offers several magic functions to assist API development and automatically
    associates HTTP methods with Python methods defined in our resource object.
  prefs: []
  type: TYPE_NORMAL
- en: API endpoint
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An API endpoint is a point of entry to establish communication between client
    software and server software. In simple terms, an API endpoint is alternative
    terminology for a URL of a server or service where a program is listening for
    API requests. With the Flask-RESTful extension, we define an API endpoint by associating
    a certain URL (or URLs) with a resource object. In Flask implementation, we implement
    a resource object by extending from the base `Resource` class.
  prefs: []
  type: TYPE_NORMAL
- en: Routing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The concept of routing for API is similar to web application routing in Flask,
    with the only difference being that in the case of an API, we need to map a `Resource`
    object to one or more endpoint URLs.
  prefs: []
  type: TYPE_NORMAL
- en: Argument parsing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The parsing of request arguments for an API is possible by using the query string
    or HTML form-encoded data. However, this is not a preferred approach because both
    the query string or HTML forms are not meant or designed to be used with an API.
    The recommended approach is to extract the arguments directly from an HTTP request.
    To facilitate this, the Flask-RESTful extension offers a special class, `reqparse`.
    This `reqparse` class is similar to `argparse`, which is a popular choice for
    parsing command-line arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will learn about building a REST API for accessing data from a database
    system.
  prefs: []
  type: TYPE_NORMAL
- en: Developing a REST API for database access
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To illustrate the use of Flask and the Flask-RESTful extension for building
    a REST API, we will revise our web application (`app5.py`) and will offer access
    to the `Student` object (a `Resource` object) using the REST architectural style.
    We are expecting the arguments sent for the `PUT` and `POST` methods inside the
    request body and the API will send back the response in JSON format. The revised
    code of `app5.py` with a REST API interface is shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we started with the initialization of the Flask
    application and the database instance. As a next step, we created an API instance
    using the Flask instance. We achieved this by means of the `api = Api(app)` statement.
    This API instance is the key to develop the rest of the API application and we
    will use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to configure the `reqparse` instance by registering the argument
    we are expecting to parse from the HTTP request. In our code example, we registered
    two arguments of the string type, `name` and `grade`, as shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to create a `Student` model object, which is mostly the same
    as we did in `app5.py`, except that we will add a `serialize` method to convert
    our object into JSON format. This is an important step in serializing the JSON
    response before sending it back to the API clients. There are other solutions
    available to achieve the same, but we selected this option for simplicity reasons.
    The precise sample code for the creation of a `Student` object is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we created two `Resource` classes to access student database objects.
    These are `StudentDao` and `StudentListDao`. These are described next:'
  prefs: []
  type: TYPE_NORMAL
- en: '`StudentDao` offers methods such as `get` and `delete` on the individual resource
    instance, and these methods are mapped to the `GET` and `DELETE` methods of the
    HTTP protocol.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StudentListDao` offers methods such as `get` and `post`. The `GET` method
    is added to provide a list of all resources of the `Student` type using the `GET`
    HTTP method, and the `POST` method is included to add a new resource object using
    the `POST` HTTP method. This is a typical design pattern used to implement CRUD
    functionality for a web resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As regards methods implemented for `StudentDao` and `StudentListDao` classes,
    we returned the status code and the object itself in a single statement. This
    is a convenience offered by the Flask-RESTful extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'A sample code for the `StudentDao` class is shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'A sample code for the `StudentListDao` class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: For our `post` method of the `StudentListDao` class, we used the `reqparse`
    parser to extract the name and the grade arguments from the request. The rest
    of the implementation in the `POST` method is the same as we did for the `app5.py`
    example.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next two lines of our sample API application, we mapped URLs to our
    `Resource` objects. All requests coming for `/students/<student_id>` will be redirected
    to the `StudentDao` resource class. Any request coming for `/students` will be
    redirected to the `StudentListDao` resource class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Note that we skipped the `PUT` method implementation from the `StudentDao` class,
    but it is available with the source code provided for this chapter for completeness.
    For this code example, we did not add error and exception handling to keep the
    code concise for our discussion, but it is highly recommended to have this included
    in our final implementation.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have covered the base concepts and implementation principles
    for developing REST APIs that are adequate for anyone to start building a REST
    API. In the next section, we will extend our knowledge to build a complete web
    application based on a REST API.
  prefs: []
  type: TYPE_NORMAL
- en: Case study– Building a web application using the REST API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we learned how to build a simple web application using Flask
    and how to add a REST API to a business logic layer using a Flask extension. In
    the real world, web applications are typically three tiers: *web layer*, *business
    logic layer*, and *data access layer*. With the popularity of mobile apps, the
    architecture has evolved to have a REST API as a building block for the business
    layer. This affords the freedom of building web apps and mobile apps using the
    same business logic layer. Moreover, the same API can be available for B2B interactions
    with other vendors. This type of architecture is captured in *Figure 10.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 – Web/mobile application architecture'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17189_10_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.2 – Web/mobile application architecture
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case study, we will develop a web application on top of the REST API
    application that was developed for the `Student` model object in the previous
    code example. At a high level, we will have the components in our application
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3 – Sample web application with a REST API as a backend engine'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17189_10_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.3 – Sample web application with a REST API as a backend engine
  prefs: []
  type: TYPE_NORMAL
- en: We already developed a business logic layer and data access layer (ORM) and
    exposed the functionality through two API endpoints. This is discussed in the
    *Using Flask for a REST API* section. We will develop a web application part for
    web access and consume the API offered by the business logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `webapp.py` web application will be based on Flask. The `webapp.py` application
    (referred to as *webapp* moving forward) will be independent of the `api_app.py`
    application (referred to as *apiapp* moving forward) in the sense that the two
    applications will be running separately as two Flask instances, ideally on two
    separate machines. But if we are running the two Flask instances on the same machine
    for testing purposes, we must use different ports and use the local machine IP
    address as a host. Flask uses the *127.0.0.1* address as a host to run its built-in
    web server, which may not be allowed for running two instances. The two applications
    will talk to each other only via a REST API. Additionally, we will develop a few
    Jinja templates to submit requests for create, update, and delete operations.
    We will reuse the `api_py.py` application code as is, but we will develop the
    `webapp.py` application with features such as listing students, adding a new student,
    deleting a student, and updating a student''s data. We will add Python functions
    for each feature one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will begin with the initialization of the Flask instance as we have done
    for previous code examples. The sample code is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will add a `list` function to handle requests with the `/` URL as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will implement an `add` function to process the request for adding
    a new student to the database. Only the request with the `POST` method type is
    mapped to this Python function. The sample code is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we will add a `DELETE` function to handle a request for deleting an existing
    student. The request type mapped to this method is expected to provide the student
    ID as part of the URL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will add two functions to handle the update feature. One function
    (`update`) is used to update the data of a student in the same manner as the `post`
    function does. But before triggering the `update` function, our webapp application
    will offer a form to the user with the current data of a `student` object. The
    second function (`load_student_for_update`) will get a `student` object and send
    it to a Jinja template for users to edit. The code for both functions is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The code inside these functions is no different from what we already discussed
    in relation to previous examples. Therefore, we will not go into the details of
    every line of the code, but we will highlight the key points of this web application
    and its interaction with a REST API application:'
  prefs: []
  type: TYPE_NORMAL
- en: For our web application, we are using two Jinja templates (`main.html` and `update.html`).
    We are also using a template (we called it `base.html`) that is common to both
    templates. The `base.html` template is mainly built using the bootstrap UI framework.
    We will not discuss the details of the Jinja templates and the bootstrap, but
    we will encourage you to get familiar with both using the references provided
    at the end of this chapter. The sample Jinja templates with bootstrap code are
    available with the source code of this chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The root `/` URL of our web application will launch the main page (`main.html`),
    which allows us to add a new student and also provides a list of existing students.
    The following screenshot shows the screenshot of the main page, which will be
    rendered with our `main.html` template:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 10.4 – Main page of the webapp application'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17189_10_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.4 – Main page of the webapp application
  prefs: []
  type: TYPE_NORMAL
- en: If we add the first and last name of a student with a grade and click the `POST`
    request with data of these three input fields. Our webapp application will delegate
    this request to the `add` function. The `add` function will use the corresponding
    REST API of the `apiapp` application to add a new student and the `add` function
    will render the main page again with an updated list of students (including new
    students).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the main webapp page (`main.html`), we added two buttons (`GET` request with
    the `/delete/<id>` URL. This request will be delegated to the `delete` function.
    The `delete` function will use the REST API of the `apiapp` application to delete
    the student from the `SQLite3` database and will render the main page again with
    an updated list of students.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Upon clicking the `GET` request with the `/update/<id>` URL. This request will
    be delegated to the `load_student_for_update` function. This function will first
    load the student data using the REST API of the `apiapp` application, set the
    data in the response, and render the `update.html` template. The `update.html`
    template will show the user an HTML form filled with student data to allow editing.
    The form we developed for the update scenario is shown here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 10.5 – A sample form to update a student'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17189_10_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.5 – A sample form to update a student
  prefs: []
  type: TYPE_NORMAL
- en: After the changes, if a user submits the form by clicking the `POST` request
    with the `/update/<id>` URL. We have registered the `update` function for this
    request. The `update` function will extract data from the request and pass it
    to the REST API of the `apiapp` application. Once the student info is updated,
    we will render the `main.html` page again with an updated list of students.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we have omitted the details of pure web technologies such as
    HTML, Jinja, CSS, and UI frameworks in general. The beauty of web frameworks is
    that they allow any web technologies to be used for customer interfaces, especially
    if we are building our applications using a REST API.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our discussion of building web applications and developing a
    REST API using Flask and its extensions. Web development is not limited to one
    language or one framework. The core principles and architecture remain the same
    across web frameworks and languages. The web development principles you learned
    here will help you to understand any other web framework for Python or any other
    language.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed how to use Python and web frameworks such as Flask
    for developing web applications and a REST API. We started the chapter by analyzing
    the requirements for web development, which include a web framework, a UI framework,
    a web server, a database system, API support, security, and documentation. Later,
    we introduced how to use the Flask framework for building web applications with
    several code examples. We discussed different request types with different HTTP
    methods and how to parse the request data with relevant code examples. We also
    learned about the use of Flask to interact with a database system using an ORM
    library such as SQLAlchemey. In the latter part of the chapter, we introduced
    the role of a web API for web applications, mobile applications, and business-to-business
    applications. We investigated a Flask extension to develop a REST API with a detailed
    analysis by using a sample API application. In the last section, we discussed
    a case study of developing a *student* web application. The web application is
    built using two independent applications, both running as Flask applications.
    One application offers a REST API for the business logic layer on top of a database
    system. The other application provides a web interface to users and consumes the
    REST API interface of the first application to provide access to the student resource
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter provides extensive hands-on knowledge of building web applications
    and a REST API using Flask. The code examples included in this chapter will enable
    you to start creating web applications and write a REST API. This knowledge is
    critical for anyone who is seeking a career in web development and working in
    building a REST API.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore how to use Python to develop microservices,
    a new paradigm of software development.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the purpose of TLS?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When is Flask a superior choice to the Django framework?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the commonly used HTTP methods?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is CRUD and how is it related to a REST API?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Does a REST API only use JSON as a data format?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Flask Web Development*, by Miguel Grinberg'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Advanced Guide to Python 3 Programming*, by John Hunt'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*REST APIs with Flask and Python*, by Jason Myers & Rick Copeland'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Essential SQLAlchemy, 2nd Edition*, by Jose Salvatierra'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Bootstrap 4 Quick Start*, by Jacob Lett'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Jinja online documentation*, available at [https://jinja.palletsprojects.com/](https://jinja.palletsprojects.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main purpose of TLS is to provide encryption of data that is exchanged between
    the two systems on the internet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Flask is a better choice for small- to medium-sized applications and especially
    when the project requirements are expected to change frequently.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`GET` and `POST`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`GET`, `POST`, `PUT`, and `DELETE`).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A REST API can support any string-based format, such as JSON, XML, or HTML.
    Data format support is more related to HTTP's ability to carry the data as part
    of the HTTP body element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
