- en: '*Chapter 10*: Using Python for Web Development and REST API'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 10 章*：使用 Python 进行网络开发和 REST API'
- en: A web application is a type of application that is hosted and run by a **web
    server** within an intranet or on the internet and accessed through a web browser
    on a client device. The use of web browsers as a client interface makes it convenient
    for users to access the applications from anywhere without installing any additional
    software on a local machine. This ease of access has contributed to the success
    and popularity of web applications for more than two decades. The use of web applications
    varies, from delivering static and dynamic content such as Wikipedia and newspapers,
    e-commerce, online games, social networking, training, multimedia content, surveys,
    and blogs, to complex **Enterprise Resource Planning** (**ERP**) applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 网络应用是一种在内部网络或互联网上由 **网络服务器** 托管和运行的应用程序类型，通过客户端设备上的网络浏览器访问。使用网络浏览器作为客户端界面使用户能够从任何地方访问应用程序，而无需在本地机器上安装任何额外的软件。这种易于访问的特性促进了网络应用超过二十年的成功和流行。网络应用的使用范围广泛，从提供静态和动态内容（如维基百科和报纸）、电子商务、在线游戏、社交网络、培训、多媒体内容、调查和博客，到复杂的
    **企业资源规划**（ERP）应用。
- en: Web applications are multi-tier by nature, typically three-tier applications.
    The three tiers are a UI, business logic, and database access. Therefore, developing
    web applications involves interacting with web servers for a UI, an **application
    server** for business logic, and database systems for persisting data. In the
    mobile applications era, the UI may be a mobile app that requires access to the
    business logic tier via a REST API. The availability of a REST API or any sort
    of web services interface has become a fundamental requirement for web applications.
    This chapter discusses how to use Python for building multi-tier web applications.
    There are several frameworks available in Python to develop web applications,
    but we selected **Flask** for our discussion in this chapter because of being
    feature-rich yet lightweight. Web applications are also termed *web apps* to differentiate
    them from mobile apps that are targeted at small devices.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，网络应用是多层的，通常是三层应用。这三层包括用户界面（UI）、业务逻辑和数据库访问。因此，开发网络应用涉及到与用于 UI 的网络服务器、用于业务逻辑的应用服务器以及用于持久化数据的数据库系统进行交互。在移动应用时代，UI
    可能是一个需要通过 REST API 访问业务逻辑层的移动应用。REST API 或任何类型的网络服务接口的可用性已成为网络应用的基本需求。本章将讨论如何使用
    Python 构建 multi-tier 网络应用。Python 中有多个框架可用于开发网络应用，但我们在本章选择 **Flask** 进行讨论，因为它功能丰富但轻量级。网络应用也被称作
    *web apps*，以区分针对小型设备的移动应用。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Learning requirements for web development
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络开发的学习需求
- en: Introducing the Flask framework
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 Flask 框架
- en: Interacting with databases using Python
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Python 与数据库交互
- en: Building a REST API using Python
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Python 构建 REST API
- en: 'Case study: Building a web application using the REST API'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 案例研究：使用 REST API 构建 web 应用程序
- en: By the end of this chapter, you will be able to use the Flask framework to develop
    web applications, interact with databases, and build a REST API or web services.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够使用 Flask 框架开发网络应用，与数据库交互，并构建 REST API 或网络服务。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following are the technical requirements for this chapter:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为本章的技术要求：
- en: You need to have Python 3.7 or later installed on your computer.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要在你的计算机上安装 Python 3.7 或更高版本。
- en: Python Flask library 2.x with its extensions installed on top of Python 3.7
    or later.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python Flask 库 2.x 及其扩展，安装在 Python 3.7 或更高版本之上。
- en: Sample code for this chapter can be found at [https://github.com/PacktPublishing/Python-for-Geeks/tree/master/Chapter10](https://github.com/PacktPublishing/Python-for-Geeks/tree/master/Chapter10).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例代码可在 [https://github.com/PacktPublishing/Python-for-Geeks/tree/master/Chapter10](https://github.com/PacktPublishing/Python-for-Geeks/tree/master/Chapter10)
    找到。
- en: We will start our discussion with key requirements of developing web applications
    and a REST API.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先讨论开发网络应用和 REST API 的关键需求。
- en: Learning requirements for web development
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络开发的学习需求
- en: Developing a web application includes building UI, routing user requests or
    user actions to application endpoints, translating the user input data, writing
    business logic for user requests, interacting with the data layer to read or write
    data, and serving the results back to users. All these development components
    may require different platforms and sometimes even use different programming languages
    for implementation. In this section, we will understand the components and tools
    required for web development, starting with web application frameworks or web
    frameworks.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 开发网络应用程序包括构建 UI、将用户请求或用户操作路由到应用程序端点、转换用户输入数据、编写用户请求的业务逻辑、与数据层交互以读取或写入数据，并将结果返回给用户。所有这些开发组件可能需要不同的平台，有时甚至需要使用不同的编程语言来实现。在本节中，我们将了解网络开发所需的组件和工具，从网络应用程序框架或网络框架开始。
- en: Web frameworks
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络框架
- en: Developing web applications from scratch is time-consuming and tedious. To make
    it convenient for web developers, web application frameworks were introduced in
    the very early days of web development. Web frameworks provide a set of libraries,
    directory structures, reusable components, and deployment tools. Web frameworks
    typically follow an architecture that enables developers to build complex applications
    in less time and in an optimized way.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 从零开始开发网络应用程序既耗时又繁琐。为了方便网络开发者，网络应用程序框架在 Web 开发的早期阶段就被引入了。网络框架提供了一套库、目录结构、可重用组件和部署工具。网络框架通常遵循一种架构，使开发者能够在更短的时间内以优化的方式构建复杂的应用程序。
- en: 'There are several web frameworks available for Python: **Flask** and **Django**
    are the most popular. Both frameworks are free and open source. Flask is a lightweight
    framework and comes with standard functionalities that are required to build a
    web application, but it also allows additional libraries or extensions to use
    as they are needed. On the other hand, Django is a full stack framework that comes
    with all features out of the box without requiring additional libraries. Both
    approaches have merits and demerits, but in the end, we can develop any web application
    with any of these frameworks.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中有几种可用的网络框架：**Flask** 和 **Django** 是最受欢迎的。这两个框架都是免费和开源的。Flask 是一个轻量级框架，附带构建网络应用程序所需的标准功能，但它也允许根据需要使用额外的库或扩展。另一方面，Django
    是一个全栈框架，自带所有功能，无需额外库。这两种方法都有优点和缺点，但最终，我们可以使用这些框架中的任何一个来开发任何网络应用程序。
- en: Flask is considered a better choice if you want to have full control of your
    application with a choice of using external libraries as they fit. Flask is also
    a good fit when project requirements are changing very frequently. Django is suitable
    if you want to have all tools and libraries available to you out of the box and
    you want to focus only on implementing the business logic. Django is a good choice
    for large-scale projects, but can be overkill for simple projects. The learning
    curve for Django is steep and requires prior experience in web development. If
    you are staring at web development with Python for the first time, Flask is the
    way to go. Once you learn Flask, it is easy to adopt the Django framework for
    the next level of web projects.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想对应用程序有完全的控制权，并且可以根据需要选择使用外部库，那么 Flask 被认为是更好的选择。当项目需求非常频繁地变化时，Flask 也是很好的选择。如果你想要所有工具和库都现成可用，并且只想专注于实现业务逻辑，那么
    Django 是合适的。Django 对于大型项目来说是一个很好的选择，但对于简单的项目来说可能有些过度。Django 的学习曲线很陡峭，需要先前的网络开发经验。如果你是第一次用
    Python 开发网络，Flask 是一条可行的道路。一旦你学会了 Flask，就很容易采用 Django 框架来进入下一个层次的 Web 项目开发。
- en: 'When building web applications or any UI applications, we often come across
    the term **Model View Controller** (**MVC**) design pattern. This is an architectural
    design pattern that divides an application into three layers:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建网络应用程序或任何 UI 应用程序时，我们经常会遇到术语 **模型-视图-控制器**（**MVC**）设计模式。这是一种将应用程序分为三个层的架构设计模式：
- en: '**Model**: The model layer represents the data that is typically stored in
    a database.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**：模型层代表通常存储在数据库中的数据。'
- en: '**View**: This layer is the UI with which users interact.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图**：这一层是与用户交互的 UI。'
- en: '**Controller**: The controller layer is designed to provide a logic to handle
    user interactions with the application through UI. For example, a user may want
    to create a new object or update an existing object. The logic of which UI (view)
    to present to the user for the create or update request with or without a model
    (data) is all implemented in the controller layer.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制器**：控制器层旨在通过UI提供处理用户与应用程序交互的逻辑。例如，用户可能想要创建一个新对象或更新现有对象。对于创建或更新请求，以及是否有模型（数据）的情况下，向用户展示哪个UI（视图）的逻辑全部都在控制器层实现。'
- en: Flask does not provide direct support for MVC design patterns, but it can be
    implemented through programming. Django provides close enough implementation for
    MVC, but not fully. The controller in the Django framework is managed by Django
    itself and is not available for writing our own code in it. Django and many other
    web frameworks for Python follow the **Model View Template** (**MVT**) design
    pattern, which is like MVC except the template layer. The template layer in the
    MVT provides specially formatted templates to produce the expected UI with the
    capability to insert dynamic contents within HTML.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Flask不提供对MVC设计模式的直接支持，但可以通过编程实现。Django提供了足够接近MVC的实现，但不是完全的。Django框架中的控制器由Django本身管理，并且不允许在其中编写自己的代码。Django和许多其他Python
    Web框架遵循**模型视图模板**（**MVT**）设计模式，它类似于MVC，除了模板层。MVT中的模板层提供了特别格式化的模板，可以生成预期的UI，并具有在HTML中插入动态内容的能力。
- en: User interface
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户界面
- en: 'A **UI** is the presentation layer of the application, and sometimes it is
    included as part of the web frameworks. But we are discussing it separately here
    to highlight key technologies and choices available for this layer. First and
    foremost, the user is interacting through a browser in **HyperText Markup Language**
    (**HTML**) and **Cascading Style Sheets** (**CSS**). We can build our interfaces
    by writing HTML and CSS directly, but it is tedious and not feasible for delivering
    dynamic content in a timely manner. There are a few technologies available to
    make our lives easier when building UI:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**UI**是应用程序的表示层，有时它被包括在Web框架的一部分中。但在这里我们单独讨论它，以突出这一层的关键技术和选择。首先，用户通过浏览器在**超文本标记语言**（**HTML**）和**层叠样式表**（**CSS**）中进行交互。我们可以直接编写HTML和CSS来构建我们的界面，但这既繁琐又无法及时交付动态内容。有一些技术可以帮助我们在构建UI时更轻松地生活：'
- en: '**UI framework**: These are mainly HTML and CSS libraries to provide different
    classes (styles) for building UI. We still need to write or generate core HTML
    parts of UI, but without worrying about how to beautify our web pages. A popular
    example of a UI framework is **bootstrap**, which is built on top of CSS. It was
    introduced by Twitter for internal use, but was made open source later for anyone
    to use. **ReactJS** is another popular option, but this is more a library than
    a framework and was introduced by Facebook.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UI框架**：这些主要是HTML和CSS库，提供用于构建UI的不同类（样式）。我们仍然需要编写或生成UI的核心HTML部分，但无需担心如何美化我们的网页。一个流行的UI框架示例是**bootstrap**，它建立在CSS之上。它最初由Twitter用于内部使用，但后来开源，任何人都可以使用。**ReactJS**是另一个流行的选择，但它更像是一个库而不是框架，由Facebook引入。'
- en: '**Template engine**: A template engine is another popular mechanism to produce
    web content dynamically. A template is more like a definition of the desired output
    that holds static data as well as placeholders for dynamic contents. The placeholders
    are tokenized strings that are replaced by values at runtime. The output can be
    any format, such as HTML, XML, JSON, or PDF. **Jinja2** is one of the most popular
    templating engines used with Python, and is also included with the Flask framework.
    Django comes with its own templating engine.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模板引擎**：模板引擎是另一种流行的动态生成网页内容的机制。模板更像是对期望输出的定义，它包含静态数据和动态内容的占位符。占位符是标记化字符串，在运行时会被值替换。输出可以是任何格式，如HTML、XML、JSON或PDF。**Jinja2**是Python中最受欢迎的模板引擎之一，它也包含在Flask框架中。Django自带其模板引擎。'
- en: '**Client-side scripting**: A client-side script is a program that is downloaded
    from the web server and is executed by the client web browser. JavaScript is the
    most popular client-side scripting language. There are many JavaScript libraries
    available to make web development easier.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端脚本**：客户端脚本是从网络服务器下载并由客户端网络浏览器执行的程序。JavaScript是最流行的客户端脚本语言。有许多JavaScript库可供使用，使网页开发更加容易。'
- en: We can use more than one technology to develop web interfaces. In a typical
    web project, all three are used in different capacities.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用多种技术来开发Web界面。在一个典型的Web项目中，这三个技术都在不同的层面上被使用。
- en: Web server/application server
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Web服务器/应用服务器
- en: A web server is software that listens to client requests through HTTP and delivers
    content (such as web pages, scripts, images) as per the request type. The web
    server's fundamental job is to serve only static resources and is not capable
    of code execution.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Web服务器是软件，它通过HTTP监听客户端请求，并根据请求类型交付内容（如网页、脚本、图像）。Web服务器的基本任务是仅提供静态资源，并且无法执行代码。
- en: The application server is more specific to a programming language. The main
    job of an application server is to provide access to the implementation of a business
    logic that is written using a programming language such as Python. For many production
    environments, the web server and application server are bundled as one software
    for ease of deployment. Flask comes with its own built-in web server, named **Werkzeug**,
    for the development phase, but this is not recommended for use in production.
    For production, we must use other options such as **Gunicorn**, **uWSGI**, and
    **GCP runtime engines**.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 应用服务器更具体地针对编程语言。应用服务器的主要任务是提供使用Python等编程语言编写的业务逻辑的实现访问。对于许多生产环境，为了便于部署，Web服务器和应用服务器通常捆绑为一个软件。Flask自带内置的Web服务器，名为**Werkzeug**，用于开发阶段，但不建议在生产中使用。对于生产，我们必须使用其他选项，如**Gunicorn**、**uWSGI**和**GCP运行时引擎**。
- en: Database
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据库
- en: This is not a mandatory component, but it is almost essential for any interactive
    web application. Python offers several libraries to access commonly used database
    systems, such as **MySQL**, **MariaDB**, **PostgreSQL**, and **Oracle**. Python
    also comes equipped with a lightweight database server, **SQLite**.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个强制性的组件，但对于任何交互式Web应用来说几乎是必需的。Python提供了几个库来访问常用的数据库系统，如**MySQL**、**MariaDB**、**PostgreSQL**和**Oracle**。Python还配备了轻量级的数据库服务器**SQLite**。
- en: Security
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全性
- en: Security is fundamental for web applications, mainly because the target audience
    is typically internet users, and data privacy is the utmost requirement in such
    environments. **Secure Sockets Layer** (**SSL**) and the more recently introduced
    **Transport Layer Security** (**TLS**) are the minimum acceptable security standards
    to secure the transmission of data between clients and the server. The transport-level
    security requirements are typically handled at the web server or sometimes proxy
    server level. User-level security is the next fundamental requirement, with minimum
    username and password requirements. User security is application-level security
    and developers are mainly responsible for designing and implementing it.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性对于网络应用来说是基本的，主要是因为目标受众通常是互联网用户，在这样的环境中数据隐私是最基本的要求。**安全套接字层**（**SSL**）和最近引入的**传输层安全性**（**TLS**）是确保客户端和服务器之间数据传输安全性的最低可接受标准。传输层的安全性要求通常在Web服务器或有时代理服务器级别处理。用户级别的安全性是下一个基本要求，具有最低的用户名和密码要求。用户安全性是应用级别的安全性，开发者主要负责设计和实现它。
- en: API
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API
- en: The business logic layer in web applications can be consumed by additional clients.
    For example, a mobile app can use the same business logic for a limited or same
    set of features. For **Business to Business** (**B2B**) applications, a remote
    application can submit requests to the business logic layer directly. This is
    all possible if we expose standard interfaces such as a REST API for our business
    logic layer. In the current era, accessing the business logic layer through an
    API is a best practice to make the API ready from day one.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 网络应用中的业务逻辑层可以被额外的客户端使用。例如，一个移动应用可以使用相同业务逻辑来访问有限的或相同的功能集。对于**企业对企业**（**B2B**）应用，远程应用可以直接向业务逻辑层提交请求。如果我们公开标准接口，例如为我们的业务逻辑层提供REST
    API，这一切都是可能的。在当前时代，通过API访问业务逻辑层是一种最佳实践，以确保API从第一天起就准备就绪。
- en: Documentation
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文档
- en: Documentation is as important as writing programming code. This is especially
    true for APIs. When we say that we have an API for our application, the first
    question from API consumers is whether you can share API documentation with us.
    The best way to have API documentation is to use built-in tools that come or possibly
    integrate with our web framework. **Swagger** is a popular tool that is used to
    generate documentation automatically from the comments that are added at the time
    of coding.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 文档与编写编程代码一样重要。这对于API来说尤其如此。当我们说我们的应用程序有一个API时，API消费者首先会问我们是否可以与他们分享API文档。拥有API文档的最佳方式是使用内置工具，或者可能将其集成到我们的Web框架中。**Swagger**是一个流行的工具，它可以从编码时添加的注释自动生成文档。
- en: Now that we have discussed key requirements of web development, we will deep
    dive into how to develop a web application using Flask in the next section.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了Web开发的关键要求，我们将在下一节深入探讨如何使用Flask开发Web应用程序。
- en: Introducing the Flask framework
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Flask框架
- en: Flask is a micro web development framework for Python. The term *micro* indicates
    that the core of Flask is lightweight, but with the flexibility of being extensible.
    A simple example is interacting with a database system. Django comes with libraries
    required to interact with the most common databases. On the other hand, Flask
    allows the use of an extension as per the database type or as per the integration
    approach to achieve the same goal. Another philosophy of Flask is to use *convention
    over configuration*, which means that if we follow standard conventions of web
    development, we have to do less configuration. This makes Flask the best choice
    for beginners to learn web development with Python. We selected Flask for our
    web development, not only because of its ease-of-use capability, but also because
    it allows us to introduce different concepts in a stepwise approach.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Flask是一个用于Python的微型Web开发框架。术语*微型*表明Flask的核心是轻量级的，但具有可扩展的灵活性。一个简单的例子是与数据库系统交互。Django自带了与最常见数据库交互所需的库。另一方面，Flask允许根据数据库类型或集成方法使用扩展来实现相同的目标。Flask的另一个哲学是使用*约定优于配置*，这意味着如果我们遵循Web开发的行业标准，我们就需要做更少的配置。这使得Flask成为Python学习Web开发的最佳选择。我们选择Flask进行Web开发，不仅因为它易于使用，而且它允许我们以逐步的方式介绍不同的概念。
- en: 'In this section, we will learn the following aspects of web applications using
    Flask:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习使用Flask开发Web应用程序的以下方面：
- en: Building a basic web application with routing
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用路由构建基本Web应用程序
- en: Handling requests with different HTTP method types
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理不同HTTP方法类型的请求
- en: Rendering static and dynamic contents using Jinja2
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Jinja2渲染静态和动态内容
- en: Extracting arguments from an HTTP request
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从HTTP请求中提取参数
- en: Interacting with database systems
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与数据库系统交互
- en: Handling errors and exceptions
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理错误和异常
- en: Before we start working with code examples to be used in the next sections,
    Flask 2.x needs to be installed in our virtual environment. We will start with
    a basic web application using Flask.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始使用下一节中的代码示例之前，需要在我们的虚拟环境中安装Flask 2.x。我们将从一个基本的Web应用程序开始，使用Flask。
- en: Building a basic application with routing
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用路由构建基本应用程序
- en: 'We have already used Flask to build a sample application for GCP App Engine
    deployment in the last chapter, *Python Programming for the Cloud*. We will refresh
    our knowledge of using Flask to develop a simple web application. We will start
    with a code example to understand how a web application is built and how routing
    works in it. The complete code example is as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一章“云端的Python编程”中已经使用Flask构建了一个用于GCP App Engine部署的示例应用程序。我们将回顾如何使用Flask开发一个简单的Web应用程序。我们将从一个代码示例开始，了解Web应用程序是如何构建的以及其路由是如何工作的。完整的代码示例如下：
- en: '[PRE0]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s analyze this code example step by step:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步分析这个代码示例：
- en: '`app` in our case) as a first step. The web server will pass all requests from
    clients to this application instance using a protocol known as a `app = Flask(__name__)`.'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的例子中，`app`作为第一步。Web服务器将通过一个称为`app = Flask(__name__)`的协议将所有来自客户端的请求传递给这个应用程序实例。
- en: It is important to pass the module name as an argument to the `Flask` constructor.
    The Flask uses this argument to learn the location of the application, which becomes
    an input to determine the location of other files such as static resources, templates,
    and images. Using `__name__` is the convention (over configuration) to pass to
    the `Flask` constructor, and Flask takes care of the rest.
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将模块名称作为参数传递给`Flask`构造函数是很重要的。Flask使用这个参数来学习应用程序的位置，这将成为确定其他文件位置（如静态资源、模板和图像）的输入。使用`__name__`是将参数传递给`Flask`构造函数的惯例（而不是配置），Flask会处理其余部分。
- en: '`app` instance, now it is the responsibility of the instance to execute a certain
    piece of code to handle the request. This piece of code, which is typically a
    Python function, is called `handler`. The good news is that each request is typically
    (not all the time) associated with a single URL, which makes it possible to define
    a mapping between a URL and a Python function. This URL to Python function mapping
    is called a route. In our code example, we selected a simple approach to define
    this mapping by using the `route` decorator. For example, the `/hello` URL is
    mapped to the `hello` function, and the `/greeting` URL is mapped to the `greeting`
    function. If we prefer to define all routes in one place, we can use `add_url_rule`
    with the app instance for all route definitions.'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`app`实例，现在执行处理请求的特定代码的责任属于该实例。这段代码通常是一个Python函数，被称为`handler`。好消息是每个请求通常（并非总是）与一个单独的URL相关联，这使得定义URL和Python函数之间的映射成为可能。这种URL到Python函数的映射称为路由。在我们的代码示例中，我们通过使用`route`装饰器选择了一种简单的方法来定义这种映射。例如，`/hello`
    URL映射到`hello`函数，`/greeting` URL映射到`greeting`函数。如果我们希望在一个地方定义所有路由，我们可以使用`add_url_rule`与app实例进行所有路由定义。'
- en: '**Handler function**: The handler function after processing the request has
    to send a response back to the client. A response can be a simple string with
    or without HTML, or it can be a complex web page that can be static or dynamic
    based on a template. In our code example, we returned a simple string for illustration
    purposes.'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**处理函数**：处理完请求后，处理函数必须向客户端发送响应。响应可以是一个简单的字符串，包含或不包含HTML，也可以是一个复杂的网页，可以是静态的或基于模板的动态网页。在我们的代码示例中，为了说明目的，我们返回了一个简单的字符串。'
- en: '`app.run()` method, or by using the `flask run` command in a shell. When we
    start this web server, it looks for an `app.py` or `wsgi.py` module by default,
    and it will be loaded automatically with the server if we use the `app.py` name
    for our module file (again, convention over configuration). But if we are using
    a different name for our module (it is our case), we must set an environment variable,
    `FLASK_APP = <module name>`, which will be used by the web server to load the
    module.'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`app.run()`方法，或者在shell中使用`flask run`命令。当我们启动这个Web服务器时，它默认会查找`app.py`或`wsgi.py`模块，并且如果我们的模块文件使用`app.py`名称，它将自动与服务器一起加载（再次强调，惯例胜于配置）。但如果我们为我们的模块使用不同的名称（这正是我们的情况），我们必须设置一个环境变量`FLASK_APP
    = <module name>`，该变量将被Web服务器用于加载模块。'
- en: 'If you have created a Flask project using an IDE such as `http://localhost:5000/`
    and it is accessible only on your local machine by default. If we want to start
    the server using a different hostname and port, we can use the following command
    (or the equivalent Python statement):'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你使用IDE（如`http://localhost:5000/`）创建了一个Flask项目，并且默认情况下它只能通过你的本地机器访问。如果我们想使用不同的主机名和端口启动服务器，我们可以使用以下命令（或等效的Python语句）：
- en: '[PRE1]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`curl` commands:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`curl`命令：'
- en: '[PRE2]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now that we have finished our discussion on the fundamentals of a Flask application,
    we will start exploring topics related to consuming the request and sending a
    dynamic response back to the clients.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了对Flask应用程序基础知识的讨论，我们将开始探索与处理请求和向客户端发送动态响应相关的话题。
- en: Handling requests with different HTTP method types
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理不同HTTP方法类型的请求
- en: HTTP is based on a `GET`, `POST`, `PUT`, `DELETE`, `HEAD`, `PATCH`, and `OPTIONS`.
    `GET` and `POST` are the most frequently used HTTP methods, and so we will cover
    only these to illustrate our web development concepts.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP基于`GET`、`POST`、`PUT`、`DELETE`、`HEAD`、`PATCH`和`OPTIONS`。`GET`和`POST`是最常用的HTTP方法，因此我们将只涵盖这些方法来阐述我们的Web开发概念。
- en: 'But before discussing these two methods, it is also important to understand
    the two key components of HTTP, which are **HTTP request** and **HTTP response**.
    An HTTP request is divided into three parts:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 但在讨论这两种方法之前，了解HTTP的两个关键组件也很重要，即**HTTP请求**和**HTTP响应**。HTTP请求分为三个部分：
- en: '**Request line**: This line includes the HTTP method to be used, the URI of
    the request, and the HTTP protocol (version) to be used:'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**请求行**：这一行包括要使用的 HTTP 方法、请求的 URI 以及要使用的 HTTP 协议（版本）：'
- en: '[PRE3]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`:`)'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:`)'
- en: '`POST` requests inside the body of the HTTP request. For a REST API, we can
    send data for `PUT` or `POST` requests within the body.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 HTTP 请求的正文中的 `POST` 请求。对于 REST API，我们可以在正文内发送 `PUT` 或 `POST` 请求的数据。
- en: 'When we send an HTTP request to a web server, we will get an HTTP response
    as a result. The HTTP response will have similar parts to the HTTP request:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们向 Web 服务器发送 HTTP 请求时，我们将得到一个 HTTP 响应作为结果。HTTP 响应将具有与 HTTP 请求类似的部分：
- en: '`200` or something in the range of `200-299` indicates success. Error codes
    are in the range of `400-499` for client-side errors, and in the range of `500-599`
    for server-side errors.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`200` 或 `200-299` 范围内的代码表示成功。客户端错误代码在 `400-499` 范围内，服务器端错误代码在 `500-599` 范围内。'
- en: '**Header**: Header fields are similar to the HTTP request header fields.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**头部**：头部字段类似于 HTTP 请求头部字段。'
- en: '**Body** (optional): Although optional, this is the key part of an HTTP response.
    This can include HTML pages for web applications or data in any other format.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**正文**（可选）：尽管是可选的，但这却是 HTTP 响应的关键部分。这可以包括 Web 应用程序的 HTML 页面或任何其他格式的数据。'
- en: '`GET` is used to send a request for a certain resource identified in the URL
    with the option to add a **query string** as part of the URL. The *?* is added
    in the URL to keep the query string separate from the base URL. For example, if
    we search for the word *Python* on Google, we will see a URL as follows in the
    browser:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`GET` 用于发送对 URL 中标识的资源进行请求，并可选择将 **查询字符串** 作为 URL 的一部分添加。在 URL 中添加 *?* 可以将查询字符串与基本
    URL 区分开来。例如，如果我们想在 Google 上搜索单词 *Python*，我们将在浏览器中看到一个如下所示的 URL：'
- en: '[https://www.google.com/search?q=Python](https://www.google.com/search?q=Python)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.google.com/search?q=Python](https://www.google.com/search?q=Python)'
- en: In this URL, `q=Python` is a query string. A query string is used to carry data
    in the form of key-value pairs. This approach of accessing resources is popular
    because of its simplicity but does have its limitations. The data in a query string
    is visible in the URL, which means we cannot send sensitive information such as
    a username and password as a query string. The length of the query string cannot
    be more than 255 characters. However, the `GET` method is in use for searching
    websites such as Google and YAHOO for reasons of simplicity. In the case of the
    `POST` method, the data is sent via the HTTP request body, which eliminates the
    limitations of the `GET` method. The data does not appear as part of the URL and
    there is no limit in terms of the data that we can send to the HTTP server. There
    is also no limit in terms of the data types supported using the `POST` method.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 URL 中，`q=Python` 是一个查询字符串。查询字符串用于以键值对的形式携带数据。这种访问资源的方法因其简单性而受到欢迎，但也存在一些限制。查询字符串中的数据在
    URL 中是可见的，这意味着我们不能将敏感信息，如用户名和密码，作为查询字符串发送。查询字符串的长度不能超过 255 个字符。然而，`GET` 方法因其简单性而被用于搜索网站，如
    Google 和 YAHOO。在 `POST` 方法的情况下，数据通过 HTTP 请求正文发送，这消除了 `GET` 方法的限制。数据不会作为 URL 的一部分出现，并且我们可以发送到
    HTTP 服务器的数据没有限制。使用 `POST` 方法支持的数据类型也没有限制。
- en: 'Flask provides a few convenient ways to identify whether a request is sent
    using `GET` or `POST` or is using any other method. In our next code example,
    we illustrate two approaches; the first approach uses the `route` decorator, with
    an exact list of the method types expected, and the second approach is using a
    decorator specific for the HTTP method type, such as the `get` decorator and the
    `post` decorator. The use of both approaches is illustrated in the next code example,
    followed by a detailed analysis:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Flask 提供了一些方便的方法来识别请求是使用 `GET` 或 `POST` 发送，还是使用其他任何方法。在我们的下一个代码示例中，我们将展示两种方法；第一种方法使用
    `route` 装饰器，并指定期望的方法类型列表，第二种方法使用特定于 HTTP 方法类型的装饰器，例如 `get` 装饰器和 `post` 装饰器。这两种方法的使用将在下一个代码示例中展示，随后将进行详细分析：
- en: '[PRE4]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s discuss the three route definitions and corresponding functions in our
    sample code one by one:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一讨论我们示例代码中的三个路由定义及其对应的功能：
- en: In the first route definition (`@app.route('/submit', methods=['GET']))`, we
    used the `route` decorator for mapping a URL, with requests of the `GET` type
    to a Python function. With this decorator setting, our Python function will handle
    requests with the `GET` method just for the `/submit` URL.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第一个路由定义（`@app.route('/submit', methods=['GET'])`）中，我们使用了`route`装饰器来映射一个URL，将`GET`类型的请求映射到一个Python函数。通过这个装饰器的设置，我们的Python函数将仅处理`/submit`
    URL的`GET`方法请求。
- en: In the second route definition (`@app.post('/submit'))`, we used the `post`
    decorator and only specify the request URL with it. This is a simplified version
    of mapping a request with the `POST` method to a Python function. This new setting
    is equivalent to the first route definition, but with the `POST` method type in
    a simplified form. We can achieve the same for a `GET` method by using the `get`
    decorator.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第二个路由定义（`@app.post('/submit')`）中，我们使用了`post`装饰器，并且只使用它指定请求URL。这是将请求与`POST`方法映射到Python函数的简化版本。这个新设置与第一个路由定义等效，但以简化的形式包含了`POST`方法类型。我们可以通过使用`get`装饰器以相同的方式为`GET`方法实现这一点。
- en: In the third route definition (`@app.route('/submit2', methods = ['GET', 'POST'])`),
    we mapped a single URL with requests using both the `POST` and `GET` methods to
    a single Python function. This is a convenient approach when we are expecting
    to handle any request method by using a single handler (Python function). Inside
    the Python function, we used the `method` attribute of the request object to identify
    whether the request is of the `GET` or `POST` type. Note that the request object
    is made available to our Flask app by the web server once we import the `request`
    package into our program. This approach gives flexibility for clients to submit
    requests using any one of the two methods using the same URL and, as a developer,
    we mapped them to a single Python function.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第三个路由定义（`@app.route('/submit2', methods = ['GET', 'POST'])`）中，我们将一个URL的请求使用`POST`和`GET`两种方法映射到单个Python函数。当我们期望使用单个处理器（Python函数）处理任何请求方法时，这是一个方便的方法。在Python函数内部，我们使用了请求对象的`method`属性来识别请求是`GET`类型还是`POST`类型。请注意，一旦我们将`request`包导入到我们的程序中，Web服务器就会将请求对象提供给我们的Flask应用。这种方法为客户使用相同的URL提交两种方法之一的请求提供了灵活性，作为开发者，我们将它们映射到单个Python函数。
- en: 'We can test this code example more conveniently through the `curl` utility
    because it will not be easy to submit a `POST` request without defining an HTML
    form. The following `curl` commands can be used to send HTTP requests to our web
    application:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过`curl`实用程序更方便地测试这个代码示例，因为它在未定义HTML表单的情况下提交`POST`请求将不会很容易。以下`curl`命令可以用来向我们的Web应用发送HTTP请求：
- en: '[PRE5]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Next, we will discuss how to render a response from static pages and templates.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论如何从静态页面和模板中渲染响应。
- en: Rendering static and dynamic contents
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染静态和动态内容
- en: The static contents are important for a web application as they include CSS
    and JavaScript files. The static files can be served directly by the web server.
    Flask can also make this happen if we create a directory called `static` in our
    project and redirect the client to the static file location.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 静态内容对于Web应用来说非常重要，因为它们包括CSS和JavaScript文件。静态文件可以直接由Web服务器提供。如果我们在我们项目的目录中创建一个名为`static`的目录并将客户端重定向到静态文件位置，Flask也可以实现这一点。
- en: 'Dynamic contents can be created using Python, but it is tedious and requires
    quite an effort to maintain such a code in Python. The recommended approach is
    to use a template engine such as **Jinja2**. Flask comes with a Jinja2 library,
    so there is no additional library to install, nor do we need to add any additional
    configuration to set up Jinja2\. A sample code with two functions, one handling
    a request for static contents and the other for dynamic contents, is shown next:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用Python创建动态内容，但这很繁琐，并且需要相当大的努力来维护这样的Python代码。推荐的方法是使用模板引擎，如**Jinja2**。Flask自带Jinja2库，因此无需安装任何额外的库，也无需进行任何额外的配置来设置Jinja2。下面是一个包含两个函数的示例代码，一个处理静态内容的请求，另一个处理动态内容的请求：
- en: '[PRE6]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'For a better understanding of this sample code, we will highlight the key points:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这段示例代码，我们将突出关键点：
- en: We import additional modules from Flask such as `url_for`, `redirect`, and `render_template`.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们从Flask中导入额外的模块，例如`url_for`、`redirect`和`render_template`。
- en: For the `/hello` route, we build a URL using the `url_for` function with the
    `static` directory and the name of the HTML file as arguments. We send the response,
    which is an instruction to the browser, to redirect the client to the URL of a
    static file location. The redirect instructions are indicated to the web browser
    by using a status code in the range of `300-399`, which is automatically set by
    Flask when we used the `redirect` function.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`/hello`路由，我们使用`url_for`函数，以`static`目录和HTML文件名为参数构建URL。我们发送响应，这是一条指示浏览器将客户端重定向到静态文件位置URL的指令。重定向指令通过使用范围在`300-399`之间的状态码来指示Web浏览器，这是Flask在调用`redirect`函数时自动设置的。
- en: 'For the `/gtreeting` route, we render a Jinja template, `app3_d.html`, using
    the `render_template` function. We also passed a greeting message string as a
    value to a variable for the template. The greeting variable will be available
    to the Jinja template, as shown in the following template excerpt from the `app3_d.html`
    file:'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`/gtreeting`路由，我们使用`render_template`函数渲染Jinja模板`app3_d.html`。我们还传递了一个问候消息字符串作为变量的值给模板。问候变量将可用于Jinja模板，如下所示，这是从`app3_d.html`文件中的模板摘录：
- en: '[PRE7]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This sample web application can be accessed using a web browser and using the
    `curl` utility. In the next section, we will discuss how to extract parameters
    from different types of requests.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例Web应用程序可以使用Web浏览器和`curl`实用程序访问。在下一节中，我们将讨论如何从不同类型的请求中提取参数。
- en: Extracting parameters from an HTTP request
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从HTTP请求中提取参数
- en: 'Web applications are different from websites because they are interactive with
    users and this is not possible without exchanging data between a client and a
    server. In this section, we will discuss how to extract data from a request. Depending
    on the type of HTTP method used, we will adopt a different approach. We will cover
    the following three types of requests as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Web应用程序与网站不同，因为它们与用户是交互式的，而没有客户端和服务器之间的数据交换这是不可能的。在本节中，我们将讨论如何从请求中提取数据。根据使用的HTTP方法类型，我们将采用不同的方法。我们将按以下方式涵盖以下三种类型的请求：
- en: Parameters as part of the request URL
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数作为请求URL的一部分
- en: Parameters as query string with a `GET` request
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`GET`请求作为查询字符串的参数
- en: Parameters as HTML form data with a `POST` request
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`POST`请求作为HTML表单数据的参数
- en: 'A sample code with three different routes to cover the three aforementioned
    request types is as follows. We are rendering a Jinja template (`app4.html`),
    which is the same as we used for the `app3_d.html` file, except the variable name
    is `name` instead of `greeting`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个包含三种不同路由的示例代码，以涵盖上述三种请求类型。我们渲染了一个Jinja模板（`app4.html`），它与`app3_d.html`文件相同，只是变量名是`name`而不是`greeting`：
- en: '[PRE8]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, we will discuss the parameter extraction approach for each case:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论每种情况的参数提取方法：
- en: For the first set of routes (`app.route`), we defined a route in a way that
    any text after `/hello/` is considered parameters with the request. We can set
    zero or one or two parameters, and our Python function is able to handle any combination
    and returns the name (which can be empty) to the template as a response. This
    approach is good for simple cases of parameter passing to the server program.
    This is a popular choice in REST API development to access a single resource instance.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于第一组路由（`app.route`），我们定义路由的方式是，任何在`/hello/`之后的文本都被视为与请求一起的参数。我们可以设置零个、一个或两个参数，我们的Python函数能够处理任何组合，并将名称（可能为空）作为响应返回给模板。这种方法适用于简单地将参数传递给服务器程序的情况。在REST
    API开发中，这是一种流行的选择，用于访问单个资源实例。
- en: For the second route (`app.get`), we are extracting query string parameters
    from the `args` dictionary object. We can fetch the parameter value either by
    using its name as a dictionary key or by using the `GET` method with the second
    argument as a default value. We used an empty string as a default value with the
    `GET` method. We showed both options, but we recommend using the `GET` method
    if you want to set a default value in case no parameter exists in the request.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于第二个路由（`app.get`），我们从`args`字典对象中提取查询字符串参数。我们可以通过使用其名称作为字典键或使用带有第二个参数作为默认值的`GET`方法来获取参数值。我们使用空字符串作为`GET`方法的默认值。我们展示了两种选项，但如果我们想在请求中不存在参数的情况下设置默认值，我们推荐使用`GET`方法。
- en: For the third route (`app.post`), parameters come as form data as part of the
    body of the HTTP request and we will be using form dictionary object to extract
    these parameters. Again, we used the parameter name as a dictionary key and also
    used the `GET` method for illustration purposes.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于第三个路由（`app.post`），参数作为表单数据作为HTTP请求正文的一部分，我们将使用表单字典对象来提取这些参数。再次强调，我们使用参数名称作为字典键，并且为了说明目的，还使用了`GET`方法。
- en: 'To test these scenarios, we recommend using the `curl` utility, especially
    for `POST` requests. We tested the application with the following commands:'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了测试这些场景，我们建议使用`curl`工具，特别是对于`POST`请求。我们使用以下命令测试了应用程序：
- en: '[PRE9]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the next section, we will discuss how to interact with a database in Python.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论如何在Python中与数据库交互。
- en: Interacting with database systems
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与数据库系统交互
- en: A full stack web application requires the persistence of structured data, so
    knowledge and experience of working with a database are prerequisites for web
    development. Python and Flask can integrate with most SQL or no-SQL database systems.
    Python itself comes with a lightweight SQLite database with the module name `sqlite3`.
    We will use SQLite because it does not require setting up a separate database
    server and works very well for small-scale applications. For production environments,
    we must use other database systems, such as MySQL or MariaDB, or PostgreSQL. To
    access and interact with a database system, we will use one of the Flask extensions,
    `Flask-SQLAlchemy`. The `Flask-SQLAlchemy` extension is based on the `SQLAlchemy`
    library of Python and makes the library available to our web application. The
    `SQLAlchemy` library provides an `SQLAlchemy` or a similar library to work with
    database systems.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 一个全栈Web应用程序需要持久化结构化数据，因此了解和使用数据库的知识和经验是Web开发的先决条件。Python和Flask可以与大多数SQL或非SQL数据库系统集成。Python自带一个轻量级的SQLite数据库，模块名为`sqlite3`。我们将使用SQLite，因为它不需要设置单独的数据库服务器，并且非常适合小型应用程序。对于生产环境，我们必须使用其他数据库系统，例如MySQL或MariaDB，或者PostgreSQL。为了访问和与数据库系统交互，我们将使用Flask扩展之一，`Flask-SQLAlchemy`。`Flask-SQLAlchemy`扩展基于Python的`SQLAlchemy`库，并将库提供给我们的Web应用程序。`SQLAlchemy`库提供了一个`SQLAlchemy`或类似的库来与数据库系统交互。
- en: To interact with any database system from our application, we need to create
    our Flask application instance as usual. The next step is to configure the application
    instance with the URL for our database location (a file in the case of SQLite3).
    Once the application instance is created, we will create a `SQLAlchemy` instance
    by passing it to the application instance. When using a database such as SQLite,
    we only have to initialize the database the first time. It can be initiated from
    a Python program, but we will not favor this approach so as to avoid the database
    reset every time we start our application. It is recommended to initialize the
    database one time only from a command line using the `SQLAlchemy` instance. We
    will discuss the exact steps of initializing the database after our code example.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要从我们的应用程序与任何数据库系统交互，我们需要像往常一样创建我们的Flask应用程序实例。下一步是使用我们的数据库位置URL（对于SQLite3的情况是一个文件）配置应用程序实例。一旦创建了应用程序实例，我们将通过将其传递给应用程序实例来创建一个`SQLAlchemy`实例。当使用如SQLite这样的数据库时，我们只需要在第一次初始化数据库。它可以由Python程序启动，但我们将不倾向于这种方法，以避免每次启动应用程序时都重置数据库。建议只使用`SQLAlchemy`实例从命令行初始化数据库一次。我们将在代码示例之后讨论初始化数据库的确切步骤。
- en: 'To illustrate the use of the `SQLAlchemy` library with our web application,
    we will create a simple application to *add*, *list*, and *delete* student objects
    from a database table. Here is a sample code of the application to initialize
    the Flask application and the database instance (a `SQLAlchemy` instance) and
    also to create a `Model` object of the `Student` class:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明`SQLAlchemy`库与我们的Web应用程序的使用，我们将创建一个简单的应用程序来从数据库表中*添加*、*列出*和*删除*学生对象。以下是初始化Flask应用程序和数据库实例（一个`SQLAlchemy`实例）以及创建`Student`类`Model`对象的示例代码：
- en: '[PRE10]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Once we have created the `SQLAlchemy` instance, `db`, we can work with database
    objects. The beauty of an ORM library such as `SQLAlchemy` is that we can define
    a database schema, known as a `Student`, which is inherited from a base class,
    `db.Model`. In this model class, we defined the `id`, `name`, and `grade` attributes
    that will correspond to three columns in a database table, *Student*, in the `SQLite3`
    database instance. For each attribute, we defined its data type with the maximum
    length, whether it has a primary key, and whether it is nullable. These additional
    attribute definitions are important to configure the database tables in an optimized
    way.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了`SQLAlchemy`实例`db`，我们就可以处理数据库对象。像`SQLAlchemy`这样的ORM库的优点在于，我们可以定义一个数据库模式，称为`Student`，它继承自基类`db.Model`。在这个模型类中，我们定义了`id`、`name`和`grade`属性，这些属性将对应于`SQLite3`数据库实例中的`Student`数据库表中的三列。对于每个属性，我们定义了其数据类型、最大长度、是否为主键以及是否可为空。这些额外的属性定义对于以优化方式配置数据库表非常重要。
- en: 'In the following code snippet, we will illustrate a Python function, `list_students`,
    for getting a list of student objects from the database. This function is mapped
    to the `/list` URL of our sample web application and it returns all `Student`
    objects from the database table by using the `all` method on the `query` instance
    (an attribute of the `db` instance). Note that the `query` instance and its methods
    are available from the base class, `db.Model`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码片段中，我们将展示一个Python函数，`list_students`，用于从数据库中获取学生对象列表。此函数映射到我们示例Web应用的`/list`
    URL，并通过在`query`实例（`db`实例的一个属性）上使用`all`方法来返回数据库表中的所有`Student`对象。请注意，`query`实例及其方法都来自基类`db.Model`：
- en: '[PRE11]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the next code snippet, we will write a function (`add_student`) to add students
    to the database table. This function is mapped to the `/add` URL and expects the
    student''s name and their grade passed as request parameters using the `GET` method.
    To add a new object to the database, we will create a new instance of the `Student`
    class with the requisite attribute values and then use the `db.Session` instance
    to add to the ORM layer by using the `add` function. The `add` function will not
    add the instance to the database by itself. We will use the `commit` method to
    push it to the database table. Once a new student is added to our database table,
    we redirect control to the `/list` URL. The reason we used a redirect to this
    URL is that we want to return the latest list of students after adding a new one
    and to reuse the `list_students` function, which we already implemented. The complete
    code for the `add_student` function is as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个代码片段中，我们将编写一个函数（`add_student`）用于将学生添加到数据库表中。此函数映射到`/add` URL，并期望通过`GET`方法使用请求参数传递学生的姓名和成绩。为了将新对象添加到数据库中，我们将创建一个具有必要属性值的`Student`类的新实例，然后使用`db.Session`实例通过`add`函数将其添加到ORM层。`add`函数本身不会将实例添加到数据库中。我们将使用`commit`方法将其推送到数据库表。一旦新学生被添加到我们的数据库表中，我们将控制权重定向到`/list`
    URL。我们之所以使用重定向到该URL，是因为我们希望在添加新学生后返回最新的学生列表，并重用我们已实现的`list_students`函数。`add_student`函数的完整代码如下：
- en: '[PRE12]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the last part of this code example, we will write a Python function (`delete_student`)
    to delete a student from the database table. This function is mapped to the `/delete<int:id>`
    URL. Note that we are expecting the client to send the student ID (which we sent
    with a list of students using the `list` request). To delete a student, first,
    we query for the exact student instance by using the student ID. This is achieved
    by using the `filter_by` method on the `query` instance. Once we have the exact
    `Student` instance, we use the `delete` method of the `db.Session` instance and
    then commit the changes. As with the `add_student` function, we redirected the
    client to the `/list` URL to return an up-to-date list of students to our Jinja
    template:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码示例的最后部分，我们将编写一个Python函数（`delete_student`）用于从数据库表中删除学生。此函数映射到`/delete<int:id>`
    URL。请注意，我们期望客户端发送学生ID（我们通过`list`请求发送学生列表）。要删除学生，首先，我们使用学生ID通过`filter_by`方法在`query`实例上查询确切的`Student`实例。一旦我们有了确切的`Student`实例，我们使用`db.Session`实例的`delete`方法，然后提交更改。与`add_student`函数一样，我们将客户端重定向到`/list`
    URL，以返回更新后的学生列表到我们的Jinja模板：
- en: '[PRE13]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To show a list of students in a browser, we created a simple Jinja template
    (`app5.html`). The `app5.html` template file will provide a list of students in
    a table format. It is important to note that we use a Jinja `for` loop to build
    the HTML table rows dynamically, as shown in the following Jinja template:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在浏览器中显示学生列表，我们创建了一个简单的Jinja模板（`app5.html`）。`app5.html`模板文件将以表格格式提供学生列表。需要注意的是，我们使用Jinja
    `for`循环动态构建HTML表格行，如下面的Jinja模板所示：
- en: '[PRE14]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Before starting this application, we should initialize the database schema
    as a one-time step. This can be done by using a Python program, but we have to
    make sure the code is executed only once or only when the database is not already
    initialized. A recommended approach is to do this step manually using the Python
    shell. In the Python shell, we can import the `db` instance from our application
    module and then use the `db.create_all` method to initialize the database as per
    the model classes defined in our program. Here are the sample commands to be used
    for our application for database initialization:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始此应用程序之前，我们应该初始化数据库模式作为一次性步骤。这可以通过使用Python程序来完成，但我们必须确保代码只执行一次或仅在数据库尚未初始化时执行。一种推荐的方法是手动使用Python
    shell来完成此步骤。在Python shell中，我们可以从我们的应用程序模块导入`db`实例，然后使用`db.create_all`方法根据我们程序中定义的模型类初始化数据库。以下是用于我们应用程序数据库初始化的示例命令：
- en: '[PRE15]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: These commands will create a `student.db` file in the same directory where we
    have our program. To reset the database, we can either delete the `student.db`
    file and rerun the initialization commands, or we can use the `db.drop_all` method
    in the Python shell.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令将在我们程序所在的同一目录中创建一个`student.db`文件。要重置数据库，我们可以删除`student.db`文件并重新运行初始化命令，或者我们可以在Python
    shell中使用`db.drop_all`方法。
- en: 'We can test the application using the `curl` utility or through a browser using
    the following URLs:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`curl`实用程序或通过以下URL通过浏览器测试应用程序：
- en: '`http://localhost:5000/list`'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost:5000/list`'
- en: '`http://localhost:5000/add?fname=John&Lee=asif&grade=9`'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost:5000/add?fname=John&Lee=asif&grade=9`'
- en: '`http://localhost:5000/delete/<id>`'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost:5000/delete/<id>`'
- en: Next, we will discuss how to handle errors in a Flask-based web application.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论如何在基于Flask的Web应用程序中处理错误。
- en: Handling errors and exceptions in web applications
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理Web应用程序中的错误和异常
- en: 'In all our code examples, we did not pay attention to how to deal with situations
    when a user enters an incorrect URL in their browser or sends a wrong set of arguments
    to our application. This was not a design intention, but the aim was to focus
    on the key components of web applications first. The beauty of web frameworks
    is that they typically support error handling by default. If any error occurs,
    an appropriate status code is returned automatically. The error codes are well
    defined as part of the HTTP protocol. For example, the error codes from `400`
    *to* `499` indicate errors with client requests, and the error codes from `500`
    *to* `599` indicate problems with the server while executing the request. A few
    commonly observed errors are summarized next:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们所有的代码示例中，我们没有关注当用户在浏览器中输入错误的URL或向我们的应用程序发送错误参数集时的处理情况。这并不是设计意图，而是首先关注Web应用程序的关键组件。Web框架的美丽之处在于它们通常默认支持错误处理。如果发生任何错误，将自动返回适当的状态码。错误代码作为HTTP协议的一部分被很好地定义。例如，从`400`到`499`的错误代码表示客户端请求的错误，而从`500`到`599`的错误代码表示在执行请求时服务器的问题。以下是一些常见的错误总结：
- en: '![Table 10.1 – A commonly observed HTTP errors'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '![表10.1 – 常见观察到的HTTP错误'
- en: '](img/B17189_10_Table_1.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17189_10_Table_1.jpg)'
- en: Table 10.1 – A commonly observed HTTP errors
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 表10.1 – 常见观察到的HTTP错误
- en: A complete list of HTTP status codes and errors is available at [https://httpstatuses.com/](https://httpstatuses.com/).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP状态码和错误的完整列表可在[https://httpstatuses.com/](https://httpstatuses.com/)找到。
- en: The Flask framework also comes with an error handling framework. While handling
    client requests, if our program breaks, a `500 Internal Server Error` is returned
    by default. If a client requests a URL that is not mapped to any Python function,
    Flask will return a `404 Not Found` error to the client. These different error
    types are implemented as subclasses of the `HTTPException` class, which is part
    of the Flask library.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Flask框架还附带了一个错误处理框架。在处理客户端请求时，如果我们的程序崩溃，默认会返回`500 内部服务器错误`。如果客户端请求一个未映射到任何Python函数的URL，Flask将向客户端返回`404
    未找到`错误。这些不同的错误类型作为`HTTPException`类的子类实现，该类是Flask库的一部分。
- en: 'If we want to handle these errors or exceptions with a custom behavior or custom
    message, we can register our handler with the Flask application. Note that an
    error handler is a function in Flask that is only triggered when an error occurs,
    and we can associate a specific error or generic exception with our handlers.
    We build a sample code to illustrate the concept at a high level. First, we will
    illustrate a simple web application with two functions ( `hello` and `greeting`)
    for handling two URLs, as shown in the following sample code:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要用自定义行为或自定义消息来处理这些错误或异常，我们可以将我们的处理器注册到 Flask 应用程序中。请注意，错误处理器是 Flask 中仅在发生错误时才会触发的一个函数，我们可以将特定的错误或通用异常与我们的处理器关联。我们将构建一个示例代码来从高层次上说明这个概念。首先，我们将通过以下示例代码展示一个简单的
    Web 应用程序，其中包含两个函数（`hello` 和 `greeting`）来处理两个 URL：
- en: '[PRE16]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To handle the errors, we will register our handler against the app instance
    using the `errorHandler` decorator. For our sample code (shown next), we registered
    a `page_not_found` handler against error code `404` for the Flask application.
    For error code `500`, we registered an `internal_error` function as an error handler.
    In the end, we registered `generic_handler` for the `HTTPException` class. This
    generic handler will catch the error or exception other than `404` and `500`.
    A sample code with all three handlers is shown next:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理错误，我们将使用 `errorHandler` 装饰器将我们的处理器注册到应用程序实例。对于我们的示例代码（如下所示），我们将 `page_not_found`
    处理器注册到 Flask 应用程序的 `404` 错误代码。对于 `500` 错误代码，我们注册了一个 `internal_error` 函数作为错误处理器。最后，我们将
    `generic_handler` 注册到 `HTTPException` 类。这个通用处理器将捕获除 `404` 和 `500` 之外的错误或异常。下面展示了包含所有三个处理器的示例代码：
- en: '[PRE17]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'For illustration purposes, we also wrote basic Jinja templates with custom
    messages; `error404.html`, `error500.html`, and `error.html`. The `error404.html`
    and `error500.html` templates are using the message that is hardcoded in the template.
    However, the `error.html` template expects the custom message coming from the
    web server. To test these sample applications, we will request the following through
    a browser or the `curl` utility:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明目的，我们还编写了带有自定义消息的基本 Jinja 模板；`error404.html`、`error500.html` 和 `error.html`。`error404.html`
    和 `error500.html` 模板使用模板中硬编码的消息。然而，`error.html` 模板期望从 Web 服务器接收自定义消息。为了测试这些示例应用程序，我们将通过浏览器或
    `curl` 工具请求以下内容：
- en: '`GET http://localhost:5000/`: We will expect a normal response in this case.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET http://localhost:5000/`：在这种情况下，我们将期望一个正常响应。'
- en: '`GET http://localhost:5000/hello`: We will expect a `404` error as there is
    no Python function mapped to this URL and the Flask app will render an `error404.html`
    template.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET http://localhost:5000/hello`：我们将期望出现 `404` 错误，因为没有 Python 函数映射到这个 URL，Flask
    应用程序将渲染一个 `error404.html` 模板。'
- en: '`GET http://localhost:5000/greeting`: We will expect a `500` error because
    we try to divide a number by zero to raise the `ZeroDivisionError` error. Since
    this is a server-side error (`500`), it will trigger our `interna l_error` handler,
    which renders a generic `error500.html` template.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET http://localhost:5000/greeting`：我们将期望出现 `500` 错误，因为我们尝试将一个数字除以零以引发 `ZeroDivisionError`
    错误。由于这是一个服务器端错误（`500`），它将触发我们的 `internal_error` 处理器，该处理器渲染一个通用的 `error500.html`
    模板。'
- en: '`POST http://localhost:5000/`: To emulate the role of a generic handler, we
    will send a request that triggers an error code other than `404` and `500`. This
    is easily possible by sending a `POST` request for a URL that is expecting a `GET`
    request and the server will raise a `405` error in this case (for an unsupported
    HTTP method). We have no error handler specific for error code 405 in our application,
    but we have registered a generic handler with `HTTPException`. This generic handler
    will handle this error and render a generic `error.html` template.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST http://localhost:5000/`：为了模拟通用处理器的角色，我们将发送一个触发除 `404` 和 `500` 之外错误代码的请求。这很容易通过发送一个期望
    `GET` 请求的 URL 的 `POST` 请求来实现，在这种情况下，服务器将引发 `405` 错误（对于不支持的 HTTP 方法）。在我们的应用程序中，我们没有针对错误代码
    405 的特定错误处理器，但我们已注册了一个带有 `HTTPException` 的通用处理器。这个通用处理器将处理这个错误并渲染一个通用的 `error.html`
    模板。'
- en: This concludes our discussion of using the Flask framework for web application
    development. Next, we will explore building a REST API using Flask extensions.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们关于使用 Flask 框架进行 Web 应用程序开发的讨论。接下来，我们将探索使用 Flask 扩展构建 REST API。
- en: Building a REST API
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建 REST API
- en: '**REST**, or **ReST**, is an acronym for **Representational State Transfer**,
    which is an architecture for client machines to request information about the
    resources that exist on a remote machine. **API** stands for **Application Programming
    Interface**, which is a set of rules and protocols for interacting with application
    software running on different machines. The interaction of different software
    entities is not a new requirement. In the last few decades, there have been many
    technologies proposed and invented to make software-level interactions seamless
    and convenient. A few noticeable technologies include **Remote Procedure Call**
    (**RPC**), **Remote Method Invocation** (**RMI**), CORBA, and SOAP web services.
    These technologies have limitations in terms of being tied to a certain programming
    language (for example, RMI) or tied to a proprietary transport mechanism, or using
    only a certain type of data format. These limitations have been almost entirely
    eliminated by the RESTful API, which is commonly known as the REST API.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**REST**，或**ReST**，是**表示状态转移**的缩写，这是一种客户端机器请求关于远程机器上存在的资源信息的架构。**API**代表**应用程序编程接口**，它是一套规则和协议，用于与运行在不同机器上的应用程序软件进行交互。不同软件实体之间的交互不是新的需求。在过去的几十年里，已经提出了许多技术和发明，以使软件级交互无缝且方便。一些值得注意的技术包括**远程过程调用**（**RPC**）、**远程方法调用**（**RMI**）、CORBA和基于SOAP的Web服务。这些技术在某些方面存在局限性，例如与特定的编程语言（例如RMI）绑定或绑定到专有传输机制，或仅使用某种类型的数据格式。RESTful
    API（通常称为REST API）几乎消除了这些限制。'
- en: 'The flexibility and simplicity of the HTTP protocol make it a favorable candidate
    to use as a transport mechanism for a REST API. Another advantage of using HTTP
    is that it allows several data formats for data exchange (such as text, XML, and
    JSON) and is not constrained to one format, such as how XML is the only format
    for SOAP-based APIs. The REST API is not tied to any one specific language, which
    makes it a de facto choice for building APIs for web interactions. An architectural
    view of a REST API call from a REST client to a REST server using HTTP is shown
    next:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP协议的灵活性和简单性使其成为作为REST API传输机制的合适候选者。使用HTTP的另一个优点是它允许使用多种数据格式进行数据交换（如文本、XML和JSON），并且不受限于单一格式，例如XML是SOAP基于API的唯一格式。REST
    API不依赖于任何特定的语言，这使得它成为构建用于网络交互的API的事实选择。以下是一个从REST客户端到使用HTTP的REST服务器的REST API调用的架构视图：
- en: '![Figure 10.1 – REST API interaction between clients and a server'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.1 – 客户端与服务器之间的REST API交互'
- en: '](img/B17189_10_01_New.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17189_10_01_New.jpg)'
- en: Figure 10.1 – REST API interaction between clients and a server
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 – 客户端与服务器之间的REST API交互
- en: A REST API relies on HTTP requests and uses its native methods such as `GET`,
    `PUT`, `POST`, and `DELETE`. The use of the HTTP method simplifies the implementation
    of client-side and server-side software from an API design perspective. A REST
    API is developed keeping in mind the CRUD operations concept. `GET` for `Read`,
    `POST` for `Create`, `PUT` for `Update`, and `DELETE` for `Delete` operation.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: REST API依赖于HTTP请求并使用其原生方法，如`GET`、`PUT`、`POST`和`DELETE`。使用HTTP方法简化了从API设计角度出发的客户端和服务器端软件的实现。REST
    API的开发考虑到了CRUD操作的概念。`GET`用于`读取`，`POST`用于`创建`，`PUT`用于`更新`，`DELETE`用于`删除`操作。
- en: When building a REST API with HTTP methods, we must be careful in choosing the
    correct method based on its idempotency capabilities. An operation is considered
    idempotent in mathematics if the operation is giving the same results even if
    it is repeated multiple times. From the rest API design perspective, the `POST`
    method is not idempotent, which means we have to make sure that the API clients
    are not initiating a `POST` request multiple times for the same set of data. The
    `GET`, `PUT`, and `DELETE` methods are idempotent, although it is quite possible
    to get a `404` error code if we try to delete the same resource the second time.
    However, this is acceptable behavior from an idempotence point of view.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用HTTP方法构建REST API时，我们必须谨慎选择正确的方法，基于其幂等能力。在数学上，如果一个操作即使重复多次也会给出相同的结果，则认为该操作是幂等的。从REST
    API设计角度来看，`POST`方法不是幂等的，这意味着我们必须确保API客户端不会对同一组数据多次发起`POST`请求。`GET`、`PUT`和`DELETE`方法是幂等的，尽管如果我们尝试第二次删除同一资源，可能会得到`404`错误代码。然而，从幂等性的角度来看，这种行为是可以接受的。
- en: Using Flask for a REST API
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Flask进行REST API
- en: A REST API in Python can be built using different libraries and frameworks.
    The most popular frameworks for building a REST API are Django, Flask (using the
    **Flask-RESTful** extension), and **FastAPI**. Each of these frameworks has merits
    and demerits. Django is a suitable choice for building a REST API if the web application
    is also being built using Django. However, using Django only for API development
    would be overkill. The Flask-RESTful extension works seamlessly with a Flask web
    application. Both Django and Flask have strong community support, which is sometimes
    an important factor when selecting a library or a framework. FastAPI is considered
    the best in performance and is a good choice if the goal is only to build a REST
    API for your application. However, community support for FastAPI is not at the
    same level as we have for Django and Flask.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，可以使用不同的库和框架来构建 REST API。构建 REST API 最受欢迎的框架是 Django、Flask（使用 **Flask-RESTful**
    扩展）和 **FastAPI**。这些框架各有优缺点。如果网络应用也正在使用 Django 构建，那么 Django 是构建 REST API 的合适选择。然而，仅使用
    Django 进行 API 开发可能有些过度。Flask-RESTful 扩展与 Flask 网络应用无缝协作。Django 和 Flask 都拥有强大的社区支持，这在选择库或框架时有时是一个重要因素。FastAPI
    被认为是性能最好的，如果目标是只为你的应用构建 REST API，那么它是一个不错的选择。然而，FastAPI 的社区支持并不像 Django 和 Flask
    那样强大。
- en: We selected a Flask RESTful extension for REST API development for the continuation
    of our discussion that we had started for the web application development. Note
    that we can build a simple web API using just Flask, and we have done this in
    the previous chapter when we developed a sample web service-based application
    for Google Cloud deployment. In this section, we will focus on using the REST
    architectural style in building the API. This means that we will use the HTTP
    method to perform an operation on a resource that will be represented by a Python
    object.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择了一个 Flask RESTful 扩展用于 REST API 开发，以继续我们之前开始的关于网络应用开发的讨论。请注意，我们只需使用 Flask
    就可以构建一个简单的 Web API，我们已经在上一章中这样做过，当时我们开发了一个基于 Web 服务应用的示例，用于 Google Cloud 部署。在本节中，我们将专注于使用
    REST 架构风格来构建 API。这意味着我们将使用 HTTP 方法对由 Python 对象表示的资源执行操作。
- en: Important
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 重要
- en: Flask-RESTful support is unique in the way that it provides a convenient way
    to set the response code and response header as a part of return statements.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Flask-RESTful 支持的独特之处在于它提供了一种方便的方式，将响应代码和响应头作为返回语句的一部分来设置。
- en: 'To use Flask and the Flask-RESTful extension, we will be required to install
    the Flask-RESTful extension. We can install it in our virtual environment by using
    the following `pip` command:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Flask 和 Flask-RESTful 扩展，我们需要安装 Flask-RESTful 扩展。我们可以在虚拟环境中使用以下 `pip` 命令来安装它：
- en: '[PRE18]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Before discussing how to implement a REST API, it is beneficial to get familiar
    with a few terms and concepts related to API.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论如何实现 REST API 之前，熟悉一些与 API 相关的术语和概念是有益的。
- en: Resource
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 资源
- en: A resource is a key element for a REST API, and this is powered by the Flask-RESTful
    extension. A resource object is defined by extending our class from the base `Resource`
    class, which is available from the Flask-RESTful extension library. The base `Resource`
    class offers several magic functions to assist API development and automatically
    associates HTTP methods with Python methods defined in our resource object.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 资源是 REST API 的一个关键元素，这得益于 Flask-RESTful 扩展。资源对象是通过从 Flask-RESTful 扩展库中的基础 `Resource`
    类扩展我们的类来定义的。基础 `Resource` 类提供了一些魔法函数来协助 API 开发，并自动将 HTTP 方法与我们在资源对象中定义的 Python
    方法关联起来。
- en: API endpoint
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: API 端点
- en: An API endpoint is a point of entry to establish communication between client
    software and server software. In simple terms, an API endpoint is alternative
    terminology for a URL of a server or service where a program is listening for
    API requests. With the Flask-RESTful extension, we define an API endpoint by associating
    a certain URL (or URLs) with a resource object. In Flask implementation, we implement
    a resource object by extending from the base `Resource` class.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: API 端点是一个客户端软件和服务器软件之间建立通信的点。简单来说，API 端点是服务器或服务的 URL 的另一种说法，程序在这里监听 API 请求。使用
    Flask-RESTful 扩展，我们通过将某个 URL（或多个 URL）与资源对象关联来定义 API 端点。在 Flask 实现中，我们通过从基础 `Resource`
    类扩展来实现资源对象。
- en: Routing
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 路由
- en: The concept of routing for API is similar to web application routing in Flask,
    with the only difference being that in the case of an API, we need to map a `Resource`
    object to one or more endpoint URLs.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: API 的路由概念与 Flask 中的 Web 应用程序路由类似，唯一的区别在于在 API 的情况下，我们需要将一个 `Resource` 对象映射到一个或多个端点
    URL。
- en: Argument parsing
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参数解析
- en: The parsing of request arguments for an API is possible by using the query string
    or HTML form-encoded data. However, this is not a preferred approach because both
    the query string or HTML forms are not meant or designed to be used with an API.
    The recommended approach is to extract the arguments directly from an HTTP request.
    To facilitate this, the Flask-RESTful extension offers a special class, `reqparse`.
    This `reqparse` class is similar to `argparse`, which is a popular choice for
    parsing command-line arguments.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用查询字符串或 HTML 表单编码的数据可以解析 API 的请求参数。然而，这不是一个推荐的方法，因为查询字符串或 HTML 表单都不适合或设计用于与
    API 一起使用。推荐的方法是直接从 HTTP 请求中提取参数。为了方便这样做，Flask-RESTful 扩展提供了一个特殊的类，`reqparse`。这个
    `reqparse` 类类似于 `argparse`，后者是解析命令行参数的一个流行选择。
- en: Next, we will learn about building a REST API for accessing data from a database
    system.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习如何构建用于从数据库系统中访问数据的 REST API。
- en: Developing a REST API for database access
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发数据库访问的 REST API
- en: 'To illustrate the use of Flask and the Flask-RESTful extension for building
    a REST API, we will revise our web application (`app5.py`) and will offer access
    to the `Student` object (a `Resource` object) using the REST architectural style.
    We are expecting the arguments sent for the `PUT` and `POST` methods inside the
    request body and the API will send back the response in JSON format. The revised
    code of `app5.py` with a REST API interface is shown next:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明如何使用 Flask 和 Flask-RESTful 扩展来构建 REST API，我们将修改我们的 Web 应用程序 (`app5.py`)，并使用
    REST 架构风格提供对 `Student` 对象（一个 `Resource` 对象）的访问。我们期望在请求体中发送的 `PUT` 和 `POST` 方法的参数，API
    将以 JSON 格式发送响应。带有 REST API 接口的 `app5.py` 修改后的代码如下：
- en: '[PRE19]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding code snippet, we started with the initialization of the Flask
    application and the database instance. As a next step, we created an API instance
    using the Flask instance. We achieved this by means of the `api = Api(app)` statement.
    This API instance is the key to develop the rest of the API application and we
    will use it.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们从初始化 Flask 应用程序和数据库实例开始。作为下一步，我们使用 Flask 实例创建了一个 API 实例。我们通过 `api
    = Api(app)` 语句实现了这一点。这个 API 实例是开发其余 API 应用程序的关键，我们将使用它。
- en: 'Next, we need to configure the `reqparse` instance by registering the argument
    we are expecting to parse from the HTTP request. In our code example, we registered
    two arguments of the string type, `name` and `grade`, as shown in the following
    code snippet:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要通过注册我们期望从 HTTP 请求中解析的参数来配置 `reqparse` 实例。在我们的代码示例中，我们注册了两个字符串类型的参数，`name`
    和 `grade`，如下面的代码片段所示：
- en: '[PRE20]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The next step is to create a `Student` model object, which is mostly the same
    as we did in `app5.py`, except that we will add a `serialize` method to convert
    our object into JSON format. This is an important step in serializing the JSON
    response before sending it back to the API clients. There are other solutions
    available to achieve the same, but we selected this option for simplicity reasons.
    The precise sample code for the creation of a `Student` object is as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建一个 `Student` 模型对象，这基本上与我们在 `app5.py` 中所做的一样，只不过我们将添加一个 `serialize` 方法来将我们的对象转换为
    JSON 格式。这是在将 JSON 响应发送回 API 客户端之前序列化的重要步骤。还有其他一些解决方案可以实现相同的功能，但我们出于简单性的考虑选择了这个选项。创建
    `Student` 对象的精确示例代码如下：
- en: '[PRE21]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, we created two `Resource` classes to access student database objects.
    These are `StudentDao` and `StudentListDao`. These are described next:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建了两个 `Resource` 类来访问学生数据库对象。这些是 `StudentDao` 和 `StudentListDao`。接下来将对其进行描述：
- en: '`StudentDao` offers methods such as `get` and `delete` on the individual resource
    instance, and these methods are mapped to the `GET` and `DELETE` methods of the
    HTTP protocol.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StudentDao` 在单个资源实例上提供了 `get` 和 `delete` 等方法，这些方法映射到 HTTP 协议的 `GET` 和 `DELETE`
    方法。'
- en: '`StudentListDao` offers methods such as `get` and `post`. The `GET` method
    is added to provide a list of all resources of the `Student` type using the `GET`
    HTTP method, and the `POST` method is included to add a new resource object using
    the `POST` HTTP method. This is a typical design pattern used to implement CRUD
    functionality for a web resource.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StudentListDao`提供了`get`和`post`等方法。`GET`方法被添加以使用`GET`HTTP方法列出所有`Student`类型的资源，而`POST`方法被包含在内，用于使用`POST`HTTP方法添加新的资源对象。这是实现Web资源CRUD功能的一个典型设计模式。'
- en: As regards methods implemented for `StudentDao` and `StudentListDao` classes,
    we returned the status code and the object itself in a single statement. This
    is a convenience offered by the Flask-RESTful extension.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 关于为`StudentDao`和`StudentListDao`类实现的方法，我们在一个语句中返回了状态码和对象本身。这是Flask-RESTful扩展提供的一个便利功能。
- en: 'A sample code for the `StudentDao` class is shown next:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例代码展示了`StudentDao`类的示例代码：
- en: '[PRE22]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'A sample code for the `StudentListDao` class is as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`StudentListDao`类的示例代码如下：'
- en: '[PRE23]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: For our `post` method of the `StudentListDao` class, we used the `reqparse`
    parser to extract the name and the grade arguments from the request. The rest
    of the implementation in the `POST` method is the same as we did for the `app5.py`
    example.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`StudentListDao`类的`post`方法，我们使用了`reqparse`解析器从请求中提取名称和成绩参数。`POST`方法中的其余实现与我们在`app5.py`示例中执行的方式相同。
- en: 'In the next two lines of our sample API application, we mapped URLs to our
    `Resource` objects. All requests coming for `/students/<student_id>` will be redirected
    to the `StudentDao` resource class. Any request coming for `/students` will be
    redirected to the `StudentListDao` resource class:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例API应用程序的下两行中，我们将URL映射到我们的`Resource`对象。所有针对`/students/<student_id>`的请求都将重定向到`StudentDao`资源类。任何针对`/students`的请求都将重定向到`StudentListDao`资源类：
- en: '[PRE24]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note that we skipped the `PUT` method implementation from the `StudentDao` class,
    but it is available with the source code provided for this chapter for completeness.
    For this code example, we did not add error and exception handling to keep the
    code concise for our discussion, but it is highly recommended to have this included
    in our final implementation.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们省略了`StudentDao`类的`PUT`方法实现，但它在本章提供的源代码中是可用的，以保持完整性。对于这个代码示例，我们没有添加错误和异常处理，以使代码简洁，便于讨论，但强烈建议在最终实现中包含这一部分。
- en: In this section, we have covered the base concepts and implementation principles
    for developing REST APIs that are adequate for anyone to start building a REST
    API. In the next section, we will extend our knowledge to build a complete web
    application based on a REST API.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了开发REST API的基础概念和实现原则，这些API对于任何想要开始构建REST API的人来说都是足够的。在下一节中，我们将扩展我们的知识，以基于REST
    API构建一个完整的Web应用程序。
- en: Case study– Building a web application using the REST API
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例研究 – 使用REST API构建Web应用程序
- en: 'In this chapter, we learned how to build a simple web application using Flask
    and how to add a REST API to a business logic layer using a Flask extension. In
    the real world, web applications are typically three tiers: *web layer*, *business
    logic layer*, and *data access layer*. With the popularity of mobile apps, the
    architecture has evolved to have a REST API as a building block for the business
    layer. This affords the freedom of building web apps and mobile apps using the
    same business logic layer. Moreover, the same API can be available for B2B interactions
    with other vendors. This type of architecture is captured in *Figure 10.2*:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用Flask构建简单的Web应用程序，以及如何使用Flask扩展将REST API添加到业务逻辑层。在现实世界中，Web应用程序通常是三层：*Web层*、*业务逻辑层*和*数据访问层*。随着移动应用的普及，架构已经发展到将REST
    API作为业务层的构建块。这为使用相同业务逻辑层构建Web应用程序和移动应用程序提供了自由。此外，相同的API可以用于与其他供应商的B2B交互。这种类型的架构在*图10.2*中有所体现：
- en: '![Figure 10.2 – Web/mobile application architecture'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.2 – Web/移动应用程序架构'
- en: '](img/B17189_10_02.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17189_10_02.jpg)'
- en: Figure 10.2 – Web/mobile application architecture
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 – Web/移动应用程序架构
- en: 'In our case study, we will develop a web application on top of the REST API
    application that was developed for the `Student` model object in the previous
    code example. At a high level, we will have the components in our application
    as shown here:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例研究中，我们将在之前代码示例中为`Student`模型对象开发的REST API应用程序之上开发一个Web应用程序。从高层次来看，我们的应用程序将包含以下组件：
- en: '![Figure 10.3 – Sample web application with a REST API as a backend engine'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.3 – 带有REST API后端引擎的示例Web应用程序'
- en: '](img/B17189_10_03.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.3](img/B17189_10_03.jpg)'
- en: Figure 10.3 – Sample web application with a REST API as a backend engine
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.3 – 带有 REST API 后端引擎的示例 Web 应用程序
- en: We already developed a business logic layer and data access layer (ORM) and
    exposed the functionality through two API endpoints. This is discussed in the
    *Using Flask for a REST API* section. We will develop a web application part for
    web access and consume the API offered by the business logic.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经开发了一个业务逻辑层和数据访问层（ORM），并通过两个 API 端点公开了功能。这将在 *使用 Flask 构建 REST API* 部分中讨论。我们将开发一个用于网络访问的
    Web 应用程序部分，并使用业务逻辑提供的 API。
- en: 'The `webapp.py` web application will be based on Flask. The `webapp.py` application
    (referred to as *webapp* moving forward) will be independent of the `api_app.py`
    application (referred to as *apiapp* moving forward) in the sense that the two
    applications will be running separately as two Flask instances, ideally on two
    separate machines. But if we are running the two Flask instances on the same machine
    for testing purposes, we must use different ports and use the local machine IP
    address as a host. Flask uses the *127.0.0.1* address as a host to run its built-in
    web server, which may not be allowed for running two instances. The two applications
    will talk to each other only via a REST API. Additionally, we will develop a few
    Jinja templates to submit requests for create, update, and delete operations.
    We will reuse the `api_py.py` application code as is, but we will develop the
    `webapp.py` application with features such as listing students, adding a new student,
    deleting a student, and updating a student''s data. We will add Python functions
    for each feature one by one:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`webapp.py` Web 应用程序将基于 Flask。`webapp.py` 应用程序（以下称为 *webapp*）在意义上将是独立的，即两个应用程序将作为两个
    Flask 实例分别运行，理想情况下在两台不同的机器上。但如果我们在同一台机器上运行这两个 Flask 实例进行测试，我们必须使用不同的端口，并使用本地机器
    IP 地址作为主机。Flask 使用 *127.0.0.1* 地址作为主机来运行其内置的 Web 服务器，这可能不允许运行两个实例。两个应用程序将通过 REST
    API 互相通信。此外，我们还将开发一些 Jinja 模板来提交创建、更新和删除操作的请求。我们将直接重用 `api_py.py` 应用程序代码，但我们将开发具有列出学生、添加新学生、删除学生和更新学生数据等功能的
    `webapp.py` 应用程序。我们将为每个功能逐一添加 Python 函数：'
- en: 'We will begin with the initialization of the Flask instance as we have done
    for previous code examples. The sample code is as follows:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将开始初始化 Flask 实例，就像我们在之前的代码示例中所做的那样。示例代码如下：
- en: '[PRE25]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, we will add a `list` function to handle requests with the `/` URL as
    follows:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一个 `list` 函数来处理以 `/` URL 为请求的请求：
- en: '[PRE26]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next, we will implement an `add` function to process the request for adding
    a new student to the database. Only the request with the `POST` method type is
    mapped to this Python function. The sample code is as follows:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将实现一个 `add` 函数来处理将新学生添加到数据库的请求。只有使用 `POST` 方法类型的请求才会映射到这个 Python 函数。示例代码如下：
- en: '[PRE27]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Next, we will add a `DELETE` function to handle a request for deleting an existing
    student. The request type mapped to this method is expected to provide the student
    ID as part of the URL.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一个 `DELETE` 函数来处理删除现有学生的请求。映射到这个方法的请求类型预期将提供学生 ID 作为 URL 的一部分。
- en: '[PRE28]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, we will add two functions to handle the update feature. One function
    (`update`) is used to update the data of a student in the same manner as the `post`
    function does. But before triggering the `update` function, our webapp application
    will offer a form to the user with the current data of a `student` object. The
    second function (`load_student_for_update`) will get a `student` object and send
    it to a Jinja template for users to edit. The code for both functions is as follows:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将添加两个函数来处理更新功能。一个函数（`update`）用于以与 `post` 函数相同的方式更新学生的数据。但在触发 `update`
    函数之前，我们的 webapp 应用程序将向用户提供一个表单，其中包含 `student` 对象的当前数据。第二个函数（`load_student_for_update`）将获取一个
    `student` 对象并将其发送到 Jinja 模板，供用户编辑。两个函数的代码如下：
- en: '[PRE29]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The code inside these functions is no different from what we already discussed
    in relation to previous examples. Therefore, we will not go into the details of
    every line of the code, but we will highlight the key points of this web application
    and its interaction with a REST API application:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数内部的代码与我们之前讨论的没有不同。因此，我们不会深入到代码的每一行，但我们将突出显示这个 Web 应用程序及其与 REST API 应用程序交互的关键点：
- en: For our web application, we are using two Jinja templates (`main.html` and `update.html`).
    We are also using a template (we called it `base.html`) that is common to both
    templates. The `base.html` template is mainly built using the bootstrap UI framework.
    We will not discuss the details of the Jinja templates and the bootstrap, but
    we will encourage you to get familiar with both using the references provided
    at the end of this chapter. The sample Jinja templates with bootstrap code are
    available with the source code of this chapter.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于我们的Web应用程序，我们使用两个Jinja模板（`main.html`和`update.html`）。我们还使用了一个模板（我们称之为`base.html`），它是两个模板共有的。`base.html`模板主要使用bootstrap
    UI框架构建。我们不会讨论Jinja模板和bootstrap的细节，但我们将鼓励您使用本章末尾提供的参考熟悉这两个。本章源代码中提供了带有bootstrap代码的示例Jinja模板。
- en: 'The root `/` URL of our web application will launch the main page (`main.html`),
    which allows us to add a new student and also provides a list of existing students.
    The following screenshot shows the screenshot of the main page, which will be
    rendered with our `main.html` template:'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们Web应用程序的根`/` URL将启动主页（`main.html`），这允许我们添加一个新的学生，同时也提供了一个现有学生的列表。以下截图显示了主页面，它将使用我们的`main.html`模板进行渲染：
- en: '![Figure 10.4 – Main page of the webapp application'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.4 – webapp应用程序的主页]'
- en: '](img/B17189_10_04.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17189_10_04.jpg]'
- en: Figure 10.4 – Main page of the webapp application
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 – webapp应用程序的主页
- en: If we add the first and last name of a student with a grade and click the `POST`
    request with data of these three input fields. Our webapp application will delegate
    this request to the `add` function. The `add` function will use the corresponding
    REST API of the `apiapp` application to add a new student and the `add` function
    will render the main page again with an updated list of students (including new
    students).
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们添加一个学生的姓名和成绩，并点击包含这三个输入字段数据的`POST`请求。我们的webapp应用程序将委托此请求到`add`函数。`add`函数将使用`apiapp`应用程序的相应REST
    API添加一个新的学生，并将`add`函数再次渲染带有更新学生列表（包括新学生）的主页。
- en: On the main webapp page (`main.html`), we added two buttons (`GET` request with
    the `/delete/<id>` URL. This request will be delegated to the `delete` function.
    The `delete` function will use the REST API of the `apiapp` application to delete
    the student from the `SQLite3` database and will render the main page again with
    an updated list of students.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在主Web应用程序页面（`main.html`）上，我们添加了两个按钮（带有`/delete/<id>` URL的`GET`请求。此请求将被委托到`delete`函数。`delete`函数将使用`apiapp`应用程序的REST
    API从`SQLite3`数据库中删除学生，并将再次渲染带有更新学生列表的主页。
- en: 'Upon clicking the `GET` request with the `/update/<id>` URL. This request will
    be delegated to the `load_student_for_update` function. This function will first
    load the student data using the REST API of the `apiapp` application, set the
    data in the response, and render the `update.html` template. The `update.html`
    template will show the user an HTML form filled with student data to allow editing.
    The form we developed for the update scenario is shown here:'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击带有`/update/<id>` URL的`GET`请求。此请求将被委托到`load_student_for_update`函数。此函数将首先使用`apiapp`应用程序的REST
    API加载学生数据，设置响应中的数据，并渲染`update.html`模板。`update.html`模板将向用户显示一个填写有学生数据的HTML表单，以允许编辑。我们为更新场景开发的表单如下所示：
- en: '![Figure 10.5 – A sample form to update a student'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.5 – 更新学生信息的示例表单]'
- en: '](img/B17189_10_05.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17189_10_05.jpg]'
- en: Figure 10.5 – A sample form to update a student
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5 – 更新学生信息的示例表单
- en: After the changes, if a user submits the form by clicking the `POST` request
    with the `/update/<id>` URL. We have registered the `update` function for this
    request. The `update` function will extract data from the request and pass it
    to the REST API of the `apiapp` application. Once the student info is updated,
    we will render the `main.html` page again with an updated list of students.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在更改后，如果用户通过点击带有`/update/<id>` URL的`POST`请求提交表单。我们已为此请求注册了`update`函数。`update`函数将从请求中提取数据并将其传递给`apiapp`应用程序的REST
    API。一旦学生信息更新，我们将再次渲染带有更新学生列表的`main.html`页面。
- en: In this chapter, we have omitted the details of pure web technologies such as
    HTML, Jinja, CSS, and UI frameworks in general. The beauty of web frameworks is
    that they allow any web technologies to be used for customer interfaces, especially
    if we are building our applications using a REST API.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们省略了纯Web技术如HTML、Jinja、CSS以及通用UI框架的细节。Web框架的美丽之处在于，它们允许任何Web技术用于客户界面，尤其是如果我们使用REST
    API构建我们的应用程序时。
- en: This concludes our discussion of building web applications and developing a
    REST API using Flask and its extensions. Web development is not limited to one
    language or one framework. The core principles and architecture remain the same
    across web frameworks and languages. The web development principles you learned
    here will help you to understand any other web framework for Python or any other
    language.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们关于使用Flask及其扩展构建Web应用程序和开发REST API的讨论。Web开发不仅限于一种语言或一种框架。核心原则和架构在所有Web框架和语言中都是相同的。在这里学到的Web开发原则将帮助您理解任何其他Python或任何其他语言的Web框架。
- en: Summary
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed how to use Python and web frameworks such as Flask
    for developing web applications and a REST API. We started the chapter by analyzing
    the requirements for web development, which include a web framework, a UI framework,
    a web server, a database system, API support, security, and documentation. Later,
    we introduced how to use the Flask framework for building web applications with
    several code examples. We discussed different request types with different HTTP
    methods and how to parse the request data with relevant code examples. We also
    learned about the use of Flask to interact with a database system using an ORM
    library such as SQLAlchemey. In the latter part of the chapter, we introduced
    the role of a web API for web applications, mobile applications, and business-to-business
    applications. We investigated a Flask extension to develop a REST API with a detailed
    analysis by using a sample API application. In the last section, we discussed
    a case study of developing a *student* web application. The web application is
    built using two independent applications, both running as Flask applications.
    One application offers a REST API for the business logic layer on top of a database
    system. The other application provides a web interface to users and consumes the
    REST API interface of the first application to provide access to the student resource
    objects.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了如何使用Python和Web框架（如Flask）开发Web应用程序和REST API。我们通过分析Web开发的必要条件开始本章，这些条件包括Web框架、UI框架、Web服务器、数据库系统、API支持、安全性和文档。随后，我们介绍了如何使用Flask框架通过几个代码示例构建Web应用程序。我们讨论了不同HTTP方法下的不同请求类型，以及如何使用相关代码示例解析请求数据。我们还学习了如何使用Flask通过ORM库（如SQLAlchemy）与数据库系统交互。在章节的后半部分，我们介绍了Web
    API在Web应用程序、移动应用程序和业务对业务应用程序中的作用。我们通过使用示例API应用程序进行了详细分析，研究了用于开发REST API的Flask扩展。在最后一部分，我们讨论了开发*学生*Web应用程序的案例研究。该Web应用程序使用两个独立的应用程序构建，这两个应用程序都作为Flask应用程序运行。一个应用程序在数据库系统之上提供业务逻辑层的REST
    API。另一个应用程序为用户提供Web界面，并消费第一个应用程序的REST API接口，以提供对学生资源对象的访问。
- en: This chapter provides extensive hands-on knowledge of building web applications
    and a REST API using Flask. The code examples included in this chapter will enable
    you to start creating web applications and write a REST API. This knowledge is
    critical for anyone who is seeking a career in web development and working in
    building a REST API.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了使用Flask构建Web应用程序和REST API的丰富实战知识。本章包含的代码示例将使您能够开始创建Web应用程序并编写REST API。这些知识对于寻求在Web开发领域发展并参与构建REST
    API的人来说至关重要。
- en: In the next chapter, we will explore how to use Python to develop microservices,
    a new paradigm of software development.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何使用Python开发微服务，这是软件开发的一种新范式。
- en: Questions
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the purpose of TLS?
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: TLS的目的是什么？
- en: When is Flask a superior choice to the Django framework?
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在什么情况下，Flask框架比Django框架更优越？
- en: What are the commonly used HTTP methods?
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 常用的HTTP方法有哪些？
- en: What is CRUD and how is it related to a REST API?
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CRUD是什么？它与REST API有何关联？
- en: Does a REST API only use JSON as a data format?
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: REST API是否仅使用JSON作为数据格式？
- en: Further reading
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Flask Web Development*, by Miguel Grinberg'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《Flask Web开发》*，作者：米格尔·格林伯格'
- en: '*Advanced Guide to Python 3 Programming*, by John Hunt'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《Python 3编程高级指南》*，作者：约翰·亨特'
- en: '*REST APIs with Flask and Python*, by Jason Myers & Rick Copeland'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《使用Flask和Python构建REST API》*，作者：杰森·迈尔斯和里克·科普兰德'
- en: '*Essential SQLAlchemy, 2nd Edition*, by Jose Salvatierra'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《Essential SQLAlchemy，第2版》*，作者：豪塞·萨尔瓦蒂埃拉'
- en: '*Bootstrap 4 Quick Start*, by Jacob Lett'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《Bootstrap 4快速入门》*，作者：雅各布·莱特'
- en: '*Jinja online documentation*, available at [https://jinja.palletsprojects.com/](https://jinja.palletsprojects.com/)'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Jinja在线文档*，可在[https://jinja.palletsprojects.com/](https://jinja.palletsprojects.com/)找到'
- en: Answers
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: The main purpose of TLS is to provide encryption of data that is exchanged between
    the two systems on the internet.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: TLS 的主要目的是提供在互联网上两个系统之间交换数据的加密。
- en: Flask is a better choice for small- to medium-sized applications and especially
    when the project requirements are expected to change frequently.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Flask 是中小型应用的更好选择，尤其是在项目需求预期会频繁变化的情况下。
- en: '`GET` and `POST`.'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GET` 和 `POST`。'
- en: '`GET`, `POST`, `PUT`, and `DELETE`).'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GET`、`POST`、`PUT` 和 `DELETE`。'
- en: A REST API can support any string-based format, such as JSON, XML, or HTML.
    Data format support is more related to HTTP's ability to carry the data as part
    of the HTTP body element.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: REST API 可以支持任何基于字符串的格式，例如 JSON、XML 或 HTML。数据格式支持更多地与 HTTP 作为 HTTP 主体元素传输数据的能力相关。
