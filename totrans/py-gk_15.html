<html><head></head><body>
		<div id="_idContainer090">
			<h1 id="_idParaDest-251"><em class="italic"><a id="_idTextAnchor289"/>Chapter 11</em>: Using Python for Microservices Development</h1>
			<p>Monolithic applications that are built as a single-tiered software have been a popular option for developing applications for many years. However, it is not efficient to deploy monolithic applications in cloud platforms in terms of reserving and utilizing resources. This is even true for the deployment of large-scale monolithic applications on physical machines. The maintenance and development costs of such applications are always high. Multi-tier applications have solved this problem to some extent for web applications by breaking the applications down into several tiers.</p>
			<p>To meet dynamic resource demands and to reduce development/maintenance costs, the real savior is a <strong class="bold">microservices architecture</strong>. This new architecture encourages applications to be built on loosely coupled services and deployed on dynamically scalable platforms such as containers. Organizations such as Amazon, Netflix, and Facebook have already moved from a monolithic model to microservices-based architecture. Without this change, these organizations couldn't have served a large number of clients.</p>
			<p>We will cover the following topics in this chapter:</p>
			<ul>
				<li>Introducing microservices</li>
				<li>Learning best practices for microservices</li>
				<li>Building microservices-based applications</li>
			</ul>
			<p>After completing this chapter, you will learn about microservices and will be able to build applications based on microservices.</p>
			<h1 id="_idParaDest-252"><a id="_idTextAnchor290"/>Technical requirements</h1>
			<p>The following are the technical requirements for this chapter:</p>
			<ul>
				<li>You need to have Python 3.7 or later installed on your computer.</li>
				<li>Python Flask library with RESTful extensions installed on top of a Python 3.7 or later release.</li>
				<li>Python Django with Django Rest Framework library on top of a Python 3.7 or later release.</li>
				<li>You need to have a Docker registry account and installed Docker Engine and Docker Compose on your machine.</li>
				<li>To deploy a microservice in GCP Cloud Run, you will need a GCP account (a free trial will work fine).</li>
			</ul>
			<p>Sample code for this chapter can be found at <a href="https://github.com/PacktPublishing/Python-for-Geeks/tree/master/Chapter11">https://github.com/PacktPublishing/Python-for-Geeks/tree/master/Chapter11</a>. </p>
			<p>We will start our discussion with the introduction of microservices.</p>
			<h1 id="_idParaDest-253"><a id="_idTextAnchor291"/>Introducing microservices</h1>
			<p>A microservice is an <a id="_idIndexMarker1245"/>independent software entity that must have the following characteristics:</p>
			<ul>
				<li><strong class="bold">Loosely coupled</strong> with other<a id="_idIndexMarker1246"/> services and without any dependency on other software components</li>
				<li><strong class="bold">Easy to develop</strong> and <strong class="bold">maintain</strong> by a small team without depending on other teams</li>
				<li><strong class="bold">Independently installable</strong> as a separate entity, preferably in a container</li>
				<li>Offers <strong class="bold">easy-to-consume</strong> interfaces using synchronous protocols such as REST APIs, or <a id="_idIndexMarker1247"/>asynchronous protocols <a id="_idIndexMarker1248"/>such as <strong class="bold">Kafka</strong> or <strong class="bold">RabbitMQ</strong></li>
			</ul>
			<p>The keywords in terms of software being called a microservice are independently deployable, loosely coupled, and easily maintainable. Each microservice can have its own database servers to avoid sharing resources with other microservices. This will ensure the elimination of dependencies between the microservices.</p>
			<p>The microservices architecture style<a id="_idIndexMarker1249"/> is a software development paradigm for developing applications using purely microservices. This architecture even includes the main interface entity of the application, such as a web application. An example of a <a id="_idIndexMarker1250"/>microservices-based application is illustrated next: </p>
			<div>
				<div id="_idContainer084" class="IMG---Figure">
					<img src="image/B17189_11_01.jpg" alt="Figure 11.1 – A sample microservices architecture style application&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">  </p>
			<p class="figure-caption">Figure 11.1 – A sample microservices architecture style application</p>
			<p>In this example application, we<a id="_idIndexMarker1251"/> have individual <a id="_idIndexMarker1252"/>microservices such as <strong class="bold">Authorization Service</strong>, <strong class="bold">Product Catalog Service</strong>, and <strong class="bold">Product Inventory Service</strong>. We built a web application, also as a <a id="_idIndexMarker1253"/>microservice, that uses the three individual microservices through the REST API. For mobile<a id="_idIndexMarker1254"/> clients, a mobile app can be built using the same individual microservices through an API gateway. We can see an immediate advantage of microservices architecture, which is reusability. A few other advantages<a id="_idIndexMarker1255"/> of using microservices are as follows:</p>
			<ul>
				<li>We are flexible when it comes to selecting any technology and any programming language that suits any individual microservice requirements. We can even reuse legacy code written in any language if we can expose it using an API interface.</li>
				<li>We can develop, test, and maintain individual microservices by small independent teams. It is crucial to have independent and autonomous small teams for the development of large-scale applications.</li>
				<li>One of the challenges with monolithic applications is the managing of conflicting library versions, which we are forced to include because of different features bundled in a single application. With microservices, the chances of conflict as regards the versions of these libraries are minimized. </li>
				<li>We can deploy and<a id="_idIndexMarker1256"/> patch the individual microservices independently. This enables us to use <strong class="bold">Continuous Integration/Continuous Delivery</strong> (<strong class="bold">CI/CD</strong>) for complex applications. This is also important when we need to apply a patch <a id="_idIndexMarker1257"/>or upgrade one feature of an application. For monolithic applications, we will redeploy the entire application, which means there are chances to break other parts of the application. With microservices, only one or two services will be redeployed without risks of breaking anything else in other microservices.</li>
				<li>We can isolate faults and failures on a microservice level instead of the application level. If there is a fault or failure with one service, we can debug it, fix it, and patch it or stop it for maintenance without impacting the rest of the application's functionality. In the case of monolithic applications, a problem in one component can bring down the entire application.</li>
			</ul>
			<p>Despite several advantages, there are some<a id="_idIndexMarker1258"/> disadvantages associated with using the microservices architecture style:</p>
			<ul>
				<li>First is the increased complexity of creating microservices-based applications. The complexity mainly arises from the fact that each microservice has to expose an API and the consumer service or program has to interact with microservices using an API. Security on a per microservice basis is another contributor to the complexity.</li>
				<li>The second disadvantage is the increased resource requirements as compared to monolithic applications. Every microservice requires additional memory to be hosted independently in a container or a virtual machine, even if it is a <strong class="bold">Java Virtual Machine</strong> (<strong class="bold">JVM</strong>). </li>
				<li>The third disadvantage is <a id="_idIndexMarker1259"/>that additional efforts are required to debug and troubleshoot a problem across different microservices that may be deployed in separate containers or systems.</li>
			</ul>
			<p>Next, we will study the best practice of building microservices. </p>
			<h1 id="_idParaDest-254"><a id="_idTextAnchor292"/>Learning best practices for microservices</h1>
			<p>When starting a new application, the first and foremost question we should be asking ourselves is whether the<a id="_idIndexMarker1260"/> microservices architecture is a good fit. This starts with an analysis of the application requirements and the ability to divide the requirements into separate and individual components. If you see that your components frequently depend on one another, this is an indicator that the segregation of components may require reworking, or that this application may not be a fit for the microservices architecture.</p>
			<p>It is important to make this decision of whether to use microservices right in the early phase of an application. There is a school of thought that says that it is better to start building an application using monolithic architecture to avoid the additional costs of microservices in the beginning. However, this is not an advisable approach. Once we have built a monolithic application, it is difficult to transform it into microservices architecture, especially if the application is already in production. Companies such as Amazon and Netflix have done it, but they did it as part of their evolution of technology and certainly, they have the human and technology resources available to undertake this transformation. </p>
			<p>Once we have made our decision to build our next application using microservices, the following best practices will guide you in making design and deployment decisions:</p>
			<ul>
				<li><strong class="bold">Independent and loosely coupled</strong>: These requirements are part of the microservices definition. Each microservice should be built independently from the other microservices and is built as loosely coupled as possible. </li>
				<li><strong class="bold">Domain-Driven Design</strong> (<strong class="bold">DDD</strong>): The purpose of microservices architecture is not to have as many small microservices as possible. We need to always remember that each microservice has its overhead costs. We should build as many microservices as the business or domain requires. We recommend considering <a id="_idIndexMarker1261"/>DDD, which was introduced by <em class="italic">Eric Evans</em> in 2004. <p>If we try to apply DDD to microservices, it suggests having a strategic design first to define different contexts by combining related business domains and their subdomains. The strategic design can be followed by a tactical design that focuses on breaking down the core domains into fine-grained building blocks and entities. This breakdown will provide clear guidelines to map the requirements to possible microservices. </p></li>
				<li><strong class="bold">Communication interfaces</strong>: We<a id="_idIndexMarker1262"/> should use well-defined microservice interfaces, preferably a REST API or an event-driven API, for communication. Microservices should avoid calling each other directly. </li>
				<li><strong class="bold">Use an API gateway</strong>: Microservices and their consumer applications should interact with individual microservices using an API gateway. The API gateway can take care of security aspects, such as authentication and load balancing, out of the box. Moreover, with a new version of a microservice, we can use the API gateway to redirect the client requests to the newer version without impacting the client-side software. </li>
				<li><strong class="bold">Limit technology stack</strong>: Although microservice architecture allows the use of any programming language and framework on a per-service basis, it is not advisable to develop microservices using different technologies in the absence of any business or reusability reasons. A diverse technology stack may be appealing for academic reasons, but it will bring operational complexity in maintaining and troubleshooting the application. </li>
				<li><strong class="bold">Deployment model</strong>: It is not mandatory to deploy a microservice in a container, but it is recommended. Containers bring a lot of built-in features, such as automated deployment, cross-platform support, and interoperability. Additionally, by using containers, we can assign the resources to the service as per its requirements and ensure a fair distribution of resources across different microservices.</li>
				<li><strong class="bold">Version control</strong>: We should <a id="_idIndexMarker1263"/>be using a separate versioning control system for each microservice.</li>
				<li><strong class="bold">Team organization</strong>: Microservices architecture provides an opportunity to have dedicated teams on a per-microservice basis. We should be keeping this principle in mind when organizing teams for a large-scale project. The size of a team should be based on<a id="_idIndexMarker1264"/> the <em class="italic">two-pizza philosophy</em>, which states that we should set up a team with as many engineers who can be fed by two large pizzas. A team can own one or more microservices based on their complexity. </li>
				<li><strong class="bold">Centralized logging/monitoring</strong>: As discussed previously, troubleshooting problems in a microservice architecture-style application can be time-consuming, especially if the microservices are running in containers. We should be using open source or<a id="_idIndexMarker1265"/> professional tools to monitor and troubleshoot the microservices to reduce <a id="_idIndexMarker1266"/>such operational costs. A few <a id="_idIndexMarker1267"/>examples of<a id="_idIndexMarker1268"/> such tools are <strong class="bold">Splunk</strong>, <strong class="bold">Grafana</strong>, <strong class="bold">Elk</strong>, and <strong class="bold">App Dynamics</strong>.</li>
			</ul>
			<p>Now that we have covered the introduction as well as best practices of microservices, next, we will deep dive into learning to build an application using microservices.</p>
			<h1 id="_idParaDest-255"><a id="_idTextAnchor293"/>Building microservices-based applications</h1>
			<p>Before going into the <a id="_idIndexMarker1269"/>implementation details of microservices, it is important to analyze several microservice frameworks and deployment options. We will start with a microservices framework available in Python.</p>
			<h2 id="_idParaDest-256"><a id="_idTextAnchor294"/>Learning microservice development options in Python</h2>
			<p>In Python, we<a id="_idIndexMarker1270"/> have a plethora of frameworks and libraries <a id="_idIndexMarker1271"/>available for microservice development. We cannot enumerate all the available options, but it is worth highlighting the most popular and those that have some different feature sets. These options are described next: </p>
			<ul>
				<li><strong class="bold">Flask</strong>: This is a<a id="_idIndexMarker1272"/> lightweight framework that can be used to build <strong class="bold">Web Service Gateway Interface</strong> (<strong class="bold">WSGI</strong>)-based<a id="_idIndexMarker1273"/> microservices. Note that <a id="_idIndexMarker1274"/>WSGI is based on a request-response synchronous design pattern. We already used Flask and its RESTful extension to build a REST API application in <a href="B17189_10_Final_PG_ePub.xhtml#_idTextAnchor264"><em class="italic">Chapter 10</em></a>, <em class="italic">Using Python for Web Development and REST API</em>. Since Flask is a popular web and API development framework, it is an easy adoption choice for many developers who are already using Flask.</li>
				<li><strong class="bold">Django</strong>: Django<a id="_idIndexMarker1275"/> is <a id="_idIndexMarker1276"/>another popular web framework with a large community of developers. With <a id="_idIndexMarker1277"/>its <strong class="bold">Django Rest Framework </strong>(<strong class="bold">DRF</strong>), we can build microservices with REST API interfaces. Django offers both WSGI and <strong class="bold">Asynchronous Service Gateway Interface</strong> (<strong class="bold">ASGI</strong>)-based <a id="_idIndexMarker1278"/>microservices. ASGI is considered a successor to the WSGI interface. ASGI is an excellent option if you are interested in developing your application based on <strong class="bold">Asyncio</strong>, a<a id="_idIndexMarker1279"/> topic we discussed in detail in <a href="B17189_07_Final_PG_ePub.xhtml#_idTextAnchor207"><em class="italic">Chapter 7</em></a>, <em class="italic">Multiprocessing, Multithreading, and Asynchronous Programming</em>. </li>
				<li><strong class="bold">Falcon</strong>: This is also<a id="_idIndexMarker1280"/> a popular web framework <a id="_idIndexMarker1281"/>after Flask and Django. It does not come with a built-in web server, but it is well optimized for microservices. Like Django, it supports both ASGI and WSGI. </li>
				<li><strong class="bold">Nameko</strong>: This<a id="_idIndexMarker1282"/> framework is specifically<a id="_idIndexMarker1283"/> designed for microservice development in Python, and is not a web application framework. Nameko comes with built-in support for <strong class="bold">Remote Procedure Call</strong> (<strong class="bold">RPC</strong>), asynchronous events, and WebSocket-based RPCs. If your<a id="_idIndexMarker1284"/> application requires any of these communication interfaces, you should consider Nameko. </li>
				<li><strong class="bold">Bottle</strong>: This is<a id="_idIndexMarker1285"/> a super lightweight WSGI-based microservices framework. The whole framework is based on a single file and <a id="_idIndexMarker1286"/>leverages only a Python standard library for its operations.</li>
				<li><strong class="bold">Tornado</strong>: It is <a id="_idIndexMarker1287"/>based on non-blocking <a id="_idIndexMarker1288"/>network I/O. Tornado can handle high traffic with extremely low overheads. This is also a suitable choice for long-polling and WebSocket-based connections.</li>
			</ul>
			<p>For the development of our sample microservices, we can use any of the frameworks mentioned earlier. But we will use Flask and Django for two reasons. First, these two are the most popular for developing web applications and microservices. Second, we will reuse an example API application that we developed in the previous chapter. A new microservice will be developed using Django and it will illustrate how to use Django for web and API development. </p>
			<p>Next, we will discuss microservice deployment options. </p>
			<h2 id="_idParaDest-257"><a id="_idTextAnchor295"/>Introducing deployment options for microservices</h2>
			<p>Once we write <a id="_idIndexMarker1289"/>microservices, the next question is how to deploy them as an isolated and independent entity. For the sake of discussion, we will assume that microservices are built with HTTP/REST interfaces. We can deploy all microservices on the same web server as different web apps or host one web server for one microservice. One microservice in a separate web server can be deployed on a single machine (physical or virtual) or on separate machines or even on separate containers. We have summarized all these different deployment models in the following diagram: </p>
			<div>
				<div id="_idContainer085" class="IMG---Figure">
					<img src="image/B17189_11_02.jpg" alt="Figure 11.2 – Microservices deployment models&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.2 – Microservices deployment models</p>
			<p>The four deployments <a id="_idIndexMarker1290"/>models shown in <em class="italic">Figure 11.2</em> are described as follows:</p>
			<ul>
				<li><strong class="bold">Model A</strong>: In this model, we are deploying four different microservices on the same web server. There is a good chance that the microservices in this case are sharing libraries, being on a single web server. This may result in library conflicts and is not a recommended model for deploying microservices.</li>
				<li><strong class="bold">Model B</strong>: For this model, we deployed four microservices on a single machine, but using one microservice per web server to make them independent. This model is fine for development environments, but may not be suitable on a production scale.</li>
				<li><strong class="bold">Model C</strong>: This model is using four virtual machines to host four different microservices. Each machine host only one microservice with a web server. This model is suitable for production if it is not possible to use containers. The main caveat of this model is the additional costs because of resource overheads that each virtual machine will bring with it. </li>
				<li><strong class="bold">Model D</strong>: In this model, we deploy each microservice as a container on a single machine or across multiple machines. This is not only cost-effective but also provides an easy way to be compliant with microservice specifications. This is the recommended model whenever it is feasible to use. </li>
			</ul>
			<p>We analyzed different deployment models to understand which option is more appropriate than others. For the development of our sample microservices-based application, we will use a mix of both a container-based microservice and a microservice hosted only on a <a id="_idIndexMarker1291"/>web server. This mixed model illustrates that we can use any option technically, although the container-based deployment is a recommended one. Later, we will take one of our microservices to the cloud to demonstrate the portability of microservices. </p>
			<p>After discussing the development and deployment options for microservices, it is time to start building an application using two microservices in the next section. </p>
			<h2 id="_idParaDest-258"><a id="_idTextAnchor296"/>Developing a sample microservices-based application</h2>
			<p>For the sample<a id="_idIndexMarker1292"/> application, we will develop two microservices and a web application using Flask and Django frameworks. Our sample application will be an extension of the <strong class="bold">Student</strong> web application that was developed as a case study in the previous chapter. The application architecture will appear as shown here:</p>
			<div>
				<div id="_idContainer086" class="IMG---Figure">
					<img src="image/B17189_11_03.jpg" alt="Figure 11.3 – C microservices-based architecture of a sample application &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.3 – C microservices-based architecture of a sample application </p>
			<p>To develop thi<a id="_idIndexMarker1293"/>s sample application, we will develop the following components:</p>
			<ul>
				<li>Build a new <strong class="bold">Grades</strong> microservice using the Django framework and deploy it with a <strong class="bold">Docker Engine</strong>. Docker Engine is an open source software to containerize our application. The Grades microservice will provide additional information about each grade, such as the building name and class teacher name, and these attributes are not stored with the <strong class="source-inline">Student</strong> model under the Students microservice.</li>
				<li>Reuse the <strong class="source-inline">apiapp</strong> application from the previous chapter. It is named as a <strong class="source-inline">Students</strong> microservice for this sample application. There will be no change in the code of this application/module.</li>
				<li>We will update the <strong class="source-inline">webapp</strong> application from the previous chapter's case study to consume the <strong class="source-inline">Grades</strong> microservice and add additional <strong class="source-inline">Grade</strong> attributes with each <strong class="source-inline">Student</strong> object. This will require minor updates to the Jinja templates as well.</li>
			</ul>
			<p>We will start by building the <strong class="source-inline">Grades</strong> microservice with Django. </p>
			<h3>Creating a Grades microservice</h3>
			<p>To develop a<a id="_idIndexMarker1294"/> microservice using Django, we will use <strong class="bold">Django Rest Framework</strong> (<strong class="bold">DRF</strong>). Django uses various components from its web framework to build a <a id="_idIndexMarker1295"/>REST API and microservices. Hence, this development exercise will also give you a high-level idea about developing web applications using Django. </p>
			<p>Since we started with Flask and are already familiar with the core web concepts of web development, it will be a convenient transition for us to start using Django. Let's now understand the steps involved:</p>
			<ol>
				<li>First things first, we will create a project directory or create a new project in our favorite IDE with a virtual environment. If you are not using an IDE, you can create and activate a virtual environment under your project directory using the following commands:<p class="source-code">python -m venv myenv</p><p class="source-code">source myenv/bin/activate</p><p>For any web application, it is vital to create a virtual environment for each application. Using a global environment for library dependencies can result in such errors that are hard to troubleshoot. </p></li>
				<li>To build a Django application, we will require at least two libraries that can be installed using the following <strong class="source-inline">pip</strong> commands:<p class="source-code"><strong class="bold">pip install django </strong></p><p class="source-code"><strong class="bold">pip install django-rest-framework</strong></p></li>
				<li>Once we have installed Django, we can use the <strong class="source-inline">django-admin</strong> command-line utility to create a Django project. The command shown next will create a Django <strong class="source-inline">grades</strong> project for our microservice:<p class="source-code"><strong class="bold">django-admin startproject grades</strong></p><p>This command will <a id="_idIndexMarker1296"/>create an <strong class="source-inline">admin</strong> web app under the <strong class="source-inline">grades</strong> directory and add a <strong class="source-inline">manage.py</strong> file to our project. The <strong class="source-inline">admin</strong> web app includes built-in web server launch scripts, a settings file, and a URL routing file. <strong class="source-inline">manage.py</strong> is also a command-line utility, like <strong class="source-inline">django-admin</strong>, and offers similar features but in the context of a Django project. The file structure of the project directory will look as follows when we create a new Django project: </p><div id="_idContainer087" class="IMG---Figure"><img src="image/B17189_11_04.jpg" alt="Figure 11.4 – File structure of a new Django project &#13;&#10;"/></div><p class="figure-caption">Figure 11.4 – File structure of a new Django project </p><p>As shown in <em class="italic">Figure 11.4</em>, the <strong class="source-inline">settings.py</strong> file contains a project-level setting including a list of apps to deploy with the web server. The <strong class="source-inline">urls.py</strong> file contains routing information for different deployed applications. Currently, only the <strong class="source-inline">admin</strong> app is included in this file. <strong class="source-inline">asgi.py</strong> and <strong class="source-inline">wsgi.py</strong> are available to launch the ASGI or WSGI web server, and the option of which one to use is set in the <strong class="source-inline">settings.py</strong> file. </p></li>
				<li>The next step is to create a new Django application (our <strong class="source-inline">Grades</strong> microservice) by using the following command under the main <strong class="source-inline">grades</strong> project directory:<p class="source-code"><strong class="bold">python3 manage.py startapp grades_svc</strong></p><p>This command will <a id="_idIndexMarker1297"/>create a new application (with web components) in a separate directory with the same name as we gave this command, <strong class="source-inline">grades_svc</strong>. This will also create a default <strong class="source-inline">SQLite3</strong> database instance. The option of using the default <strong class="source-inline">SQLite3</strong> database is available in the <strong class="source-inline">settings.py</strong> file, but it can be changed if we decide to use any other database. </p></li>
				<li>In addition to the files created automatically in the <strong class="source-inline">grades_svc</strong> directory, we will add two more files – <strong class="source-inline">urls.py</strong> and <strong class="source-inline">serializers.py</strong>. A complete project directory structure with two additional files is shown in <em class="italic">Figure 11.5</em>. The roles of different files relevant to our project are also elaborated in this diagram:<div id="_idContainer088" class="IMG---Figure"><img src="image/B17189_11_05.jpg" alt="Figure 11.5 – Full directory structure with the grades_svc app&#13;&#10;"/></div><p class="figure-caption"> </p><p class="figure-caption">Figure 11.5 – Full directory structure with the grades_svc app</p></li>
				<li>Next, we will add the<a id="_idIndexMarker1298"/> necessary code for our microservice in these files one by one. We will start by defining our <strong class="source-inline">Grade</strong> model class by extending the <strong class="source-inline">Model</strong> class from the Django database <strong class="source-inline">models</strong> package. The complete code of the <strong class="source-inline">models.py</strong> file is as follows:<p class="source-code">from django.db import models</p><p class="source-code">class Grade(models.Model):</p><p class="source-code">    grade_id = models.CharField(max_length=20)</p><p class="source-code">    building = models.CharField(max_length=200)</p><p class="source-code">    teacher = models.CharField(max_length=200)</p><p class="source-code">    def __str__(self):</p><p class="source-code">        return self.grade_id</p></li>
				<li>To make our model visible in the <strong class="source-inline">admin</strong> app dashboard, we need to register our model <strong class="source-inline">Grade</strong> class in the <strong class="source-inline">admin.py</strong> file as follows:<p class="source-code">from django.contrib import admin</p><p class="source-code">from .models import Grade</p><p class="source-code"><strong class="bold">admin.site.register(Grade)</strong></p></li>
				<li>Next, we will implement a method to retrieve a list of <strong class="source-inline">Grade</strong> objects from the database. We <a id="_idIndexMarker1299"/>will add a <strong class="source-inline">GradeViewSet</strong> class by extending <strong class="source-inline">ViewSet</strong> in the <strong class="source-inline">views.py</strong> file as follows:<p class="source-code">from rest_framework import viewsets, status</p><p class="source-code">from rest_framework.response import Response</p><p class="source-code">from .models import Grade</p><p class="source-code">from .serializers import GradeSerializer</p><p class="source-code">class GradeViewSet(<strong class="bold">viewsets.ViewSet</strong>):</p><p class="source-code">    def list(self, request):</p><p class="source-code">        grades_list = Grade.objects.all()</p><p class="source-code">        serializer = GradeSerializer(grades_list,             many=True)</p><p class="source-code">        return Response(serializer.data)</p><p class="source-code">     def create(self, request):</p><p class="source-code">         pass:</p><p class="source-code">     def retrieve(self, request, id=None):</p><p class="source-code">         pass:</p><p>Note that we also added methods for adding a new <strong class="source-inline">Grade</strong> object and for getting a <strong class="source-inline">Grade</strong> object according to its ID in actual implementation for the completeness of our microservice. We are showing only the <strong class="source-inline">list</strong> method because this is the only method relevant for our sample application. It is also important to highlight that the view objects should be implemented as classes and we should <a id="_idIndexMarker1300"/>avoid putting application logic in the view objects.</p></li>
			</ol>
			<p>Once we implement our core methods under the <strong class="source-inline">grades_svc</strong> application, we will add our application to the Django project for deployment and add routes at the application as well as at the API level:</p>
			<ol>
				<li value="1">First, we will add our <strong class="source-inline">grades_svc</strong> app and also <strong class="source-inline">rest-framework</strong> to the list of <strong class="source-inline">INSTALLED_APPS</strong> in the <strong class="source-inline">settings.py</strong> file as follows:<p class="source-code">INSTALLED_APPS = [</p><p class="source-code">    'django.contrib.admin',</p><p class="source-code">    'django.contrib.auth',</p><p class="source-code">    'django.contrib.contenttypes',</p><p class="source-code">    'django.contrib.sessions',</p><p class="source-code">    'django.contrib.messages',</p><p class="source-code">    'django.contrib.staticfiles',</p><p class="source-code">    <strong class="bold">'grades_svc'</strong>,</p><p class="source-code">    <strong class="bold">'rest_framework'</strong>,</p><p class="source-code">]</p><p>A common mistake made by developers is to keep adding new components to a single settings file, which is hard to maintain for a large project. The best practice is to split the file into multiple files and load them in the main settings file.</p></li>
				<li>This will also ensure that our application is visible in the <strong class="source-inline">admin</strong> app. The next step is to add URL configuration at the <strong class="source-inline">admin</strong> app level and then at the application level. First, we will add the URL for our application in the <strong class="source-inline">urls.py</strong> file under the <strong class="source-inline">admin</strong> app as follows:<p class="source-code">urlpatterns = [</p><p class="source-code">    path('admin/', admin.site.urls),</p><p class="source-code">    <strong class="bold">path('', include('grades_svc.urls')),</strong></p><p class="source-code">]</p><p>In the <strong class="source-inline">urls.py</strong> file of the admin app, we are redirecting every request to our microservice, except the one that comes with the <strong class="source-inline">admin/</strong> URL. </p></li>
				<li>The next step<a id="_idIndexMarker1301"/> is to set routes in our application based on different HTTP methods. This requires us to add the <strong class="source-inline">urls.py</strong> file to our <strong class="source-inline">grades_svc</strong> directory with the following route definitions: <p class="source-code">from django.urls import path</p><p class="source-code">from .views import GradeViewSet</p><p class="source-code">urlpatterns = [</p><p class="source-code">    path(grades/', GradeViewSet.as_view({</p><p class="source-code">        <strong class="bold">'get':'list</strong>', #relevant for our sample             application</p><p class="source-code">        <strong class="bold">'post':'create'</strong></p><p class="source-code">        })),</p><p class="source-code">    path('grades/&lt;str:id&gt;', GradeViewSet.as_view({</p><p class="source-code">        <strong class="bold">'get': 'retrieve</strong>'</p><p class="source-code">    }))</p><p class="source-code">]</p><p>In this file, we are attaching <strong class="source-inline">GET</strong> and <strong class="source-inline">POST</strong> methods of HTTP requests with the <strong class="source-inline">grades/</strong> URL to the <strong class="source-inline">list</strong> and <strong class="source-inline">create</strong> methods of the <strong class="source-inline">GradeViewSet</strong> class that we implemented in the <strong class="source-inline">views.py</strong> file earlier. Similarly, we attached the <strong class="source-inline">GET</strong> request with the <strong class="source-inline">grades/&lt;str:id&gt;</strong> URL to the <strong class="source-inline">retrieve</strong> method of the <strong class="source-inline">GradeViewSet</strong> class. By using this file, we can add additional URL mapping to the Python functions/methods. </p></li>
			</ol>
			<p>This concludes our<a id="_idIndexMarker1302"/> implementation of our <strong class="source-inline">Grades</strong> microservice. The next step is to run this service under the Django web server for validation. But before running the service, we will make sure that the model objects are transferred to the database. This is equivalent to initializing the database in the case of Flask. In the case of Django, we run the following two commands to prepare the changes and then execute them:</p>
			<p class="source-code">python3 manage.py <strong class="bold">makemigrations</strong></p>
			<p class="source-code">python3 manage.py <strong class="bold">migrate</strong></p>
			<p>Often, developers miss this important step and get errors when trying to start the application. So, ensure that all the changes are executed before we start the web server by using the following command:</p>
			<p class="source-code">python3 manage.py runserver</p>
			<p>This will start a web server on a default port, <strong class="source-inline">8000</strong>, on our local host machine. Note that the default settings, including the database and web server with host and port attributes, can be changed in the <strong class="source-inline">settings.py</strong> file. Additionally, we will recommend setting up a user account for the <strong class="source-inline">admin</strong> app by using the following command:</p>
			<p class="source-code">python3 manage.py createsuperuser</p>
			<p>This command will prompt you to select a username, email address, and password for the admin account. Once our microservice is performing the functions as expected, it is time to bundle it in a container and run it as a container application. This is explained in the next section.</p>
			<h3>Containerizing a microservice</h3>
			<p>Containerization is a<a id="_idIndexMarker1303"/> type of operating system virtualization in which applications are run in their separate<a id="_idIndexMarker1304"/> user space, but sharing the same operating system. This separate <a id="_idIndexMarker1305"/>user space is<a id="_idIndexMarker1306"/> called a <strong class="bold">container</strong>. Docker<a id="_idIndexMarker1307"/> is the most popular platform for creating, managing, and running applications as containers. Docker still holds more<a id="_idIndexMarker1308"/> than an 80% market<a id="_idIndexMarker1309"/> share, but there are other container runtimes such as <strong class="bold">CoreOS rkt</strong>, <strong class="bold">Mesos</strong>, <strong class="bold">lxc</strong>, and <strong class="bold">containerd</strong>. Before using Docker to <a id="_idIndexMarker1310"/>containerize our<a id="_idIndexMarker1311"/> microservice, we will quickly review the main components of the Docker platform: </p>
			<ul>
				<li><strong class="bold">Docker Engine</strong>: This is the <a id="_idIndexMarker1312"/>core Docker application for building, packaging, and running container-based applications.</li>
				<li><strong class="bold">Docker image</strong>: A <a id="_idIndexMarker1313"/>Docker image is a file that is used to run the application in a container environment. The applications developed using Docker Engine are stored as Docker images, which are a collection of application code, libraries, resource files, and any other dependencies that are required for application execution.</li>
				<li><strong class="bold">Docker Hub</strong>: This is an online <a id="_idIndexMarker1314"/>repository of Docker images for sharing within your team and with the community as well. <strong class="bold">Docker Registry</strong> is<a id="_idIndexMarker1315"/> another term used in the same context. Docker Hub is an official name of the Docker registry that manages Docker image repositories. </li>
				<li><strong class="bold">Docker Compose</strong>: This is <a id="_idIndexMarker1316"/>a tool for building and running container applications using a YAML-based file instead of using the CLI commands of Docker Engine. Docker Compose provides an easy way to deploy and run multiple containers with configuration attributes and dependencies. Therefore, we will recommend using Docker Compose or similar technology to build and run your containers. </li>
			</ul>
			<p>To use Docker Engine and Docker Compose, you need to have an account with the Docker registry. Also, you must download and install Docker Engine and Docker Compose on your machine before starting the following steps:</p>
			<ol>
				<li value="1">As a first step, we will create a list of our project dependencies by using the <strong class="source-inline">pip freeze</strong> command file as follows:<p class="source-code"><strong class="bold">pip freeze -&gt; requirements.txt</strong></p><p>This command will create a list of dependencies and export them to the <strong class="source-inline">requirements.txt</strong> file. This file will be used by Docker Engine to download these libraries inside the<a id="_idIndexMarker1317"/> container on top of a Python interpreter. The contents of this file in our project are as follows: </p><p class="source-code">asgiref==3.4.1</p><p class="source-code">Django==3.2.5</p><p class="source-code">django-rest-framework==0.1.0</p><p class="source-code">djangorestframework==3.12.4</p><p class="source-code">pytz==2021.1</p><p class="source-code">sqlparse==0.4.1</p></li>
				<li>In the next step, we will build <strong class="source-inline">Dockerfile</strong>. This file will also be used by Docker Engine to create a new image of a container. In our case, we will add the following lines to this file:<p class="source-code">FROM python:3.8-slim</p><p class="source-code">ENV PYTHONUNBUFFERED 1</p><p class="source-code">WORKDIR /app</p><p class="source-code">COPY requirements.txt /app/requirements.txt</p><p class="source-code">RUN pip install -r requirements.txt</p><p class="source-code">COPY . /app</p><p class="source-code">CMD python manage.py runserver 0.0.0.0:8000</p><p>The first line in this file is setting the base image for this container, and we set it to <strong class="source-inline">Python:3.8-slim</strong>, which is already available in the Docker repository. The second line in the file is setting an environment variable for better logging. The rest of the lines are self-explanatory as they are mostly Unix commands.</p></li>
				<li>As a next step, we will<a id="_idIndexMarker1318"/> create a Docker Compose file (<strong class="source-inline">docker-compose.yml</strong>) as follows:<p class="source-code">version: '3.7'</p><p class="source-code">services:</p><p class="source-code">  gradesms:</p><p class="source-code">    build:</p><p class="source-code">      context: <strong class="bold">.</strong></p><p class="source-code">      dockerfile: Dockerfile</p><p class="source-code">    ports:</p><p class="source-code">      - 8000:8000</p><p class="source-code">    volumes:</p><p class="source-code">     - .:/app</p><p>This is a YAML file, and we define containers as services in it. Since we have only one container, we defined the <strong class="source-inline">gradesms</strong> service. Note that <strong class="source-inline">build</strong> is pointing to <strong class="source-inline">Dockerfile</strong> we just created and assuming it is in the same directory as this <strong class="source-inline">docker-compose.yml</strong> file. The container port <strong class="source-inline">8000</strong> is mapped to the web server port <strong class="source-inline">8000</strong>. This is an important step in allowing traffic from the container to your application inside the container.</p></li>
				<li>As the last step, we mount the current directory (<strong class="source-inline">.</strong>) to the <strong class="source-inline">/app</strong> directory inside the container. This will allow the changes made on our system to be reflected in the container and vice versa. This step is important if you are creating containers during the development cycle. </li>
				<li>We can start our container by using the following Docker Compose command:<p class="source-code"><strong class="bold">docker-compose up</strong></p><p>For the first time, it will build a new container image and will require internet access to download the base container image from the Docker registry. After creating a container<a id="_idIndexMarker1319"/> image, it will automatically start the container. </p></li>
			</ol>
			<p>Details of how Docker Engine and Docker Compose work are beyond the scope of this book, but we recommend that you become familiar with container technology such as Docker through their<a id="_idIndexMarker1320"/> online documentation (<a href="https://docs.docker.com/">https://docs.docker.com/</a>). </p>
			<h3>Reusing our Students API app</h3>
			<p>We will be <a id="_idIndexMarker1321"/>reusing our <strong class="source-inline">Students</strong> API app, which we developed in the previous chapter. This app will be started with its built-in server and we will name it the <strong class="source-inline">Students</strong> microservice for our sample application. There will be no change in this application. </p>
			<h3>Updating our Students web application</h3>
			<p>The <strong class="source-inline">webapp</strong> application, which<a id="_idIndexMarker1322"/> we developed for the case study in the previous chapter, is only using <strong class="source-inline">apiapp</strong> via a REST API. In a revised version of this web application, we will use the <strong class="source-inline">Grades</strong> microservice and the <strong class="source-inline">Students</strong> microservice to fetch the list of <strong class="source-inline">Grade</strong> objects and the list of <strong class="source-inline">Student</strong> objects. The <strong class="source-inline">list</strong> function in our web application will combine the two object lists to provide additional info to web clients. The updated <strong class="source-inline">list</strong> function in the <strong class="source-inline">webapp.py</strong> file will be as follows:</p>
			<p class="source-code">STUDENTS_MS = http://localhost:8080/students</p>
			<p class="source-code">GRADES_MS   = "http://localhost:8000/grades"</p>
			<p class="source-code">@app.get('/')</p>
			<p class="source-code">def list():</p>
			<p class="source-code">   student_svc_resp = requests.get(STUDENTS_MS)</p>
			<p class="source-code">   students = json.loads(student_svc_resp.text)</p>
			<p class="source-code">   grades_svc_resp = requests.get(GRADES_MS)</p>
			<p class="source-code">   grades_list = json.loads(grades_svc_resp.text)</p>
			<p class="source-code">   grades_dict = {cls_item['grade']:</p>
			<p class="source-code">                    cls_item for cls_item in grades_list}</p>
			<p class="source-code">  for student in students:</p>
			<p class="source-code">    student['building'] =         grades_dict[student['grade']]['building']</p>
			<p class="source-code">    student['teacher'] =         grades_dict[student['grade']]['teacher']</p>
			<p class="source-code">   return render_template('main.html', students=students)</p>
			<p>In this revised code, we created a <strong class="source-inline">grades</strong> dictionary using a dictionary comprehension from the list<a id="_idIndexMarker1323"/> of <strong class="source-inline">Grades</strong> objects. This dictionary will be used to insert the grade attributes inside the <strong class="source-inline">Student</strong> objects before sending them to the Jinja template for rendering. In our main Jinja template (<strong class="source-inline">main.html</strong>), we added two additional columns, <strong class="bold">Building</strong> and <strong class="bold">Teacher</strong>, to the <strong class="bold">Students</strong> table, as shown here:</p>
			<div>
				<div id="_idContainer089" class="IMG---Figure">
					<img src="image/B17189_11_06.jpg" alt="Figure 11.6 – Updated main page with Building and Teacher data&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.6 – Updated main page with Building and Teacher data</p>
			<p>In this section, we covered creating a microservice, deploying it as a Docker container as well as a web app on a web server, and combining the results of the two microservices for a web application. </p>
			<h3>Deploying the Students microservice to GCP Cloud Run</h3>
			<p>So far, we <a id="_idIndexMarker1324"/>have used the <strong class="source-inline">Students</strong> microservice<a id="_idIndexMarker1325"/> as a web application with a REST API hosted in a flask development server. It is now the time to containerize it and deploy it to the <strong class="bold">Google Cloud Platform</strong> (<strong class="bold">GCP</strong>). GCP <a id="_idIndexMarker1326"/>has a runtime engine (<strong class="bold">Cloud Run</strong>) for deploying containers and running them as a service (microservice). Here are the steps involved: </p>
			<ol>
				<li value="1">To package the application code of our <strong class="source-inline">Students</strong> microservice in a container, we will first identify a list of dependencies and export them to a <strong class="source-inline">requirements.txt</strong> file. We will run the following command from the virtual environment of the <strong class="source-inline">Students</strong> microservice project: <p class="source-code"><strong class="bold">pip freeze -&gt; requirements.txt</strong></p></li>
				<li>The next step is<a id="_idIndexMarker1327"/> to build a Dockerfile in the <a id="_idIndexMarker1328"/>root directory of the project, like the one we prepared for our <strong class="source-inline">Grades</strong> microservice. The contents of the Dockerfile are as follows:<p class="source-code">FROM python:3.8-slim</p><p class="source-code">ENV PYTHONUNBUFFERED True</p><p class="source-code">WORKDIR /app</p><p class="source-code">COPY . ./</p><p class="source-code">#Install production dependencies.</p><p class="source-code">RUN pip install -r requirements.txt</p><p class="source-code">RUN pip install Flask gunicorn</p><p class="source-code"># Run the web service on container startup. we will use </p><p class="source-code"># gunicorn and bind our api_app as the main application</p><p class="source-code">CMD exec gunicorn --bind:$PORT --workers 1 --threads 8 api_app:app</p><p>To deploy our application on GCP Cloud Run, Dockerfile will suffice. But first, we need to build the container image using the GCP Cloud SDK. This will require us to create a GCP project using either the Cloud SDK or GCP Console. We explained the steps of creating a GCP project and associating a billing account with it in the previous chapters. We assume you have created a project with the name <strong class="source-inline">students-run</strong> on GCP.</p></li>
				<li>Once the project is ready, we can use the following command to build a container image of our <strong class="source-inline">Students</strong> API application:<p class="source-code"><strong class="bold">gcloud builds submit --tag gcr.io/students-run/students</strong></p><p>Note that <strong class="source-inline">gcr</strong> stands for Google Container Registry.</p></li>
				<li>To create an image, we have to provide the tag attribute in the following format:<p class="source-code">&lt;hostname&gt;/&lt;Project ID&gt;/&lt;Image name&gt;</p></li>
				<li>In our case, the hostname is <strong class="source-inline">gcr.io</strong>, which is based in the United States. We can use a locally created image as well, but we must first set the <strong class="source-inline">tag</strong> attribute as per the <a id="_idIndexMarker1329"/>aforementioned format and then push it to the Google registry. This can be achieved with the<a id="_idIndexMarker1330"/> following Docker commands:<p class="source-code">docker tag <strong class="bold">SOURCE_IMAGE</strong> &lt;hostname&gt;/&lt;Project ID&gt;/&lt;Image name&gt;:tagid</p><p class="source-code">docker <strong class="bold">push</strong> &lt;hostname&gt;/&lt;Project ID&gt;/&lt;Image name&gt;</p><p class="source-code">#or if we want to push a specific tag</p><p class="source-code">docker push &lt;hostname&gt;/&lt;Project ID&gt;/&lt;Image name&gt;:<strong class="bold">tag</strong></p><p>As we can see, the <strong class="source-inline">gcloud build</strong> command can achieve two steps in one command.</p></li>
				<li>The next step is to run the uploaded image. We can run our container image by using the following Cloud SDK command:<p class="source-code"><strong class="bold">gcloud run deploy --image gcr.io/students-run/students</strong></p><p>The execution of our image can be triggered from the GCP console as well. Once the container is successfully deployed and running, the output of this command (or on a GCP console) will include the URL of our microservice. </p></li>
			</ol>
			<p>To consume this new version of the <strong class="source-inline">Students</strong> microservice from GCP Cloud Run, we will update our web application to switch to use the URL of this newly deployed service in GCP Cloud Run. If we test our web application with a locally deployed <strong class="source-inline">Grades</strong> microservice and the remotely deployed <strong class="source-inline">Students</strong> microservice, we will get the same results as shown earlier in <em class="italic">Figure 11.6</em> and can perform all operations as we did when the <strong class="source-inline">Students</strong> microservice was deployed locally. </p>
			<p>This concludes our discussion on building microservices using different Python frameworks, deploying them locally as well as in the cloud, and consuming them from a web application. </p>
			<h1 id="_idParaDest-259"><a id="_idTextAnchor297"/>Summary</h1>
			<p>In this chapter, we introduced microservices architecture and discussed its merits and demerits. We covered several best practices for building, deploying, and operationalizing microservices. We also analyzed the development options available in Python for building microservices that include Flask, Django, Falcon, Nameko, Bottle, and Tornado. We selected Flask and Django to build sample microservices. To implement a new microservice, we used Django with its REST framework (DRF). This microservice implementation also introduces you to how the Django framework works in general. Later, we provided details of how to containerize a newly created microservice using Docker Engine and Docker Compose. Finally, we converted our <strong class="source-inline">Students</strong> API application to a Docker image and deployed it on GCP Cloud Run. We updated the <strong class="source-inline">Students</strong> web application to consume two microservices deployed in different parts of the world.</p>
			<p>The code examples included in this chapter will provide you with hands-on experience in building and deploying microservices for different environments. This knowledge is beneficial for anyone who is looking to build microservices in their next projects. In the next chapter, we will explore how to use Python to develop serverless functions, another new paradigm of software development for the cloud. </p>
			<h1 id="_idParaDest-260"><a id="_idTextAnchor298"/>Questions</h1>
			<ol>
				<li value="1">Can we deploy a microservice without a container?</li>
				<li>Is it appropriate for two microservices to share a single database but with a different schema?</li>
				<li>What is Docker Compose and how does it help to deploy microservices?</li>
				<li>Is REST the only format for data exchange for microservices?</li>
			</ol>
			<h1 id="_idParaDest-261"><a id="_idTextAnchor299"/>Further reading</h1>
			<ul>
				<li><em class="italic">Hands-On Docker for Microservices with Python</em>, by Jaime Buelta</li>
				<li><em class="italic">Python Microservices Development</em>, by Tarek Ziade</li>
				<li><em class="italic">Domain-Driven Design: Tackling Complexity in the Heart of Software</em>, by Eric Evans</li>
				<li><em class="italic">Google Cloud Run quick-start tutorials</em> for building and deploying microservices, available at <a href="https://cloud.google.com/run/docs/quickstarts/">https://cloud.google.com/run/docs/quickstarts/</a></li>
			</ul>
			<h1 id="_idParaDest-262"><a id="_idTextAnchor300"/>Answers</h1>
			<ol>
				<li value="1">Yes, but it is recommended to deploy it in a container.</li>
				<li>Technically, it is feasible, but it is not a best practice. Database failure will bring both microservices down.</li>
				<li>Docker Compose is a tool for deploying and running container applications using a YAML file. It provides an easy format to define different services (containers) with deployment and runtime attributes.</li>
				<li>A REST API is the most popular interface for data exchange for microservices, but not the only one. Microservices can also use RPC and events-based protocols for data exchange.</li>
			</ol>
		</div>
	</body></html>