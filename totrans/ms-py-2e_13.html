<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer236" class="Basic-Text-Frame">&#13;
    <h1 class="chapterNumber">13</h1>&#13;
    <h1 id="_idParaDest-363" class="chapterTitle">asyncio – Multithreading without Threads</h1>&#13;
    <p class="normal">The previous chapter showed us how to track our application performance. In this chapter, we will use asynchronous programming to switch between functions whenever we have to wait for <strong class="keyWord">input/output</strong> (<strong class="keyWord">I/O</strong>) operations. This effectively fakes the effects of multiple threads or processes without introducing the overhead that comes with those solutions. In the next chapter, we will also cover multiple threads and processes for the cases where I/O is not your bottleneck or where <code class="inlineCode">asyncio</code> is not an option.</p>&#13;
    <p class="normal">Whenever you are dealing with external resources such as reading/writing files, interacting with APIs or databases, and other I/O operations, you can achieve great benefits from using <code class="inlineCode">asyncio</code>. Where normally a single stalling remote connection can make your entire process hang, with <code class="inlineCode">asyncio,</code> it will simply switch to a different part of your code.</p>&#13;
    <p class="normal">This chapter will explain how asynchronous functions can be used in Python and how code can be restructured in such a way that it still functions, even though it doesn’t follow the standard procedural coding pattern of returning the values. The potential downside is that, similar to working with multiple threads and multiple processes, the possibility exists of your code executing in an unexpected order.</p>&#13;
    <p class="normal">The following topics are covered:</p>&#13;
    <ul>&#13;
      <li class="bulletList">Introduction to <code class="inlineCode">asyncio</code> </li>&#13;
      <li class="bulletList"><code class="inlineCode">asyncio</code> basic concepts, including coroutines, event loops, futures, and tasks</li>&#13;
      <li class="bulletList">Functions using <code class="inlineCode">async def</code>, <code class="inlineCode">async for</code>, <code class="inlineCode">async with</code>, and <code class="inlineCode">await</code></li>&#13;
      <li class="bulletList">Parallel execution</li>&#13;
      <li class="bulletList">Examples of implementation with <code class="inlineCode">asyncio</code>, including clients and servers</li>&#13;
      <li class="bulletList">Debugging <code class="inlineCode">asyncio</code></li>&#13;
    </ul>&#13;
    <h1 id="_idParaDest-364" class="heading-1">Introduction to asyncio</h1>&#13;
    <p class="normal">The <code class="inlineCode">asyncio</code> library<a id="_idIndexMarker1044"/> was created to make using asynchronous processing much easier and more predictable. It was meant as a replacement for the <code class="inlineCode">asyncore</code> module, which has been available for a very long time (since Python 1.5 even) but was not all that usable. The <code class="inlineCode">asyncio</code> library was officially introduced for Python 3.4 and has seen many improvements with each newer Python release since.</p>&#13;
    <p class="normal">In a nutshell, the <code class="inlineCode">asyncio</code> library allows you to switch to the execution of a different function whenever you need to wait for I/O operations. So instead of Python waiting for your operating system to finish reading a file for you, blocking the entire application in the process, it can do something useful in a different function in the meantime.</p>&#13;
    <h2 id="_idParaDest-365" class="heading-2">Backward compatibility and async/await statements</h2>&#13;
    <p class="normal">Before we continue with <a id="_idIndexMarker1045"/>any examples, it is important to know how <code class="inlineCode">asyncio</code> has changed within Python versions. Even though the <code class="inlineCode">asyncio</code> library was only introduced in Python 3.4, a large portion of the generic syntax has been replaced in Python 3.5. Using the old Python 3.4 syntax is still possible, but an easier and therefore recommended syntax using <code class="inlineCode">await</code> has been introduced.</p>&#13;
    <p class="normal">This chapter will assume<a id="_idIndexMarker1046"/> Python 3.7 or newer in all examples unless specified differently. If you are still running an older version, however, please look at the following sections, which illustrate how to run <code class="inlineCode">asyncio</code> on older systems. If you have Python 3.7+, feel free to skip to the section titled <em class="italic">A basic example of parallel execution</em>.</p>&#13;
    <h3 id="_idParaDest-366" class="heading-3">Python 3.4</h3>&#13;
    <p class="normal">For the traditional <a id="_idIndexMarker1047"/>Python 3.4 usage, a few things need to be considered:</p>&#13;
    <ul>&#13;
      <li class="bulletList">Functions should be declared using the <code class="inlineCode">asyncio.coroutine</code> decorator</li>&#13;
      <li class="bulletList">Asynchronous results should be fetched using <code class="inlineCode">yield from coroutine()</code></li>&#13;
      <li class="bulletList">Asynchronous <a id="_idIndexMarker1048"/>loops are not directly supported, but can be emulated using a <code class="inlineCode">while True: yield from coroutine()</code></li>&#13;
    </ul>&#13;
    <p class="normal">Example:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> asyncio&#13;
&#13;
<span class="hljs-meta">@asyncio.coroutine</span>&#13;
<span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">main</span><span class="hljs-function">():</span>&#13;
    print(<span class="hljs-string">'Hello from main'</span>)&#13;
    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">from</span> asyncio.sleep(<span class="hljs-number">1</span>)&#13;
&#13;
loop = asyncio.new_event_loop()&#13;
loop.run_until_complete(main())&#13;
loop.close()&#13;
</code></pre>&#13;
    <h3 id="_idParaDest-367" class="heading-3">Python 3.5</h3>&#13;
    <p class="normal">The Python 3.5 syntax<a id="_idIndexMarker1049"/> is much more obvious than the Python 3.4 version. While the <code class="inlineCode">yield from</code> is understandable given the origins of coroutines in earlier Python versions, it is actually the wrong name for the job. Let <code class="inlineCode">yield</code> be used for generators and <code class="inlineCode">await</code> be used in coroutines.</p>&#13;
    <ul>&#13;
      <li class="bulletList">Functions should be declared using <code class="inlineCode">async def</code> instead of <code class="inlineCode">def</code></li>&#13;
      <li class="bulletList">Asynchronous results should be fetched using <code class="inlineCode">await coroutine()</code></li>&#13;
      <li class="bulletList">Asynchronous loops can be created using <code class="inlineCode">async for ... in ...</code></li>&#13;
    </ul>&#13;
    <p class="normal">Example:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> asyncio&#13;
&#13;
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">main</span><span class="hljs-function">():</span>&#13;
    print(<span class="hljs-string">'Hello from main'</span>)&#13;
    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)&#13;
&#13;
loop = asyncio.new_event_loop()&#13;
loop.run_until_complete(main())&#13;
loop.close()&#13;
</code></pre>&#13;
    <h3 id="_idParaDest-368" class="heading-3">Python 3.7</h3>&#13;
    <p class="normal">Since Python 3.7<a id="_idIndexMarker1050"/> it has become slightly easier and more obvious to run <code class="inlineCode">asyncio</code> code. If you have the luxury of a newer Python version, you can use the following to run your <code class="inlineCode">async</code> function:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> asyncio&#13;
&#13;
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">main</span><span class="hljs-function">():</span>&#13;
    print(<span class="hljs-string">'Hello from main'</span>)&#13;
    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)&#13;
&#13;
asyncio.run(main())&#13;
</code></pre>&#13;
    <p class="normal">With older Python versions, we need a fairly advanced bit of code to properly replace <code class="inlineCode">asyncio.run()</code>, but if you are not concerned with potentially reusing existing event loops (detailed information about event loops can be found later in the chapter) and take care of shutting down your tasks yourself, you can get away with the following:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> asyncio&#13;
&#13;
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">main</span><span class="hljs-function">():</span>&#13;
    print(<span class="hljs-string">'Hello from main'</span>)&#13;
    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)&#13;
&#13;
loop = asyncio.new_event_loop()&#13;
asyncio.set_event_loop(loop)&#13;
<span class="hljs-keyword">try</span>:&#13;
    loop.run_until_complete(main())&#13;
<span class="hljs-keyword">finally</span>:&#13;
    <span class="hljs-comment"># Run the loop again to finish pending tasks</span>&#13;
    loop.run_until_complete(asyncio.sleep(<span class="hljs-number">0</span>))&#13;
&#13;
    asyncio.set_event_loop(<span class="hljs-literal">None</span>)&#13;
    loop.close()&#13;
</code></pre>&#13;
    <p class="normal">Or a shorter version that is certainly not equivalent but will handle many of your test cases:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> asyncio&#13;
&#13;
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">main</span><span class="hljs-function">():</span>&#13;
    print(<span class="hljs-string">'Hello from main'</span>)&#13;
    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)&#13;
&#13;
loop = asyncio.get_event_loop()&#13;
loop.run_until_complete(main())&#13;
</code></pre>&#13;
    <p class="normal">If at all possible, I <a id="_idIndexMarker1051"/>would certainly recommend using <code class="inlineCode">asyncio.run()</code>, of course. Even without <code class="inlineCode">asyncio.run()</code>, you are likely to run into library compatibility issues with older versions of Python.</p>&#13;
    <p class="normal">If you have to, however, you can find the source for <code class="inlineCode">asyncio.run()</code> in the Python Git so you can implement a simplified version yourself: <a href="https://github.com/python/cpython/blob/main/Lib/asyncio/runners.py"><span class="url">https://github.com/python/cpython/blob/main/Lib/asyncio/runners.py</span></a>.</p>&#13;
    <h2 id="_idParaDest-369" class="heading-2">A basic example of parallel execution</h2>&#13;
    <p class="normal">When it comes to <a id="_idIndexMarker1052"/>code performance, you will usually encounter one of the two following bottlenecks:</p>&#13;
    <ul>&#13;
      <li class="bulletList">Waiting for external I/O such as web servers, the filesystem, a database server, anything network-related, and others</li>&#13;
      <li class="bulletList">The CPU, in the case of heavy calculations</li>&#13;
    </ul>&#13;
    <p class="normal">If your CPU is the bottleneck due to heavy calculations, you will need to resort to using faster algorithms, faster or more processors, or offloading the calculations to dedicated hardware such as video cards. In these cases, the <code class="inlineCode">asyncio</code> library won’t help you much.</p>&#13;
    <p class="normal">If your code is mostly waiting for the user, the kernel, the filesystem, or external servers, <code class="inlineCode">asyncio</code> can help you a lot while being a fairly easy solution with few side effects. As we will see in the <em class="italic">asyncio concepts</em> section, there are some caveats, however. Making existing code <code class="inlineCode">asyncio</code>-compatible can be a lot of work.</p>&#13;
    <p class="normal">Let’s start with a very simple example to show the difference between regular and <code class="inlineCode">asyncio</code> code when having to wait.</p>&#13;
    <p class="normal">First, the regular Python version that executes a 1-second <code class="inlineCode">sleep</code> two times:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> time&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> asyncio&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">normal_sleep</span><span class="hljs-con-function">():</span>&#13;
<span class="hljs-con-meta">...</span>     print(<span class="hljs-con-string">'before sleep'</span>)&#13;
<span class="hljs-con-meta">...</span>     time.sleep(<span class="hljs-con-number">1</span>)&#13;
<span class="hljs-con-meta">...</span>     print(<span class="hljs-con-string">'after sleep'</span>)&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">normal_sleeps</span><span class="hljs-con-function">(</span><span class="hljs-con-params">n</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">for</span> _ <span class="hljs-con-keyword">in</span> <span class="hljs-con-built_in">range</span>(n):&#13;
<span class="hljs-con-meta">...</span>         normal_sleep()&#13;
&#13;
<span class="hljs-con-comment"># Normal execution</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> start = time.time()&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> normal_sleeps(<span class="hljs-con-number">2</span>)&#13;
before sleep&#13;
after sleep&#13;
before sleep&#13;
after sleep&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> print(<span class="hljs-con-string">f'duration: </span><span class="hljs-con-subst">{time.time() - start:</span><span class="hljs-con-number">.0</span><span class="hljs-con-subst">f}</span><span class="hljs-con-string">'</span>)&#13;
duration: 2&#13;
</code></pre>&#13;
    <p class="normal">And now<a id="_idIndexMarker1053"/> the <code class="inlineCode">asyncio</code> version that executes a 1-second <code class="inlineCode">sleep</code> two times:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">async</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">asyncio_sleep</span><span class="hljs-con-function">():</span>&#13;
<span class="hljs-con-meta">...</span>     print(<span class="hljs-con-string">'before sleep'</span>)&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">await</span> asyncio.sleep(<span class="hljs-con-number">1</span>)&#13;
<span class="hljs-con-meta">...</span>     print(<span class="hljs-con-string">'after sleep'</span>)&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">async</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">asyncio_sleeps</span><span class="hljs-con-function">(</span><span class="hljs-con-params">n</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>     coroutines = []&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">for</span> _ <span class="hljs-con-keyword">in</span> <span class="hljs-con-built_in">range</span>(n):&#13;
<span class="hljs-con-meta">...</span>         coroutines.append(asyncio_sleep())&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">await</span> asyncio.gather(*coroutines)&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> start = time.time()&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> asyncio.run(asyncio_sleeps(<span class="hljs-con-number">2</span>))&#13;
before sleep&#13;
before sleep&#13;
after sleep&#13;
after sleep&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> print(<span class="hljs-con-string">f'duration: </span><span class="hljs-con-subst">{time.time() - start:</span><span class="hljs-con-number">.0</span><span class="hljs-con-subst">f}</span><span class="hljs-con-string">'</span>)&#13;
duration: 1&#13;
</code></pre>&#13;
    <p class="normal">As you can see, it still had to wait 1 second for the actual <code class="inlineCode">sleep</code>, but it could run them in parallel. The <code class="inlineCode">asyncio_sleep()</code> functions started simultaneously, as can be seen by the <code class="inlineCode">before sleep</code> output.</p>&#13;
    <p class="normal">Let’s analyze the <a id="_idIndexMarker1054"/>components used in this example:</p>&#13;
    <ul>&#13;
      <li class="bulletList"><code class="inlineCode">async def</code>: This <a id="_idIndexMarker1055"/>tells the Python interpreter that our function is a coroutine function instead of a regular function.</li>&#13;
      <li class="bulletList"><code class="inlineCode">asyncio.sleep()</code>: Asynchronous version of <code class="inlineCode">time.sleep()</code>. The big difference between<a id="_idIndexMarker1056"/> these two is that <code class="inlineCode">time.sleep()</code> will keep the Python process busy while it’s sleeping, while <code class="inlineCode">asyncio.sleep()</code> will allow switching to a different task within the event loop. This process is very similar to the workings of task switching in most operating systems.</li>&#13;
      <li class="bulletList"><code class="inlineCode">asyncio.run()</code>: A wrapper that executes a coroutine in the default event loop. This <a id="_idIndexMarker1057"/>is effectively the <code class="inlineCode">asyncio</code> task switcher; more about this in the next section.</li>&#13;
      <li class="bulletList"><code class="inlineCode">asyncio.gather()</code>: Wraps a sequence of awaitable objects and gathers the results for you. The <a id="_idIndexMarker1058"/>wait time is configurable, as is the manner of waiting. You can choose to wait until the first result, until all results are available, or until the first exception occurs.</li>&#13;
    </ul>&#13;
    <p class="normal">This immediately demonstrates a few of the caveats and pitfalls of <code class="inlineCode">asyncio</code> code as well.</p>&#13;
    <p class="normal">If we had accidentally used <code class="inlineCode">time.sleep()</code> instead of <code class="inlineCode">asyncio.sleep()</code>, the code would have taken 2 seconds to run instead and blocked the entire loop while doing so. More about this in the next section.</p>&#13;
    <p class="normal">If we had used <code class="inlineCode">await asyncio.sleep()</code> instead of using <code class="inlineCode">await asyncio.gather()</code> at the end, the code would have run sequentially, and not in parallel, as you are probably looking for.</p>&#13;
    <p class="normal">Now that we have seen a basic example of <code class="inlineCode">asyncio</code>, we need to learn more about the internals so the limitations become more apparent.</p>&#13;
    <h2 id="_idParaDest-370" class="heading-2">asyncio concepts</h2>&#13;
    <p class="normal">The <code class="inlineCode">asyncio</code> library has<a id="_idIndexMarker1059"/> several basic concepts that have to be explained before venturing further into examples and uses. The example shown in the previous section actually uses several of them, but a little explanation about the how and why might still be useful.</p>&#13;
    <p class="normal">The main concepts of <code class="inlineCode">asyncio</code> are coroutines and event loops. Within those there are several helper classes available such as <code class="inlineCode">Streams</code>, <code class="inlineCode">Futures</code>, and <code class="inlineCode">Processes</code>. The next few paragraphs will explain the basics of them so we can understand the implementations as examples in the later sections.</p>&#13;
    <h3 id="_idParaDest-371" class="heading-3">Coroutines, Futures, and Tasks</h3>&#13;
    <p class="normal">The <code class="inlineCode">coroutine</code>, <code class="inlineCode">asyncio.Future</code>, and <code class="inlineCode">asyncio.Task</code> objects are essentially promises of a result; they return the results if they are available and can be used to cancel the execution of the<a id="_idIndexMarker1060"/> promise if they have not finished processing yet. It should be noted that the creation of these objects will not guarantee that the code will be executed. The actual execution starts happening when you either <code class="inlineCode">await</code> the results or tell an event loop to execute the promise. This is covered in the next section about event loops. </p>&#13;
    <p class="normal">The most basic object you will encounter when using <code class="inlineCode">asyncio</code> is the <code class="inlineCode">coroutine</code>. The result of any regular <code class="inlineCode">async def</code> (such as <code class="inlineCode">asyncio.sleep()</code>) is a <code class="inlineCode">coroutine</code> object. Once you <code class="inlineCode">await</code> that <code class="inlineCode">coroutine</code>, it will be executed and you will get the results.</p>&#13;
    <p class="normal">The <code class="inlineCode">asyncio.Future</code> and <code class="inlineCode">asyncio.Task</code> classes can also be executed through <code class="inlineCode">await</code>, but also allow you to register<a id="_idIndexMarker1061"/> callback functions that receive the results (or exceptions) as soon as they are available. Additionally, they maintain a state variable internally, which allows an outside party to cancel the future and stop (or prevent) its execution. The API is very similar to the <code class="inlineCode">concurrent.futures.Future</code> class, but they are not fully compatible, so make sure you do not confuse the two.</p>&#13;
    <p class="normal">To clarify a bit further, all of these are awaitable but have different levels of abstraction:</p>&#13;
    <ul>&#13;
      <li class="bulletList"><code class="inlineCode">coroutine</code>: The result of a <a id="_idIndexMarker1062"/>called <code class="inlineCode">async def</code> that has not yet been awaited. You will mostly use these.</li>&#13;
      <li class="bulletList"><code class="inlineCode">asyncio.Future</code>: A class <a id="_idIndexMarker1063"/>that represents an eventual result. It does not need to wrap a <code class="inlineCode">coroutine</code> and the result can be set manually.</li>&#13;
      <li class="bulletList"><code class="inlineCode">asyncio.Task</code>: An implementation of <code class="inlineCode">asyncio.Future</code> that is meant to wrap a <code class="inlineCode">coroutine</code> to have <a id="_idIndexMarker1064"/>a convenient and consistent interface.</li>&#13;
    </ul>&#13;
    <p class="normal">Usually the creation of these classes is not something you need to worry about directly; instead of creating the class yourself, the recommended way is through either <code class="inlineCode">asyncio.create_task() </code>or <code class="inlineCode">loop.create_task()</code>. The former actually executes <code class="inlineCode">loop.create_task()</code> internally, but it’s more convenient if you simply want to execute it on the running event loop through <code class="inlineCode">asyncio.get_running_loop()</code> without having to specify it. If you need to extend the <code class="inlineCode">Task</code> class for some reason, that is easily possible through the <code class="inlineCode">loop.set_task_factory()</code> method. </p>&#13;
    <p class="normal">Before Python 3.7, <code class="inlineCode">asyncio.create_task()</code> was called <code class="inlineCode">asyncio.ensure_future()</code>.</p>&#13;
    <h3 id="_idParaDest-372" class="heading-3">Event loops</h3>&#13;
    <p class="normal">The event loop<a id="_idIndexMarker1065"/> concept is actually the most important one within <code class="inlineCode">asyncio</code>. You might suspect that the coroutines themselves are what everything is about, but without the event loop they are useless. Event loops function as task switchers, similar to how operating systems switch between active tasks on the CPU. Even with multicore processors, there still needs to be a main process to tell the CPU which tasks to run and which need to wait or sleep for a bit. That is exactly what the event loop does: it decides which task to run.</p>&#13;
    <p class="normal">Effectively, every time you do <code class="inlineCode">await</code>, the event loop will look at the pending awaitables and will continue the execution of one that is currently pending. This is also where the danger of a single event loop comes in. If, for some reason, you have a slow/blocking function in your coroutine, such as accidentally using <code class="inlineCode">time.sleep()</code> instead of <code class="inlineCode">asyncio.sleep()</code>, it will block the entire event loop until it finishes.</p>&#13;
    <p class="normal">In practice, this means that <code class="inlineCode">await asyncio.sleep(5)</code> only guarantees that your code will wait <em class="italic">at least</em> 5 seconds. If, during that <code class="inlineCode">await</code>, some other coroutine blocked the event loop for 10 seconds, the <code class="inlineCode">asyncio.sleep(5)</code> would take at least 10 seconds.</p>&#13;
    <h4 class="heading-4">Event loop implementations</h4>&#13;
    <p class="normal">So far we have only<a id="_idIndexMarker1066"/> seen <code class="inlineCode">asyncio.run()</code>, which uses <code class="inlineCode">asyncio.get_event_loop()</code> internally to return the default event loop with the default event loop policy. Currently, there are two bundled event loop implementations:</p>&#13;
    <ul>&#13;
      <li class="bulletList">The <code class="inlineCode">asyncio.SelectorEventLoop</code> implementation, which is used by default on Unix and Linux systems</li>&#13;
      <li class="bulletList">The <code class="inlineCode">asyncio.ProactorEventLoop</code> implementation, which is only supported (and the default) on Windows</li>&#13;
    </ul>&#13;
    <p class="normal">Internally, the <code class="inlineCode">asyncio.ProactorEventLoop</code> implementation uses I/O completion ports, a system that is supposedly faster and more efficient than the <code class="inlineCode">select</code> implementation of the <code class="inlineCode">asyncio.SelectorEventLoop</code> on Windows systems.</p>&#13;
    <p class="normal">The <code class="inlineCode">asyncio.SelectorEventLoop</code> is based on selectors, which, since Python 3.4, are available through the <code class="inlineCode">select</code> module in the core Python module. There are several selectors available: the traditional <code class="inlineCode">selectors.SelectSelector</code>, which uses <code class="inlineCode">select.select</code> internally, but also more modern solutions such as <code class="inlineCode">selectors.KqueueSelector</code>, <code class="inlineCode">selectors.EpollSelector</code>, and <code class="inlineCode">selectors.DevpollSelector</code>. Even though <code class="inlineCode">asyncio.SelectorEventLoop</code> will select the most efficient selector<a id="_idIndexMarker1067"/> by default, there are cases where the most efficient one is not suitable in some way or another.</p>&#13;
    <div class="note">&#13;
      <p class="normal">The most efficient selector is chosen by process of elimination. If the <code class="inlineCode">select</code> module has a <code class="inlineCode">kqueue</code> attribute, the <code class="inlineCode">KqueueSelector</code> will be used. If <code class="inlineCode">kqueue</code> is not available, the next best option will be chosen in the following order:</p>&#13;
      <ol class="numberedList" style="list-style-type: decimal;">&#13;
        <li class="numberedList" value="1"><code class="inlineCode">KqueueSelector</code>: <code class="inlineCode">kqueue</code> is an event notification interface for BSD systems. It is currently supported on FreeBSD, NetBSD, OpenBSD, DragonFly BSD, and macOS (OS X).</li>&#13;
        <li class="numberedList"><code class="inlineCode">EpollSelector</code>: <code class="inlineCode">epoll</code> is the Linux kernel version of <code class="inlineCode">kqueue</code>.</li>&#13;
        <li class="numberedList"><code class="inlineCode">DevpollSelector</code>: This selector uses <code class="inlineCode">/dev/poll</code>, a system that is similar to <code class="inlineCode">kqueue</code> and <code class="inlineCode">epoll</code> but is supported on Solaris systems.</li>&#13;
        <li class="numberedList"><code class="inlineCode">PollSelector</code>: <code class="inlineCode">poll()</code> is a system call that will call your function when an update is available. The actual implementation depends on the system.</li>&#13;
        <li class="numberedList"><code class="inlineCode">SelectSelector</code>: Very similar to <code class="inlineCode">poll()</code>, but <code class="inlineCode">select()</code> builds a bitmap for all file descriptors and walks through that list for every update, which is quite a bit less efficient than <code class="inlineCode">poll()</code>.</li>&#13;
      </ol>&#13;
    </div>&#13;
    <p class="normal">In those cases, the selector event loop allows you to specify a different selector:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> asyncio&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> selectors&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> selector = selectors.SelectSelector()&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> loop = asyncio.SelectorEventLoop(selector)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> asyncio.set_event_loop(loop)&#13;
</code></pre>&#13;
    <p class="normal">It should be noted that the differences between these are generally too small to notice in most real-world applications. This is why I would recommend ignoring optimizations like these wherever possible, as they will most likely have very little effect and might actually cause problems if used incorrectly. The only situation I have come across where these would actually matter is when building a server that has to handle a lot of simultaneous connections. By “a lot,” I refer to over 100,000 concurrent connections on a single server, which<a id="_idIndexMarker1068"/> is a problem only a few people on this planet have to deal with.</p>&#13;
    <p class="normal">If performance is important to you (and you are running Linux/OS X) I would recommend looking at <code class="inlineCode">uvloop</code>, a really fast event loop that is built on <code class="inlineCode">libuv</code>, an asynchronous I/O library written in C that’s supported on most platforms. According to the <code class="inlineCode">uvloop</code> benchmarks, it can make your event loop 2-4 times faster.</p>&#13;
    <h4 class="heading-4">Event loop policies</h4>&#13;
    <p class="normal">The event loop policies<a id="_idIndexMarker1069"/> are merely the constructs that store and create event loops for you and have been written with maximum flexibility in mind. The only reason I can think of for modifying the event loop policy is if you want to make specific event loops run on specific processors and/or systems, such as enabling <code class="inlineCode">uvloop</code> only if you are running Linux or OS X. Beyond that, it offers more flexibility than most people will ever need. To make <code class="inlineCode">uvloop</code> the default loop if installed, you could do the following:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> asyncio&#13;
&#13;
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">UvLoopPolicy</span><span class="hljs-class">(</span><span class="hljs-params">asyncio.DefaultEventLoopPolicy</span><span class="hljs-class">):</span>&#13;
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">new_event_loop</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>&#13;
        <span class="hljs-keyword">try</span>:&#13;
            <span class="hljs-keyword">from</span> uvloop <span class="hljs-keyword">import</span> Loop&#13;
            <span class="hljs-keyword">return</span> Loop()&#13;
        <span class="hljs-keyword">except</span> ImportError:&#13;
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().new_event_loop()&#13;
&#13;
asyncio.set_event_loop_policy(UvLoopPolicy())&#13;
</code></pre>&#13;
    <p class="normal">Beyond overriding the <code class="inlineCode">new_event_loop()</code> to customize the creation of new event loops, you can also override how the re-use of event loops works by overriding the <code class="inlineCode">get_event_loop()</code> and <code class="inlineCode">set_event_loop()</code> methods. I <a id="_idIndexMarker1070"/>have personally never had any use for it beyond enabling <code class="inlineCode">uvloop</code>, however.</p>&#13;
    <h4 class="heading-4">Event loop usage</h4>&#13;
    <p class="normal">Now that we know <a id="_idIndexMarker1071"/>what event loops are, what they do, and how an event loop is selected, let’s look at how they can be applied beyond <code class="inlineCode">asyncio.run()</code>.</p>&#13;
    <p class="normal">If you get into running your own event loops you will likely use <code class="inlineCode">loop.run_forever()</code>, which, as you might expect, keeps running forever. Or at least until <code class="inlineCode">loop.stop()</code> has been run. But you can also run a single task using <code class="inlineCode">loop.run_until_complete()</code>. The latter is very useful for one-off operations, but can cause bugs in some scenarios. If you create a task from a very small/quick coroutine, odds are that the task will not have any time to run so it won’t be executed until the next time you execute <code class="inlineCode">loop.run_until_complete()</code> or <code class="inlineCode">loop.run_forever()</code>. More about that later in this chapter, however; for now, we will assume a long-running loop using <code class="inlineCode">loop.run_forever()</code>.</p>&#13;
    <p class="normal">Because we have an event loop running forever now, we need to add tasks to it – this is where things get interesting. There are quite a few choices available within the default event loops:</p>&#13;
    <ul>&#13;
      <li class="bulletList"><code class="inlineCode">call_soon()</code>: Add an item to the end of the (FIFO) queue so the functions will be executed in the order they were inserted.</li>&#13;
      <li class="bulletList"><code class="inlineCode">call_soon_threadsafe()</code>: The same as <code class="inlineCode">call_soon()</code> except for being thread-safe. The <code class="inlineCode">call_soon()</code> method isn’t thread-safe because thread safety requires the usage of <a id="_idIndexMarker1072"/>the <strong class="keyWord">global interpreter lock </strong>(<strong class="keyWord">GIL</strong>), which effectively makes your program single-threaded at the moment of thread safety. <em class="chapterRef">Chapter 14, Multiprocessing – When a Single CPU Core is Not Enough, </em>explains both the GIL and thread safety in detail.</li>&#13;
      <li class="bulletList"><code class="inlineCode">call_later()</code>: Call the function after the given number of seconds; if two jobs would run at the same time, they will run in an undefined order. If the undefined order is an issue, you can also opt to use <code class="inlineCode">asyncio.gather()</code> or increase the <code class="inlineCode">delay</code> parameter for one of the two tasks slightly. Note that the <code class="inlineCode">delay</code> is a minimum – if the event loop is locked/busy, it could run later.</li>&#13;
      <li class="bulletList"><code class="inlineCode">call_at()</code>: Call a function at a specific time related to the output of <code class="inlineCode">loop.time()</code>, which is the number of seconds since the <code class="inlineCode">loop</code> started. So, if the current value of <code class="inlineCode">loop.time()</code> is <code class="inlineCode">90</code> (which means the <code class="inlineCode">loop</code> started running <code class="inlineCode">90</code> seconds ago), then you could run <code class="inlineCode">loop.call_at(95, ...)</code> to run after <code class="inlineCode">5</code> seconds.</li>&#13;
    </ul>&#13;
    <p class="normal">All of these functions<a id="_idIndexMarker1073"/> return <code class="inlineCode">asyncio.Handle</code> objects. These objects allow the cancelation of the task if it hasn’t been executed yet through the <code class="inlineCode">handle.cancel()</code> function. Be careful with canceling from other threads, however, as cancelation is not thread-safe either. To execute it in a thread-safe way, we have to execute the cancelation function as a task as well: <code class="inlineCode">loop.call_soon_threadsafe(handle.cancel)</code>. </p>&#13;
    <p class="normal">Example usage:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> time&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> asyncio&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">printer</span><span class="hljs-con-function">(</span><span class="hljs-con-params">name</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>     print(<span class="hljs-con-string">f'Started </span><span class="hljs-con-subst">{name}</span><span class="hljs-con-string"> at </span><span class="hljs-con-subst">{loop.time() - offset:</span><span class="hljs-con-number">.1</span><span class="hljs-con-subst">f}</span><span class="hljs-con-string">'</span>)&#13;
<span class="hljs-con-meta">...</span>     time.sleep(<span class="hljs-con-number">0.2</span>)&#13;
<span class="hljs-con-meta">...</span>     print(<span class="hljs-con-string">f'Finished </span><span class="hljs-con-subst">{name}</span><span class="hljs-con-string"> at </span><span class="hljs-con-subst">{loop.time() - offset:</span><span class="hljs-con-number">.1</span><span class="hljs-con-subst">f}</span><span class="hljs-con-string">'</span>)&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> loop = asyncio.new_event_loop()&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> _ = loop.call_at(loop.time() + <span class="hljs-con-number">.2</span>, printer, <span class="hljs-con-string">'call_at'</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> _ = loop.call_later(<span class="hljs-con-number">.1</span>, printer, <span class="hljs-con-string">'call_later'</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> _ = loop.call_soon(printer, <span class="hljs-con-string">'call_soon'</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> _ = loop.call_soon_threadsafe(printer, <span class="hljs-con-string">'call_soon_threadsafe'</span>)&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-comment"># Make sure we stop after a second</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> _ = loop.call_later(<span class="hljs-con-number">1</span>, loop.stop)&#13;
&#13;
<span class="hljs-con-comment"># Store the offset because the loop requires time to start</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> offset = loop.time()&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> loop.run_forever()&#13;
Started call_soon at 0.0&#13;
Finished call_soon at 0.2&#13;
Started call_soon_threadsafe at 0.2&#13;
Finished call_soon_threadsafe at 0.4&#13;
Started call_later at 0.4&#13;
Finished call_later at 0.6&#13;
Started call_at at 0.6&#13;
Finished call_at at 0.8&#13;
</code></pre>&#13;
    <p class="normal">You might be wondering why we are using <code class="inlineCode">time.sleep()</code> instead of <code class="inlineCode">asyncio.sleep()</code> here. That is an intentional choice to show how none of these functions offer any guarantee of when the function is executed if the <code class="inlineCode">loop</code> is somehow blocked. Even though we specified a <code class="inlineCode">0.1</code> second delay for the <code class="inlineCode">loop.call_later()</code> call, it took <code class="inlineCode">0.4</code> seconds to actually start. If we had used <code class="inlineCode">asyncio.sleep()</code> instead, the functions would have run in parallel.</p>&#13;
    <p class="normal">The <code class="inlineCode">call_soon()</code>, <code class="inlineCode">call_soon_threadsafe()</code>, and <code class="inlineCode">call_later()</code> functions are all just wrappers for <code class="inlineCode">call_at()</code>. In the case of <code class="inlineCode">call_soon()</code>, it just wraps <code class="inlineCode">call_later()</code> with a delay of <code class="inlineCode">0</code>, and <code class="inlineCode">call_at()</code> is simply a <code class="inlineCode">call_soon()</code> with <code class="inlineCode">asyncio.time()</code> added to the delay.</p>&#13;
    <p class="normal">Depending on<a id="_idIndexMarker1074"/> the type of event loop, there are actually many other methods for creating connections, file handlers, and more, similar to <code class="inlineCode">asyncio.create_task()</code>. Those will be explained with examples in the later sections, since they have less to do with the event loop and are more about programming with coroutines.</p>&#13;
    <h3 id="_idParaDest-373" class="heading-3">Executors</h3>&#13;
    <p class="normal">Since even a<a id="_idIndexMarker1075"/> simple <code class="inlineCode">time.sleep()</code> can completely block your event loop, you might be wondering what the practical use for <code class="inlineCode">asyncio</code> is. It would mean you have to rewrite your entire code base to be <code class="inlineCode">asyncio</code>-compatible, right? Ideally that would be the best solution, but we can work around this limitation by executing sync code from <code class="inlineCode">asyncio</code> code using executors. An <code class="inlineCode">Executor</code> creates the other type of <code class="inlineCode">Future</code> (<code class="inlineCode">concurrent.futures.Future</code> as opposed to <code class="inlineCode">asyncio.Future</code>) we talked about earlier, and runs your code in a separate thread or process to provide an <code class="inlineCode">asyncio</code> interface to synchronous code.</p>&#13;
    <p class="normal">Here is a basic example of the synchronous <code class="inlineCode">time.sleep()</code> executed through an executor to make it asynchronous:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> time&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> asyncio&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">executor_sleep</span><span class="hljs-con-function">():</span>&#13;
<span class="hljs-con-meta">...</span>     print(<span class="hljs-con-string">'before sleep'</span>)&#13;
<span class="hljs-con-meta">...</span>     time.sleep(<span class="hljs-con-number">1</span>)&#13;
<span class="hljs-con-meta">...</span>     print(<span class="hljs-con-string">'after sleep'</span>)&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">async</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">executor_sleeps</span><span class="hljs-con-function">(</span><span class="hljs-con-params">n</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>     loop = asyncio.get_running_loop()&#13;
<span class="hljs-con-meta">...</span>     futures = []&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">for</span> _ <span class="hljs-con-keyword">in</span> <span class="hljs-con-built_in">range</span>(n):&#13;
<span class="hljs-con-meta">...</span>         future = loop.run_in_executor(<span class="hljs-con-literal">None</span>, executor_sleep)&#13;
<span class="hljs-con-meta">...</span>         futures.append(future)&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">await</span> asyncio.gather(*futures)&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> start = time.time()&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> asyncio.run(executor_sleeps(<span class="hljs-con-number">2</span>))&#13;
before sleep&#13;
before sleep&#13;
after sleep&#13;
after sleep&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> print(<span class="hljs-con-string">f'duration: </span><span class="hljs-con-subst">{time.time() - start:</span><span class="hljs-con-number">.0</span><span class="hljs-con-subst">f}</span><span class="hljs-con-string">'</span>)&#13;
duration: 1&#13;
</code></pre>&#13;
    <p class="normal">So, instead of running <code class="inlineCode">executor_sleep()</code> directly, we are creating a future through <code class="inlineCode">loop.run_in_executor()</code>. This makes <code class="inlineCode">asyncio</code> execute this function through the default executor, which is normally a <code class="inlineCode">concurrent.futures.ThreadPoolExecutor</code>, and return the results when it’s done. You do need to be aware of thread safety because it is handled in a separate thread, but more about that topic in the next chapter.</p>&#13;
    <p class="normal">For operations that <a id="_idIndexMarker1076"/>are blocking but not CPU-bound (in other words, no heavy calculations), the default threading-based executor will work great. For CPU-bound operations it will not help you, since the operations will still be limited to a single CPU core. For those scenarios, we can use <code class="inlineCode">concurrent.futures.ProcessPoolExecutor()</code>:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> time&#13;
<span class="hljs-keyword">import</span> asyncio&#13;
<span class="hljs-keyword">import</span> concurrent.futures&#13;
&#13;
<span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">executor_sleep</span><span class="hljs-function">():</span>&#13;
    print(<span class="hljs-string">'before sleep'</span>)&#13;
    time.sleep(<span class="hljs-number">1</span>)&#13;
    print(<span class="hljs-string">'after sleep'</span>)&#13;
&#13;
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">executor_sleeps</span><span class="hljs-function">(</span><span class="hljs-params">n</span><span class="hljs-function">):</span>&#13;
    loop = asyncio.get_running_loop()&#13;
    futures = []&#13;
    <span class="hljs-keyword">with</span> concurrent.futures.ProcessPoolExecutor() <span class="hljs-keyword">as</span> pool:&#13;
        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):&#13;
            future = loop.run_in_executor(pool, executor_sleep)&#13;
            futures.append(future)&#13;
&#13;
        <span class="hljs-keyword">await</span> asyncio.gather(*futures)&#13;
&#13;
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:&#13;
    start = time.time()&#13;
    asyncio.run(executor_sleeps(<span class="hljs-number">2</span>))&#13;
    print(<span class="hljs-string">f'duration: </span><span class="hljs-subst">{time.time() - start:</span><span class="hljs-number">.0</span><span class="hljs-subst">f}</span><span class="hljs-string">'</span>)&#13;
</code></pre>&#13;
    <p class="normal">While this example looks nearly identical to the previous example, the internal mechanism is quite different and the use of multiple Python processes instead of multiple threads comes <a id="_idIndexMarker1077"/>with several caveats:</p>&#13;
    <ul>&#13;
      <li class="bulletList">Memory cannot easily be shared between processes. This means that anything you want to pass as an argument and anything that you need to return has to be supported by the <code class="inlineCode">pickle</code> process so Python can send the data, through the network, to the other Python process. This is explained in detail in <em class="chapterRef">Chapter 14</em>.</li>&#13;
      <li class="bulletList">The main script has to be run from an <code class="inlineCode">if __name__ == '__main__'</code> block, otherwise the executor would end up in an infinite loop spawning itself.</li>&#13;
      <li class="bulletList">Most resources cannot be shared between processes. This is similar to not being able to share memory, but it goes beyond that. If you have a database connection in your main process, that connection cannot be used from the process so it will need to have its own connections.</li>&#13;
      <li class="bulletList">Killing/exiting the process can be more difficult since killing the main process is not always a guarantee of killing the child processes.</li>&#13;
      <li class="bulletList">Depending on your operating system, every new process will use its own memory, resulting in greatly increased memory usage.</li>&#13;
      <li class="bulletList">Creating a new process is generally a far heavier operation than creating a new thread, so you have a lot more overhead.</li>&#13;
      <li class="bulletList">Synchronization between processes is much slower than with threads.</li>&#13;
    </ul>&#13;
    <p class="normal">All of these reasons definitely shouldn’t prevent you from using <code class="inlineCode">ProcessPoolExecutor</code>, but you should always ask yourself if you actually need it. It can be an amazing solution if you need to run many heavy calculations in parallel. If at all possible, I would recommend using functional programming with <code class="inlineCode">ProcessPoolExecutor</code>. <em class="chapterRef">Chapter 14</em>,<em class="chapterRef"> </em><em class="italic">Multiprocessing – When a Single CPU Core Is Not Enough</em>, covers<a id="_idIndexMarker1078"/> multiprocessing in much more detail.</p>&#13;
    <p class="normal">Now that we have a basic grasp of <code class="inlineCode">asyncio</code>, it is time to continue with some examples of where <code class="inlineCode">asyncio</code> can be useful.</p>&#13;
    <h1 id="_idParaDest-374" class="heading-1">Asynchronous examples</h1>&#13;
    <p class="normal">One of the most common reasons for stalling scripts and applications is the usage of remote resources, where <em class="italic">remote</em> means any interaction with the network, filesystem, or other resources. With <code class="inlineCode">asyncio</code>, at least a large portion of that is easily fixable. Fetching multiple remote<a id="_idIndexMarker1079"/> resources and serving to multiple clients is quite a bit easier and more lightweight than it used to be. While both multithreading and multiprocessing can be used for these cases as well, <code class="inlineCode">asyncio</code> is a much lighter alternative that is actually easier to manage in many cases.</p>&#13;
    <p class="normal">The next few sections show a few examples of how to implement certain operations using <code class="inlineCode">asyncio</code>.</p>&#13;
    <p class="normal">Before you start implementing your own code and copying the examples here, I would recommend doing a quick search on the web for whichever library you are looking for and seeing if there is an <code class="inlineCode">asyncio</code> version available.</p>&#13;
    <p class="normal">In general, looking for “asyncio &lt;protocol&gt;” will give you great results. Alternatively, many libraries use the <code class="inlineCode">aio</code> prefix for the library name, such as <code class="inlineCode">aiohttp</code>, so that can help your search as well.</p>&#13;
    <h2 id="_idParaDest-375" class="heading-2">Processes</h2>&#13;
    <p class="normal">So far, we have simply <a id="_idIndexMarker1080"/>executed simple <code class="inlineCode">async</code> functions within Python such as <code class="inlineCode">asyncio.sleep()</code>, but some things are a tad more difficult to run asynchronously. For example, let’s assume we have some long-running external application that we wish to run without blocking our main thread completely.</p>&#13;
    <p class="normal">The options for running external processes in a non-blocking mode are generally:</p>&#13;
    <ul>&#13;
      <li class="bulletList">Threading</li>&#13;
      <li class="bulletList">Multiprocessing</li>&#13;
      <li class="bulletList">Polling (periodically checking) for output</li>&#13;
    </ul>&#13;
    <p class="normal">Both threading and multiprocessing are covered in <em class="chapterRef">Chapter 14</em>.</p>&#13;
    <p class="normal">Without resorting to more complex solutions such as threading and multiprocessing, which introduce variable synchronization issues, we only have polling remaining. With polling, we check if there is new output at an interval, which can slow down your results by as much as the poll interval. That is, if your poll interval is 1 second and the process generates output 0.1 seconds after the last poll, the next 0.9 seconds are wasted waiting. To alleviate this, you could reduce the poll interval, of course, but with a lower poll interval more time is wasted checking to see if there are results.</p>&#13;
    <p class="normal">With <code class="inlineCode">asyncio</code>, we can have the advantages of the polling method without the time wasted between the poll intervals. Using <code class="inlineCode">asyncio.create_subprocess_shell</code> and <code class="inlineCode">asyncio.create_subprocess_exec</code>, we can <code class="inlineCode">await</code> output just like other coroutines. The usage of the class is very <a id="_idIndexMarker1081"/>similar to <code class="inlineCode">subprocess.run</code> except that the functions have been made asynchronous, resulting in the removal of the poll function, of course.</p>&#13;
    <div class="note">&#13;
      <p class="normal"> The examples below expect the <code class="inlineCode">sleep</code> command to be available in your environment. On all Unix/Linux/BSD systems, this is the case by default. On Windows, it is not available by default, but can be installed easily. The <code class="inlineCode">timeout</code> command can be used as an alternative.</p>&#13;
      <p class="normal">If you do wish to use <code class="inlineCode">sleep</code> and other Unix tools, the easiest method I have found is to install Git for Windows and let it install the <strong class="screenText">optional Unix tools</strong>:</p>&#13;
      <figure class="mediaobject"><img src="Images/B15882_13_01.png" alt="" width="588" height="456"/></figure>&#13;
      <p class="packt_figref">Figure 13.1: Git for Windows installer</p>&#13;
    </div>&#13;
    <p class="normal">First, let’s look at the <a id="_idIndexMarker1082"/>traditional sequential version of a script that runs external processes (in this case the <code class="inlineCode">sleep</code> command) through the <code class="inlineCode">subprocess</code> module:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> time&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> subprocess&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">subprocess_sleep</span><span class="hljs-con-function">():</span>&#13;
<span class="hljs-con-meta">...</span>     print(<span class="hljs-con-string">f'Started sleep at: </span><span class="hljs-con-subst">{time.time() - start:</span><span class="hljs-con-number">.1</span><span class="hljs-con-subst">f}</span><span class="hljs-con-string">'</span>)&#13;
<span class="hljs-con-meta">...</span>     process = subprocess.Popen([<span class="hljs-con-string">'sleep'</span>, <span class="hljs-con-string">'0.1'</span>])&#13;
<span class="hljs-con-meta">...</span>     process.wait()&#13;
<span class="hljs-con-meta">...</span>     print(<span class="hljs-con-string">f'Finished sleep at: </span><span class="hljs-con-subst">{time.time() - start:</span><span class="hljs-con-number">.1</span><span class="hljs-con-subst">f}</span><span class="hljs-con-string">'</span>)&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> start = time.time()&#13;
</code></pre>&#13;
    <p class="normal">After the first <code class="inlineCode">print()</code>, we use <code class="inlineCode">subprocess.Popen()</code> to run the <code class="inlineCode">sleep</code> command with argument <code class="inlineCode">0.1</code> so it will sleep for <code class="inlineCode">0.1</code> seconds. As opposed to <code class="inlineCode">subprocess.run()</code>, which blocks your Python process and waits until the external process has finished running, <code class="inlineCode">subprocess.Popen()</code> creates and starts the process and returns a reference to the running process, but it won’t automatically wait for the output. </p>&#13;
    <p class="normal">This allows us to explicitly call <code class="inlineCode">process.wait()</code> to wait or poll for the results, as we will see in the next example. Internally, <code class="inlineCode">subprocess.run()</code> is actually a convenient shortcut for a common use case of <code class="inlineCode">subprocess.Popen()</code>.</p>&#13;
    <p class="normal">When running the code, we <a id="_idIndexMarker1083"/>get the following output, as you would expect:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">for</span> _ <span class="hljs-con-keyword">in</span> <span class="hljs-con-built_in">range</span>(<span class="hljs-con-number">2</span>):&#13;
<span class="hljs-con-meta">...</span>     subprocess_sleep()&#13;
Started sleep at: 0.0&#13;
Finished sleep at: 0.1&#13;
Started sleep at: 0.1&#13;
Finished sleep at: 0.2&#13;
</code></pre>&#13;
    <p class="normal">Since everything is executed sequentially, it takes two times the 0.1 seconds that the <code class="inlineCode">sleep</code> command is sleeping for. This is, of course, the worst-case scenario: it completely blocks your Python process while it is running.</p>&#13;
    <p class="normal">Instead of waiting for the <code class="inlineCode">sleep</code> command immediately after running, we are now going to start all processes in parallel and only wait for the results once they have all started in the background:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> time&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> subprocess&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">subprocess_sleep</span><span class="hljs-con-function">():</span>&#13;
<span class="hljs-con-meta">...</span>     print(<span class="hljs-con-string">f'Started sleep at: </span><span class="hljs-con-subst">{time.time() - start:</span><span class="hljs-con-number">.1</span><span class="hljs-con-subst">f}</span><span class="hljs-con-string">'</span>)&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">return</span> subprocess.Popen([<span class="hljs-con-string">'</span><span class="hljs-con-string">sleep'</span>, <span class="hljs-con-string">'0.1'</span>])&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> start = time.time()&#13;
</code></pre>&#13;
    <p class="normal">As you can see, we are returning the process by returning <code class="inlineCode">subprocess.Popen()</code> without executing <code class="inlineCode">process.wait()</code>.</p>&#13;
    <p class="normal">Now we start all processes immediately and only wait for output after they have all started:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> processes = []&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">for</span> _ <span class="hljs-con-keyword">in</span> <span class="hljs-con-built_in">range</span>(<span class="hljs-con-number">2</span>):&#13;
<span class="hljs-con-meta">...</span>     processes.append(subprocess_sleep())&#13;
Started sleep at: 0.0&#13;
Started sleep at: 0.0&#13;
</code></pre>&#13;
    <p class="normal">The processes should be running in the background now, so let’s wait for the results:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">for</span> process <span class="hljs-con-keyword">in</span> processes:&#13;
<span class="hljs-con-meta">...</span>     returncode = process.wait()&#13;
<span class="hljs-con-meta">...</span>     print(<span class="hljs-con-string">f'Finished sleep at: </span><span class="hljs-con-subst">{time.time() - start:</span><span class="hljs-con-number">.1</span><span class="hljs-con-subst">f}</span><span class="hljs-con-string">'</span>)&#13;
Finished sleep at: 0.1&#13;
Finished sleep at: 0.1&#13;
</code></pre>&#13;
    <p class="normal">While that looks a lot better in<a id="_idIndexMarker1084"/> terms of runtime, it still blocks the main process when we run <code class="inlineCode">process.wait()</code>. It also required restructuring in such a way that the teardown (the <code class="inlineCode">Finished</code> print statement) is not in the same block as the start process, as was the case with the earlier example. This means that if something were to go wrong with your application, you would manually need to keep track of which process was failing, which is a bit inconvenient.</p>&#13;
    <p class="normal">With the <code class="inlineCode">asyncio</code> version, we can once again go back to processing everything related to the <code class="inlineCode">sleep</code> command in a single function, very similar to the first example with <code class="inlineCode">subprocess.Popen()</code>:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> time&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> asyncio&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">async</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">async_process_sleep</span><span class="hljs-con-function">():</span>&#13;
<span class="hljs-con-meta">...</span>     print(<span class="hljs-con-string">f'Started sleep at: </span><span class="hljs-con-subst">{time.time() - start:</span><span class="hljs-con-number">.1</span><span class="hljs-con-subst">f}</span><span class="hljs-con-string">'</span>)&#13;
<span class="hljs-con-meta">...</span>     process = <span class="hljs-con-keyword">await</span> asyncio.create_subprocess_exec(<span class="hljs-con-string">'</span><span class="hljs-con-string">sleep'</span>, <span class="hljs-con-string">'0.1'</span>)&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">await</span> process.wait()&#13;
<span class="hljs-con-meta">...</span>     print(<span class="hljs-con-string">f'Finished sleep at: </span><span class="hljs-con-subst">{time.time() - start:</span><span class="hljs-con-number">.1</span><span class="hljs-con-subst">f}</span><span class="hljs-con-string">'</span>)&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">async</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">main</span><span class="hljs-con-function">():</span>&#13;
<span class="hljs-con-meta">...</span>     coroutines = []&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">for</span> _ <span class="hljs-con-keyword">in</span> <span class="hljs-con-built_in">range</span>(<span class="hljs-con-number">2</span>):&#13;
<span class="hljs-con-meta">...</span>         coroutines.append(async_process_sleep())&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">await</span> asyncio.gather(*coroutines)&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> start = time.time()&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> asyncio.run(main())&#13;
Started sleep at: 0.0&#13;
Started sleep at: 0.0&#13;
Finished sleep at: 0.1&#13;
Finished sleep at: 0.1&#13;
</code></pre>&#13;
    <p class="normal">As you can see, it is trivial to run multiple applications at the same time this way. The syntax is essentially the same as it would be with <code class="inlineCode">subprocess</code> without having to block or poll.</p>&#13;
    <p class="normal">If you are running this <a id="_idIndexMarker1085"/>from a long-running <code class="inlineCode">asyncio</code> event loop and you don’t need to capture the results, you could skip the entire <code class="inlineCode">asyncio.gather()</code> step and use <code class="inlineCode">asyncio.create_task(async_process_sleep())</code> instead.</p>&#13;
    <h2 id="_idParaDest-376" class="heading-2">Interactive processes</h2>&#13;
    <p class="normal">Starting processes is the <a id="_idIndexMarker1086"/>easy part; the more difficult part is interactive input and output with processes. The <code class="inlineCode">asyncio</code> module has several measures to make that part easier, but it can still be difficult when actually working with the results.</p>&#13;
    <p class="normal">Here’s an example of calling the Python interpreter as an external subprocess, executing some code, and exiting again in a simple one-off fashion:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> time&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> asyncio&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">async</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">run_python_script</span><span class="hljs-con-function">(</span><span class="hljs-con-params">script</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>     print(<span class="hljs-con-string">f'Executing: </span><span class="hljs-con-subst">{script!r}</span><span class="hljs-con-string">'</span>)&#13;
<span class="hljs-con-meta">...</span>     process = <span class="hljs-con-keyword">await</span> asyncio.create_subprocess_exec(&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-string">'python3'</span>,&#13;
<span class="hljs-con-meta">...</span>         stdout=asyncio.subprocess.PIPE,&#13;
<span class="hljs-con-meta">...</span>         stdin=asyncio.subprocess.PIPE,&#13;
<span class="hljs-con-meta">...</span>     )&#13;
<span class="hljs-con-meta">...</span>     stdout, stderr = <span class="hljs-con-keyword">await</span> process.communicate(script)&#13;
<span class="hljs-con-meta">...</span>     print(<span class="hljs-con-string">f'stdout: </span><span class="hljs-con-subst">{stdout!r}</span><span class="hljs-con-string">'</span>)&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> asyncio.run(run_python_script(<span class="hljs-con-string">b'print(2 ** 20)'</span>))&#13;
Executing: b'print(2 ** 20)'&#13;
stdout: b'1048576\n'&#13;
</code></pre>&#13;
    <p class="normal">In this case, we added a pipe to <code class="inlineCode">stdout</code> (standard output) and <code class="inlineCode">stdin</code> (standard input) so we can read from <code class="inlineCode">stdout</code> and write to <code class="inlineCode">stdin</code> manually. After the process has started, we can use <code class="inlineCode">process.communicate()</code> to write to <code class="inlineCode">stdin</code>, and <code class="inlineCode">process.communicate()</code> will automatically read all output from <code class="inlineCode">stdout</code> and <code class="inlineCode">stderr</code> if they are available. Since we did not declare what <code class="inlineCode">stderr</code> is supposed to be, Python will automatically send all <code class="inlineCode">process.stderr</code> output to <code class="inlineCode">sys.stderr</code> for us, so we can ignore <code class="inlineCode">stderr</code> here as it will be <code class="inlineCode">None</code>. </p>&#13;
    <p class="normal">Now the actual challenge comes when we want interactive subprocesses with two-way communication through <code class="inlineCode">stdin</code>/<code class="inlineCode">stdout</code>/<code class="inlineCode">stderr</code> that keep on running for a longer time. That is also possible of course, but it can be hard to avoid deadlocks in situations where both sides are waiting for input. Here’s a very simple example of a Python subprocess that does effectively the<a id="_idIndexMarker1087"/> same as <code class="inlineCode">communicate()</code> above, but manually, to give you granular control over the input and output of the process:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> asyncio&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">async</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">run_script</span><span class="hljs-con-function">():</span>&#13;
<span class="hljs-con-meta">...</span>     process = <span class="hljs-con-keyword">await</span> asyncio.create_subprocess_exec(&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-string">'python3'</span>,&#13;
<span class="hljs-con-meta">...</span>         stdout=asyncio.subprocess.PIPE,&#13;
<span class="hljs-con-meta">...</span>         stdin=asyncio.subprocess.PIPE,&#13;
<span class="hljs-con-meta">...</span>     )&#13;
<span class="hljs-con-meta">...</span> &#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-comment"># Write a simple Python script to the interpreter</span>&#13;
<span class="hljs-con-meta">...</span>     process.stdin.write(<span class="hljs-con-string">b'print("Hi~")'</span>)&#13;
<span class="hljs-con-meta">...</span> &#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-comment"># Make sure the stdin is flushed asynchronously</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">await</span> process.stdin.drain()&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-comment"># And send the end of file so the Python interpreter will</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-comment"># start processing the input. Without this the process will</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-comment"># stall forever.</span>&#13;
<span class="hljs-con-meta">...</span>     process.stdin.write_eof()&#13;
<span class="hljs-con-meta">...</span> &#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-comment"># Fetch the lines from the stdout asynchronously</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">async</span> <span class="hljs-con-keyword">for</span> line <span class="hljs-con-keyword">in</span> process.stdout:&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-comment"># Decode the output from bytes and strip the whitespace</span>&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-comment"># (newline) at the right</span>&#13;
<span class="hljs-con-meta">...</span>         print(<span class="hljs-con-string">'</span><span class="hljs-con-string">stdout:'</span>, line.rstrip())&#13;
<span class="hljs-con-meta">...</span> &#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-comment"># Wait for the process to exit</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">await</span> process.wait()&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> asyncio.run(run_script())&#13;
stdout: b'Hi~'&#13;
</code></pre>&#13;
    <p class="normal">The code might appear largely as you would expect, but there are a few parts that are non-obvious to use, yet required to function. While the creation of the subprocess is identical to the previous example, the writing of the code to <code class="inlineCode">stdin</code> is slightly different. </p>&#13;
    <p class="normal">Instead of using <code class="inlineCode">process.communicate()</code>, we now write directly to the <code class="inlineCode">process.stdin</code> pipe. When you run <code class="inlineCode">process.stdin.write(),</code> Python will <em class="italic">try</em> to write to the stream, but might not be able to because the process hasn’t started running yet. Because of that, we need to manually flush these buffers by using <code class="inlineCode">process.stdin.drain()</code>. Once that is done, we send an end-of-file (<code class="inlineCode">EOF</code>) character so the Python subprocess knows that no more input is coming.</p>&#13;
    <p class="normal">Once the input is written, we<a id="_idIndexMarker1088"/> need to read the output from the Python subprocess. We could use <code class="inlineCode">process.stdout.readline()</code> in a loop for this, but similar to how we can do <code class="inlineCode">for line in open(filename)</code>, we can also read <code class="inlineCode">process.stdout</code> line by line using an <code class="inlineCode">async for</code> loop until the stream is closed.</p>&#13;
    <p class="normal">If at all possible, I would recommend abstaining from using <code class="inlineCode">stdin</code> to send data to subprocesses and instead use some network, pipe, or file communication instead. As we will see in the next section covering an echo client and server, those are much more convenient to handle and less prone to deadlocks.</p>&#13;
    <h2 id="_idParaDest-377" class="heading-2">Echo client and server</h2>&#13;
    <p class="normal">The most basic kind <a id="_idIndexMarker1089"/>of server you can get is an “echo” server, which sends all messages<a id="_idIndexMarker1090"/> received back. Since we can run multiple tasks in parallel with <code class="inlineCode">asyncio</code>, we can run both the server and the client from the same script here. Splitting them into two processes is also possible, of course.</p>&#13;
    <p class="normal">Creating a basic client and server is easy to do:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> asyncio&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> HOST = <span class="hljs-con-string">'127.0.0.1'</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> PORT = <span class="hljs-con-number">1234</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">async</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">echo_client</span><span class="hljs-con-function">(</span><span class="hljs-con-params">message</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-comment"># Open the connection to the server</span>&#13;
<span class="hljs-con-meta">...</span>     reader, writer = <span class="hljs-con-keyword">await</span> asyncio.open_connection(HOST, PORT)&#13;
<span class="hljs-con-meta">...</span> &#13;
<span class="hljs-con-meta">...</span>     print(<span class="hljs-con-string">f'Client sending </span><span class="hljs-con-subst">{message!r}</span><span class="hljs-con-string">'</span>)&#13;
<span class="hljs-con-meta">...</span>     writer.write(message)&#13;
<span class="hljs-con-meta">...</span> &#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-comment"># We need to drain and write the EOF to stop sending</span>&#13;
<span class="hljs-con-meta">...</span>     writer.write_eof()&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">await</span> writer.drain()&#13;
<span class="hljs-con-meta">...</span> &#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">async</span> <span class="hljs-con-keyword">for</span> line <span class="hljs-con-keyword">in</span> reader:&#13;
<span class="hljs-con-meta">...</span>         print(<span class="hljs-con-string">f'Client received: </span><span class="hljs-con-subst">{line!r}</span><span class="hljs-con-string">'</span>)&#13;
<span class="hljs-con-meta">...</span> &#13;
<span class="hljs-con-meta">...</span>     writer.close()&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">async</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">echo</span><span class="hljs-con-function">(</span><span class="hljs-con-params">reader, writer</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-comment"># Read all lines from the reader and send them back</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">async</span> <span class="hljs-con-keyword">for</span> line <span class="hljs-con-keyword">in</span> reader:&#13;
<span class="hljs-con-meta">...</span>         print(<span class="hljs-con-string">f'Server received: </span><span class="hljs-con-subst">{line!r}</span><span class="hljs-con-string">'</span>)&#13;
<span class="hljs-con-meta">...</span>         writer.write(line)&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">await</span> writer.drain()&#13;
<span class="hljs-con-meta">...</span> &#13;
<span class="hljs-con-meta">...</span>     writer.close()&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">async</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">echo_server</span><span class="hljs-con-function">():</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-comment"># Create a TCP server that listens on 'HOST'/'PORT' and</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-comment"># calls 'echo' when a client connects.</span>&#13;
<span class="hljs-con-meta">...</span>     server = <span class="hljs-con-keyword">await</span> asyncio.start_server(echo, HOST, PORT)&#13;
<span class="hljs-con-meta">...</span> &#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-comment"># Start listening</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">async</span> <span class="hljs-con-keyword">with</span> server:&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">await</span> server.serve_forever()&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">async</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">main</span><span class="hljs-con-function">():</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-comment"># Create and run the echo server</span>&#13;
<span class="hljs-con-meta">...</span>     server_task = asyncio.create_task(echo_server())&#13;
<span class="hljs-con-meta">...</span> &#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-comment"># Wait a little for the server to start</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">await</span> asyncio.sleep(<span class="hljs-con-number">0.01</span>)&#13;
<span class="hljs-con-meta">...</span> &#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-comment"># Create a client and send the message</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">await</span> echo_client(<span class="hljs-con-string">b'test message'</span>)&#13;
<span class="hljs-con-meta">...</span> &#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-comment"># Kill the server</span>&#13;
<span class="hljs-con-meta">...</span>     server_task.cancel()&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> asyncio.run(main())&#13;
Client sending b'test message'&#13;
Server received: b'test message'&#13;
Client received: b'test message'&#13;
</code></pre>&#13;
    <p class="normal">In this example, we can see that we sent the server to the background using <code class="inlineCode">asyncio.create_task()</code>. After that, we have to wait just a tiny amount of time for the background task to start working, which we are doing using <code class="inlineCode">asyncio.sleep()</code>. The sleep time of <code class="inlineCode">0.01</code> was chosen arbitrarily (and <code class="inlineCode">0.001</code> is probably enough as well), but it should be enough for most<a id="_idIndexMarker1091"/> systems to communicate with the kernel to create a listening socket. Once the <a id="_idIndexMarker1092"/>server is running, we start our client to send a message and wait for the response.</p>&#13;
    <p class="normal">Naturally, this example could have been written in many different ways. Instead of <code class="inlineCode">async for</code>, you could use <code class="inlineCode">reader.readline()</code> to read until the next newline, or you could use <code class="inlineCode">reader.read(number_of_bytes)</code> to read a specific number of characters. It all depends on the protocol you wish to write. In the case of the HTTP/1.1 protocol, the server expects a <code class="inlineCode">Connection: close</code>; in the case of the SMTP protocol, a <code class="inlineCode">QUIT</code> message should be sent. In our case, we use the <code class="inlineCode">EOF</code> character as an indicator.</p>&#13;
    <h2 id="_idParaDest-378" class="heading-2">Asynchronous file operations</h2>&#13;
    <p class="normal">One of the operations you <a id="_idIndexMarker1093"/>would prefer to be asynchronous is file operations. Even though storage devices have become much faster over the years, you are not always working on fast local storage. If you want to write to a network drive over a Wi-Fi connection, for example, you can experience quite a lot of latency. By using <code class="inlineCode">asyncio</code>, you can make sure this won’t stall your entire interpreter.</p>&#13;
    <p class="normal">Unfortunately, there is currently no easy way to do file operations through <code class="inlineCode">asyncio</code> in a cross-platform way because most operating systems have no (scalable) asynchronous file operations support. Luckily, someone created a workaround for this issue. The <code class="inlineCode">aiofiles</code> library uses<a id="_idIndexMarker1094"/> the <code class="inlineCode">threading</code> library internally to give you an <code class="inlineCode">asyncio</code> interface to file operations. While you could easily use an <code class="inlineCode">Executor</code> to handle the file operations for you, the <code class="inlineCode">aiofiles</code> library is a very convenient wrapper that I recommend using.</p>&#13;
    <p class="normal">First, install the library:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> pip3 install aiofiles&#13;
</code></pre>&#13;
    <p class="normal">Now we can use <code class="inlineCode">aiofiles</code> to open, read, and<a id="_idIndexMarker1095"/> write files in a non-blocking manner through <code class="inlineCode">asyncio</code>:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> asyncio&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> aiofiles&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">async</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">main</span><span class="hljs-con-function">():</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">async</span> <span class="hljs-con-keyword">with</span> aiofiles.<span class="hljs-con-built_in">open</span>(<span class="hljs-con-string">'aiofiles.txt'</span>, <span class="hljs-con-string">'w'</span>) <span class="hljs-con-keyword">as</span> fh:&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">await</span> fh.write(<span class="hljs-con-string">'Writing to file'</span>)&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">async</span> <span class="hljs-con-keyword">with</span> aiofiles.<span class="hljs-con-built_in">open</span>(<span class="hljs-con-string">'aiofiles.txt'</span>, <span class="hljs-con-string">'r'</span>) <span class="hljs-con-keyword">as</span> fh:&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">async</span> <span class="hljs-con-keyword">for</span> line <span class="hljs-con-keyword">in</span> fh:&#13;
<span class="hljs-con-meta">...</span>             print(line) &#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> asyncio.run(main())&#13;
Writing to file&#13;
</code></pre>&#13;
    <p class="normal">The usage of <code class="inlineCode">aiofiles</code> is very similar to a regular <code class="inlineCode">open()</code> call, except with the <code class="inlineCode">async</code> prefix in all cases.</p>&#13;
    <h2 id="_idParaDest-379" class="heading-2">Creating async generators to support async for</h2>&#13;
    <p class="normal">In the <a id="_idIndexMarker1096"/>earlier examples, you might have wondered how to support <code class="inlineCode">async for</code> statements. Essentially it is very easy to do so; instead of a regular generator that you could create with the <code class="inlineCode">__iter__</code> and <code class="inlineCode">__next__</code> magic functions in a class, you would now use <code class="inlineCode">__aiter__</code> and <code class="inlineCode">__anext__</code> instead:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> asyncio&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">AsyncGenerator</span><span class="hljs-con-class">:</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__init__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self, iterable</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>         self.iterable = iterable&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">async</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__aiter__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">for</span> item <span class="hljs-con-keyword">in</span> self.iterable:&#13;
<span class="hljs-con-meta">...</span>             <span class="hljs-con-keyword">yield</span> item&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">async</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">main</span><span class="hljs-con-function">():</span>&#13;
<span class="hljs-con-meta">...</span>     async_generator = AsyncGenerator([<span class="hljs-con-number">4</span>, <span class="hljs-con-number">2</span>])&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">async</span> <span class="hljs-con-keyword">for</span> item <span class="hljs-con-keyword">in</span> async_generator:&#13;
<span class="hljs-con-meta">...</span>         print(<span class="hljs-con-string">f'Got item: </span><span class="hljs-con-subst">{item}</span><span class="hljs-con-string">'</span>)&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> asyncio.run(main())&#13;
Got item: 4&#13;
Got item: 2&#13;
</code></pre>&#13;
    <p class="normal">Effectively, the code <a id="_idIndexMarker1097"/>is identical to regular generators and <code class="inlineCode">with</code> statements, but you can also access <code class="inlineCode">asyncio</code> code from the functions. There is really nothing special about these methods except that they need the <code class="inlineCode">async</code> prefix and the <code class="inlineCode">a</code> in the name, so you get <code class="inlineCode">__aiter__</code> instead of <code class="inlineCode">__iter__</code>.</p>&#13;
    <p class="normal">Creating async context managers to support async with</p>&#13;
    <p class="normal">Similar to<a id="_idIndexMarker1098"/> the <code class="inlineCode">async</code> generator, we can also create an <code class="inlineCode">async</code> context manager. Instead of the <code class="inlineCode">__iter__</code> method, we now have to replace the <code class="inlineCode">__enter__</code> and <code class="inlineCode">__exit__</code> methods with <code class="inlineCode">__aenter__</code> and <code class="inlineCode">__aexit__,</code> respectively.</p>&#13;
    <p class="normal">Effectively the code is identical to a <code class="inlineCode">with</code> statement, but you can also access <code class="inlineCode">asyncio</code> code from the functions:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> asyncio&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">AsyncContextManager</span><span class="hljs-con-class">:</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">async</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__aenter__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>         print(<span class="hljs-con-string">'</span><span class="hljs-con-string">Hi :)'</span>)&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">async</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__aexit__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self, exc_type, exc_value, traceback</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>         print(<span class="hljs-con-string">'</span><span class="hljs-con-string">Bye :('</span>)&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">async</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">main</span><span class="hljs-con-function">():</span>&#13;
<span class="hljs-con-meta">...</span>     async_context_manager = AsyncContextManager()&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span>     print(<span class="hljs-con-string">'Before with'</span>)&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">async</span> <span class="hljs-con-keyword">with</span> async_context_manager:&#13;
<span class="hljs-con-meta">...</span>         print(<span class="hljs-con-string">'During with'</span>)&#13;
<span class="hljs-con-meta">...</span>     print(<span class="hljs-con-string">'After with'</span>)&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> asyncio.run(main())&#13;
Before with&#13;
Hi :)&#13;
During with&#13;
Bye :(&#13;
After with&#13;
</code></pre>&#13;
    <p class="normal">Similar to <a id="_idIndexMarker1099"/>the <code class="inlineCode">async</code> generator, there really is nothing special about these methods. But the <code class="inlineCode">async</code> context manager in particular is very useful for setup/teardown methods, as we will see in the next section.</p>&#13;
    <h2 id="_idParaDest-380" class="heading-2">Asynchronous constructors and destructors</h2>&#13;
    <p class="normal">At some point, you will probably want to run some asynchronous code from your constructors<a id="_idIndexMarker1100"/> and/or destructors, perhaps to initialize a database connection or other type of network connection. Unfortunately, that is not really possible.</p>&#13;
    <p class="normal">Naturally, using <code class="inlineCode">__await__</code> or <a id="_idIndexMarker1101"/>metaclasses, you could hack around this for your constructor. And with an <code class="inlineCode">asyncio.run(...)</code> you could do something similar for your destructor. Neither is really a great solution though – I would suggest restructuring your code instead.</p>&#13;
    <p class="normal">Depending on the scenario I would suggest using either:</p>&#13;
    <ul>&#13;
      <li class="bulletList">Context managers to properly enter/exit using an <code class="inlineCode">async with</code> statement</li>&#13;
      <li class="bulletList">A Factory pattern where an <code class="inlineCode">async def</code> generates and initializes the class for you, together with an <code class="inlineCode">async def close()</code> as an async destructor</li>&#13;
    </ul>&#13;
    <p class="normal">We have already seen the context manager in the previous section, and that would be the method I would recommend in most cases, such as creating database connections and/or transactions, since you cannot accidentally forget to run the teardown using that.</p>&#13;
    <div class="note">&#13;
      <p class="normal"> The Factory design pattern uses a function to facilitate the creation of an object. In this case, that means instead of doing <code class="inlineCode">instance = SomeClass(...),</code> you would have <code class="inlineCode">instance = await SomeClass.create(...)</code> so you can have an asynchronous initialization method.</p>&#13;
    </div>&#13;
    <p class="normal">But a Factory pattern with a<a id="_idIndexMarker1102"/>n explicit create and close method is, of course, a <a id="_idIndexMarker1103"/>good possibility too:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> asyncio&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">SomeClass</span><span class="hljs-con-class">:</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__init__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self, *args, **kwargs</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>         print(<span class="hljs-con-string">'Sync init'</span>)&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">async</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">init</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self, *args, **kwargs</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>         print(<span class="hljs-con-string">'Async init'</span>)&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-meta">    @classmethod</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">async</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">create</span><span class="hljs-con-function">(</span><span class="hljs-con-params">cls, *args, **kwargs</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-comment"># Create an instance of 'SomeClass' which calls the</span>&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-comment"># sync init: 'SomeClass.__init__(*args, **kwargs)'</span>&#13;
<span class="hljs-con-meta">...</span>         self = cls(*args, **kwargs)&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-comment"># Now we can call the async init:</span>&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">await</span> self.init(*args, **kwargs)&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">return</span> self&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">async</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">close</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>         print(<span class="hljs-con-string">'Async destructor'</span>)&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__del__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>         print(<span class="hljs-con-string">'Sync destructor'</span>)&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">async</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">main</span><span class="hljs-con-function">():</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-comment"># Note that we use 'SomeClass.create()' instead of</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-comment"># 'SomeClass()' so we also run 'SomeClass().init()'</span>&#13;
<span class="hljs-con-meta">...</span>     some_class = <span class="hljs-con-keyword">await</span> SomeClass.create()&#13;
<span class="hljs-con-meta">...</span>     print(<span class="hljs-con-string">'Using the class here'</span>)&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">await</span> some_class.close()&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">del</span> some_class&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> asyncio.run(main())&#13;
Sync init&#13;
Async init&#13;
Using the class here&#13;
Async destructor&#13;
Sync destructor&#13;
</code></pre>&#13;
    <p class="normal">With the order of operations as shown before, you can properly create and tear down an <code class="inlineCode">asyncio</code> class that way. As a failsafe (explicitly calling <code class="inlineCode">close()</code> is always the better solution), you can add an <code class="inlineCode">async</code> destructor to your <code class="inlineCode">__del__</code> by calling the loop.</p>&#13;
    <p class="normal">For the next example, we<a id="_idIndexMarker1104"/> will use the <code class="inlineCode">asyncpg</code> library, so make sure to install it<a id="_idIndexMarker1105"/> first:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> pip3 install asyncpg&#13;
</code></pre>&#13;
    <p class="normal">Now, an <code class="inlineCode">asyncio</code> database connection to PostgreSQL could be implemented like this:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> typing&#13;
<span class="hljs-keyword">import</span> asyncio&#13;
<span class="hljs-keyword">import</span> asyncpg&#13;
&#13;
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">AsyncPg</span><span class="hljs-class">:</span>&#13;
    _connection: typing.Optional[asyncpg.Connection]&#13;
&#13;
    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">init</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>&#13;
        self._connection = asyncpg.connect(...)&#13;
&#13;
    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">close</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>&#13;
        <span class="hljs-keyword">await</span> self._connection.close()&#13;
&#13;
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__del__</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>&#13;
        <span class="hljs-keyword">if</span> self._connection:&#13;
            loop = asyncio.get_event_loop()&#13;
            <span class="hljs-keyword">if</span> loop.is_running():&#13;
                loop.create_task(self.close())&#13;
            <span class="hljs-keyword">else</span>:&#13;
                loop.run_until_complete(self.close())&#13;
                &#13;
            self._connection = <span class="hljs-literal">None</span>&#13;
</code></pre>&#13;
    <p class="normal">You could also create a registry to easily close all classes that were created so you can’t forget to do so on exit. But if possible, I would still recommend the context manager-style solution. You could also make a convenient shortcut using a decorator by creating an <code class="inlineCode">async</code> version of <code class="inlineCode">contextlib.ContextDecorator</code>.</p>&#13;
    <p class="normal">Next up, we will look at how to debug <code class="inlineCode">asyncio</code> code and how to catch common mistakes.</p>&#13;
    <h1 id="_idParaDest-381" class="heading-1">Debugging asyncio</h1>&#13;
    <p class="normal">The <code class="inlineCode">asyncio</code> module has a<a id="_idIndexMarker1106"/> few special provisions to make debugging somewhat easier. Given the asynchronous nature of functions within <code class="inlineCode">asyncio</code>, this is a very welcome feat. While the debugging of multithreaded/multiprocessing functions or classes can be difficult – since concurrent classes can easily change environment variables in parallel – with <code class="inlineCode">asyncio</code>, it’s just as difficult, if not more, because <code class="inlineCode">asyncio</code> background tasks run in the stack of the event loop, not your own stack. </p>&#13;
    <div class="note">&#13;
      <p class="normal"> If you wish to skip this part of the chapter, I urge you to at least read the section on <em class="italic">Exiting before all tasks are done</em>. That covers a <strong class="keyWord">huge</strong> pitfall with <code class="inlineCode">asyncio</code>.</p>&#13;
    </div>&#13;
    <p class="normal">The first and most obvious way of debugging <code class="inlineCode">asyncio</code> is to use the event loop debug mode. We have several options for enabling the debug mode:</p>&#13;
    <ul>&#13;
      <li class="bulletList">Set the <code class="inlineCode">PYTHONASYNCIODEBUG</code> environment variable to <code class="inlineCode">True</code></li>&#13;
      <li class="bulletList">Enable the Python development mode using the <code class="inlineCode">PYTHONDEVMODE</code> environment variable or by executing Python with the <code class="inlineCode">-X dev</code> command-line option</li>&#13;
      <li class="bulletList">Pass the <code class="inlineCode">debug=True</code> argument to <code class="inlineCode">asyncio.run()</code></li>&#13;
      <li class="bulletList">Call <code class="inlineCode">loop.set_debug()</code></li>&#13;
    </ul>&#13;
    <p class="normal">Of these methods, I recommend using the <code class="inlineCode">PYTHONASYNCIODEBUG</code> or <code class="inlineCode">PYTHONDEVMODE</code> environment variables because these are applied very early and can therefore catch several errors that the others might miss. We will see an example of that in the next section about forgotten <code class="inlineCode">await</code> statements.</p>&#13;
    <div class="note">&#13;
      <p class="normal"><strong class="screenText">Note about setting environment variables</strong></p>&#13;
      <p class="normal">Within most Linux/Unix/Mac shell sessions, environment variables can be set using <code class="inlineCode">variable=value</code> as a prefix:</p>&#13;
      <pre class="programlisting con"><code class="hljs-con">SOME_ENVIRONMENT_VARIABLE=value python3 script.py&#13;
</code></pre>&#13;
      <p class="normal">Also, environment variables can be configured for the current shell (when using ZSH or Bash) session using <code class="inlineCode">export</code>:</p>&#13;
      <pre class="programlisting con"><code class="hljs-con">export SOME_ENVIRONMENT_VARIABLE=value&#13;
</code></pre>&#13;
      <p class="normal">The current value can be fetched using the following line:</p>&#13;
      <pre class="programlisting con"><code class="hljs-con">echo $SOME_ENVIRONMENT_VARIABLE&#13;
</code></pre>&#13;
      <p class="normal">On Windows, you can configure an environment variable for your local shell session using the <code class="inlineCode">set</code> command:</p>&#13;
      <pre class="programlisting con"><code class="hljs-con">set SOME_ENVIRONMENT_VARIABLE=value&#13;
</code></pre>&#13;
      <p class="normal">The current value can be fetched using this line:</p>&#13;
      <pre class="programlisting con"><code class="hljs-con">set SOME_ENVIRONMENT_VARIABLE&#13;
</code></pre>&#13;
    </div>&#13;
    <p class="normal">When the debug mode is<a id="_idIndexMarker1107"/> enabled, the <code class="inlineCode">asyncio</code> module will check a few common <code class="inlineCode">asyncio</code> mistakes and issues. Specifically:</p>&#13;
    <ul>&#13;
      <li class="bulletList">Coroutines<a id="_idIndexMarker1108"/> that have not been yielded will raise an exception.</li>&#13;
      <li class="bulletList">Calling coroutines from the “wrong” thread raises an exception. This can occur if you have code running in different threads from the thread running the current event loop. This is effectively a case of thread safety, which is covered in <em class="chapterRef">Chapter 14</em>.</li>&#13;
      <li class="bulletList">The execution time of the selector will be logged.</li>&#13;
      <li class="bulletList">Slow coroutines (more than 100 ms) will be logged. This timeout can be modified through <code class="inlineCode">loop.slow_callback_duration</code>.</li>&#13;
      <li class="bulletList">Warnings will be raised when resources are not closed properly.</li>&#13;
      <li class="bulletList">Tasks that were destroyed before execution will be logged.</li>&#13;
    </ul>&#13;
    <p class="normal">Let’s showcase a few of these mistakes.</p>&#13;
    <h2 id="_idParaDest-382" class="heading-2">Forgetting to await a coroutine</h2>&#13;
    <p class="normal">This is probably the<a id="_idIndexMarker1109"/> most common <code class="inlineCode">asyncio</code> bug and it has bitten me many, many times. It is so easy to do <code class="inlineCode">some_coroutine()</code> instead of <code class="inlineCode">await some_coroutine()</code> and you usually find out when it’s already too late.</p>&#13;
    <p class="normal">Luckily, Python can help us with this one, so let’s look at what happens when you forget to <code class="inlineCode">await</code> a coroutine with <code class="inlineCode">PYTHONASYNCIODEBUG</code> set to <code class="inlineCode">1</code>:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">printer</span><span class="hljs-function">():</span>&#13;
    print(<span class="hljs-string">'This is a coroutine'</span>)&#13;
&#13;
printer()&#13;
</code></pre>&#13;
    <p class="normal">This results in an error for the <code class="inlineCode">printer</code> coroutine, which we forgot to <code class="inlineCode">await</code>:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> PYTHONASYNCIODEBUG=1 python3 T_13_forgot_await.py&#13;
T_13_forgot_await.py:5: RuntimeWarning: coroutine 'printer' was never awaited&#13;
  printer()&#13;
RuntimeWarning: Enable tracemalloc to get the object allocation traceback&#13;
</code></pre>&#13;
    <p class="normal">Note that this will only occur when the event loop has been closed. The event loop can’t know if you intended to execute the coroutine at a later moment, so this can still be difficult to debug.</p>&#13;
    <p class="normal">This is also one of the cases <a id="_idIndexMarker1110"/>where using the <code class="inlineCode">PYTHONASYNCIODEBUG</code> environment variable instead of <code class="inlineCode">loop.set_debug(True)</code> can make a difference. Think about a scenario where you have multiple event loops and forget to enable debug mode for all of them, or where a forgotten coroutine is created before debug mode is enabled, which means it will not be tracked. </p>&#13;
    <h2 id="_idParaDest-383" class="heading-2">Slow blocking functions</h2>&#13;
    <p class="normal">Not considering that a function might be slow and blocking your loop is easy to do. If it is somewhat slow but not slow enough that you’ll notice, you will probably never find out about it unless you enable the <a id="_idIndexMarker1111"/>debug mode. Let’s look at how the debug mode helps us here:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> time&#13;
<span class="hljs-keyword">import</span> asyncio&#13;
&#13;
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">main</span><span class="hljs-function">():</span>&#13;
    <span class="hljs-comment"># Oh no... a synchronous sleep from asyncio code</span>&#13;
    time.sleep(<span class="hljs-number">0.2</span>)&#13;
&#13;
asyncio.run(main(), debug=<span class="hljs-literal">True</span>)&#13;
</code></pre>&#13;
    <p class="normal">In this case, we “accidentally” used <code class="inlineCode">time.sleep()</code> instead of <code class="inlineCode">asyncio.sleep()</code>.</p>&#13;
    <p class="normal">For these issues, <code class="inlineCode">debug=True</code> works great, but it never hurts to use <code class="inlineCode">PYTHONASYNCIODEBUG=1</code> when developing:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> PYTHONASYNCIODEBUG=1 python3 T_14_slow_blocking_code.py&#13;
Executing &lt;Task finished ...&gt; took 0.204 seconds&#13;
</code></pre>&#13;
    <p class="normal">As we expected, we get a warning with this slow function. </p>&#13;
    <p class="normal">The default warning threshold is set to 100 ms and we are sleeping for 200 ms, so it is reported. The threshold can be changed <a id="_idIndexMarker1112"/>through <code class="inlineCode">loop.slow_callback_duration=&lt;seconds&gt;</code> if needed. This could be useful if you are working on a slower system such as a Raspberry Pi, or if you want to look for slow code.</p>&#13;
    <h2 id="_idParaDest-384" class="heading-2">Forgetting to check the results or exiting early</h2>&#13;
    <p class="normal">A common way to write code with <code class="inlineCode">asyncio</code> is to use fire-and-forget with <code class="inlineCode">asyncio.create_task()</code> without storing the resulting future. While this is not inherently wrong, if an exception unexpectedly occurs in your code, it can be very difficult to find the culprit without the debug mode enabled.</p>&#13;
    <p class="normal">To illustrate, we are going to use the following uncaught exception and execute it both with and without debug mode:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> asyncio&#13;
&#13;
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">throw_exception</span><span class="hljs-function">():</span>&#13;
    <span class="hljs-keyword">raise</span> RuntimeError()&#13;
&#13;
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">main</span><span class="hljs-function">():</span>&#13;
    <span class="hljs-comment"># Ignoring an exception from an async def</span>&#13;
    asyncio.create_task(throw_exception())&#13;
&#13;
asyncio.run(main())&#13;
</code></pre>&#13;
    <p class="normal">If we execute this without debug mode, we get the following output:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> python3 T_15_forgotten_exception.py&#13;
Task exception was never retrieved&#13;
future: &lt;Task finished ... at T_15_forgotten_exception.py:4&gt; exception=RuntimeError()&gt;&#13;
Traceback (most recent call last):&#13;
  File "T_15_forgotten_exception.py", line 5, in throw_exception&#13;
    raise RuntimeError()&#13;
RuntimeError&#13;
</code></pre>&#13;
    <p class="normal">While this does nicely show us where the exception occurred and what exception occurred, it does not show us who or what created the coroutine.</p>&#13;
    <p class="normal">Now if we repeat the same<a id="_idIndexMarker1113"/> with debug mode enabled, we get this:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> PYTHONASYNCIODEBUG=1 python3 T_15_forgotten_exception.py&#13;
Task exception was never retrieved&#13;
future: &lt;Task finished ... at T_15_forgotten_exception.py:4&gt; exception=RuntimeError() created at asyncio/tasks.py:361&gt;&#13;
source_traceback: Object created at (most recent call last):&#13;
  File "T_15_forgotten_exception.py", line 13, in &lt;module&gt;&#13;
    asyncio.run(main())&#13;
  File "asyncio/runners.py", line 44, in run&#13;
    return loop.run_until_complete(main)&#13;
  File "asyncio/base_events.py", line 629, in run_until_complete&#13;
    self.run_forever()&#13;
  File "asyncio/base_events.py", line 596, in run_forever&#13;
    self._run_once()&#13;
  File "asyncio/base_events.py", line 1882, in _run_once&#13;
    handle._run()&#13;
  File "asyncio/events.py", line 80, in _run&#13;
    self._context.run(self._callback, *self._args)&#13;
  File "T_15_forgotten_exception.py", line 10, in main&#13;
    asyncio.create_task(throw_exception())&#13;
  File "asyncio/tasks.py", line 361, in create_task&#13;
    task = loop.create_task(coro)&#13;
Traceback (most recent call last):&#13;
  File "T_15_forgotten_exception.py", line 5, in throw_exception&#13;
    raise RuntimeError()&#13;
RuntimeError&#13;
</code></pre>&#13;
    <p class="normal">This might still be a bit hard to read, but now we see that the exception originated from <code class="inlineCode">asyncio.create_task(throw_exception())</code> and we can even see the <code class="inlineCode">asyncio.run(main())</code> call.</p>&#13;
    <p class="normal">For a slightly larger code base, this can be essential in tracing the source of your exceptions.</p>&#13;
    <h2 id="_idParaDest-385" class="heading-2">Exiting before all tasks are done</h2>&#13;
    <p class="normal">Pay attention here, <a id="_idIndexMarker1114"/>because this issue is extremely subtle but can have huge consequences if you don’t notice it.</p>&#13;
    <p class="normal">Similar to forgetting to fetch the results, when you create a task while the loop is already tearing down, the task will <em class="italic">not</em> always run. In some cases, it does not have the chance to run and you most likely won’t notice it.</p>&#13;
    <p class="normal">Take a look at this example where we have a task spawning another task:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> asyncio&#13;
&#13;
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">sub_printer</span><span class="hljs-function">():</span>&#13;
    print(<span class="hljs-string">'Hi from the sub-printer'</span>)&#13;
&#13;
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">printer</span><span class="hljs-function">():</span>&#13;
    print(<span class="hljs-string">'Before creating the sub-printer task'</span>)&#13;
    asyncio.create_task(sub_printer())&#13;
    print(<span class="hljs-string">'After creating the sub-printer task'</span>)&#13;
&#13;
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">main</span><span class="hljs-function">():</span>&#13;
    asyncio.create_task(printer())&#13;
&#13;
asyncio.run(main())&#13;
</code></pre>&#13;
    <p class="normal">In this case, even the debug mode cannot help you. To illustrate, let’s look at what happens when we call this with debug mode enabled:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> PYTHONASYNCIODEBUG=1 python3 T_16_early_exit.py&#13;
Before creating the sub-printer task&#13;
After creating the sub-printer task&#13;
</code></pre>&#13;
    <p class="normal">The call to <code class="inlineCode">sub_printer()</code> seems to have disappeared. It really hasn’t, but we did not explicitly wait for it to finish so it never got a chance to run.</p>&#13;
    <p class="normal">The <strong class="keyWord">best</strong> solution by far is to keep track of all futures created by <code class="inlineCode">asyncio.create_task()</code> and do an <code class="inlineCode">await asyncio.gather(*futures)</code> at the end of your <code class="inlineCode">main()</code> function. But this is not always an option – you might not have access to the futures created by other libraries, or the futures might be created in a scope you cannot easily access. So what can you do?</p>&#13;
    <p class="normal">As a very simple workaround, you can simply wait at the end of your <code class="inlineCode">main()</code> function:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> asyncio&#13;
&#13;
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">sub_printer</span><span class="hljs-function">():</span>&#13;
    print(<span class="hljs-string">'Hi from the sub-printer'</span>)&#13;
&#13;
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">printer</span><span class="hljs-function">():</span>&#13;
    print(<span class="hljs-string">'Before creating the sub-printer task'</span>)&#13;
    asyncio.create_task(sub_printer())&#13;
    print(<span class="hljs-string">'After creating the sub-printer task'</span>)&#13;
&#13;
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">main</span><span class="hljs-function">():</span>&#13;
    asyncio.create_task(printer())&#13;
    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">0.1</span>)&#13;
&#13;
asyncio.run(main())&#13;
</code></pre>&#13;
    <p class="normal">For this case, adding that little bit of sleep time works fine:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> python3 T_17_wait_for_exit.py&#13;
Before creating the sub-printer task&#13;
After creating the sub-printer task&#13;
Hi from the sub-printer&#13;
</code></pre>&#13;
    <p class="normal">But this only does the trick if your task is fast enough or if you increase the sleep time. If we had a database teardown method that takes several seconds, we could still end up with an issue. As a very crude workaround, it can be useful to add this to your code since it will be more obvious when you’re missing a task.</p>&#13;
    <p class="normal">A slightly better solution is to ask <code class="inlineCode">asyncio</code> what tasks are still running and wait until they have finished. The drawback of this method is that if you have a task that runs forever (in other words, <code class="inlineCode">while True</code>), you will wait forever for the script to exit.</p>&#13;
    <p class="normal">So let’s look at how we <a id="_idIndexMarker1115"/>could implement a feature like this, with a fixed timeout so we won’t wait forever:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> asyncio&#13;
&#13;
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">sub_printer</span><span class="hljs-function">():</span>&#13;
    print(<span class="hljs-string">'Hi from the sub-printer'</span>)&#13;
&#13;
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">printer</span><span class="hljs-function">():</span>&#13;
    print(<span class="hljs-string">'Before creating the sub-printer task'</span>)&#13;
    asyncio.create_task(sub_printer())&#13;
    print(<span class="hljs-string">'After creating the sub-printer task'</span>)&#13;
&#13;
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">main</span><span class="hljs-function">():</span>&#13;
    asyncio.create_task(printer())&#13;
    <span class="hljs-keyword">await</span> shutdown()&#13;
&#13;
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">shutdown</span><span class="hljs-function">(</span><span class="hljs-params">timeout=</span><span class="hljs-number">5</span><span class="hljs-function">):</span>&#13;
    tasks = []&#13;
    <span class="hljs-comment"># Collect all tasks from 'asyncio'</span>&#13;
    <span class="hljs-keyword">for</span> task <span class="hljs-keyword">in</span> asyncio.all_tasks():&#13;
        <span class="hljs-comment"># Make sure we skip our current task so we don't loop</span>&#13;
        <span class="hljs-keyword">if</span> task <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> asyncio.current_task():&#13;
            tasks.append(task)&#13;
&#13;
    <span class="hljs-keyword">for</span> future <span class="hljs-keyword">in</span> asyncio.as_completed(tasks, timeout=timeout):&#13;
        <span class="hljs-keyword">await</span> future&#13;
&#13;
asyncio.run(main())&#13;
</code></pre>&#13;
    <p class="normal">This time, we have added a <code class="inlineCode">shutdown()</code> method that fetches all tasks from <code class="inlineCode">asyncio</code> using <code class="inlineCode">asyncio.all_tasks()</code>. After collecting the tasks, we need to make sure that we don’t get our current task because that would result in a chicken-and-egg problem. The <code class="inlineCode">shutdown()</code> task will never exit while waiting for the <code class="inlineCode">shutdown()</code> task to finish.</p>&#13;
    <p class="normal">When all tasks are gathered, we use <code class="inlineCode">asyncio.as_completed()</code> to wait for them to finish and return after. If the waiting takes more than <code class="inlineCode">timeout</code> seconds, <code class="inlineCode">asyncio.as_completed()</code> will raise an <code class="inlineCode">asyncio.TimeoutError</code> for us.</p>&#13;
    <p class="normal">You can easily modify this <a id="_idIndexMarker1116"/>to try and cancel all tasks so all non-shielded tasks will be canceled right away. And you can also change the exception to a warning instead if the pending tasks are not critical in your use case.</p>&#13;
    <div class="note">&#13;
      <p class="normal"><code class="inlineCode">task = asyncio.shield(...)</code> protects against <code class="inlineCode">task.cancel()</code> and functions like an onion. A single <code class="inlineCode">asyncio.shield()</code> protects against a single <code class="inlineCode">task.cancel()</code>; to protect against multiple cancelations, you will need to shield in a loop, or at least multiple times.</p>&#13;
    </div>&#13;
    <p class="normal">Lastly, it should be noted that this solution is not without its flaws either. It could happen that one of the tasks spawns new tasks while running; this is not something that is handled by this implementation, and handling it improperly might lead to waiting forever.</p>&#13;
    <p class="normal">Now that we know how to debug the most common <code class="inlineCode">asyncio</code> issues, it’s time to end with a few exercises.</p>&#13;
    <h1 id="_idParaDest-386" class="heading-1">Exercises</h1>&#13;
    <p class="normal">Working with <code class="inlineCode">asyncio</code> will require active thought throughout most of your development process. Besides <code class="inlineCode">asyncio.run()</code> and similar methods, there is no way to run an <code class="inlineCode">async def</code> from synchronous code. This means that every intermediate function between your main <code class="inlineCode">async def</code> and the code that needs <code class="inlineCode">asyncio</code> will have to be <code class="inlineCode">async</code> as well.</p>&#13;
    <p class="normal">You could make a synchronous function return a coroutine so one of the parent functions can run it within an event loop. But that usually results in a very confusing execution order of the code, so I would not recommend going down that route.</p>&#13;
    <p class="normal">In short, this means that any <code class="inlineCode">asyncio</code> project you try with the <code class="inlineCode">asyncio</code> debug setting enabled is good practice. We can create a few challenges, however:</p>&#13;
    <ul>&#13;
      <li class="bulletList">Try to create a <code class="inlineCode">asyncio</code> base class that automatically registers all instances for easy closing/destructuring when you are done</li>&#13;
      <li class="bulletList">Create an <code class="inlineCode">asyncio</code> wrapper class for a synchronous process such as file or network operations using executors</li>&#13;
      <li class="bulletList">Convert any of your scripts or projects to <code class="inlineCode">asyncio</code></li>&#13;
    </ul>&#13;
    <div class="note">&#13;
      <p class="normal">Example answers for these exercises can be found on GitHub: <a href="Chapter_13.xhtml"><span class="url">https://github.com/mastering-python/exercises</span></a>. You are encouraged to submit your own solutions and learn about alternative solutions from others.</p>&#13;
    </div>&#13;
    <h1 id="_idParaDest-387" class="heading-1">Summary</h1>&#13;
    <p class="normal">In this chapter, we have seen:</p>&#13;
    <ul>&#13;
      <li class="bulletList">The basic concepts of <code class="inlineCode">asyncio</code> and how they interact</li>&#13;
      <li class="bulletList">How to run external processes using <code class="inlineCode">asyncio</code></li>&#13;
      <li class="bulletList">How to create a server and client using <code class="inlineCode">asyncio</code></li>&#13;
      <li class="bulletList">How to create context managers with <code class="inlineCode">asyncio</code></li>&#13;
      <li class="bulletList">How to create generators with <code class="inlineCode">asyncio</code></li>&#13;
      <li class="bulletList">How to debug common issues when using <code class="inlineCode">asyncio</code></li>&#13;
      <li class="bulletList">How to avoid the unfinished task pitfall</li>&#13;
    </ul>&#13;
    <p class="normal">By now you should know how to keep your main loop responsive while waiting for results without having to resort to polling. In <em class="chapterRef">Chapter 14</em>,<em class="chapterRef"> </em><em class="italic">Multiprocessing – When a Single CPU Core Is Not Enough</em>, we will learn about <code class="inlineCode">threading</code> and <code class="inlineCode">multiprocessing</code> as an <code class="inlineCode">asyncio</code> alternative to running multiple functions in parallel. </p>&#13;
    <p class="normal">For new projects, I would strongly consider using <code class="inlineCode">asyncio</code> from the ground up because it is usually the fastest solution for handling external resources. For existing scripts, however, this can be a very invasive process. So knowing about <code class="inlineCode">threading</code> and <code class="inlineCode">multiprocessing</code> is certainly important, also because <code class="inlineCode">asyncio</code> can leverage them and you should be aware of thread and process safety.</p>&#13;
    <p class="normal">When building utilities based on the <code class="inlineCode">asyncio</code> library, make sure to search for pre-made libraries to solve your problems as <code class="inlineCode">asyncio</code> is gaining more adoption every year. In many cases, someone has already created a library for you.</p>&#13;
    <p class="normal">Next up is parallel execution using <code class="inlineCode">threading</code> and <code class="inlineCode">multiprocessing</code>.</p>&#13;
    <h1 class="heading-1">Join our community on Discord</h1>&#13;
    <p class="normal">Join our community’s Discord space for discussions with the author and other readers: <a href="https://discord.gg/QMzJenHuJf"><span class="url">https://discord.gg/QMzJenHuJf</span></a></p>&#13;
    <p class="normal"><img src="Images/QR_Code156081100001293319171.png" alt="" width="177" height="177"/></p>&#13;
  </div>&#13;
</div></body></html>