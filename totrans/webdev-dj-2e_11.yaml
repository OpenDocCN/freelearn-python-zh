- en: 11\. Advanced Templating and Class-Based Views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to use Django's templating API to create
    custom template tags and filters. You will also write **class-based views** that
    will help you perform CRUD operations. By the end of this chapter, you will have
    a clear understanding of how Django handles advanced templating and how you can
    build custom views that support CRUD-based operations. You will be able to use
    classes to define views inside Django and be able to build custom tags and filters
    to complement the powerful templating engine provided by Django.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Chapter 3*, *URL Mapping, Views, and Templates*, we learned how to build
    views and create templates in Django. Then, we learned how to use those views
    to render the templates we built. In this chapter, we will build upon our knowledge
    of developing views by using `if-else` conditions to successfully handle the different
    types of HTTP request methods. In contrast, class-based views allow us to define
    separate methods for every HTTP request method we want to handle. Then, based
    on the type of request received, Django takes care of calling the correct method
    in the class-based view.
  prefs: []
  type: TYPE_NORMAL
- en: Beyond the ability to build views based on different development techniques,
    Django also comes packed with a powerful templating engine. This engine allows
    developers to build reusable templates for their web applications. This reusability
    of the templating engine is further enhanced by using **template tags** and **filters**,
    which help easily implement commonly used features inside templates, features
    such as iterating over lists of data, formatting the data in a given style, extracting
    a piece of text from a variable to display, and overriding the content in a specific
    block of a template. All these features also expand the reusability of a Django
    template.
  prefs: []
  type: TYPE_NORMAL
- en: As we go through this chapter, we will look at how we can expand the default
    set of template filters and template tags provided by Django by leveraging Django's
    ability to define our own custom template tags and filters. These custom template
    tags and filters can then be used to implement some common features in a reusable
    fashion across our web application. For example, while building a user profile
    badge that can be shown in several places inside a web application, it is better
    to leverage the ability to write a custom template inclusion tag that just inserts
    the template of the badge in any of the views we desire, rather than rewriting
    the entire code for the badge template or by introducing additional complexity
    to the templates.
  prefs: []
  type: TYPE_NORMAL
- en: Template Filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While developing templates, developers often just want to change the value of
    a template variable before rendering it to the user. For example, consider that
    we are building a profile page for a Bookr user. There, we want to show the number
    of books the user has read. Below that, we also want to show a table listing the
    books they have read.
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve this, we can pass two separate variables from our view to the HTML
    template. One can be named `books_read`, which denotes the number of books read
    by the user. The other can be `book_list`, containing the list of names of the
    books read by the user, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Or we can use **Template filters**. Template filters in Django are simple Python-based
    functions that accept a variable as an argument (and any additional data in the
    context of the variable), change its value as per our requirements, and then render
    the changed value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the same outcome from writing the previous snippet can also be obtained
    without the use of two separate variables by using template filters in Django,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, we used the built-in `length` filter provided by Django. The use of this
    filter causes the length of the `book_list` variable to be evaluated and returned,
    which is then inserted into our HTML template during rendering.
  prefs: []
  type: TYPE_NORMAL
- en: Like `length`, there are a lot of other template filters that come pre-packaged
    with Django and that are ready to be used. For example, the `lowercase` filter
    converts the text to all lowercase format, the `last` filter can be used to return
    the last item in the list, and the `json_script` filter can be used to output
    a Python object passed to the template as a JSON value wrapped in a `<script>`
    tag in your template.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You can refer to Django''s official documentation for the complete list of
    template filters offered by Django: [https://docs.djangoproject.com/en/3.1/ref/templates/builtins/](https://docs.djangoproject.com/en/3.1/ref/templates/builtins/).'
  prefs: []
  type: TYPE_NORMAL
- en: Custom Template Filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django supplies a lot of useful filters that we can use in our templates while
    we are working on our projects. But what if someone wants to format a specific
    piece of text and render it with different fonts? Or say if someone wants to translate
    an error code to a user-friendly error message based on the mapping of the error
    code in the backend. In these cases, predefined filters do not suffice, and we
    would like to write our own filter that we can reuse across the project.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Django supplies an easy-to-use API that we can use to write custom
    filters. This API provides developers with some useful decorator functions that
    can be used to quickly register a Python function as a custom template filter.
    Once a Python function is registered as a custom filter, a developer can start
    using the function in templates.
  prefs: []
  type: TYPE_NORMAL
- en: 'An instance of this `template` library method is required to access these filters.
    This instance can be created by instantiating the `Library()` class in Django
    from Django''s `template` module, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Once the instance is created, we can now use the filter decorator from the template
    library instance to register our filters.
  prefs: []
  type: TYPE_NORMAL
- en: Template Filters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To create custom template filters, there are a couple of steps we need to take.
    Let's try to understand what these steps are and how they help us with the creation
    of a custom template filter.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up the Directory for Storing Template Filters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is important to note that when creating a custom template filter or template
    tag, we need to put them in a directory named `templatetags` under the application
    directory. This requirement arises because Django is internally configured to
    look for custom template tags and filters when loading a web application. A failure
    to name the directory as `templatetags` will result in Django not loading the
    custom template filters and tags created by us.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create this directory, first, navigate to the application folder inside
    which you want to create custom template filters, and then run the following command
    in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the directory is created, the next step is to create a new file inside
    the `templatetags` directory to store the code for our custom filters. This can
    be done by executing the following command inside the `templatetags` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The aforementioned command won't work on Windows. You can, however, navigate
    to the desired directory and create a new file using Windows Explorer.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, this can be done by using the GUI interface provided by PyCharm.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up the Template Library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once the file for storing the code for the custom filter is created, we can
    now start working on implementing our custom filter code. For custom filters to
    work in Django, they need to be registered to Django''s template library before
    they can be used inside templates. To that end, the first step is to set up an
    instance of the template library, which will be used to register our custom filters.
    For this, inside the `custom_filters.py` file we created in the previous section,
    we first need to import the template module from the Django project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the import is resolved, the next step is to create an instance of the
    template library by adding the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `Library` class from Django's template module is implemented as a **Singleton**
    class that returns the same object that is only initialized once at the start
    of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Once the template library instance is set up, we are now good to proceed with
    implementing our custom filter.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Custom Filter Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Custom filters inside Django are nothing more than simple Python functions
    that essentially take the following parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: The value on which the filter is being applied (mandatory)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Any additional parameters (zero or more) that need to be passed to the filter (optional)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To behave as template filters, these functions need to be decorated with the
    `filter` attribute from Django''s template library instance. For example, the
    generic implementation of a custom filter will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: With this, we have learned the basics of how to implement custom filters. Before
    we head to our first exercise, let's quickly learn how to use them.
  prefs: []
  type: TYPE_NORMAL
- en: Using Custom Filters inside Templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once the filter is created, it''s simple to start using it inside our templates.
    To do that, the filter first needs to be imported into the template. This can
    be easily done by adding the following line to the top of the template file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: When Django's templating engine is parsing the template files, the preceding
    line is automatically resolved by Django to find the correct module specified
    under the `templatetags` directory. Consequently, all the filters mentioned inside
    the `custom_filter` module are automatically made available inside the template.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using our custom filter inside the template is as simple as adding the following
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Equipped with this knowledge, let's now create our first custom filter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 11.01: Creating a Custom Template Filter'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will write a custom filter named `explode`, which, when
    provided with a string and a user-supplied separator, returns a list of strings.
    For example, consider the following string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You will apply the following filter to this string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The output after applying this filter should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new application inside the `bookr` project that you can use for demo purposes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding command will set up a new application inside your Django project.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, create a new directory named `templatetags` inside your `filter_demo`
    application directory to store the code for your custom template filters. To create
    the directory, run the following command from inside the `filter_demo` directory
    from the terminal app or command prompt:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once the directory is created, create a new file named `explode_filter.py` inside
    the `templatetags` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the file and add the following lines to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code creates an instance of the Django library that can be used
    to register our custom filter with Django.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the following code to implement the `explode` filter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `explode` filter takes two arguments; one is `value` on which the filter
    was used, and the second is `separator` passed from the template to the filter.
    The filter will use this separator to convert the string into a list.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'With the custom filter ready, create a template where this filter can be applied.
    For this, first, create a new folder named `templates` under the `filter_demo`
    directory and then create a new file named `index.html` inside it with the following
    contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, with the template created, the next thing is to create a Django view that
    can render this template and pass the `name` variable to the template. For this,
    open the `views.py` file and add the following highlighted code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now map the view to a URL that can then be used to render the results in the
    browser. To do this, create a new file named `urls.py` inside the `filter_demo`
    directory and add the following code to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `filter_demo` application to the project URL mapping. To do this, open
    `urls.py` in the `bookr` project directory and add the following highlighted line
    inside `urlpatterns`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, add the application under the `INSTALLED_APPS` section under `settings.py`
    of the `bookr` project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To view whether the custom filter works, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, navigate to the following page in your browser: `http://localhost:8000/filter_demo`
    (or `127.0.0.1` instead of `localhost`).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This page should appear as shown in *Figure 11.1*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 11.1: Index page displayed by using the explode filter](img/B15509_11_01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 11.1: Index page displayed by using the explode filter'
  prefs: []
  type: TYPE_NORMAL
- en: With this, we saw how we can quickly create a custom filter inside Django and
    then use it in our templates. Now, let's take a look at another type of filter,
    namely, string filters, which work solely on string type values.
  prefs: []
  type: TYPE_NORMAL
- en: String Filters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *Exercise 11.01*, *Creating a Custom Template Filter*, we built a custom
    filter, which allowed us to split a provided string with a separator and generate
    a list from it. This filter can take any kind of variable and split it as a list
    of values based on a delimiter provided. But what if we wanted to restrict our
    filter to work only with strings and not with any other type of values, such as
    integers?
  prefs: []
  type: TYPE_NORMAL
- en: To develop filters that work only on *strings*, we can use the `stringfilter`
    decorator provided by Django's template library. When the `stringfilter` decorator
    is used to register a Python method as a filter in Django, the framework ensures
    that the value being passed to the filter is converted to a string before the
    filter executes. This reduces any potential issues that may arise when non-string
    values are passed to our filter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps to implement a `     custom_filter.py` file we created in the *Setting Up the Directory for Storing
    Template Filters* section? We can add a new Python function inside it that will
    act as our string filter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can implement a string filter though, we first need to import the
    `stringfilter` decorator, which demarcates a custom filter function as a string
    filter. We can add this decorator by adding the following `import` statement inside
    the `custom_filters.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, to implement our custom string filter, the following syntax can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: With this approach, we can build as many string filters as we want and use them
    just like any other filter.
  prefs: []
  type: TYPE_NORMAL
- en: Template Tags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Template tags are a powerful feature of Django's templating engine. They allow
    developers to build powerful templates by generating HTML through the evaluation
    of certain conditions and help avoid the repetitive writing of common code.
  prefs: []
  type: TYPE_NORMAL
- en: One example where we may use template tags is the sign up/login options in the
    navigation bar of a website. In this case, we can use template tags to evaluate
    whether the visitor on the current page is logged in. Based on that, we can render
    either a profile banner or a sign up/login banner.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tags are also a common occurrence while developing templates. For example,
    consider the following line of code, which we used to import the custom filters
    inside our templates in *Exercise 11.01*, *Creating a Custom Template Filter*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This uses a template tag known as `load`, which is responsible for loading the
    `explode` filter into the template. Template tags are much more powerful compared
    to filters. While filters have access only to the values they are operating on,
    template tags have access to the context of the whole template and hence they
    can be used to build a lot of complex functionalities inside a template.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at the different types of template tags that are supported by Django
    and how we can build our own custom template tags.
  prefs: []
  type: TYPE_NORMAL
- en: Types of Template Tags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Django majorly supports two types of template tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Simple tags**: These are the tags that operate on the variable data provided
    (and any additional variables to them) and render in the same template they have
    been called in. For example, one such use case can include the rendering of a
    custom welcome message to the user based on their username or displaying the last
    login time of the user based on their username.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Inclusion tags**: These tags take in the provided data variables and generate
    an output by rendering another template. For example, the tag can take in a list
    of objects and iterate over them to generate an HTML list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next sections, we will take a look at how we can create these different
    types of tags and use them in our application.
  prefs: []
  type: TYPE_NORMAL
- en: Simple Tags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Simple tags provide a way for developers to build template tags that take in
    one or more variables from the template, process them, and return a response.
    The response returned from the template tag is used to replace the template tag
    definition provided inside the HTML template. These kinds of tags can be used
    to build several useful functionalities, for example, the parsing of dates, or
    displaying any active alerts, if there are any, that we want to show to the user.
  prefs: []
  type: TYPE_NORMAL
- en: The simple tags can be created easily using the `simple_tag` decorator provided
    by the template library, by decorating the Python method that should act as a
    template tag. Now, let us look at how we can implement a custom simple tag using
    Django's template library.
  prefs: []
  type: TYPE_NORMAL
- en: How to Create a Simple Template Tag
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating simple template tags follows the same conventions we discussed in the
    *Custom Template Filters* section, with some subtle differences. Let us go over
    the process of understanding how template tags can be created for use in our Django templates.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up the Directory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Just like custom filters, custom template tags also need to be created inside
    the same `templatetags` directory to make them discoverable by Django''s templating
    engine. The directory can be created either directly using the PyCharm GUI or
    by running the following command inside the application directory where we want
    to create our custom tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Once this is done, we can now create a new file that will store the code for
    our custom template tags by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The aforementioned command won't work on Windows. You can, however, create a
    new file using Windows Explorer.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up the Template Library
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once the directory structure is set up and we have a file in place for keeping
    the code for our custom template tags, we can now proceed and start creating our
    template tags. But before that, we need to set up an instance of Django''s template
    library as we did earlier. This can be done by adding the following lines of code
    to our `custom_tag.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Like custom filters, the template library instance is used here to register
    the custom template tags for use inside Django templates.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a Simple Template Tag
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Simple template tags inside Django are Python functions that can take any number
    of arguments as desired by us. These Python functions need to be decorated with
    the `simple_tag` decorator from the template library such that those functions
    are registered as simple template tags. The following snippet of code shows how
    a simple template tag is implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Using Simple Tags inside Templates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using simple tags inside Django templates is quite easy. Inside the template
    file, we need to first make sure that we have the tag imported inside the template
    by adding the following to the top of the template file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding statement will load all the tags from the `custom_tag.py` file
    we defined earlier and make them available inside our template. Then we can use
    our custom simple tag by adding the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's put this knowledge into practice and create our first custom simple tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 11.02: Creating a Custom Simple Tag'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will create a simple tag that will take in two arguments:
    the first one will be a greeting message, and the second will be the name of the
    user. This tag will print a formatted greeting message:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Following up on the example shown in *Exercise 11.01*, *Creating a Custom Template
    Filter*, let us re-use the same directory structure to store the code for the
    simple tag inside. So, first, create a new file named `simple_tag.py` under the
    `filter_demo/template_tags` directory. Inside this file, add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this case, you create a new Python method, `greet_user()`, which takes in
    two arguments, `message`, the message to use for the greeting, and `username`,
    the name of the user who should be greeted. This method is then decorated with
    `@register.simple_tag`, which indicates that this method is a simple tag and can
    be used as a template tag in the templates.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, create a new template that will use your simple tag. For this, create
    a new file named `simple_tag_template.html` under the `filter_demo/templates`
    directory and add the following code to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code snippet, you just created a bare-bones HTML page that
    will use your custom simple tag. The semantics of loading a custom template tag
    is similar to that of loading a custom template filter and requires the use of
    a `{% load %}` tag in the template. The process will look for the `simple_tag.py`
    module under the `templatetags` directory and, if found, will load the tags that
    have been defined under the module.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following line shows how you can use the custom template tag:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this, you first used Django's tag specifier, `{% %}`, and inside it, the
    first argument you passed is the name of the tag that needs to be used, followed
    by the first argument, `Hey there`, which is the greeting message, and the second
    argument, `username`, which will be passed to the template from the view function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'With the template created, the next step involves creating a view that will
    render your template. For this, add the following code under the `views.py` file
    under the `filter_demo` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code snippet, you created a simple function-based view, which
    will render your `simple_tag_template` defined in *step 2* and pass the value
    `'jdoe'` to the variable called `username`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'With the view created, the next step is to map it to a URL endpoint in your
    application. To do this, open the `urls.py` file under the `filter_demo` directory
    and add the following inside the `urlpatterns` list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With this, `greeting_view` is now mapped to the URL endpoint `/greet` for your
    `filter_demo` application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To see the custom tag in action, start your web server by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After visiting `http://localhost:8000/filter_demo/greet` in the browser (or
    `127.0.0.1` instead of `localhost`), you should see the following page:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 11.2: Greeting message generated with the help of the custom simple
    tag](img/B15509_11_02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 11.2: Greeting message generated with the help of the custom simple
    tag'
  prefs: []
  type: TYPE_NORMAL
- en: With this, we have created our first custom template tag and used it successfully
    to render our template, as shown in *Figure 11.2*. Now, let's look at another
    important aspect of simple tags, which is associated with passing the context
    variables available in the template to the template tag.
  prefs: []
  type: TYPE_NORMAL
- en: Passing the Template Context in a Custom Template Tag
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous exercise, we created a simple tag to which we passed two arguments,
    namely, the greeting message and the username. But what if we wanted to pass a
    large number of variables to the tag? Or simply, what if we did not want to pass
    the username of the user explicitly to the tag?
  prefs: []
  type: TYPE_NORMAL
- en: There are times when developers would like to have access to all the variables
    and data that is present in the template to be available inside the custom tag.
    Fortunately for us, this is easy to implement.
  prefs: []
  type: TYPE_NORMAL
- en: Using our previous example of the `greet_user` tag, let's create a new tag named
    `contextual_greet_user` and see how we can pass the data available in the template
    directly to the tag instead of passing it manually as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first modification we need to make is to modify our decorator to look like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, we tell Django that when our `contextual_greet_user` tag is used,
    Django should also pass it the template context, which has all the data that is
    passed from the view to the template. With this addition done, the next thing
    we need to do is to change our `contextual_greet_user` implementation to accept
    the added context as an argument. The following code shows the modified form of
    the `contextual_greet_user` tag, which uses our template context to render a greeting
    message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code example, we can see how the `contextual_greet_user()`
    method was modified to accept the passed context as the first argument, followed
    by the greeting message passed by the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'To leverage this modified template tag, all we need to do is to change our
    call to the `contextual_greet_user` tag inside `simple_tag_template.html` under
    `filter_demo` to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Then, when we reload our Django web application, the output at `http://localhost:8000/filter_demo/greet`
    should look similar to what was shown in *step 5* of *Exercise 11.02*, *Creating
    a Custom Simple Tag*.
  prefs: []
  type: TYPE_NORMAL
- en: With this, we got to know how we can build a simple tag and handle passing the
    template context to the tag. Now, let us look at how we can build an inclusion
    tag that can be used to render data in a certain format as described by another
    template.
  prefs: []
  type: TYPE_NORMAL
- en: Inclusion Tags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Simple tags allow us to build tags that accept one or more input variables,
    do some processing on them, and return an output. This output is then inserted
    at the place where the simple tag was used.
  prefs: []
  type: TYPE_NORMAL
- en: But what if we wanted to build tags that, instead of returning text output,
    return an HTML template, which can then be used to render the parts of the page.
    For example, a lot of web applications allow users to add custom widgets to their
    profiles. These individual widgets can be built as an inclusion tag and rendered
    over independently. This kind of approach keeps the code for the base page template
    and the individual templates separate and hence allows for easy reuse as well
    as refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: Developing custom inclusion tags is a similar process to how we develop our
    simple tags. This involves the use of the `inclusion_tag` decorator provided by
    the template library. So, let's take a look at how we can do it.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Inclusion Tags
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Inclusion tags are those tags that are used for rendering a template as a response
    to their usage inside a template. These tags can be implemented in a similar manner
    to how other custom template tags are implemented, with some minor modifications.
  prefs: []
  type: TYPE_NORMAL
- en: Inclusion tags are also simple Python functions that can take multiple parameters,
    where each parameter maps to an argument passed from the template where the tag
    was called. These tags are decorated using the `inclusion_tag` decorator from
    Django's template library. The `inclusion_tag` decorator takes a single parameter,
    the name of the template, which should be rendered as a response to the processing
    of the inclusion tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'A generic implementation of an inclusion tag will look like the one shown in
    the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Notice the return value in this case. An inclusion tag is supposed to return
    a dictionary of values that will be used to render the `template_file.html` file
    specified as an argument in the `inclusion_tag` decorator.
  prefs: []
  type: TYPE_NORMAL
- en: Using an Inclusion Tag inside a Template
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An inclusion tag can easily be used inside a template file. This can be done
    by first importing the tag as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'And then by using the tag like any other tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The response of the rendering of this tag will be a sub-template that will be
    rendered inside our primary template where the inclusion tag was used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 11.03: Building a Custom Inclusion Tag'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we are going to build a custom `inclusion` tag, which will
    render the list of books read by a user:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For this exercise, you will continue to use the same demo folders as in earlier
    exercises. First, create a new file named `inclusion_tag.py` under the `filter_demo/templatetags`
    directory and write the following code inside it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `@register.inclusion_tag` decorator is used to mark the method as a custom
    inclusion tag. This decorator takes the name of the template as an argument that
    should be used to render the data returned by the tag function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'After the decorator, you define a function that implements the logic of your
    custom inclusion tag. This function takes a single argument called `books`. This
    argument will be passed from the template file and will contain a list of books
    that the reader has read (in the form of a `Python` dictionary). Inside the definition,
    you convert the dictionary into a Pythonic list of book names. The key in the
    dictionary is mapped to the name of the book and the value is mapped to the author:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the list is formed, the following code returns the list as a context for
    the template passed to the inclusion tag (in this example, `book_list.html`):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The value returned by this method will be passed by Django to the `book_list.html`
    template and the contents will then be rendered.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, create the actual template, which will contain the rendering structure
    for the template tag. For this, create a new template file, `book_list.html`,
    under the `filter_demo/templates` directory, and add the following content to
    it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, in the new template file, you created an unordered list that will hold
    the list of books a user has read. Next, using the `for` template tag, you iterate
    over the values within `book_list` that will be provided by the custom template function:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This iteration results in the creation of several list items, as defined by
    the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The list item is generated with the contents from `book_list`, which was passed
    to the template. The `for` tag executes as many times as the number of items present
    in `book_list`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'With the template defined for the `book_list` tag, modify the existing greeting
    template to make this tag available inside it and use it to show a list of books
    that the user has read. For this, modify the `simple_tag_template.html` file under
    the `filter_demo/templates` directory and change the code to look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this snippet, the first thing you did was load the `inclusion_tag` module
    by writing the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the tag is loaded, you can now use it anywhere in the template. To use
    it, you added the `book_list` tag in the following format:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This tag takes a single argument, which is a dictionary of the books, inside
    which the key is the book title and the value of the key is the author of the
    book. At this point, you can even customize the greeting message; in this step,
    we have gone with a simple "`Hey`" instead of "`Hey there`".
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'With the template now modified, the final step involves passing the required
    data to the template. To achieve this, modify `views.py` in the `filter_demo`
    directory and change the greeting view function to look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, you modified the `greeting_view` function to add a dictionary of books
    and their authors and then you passed it to the `simple_tag_template` context.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'With the preceding changes implemented, it''s time to render the modified template.
    To do this, restart your Django application server by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Navigate to `http://localhost:8080/filter_demo/greet`, which should now render
    a page similar to the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 11.3: List of books read by a user when they visit the greeting endpoint](img/B15509_11_03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 11.3: List of books read by a user when they visit the greeting endpoint'
  prefs: []
  type: TYPE_NORMAL
- en: The page shows the list of books read by a user when they visit the greeting
    endpoint. The list you see on the page is rendered using inclusion tags. The template
    for listing these books is created separately first and then, using the inclusion
    tag, it is added to the page.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Our work with the `filter_demo` app is complete. You can continue to customize
    this app further if you wish to practice the concepts you learned. Since the app
    was created solely to explain the concepts of custom template filters and template
    tags, and is unrelated to the `bookr` app we're building, you won't find it included
    in the `final/bookr` application folder on the GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: With this, we now have the foundations on which we can build highly complex
    template filters or custom tags that can be helpful in the development of the
    projects we want to work on.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's revisit Django views and dive into a new territory of views called
    **Class-Based Views**. Provided by Django, these help us leverage the power of
    object-oriented programming and allow the re-use of code for the rendering of
    a view.
  prefs: []
  type: TYPE_NORMAL
- en: Django Views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To recall, a view in Django is a piece of Python code that allows a request
    to be taken in, performs an action based on the request, and then returns a response
    to the user, and hence forms an important part of our Django applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside Django, we have the option of building our views by following two different
    methodologies, one of which we have already seen in the preceding examples and
    is known as function-based views, while the other one, which we will be covering
    soon, is known as class-based views:'
  prefs: []
  type: TYPE_NORMAL
- en: '`HTTPRequest` type object as their first positional parameter and return an
    `HTTPResponse` type object, which corresponds to the action the view wants to
    perform once the request is processed by it. In the preceding exercise, `index()`
    and `greeting_view()` were examples of FBVs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Class-Based Views** (**CBVs**): CBVs are views that closely adhere to the
    Python object-oriented principles and allow mapping of the view calls in a class-based
    representation. These views are specialized in nature and a given type of CBV
    performs a specific operation. The benefits that CBVs provide include easy extensibility
    of the view and the re-use of code, which may turn out to be a complex task with
    FBVs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, with the basic definitions clear, and with knowledge of FBVs already in
    our arsenal, let's look at CBVs and see what they have in store for us.
  prefs: []
  type: TYPE_NORMAL
- en: Class-Based Views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django provides different ways in which developers can write views for their
    applications. One way is to map a Python function to act as a view function to
    create FBVs. Another way of creating views is to use Python object instances (which
    are based on top of Python classes). These are known as CBVs. An important question
    that arises is, what is the need for a CBV when we can already create views using
    the FBV approach?
  prefs: []
  type: TYPE_NORMAL
- en: The idea here, when creating FBVs, is that at times, we may be replicating the
    same logic again and again, for example, the processing of certain fields, or
    logic for handling certain request types. Although it is completely possible to
    create logically separate functions that handle a particular piece of logic, the
    task becomes difficult to manage as the complexity of the application increases.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is where CBVs come in handy, where they abstract away implementation of
    the common repetitive code that we need to write to handle certain tasks, such
    as the rendering of templates. At the same time, they also make it easy to re-use
    pieces of code through the use of inheritance and mix-ins. For example, the following
    code snippet shows the implementation of a CBV:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we built a simple CBV by inheriting from the built-in
    view class, which is provided by Django.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using these CBVs is also quite easy. For example, let''s say we wanted to map
    `IndexView` to a URL endpoint in our application. In this case, all we need to
    do is to add the following line to our `urlpatterns` list inside the `urls.py`
    file of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: In this, as we can observe, we used the `as_view()` method of the CBV we created.
    Every CBV implements the `as_view()` method, which allows the view class to be
    mapped to a URL endpoint by returning the instance of the view controller from
    the view class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Django provides a couple of built-in CBVs that provide the implementation of
    a lot of common tasks, such as how to render a template, or how to process a particular
    request. The built-in CBVs help to avoid the rewriting of code from scratch when
    handling basic functionality, thereby enabling the reusability of code. Some of
    these in-built views include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Request` methods, such as `GET`, `POST`, `PUT`, and `DELETE`, and the view
    will automatically delegate the call to the method that is responsible for handling
    the request based on the type of request received.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TemplateView**: A view that can be used to render a template based on the
    parameters for the template data provided in the URL of the call. This allows
    developers to easily render a template without writing any logic related to how
    the rendering should be handled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RedirectView**: A view that can be used to automatically redirect a user
    to the correct resource based on the request they have made.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DetailView**: A view that is mapped to a Django model and can be used to
    render the data obtained from the model using a template of choice.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding views are just some of the built-in views that Django provides
    by default and we will cover more of them as we move through the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Now, to better understand how CBVs work inside Django, let's try to build our
    first CBV.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 11.04: Creating a Book Catalog Using a CBV'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, you will create a class-based form view that will help build
    a book catalog. This catalog will consist of the name of the book and the name
    of the author of the book.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To understand the concept of class-based views, we will create a separate application
    inside Bookr with its own set of models and forms such that our existing code
    from previous exercises is not affected. Just like `filter_demo`, we won't be
    including this app in the `final/bookr` folder on our GitHub repo.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, create a new application inside our `bookr` project and name
    it `book_management`. This can be done by simply running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, before building the book catalog, you first need to define a Django model
    that will help you store the records inside the database. To do this, open the
    `models.py` file under the `book_management` app you just created and define a
    new model named `Book`, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The model contains two fields, the name of the book and the name of the author.
    With the model in place, you'll need to migrate the model to your database such
    that you can start storing your data inside the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once all the preceding steps are complete, add your book_management application
    to the `INSTALLED_APPS` list such that it can be discovered by Django and you
    can use your model properly. For this, open the `settings.py` file under the bookr
    directory and add the following code at the final position in the `INSTALLED_APPS`
    section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Migrate your model to the database by running the following two commands. These
    will first create a Django migrations file and then create a table in your database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, with the database model in place, let''s create a new form that we will
    use to capture information about the books, such as the book title, author, and
    ISBN. For this, create a new file named `forms.py` under the `book_management`
    directory and add the following code inside it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the preceding code snippet, you first imported Django''s forms module, which
    will allow you to easily create forms and will also provide the rendering capability
    for the form. The next line imports the model that will store the data for the form:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the next line, you created a new class named `BookForm`, which inherits
    from the `ModelForm`. This is nothing but a class that maps the fields of the
    model to the form. To successfully achieve this mapping between the model and
    the form, you defined a new subclass named `Meta` under the `BookForm` class and
    set the attribute model to point to the `Book` model and the attribute fields
    to the list of fields that you want to display in the form:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This allows for `ModelForm` to render the correct form HTML when expected to
    do so. The `ModelForm` class provides a built-in `Form.save()` method, which,
    when used, writes the data in the form to the database, and so helps avoid having
    to write redundant code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that you have both your model and the form ready, go ahead and implement
    a view that will render the form and accept input from the user. For this, open
    `views.py` under the book_management directory and add the following lines of
    code to the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code snippet, you created two major views, one being `BookRecordFormView`,
    which is also responsible for rendering the book catalog entry form, and the other
    being `FormSuccessView`, which you will use to render the success message if the
    form data is saved successfully. Let's now look at both the views individually
    and understand what we are doing.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'First, you created a new view named the `BookRecordFormView` CBV, which inherits
    from `FormView`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `FormView` class allows you to easily create views that deal with forms.
    To this class, you need to provide certain parameters, such as the name of the
    template it will render to show the form, the form class that it should use to
    render the form, and the success URL to redirect to when the form is processed
    successfully:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `FormView` class also provides a `form_valid()` method, which is called
    when the form successfully finishes the validation. Inside the `form_valid()`
    method, we can decide what we want to do. For our use case, when the form validation
    completes successfully, we first call the `form.save()` method, which persists
    the data for our form into the database, and then call the base class `form_valid()`
    method, which will cause the form view to redirect to the successful URL if form
    validation was a success:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside this class, we override the `get()` method, which will be rendered when
    the form is saved successfully. Inside the `get()` method, we render a simple
    success message by returning a new `HttpResponse`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, create a template that will be used to render the form. For this, create
    a new `templates` folder under the `book_management` directory and create a new
    file named `book_form.html`. Add the following lines of code inside the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Inside this code snippet, two important things need to be discussed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The first is the use of the `{% csrf_token %}` tag. This tag is inserted to
    prevent the form from running into `csrf_token` tag is one of the built-in template
    tags provided by Django to avoid such attacks. It does so by generating a unique
    token for every form instance that is rendered.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The second is the use of the `{{ form.as_p }}` template variable. The data for
    this variable is provided by our `FormView`-based view automatically. The `as_p`
    call causes the form fields to be rendered inside the `<p></p>` tags.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'With the CBVs now built, go ahead and map them to URLs, such that you can start
    using them to add new book records. To do this, create a new file named `urls.py`
    under the book_management directory and add the following code to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Most parts of the preceding snippet are similar to the ones that you have written
    earlier, but there is one thing different in the way we map our CBVs under the
    URL patterns. When using CBVs, instead of directly adding the function name, we
    use the class name and use its `as_view` method, which maps the class object to
    the view. For example, to map `BookRecordFormView` as a view, we will use `BookRecordFormView.as_view()`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'With the URLs added to our `urls.py` file, the next thing is to add our application
    URL mapping to our `bookr` project. To do this, open the `urls.py` file under
    the `bookr` application and add the following line to `urlpatterns`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, start your development server by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then, visit `http://localhost:8080/book_management/new_book_record` (or `127.0.0.1`
    instead of `localhost`.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If everything works fine, you will see a page as shown here:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 11.4: View for adding a new book to the database](img/B15509_11_04.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 11.4: View for adding a new book to the database'
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon clicking `Save record`, your record will be written to the database and
    the following page will show up:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.5: Template rendered when the record is successfully inserted](img/B15509_11_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.5: Template rendered when the record is successfully inserted'
  prefs: []
  type: TYPE_NORMAL
- en: With this, we have created our own CBV, which allows us to save records for
    new books. With our knowledge of CBVs in tow, let's now take a look at how we
    can perform Create, Read, Update, Delete (CRUD) operations with the help of CBVs.
  prefs: []
  type: TYPE_NORMAL
- en: CRUD Operations with CBVs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While working with Django models, one of the most common patterns we run into
    involves the creation, reading, updating, and deletion of objects that are stored
    inside our database. The Django admin interface allows us to achieve these CRUD
    operations easily, but what if we wanted to build custom views to give us the
    same capability?
  prefs: []
  type: TYPE_NORMAL
- en: As it turns out, Django's CBVs allow us to achieve this quite easily. All we
    need to do is to write our custom CBVs and inherit from the built-in base classes
    provided by Django. Building on our existing example of book record management,
    let's see how we can build CRUD-based views in Django.
  prefs: []
  type: TYPE_NORMAL
- en: Create View
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To build a view that helps in object creation, we''ll need to open the `view.py`
    file under the `book_management` directory and add the following lines of code
    to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, we have created our `CreateView` for the book resource. Before we
    can use it, we will need to map it to a URL. To do this, we can open the `urls.py`
    file under the book_management directory and add the following entry under the
    `urlpatterns` list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when we visit `http://127.0.0.1:8000/book_management/book_record_create`,
    we will be greeted with the following page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.6: A view to insert a new book record based on Create view](img/B15509_11_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.6: A view to insert a new book record based on Create view'
  prefs: []
  type: TYPE_NORMAL
- en: This looks similar to the one that we got when using the Form view. On filling
    in the data and clicking `Save record`, Django will save the data to the database.
  prefs: []
  type: TYPE_NORMAL
- en: Update View
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this view, we want to update the data for a given record. To do this, we
    would need to open the `view.py` file under the `book_management` directory and
    add the following lines of code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we have used the built-in `UpdateView` template,
    which allows us to update the stored records. The fields attribute here should
    take in the name of the fields that we would like to allow the user to update.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the view is created, the next step is to add the URL mapping. To do this,
    we can open the `urls.py` file under the `book_management` directory and add the
    following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we have appended `<int:pk>` to the URL field. This signifies
    the field input we are going to have to retrieve the record for. Inside Django
    models, Django inserts a primary key of the integer type, which is used to uniquely
    identify the records. Inside the URL mapping, this is the field that we have been
    asking to insert.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, when we try to open `http://127.0.0.1:8000/book_management/book_record_update/1`,
    it should show us a record of the first record that we inserted into our database
    and allow us to edit it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.7: View displaying the book record update template based on the
    Update view](img/B15509_11_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.7: View displaying the book record update template based on the Update
    view'
  prefs: []
  type: TYPE_NORMAL
- en: Delete View
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Delete view, as the name suggests, is a view that deletes the record from our
    database. To implement such a view for our `Book` model, you will need to open
    the `views.py` file under the `book_management` directory and add the following
    code snippet to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, we have just created a Delete view for our book records. As we can
    see, this view uses a different template where all we would like to confirm from
    the user is, do they really want to delete the record or not? To achieve this,
    you can create a new template file, `book_delete_form.html`, and add the following
    code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can add a mapping for our Delete view by modifying the `urlpatterns`
    list inside the `urls.py` file under the `book_management` directory as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when visiting `http://127.0.0.1:8000/book_management/book_record_delete/1`,
    we should be greeted with the following page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.8: Delete Book Record view based on the Delete view class](img/B15509_11_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.8: Delete Book Record view based on the Delete view class'
  prefs: []
  type: TYPE_NORMAL
- en: Upon clicking the `Delete record` button, the record will be deleted from the
    database and the Deletion success page will be rendered.
  prefs: []
  type: TYPE_NORMAL
- en: Read View
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this view, we would like to see a list of records that our database stores
    for the books. To achieve this, we are going to build a view named `DetailView`,
    which will render details about the book we are requesting. To build this view,
    we can add the following lines of code to our `views.py` file under the `book_management`
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we are creating `DetailView`, which will help
    us to render the details about the book ID we are asking for. The Detail view
    internally queries our database model with the book ID we provide to it and, if
    a record is found, renders the template with the data stored inside the record
    by passing it as an object variable inside the template context.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once this is done, the next step is to create the template for our book details.
    For this we''ll need to create a new template file named `book_detail.html` under
    our `templates` directory inside the `book_management` application with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, with the template created, the last thing we need to do is to add a URL
    mapping for the Detail view. This can be done by appending the following to the
    `urlpatterns` list under the `urls.py` file of the `book_management` application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, with all of this configured, if we now go and open `http://127.0.0.1:8000/book_management/book_record_detail/1`,
    we will get to see the details pertaining to our book, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.9: View rendered when we try to access a previously stored book
    record](img/B15509_11_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.9: View rendered when we try to access a previously stored book record'
  prefs: []
  type: TYPE_NORMAL
- en: With the preceding examples, we just enabled CRUD operations for our `Book`
    model, and all of that while using CBVs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 11.01: Rendering Details on the User Profile Page Using Inclusion
    Tags'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this activity, you will create a custom inclusion tag that helps to develop
    a user profile page that renders not only the users' details but also lists the
    books they have read.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps should help you to complete this activity successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `templatetags` directory under the `reviews` application inside
    the `bookr` project to provide a place where you can create your custom template
    tags.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new file named `profile_tags.py`, which will store the code for your
    inclusion tag.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `profile_tags.py` file, import Django's template library and use
    it to initialize an instance of the template library class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the `Review` model from the reviews application to fetch the reviews
    written by a user. This will be used to filter the reviews for the current user
    to render on the user profile page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, create a new Python function named `book_list`, which will contain the
    logic for your inclusion tag. This function should only take a single parameter,
    the username of the currently logged-in user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the body of the `book_list` function, add the logic for fetching the
    reviews for this user and extract the name of the books this user has read. Assume
    that a user has read all those books for which they have provided a review.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Decorate this `book_list` function with the `inclusion_tag` decorator and provide
    it with a template name `book_list.html`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new template file named `book_list.html`, which was specified to the
    inclusion tag decorator in *step 7*. Inside this file, add code to render a list
    of books. This can be done by using a `for` loop construct and rendering HTML
    list tags for every item inside the list provided.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify the existing `profile.html` file under the `templates` directory, which
    will be used to render the user profile. Inside this template file, include the
    custom template tag and use it to render the list of books read by the user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once you implement all the aforementioned steps, starting the application server
    and visiting the user profile page should render a page that is similar to the
    one shown in *Figure 11.10*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 11.10: User profile page with the list of books read by the user](img/B15509_11_10.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 11.10: User profile page with the list of books read by the user'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this activity can be found at [http://packt.live/2Nh1NTJ](http://packt.live/2Nh1NTJ).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the advanced templating concepts in Django
    and understood how we can create custom template tags and filters to fit a myriad
    of use cases and support the reusability of components across the application.
    We then looked at how Django provides us with the flexibility to implement FBVs
    and CBVs to render our responses.
  prefs: []
  type: TYPE_NORMAL
- en: While exploring CBVs, we learned how they can help us avoid code duplication
    and how we can leverage the built-in CBVs to render forms that save data, help
    us update existing records, and implement CRUD operations on our database resources.
  prefs: []
  type: TYPE_NORMAL
- en: As we move to the next chapter, we will now utilize our knowledge of building
    CBVs to work on implementing REST APIs in Django. This will allow us to perform
    well-defined HTTP operations on our data inside our Bookr application without
    maintaining any state inside the application.
  prefs: []
  type: TYPE_NORMAL
