- en: Chapter 1. Choosing Your Tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we look at the many aspects of designing web applications.
    The idea is to provide you with an overview that may help you recognize components
    in subsequent chapters and give you some insight into the arguments used to decide
    which tool or library to use.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Also, as this book covers more than just developing example applications, we
    illustrate some issues that are relevant when designing an application that does
    not deal with coding directly, like security or usability.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In this chapter, we will be:'
  prefs: []
  type: TYPE_NORMAL
- en: Indentifying the components that a web application consists of
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing suitable tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Considering what designing for maintainability and usability implies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a lot of ground to cover, so let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying the components of a web application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A web application is not a monolithic object. In designing such an application,
    it might help focus if you look at an application as a collection of related objects,
    each with its well-defined purpose. This can be done with multiple levels of detail
    and even the mile high view may already give some valuable insights.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action getting an overview of a web application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From the following picture shown, it should be clear that a web application
    is not a singular thing. It consists of parts that reside on a server and parts
    that run on the computer of the user. Both halves are just as important; although
    the server may hold the application data and implement the logic to modify that
    data following requests from the user, the data is displayed by the part of the
    web application running in the browser on the client computer and the user signals
    his/her request by interacting with the user interface components in the browser,
    for example, by clicking on an "OK" button.
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action getting an overview of a web application](img/3746OS_01_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Think about your application and consider both server and client-side. The advantage
    of looking at the individual halves is that we might make choices that are optimal
    for the specific half.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Look at the general requirements for the client half. For example, because we
    want to offer the user a sophisticated user interface, we opt for the jQuery UI
    library. This decision does not touch the overall design decision on the server,
    because apart from delivering the files that the jQuery UI library consists of,
    the choice of user interface library has no impact on the choice of the database
    engine or the server operating system for example.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Look at the requirements for the server half. For example, consider which implementation
    language to use. We select Python as the language to implement the server-side
    code but if we had compelling arguments to switch to C#, we could do so without
    the need to change anything on the client.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we zoom in on our web application, an image emerges of many interacting layers,
    each encapsulating a well defined piece of functionality. Everywhere two layers
    touch, information flows through a well defined interface (API). This helps in
    the separation of concepts (our application is only talking to the database layer
    to store and retrieve persistent data and only to the web server to return data
    upon request) but in practice, the separation between these layers isn't completely
    clear in all circumstances. For example, the server-side part of our application
    is actually an integral part of the web server.
  prefs: []
  type: TYPE_NORMAL
- en: This simple schematic of a web application is virtually identical to a regular
    client-server architecture. However, when we look more closely at the implementation
    of the client and the interaction between client and server, differences will
    emerge as we will see in the next section where we zoom in a bit closer.
  prefs: []
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With both halves of the application identified, we can now zoom in on each individual
    half.
  prefs: []
  type: TYPE_NORMAL
- en: This will enable us to get a more detailed image, that will help us to make
    informed decisions regarding the smaller components that make up our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main components are easy to identify:'
  prefs: []
  type: TYPE_NORMAL
- en: The data store holds data on the server (it is often a database engine, sometimes
    just files on the filesystem).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The server-side application services requests that are passed through from the
    web server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The web server forwards those responses to the client again and may serve static
    files as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The web browser takes care of running the client side of the application, but
    within the browser, we can identify several layers of activities. These consist
    of:'
  prefs: []
  type: TYPE_NORMAL
- en: Fetching the content to structure the data (often HTML files)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running JavaScript code to enhance the presentation of the data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allowing interaction with the user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![What just happened?](img/3746OS_01_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Of course we could zoom in even further to reveal additional detail like the
    operating system on the client and the server, or even the hardware and the network
    components and although occasionally useful, this would generally be overkill.
    With the main components clearly identified, we can take the next step and choose
    suitable tools to implement these components.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing suitable tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you want to develop quality applications, you need suitable tools. Tools,
    of course, do not guarantee quality, but they can make life a lot easier. When
    developing web applications, there are two kinds of tools you need to consider:
    the ones you use to design, build, test, and deploy your application, like editors,
    version management systems, test frameworks, and maybe a package tool, and the
    tools that deliver your application to the end user. That last set of tools consists
    of a whole chain of components, from server operating system, web server, and
    database engine, all the way to the web browser and the JavaScript libraries used
    to display and interact with the application.'
  prefs: []
  type: TYPE_NORMAL
- en: When we start a project, we have to know which tools we need and have to understand
    the capabilities and limitations of the many variations of these tools. There
    are, for example, quite a few JavaScript libraries that may be used to provide
    cross-browser compatible user interaction.
  prefs: []
  type: TYPE_NORMAL
- en: The trick is to make an informed choice. These choices are not necessarily limited
    to open source tools. If budget permits, it might be worthwhile to have the benefit
    of the special features many commercial development tools and libraries offer,
    but in this book, we limit ourselves to open source and/or free resources. This
    makes sense as the cost of tooling and licenses in small projects can make a significant
    dent in a budget.
  prefs: []
  type: TYPE_NORMAL
- en: The opportunity to use free tools might not exist for the deployment environment.
    You may well develop your application on your own Linux box, but test and deploy
    it on a Windows server. The latter needs a license that will not be free, but
    even open source options are not always free. Many companies nowadays shift to
    deploying their applications to the cloud and even though these machines might
    be running an open source operating system, you pay not only for CPU power and
    bandwidth but also for support, the latter being crucial in applications that
    will lose you money if they are not running. However, using open source tools
    in general gives you a much wider choice because many tools run equally well on
    any platform.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we will look at the many components that make up
    the tool chain and will try to show what arguments were used for the choices made
    for developing the applications in this book and what (if any) viable alternatives
    are there. Note that some arguments are quite subjective and the choice finally
    made does not necessarily indicate that the alternative is bad; we certainly are
    not attempting to start flame wars over which tool is better. We simply list requirements
    for application development as we see it and try to find the tools suitable for
    the task. In some situations, another tool might be better, but for this book,
    we try to find a matching toolset that can be used for all sample applications
    that are free (as in beer) and easy to learn and use.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action choosing a delivery framework, also known as web server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the first section of this chapter, we showed that a web application lives
    in two realms at the same time, namely, on the server and on the client. In order
    to deliver information to the client and receive a response in return, our web
    application needs two important items at the server: a delivery framework and
    an application to compose content and respond to the request.'
  prefs: []
  type: TYPE_NORMAL
- en: The delivery framework might be a full-fledged general purpose web server such
    as Apache or Microsoft Information Server, but although these are very versatile
    and come with many options to tune the web server to your specific needs, they
    certainly take quite some time to get acquainted with and it takes extra attention
    to integrate the dynamic content of your application with these servers. If performance
    is crucial or the requirements for your project include that your application
    has to be deployed as part of these servers, you may not have a choice, but otherwise
    its worth looking at the alternatives that are simpler to use or offer integration
    advantages.
  prefs: []
  type: TYPE_NORMAL
- en: So what do we need?
  prefs: []
  type: TYPE_NORMAL
- en: A fairly lightweight web server that is easy to configure and maintain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That allows for smooth integration of static and dynamic content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That comes with reusable components that ease the development process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That is actively maintained and developed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given these requirements, our choice for delivery framework is CherryPy.
  prefs: []
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'CherryPy fits the bill nicely. Its main advantages are:'
  prefs: []
  type: TYPE_NORMAL
- en: CherryPy is written in Python and components that deliver dynamic content are
    written as Python classes that are tightly integrated with CherryPy's core.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CherryPy comes with a whole host of **tools**; reusable components that can
    be used to implement anything from custom error pages to session management.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CherryPy has a proven track record as the core web server of the larger TurboGears
    network.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And finally, CherryPy is actively developed and enjoys a large user community.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The disadvantage of being written in Python is that performance might not be
    top notch, but we will look into that in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action choosing a server-side scripting language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When developing web applications, you have a virtually unlimited choice of programming
    languages you can use, so we have to consider what is important for us in our
    project and make a tradeoff if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Consider how important development time is compared to performance. Compiled
    languages like C# or C++ might be used if CPU power is scarce or if you do not
    want to distribute the source code in a readable format. But when development
    time is at a premium, using scripting languages often saves time as they make
    it easier to develop applications in an incremental way, even to the point where
    you can type in commands interactively to see what is possible and later incorporate
    these trials in your code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance is generally not an issue, especially when using scripting languages
    that are compiled to intermediate byte code, as is the case for languages like
    Python and Perl, for example. And while it is true that scripted languages are
    compiled each time they are run, this has a negligible effect when the program
    is a long running web application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Weigh the importance of debugging. Interpreted languages are often simpler to
    debug as compiled languages, both because the debugger has access to more information
    that you may explore interactively if something breaks and because you can try
    out any modules you have written by interactively calling functions to see what
    happens.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Think beyond the project. Once implemented and deployed, your application might
    have a long and happy life, but that inevitably means that there will be requests
    for smaller or larger changes and choosing a suitable language can help to reduce
    the maintenance effort. Compared to compiled languages that in general have quite
    low-level instructions and language constructs, interpreted languages have (very)
    high level constructs that make for condensed code that packs a lot of meaning
    in a few statements. That is not only easier to read but also faster to interpret
    and in the end these high level constructs, once interpreted, run at (almost)
    compiled speed making the performance difference sometimes hard to spot. More
    meaning and less code do make for easier reading and this is a huge benefit when
    maintaining code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the end, the choice for the language to implement the web application is
    at least in part a matter of taste, but in this book we opt for Python as it offers
    an optimal tradeoff between the different considerations.
  prefs: []
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have chosen Python as our server-side scripting language, let''s
    have a good look at the arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: Python is easy to read and therefore easy to learn and maintain. Although Python
    is relatively unique among programming languages in treating whitespace as meaningful
    in many places, this does enhance readability quite a lot.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python is a very high level language, incorporating concepts like list comprehension
    and functional programming. This allows for compact programs that pack a lot of
    functionality in little code, enhancing readability and reducing maintenance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python comes "batteries included". Python is distributed with a vast amount
    of well designed and well maintained libraries (modules) that provide anything
    from access to `.csv` files and parsing XML, to building an HTTP server with a
    handful of code and these modules are at least as well documented as the language
    itself. This all means we can cut down on development time as in many cases we
    do not have to reinvent the wheel ourselves.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python has many third party modules. Even if a module is not included with the
    distribution, chances are somebody has written just the module you are looking
    for.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python is an object-oriented language. This is widely regarded as a good thing
    as it aids in data abstraction but its main attraction to people developing database-driven
    applications is that it allows for a natural way of mapping tables to types (classes).
    Records in a table of cars can be mapped to a 'Car' class and instances of this
    class can then be manipulated in much the same way as native classes like strings
    or lists. This again makes it easier to read the code and therefore maintain the
    code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python is available on many cloud platforms. To run a Python program on the
    server, you need Python deployed on that server. If you have full access, this
    might not be an issue and indeed hosting companies provide (virtual) machines
    with Python already installed but for very lightweight cloud platforms like Google
    Gears, your choice of available languages might be limited. However, Python (together
    with Java) is fully supported by Google Gears and although this is not a consideration
    for the example applications in this book, it might be for your applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The version of Python we use in this book is version 3 (version 3.2 at the time
    of writing). Although not all third party modules are (yet) ported to this new
    version, it is the best version to use if you want to develop in a future proof
    way.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python's multi-threading capabilities at the moment do not allow for optimal
    usage of multi-core processors. Most implementations of Python do not allow running
    separate threads truly in parallel. This is by far not as bad as you may think
    though, as this restriction is mainly valid for interpreted python code, not necessarily
    for code running in, for example, the OS kernel. And because in a web server a
    lot of time is spent waiting for packets to be sent or received over the network,
    this mostly does not affect the performance of your Python code. In the future,
    the multi-threading implementation of Python may change, but this is a hotly debated
    subject. More on this subject can be found by searching for "Python 3 GIL".
  prefs: []
  type: TYPE_NORMAL
- en: Time for action choosing a database engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the key requirements of any web-application is that is has access to
    some sort of persistent storage. This might be used to store core data like a
    catalog of car parts, but a password file also needs a form of persistent storage.
  prefs: []
  type: TYPE_NORMAL
- en: Often it is possible to store the information in files on the filesystem and
    indeed some of the applications we develop in this book do just that, but if you
    have a lot of structured data or you find that many people want to access this
    data at the same time, it is usually a better choice to store this data in a database
    and access this data through a database engine.
  prefs: []
  type: TYPE_NORMAL
- en: 'When choosing a database engine, you should consider the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: Does it offer the functionality you need? Database engines are sophisticated
    pieces of software and in general offer a lot of functionality, often more than
    you need. Although this may sound like an advantage, all these features must be
    learned by a developer to take advantage of them and may complicate your code
    which may increase the effort to maintain an application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is it easy to install and maintain? Database engines often run as separate applications
    that are accessed over a network. This means that they have to be installed, tested,
    and maintained separately. This may add significantly to the effort needed to
    deploy your application. And installation isn't even everything; you will have
    to consider operational issues as well, for example, how much effort it is to
    set up a suitable backup scheme or how to monitor the availability of the database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does it offer an API that is simple to use from your chosen programming language
    and does this API provide access to all necessary functionality?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And finally, does it perform well enough to respond swiftly to the requests
    of your application, even during peaks?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Python offers a standardized API to access many available database engines,
    including MySQL and PostgreSQL. Fully in line with its ''batteries included''
    philosophy, Python also comes included with a database engine and a module to
    access it. This database is called SQLite and is a so called embedded database:
    it doesn''t run as a standalone process that can be accessed through some means
    of inter-process communication, but the database engine is an integral part of
    the program that uses it. Its only external part is a single file containing the
    data in the database itself and that may be shared by other programs that include
    the SQLite engine. As it fits our requirements, SQLite will be the database engine
    we will use for the applications we develop in this book.'
  prefs: []
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our choice for SQLite as the database for many of our applications is easily
    justified:'
  prefs: []
  type: TYPE_NORMAL
- en: Although not as feature-rich as, for example, MySQL, it does provide the functionality
    we need.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installation is practically a no brainer as SQLite comes included with Python.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The API offered by the `sqlite3` module gives access to all functionality.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It performs well enough for our needs (although statements about performance
    are very difficult to make in advance).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main arguments supporting the use of SQLite in our applications are not
    its speed, small memory footprint, or reliability (although these are certainly
    not drawbacks as SQLite's reputation as database engine of choice for mobile telephone
    appliances proves) but the fact that because it is embedded in your program, it
    obviates the need for a separately configured and maintained database engine.
    This cuts down on maintenance in a serious manner as database engines are demanding
    beasts that take a lot of care and feeding. Also, because it is included in Python,
    it reduces the number of external dependencies when deploying an application.
  prefs: []
  type: TYPE_NORMAL
- en: A final argument is its type system that closely resembles Python's type system;
    in contrast to many other database engines, SQLite allows you to store any value
    in a column no matter how this column was typed when it was created, just like
    you can store a string in a Python variable that was first used to store an integer
    value. This close correspondence of types allows for an intuitive mapping of Python
    values to values stored in the database, an advantage that we will study closely
    when we encounter our first application that uses SQLite.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The integration with Python is so close that it is possible to use Python functions
    within the SQL expressions used to query SQLite. The native set of functions in
    SQLite is quite small compared to other database engines but the ability to use
    Python functions removes this limitation completely. It is, for example, straightforward
    to add a hash function from Python's `hashlib` module, that is very convenient
    when implementing a password database.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action deciding on object relational mappers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Relational database engines like SQLite use tables consisting of rows and columns
    as their primary data abstraction model. Object-oriented languages like Python
    define classes to instantiate objects that have attributes. There is a fair amount
    of correspondence between these concepts as class definitions mimic table definitions
    where object instances with attributes relate to records with columns but maintaining
    the integrity of that relation is not so straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: The problem not only lies in the different languages used to define tables and
    classes. The main issue in relational databases is maintaining referential integrity.
    If you have, for example, a record representing a car part that references a record
    in a different table that represents a car type, then a relational database lets
    you define explicit actions to execute if, for example, the record representing
    the car type is deleted. These constraints are of course possible to implement
    in Python data structures as well, but it does take serious effort to implement.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, most database engines require fixed data types for each column whereas
    Python variables and attributes may refer to any kind of data type. This restriction
    is not present in SQLite but even SQLite cannot store everything without conversion.
    A Python variable, for example, may refer to a list of objects, something that
    cannot be stored in a single column of a relational database.
  prefs: []
  type: TYPE_NORMAL
- en: Still, we would very much like to have a way to store object instances in a
    relational database or at least the data contained in those object instances,
    and have the means to define the relation between classes and tables in a maintainable
    way. To this end, many people have designed solutions in the form of object relational
    mappers. For Python, quite a few exist that are both mature and robust tools (like
    SQLAlchemy).
  prefs: []
  type: TYPE_NORMAL
- en: 'When deciding which tool to use, you should at least consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: How much time it will cost to learn to use it. Those tools are usually very
    versatile and quite often require a considerable amount of effort to learn.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How will it affect development and maintenance? Complex tools may help to solve
    the challenge of creating an effective and efficient mapping between classes and
    tables, but may require an idiom that detracts from a clear overview of your implementation.
    This may well be worth it, if your data model consists of many classes and performance
    is an important consideration, but for smaller projects the added complexity might
    be too great of a disadvantage when it impacts significantly on the development
    time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because the focus in this book is on understanding the choices in implementing
    web applications and persistent storage, using a complex tool like an object relational
    mapper may hide all kinds of aspects necessary to gain understanding.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, we will not use a third party object relational mapper in the examples
    in this book but implement increasingly versatile storage solutions in each chapter,
    tackling specific requirements as we encounter them. We will see that in many
    situations an object relational mapper is superfluous, but in the final chapters,
    we will build a simple framework ourselves to give us not only a tool but an insight
    into the intricacies of mapping complex assemblies of classes to tables in a database
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action choosing a presentation framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Web applications might be all about accessing and manipulating data from within
    a web browser but the way the application looks and feels to the user is just
    as important. A user interface that is non-intuitive, sluggish, or fails to work
    on some mainstream browser will not invite users to use your application again.
  prefs: []
  type: TYPE_NORMAL
- en: 'HTML, the markup language commonly used to display content, does allow for
    some interaction through the use of`<form>` elements and the way a page is presented
    can be styled with cascading style sheets, but its use has some major drawbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: It is quite difficult to create user interface components from basic building
    blocks that resemble commonly used applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use of HTML feels sluggish because each form, when submitted, fetches a
    completely new page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fortunately, all major browsers support JavaScript and that language can be
    used to add a whole new level of interactivity. However, in order to smooth out
    all inconsistencies between browsers, you can save a lot of development time when
    you use a JavaScript library that takes care of those inconsistencies and adds
    cross browser compatible user interface components (widgets).
  prefs: []
  type: TYPE_NORMAL
- en: Although such libraries are used client side, HTML pages can be composed in
    a way that instructs the browser to fetch these libraries from a central source,
    for example, the same server that serves the web application. This way, the use
    of these libraries imposes no extra requirements on the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some points to consider when choosing a suitable library are:'
  prefs: []
  type: TYPE_NORMAL
- en: Is it really cross browser compatible? Not all libraries support each and every
    browser. This might be important if your application still needs to work with
    a fairly old browser.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does it offer the graphical components and functionality you need?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is it well designed and documented, extensible, and consistently implemented?
    After all, such a library should be fairly easy to learn and as no library can
    offer everything, extensibility and especially how easy it is to extend it are
    important considerations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does it have an active user community? All the more important here because such
    a community may not only provide answers to your questions, but may be a good
    source of reusable components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Based on these considerations, we choose to use two intimately connected JavaScript
    libraries: jQuery and jQuery UI.'
  prefs: []
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's have a look at why jQuery and jQuery UI are such a good choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'jQuery provides the functionality to select and manipulate HTML elements on
    a page and jQuery UI provides a number of sophisticated widgets and effects. Together,
    they offer many advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: jQuery not only hides browser inconsistencies, but its methods take CSS3 compatible
    selectors even on browsers that do not support CSS3 in the style sheet they accept.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both libraries are widely used, actively maintained, free, and are distributed
    as small files. The latter is important when you consider that these files need
    to be transferred from server to client so any bandwidth saved is good.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: jQuery UI offers a rich set of well designed and professional looking graphical
    components and effects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other advantages of the wide adoption of these libraries are that there are
    many resources available to get you started and that many people have written
    plugins that extend the usability of these libraries even more. As we will see
    on many occasions, the essence of developing a good application efficiently is
    often choosing the right plugin for the job.
  prefs: []
  type: TYPE_NORMAL
- en: Designing for maintainability and usability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is one thing to come up with a great idea on how to implement some web application
    but yet another to design an application in such a way that it will be easy to
    maintain and use. Designing with these considerations in mind will make all the
    difference between a professional application and a mediocre one.
  prefs: []
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Everybody will agree that it makes sense to test an application before it is
    deployed but thorough testing requires some serious effort. Testing is also often
    considered as boring or even detracting from the 'real' development work and shares
    this aura with writing documentation.
  prefs: []
  type: TYPE_NORMAL
- en: However, testing gives you a better feel for the quality of the application
    you deliver and a test framework, however simple, is always better than none,
    especially for the kind of small to medium web applications we look at in this
    book, as these tend to be written by very small teams that quickly prototype and
    often change the code as insight progresses and customer requirements change.
    Having a test suite at hand ensures that at least the parts of the code that don't
    change keep on performing as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, not everything can be tested and the tools needed to test part of
    your code should be simple to use, otherwise there is no incentive to keep on
    using them. We will look at **unit tests** for a number of modules we develop
    in Python. Unit testing is an approach where we try to define the behavior of
    an isolated piece of code (for example, a single method) and check whether this
    code produces the expected results. If the implementation of the code changes
    but the tests still show no failure, we know that the new implementation can be
    used safely.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action choosing a test framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When choosing a test framework, ask yourself the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What do I want to test? You cannot test everything and developing tests takes
    time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How easy is it to write and maintain the tests? This question is just as relevant
    for developing tests as it is for developing code in general.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How much effort is needed to perform the tests? If it is easy to automate the
    tests, they can, for example, be run as part of the deployment as an extra check.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Just for Python alone there are quite a few testing frameworks available, but
    we will choose the `unittest` module distributed with Python. Note that although
    we choose to write only automated test for the Python parts of the applications,
    this doesn't mean we have not tested the JavaScript parts, but user interactions
    tend to lend themselves less to an automated way of testing so we do not address
    that in this book.
  prefs: []
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the Python unit tests, we restrict ourselves to the `unittest` module that
    is distributed with Python, as this will not introduce any new dependencies on
    external tools but also because:'
  prefs: []
  type: TYPE_NORMAL
- en: It is fairly simple to learn and use.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It produces clear messages if a test fails.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is easy to automate and may easily be integrated with, for example, a setup
    script.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Version management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A version management tool is normally not part of a web application and not
    strictly required to develop one. However, when you want to keep track of changes
    in your code, especially when the number of files keeps on growing, a version
    management tool is invaluable.
  prefs: []
  type: TYPE_NORMAL
- en: Most come with integrated functionality to show the differences between versions
    and all have the possibility to annotate a version or revision in order to clearly
    mark it. Widely used open source solutions are **git** and **svn**.
  prefs: []
  type: TYPE_NORMAL
- en: Both may operate as a server that can be accessed through a web browser but
    command-line tools are available as well and svn even has a very user-friendly
    integration within Windows' file explorer. Both have their strengths and weaknesses
    and it is hard to declare a clear winner. This book and its accompanying examples
    were all maintained in svn, primarily because of the ease of use of the Windows
    client.
  prefs: []
  type: TYPE_NORMAL
- en: Usability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Web applications are built for end users, not for developers. It is not always
    easy to design an interface that is easy to use. In fact, designing really good
    interfaces is difficult and takes considerable skill and knowledge. However, this
    does not mean that there aren't any rules of thumb that can help you prevent usability
    disasters. We look at some of them in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Good looking adhering to common GUI paradigms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Applications are easier to use if the interface components are already familiar.
    Therefore, it is generally a good idea to look at applications that are successful
    and used by many people.
  prefs: []
  type: TYPE_NORMAL
- en: 'A common concern in many applications is the need to present a lot of information
    in a small amount of space. It is therefore no wonder that many modern applications
    use accordion menus and/or a tabbed interface to structure that data, such as
    the following screenshots:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Good looking adhering to common GUI paradigms](img/3746_1_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'An accordion menu is great for displaying a fair amount of information in a
    side bar but even more information can be presented in tabs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Good looking adhering to common GUI paradigms](img/3746_1_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Examples are found in all recent editions of common office productivity software,
    web browser, and CRM applications. Having a good look at the ones you like working
    with yourself might be a good start. In the larger applications developed in this
    book, we will certainly refer to some key applications that may be used as an
    inspiration.
  prefs: []
  type: TYPE_NORMAL
- en: Themable
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Choosing a consistent and pleasing color scheme and font makes an application
    more coherent and therefore more pleasurable to use. An overload of information
    can baffle people and using a wild color scheme or many different fonts will not
    help in getting an overview of the data that is presented.
  prefs: []
  type: TYPE_NORMAL
- en: But whether your user interface supports the concept of a theme that is easy
    to change plays an important role in other areas as well. You probably want your
    web application to blend in well with the rest of your website or to convey some
    sort of company or brand identity. Using a consistent color scheme will help.
    It might even be desirable to offer a choice of themes to the end user, for example,
    to provide people with visual impairments with high contrast themes for better
    legibility. The library fully supports the use of themes and makes it simple to
    extend this themability to widgets we design ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-browser compatible
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Web applications are often geared to a specific audience, so it might be possible
    that the requirements specify only a single browser, but in general, we don't
    want to deny the user his/her favorite browser. jQuery takes away most of the
    pain in supporting more than one browser. Our apps are designed for Internet Explorer
    8, Firefox 3.x, and Google Chrome, but probably will run on most other browsers
    as well. Note that 'probably' might not be good enough and it is always a good
    idea to test your application specifically on any required platform!
  prefs: []
  type: TYPE_NORMAL
- en: Cross-platform compatible
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Client-side, the web browser is the key component in our chain to watch out
    for and therefore, the operating system it is running on will quite likely not
    be a source of problems.
  prefs: []
  type: TYPE_NORMAL
- en: Server-side, we want to keep our options open as well. Fortunately, Python is
    a cross platform solution, so any Python program that runs on Windows will normally
    run on GNU/Linux as well and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: We should be careful though when using modules that are not distributed with
    Python and are not pure Python. These might be available on every platform but
    it is better to check beforehand. The applications in this book use only modules
    provided in the standard Python distribution, with the exception of CherryPy,
    which is a pure Python module and should run on every platform.
  prefs: []
  type: TYPE_NORMAL
- en: Maintainability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Writing code is hard work, maintaining it can be even harder. We briefly touched
    upon this subject earlier when we discussed the use of a testing framework, but
    maintaining code is more than being able to test it.
  prefs: []
  type: TYPE_NORMAL
- en: Standards compliant
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An important concept in creating code that is easy to maintain is being standards
    compliant. Adhering to standards means that other people stand a greater chance
    in understanding your code.
  prefs: []
  type: TYPE_NORMAL
- en: SQL, for example, is a query language that most database engines understand.
    Therefore, it is less relevant which engine we use for people maintaining the
    code as they do not have to learn an obscure query language.
  prefs: []
  type: TYPE_NORMAL
- en: Another example is communication between client and server. We can devise our
    own protocol to construct requests in JavaScript and respond to those requests
    in Python, but it is a lot less error prone to use documented standards like AJAX
    to communicate and JSON to encode data. It also saves on documentation as people
    can be referred to any number of books, if they want to learn more about those
    standards.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Standard does not necessarily mean 'approved by some independent organization'.
    Many standards are informal but work because everybody uses them and writes about
    them. Both AJAX and JSON are examples of that. Also the Python programming language
    is a de facto standard but JavaScript enjoys a formal standard (which doesn't
    mean all implementations adhere to the standard).
  prefs: []
  type: TYPE_NORMAL
- en: Security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Security is often regarded as an obscure or arcane subject, but security covers
    many practical issues that play a role in even the smallest web application. We
    wouldn't want anyone to access a paid-for web application, for example. However,
    security is more than just access control and we touch briefly on some aspects
    of security in the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: Reliable
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A web application should be reliable in its use. Nothing is more annoying than
    being presented with a server-side error halfway in the process of filling in
    a mortgage application, for example. As a developer and tester, you take care
    of testing the software thoroughly in the hope of catching any bugs but before
    implementing the application, the reliability of the software and libraries it
    uses should be taken into consideration.
  prefs: []
  type: TYPE_NORMAL
- en: You should especially be wary of using the latest and greatest nifty feature
    of some library in production software. This might be fun when whipping up some
    mock up or concept application, but do ask yourself if your customer really needs
    this bleeding edge feature and if he's/she's not better off with a tried and tested
    version.
  prefs: []
  type: TYPE_NORMAL
- en: Many open source projects (including Python) develop and maintain both a so
    called stable branch and a development branch to show off new features. The former
    you should use in production applications and the latter should be tried elsewhere.
  prefs: []
  type: TYPE_NORMAL
- en: Robust
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Applications should not only be as bug-free as possible, but should also perform
    nicely under stress as well. The performance should be as high as possible under
    load, but just as important you should know what to expect when the load reaches
    some threshold.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, tuning for performance is one of the trickiest jobs imaginable
    because all components in the chain may play a role. Server-side considerations
    are the performance of the database engine used, the scripting language, and the
    web server.
  prefs: []
  type: TYPE_NORMAL
- en: Client-side, the quality of the presentation framework and the overall performance
    of the web browser are important and in between the server and client is the great
    unknown of the characteristics of the underlying network.
  prefs: []
  type: TYPE_NORMAL
- en: With so many variables, it is not easy to design an optimal solution in advance.
    However, we can test the performance of individual components and see if the component
    is a bottle neck. For example, if it takes three seconds to refresh a page provided
    by a web application you can rule out the database engine as a bottleneck if you
    can time the database access independently. The knowledge gained creating unit
    tests can be reused here because we already know how to isolate some functionality,
    and adding a timer and asserting that the response for a query is fast enough
    can be made a test itself.
  prefs: []
  type: TYPE_NORMAL
- en: It is also quite feasible to separately measure the time it takes to fetch a
    web component and to render it in the browser with a tool like Firebug and get
    an idea whether the client or the server is the bottleneck. (Firebug is a Firefox
    extension and can be found at [http://getfirebug.com/)](http://getfirebug.com/)).
  prefs: []
  type: TYPE_NORMAL
- en: Access control and authentication
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In almost every application that we develop in this book, we implement some
    sort of authentication scheme. Most of the time, we will use a simple username/password
    combination to verify that the user is who he/she claims to be. Once the user
    is authenticated, we can then decide to serve only certain information, for example,
    just a list of the tasks belonging to him/her, but no tasks of any other user.
  prefs: []
  type: TYPE_NORMAL
- en: However, whether access to information is allowed, isn't always that basic.
    Even in simple applications, there might be a user who should be allowed more
    than others, for example, adding new users or resetting passwords. If the number
    of different things a user is allowed to do is small, this is straightforward
    to implement, but if the situation is more complex, it is not that easy to implement,
    let alone to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the more elaborate applications featured in the later chapters of this book,
    we will therefore adopt the concept of role based access. The idea is to define
    roles that describe which actions are allowed when assuming a role. In a customer
    relations management application, for example, there might be three roles: a sales
    person, who is only allowed to access information for his customers, the sales
    manager who may access all information, and an administrator who may not access
    any information, but is allowed to back up and restore information, for example.'
  prefs: []
  type: TYPE_NORMAL
- en: Once the rights of these roles are clear, we can associate any or all of these
    roles with specific persons. A small organization, for example, may have a technically
    savvy sales person who can also assume the admin role, yet still be unable to
    access information about customers other than his own this way.
  prefs: []
  type: TYPE_NORMAL
- en: If rights associated with a certain role are changed, we do not have to repeat
    this information for each and every person that may assume that role, thus making
    administration that much simpler.
  prefs: []
  type: TYPE_NORMAL
- en: Confidentiality
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In some applications, we may want to make sure no one is listening in on the
    data transferred between the browser and web server. After all, in general you
    do not know which path your data takes, as it is routed across the Internet and
    at any point there might be someone who can intercept your data.
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to ensure confidentiality is to use connection level encryption
    and the HTTPS protocol does just that. The web server we use, CherryPy, is certainly
    capable of serving requests over HTTPS and configuring it to do so is quite simple
    but it involves creating signed certificates which is a bit out of the scope of
    this book. Refer to [http://www.cherrypy.org/wiki/ServerObject](http://www.cherrypy.org/wiki/ServerObject)
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Integrity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The last aspect of security we talk about in this context is data integrity.
    Corruption of data may not always be prevented, but wholesale destruction may
    be guarded against with proper backup and restore protocols.
  prefs: []
  type: TYPE_NORMAL
- en: However, data corruption lurks in very small corners too. One of the trickiest
    things that can happen is the possibility of inserting data that is wrong. For
    example, if it is possible to input a date with a month outside the range 1-12,
    very strange things might happen if the application relies elsewhere on dates
    having the correct format.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is, therefore, important to prevent the user entering wrong data by building
    in some sort of client-side validation. An excellent example is jQuery UI''s `datepicker`
    widget that we will encounter in [Chapter 3](ch03.html "Chapter 3. Tasklist I:
    Persistence"), *Tasklist I: Persistence*. If a text input field is adorned with
    a `datepicker`, the user can only enter dates by selecting dates from the `datepicker`.
    This is a great aid to the end-user, but we should never rely on client-side validation
    because our client-side validation might be inadequate (because it contains a
    bug or doesn''t check all cases) and certainly cannot prevent malicious users
    from connecting to the server and actively inserting wrong data. We do need server-side
    input validation as well to prevent this and we will encounter some examples of
    it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The key thing is to provide both: server-side validation as a last resort and
    client-side as an aid to the user.'
  prefs: []
  type: TYPE_NORMAL
- en: A final word on security
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Security is complex and tricky and details may be overlooked easily. You might
    know you have a front door made of 10 centimeter oak with state of the art steel
    locks, but if you forget to lock the backdoor all that oak and steel serves no
    purpose. Of all the subjects touched upon in this book, security is the one that
    you should always talk over with an expert. Even an expert cannot give you guarantees
    but taking a fresh look at the security requirements might keep you out of trouble.
    Make sure that you run the sample applications provided in this book in a secure
    environment behind a well managed firewall.
  prefs: []
  type: TYPE_NORMAL
- en: Help, I am confused!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Reading this chapter, you may get the feeling that developing web applications
    is horribly complex, even if you use the right tools. So many things may play
    a role! Do not despair though.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action maintaining overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you take a close look, you will see that none of it is rocket science, the
    most it takes is common sense and attention for detail, and in every chapter,
    we highlight the relevant issues in a straightforward language where it is relevant.
    Remember that this is a practical book, there will be many working examples that
    are examined in close detail and we won't inundate you with theory, but give you
    just enough to get things done.
  prefs: []
  type: TYPE_NORMAL
- en: At every step in the development process, ask yourself the following questions?
  prefs: []
  type: TYPE_NORMAL
- en: What needs to be done? There is no need to work on all things at the same time,
    indeed this is practically impossible. Allow yourself to form a high level idea
    first and identify the components in the next level down. Don't get bogged down
    with details when the outline is not clear yet.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which components of the application are involved? Identify the specific components
    involved when you develop a piece of functionality. The whole idea of identifying
    layers and components is to be able concentrate on a limited part of the application
    when developing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This might not always work perfectly, but it certainly helps in maintaining
    focus. For example, when developing parts of the presentation layer, you may find
    that additional content is needed that should be provided by the delivery layer.
    Instead of immediately switching focus to that delivery layer, it's often simpler
    to define what is needed and complete the part of the presentation layer you are
    working on.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: What are the requirements? There is no need to implement stuff that is not needed.
    This may sound obvious, but many developers nevertheless fall into this trap.
    It is tempting of course to design your code to be as flexible as possible but
    it takes a lot of time, and as requirements change, it is unlikely that it'll
    prove flexible enough. Instead, the effort is better spent on writing code that
    is easy to understand so that the inevitable changes in requirements take less
    time to process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When asking those questions and given the choices we made in this chapter,
    it might be helpful to draw a new picture that illustrates the technologies we
    will use:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened?](img/3746OS_01_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The different components between the server and client that together make up
    the web application can be pictured as a layered stack. For each layer, we have
    chosen one or a few technologies, as illustrated in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened?](img/3746OS_01_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Each application we encounter will be based on this model, so it might help
    to refer to this diagram once in a while if you feel you have lost track.
  prefs: []
  type: TYPE_NORMAL
- en: After reading this book, you will be left with the feeling that writing good,
    useable web applications is maybe a little bit more involved than you might have
    thought at first, but that is certainly within the reach of even the smallest
    of teams. Armed with all the fresh knowledge and practical experience, you will
    not have to compromise on quality, not even in the smallest project.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter gave us a head start in providing an overview of the components
    and techniques involved in creating a quality web application. Specifically, we
    looked at:'
  prefs: []
  type: TYPE_NORMAL
- en: The components that make up a web application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The technologies we choose to implement these components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which other issues play a role in the design, like security and usability.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this extra knowledge, nothing can hold us back from writing our first web
    application in Python and that is exactly what we will do in the next chapter.
  prefs: []
  type: TYPE_NORMAL
