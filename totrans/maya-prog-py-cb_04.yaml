- en: Chapter 4. Giving Things a Coat of Paint – UVs and Materials
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will be looking at topics related to the UV layout and
    shader creation:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Querying UV data
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Laying out UVs with Python
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating shading networks with code
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying shaders to objects
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using shading nodes for non-rendering tasks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we looked at how to manipulate geometry with script.
    However, for most projects, creating the models is only the first step. Unless
    you want everything to look like boring gray plastic, you'll need to layout UVs,
    then create and apply shading networks.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will be looking at how to do just that.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Querying UV data
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we will be looking at how to get information about UVs on a
    polygonal object. We will look at examining how many UV sets the object contains,
    getting the UVs for a given part of the object, and grabbing the position of a
    given UV point.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: We will also look at how to convert one kind of selection to another and use
    that to determine if a given edge can be split or not.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure that you have a scene that contains at least one polygonal object
    that has UVs—either an object that you have unwrapped or any of the built-in primitive
    shapes, which have UVs by default.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new file, name it `uvInfo.py` (or similar), and add the following
    code:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you run the preceding script with a polygonal object selected, you will
    get some information about the object''s UVs, specifically:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: How many UVs the object has.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The location (in UV space) of the first UV point
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether or not the first edge lies on the border between two separate UV shells.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We start by grabbing the currently selected object and storing it into our `obj`
    variable. Once we have done this, we use the `polyEvaluate` command to determine
    the total number of UVs the object has. This is similar to what we did in the
    previous chapter to find the number of geometric components, but this time around,
    we use the `uvComponent`/`uvc` flag.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next up, we will find the specific position of the first UV point. UVs can
    be accessed in much the same way other polygonal components, but using the "map"
    list instead of the "f" (faces), "e" (edges), or "vtx" (vertices). Therefore,
    if we want to refer to the first UV of an object named `myObject`, we would use
    the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, 0 indicates the first entry in the list and therefore the first UV of
    the object.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'To actually find the specific U and V coordinates of a given UV, we can use
    the `polyEditUV` command in a query mode, as in the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next up is determining whether a given edge is internal to a UV shell or if
    it is on the border between two different shells. To do this, we create a function
    that accepts the name of an object and the index of an edge to check:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The key thing that we are doing is to see how many vertices and how many UVs
    correspond to the given edge. If the number of vertices is not equal to the number
    of UVs, then that edge must be straddling the border of two different UV shells.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在做的关键事情是查看有多少顶点和UV与给定的边相对应。如果顶点的数量不等于UV的数量，那么这条边必须跨越两个不同的UV壳的边界。
- en: To determine how many vertices/UVs correspond to a given edge, we'll convert
    the edge to the desired component type using the `polyListComponentConversion`
    command. For that to work properly, we will need to specify both what we are converting
    from (in this case, edges), and what we're converting to (either vertices or UVs).
    The way that we do that is a bit odd; instead of specifying the types of each,
    we have to set two Boolean flags to true, one for the source type and one for
    the destination.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定有多少顶点/UV与给定的边相对应，我们将使用`polyListComponentConversion`命令将边转换为所需的组件类型。为了正确执行，我们需要指定我们正在转换的内容（在这种情况下，是边），以及我们正在转换到什么（顶点或UV）。我们这样做的方式有点奇怪；而不是指定每种类型的类型，我们必须将两个布尔标志设置为true，一个用于源类型，一个用于目标类型。
- en: 'For example, if we were to convert the first edge of an object named `myObject`
    to vertices, we would need to do the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们要将名为`myObject`的对象的第一个边转换为顶点，我们需要做以下操作：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Adding in the proper variables to set the name of the object and the index
    of the edge gives us:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 添加适当的变量来设置对象的名称和边的索引，我们得到：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Note that we store the output of the command to a variable named "result".
    This is important because getting an accurate count of the number of points requires
    that we first select the components we want to count. This is easily done in the
    following way:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们将命令的输出存储到名为"result"的变量中。这很重要，因为要获得准确的数量，我们需要首先选择我们想要计数的组件。这可以很容易地按照以下方式完成：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Once we''ve done this, we can use the `polyEvaluate` command with the proper
    flag to give us the number of *currently selected* components. For vertices and
    UVs, we will want to use `vertexComponent` and `uvComponent`, respectively. In
    both cases, we store the result to another variable, as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们这样做，我们就可以使用带有适当标志的`polyEvaluate`命令来给出当前所选组件的数量。对于顶点和UV，我们希望使用`vertexComponent`和`uvComponent`，分别。在两种情况下，我们将结果存储到另一个变量中，如下所示：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'At this point, we have the number of vertices that correspond to the given
    edge. We then do the same operation (but with slightly different flags) to determine
    the number of UVs:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们有了与给定边相对应的顶点数量。然后我们执行相同的操作（但带有略微不同的标志）以确定UV的数量：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, we compare the number of UVs to the number of vertices. If they are
    not the same, then the edge in question must exist on more than one UV shell and,
    as such, represents a border:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将UV的数量与顶点的数量进行比较。如果它们不相同，那么所讨论的边必须存在于多个UV壳上，因此它代表了一个边界：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Back in our main function, we output the results of our various queries with
    a few print statements:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的主函数中，我们使用几个打印语句输出我们各种查询的结果：
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, we will be sure to select the original object once again because we
    selected subcomponents during the `isSplitEdge` function:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将确保再次选择原始对象，因为我们选择了`isSplitEdge`函数期间的子组件：
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Laying out UVs with Python
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python布局UV
- en: In this example, we will look at how to actually lay out UVs using Python. We
    will be applying planar, cylindrical, and spherical projections, each to a different
    subset of the faces of the selected object.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将查看如何使用Python实际布局UV。我们将应用平面、圆柱和球面投影，每个投影到所选对象的不同面集。
- en: Getting ready
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure that you have a scene containing a polygonal object. We will be applying
    three different mappings to different parts of the object (selected by dividing
    the total number of faces by three), so it is best to have an object with at least
    a few dozen faces. If you do not have a model handy, make a polygonal sphere of
    at least 10 or so divisions along both height and axis.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你有一个包含多边形对象的场景。我们将对对象的不同部分应用三种不同的映射（通过将总面数除以三来选择），因此最好有一个至少有几十个面的对象。如果你没有现成的模型，制作一个至少有10个或更多分度的多边形球体。
- en: How to do it...
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a new script and add the following code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的脚本并添加以下代码：
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Run this script with a polygonal object selected and then switch to the UV Texture
    Editor panel to see the results.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 选择多边形对象后运行此脚本，然后切换到UV纹理编辑器面板以查看结果。
- en: How it works...
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The main thing that we are doing here is to apply a new UV layout to a subset
    of the object's faces. This is a somewhat artificial example because we are selecting
    faces by just splitting the total number into thirds.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'First off, we grab the currently selected object and determine the total number
    of faces it has using `polyEvaluate`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, we determine what one-third of that number is. Note that Python will
    default to integer division because both `totalFaces` and 3 are whole integer
    values. That happens to be exactly what we need for this application, but can
    easily lead to errors if you are not expecting it:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If you ever want to ensure that you get a proper decimal value as a result,
    just be sure to divide by a floating-point value, as in:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We also create a couple of helper variables to hold the start and end indices
    for each of the three sets of faces:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'There is nothing particularly hard about what we are doing here though some
    care is needed to ensure that we include the entire range of faces. The values
    that we use are as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '|   | Start index | End index | Example indices (based on a 100-face object)
    |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
- en: '| 1st (planar) mapping | 0 | oneThird - 1 | 0-32 |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
- en: '| 2nd (cylindrical) mapping | oneThird | (oneThird * 2) - 1 | 33-65 |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
- en: '| 3rd (spherical) mapping | oneThird * 2 | totalFaces - 1 | 66-99 |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
- en: Now we are ready for the meat of the script—actually, applying mappings. All
    three mapping types (planar, cylindrical, and spherical) are applied using the
    same command, `polyProjection`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A brief aside on UV mapping—it might seem strange that the three types of mapping
    are planar, cylindrical, and spherical; why those particular shapes and no others?
    The reason for this is that if you think of the surface of the model as a two-dimensional
    skin, then any given part of the model can be classified as belonging to one of
    only three groups:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: The region doesn't have any significant curvature.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The region has significant curvature in a single direction (horizontal or vertical).
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The region has significant curvature in both directions.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That maps neatly onto the three options of planar (no curve), cylindrical (single-direction
    curve), and spherical (curvature in both directions). While the part you are trying
    to map may be very different from a perfect plane, cylinder, or sphere, start
    by asking yourself how many directions it curves in and select your mapping accordingly.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two things we need to supply to the `polyProjection` command for
    it to work—the specific faces that should receive the mapping and the type of
    mapping to apply. To specify the range of faces, we will want to index into the
    faces or "f" array of the object. We can specify more than one face at a time
    using two indices with a colon in between. For example, if our object was named
    `mySphere`, and we wanted to refer to the first six faces, we could do that with:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In this case, we''ll want to use the name of the selected object, and the `startFace`
    and `endFace` variables for the indices. Doing this gives us the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now that we have a way to specify the range of faces, we can apply the mappings,
    using the `type` flag to specify which kind of mapping to apply:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: From here, we just repeat the process with different values for `startFace`
    and `endFace`, and different options for the type flag.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you want to apply a mapping to the entire object, you might think that you
    just have the name of the object and leave out the face indices. This doesn''t
    work, but there is an easy way to tell Maya that you want to refer to all of the
    faces. To do this, just leave out both indices, but keep the colon, as in:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If the starter index is missing, Maya will substitute 0, and if the ending index
    is missing, Maya will substitute the maximum index. Leaving *both* out will result
    in the mapping being applied to the entire object.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: So far, we've only looked at selecting contiguous sequences of faces, but there
    are lots of situations where you might want to select faces that aren't consecutive
    indices. You can do that by having multiple selections separated by commas as
    first argument(s) to a function.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let us say that we wanted to select the first 5 faces *and* faces
    32 through 76 of `myObject`. We could use the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Applying this to UV mapping would give us something like the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'When working with ranges of faces, it''s very common that you''ll determine
    the specific indices at runtime, either through some kind of calculation or based
    on a user input. It''s easy enough to do, but can lead to overly complex sequences
    of stick together string literals and variables, such as the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: It's also very easy to forget to convert numerical values to strings with the
    `str()` command, which can lead to errors. Luckily enough, Python provides an
    alternative way to deal with building formatted strings from variables in the
    form of the `format` command.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: To use the format command, you create a string with sections you want to replace
    with variables. Each replaceable section is represented with curly brackets containing
    a number such as `{0}`. You can then call the format command on that string and
    pass in variables that will replace the `{}` clauses. The numbers are used to
    specify which variables should go where ("{0}" means "replace with the first variable",
    for example).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'So, as a really simple example, we could wish someone happy birthday with the
    following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Turning back to Maya, let''s say that we wanted to have a generic way to select
    a range of faces. We would want to pass in the name of the object, the start index,
    and the ending index as variables. We could do this with:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This would work just fine, but is a bit hard to read and is an easy way to
    introduce errors. If we were to rewrite that using the format command, we would
    have something like this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This tends to be a lot easier to think through because it allows you to separate
    the structure (the string) from the variables that should be slotted into it.
    You certainly don't have to use format, but as Maya scripting very often requires
    building up strings from variables in this way, using it will likely save you
    a lot of headaches. It also makes your code a lot more readable.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常更容易思考，因为它允许你将结构（字符串）与应该填充到其中的变量分开。你当然不必使用格式，但鉴于Maya脚本经常需要以这种方式从变量中构建字符串，使用它可能会节省你很多麻烦。它还使你的代码更容易阅读。
- en: See also
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The official Python documentation for the format command is a bit hard to wade
    through and presents the information in an overly opaque way. Instead, I highly
    recommend having a look at [https://pyformat.info/](https://pyformat.info/), for
    a detailed, yet highly readable explanation of the intricacies of the format command.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 格式命令的官方Python文档有点难以理解，并且以过于晦涩的方式呈现信息。相反，我强烈建议您查看[https://pyformat.info/](https://pyformat.info/)，那里有对格式命令复杂性的详细且易于阅读的解释。
- en: Creating shading networks with code
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用代码创建着色网络
- en: In this example, we'll be looking at how to create shading networks with code.
    We'll be creating a simple toon shader, with a solid color in the interior and
    a different color at the edges of the object. There are a few different ways to
    do this, including by creating a rampShader, but we'll be doing it in the somewhat
    old-fashioned way using a samplerInfo node, as it provides a great example of
    a relatively simple yet somewhat novel shading network.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将探讨如何使用代码创建着色网络。我们将创建一个简单的卡通着色器，内部为纯色，而物体的边缘为不同的颜色。有几种不同的方法可以做到这一点，包括创建渐变着色器，但我们将以相对老式的方式使用`samplerInfo`节点，因为它提供了一个相对简单但相对新颖的着色网络的绝佳示例。
- en: First off, let's have a look at what our shader will do and how it will do it.
    The key characteristic of a toon shader is that the object has an outline around
    its edges that changes as the object moves. So, the first thing we'll need is
    some way of knowing what the angle is between a given part of the model and the
    camera. Luckily, Maya provides a utility node that does just that in the form
    of samplerInfo. SamplerInfo nodes provide us with a `facingRatio` attribute that
    ranges from 0 (when a surface is perpendicular to the camera) to 1 (when a surface
    is facing directly at the camera).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看我们的着色器将做什么以及它是如何做到的。卡通着色器的关键特性是物体边缘有一个轮廓，随着物体的移动而改变。因此，我们首先需要知道模型的一部分与相机之间的角度。幸运的是，Maya提供了一个名为`samplerInfo`的实用节点，它正好可以做到这一点。`SamplerInfo`节点为我们提供了一个`facingRatio`属性，其范围从0（当表面垂直于相机时）到1（当表面直接面向相机时）。
- en: Once we have the facing ratio, we'll need to tie it to a color change somehow.
    The easiest and most flexible way to do this is to use a ramp texture with linear
    interpolation to provide a sharp cutoff between the border and interior colors.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们得到了面对比，就需要以某种方式将其与颜色变化联系起来。最简单且最灵活的方法是使用具有线性插值的渐变纹理，以在边框颜色和内部颜色之间提供清晰的截止。
- en: 'Putting all that together gives us a relatively simple, three-node shading
    network similar to the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些组合起来，我们得到了一个相对简单的、由三个节点组成的着色网络，类似于以下内容：
- en: '![Creating shading networks with code](img/4657_04_01.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![使用代码创建着色网络](img/4657_04_01.jpg)'
- en: How to do it...
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create a new script and add the following code:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的脚本并添加以下代码：
- en: '[PRE28]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If you run the script, you should see a new shader appear in the hypershade,
    consisting of a red interior and a black exterior edge.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行脚本，你应该在hypershade中看到一个新着色器出现，内部为红色，外部边缘为黑色。
- en: How it works...
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: There are three parts of the script—creating the nodes, setting their attributes,
    and connecting them to each other.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本分为三个部分——创建节点、设置它们的属性以及将它们相互连接。
- en: 'First off, we create the three nodes we need with the `shadingNode` command:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用`shadingNode`命令创建所需的三个节点：
- en: '[PRE29]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The first thing to note is that the shadingNode command is used for all three
    nodes we create even though they''re three different types (one shader, one texture,
    and one utility). In all cases, you get the results you want by specifying the
    specific kind of node that you want to create (`''blinn''`, for example) and also
    including one of the following flags set to True: `asShader`, `asTexture`, `asUtility`,
    `asPosProcess`, `asRendering`, `asLight`.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是，尽管我们创建了三个不同类型的节点（一个着色器、一个纹理和一个工具），但仍然使用`shadingNode`命令。在所有情况下，通过指定你想要创建的特定类型的节点（例如`'blinn'`）以及包括以下标志之一设置为True：`asShader`、`asTexture`、`asUtility`、`asPosProcess`、`asRendering`、`asLight`，你都可以得到你想要的结果。
- en: Leaving out those flags will result in an error. If you include the wrong flag
    (asTexture=True when creating a Blinn shader, for example), the command will still
    work, but I don't recommend it.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果省略这些标志，将会导致错误。如果你包含了错误的标志（例如在创建Blinn着色器时`asTexture=True`），命令仍然会工作，但我不建议这样做。
- en: Creating the nodes is pretty straightforward—just make sure that you also save
    the output to a variable (as we've done here) so that you can later set their
    attributes and connect them.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 创建节点相当直接——只需确保你也将输出保存到一个变量中（就像我们在这里所做的那样），这样你就可以稍后设置它们的属性并将它们连接起来。
- en: 'Once we have all of our nodes created, we need to set their attributes. In
    this case, we need to do the following few different things that are applied to
    the ramp texture:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了所有节点，我们需要设置它们的属性。在这种情况下，我们需要对渐变纹理执行以下几项不同的操作：
- en: Ensure that the color interpolation is set to linear to give us nice sharp transitions
    between colors, rather than smooth gradients.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保颜色插值设置为线性，以便在颜色之间提供清晰的过渡，而不是平滑的渐变。
- en: Make sure that the color swatches are positioned correctly along the length
    of the ramp.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保颜色样本在渐变的长度上正确定位。
- en: Set both the colors to have the edge color and the interior color that we want.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将两种颜色都设置为边缘颜色和我们想要的内部颜色。
- en: 'For all of the above, we''ll use the `setAttr` command. The `setAttr` command
    expects the name of the attribute to set as the first argument, followed by the
    value to which it should be set. For single value, numeric values, that''s pretty
    straightforward. For example, the following sets the ramp''s interpolation to
    none:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 对于上述所有内容，我们将使用`setAttr`命令。`setAttr`命令期望第一个参数是要设置的属性的名称，后面跟着应该设置的值。对于单个数值，这相当直接。例如，以下将渐变的插值设置为无：
- en: '[PRE30]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Although the type of interpolation isn't actually a numerical value, it's a
    common practice in Maya (and other places) to use integers to represent various
    options. When setting attribute values that are represented in the interface by
    a drop-down menu, you'll generally want to use an integer, with the specific value
    corresponding to the position of the option in the list (with 0 being the first
    one).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然插值的类型实际上不是一个数值，但在Maya（和其他地方）中，使用整数来表示各种选项是一种常见的做法。当设置在界面中以下拉菜单表示的属性值时，你通常会想要使用一个整数，其具体值对应于列表中选项的位置（其中0是第一个）。
- en: Next, we'll want to set the colors of the ramp texture to have the correct positions
    and colors. The first thing to understand is that ramp textures maintain an array
    of nodes, contained in their `colorEntryList` attribute. Each entry in that list
    represents a stop in the ramp texture and has both a position and a color.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要设置渐变纹理的颜色，使其具有正确的位置和颜色。首先需要理解的是，渐变纹理维护一个节点数组，这些节点包含在其`colorEntryList`属性中。该列表中的每个条目代表渐变纹理中的一个停止点，并具有位置和颜色。
- en: 'We''ll want to make sure that the first entry is at the very beginning of the
    ramp, and the second entry is slightly less than halfway along it, as it gives
    us a good default edge thickness for the shader. We do this using setAttr to set
    the position of the first two entries in the `colorEntryList` array, as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要确保第一个条目位于渐变的非常开始处，第二个条目位于中间略低的位置，因为它为我们提供了着色器的好默认边缘厚度。我们使用`setAttr`来设置`colorEntryList`数组中前两个条目的位置，如下所示：
- en: '[PRE31]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Next, we'll want to set the colors. That's a bit different, in that we need
    to feed three separate values into the `setAttr` command (one each for red, green,
    and blue). To do this, we'll need to provide all three numbers, and we'll also
    need to tell Maya to expect multiple inputs to the `setAttr` command by using
    the `type` flag.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'The `setAttr` command is one of the most powerful and most flexible commands
    that Maya offers. It can be used to alter any value of any node. All that power
    requires the command be able to accept various kinds of inputs, all specified
    with the type flag. In this case, we need a format that supports decimal values
    (since colors are represented as number from 0 to 1), and that supports three
    separate values. Either `float3` or `double3` will work. Putting that all together
    gives us the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: At this point, we've set all of the attribute values that we need for the shader.
    All that's left is to connect the nodes to each other. We do it with the `connectAttr`
    command. That's fairly straightforward and just requires that we specify first
    the source attribute, then the destination.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we want to make two connections:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: The `facingRatio` attribute of the samplerInfo to the V coordinate of the ramp
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `outColor` of the ramp texture to the color of the shader
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Doing this ends up looking like:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: There's more...
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating nodes and connecting their attributes is a great way to approach a
    wide range of tasks in Maya, but it can sometimes be tedious. For example, if
    we wanted to create a `place2dTexture` utility node and connect it to a texture
    node, we would have to make over a dozen connections, which is tedious, to say
    the least. Luckily, Maya provides an easy shortcut to create nodes with the default
    behavior in the form of the `defaultNavigation` command.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what that would look like:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note the inclusion of the `connectToExisting=True` to indicate that the nodes
    being connected are already present in the scene. Much nicer than 18 separate
    calls to `connectAttr`, indeed.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also break connections between nodes with Python with the `disconnectAttr`
    command. For example, if we wanted the previously mentioned two-node network of
    a place2dTexture and a file texture to share everything `except` the offset attribute,
    we could do the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Sometimes, it might be faster to connect two nodes with the default connections
    (with defaultNavigation) and break a few specific connections you don't want,
    instead of manually creating all the connections you do want.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Be sure to refer to the built-in documentation for the `setAttr` command for
    a complete list of the types of inputs it can accept. The documentation is a bit
    dense, but it's definitely worth a look.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Applying shaders to objects
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you have a shading network created, you'll generally want to apply it to
    one or more objects. In this example, we'll be looking at how to do it. Along
    the way, we'll create a script that can be used to apply a shader to all of the
    objects in the scene that are without one.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure that you have a scene with a few different objects in it. Select a
    few objects and apply a shader to them in the normal way, using the hypershade's
    interface. Delete the shader, leaving at least one object without any shader of
    any kind.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new script and add the following code:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Run the script, and you should see any and all of the objects that were previously
    without a shader sporting a brand new, cyan-colored blinn shader.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The script works by:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Getting a list of all the objects in the scene.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running through the list and checking whether a given node is geometry.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For any geometric node, find the shaders applied to it.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a given object has no shaders, add it to a list of non-shaded objects.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a new shader to apply.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apply the shader to the shader-less objects.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This script makes use of the `hyperShade` command in a couple of different ways—to
    find the shaders attached to an object, the objects attached to a shader, and
    to apply a shader.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s look at how to grab the shaders for a given object. To make things
    easier on ourselves later, we''ll create a function to do it. We have the following
    code:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The main thing that we're doing is to use the hyperShade command with the `shaderNetworksSelectMaterialNodes`
    (or just `smn`) flag set to true. That will select the shader (or shaders) of
    the currently selected objects. Because the command works on selections, we have
    to make sure that the object (or objects) we want to know about are selected before
    we run it. Once we've run it, we'll need to examine the currently selected nodes
    to get the list of shaders.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we create a function to easily tell if a given transform node corresponds
    to actual geometry. We need it because we''re going to iterate over all the transforms
    in the scene, and there are many things (lights, cameras, and so on) that have
    transforms but that aren''t geometry. We accept the name of the node as an input
    and find the corresponding shape node:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Then, we examine the shape node to find what kind of object it is:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note that the `listRelatives` command returns an array, so we need to index
    into that and grab the first element. It's unlikely that an object would have
    multiple shape nodes, but `listRelatives` can also be used to find an object's
    children, which will often be multiple nodes. Since it can sometimes result in
    multiples, the command therefore always returns an array even if there's only
    a single item.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of the three types of geometry in Maya (polygon, NURBS, and subdivision
    surfaces) has its own corresponding shape node. For the sake of convenience and
    code readability, we''ll create an array of those types and check the current
    shape node''s type against it:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'At this point, we''re ready to jump into the real meat of the script. We start
    by grabbing a list of all of the transforms in the scene using the `ls` command.
    So far, we''ve mainly used that to find what''s currently selected, but it can
    also be used to grab all the nodes of a specific type (selected or not):'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Then, we create an empty list to which we''ll add any object that we find to
    be lacking a shader and start running through the list of transforms. First, we
    check to make sure that the node in question is geometry of some kind. If that''s
    the case, we use our `shadersFromObject` function to find the shader(s) applied
    to the object. Once we''ve done this, we check the length of the returned list-
    if it''s zero, then the object had no shaders, and we add it to our list:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'At this point, the `unShaded` list contains all of the objects in the scene
    that lack shaders. We create a new shader, a simple blinn, and set its color to
    cyan:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Finally, we select the contents of the `unShaded` list and apply the shader
    we just made. For that, we''ll use the `hyperShade` command again, but this time
    with the assign flag to apply the specified shader to the currently selected objects.
    We have the following code:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: There's more...
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `hyperShade` command can be used to do most of the tasks one would normally
    accomplish in the hypershade panel interface. In the previous example, we grabbed
    shaders from objects, but the command can also be used to find the objects associated
    with a given shader with the `objects` flag. Wrapping that up in a nice function
    to return the objects for a given shader would look something like the following:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Once again, the `hyperShade` changes the current selection, and we use the `ls`
    command to retrieve the selection as an array.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Using shading nodes for non-shading tasks
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the really great things about the various nodes that Maya provides is
    that there are very few limits on how you use them. To Maya, all nodes are just
    collections of functionality with certain inputs and outputs, and as long as the
    type of data lines up, it doesn't really care how you connect them.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: This means that it's completely possible (and often very useful) to use hypershade
    nodes for tasks that aren't related to creating shading networks. In this example,
    we'll be doing just that using a plus/minus/average utility node to set the position
    of a given object to the average position of a number of others. This could be
    used, for example, to ensure that the pelvis of a character always stays centered
    in between the IK handles controlling its feet.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Using utility nodes can be used for tasks where you might otherwise write an
    expression, but with the added benefit that they update constantly, not just while
    the playback head is moving.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Be sure that you have a scene with at least three objects in it.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new script and add the following code:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Select at least three objects, making sure that the object you want to be controlled
    is the last one selected, and run the script. Once you've done that, try moving
    the objects around, and you'll see that the X and Z position of the controlled
    object is always an average of the X and Z positions of all the other objects.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First off, we check to make sure that there are at least three objects selected
    and error out if there isn''t:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If we have at least three objects, we proceed to create a brand new utility
    node, in this case a plus/minus/average node. Since the plus/minus/average node
    can perform three completely separate actions, we also need to set its "operation"
    attribute to average (which happens to be the fourth option in the corresponding
    dropdown, so has a value of 3), as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Once we've done this, we run through the list of selected objects and connect
    all but the last one to the utility node as inputs. PlusMinusAverage nodes can
    have one-dimensional, two-dimensional, or three-dimensional inputs. In this case,
    we'll use 3D inputs.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We're only using two inputs (X and Z), so we certainly could get by with 2D
    inputs instead. However, since we're dealing with position data, I think it's
    better to use full 3D inputs and just leave the Y inputs empty. This way, it's
    easier to later modify the script to allow the user to select any combination
    of X, Y, and Z that they want.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the "X", "Y", and "Z" of the plusMinusAverage node don't have any
    intrinsic meaning; they're just three separate pathways for the calculation, and
    we could certainly use them for things that have nothing to do with position.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'The plusMinusAverage node holds an array for each type of input (one-dimensional,
    two-dimensional, and three-dimensional). So to do anything with it, we''ll need
    to first access the proper array. If we had a plusMinusAverage node named `avgNode`
    and wanted to do something with the second one-dimensional input, we would use
    the following:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'For two- and three-dimensional inputs, we need to specify not only the proper
    array but also the proper entry. For two-dimensional inputs, the array is specified
    as:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'For three-dimensional inputs, the array is specified as:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We don't need to explicitly add inputs to the utility node; we can just use
    connectAttr to connect inputs to successive indices of the node's input 3D array.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we want to run through all of the selected objects except for
    the last one and connect their X and Z positions, which is easy enough:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'At that point, we''re mainly done. All that''s left is to connect the outputs
    of the plusMinusAverage node to the controlled object. Storing the index of the
    controlled object as a variable isn''t necessary, but does make the code a bit
    more readable:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: There's more...
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the discussed example, we created a very simple network, but it's certainly
    possible to create more complex networks. One important thing to bear in mind
    is that, while all the nodes have certain uses that they were created for, in
    no way this limits the kind of use to which they can be put. To Maya, numbers
    are just numbers, and there's nothing to stop you from using color channels to
    control position or rotation to control transparency.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
