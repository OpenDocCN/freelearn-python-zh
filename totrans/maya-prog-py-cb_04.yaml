- en: Chapter 4. Giving Things a Coat of Paint – UVs and Materials
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章. 给事物涂上油漆 – UV和材质
- en: 'In this chapter, we will be looking at topics related to the UV layout and
    shader creation:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨与UV布局和着色器创建相关的主题：
- en: Querying UV data
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询UV数据
- en: Laying out UVs with Python
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Python布局UV
- en: Creating shading networks with code
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用代码创建着色网络
- en: Applying shaders to objects
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将着色器应用到对象上
- en: Using shading nodes for non-rendering tasks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用着色节点进行非渲染任务
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In the previous chapter, we looked at how to manipulate geometry with script.
    However, for most projects, creating the models is only the first step. Unless
    you want everything to look like boring gray plastic, you'll need to layout UVs,
    then create and apply shading networks.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了如何使用脚本操作几何体。然而，对于大多数项目来说，创建模型只是第一步。除非你希望一切看起来都像无聊的灰色塑料，否则你需要布局UV，然后创建并应用着色网络。
- en: In this chapter, we will be looking at how to do just that.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何做到这一点。
- en: Querying UV data
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询UV数据
- en: In this example, we will be looking at how to get information about UVs on a
    polygonal object. We will look at examining how many UV sets the object contains,
    getting the UVs for a given part of the object, and grabbing the position of a
    given UV point.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将探讨如何获取多边形对象上的UV信息。我们将探讨检查对象包含多少UV集，获取对象特定部分的UV，以及获取给定UV点的位置。
- en: We will also look at how to convert one kind of selection to another and use
    that to determine if a given edge can be split or not.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将探讨如何将一种选择转换为另一种选择，并使用它来确定给定的边是否可以分割。
- en: Getting ready
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure that you have a scene that contains at least one polygonal object
    that has UVs—either an object that you have unwrapped or any of the built-in primitive
    shapes, which have UVs by default.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你有包含至少一个具有UV的多边形对象的场景——无论是你解包的对象还是任何默认具有UV的内置基本形状。
- en: How to do it...
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create a new file, name it `uvInfo.py` (or similar), and add the following
    code:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新文件，命名为`uvInfo.py`（或类似），并添加以下代码：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you run the preceding script with a polygonal object selected, you will
    get some information about the object''s UVs, specifically:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行前面的脚本并选择一个多边形对象，你将获得有关对象UV的一些信息，特别是：
- en: How many UVs the object has.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象有多少UV。
- en: The location (in UV space) of the first UV point
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个UV点的位置（在UV空间中）
- en: Whether or not the first edge lies on the border between two separate UV shells.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否第一个边位于两个独立的UV壳之间的边界上。
- en: How it works...
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We start by grabbing the currently selected object and storing it into our `obj`
    variable. Once we have done this, we use the `polyEvaluate` command to determine
    the total number of UVs the object has. This is similar to what we did in the
    previous chapter to find the number of geometric components, but this time around,
    we use the `uvComponent`/`uvc` flag.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先获取当前选定的对象并将其存储到我们的`obj`变量中。一旦我们这样做，我们就使用`polyEvaluate`命令来确定对象拥有的UV总数。这与我们在上一章中找到几何组件数量的方法类似，但这次我们使用`uvComponent`/`uvc`标志。
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next up, we will find the specific position of the first UV point. UVs can
    be accessed in much the same way other polygonal components, but using the "map"
    list instead of the "f" (faces), "e" (edges), or "vtx" (vertices). Therefore,
    if we want to refer to the first UV of an object named `myObject`, we would use
    the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将找到第一个UV点的具体位置。UV可以通过与其它多边形组件相同的方式访问，但使用“map”列表而不是“f”（面）、“e”（边）或“vtx”（顶点）。因此，如果我们想引用名为`myObject`的对象的第一个UV，我们将使用以下方式：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, 0 indicates the first entry in the list and therefore the first UV of
    the object.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，0表示列表中的第一个条目，因此是对象的第一UV。
- en: 'To actually find the specific U and V coordinates of a given UV, we can use
    the `polyEditUV` command in a query mode, as in the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到给定UV的特定U和V坐标，我们可以使用查询模式下的`polyEditUV`命令，如下所示：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next up is determining whether a given edge is internal to a UV shell or if
    it is on the border between two different shells. To do this, we create a function
    that accepts the name of an object and the index of an edge to check:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是确定给定的边是否在UV壳内部，或者它是否位于两个不同壳之间的边界上。为此，我们创建一个函数，该函数接受一个对象名称和要检查的边的索引：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The key thing that we are doing is to see how many vertices and how many UVs
    correspond to the given edge. If the number of vertices is not equal to the number
    of UVs, then that edge must be straddling the border of two different UV shells.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在做的关键事情是查看有多少顶点和UV与给定的边相对应。如果顶点的数量不等于UV的数量，那么这条边必须跨越两个不同的UV壳的边界。
- en: To determine how many vertices/UVs correspond to a given edge, we'll convert
    the edge to the desired component type using the `polyListComponentConversion`
    command. For that to work properly, we will need to specify both what we are converting
    from (in this case, edges), and what we're converting to (either vertices or UVs).
    The way that we do that is a bit odd; instead of specifying the types of each,
    we have to set two Boolean flags to true, one for the source type and one for
    the destination.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定有多少顶点/UV与给定的边相对应，我们将使用`polyListComponentConversion`命令将边转换为所需的组件类型。为了正确执行，我们需要指定我们正在转换的内容（在这种情况下，是边），以及我们正在转换到什么（顶点或UV）。我们这样做的方式有点奇怪；而不是指定每种类型的类型，我们必须将两个布尔标志设置为true，一个用于源类型，一个用于目标类型。
- en: 'For example, if we were to convert the first edge of an object named `myObject`
    to vertices, we would need to do the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们要将名为`myObject`的对象的第一个边转换为顶点，我们需要做以下操作：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Adding in the proper variables to set the name of the object and the index
    of the edge gives us:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 添加适当的变量来设置对象的名称和边的索引，我们得到：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Note that we store the output of the command to a variable named "result".
    This is important because getting an accurate count of the number of points requires
    that we first select the components we want to count. This is easily done in the
    following way:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们将命令的输出存储到名为"result"的变量中。这很重要，因为要获得准确的数量，我们需要首先选择我们想要计数的组件。这可以很容易地按照以下方式完成：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Once we''ve done this, we can use the `polyEvaluate` command with the proper
    flag to give us the number of *currently selected* components. For vertices and
    UVs, we will want to use `vertexComponent` and `uvComponent`, respectively. In
    both cases, we store the result to another variable, as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们这样做，我们就可以使用带有适当标志的`polyEvaluate`命令来给出当前所选组件的数量。对于顶点和UV，我们希望使用`vertexComponent`和`uvComponent`，分别。在两种情况下，我们将结果存储到另一个变量中，如下所示：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'At this point, we have the number of vertices that correspond to the given
    edge. We then do the same operation (but with slightly different flags) to determine
    the number of UVs:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们有了与给定边相对应的顶点数量。然后我们执行相同的操作（但带有略微不同的标志）以确定UV的数量：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, we compare the number of UVs to the number of vertices. If they are
    not the same, then the edge in question must exist on more than one UV shell and,
    as such, represents a border:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将UV的数量与顶点的数量进行比较。如果它们不相同，那么所讨论的边必须存在于多个UV壳上，因此它代表了一个边界：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Back in our main function, we output the results of our various queries with
    a few print statements:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的主函数中，我们使用几个打印语句输出我们各种查询的结果：
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, we will be sure to select the original object once again because we
    selected subcomponents during the `isSplitEdge` function:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将确保再次选择原始对象，因为我们选择了`isSplitEdge`函数期间的子组件：
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Laying out UVs with Python
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python布局UV
- en: In this example, we will look at how to actually lay out UVs using Python. We
    will be applying planar, cylindrical, and spherical projections, each to a different
    subset of the faces of the selected object.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将查看如何使用Python实际布局UV。我们将应用平面、圆柱和球面投影，每个投影到所选对象的不同面集。
- en: Getting ready
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure that you have a scene containing a polygonal object. We will be applying
    three different mappings to different parts of the object (selected by dividing
    the total number of faces by three), so it is best to have an object with at least
    a few dozen faces. If you do not have a model handy, make a polygonal sphere of
    at least 10 or so divisions along both height and axis.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你有一个包含多边形对象的场景。我们将对对象的不同部分应用三种不同的映射（通过将总面数除以三来选择），因此最好有一个至少有几十个面的对象。如果你没有现成的模型，制作一个至少有10个或更多分度的多边形球体。
- en: How to do it...
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a new script and add the following code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的脚本并添加以下代码：
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Run this script with a polygonal object selected and then switch to the UV Texture
    Editor panel to see the results.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 选择多边形对象后运行此脚本，然后切换到UV纹理编辑器面板以查看结果。
- en: How it works...
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The main thing that we are doing here is to apply a new UV layout to a subset
    of the object's faces. This is a somewhat artificial example because we are selecting
    faces by just splitting the total number into thirds.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里主要做的事情是为对象的面子集应用一个新的 UV 布局。这是一个有些人为的例子，因为我们只是通过将总数分成三份来选择面。
- en: 'First off, we grab the currently selected object and determine the total number
    of faces it has using `polyEvaluate`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们获取当前选定的对象，并使用 `polyEvaluate` 确定它有多少个面：
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, we determine what one-third of that number is. Note that Python will
    default to integer division because both `totalFaces` and 3 are whole integer
    values. That happens to be exactly what we need for this application, but can
    easily lead to errors if you are not expecting it:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们确定那个数的三分之一是多少。请注意，Python 默认进行整数除法，因为 `totalFaces` 和 3 都是整数。这恰好是我们在这个应用中需要的，但如果你不期望这种情况，很容易出错：
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If you ever want to ensure that you get a proper decimal value as a result,
    just be sure to divide by a floating-point value, as in:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要确保得到一个正确的十进制值作为结果，只需确保除以一个浮点值即可，如下所示：
- en: '[PRE16]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We also create a couple of helper variables to hold the start and end indices
    for each of the three sets of faces:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了几个辅助变量来保存每三组面开始和结束的索引：
- en: '[PRE17]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'There is nothing particularly hard about what we are doing here though some
    care is needed to ensure that we include the entire range of faces. The values
    that we use are as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做的事情并没有什么特别困难的，尽管需要一些注意以确保包括整个面的范围。我们使用的值如下：
- en: '|   | Start index | End index | Example indices (based on a 100-face object)
    |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '|   | 开始索引 | 结束索引 | 示例索引（基于一个100面的对象） |'
- en: '| --- | --- | --- | --- |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 1st (planar) mapping | 0 | oneThird - 1 | 0-32 |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 1st（平面）映射 | 0 | oneThird - 1 | 0-32 |'
- en: '| 2nd (cylindrical) mapping | oneThird | (oneThird * 2) - 1 | 33-65 |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| 2nd（圆柱）映射 | oneThird | (oneThird * 2) - 1 | 33-65 |'
- en: '| 3rd (spherical) mapping | oneThird * 2 | totalFaces - 1 | 66-99 |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| 3rd（球面）映射 | oneThird * 2 | totalFaces - 1 | 66-99 |'
- en: Now we are ready for the meat of the script—actually, applying mappings. All
    three mapping types (planar, cylindrical, and spherical) are applied using the
    same command, `polyProjection`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好脚本的主体——实际上，应用映射。所有三种映射类型（平面、圆柱和球面）都使用相同的命令 `polyProjection`。
- en: Tip
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'A brief aside on UV mapping—it might seem strange that the three types of mapping
    are planar, cylindrical, and spherical; why those particular shapes and no others?
    The reason for this is that if you think of the surface of the model as a two-dimensional
    skin, then any given part of the model can be classified as belonging to one of
    only three groups:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 UV 映射的简要说明——三种映射类型是平面、圆柱和球面，这可能会显得有些奇怪；为什么是这些特定的形状而不是其他形状呢？原因在于，如果你把模型的表面想象成一个二维的皮肤，那么模型的任何一部分都可以被归类为属于以下三个组之一：
- en: The region doesn't have any significant curvature.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个区域没有任何显著的曲率。
- en: The region has significant curvature in a single direction (horizontal or vertical).
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个区域在单一方向（水平或垂直）上有显著的曲率。
- en: The region has significant curvature in both directions.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个区域在两个方向上都有显著的曲率。
- en: That maps neatly onto the three options of planar (no curve), cylindrical (single-direction
    curve), and spherical (curvature in both directions). While the part you are trying
    to map may be very different from a perfect plane, cylinder, or sphere, start
    by asking yourself how many directions it curves in and select your mapping accordingly.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这完美地映射到平面（无曲线）、圆柱（单方向曲线）和球面（两个方向的曲率）三种选项。虽然你试图映射的部分可能与完美的平面、圆柱或球面非常不同，但首先问问自己它向多少个方向弯曲，然后相应地选择你的映射。
- en: 'There are two things we need to supply to the `polyProjection` command for
    it to work—the specific faces that should receive the mapping and the type of
    mapping to apply. To specify the range of faces, we will want to index into the
    faces or "f" array of the object. We can specify more than one face at a time
    using two indices with a colon in between. For example, if our object was named
    `mySphere`, and we wanted to refer to the first six faces, we could do that with:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要向 `polyProjection` 命令提供两样东西才能使其工作——应该接收映射的具体面以及要应用的映射类型。为了指定面的范围，我们将想要索引到对象的
    `faces` 或 "f" 数组。我们可以使用两个索引并用冒号分隔来指定多个面。例如，如果我们的对象名为 `mySphere`，并且我们想要引用前六个面，我们可以这样做：
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In this case, we''ll want to use the name of the selected object, and the `startFace`
    and `endFace` variables for the indices. Doing this gives us the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们希望使用所选对象的名称以及`startFace`和`endFace`变量作为索引。这样做将给出以下结果：
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now that we have a way to specify the range of faces, we can apply the mappings,
    using the `type` flag to specify which kind of mapping to apply:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经有了指定面范围的方法，我们可以应用映射，使用`type`标志来指定要应用哪种映射：
- en: '[PRE20]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: From here, we just repeat the process with different values for `startFace`
    and `endFace`, and different options for the type flag.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里开始，我们只需要用不同的`startFace`和`endFace`值以及不同的类型标志选项重复这个过程。
- en: There's more...
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'If you want to apply a mapping to the entire object, you might think that you
    just have the name of the object and leave out the face indices. This doesn''t
    work, but there is an easy way to tell Maya that you want to refer to all of the
    faces. To do this, just leave out both indices, but keep the colon, as in:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要将映射应用于整个对象，你可能认为你只需要对象的名称并省略面索引。这不起作用，但有一个简单的方法可以告诉Maya你想要引用所有面。为此，只需省略两个索引，但保留冒号，如下所示：
- en: '[PRE21]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If the starter index is missing, Maya will substitute 0, and if the ending index
    is missing, Maya will substitute the maximum index. Leaving *both* out will result
    in the mapping being applied to the entire object.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果缺少起始索引，Maya将用0替换，如果缺少结束索引，Maya将用最大索引替换。如果两个都省略，则映射将应用于整个对象。
- en: So far, we've only looked at selecting contiguous sequences of faces, but there
    are lots of situations where you might want to select faces that aren't consecutive
    indices. You can do that by having multiple selections separated by commas as
    first argument(s) to a function.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只看了选择连续的面序列，但有很多情况下你可能想要选择非连续索引的面。你可以通过将多个选择用逗号分隔作为函数的第一个参数（或多个参数）来实现这一点。
- en: 'For example, let us say that we wanted to select the first 5 faces *and* faces
    32 through 76 of `myObject`. We could use the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们想要选择`myObject`的前5个面以及32到76的面。我们可以使用以下命令：
- en: '[PRE22]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Applying this to UV mapping would give us something like the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 将此应用于UV映射将给出以下类似的结果：
- en: '[PRE23]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'When working with ranges of faces, it''s very common that you''ll determine
    the specific indices at runtime, either through some kind of calculation or based
    on a user input. It''s easy enough to do, but can lead to overly complex sequences
    of stick together string literals and variables, such as the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理面范围时，在运行时确定特定索引是非常常见的，无论是通过某种计算还是基于用户输入。这很容易做到，但可能导致过于复杂的字符串字面量和变量的序列，如下所示：
- en: '[PRE24]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: It's also very easy to forget to convert numerical values to strings with the
    `str()` command, which can lead to errors. Luckily enough, Python provides an
    alternative way to deal with building formatted strings from variables in the
    form of the `format` command.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易忘记使用`str()`命令将数值转换为字符串，这可能导致错误。幸运的是，Python提供了一个以`format`命令的形式处理从变量构建格式化字符串的替代方法。
- en: To use the format command, you create a string with sections you want to replace
    with variables. Each replaceable section is represented with curly brackets containing
    a number such as `{0}`. You can then call the format command on that string and
    pass in variables that will replace the `{}` clauses. The numbers are used to
    specify which variables should go where ("{0}" means "replace with the first variable",
    for example).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用格式命令，你创建一个包含你想要用变量替换的部分的字符串。每个可替换的部分都用包含数字的括号表示，例如`{0}`。然后你可以调用该字符串上的格式命令，并传入将替换`{}`子句的变量。数字用于指定哪些变量应该放在哪里（例如，“{0}”表示“用第一个变量替换”）。
- en: 'So, as a really simple example, we could wish someone happy birthday with the
    following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，作为一个非常简单的例子，我们可以用以下方式祝人生日快乐：
- en: '[PRE25]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Turning back to Maya, let''s say that we wanted to have a generic way to select
    a range of faces. We would want to pass in the name of the object, the start index,
    and the ending index as variables. We could do this with:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 回到Maya，假设我们想要有一个选择面范围的一般方法。我们希望传入对象的名称、起始索引和结束索引作为变量。我们可以这样做：
- en: '[PRE26]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This would work just fine, but is a bit hard to read and is an easy way to
    introduce errors. If we were to rewrite that using the format command, we would
    have something like this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这将正常工作，但有点难以阅读，并且是引入错误的一种简单方法。如果我们使用格式命令重写它，我们会得到如下所示的内容：
- en: '[PRE27]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This tends to be a lot easier to think through because it allows you to separate
    the structure (the string) from the variables that should be slotted into it.
    You certainly don't have to use format, but as Maya scripting very often requires
    building up strings from variables in this way, using it will likely save you
    a lot of headaches. It also makes your code a lot more readable.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常更容易思考，因为它允许你将结构（字符串）与应该填充到其中的变量分开。你当然不必使用格式，但鉴于Maya脚本经常需要以这种方式从变量中构建字符串，使用它可能会节省你很多麻烦。它还使你的代码更容易阅读。
- en: See also
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The official Python documentation for the format command is a bit hard to wade
    through and presents the information in an overly opaque way. Instead, I highly
    recommend having a look at [https://pyformat.info/](https://pyformat.info/), for
    a detailed, yet highly readable explanation of the intricacies of the format command.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 格式命令的官方Python文档有点难以理解，并且以过于晦涩的方式呈现信息。相反，我强烈建议您查看[https://pyformat.info/](https://pyformat.info/)，那里有对格式命令复杂性的详细且易于阅读的解释。
- en: Creating shading networks with code
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用代码创建着色网络
- en: In this example, we'll be looking at how to create shading networks with code.
    We'll be creating a simple toon shader, with a solid color in the interior and
    a different color at the edges of the object. There are a few different ways to
    do this, including by creating a rampShader, but we'll be doing it in the somewhat
    old-fashioned way using a samplerInfo node, as it provides a great example of
    a relatively simple yet somewhat novel shading network.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将探讨如何使用代码创建着色网络。我们将创建一个简单的卡通着色器，内部为纯色，而物体的边缘为不同的颜色。有几种不同的方法可以做到这一点，包括创建渐变着色器，但我们将以相对老式的方式使用`samplerInfo`节点，因为它提供了一个相对简单但相对新颖的着色网络的绝佳示例。
- en: First off, let's have a look at what our shader will do and how it will do it.
    The key characteristic of a toon shader is that the object has an outline around
    its edges that changes as the object moves. So, the first thing we'll need is
    some way of knowing what the angle is between a given part of the model and the
    camera. Luckily, Maya provides a utility node that does just that in the form
    of samplerInfo. SamplerInfo nodes provide us with a `facingRatio` attribute that
    ranges from 0 (when a surface is perpendicular to the camera) to 1 (when a surface
    is facing directly at the camera).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看我们的着色器将做什么以及它是如何做到的。卡通着色器的关键特性是物体边缘有一个轮廓，随着物体的移动而改变。因此，我们首先需要知道模型的一部分与相机之间的角度。幸运的是，Maya提供了一个名为`samplerInfo`的实用节点，它正好可以做到这一点。`SamplerInfo`节点为我们提供了一个`facingRatio`属性，其范围从0（当表面垂直于相机时）到1（当表面直接面向相机时）。
- en: Once we have the facing ratio, we'll need to tie it to a color change somehow.
    The easiest and most flexible way to do this is to use a ramp texture with linear
    interpolation to provide a sharp cutoff between the border and interior colors.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们得到了面对比，就需要以某种方式将其与颜色变化联系起来。最简单且最灵活的方法是使用具有线性插值的渐变纹理，以在边框颜色和内部颜色之间提供清晰的截止。
- en: 'Putting all that together gives us a relatively simple, three-node shading
    network similar to the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些组合起来，我们得到了一个相对简单的、由三个节点组成的着色网络，类似于以下内容：
- en: '![Creating shading networks with code](img/4657_04_01.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![使用代码创建着色网络](img/4657_04_01.jpg)'
- en: How to do it...
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create a new script and add the following code:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的脚本并添加以下代码：
- en: '[PRE28]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If you run the script, you should see a new shader appear in the hypershade,
    consisting of a red interior and a black exterior edge.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行脚本，你应该在hypershade中看到一个新着色器出现，内部为红色，外部边缘为黑色。
- en: How it works...
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: There are three parts of the script—creating the nodes, setting their attributes,
    and connecting them to each other.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本分为三个部分——创建节点、设置它们的属性以及将它们相互连接。
- en: 'First off, we create the three nodes we need with the `shadingNode` command:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用`shadingNode`命令创建所需的三个节点：
- en: '[PRE29]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The first thing to note is that the shadingNode command is used for all three
    nodes we create even though they''re three different types (one shader, one texture,
    and one utility). In all cases, you get the results you want by specifying the
    specific kind of node that you want to create (`''blinn''`, for example) and also
    including one of the following flags set to True: `asShader`, `asTexture`, `asUtility`,
    `asPosProcess`, `asRendering`, `asLight`.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是，尽管我们创建了三个不同类型的节点（一个着色器、一个纹理和一个工具），但仍然使用`shadingNode`命令。在所有情况下，通过指定你想要创建的特定类型的节点（例如`'blinn'`）以及包括以下标志之一设置为True：`asShader`、`asTexture`、`asUtility`、`asPosProcess`、`asRendering`、`asLight`，你都可以得到你想要的结果。
- en: Leaving out those flags will result in an error. If you include the wrong flag
    (asTexture=True when creating a Blinn shader, for example), the command will still
    work, but I don't recommend it.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果省略这些标志，将会导致错误。如果你包含了错误的标志（例如在创建Blinn着色器时`asTexture=True`），命令仍然会工作，但我不建议这样做。
- en: Creating the nodes is pretty straightforward—just make sure that you also save
    the output to a variable (as we've done here) so that you can later set their
    attributes and connect them.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 创建节点相当直接——只需确保你也将输出保存到一个变量中（就像我们在这里所做的那样），这样你就可以稍后设置它们的属性并将它们连接起来。
- en: 'Once we have all of our nodes created, we need to set their attributes. In
    this case, we need to do the following few different things that are applied to
    the ramp texture:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了所有节点，我们需要设置它们的属性。在这种情况下，我们需要对渐变纹理执行以下几项不同的操作：
- en: Ensure that the color interpolation is set to linear to give us nice sharp transitions
    between colors, rather than smooth gradients.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保颜色插值设置为线性，以便在颜色之间提供清晰的过渡，而不是平滑的渐变。
- en: Make sure that the color swatches are positioned correctly along the length
    of the ramp.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保颜色样本在渐变的长度上正确定位。
- en: Set both the colors to have the edge color and the interior color that we want.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将两种颜色都设置为边缘颜色和我们想要的内部颜色。
- en: 'For all of the above, we''ll use the `setAttr` command. The `setAttr` command
    expects the name of the attribute to set as the first argument, followed by the
    value to which it should be set. For single value, numeric values, that''s pretty
    straightforward. For example, the following sets the ramp''s interpolation to
    none:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 对于上述所有内容，我们将使用`setAttr`命令。`setAttr`命令期望第一个参数是要设置的属性的名称，后面跟着应该设置的值。对于单个数值，这相当直接。例如，以下将渐变的插值设置为无：
- en: '[PRE30]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Although the type of interpolation isn't actually a numerical value, it's a
    common practice in Maya (and other places) to use integers to represent various
    options. When setting attribute values that are represented in the interface by
    a drop-down menu, you'll generally want to use an integer, with the specific value
    corresponding to the position of the option in the list (with 0 being the first
    one).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然插值的类型实际上不是一个数值，但在Maya（和其他地方）中，使用整数来表示各种选项是一种常见的做法。当设置在界面中以下拉菜单表示的属性值时，你通常会想要使用一个整数，其具体值对应于列表中选项的位置（其中0是第一个）。
- en: Next, we'll want to set the colors of the ramp texture to have the correct positions
    and colors. The first thing to understand is that ramp textures maintain an array
    of nodes, contained in their `colorEntryList` attribute. Each entry in that list
    represents a stop in the ramp texture and has both a position and a color.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要设置渐变纹理的颜色，使其具有正确的位置和颜色。首先需要理解的是，渐变纹理维护一个节点数组，这些节点包含在其`colorEntryList`属性中。该列表中的每个条目代表渐变纹理中的一个停止点，并具有位置和颜色。
- en: 'We''ll want to make sure that the first entry is at the very beginning of the
    ramp, and the second entry is slightly less than halfway along it, as it gives
    us a good default edge thickness for the shader. We do this using setAttr to set
    the position of the first two entries in the `colorEntryList` array, as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要确保第一个条目位于渐变的非常开始处，第二个条目位于中间略低的位置，因为它为我们提供了着色器的好默认边缘厚度。我们使用`setAttr`来设置`colorEntryList`数组中前两个条目的位置，如下所示：
- en: '[PRE31]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Next, we'll want to set the colors. That's a bit different, in that we need
    to feed three separate values into the `setAttr` command (one each for red, green,
    and blue). To do this, we'll need to provide all three numbers, and we'll also
    need to tell Maya to expect multiple inputs to the `setAttr` command by using
    the `type` flag.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将想要设置颜色。这有点不同，因为我们需要将三个单独的值输入到 `setAttr` 命令中（每个分别用于红色、绿色和蓝色）。为此，我们需要提供所有三个数字，并且我们还需要告诉
    Maya 通过使用 `type` 标志来期望 `setAttr` 命令有多个输入。
- en: 'The `setAttr` command is one of the most powerful and most flexible commands
    that Maya offers. It can be used to alter any value of any node. All that power
    requires the command be able to accept various kinds of inputs, all specified
    with the type flag. In this case, we need a format that supports decimal values
    (since colors are represented as number from 0 to 1), and that supports three
    separate values. Either `float3` or `double3` will work. Putting that all together
    gives us the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`setAttr` 命令是 Maya 提供的最强大和最灵活的命令之一。它可以用来改变任何节点的任何值。所有这些功能都需要命令能够接受各种类型的输入，所有这些输入都通过类型标志指定。在这种情况下，我们需要一个支持十进制值的格式（因为颜色是以从
    0 到 1 的数字表示的），并且支持三个单独的值。`float3` 或 `double3` 都可以工作。将这些全部组合起来，我们得到以下内容：'
- en: '[PRE32]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: At this point, we've set all of the attribute values that we need for the shader.
    All that's left is to connect the nodes to each other. We do it with the `connectAttr`
    command. That's fairly straightforward and just requires that we specify first
    the source attribute, then the destination.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经设置了着色器所需的全部属性值。剩下要做的就是将节点连接起来。我们使用 `connectAttr` 命令来完成这个操作。这相当直接，只需要我们首先指定源属性，然后指定目标。
- en: 'In this case, we want to make two connections:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们想要建立两个连接：
- en: The `facingRatio` attribute of the samplerInfo to the V coordinate of the ramp
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 样本信息中的 `facingRatio` 属性与漫射的 V 坐标
- en: The `outColor` of the ramp texture to the color of the shader
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 漫射纹理的 `outColor` 与着色器的颜色
- en: 'Doing this ends up looking like:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 做这件事的结果看起来像：
- en: '[PRE33]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: There's more...
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Creating nodes and connecting their attributes is a great way to approach a
    wide range of tasks in Maya, but it can sometimes be tedious. For example, if
    we wanted to create a `place2dTexture` utility node and connect it to a texture
    node, we would have to make over a dozen connections, which is tedious, to say
    the least. Luckily, Maya provides an easy shortcut to create nodes with the default
    behavior in the form of the `defaultNavigation` command.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 创建节点并将它们的属性连接起来是处理 Maya 中各种任务的好方法，但有时可能会很繁琐。例如，如果我们想要创建一个 `place2dTexture` 工具节点并将其连接到纹理节点，我们可能需要做出十多个连接，这至少是繁琐的。幸运的是，Maya
    提供了一个简单的快捷方式来创建具有默认行为的节点，即 `defaultNavigation` 命令。
- en: 'Here''s what that would look like:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来会是这样：
- en: '[PRE34]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note the inclusion of the `connectToExisting=True` to indicate that the nodes
    being connected are already present in the scene. Much nicer than 18 separate
    calls to `connectAttr`, indeed.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 注意包含 `connectToExisting=True` 以指示要连接的节点已经在场景中存在。这确实比 18 个单独的 `connectAttr` 调用要优雅得多。
- en: 'You can also break connections between nodes with Python with the `disconnectAttr`
    command. For example, if we wanted the previously mentioned two-node network of
    a place2dTexture and a file texture to share everything `except` the offset attribute,
    we could do the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 Python 的 `disconnectAttr` 命令断开节点之间的连接。例如，如果我们想要之前提到的由 place2dTexture
    和文件纹理组成的两个节点网络共享除偏移属性之外的所有内容，我们可以这样做：
- en: '[PRE35]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Sometimes, it might be faster to connect two nodes with the default connections
    (with defaultNavigation) and break a few specific connections you don't want,
    instead of manually creating all the connections you do want.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，使用默认连接（带有 defaultNavigation）连接两个节点可能会更快，而不是手动创建所有你想要的连接，同时断开一些你不想保留的特定连接。
- en: See also
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Be sure to refer to the built-in documentation for the `setAttr` command for
    a complete list of the types of inputs it can accept. The documentation is a bit
    dense, but it's definitely worth a look.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 一定要参考 `setAttr` 命令的内置文档，以获取它可以接受的输入类型的完整列表。文档有点密集，但绝对值得一看。
- en: Applying shaders to objects
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将着色器应用到对象上
- en: Once you have a shading network created, you'll generally want to apply it to
    one or more objects. In this example, we'll be looking at how to do it. Along
    the way, we'll create a script that can be used to apply a shader to all of the
    objects in the scene that are without one.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了一个着色网络，你通常会想要将其应用到一个或多个对象上。在这个例子中，我们将探讨如何实现这一点。在这个过程中，我们将创建一个脚本，可以用来将着色器应用到场景中所有没有着色器的对象上。
- en: Getting ready
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure that you have a scene with a few different objects in it. Select a
    few objects and apply a shader to them in the normal way, using the hypershade's
    interface. Delete the shader, leaving at least one object without any shader of
    any kind.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你有一个包含几个不同对象的场景。选择几个对象，并使用hypershade的界面以正常方式将着色器应用到它们上。删除着色器，至少留下一个没有任何类型着色器的对象。
- en: How to do it...
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Create a new script and add the following code:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的脚本并添加以下代码：
- en: '[PRE36]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Run the script, and you should see any and all of the objects that were previously
    without a shader sporting a brand new, cyan-colored blinn shader.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本，你应该会看到任何之前没有着色器的对象都添加了一个全新的、青色的blinn着色器。
- en: How it works...
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The script works by:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本通过以下方式工作：
- en: Getting a list of all the objects in the scene.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取场景中所有对象的列表。
- en: Running through the list and checking whether a given node is geometry.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历列表并检查给定的节点是否为几何形状。
- en: For any geometric node, find the shaders applied to it.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于任何几何节点，找到应用在其上的着色器。
- en: If a given object has no shaders, add it to a list of non-shaded objects.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果给定的对象没有着色器，将其添加到非着色器对象列表中。
- en: Create a new shader to apply.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的着色器以应用。
- en: Apply the shader to the shader-less objects.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将着色器应用到没有着色器的对象上。
- en: This script makes use of the `hyperShade` command in a couple of different ways—to
    find the shaders attached to an object, the objects attached to a shader, and
    to apply a shader.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本利用`hyperShade`命令的几种不同方式——用于查找附加到对象上的着色器、附加到着色器上的对象，以及应用着色器。
- en: 'First, let''s look at how to grab the shaders for a given object. To make things
    easier on ourselves later, we''ll create a function to do it. We have the following
    code:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看如何获取给定对象的着色器。为了简化后续操作，我们将创建一个函数来完成这个任务。我们有以下代码：
- en: '[PRE37]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The main thing that we're doing is to use the hyperShade command with the `shaderNetworksSelectMaterialNodes`
    (or just `smn`) flag set to true. That will select the shader (or shaders) of
    the currently selected objects. Because the command works on selections, we have
    to make sure that the object (or objects) we want to know about are selected before
    we run it. Once we've run it, we'll need to examine the currently selected nodes
    to get the list of shaders.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们主要使用的是带有`shaderNetworksSelectMaterialNodes`（或简称`smn`）标志设置为true的hyperShade命令。这将选择当前选中对象的着色器（或着色器）。因为该命令在选区上工作，我们必须确保在我们运行它之前，我们想要了解的对象（或对象）已被选中。一旦我们运行了它，我们需要检查当前选中的节点以获取着色器的列表。
- en: 'Next, we create a function to easily tell if a given transform node corresponds
    to actual geometry. We need it because we''re going to iterate over all the transforms
    in the scene, and there are many things (lights, cameras, and so on) that have
    transforms but that aren''t geometry. We accept the name of the node as an input
    and find the corresponding shape node:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个函数，以便轻松判断给定的变换节点是否对应实际几何形状。我们需要它，因为我们将要遍历场景中的所有变换，而且有许多事物（灯光、相机等等）具有变换但不是几何形状。我们将节点的名称作为输入，并找到相应的形状节点：
- en: '[PRE38]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Then, we examine the shape node to find what kind of object it is:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们检查形状节点以确定它是什么类型的对象：
- en: '[PRE39]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note that the `listRelatives` command returns an array, so we need to index
    into that and grab the first element. It's unlikely that an object would have
    multiple shape nodes, but `listRelatives` can also be used to find an object's
    children, which will often be multiple nodes. Since it can sometimes result in
    multiples, the command therefore always returns an array even if there's only
    a single item.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`listRelatives`命令返回一个数组，因此我们需要索引到那里并获取第一个元素。一个对象不太可能有多个形状节点，但`listRelatives`也可以用来查找对象的孩子，这些孩子通常会是多个节点。由于有时会导致多个节点，因此即使只有一个项目，该命令也总是返回一个数组。
- en: 'Each of the three types of geometry in Maya (polygon, NURBS, and subdivision
    surfaces) has its own corresponding shape node. For the sake of convenience and
    code readability, we''ll create an array of those types and check the current
    shape node''s type against it:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Maya中的三种几何类型（多边形、NURBS和细分曲面）各自对应一个形状节点。为了方便和代码可读性，我们将创建一个包含这些类型的数组，并检查当前形状节点的类型是否与之匹配：
- en: '[PRE40]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'At this point, we''re ready to jump into the real meat of the script. We start
    by grabbing a list of all of the transforms in the scene using the `ls` command.
    So far, we''ve mainly used that to find what''s currently selected, but it can
    also be used to grab all the nodes of a specific type (selected or not):'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经准备好跳入脚本的真正核心部分。我们首先使用`ls`命令获取场景中所有变换的列表。到目前为止，我们主要使用它来找到当前选定的内容，但它也可以用来获取特定类型（无论是否选中）的所有节点：
- en: '[PRE41]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Then, we create an empty list to which we''ll add any object that we find to
    be lacking a shader and start running through the list of transforms. First, we
    check to make sure that the node in question is geometry of some kind. If that''s
    the case, we use our `shadersFromObject` function to find the shader(s) applied
    to the object. Once we''ve done this, we check the length of the returned list-
    if it''s zero, then the object had no shaders, and we add it to our list:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个空列表，我们将把任何我们发现缺少着色器的对象添加到这个列表中，并开始遍历这个变换列表。首先，我们检查以确保所讨论的节点是某种几何形状。如果是这样，我们使用我们的`shadersFromObject`函数来找到应用于该对象的着色器。一旦我们完成这个操作，我们就检查返回列表的长度——如果它是零，那么该对象没有着色器，我们就将其添加到我们的列表中：
- en: '[PRE42]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'At this point, the `unShaded` list contains all of the objects in the scene
    that lack shaders. We create a new shader, a simple blinn, and set its color to
    cyan:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，`unShaded`列表包含了场景中所有缺少着色器的对象。我们创建一个新的着色器，一个简单的Blinn，并将其颜色设置为青色：
- en: '[PRE43]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Finally, we select the contents of the `unShaded` list and apply the shader
    we just made. For that, we''ll use the `hyperShade` command again, but this time
    with the assign flag to apply the specified shader to the currently selected objects.
    We have the following code:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们选择`unShaded`列表的内容，并应用我们刚刚创建的着色器。为此，我们将再次使用`hyperShade`命令，但这次使用分配标志将指定的着色器应用到当前选定的对象上。我们有以下代码：
- en: '[PRE44]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: There's more...
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `hyperShade` command can be used to do most of the tasks one would normally
    accomplish in the hypershade panel interface. In the previous example, we grabbed
    shaders from objects, but the command can also be used to find the objects associated
    with a given shader with the `objects` flag. Wrapping that up in a nice function
    to return the objects for a given shader would look something like the following:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`hyperShade`命令可以用来完成在hypershade面板界面中通常可以完成的许多任务。在上一个例子中，我们从对象中获取了着色器，但该命令也可以使用`objects`标志来找到与给定着色器关联的对象。将这个功能封装在一个漂亮的函数中，以返回给定着色器的对象，看起来可能如下所示：'
- en: '[PRE45]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Once again, the `hyperShade` changes the current selection, and we use the `ls`
    command to retrieve the selection as an array.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，`hyperShade`改变了当前的选择，我们使用`ls`命令来检索选择作为一个数组。
- en: Using shading nodes for non-shading tasks
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用着色节点进行非着色任务
- en: One of the really great things about the various nodes that Maya provides is
    that there are very few limits on how you use them. To Maya, all nodes are just
    collections of functionality with certain inputs and outputs, and as long as the
    type of data lines up, it doesn't really care how you connect them.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Maya提供的各种节点中真正出色的一点是，在使用它们时几乎没有限制。对Maya来说，所有节点只是具有某些输入和输出的功能集合，只要数据类型匹配，它实际上并不关心你如何连接它们。
- en: This means that it's completely possible (and often very useful) to use hypershade
    nodes for tasks that aren't related to creating shading networks. In this example,
    we'll be doing just that using a plus/minus/average utility node to set the position
    of a given object to the average position of a number of others. This could be
    used, for example, to ensure that the pelvis of a character always stays centered
    in between the IK handles controlling its feet.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，完全有可能（并且通常非常有用）使用hypershade节点来完成与创建着色网络无关的任务。在这个例子中，我们将使用加减平均实用节点来设置给定对象的位置为多个其他对象的平均位置。例如，这可以用来确保角色的骨盆始终保持在控制其脚的IK手柄之间。
- en: Using utility nodes can be used for tasks where you might otherwise write an
    expression, but with the added benefit that they update constantly, not just while
    the playback head is moving.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 使用工具节点可以用于你可能需要编写表达式的任务，但它们的好处是它们会不断更新，而不仅仅是当播放头移动时。
- en: Getting ready
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Be sure that you have a scene with at least three objects in it.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你的场景中至少有三个对象。
- en: How to do it...
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create a new script and add the following code:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的脚本并添加以下代码：
- en: '[PRE46]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Select at least three objects, making sure that the object you want to be controlled
    is the last one selected, and run the script. Once you've done that, try moving
    the objects around, and you'll see that the X and Z position of the controlled
    object is always an average of the X and Z positions of all the other objects.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 选择至少三个对象，确保你想要控制的对象是最后一个选中的，然后运行脚本。一旦你这样做，尝试移动对象，你会发现控制对象的X和Z位置总是所有其他对象的X和Z位置的平均值。
- en: How it works...
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'First off, we check to make sure that there are at least three objects selected
    and error out if there isn''t:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查确保至少有三个对象被选中，如果没有则报错：
- en: '[PRE47]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If we have at least three objects, we proceed to create a brand new utility
    node, in this case a plus/minus/average node. Since the plus/minus/average node
    can perform three completely separate actions, we also need to set its "operation"
    attribute to average (which happens to be the fourth option in the corresponding
    dropdown, so has a value of 3), as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有至少三个对象，我们就继续创建一个新的工具节点，在这种情况下是一个加减平均节点。由于加减平均节点可以执行三个完全不同的操作，我们还需要将其“操作”属性设置为平均（这恰好是相应下拉菜单中的第四个选项，因此其值为3），如下所示：
- en: '[PRE48]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Once we've done this, we run through the list of selected objects and connect
    all but the last one to the utility node as inputs. PlusMinusAverage nodes can
    have one-dimensional, two-dimensional, or three-dimensional inputs. In this case,
    we'll use 3D inputs.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们这样做，我们就遍历所选对象的列表，并将除了最后一个之外的所有对象连接到工具节点作为输入。加减平均节点可以有一维、二维或三维输入。在这种情况下，我们将使用三维输入。
- en: Tip
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: We're only using two inputs (X and Z), so we certainly could get by with 2D
    inputs instead. However, since we're dealing with position data, I think it's
    better to use full 3D inputs and just leave the Y inputs empty. This way, it's
    easier to later modify the script to allow the user to select any combination
    of X, Y, and Z that they want.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只使用两个输入（X和Z），所以我们当然可以用二维输入来应付。然而，由于我们处理的是位置数据，我认为使用完整的3D输入并留空Y输入更好。这样，以后修改脚本以允许用户选择他们想要的任何X、Y和Z的组合会更容易。
- en: Of course, the "X", "Y", and "Z" of the plusMinusAverage node don't have any
    intrinsic meaning; they're just three separate pathways for the calculation, and
    we could certainly use them for things that have nothing to do with position.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，加减平均节点的“X”、“Y”和“Z”没有任何内在含义；它们只是计算的三条独立路径，我们当然可以用它们来做与位置无关的事情。
- en: 'The plusMinusAverage node holds an array for each type of input (one-dimensional,
    two-dimensional, and three-dimensional). So to do anything with it, we''ll need
    to first access the proper array. If we had a plusMinusAverage node named `avgNode`
    and wanted to do something with the second one-dimensional input, we would use
    the following:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 加减平均节点为每种类型的输入（一维、二维和三维）保留一个数组。因此，要使用它，我们首先需要访问正确的数组。如果我们有一个名为`avgNode`的加减平均节点并想对第二个一维输入进行操作，我们将使用以下方法：
- en: '[PRE49]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'For two- and three-dimensional inputs, we need to specify not only the proper
    array but also the proper entry. For two-dimensional inputs, the array is specified
    as:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 对于二维和三维输入，我们需要指定不仅正确的数组，还要指定正确的条目。对于二维输入，数组指定如下：
- en: '[PRE50]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'For three-dimensional inputs, the array is specified as:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 对于三维输入，数组指定如下：
- en: '[PRE51]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We don't need to explicitly add inputs to the utility node; we can just use
    connectAttr to connect inputs to successive indices of the node's input 3D array.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要明确地将输入添加到工具节点中；我们可以直接使用connectAttr将输入连接到节点的输入3D数组的连续索引。
- en: 'In this case, we want to run through all of the selected objects except for
    the last one and connect their X and Z positions, which is easy enough:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们想要遍历所有选定的对象（除了最后一个），并将它们的X和Z位置连接起来，这很容易做到：
- en: '[PRE52]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'At that point, we''re mainly done. All that''s left is to connect the outputs
    of the plusMinusAverage node to the controlled object. Storing the index of the
    controlled object as a variable isn''t necessary, but does make the code a bit
    more readable:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 到那时，我们基本上就完成了。剩下要做的就是将plusMinusAverage节点的输出连接到受控对象上。将受控对象的索引存储为变量不是必要的，但这会使代码更易于阅读：
- en: '[PRE53]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: There's more...
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In the discussed example, we created a very simple network, but it's certainly
    possible to create more complex networks. One important thing to bear in mind
    is that, while all the nodes have certain uses that they were created for, in
    no way this limits the kind of use to which they can be put. To Maya, numbers
    are just numbers, and there's nothing to stop you from using color channels to
    control position or rotation to control transparency.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论的例子中，我们创建了一个非常简单的网络，但当然可以创建更复杂的网络。需要记住的一个重要事情是，尽管所有节点都有它们被创建时的特定用途，但这绝不限制它们可以被用于何种类型的用途。对玛雅来说，数字只是数字，没有任何东西阻止你使用颜色通道来控制位置或使用旋转来控制透明度。
