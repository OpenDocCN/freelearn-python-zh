- en: Chapter 4. Giving Things a Coat of Paint – UVs and Materials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will be looking at topics related to the UV layout and
    shader creation:'
  prefs: []
  type: TYPE_NORMAL
- en: Querying UV data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Laying out UVs with Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating shading networks with code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying shaders to objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using shading nodes for non-rendering tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we looked at how to manipulate geometry with script.
    However, for most projects, creating the models is only the first step. Unless
    you want everything to look like boring gray plastic, you'll need to layout UVs,
    then create and apply shading networks.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will be looking at how to do just that.
  prefs: []
  type: TYPE_NORMAL
- en: Querying UV data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we will be looking at how to get information about UVs on a
    polygonal object. We will look at examining how many UV sets the object contains,
    getting the UVs for a given part of the object, and grabbing the position of a
    given UV point.
  prefs: []
  type: TYPE_NORMAL
- en: We will also look at how to convert one kind of selection to another and use
    that to determine if a given edge can be split or not.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure that you have a scene that contains at least one polygonal object
    that has UVs—either an object that you have unwrapped or any of the built-in primitive
    shapes, which have UVs by default.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new file, name it `uvInfo.py` (or similar), and add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the preceding script with a polygonal object selected, you will
    get some information about the object''s UVs, specifically:'
  prefs: []
  type: TYPE_NORMAL
- en: How many UVs the object has.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The location (in UV space) of the first UV point
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether or not the first edge lies on the border between two separate UV shells.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We start by grabbing the currently selected object and storing it into our `obj`
    variable. Once we have done this, we use the `polyEvaluate` command to determine
    the total number of UVs the object has. This is similar to what we did in the
    previous chapter to find the number of geometric components, but this time around,
    we use the `uvComponent`/`uvc` flag.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up, we will find the specific position of the first UV point. UVs can
    be accessed in much the same way other polygonal components, but using the "map"
    list instead of the "f" (faces), "e" (edges), or "vtx" (vertices). Therefore,
    if we want to refer to the first UV of an object named `myObject`, we would use
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, 0 indicates the first entry in the list and therefore the first UV of
    the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'To actually find the specific U and V coordinates of a given UV, we can use
    the `polyEditUV` command in a query mode, as in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up is determining whether a given edge is internal to a UV shell or if
    it is on the border between two different shells. To do this, we create a function
    that accepts the name of an object and the index of an edge to check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The key thing that we are doing is to see how many vertices and how many UVs
    correspond to the given edge. If the number of vertices is not equal to the number
    of UVs, then that edge must be straddling the border of two different UV shells.
  prefs: []
  type: TYPE_NORMAL
- en: To determine how many vertices/UVs correspond to a given edge, we'll convert
    the edge to the desired component type using the `polyListComponentConversion`
    command. For that to work properly, we will need to specify both what we are converting
    from (in this case, edges), and what we're converting to (either vertices or UVs).
    The way that we do that is a bit odd; instead of specifying the types of each,
    we have to set two Boolean flags to true, one for the source type and one for
    the destination.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we were to convert the first edge of an object named `myObject`
    to vertices, we would need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding in the proper variables to set the name of the object and the index
    of the edge gives us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we store the output of the command to a variable named "result".
    This is important because getting an accurate count of the number of points requires
    that we first select the components we want to count. This is easily done in the
    following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we''ve done this, we can use the `polyEvaluate` command with the proper
    flag to give us the number of *currently selected* components. For vertices and
    UVs, we will want to use `vertexComponent` and `uvComponent`, respectively. In
    both cases, we store the result to another variable, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we have the number of vertices that correspond to the given
    edge. We then do the same operation (but with slightly different flags) to determine
    the number of UVs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we compare the number of UVs to the number of vertices. If they are
    not the same, then the edge in question must exist on more than one UV shell and,
    as such, represents a border:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Back in our main function, we output the results of our various queries with
    a few print statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will be sure to select the original object once again because we
    selected subcomponents during the `isSplitEdge` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Laying out UVs with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we will look at how to actually lay out UVs using Python. We
    will be applying planar, cylindrical, and spherical projections, each to a different
    subset of the faces of the selected object.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure that you have a scene containing a polygonal object. We will be applying
    three different mappings to different parts of the object (selected by dividing
    the total number of faces by three), so it is best to have an object with at least
    a few dozen faces. If you do not have a model handy, make a polygonal sphere of
    at least 10 or so divisions along both height and axis.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new script and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Run this script with a polygonal object selected and then switch to the UV Texture
    Editor panel to see the results.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main thing that we are doing here is to apply a new UV layout to a subset
    of the object's faces. This is a somewhat artificial example because we are selecting
    faces by just splitting the total number into thirds.
  prefs: []
  type: TYPE_NORMAL
- en: 'First off, we grab the currently selected object and determine the total number
    of faces it has using `polyEvaluate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we determine what one-third of that number is. Note that Python will
    default to integer division because both `totalFaces` and 3 are whole integer
    values. That happens to be exactly what we need for this application, but can
    easily lead to errors if you are not expecting it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If you ever want to ensure that you get a proper decimal value as a result,
    just be sure to divide by a floating-point value, as in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We also create a couple of helper variables to hold the start and end indices
    for each of the three sets of faces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'There is nothing particularly hard about what we are doing here though some
    care is needed to ensure that we include the entire range of faces. The values
    that we use are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '|   | Start index | End index | Example indices (based on a 100-face object)
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1st (planar) mapping | 0 | oneThird - 1 | 0-32 |'
  prefs: []
  type: TYPE_TB
- en: '| 2nd (cylindrical) mapping | oneThird | (oneThird * 2) - 1 | 33-65 |'
  prefs: []
  type: TYPE_TB
- en: '| 3rd (spherical) mapping | oneThird * 2 | totalFaces - 1 | 66-99 |'
  prefs: []
  type: TYPE_TB
- en: Now we are ready for the meat of the script—actually, applying mappings. All
    three mapping types (planar, cylindrical, and spherical) are applied using the
    same command, `polyProjection`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A brief aside on UV mapping—it might seem strange that the three types of mapping
    are planar, cylindrical, and spherical; why those particular shapes and no others?
    The reason for this is that if you think of the surface of the model as a two-dimensional
    skin, then any given part of the model can be classified as belonging to one of
    only three groups:'
  prefs: []
  type: TYPE_NORMAL
- en: The region doesn't have any significant curvature.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The region has significant curvature in a single direction (horizontal or vertical).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The region has significant curvature in both directions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That maps neatly onto the three options of planar (no curve), cylindrical (single-direction
    curve), and spherical (curvature in both directions). While the part you are trying
    to map may be very different from a perfect plane, cylinder, or sphere, start
    by asking yourself how many directions it curves in and select your mapping accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two things we need to supply to the `polyProjection` command for
    it to work—the specific faces that should receive the mapping and the type of
    mapping to apply. To specify the range of faces, we will want to index into the
    faces or "f" array of the object. We can specify more than one face at a time
    using two indices with a colon in between. For example, if our object was named
    `mySphere`, and we wanted to refer to the first six faces, we could do that with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we''ll want to use the name of the selected object, and the `startFace`
    and `endFace` variables for the indices. Doing this gives us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have a way to specify the range of faces, we can apply the mappings,
    using the `type` flag to specify which kind of mapping to apply:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: From here, we just repeat the process with different values for `startFace`
    and `endFace`, and different options for the type flag.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you want to apply a mapping to the entire object, you might think that you
    just have the name of the object and leave out the face indices. This doesn''t
    work, but there is an easy way to tell Maya that you want to refer to all of the
    faces. To do this, just leave out both indices, but keep the colon, as in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: If the starter index is missing, Maya will substitute 0, and if the ending index
    is missing, Maya will substitute the maximum index. Leaving *both* out will result
    in the mapping being applied to the entire object.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we've only looked at selecting contiguous sequences of faces, but there
    are lots of situations where you might want to select faces that aren't consecutive
    indices. You can do that by having multiple selections separated by commas as
    first argument(s) to a function.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let us say that we wanted to select the first 5 faces *and* faces
    32 through 76 of `myObject`. We could use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Applying this to UV mapping would give us something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'When working with ranges of faces, it''s very common that you''ll determine
    the specific indices at runtime, either through some kind of calculation or based
    on a user input. It''s easy enough to do, but can lead to overly complex sequences
    of stick together string literals and variables, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: It's also very easy to forget to convert numerical values to strings with the
    `str()` command, which can lead to errors. Luckily enough, Python provides an
    alternative way to deal with building formatted strings from variables in the
    form of the `format` command.
  prefs: []
  type: TYPE_NORMAL
- en: To use the format command, you create a string with sections you want to replace
    with variables. Each replaceable section is represented with curly brackets containing
    a number such as `{0}`. You can then call the format command on that string and
    pass in variables that will replace the `{}` clauses. The numbers are used to
    specify which variables should go where ("{0}" means "replace with the first variable",
    for example).
  prefs: []
  type: TYPE_NORMAL
- en: 'So, as a really simple example, we could wish someone happy birthday with the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Turning back to Maya, let''s say that we wanted to have a generic way to select
    a range of faces. We would want to pass in the name of the object, the start index,
    and the ending index as variables. We could do this with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This would work just fine, but is a bit hard to read and is an easy way to
    introduce errors. If we were to rewrite that using the format command, we would
    have something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This tends to be a lot easier to think through because it allows you to separate
    the structure (the string) from the variables that should be slotted into it.
    You certainly don't have to use format, but as Maya scripting very often requires
    building up strings from variables in this way, using it will likely save you
    a lot of headaches. It also makes your code a lot more readable.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The official Python documentation for the format command is a bit hard to wade
    through and presents the information in an overly opaque way. Instead, I highly
    recommend having a look at [https://pyformat.info/](https://pyformat.info/), for
    a detailed, yet highly readable explanation of the intricacies of the format command.
  prefs: []
  type: TYPE_NORMAL
- en: Creating shading networks with code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we'll be looking at how to create shading networks with code.
    We'll be creating a simple toon shader, with a solid color in the interior and
    a different color at the edges of the object. There are a few different ways to
    do this, including by creating a rampShader, but we'll be doing it in the somewhat
    old-fashioned way using a samplerInfo node, as it provides a great example of
    a relatively simple yet somewhat novel shading network.
  prefs: []
  type: TYPE_NORMAL
- en: First off, let's have a look at what our shader will do and how it will do it.
    The key characteristic of a toon shader is that the object has an outline around
    its edges that changes as the object moves. So, the first thing we'll need is
    some way of knowing what the angle is between a given part of the model and the
    camera. Luckily, Maya provides a utility node that does just that in the form
    of samplerInfo. SamplerInfo nodes provide us with a `facingRatio` attribute that
    ranges from 0 (when a surface is perpendicular to the camera) to 1 (when a surface
    is facing directly at the camera).
  prefs: []
  type: TYPE_NORMAL
- en: Once we have the facing ratio, we'll need to tie it to a color change somehow.
    The easiest and most flexible way to do this is to use a ramp texture with linear
    interpolation to provide a sharp cutoff between the border and interior colors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Putting all that together gives us a relatively simple, three-node shading
    network similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating shading networks with code](img/4657_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new script and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: If you run the script, you should see a new shader appear in the hypershade,
    consisting of a red interior and a black exterior edge.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are three parts of the script—creating the nodes, setting their attributes,
    and connecting them to each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'First off, we create the three nodes we need with the `shadingNode` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing to note is that the shadingNode command is used for all three
    nodes we create even though they''re three different types (one shader, one texture,
    and one utility). In all cases, you get the results you want by specifying the
    specific kind of node that you want to create (`''blinn''`, for example) and also
    including one of the following flags set to True: `asShader`, `asTexture`, `asUtility`,
    `asPosProcess`, `asRendering`, `asLight`.'
  prefs: []
  type: TYPE_NORMAL
- en: Leaving out those flags will result in an error. If you include the wrong flag
    (asTexture=True when creating a Blinn shader, for example), the command will still
    work, but I don't recommend it.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the nodes is pretty straightforward—just make sure that you also save
    the output to a variable (as we've done here) so that you can later set their
    attributes and connect them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have all of our nodes created, we need to set their attributes. In
    this case, we need to do the following few different things that are applied to
    the ramp texture:'
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that the color interpolation is set to linear to give us nice sharp transitions
    between colors, rather than smooth gradients.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure that the color swatches are positioned correctly along the length
    of the ramp.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set both the colors to have the edge color and the interior color that we want.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For all of the above, we''ll use the `setAttr` command. The `setAttr` command
    expects the name of the attribute to set as the first argument, followed by the
    value to which it should be set. For single value, numeric values, that''s pretty
    straightforward. For example, the following sets the ramp''s interpolation to
    none:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Although the type of interpolation isn't actually a numerical value, it's a
    common practice in Maya (and other places) to use integers to represent various
    options. When setting attribute values that are represented in the interface by
    a drop-down menu, you'll generally want to use an integer, with the specific value
    corresponding to the position of the option in the list (with 0 being the first
    one).
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll want to set the colors of the ramp texture to have the correct positions
    and colors. The first thing to understand is that ramp textures maintain an array
    of nodes, contained in their `colorEntryList` attribute. Each entry in that list
    represents a stop in the ramp texture and has both a position and a color.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll want to make sure that the first entry is at the very beginning of the
    ramp, and the second entry is slightly less than halfway along it, as it gives
    us a good default edge thickness for the shader. We do this using setAttr to set
    the position of the first two entries in the `colorEntryList` array, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Next, we'll want to set the colors. That's a bit different, in that we need
    to feed three separate values into the `setAttr` command (one each for red, green,
    and blue). To do this, we'll need to provide all three numbers, and we'll also
    need to tell Maya to expect multiple inputs to the `setAttr` command by using
    the `type` flag.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `setAttr` command is one of the most powerful and most flexible commands
    that Maya offers. It can be used to alter any value of any node. All that power
    requires the command be able to accept various kinds of inputs, all specified
    with the type flag. In this case, we need a format that supports decimal values
    (since colors are represented as number from 0 to 1), and that supports three
    separate values. Either `float3` or `double3` will work. Putting that all together
    gives us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we've set all of the attribute values that we need for the shader.
    All that's left is to connect the nodes to each other. We do it with the `connectAttr`
    command. That's fairly straightforward and just requires that we specify first
    the source attribute, then the destination.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we want to make two connections:'
  prefs: []
  type: TYPE_NORMAL
- en: The `facingRatio` attribute of the samplerInfo to the V coordinate of the ramp
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `outColor` of the ramp texture to the color of the shader
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Doing this ends up looking like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating nodes and connecting their attributes is a great way to approach a
    wide range of tasks in Maya, but it can sometimes be tedious. For example, if
    we wanted to create a `place2dTexture` utility node and connect it to a texture
    node, we would have to make over a dozen connections, which is tedious, to say
    the least. Luckily, Maya provides an easy shortcut to create nodes with the default
    behavior in the form of the `defaultNavigation` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what that would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Note the inclusion of the `connectToExisting=True` to indicate that the nodes
    being connected are already present in the scene. Much nicer than 18 separate
    calls to `connectAttr`, indeed.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also break connections between nodes with Python with the `disconnectAttr`
    command. For example, if we wanted the previously mentioned two-node network of
    a place2dTexture and a file texture to share everything `except` the offset attribute,
    we could do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Sometimes, it might be faster to connect two nodes with the default connections
    (with defaultNavigation) and break a few specific connections you don't want,
    instead of manually creating all the connections you do want.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Be sure to refer to the built-in documentation for the `setAttr` command for
    a complete list of the types of inputs it can accept. The documentation is a bit
    dense, but it's definitely worth a look.
  prefs: []
  type: TYPE_NORMAL
- en: Applying shaders to objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you have a shading network created, you'll generally want to apply it to
    one or more objects. In this example, we'll be looking at how to do it. Along
    the way, we'll create a script that can be used to apply a shader to all of the
    objects in the scene that are without one.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure that you have a scene with a few different objects in it. Select a
    few objects and apply a shader to them in the normal way, using the hypershade's
    interface. Delete the shader, leaving at least one object without any shader of
    any kind.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new script and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Run the script, and you should see any and all of the objects that were previously
    without a shader sporting a brand new, cyan-colored blinn shader.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The script works by:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting a list of all the objects in the scene.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running through the list and checking whether a given node is geometry.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For any geometric node, find the shaders applied to it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a given object has no shaders, add it to a list of non-shaded objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a new shader to apply.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apply the shader to the shader-less objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This script makes use of the `hyperShade` command in a couple of different ways—to
    find the shaders attached to an object, the objects attached to a shader, and
    to apply a shader.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s look at how to grab the shaders for a given object. To make things
    easier on ourselves later, we''ll create a function to do it. We have the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The main thing that we're doing is to use the hyperShade command with the `shaderNetworksSelectMaterialNodes`
    (or just `smn`) flag set to true. That will select the shader (or shaders) of
    the currently selected objects. Because the command works on selections, we have
    to make sure that the object (or objects) we want to know about are selected before
    we run it. Once we've run it, we'll need to examine the currently selected nodes
    to get the list of shaders.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we create a function to easily tell if a given transform node corresponds
    to actual geometry. We need it because we''re going to iterate over all the transforms
    in the scene, and there are many things (lights, cameras, and so on) that have
    transforms but that aren''t geometry. We accept the name of the node as an input
    and find the corresponding shape node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we examine the shape node to find what kind of object it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `listRelatives` command returns an array, so we need to index
    into that and grab the first element. It's unlikely that an object would have
    multiple shape nodes, but `listRelatives` can also be used to find an object's
    children, which will often be multiple nodes. Since it can sometimes result in
    multiples, the command therefore always returns an array even if there's only
    a single item.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of the three types of geometry in Maya (polygon, NURBS, and subdivision
    surfaces) has its own corresponding shape node. For the sake of convenience and
    code readability, we''ll create an array of those types and check the current
    shape node''s type against it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we''re ready to jump into the real meat of the script. We start
    by grabbing a list of all of the transforms in the scene using the `ls` command.
    So far, we''ve mainly used that to find what''s currently selected, but it can
    also be used to grab all the nodes of a specific type (selected or not):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we create an empty list to which we''ll add any object that we find to
    be lacking a shader and start running through the list of transforms. First, we
    check to make sure that the node in question is geometry of some kind. If that''s
    the case, we use our `shadersFromObject` function to find the shader(s) applied
    to the object. Once we''ve done this, we check the length of the returned list-
    if it''s zero, then the object had no shaders, and we add it to our list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, the `unShaded` list contains all of the objects in the scene
    that lack shaders. We create a new shader, a simple blinn, and set its color to
    cyan:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we select the contents of the `unShaded` list and apply the shader
    we just made. For that, we''ll use the `hyperShade` command again, but this time
    with the assign flag to apply the specified shader to the currently selected objects.
    We have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `hyperShade` command can be used to do most of the tasks one would normally
    accomplish in the hypershade panel interface. In the previous example, we grabbed
    shaders from objects, but the command can also be used to find the objects associated
    with a given shader with the `objects` flag. Wrapping that up in a nice function
    to return the objects for a given shader would look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Once again, the `hyperShade` changes the current selection, and we use the `ls`
    command to retrieve the selection as an array.
  prefs: []
  type: TYPE_NORMAL
- en: Using shading nodes for non-shading tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the really great things about the various nodes that Maya provides is
    that there are very few limits on how you use them. To Maya, all nodes are just
    collections of functionality with certain inputs and outputs, and as long as the
    type of data lines up, it doesn't really care how you connect them.
  prefs: []
  type: TYPE_NORMAL
- en: This means that it's completely possible (and often very useful) to use hypershade
    nodes for tasks that aren't related to creating shading networks. In this example,
    we'll be doing just that using a plus/minus/average utility node to set the position
    of a given object to the average position of a number of others. This could be
    used, for example, to ensure that the pelvis of a character always stays centered
    in between the IK handles controlling its feet.
  prefs: []
  type: TYPE_NORMAL
- en: Using utility nodes can be used for tasks where you might otherwise write an
    expression, but with the added benefit that they update constantly, not just while
    the playback head is moving.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Be sure that you have a scene with at least three objects in it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new script and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Select at least three objects, making sure that the object you want to be controlled
    is the last one selected, and run the script. Once you've done that, try moving
    the objects around, and you'll see that the X and Z position of the controlled
    object is always an average of the X and Z positions of all the other objects.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First off, we check to make sure that there are at least three objects selected
    and error out if there isn''t:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'If we have at least three objects, we proceed to create a brand new utility
    node, in this case a plus/minus/average node. Since the plus/minus/average node
    can perform three completely separate actions, we also need to set its "operation"
    attribute to average (which happens to be the fourth option in the corresponding
    dropdown, so has a value of 3), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Once we've done this, we run through the list of selected objects and connect
    all but the last one to the utility node as inputs. PlusMinusAverage nodes can
    have one-dimensional, two-dimensional, or three-dimensional inputs. In this case,
    we'll use 3D inputs.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We're only using two inputs (X and Z), so we certainly could get by with 2D
    inputs instead. However, since we're dealing with position data, I think it's
    better to use full 3D inputs and just leave the Y inputs empty. This way, it's
    easier to later modify the script to allow the user to select any combination
    of X, Y, and Z that they want.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the "X", "Y", and "Z" of the plusMinusAverage node don't have any
    intrinsic meaning; they're just three separate pathways for the calculation, and
    we could certainly use them for things that have nothing to do with position.
  prefs: []
  type: TYPE_NORMAL
- en: 'The plusMinusAverage node holds an array for each type of input (one-dimensional,
    two-dimensional, and three-dimensional). So to do anything with it, we''ll need
    to first access the proper array. If we had a plusMinusAverage node named `avgNode`
    and wanted to do something with the second one-dimensional input, we would use
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'For two- and three-dimensional inputs, we need to specify not only the proper
    array but also the proper entry. For two-dimensional inputs, the array is specified
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'For three-dimensional inputs, the array is specified as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: We don't need to explicitly add inputs to the utility node; we can just use
    connectAttr to connect inputs to successive indices of the node's input 3D array.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we want to run through all of the selected objects except for
    the last one and connect their X and Z positions, which is easy enough:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'At that point, we''re mainly done. All that''s left is to connect the outputs
    of the plusMinusAverage node to the controlled object. Storing the index of the
    controlled object as a variable isn''t necessary, but does make the code a bit
    more readable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the discussed example, we created a very simple network, but it's certainly
    possible to create more complex networks. One important thing to bear in mind
    is that, while all the nodes have certain uses that they were created for, in
    no way this limits the kind of use to which they can be put. To Maya, numbers
    are just numbers, and there's nothing to stop you from using color channels to
    control position or rotation to control transparency.
  prefs: []
  type: TYPE_NORMAL
