- en: SDN Concepts in Network Automation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen on our journey so far, there are numerous scenarios where we
    can automate a network, from daily or routine tasks, to managing infrastructure
    from a single controller-based architecture.  Building upon those concepts, we
    will now gain some additional insights for working in **software-defined networks**
    (**SDNs**) and look at some examples of working with cloud platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the key components we are going to cover are:'
  prefs: []
  type: TYPE_NORMAL
- en: Cloud platform automation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network automation tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controller-based network fabric
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programmable network devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing cloud platforms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can use network automation techniques through Python to work on various cloud
    providers. From working on cloud instances, to spinning up new VMs, controlling
    full access like ACLs, and creating specific network layer tasks like VPNs, and
    network configurations of each instance, we can automate just about anything using
    available connectors or APIs in Python. Let's see some basic configuration and
    connections on the most popular cloud platform, **Amazon Web Services** (**AWS**)
    using Python.
  prefs: []
  type: TYPE_NORMAL
- en: AWS provides an extensive API through its SDK called Boto 3\. Boto 3 provides
    two types of APIs to be used, a low-level API set that is used to interact with
    direct AWS services, and a high-layer Python friendly API set for quick interactions
    with AWS. Along with Boto 3, we also would need to have the AWS CLI that is used
    as a **command-line interface** (**CLI**) to interact with AWS from the local
    machine. Think of this as a CLI based tool that is equally like DOS is to Windows
    from a CLI perspective.
  prefs: []
  type: TYPE_NORMAL
- en: 'The installation of both the AWS CLI and Boto 3 is done using `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To install from AWS CLI, use the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To install from Boto 3, use the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Once installed, the packages are ready to use. However, we need to configure
    an access key in the AWS Web Management Console which will have a certain level
    of restrictions (that we will define while creating the access key).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s quickly set up a new access key to manage the AWS in Python from our
    local machine:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Log in to the AWS web console and select IAM as the option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d6dd3bb0-93e1-416b-b09b-dde6bf496236.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on Add user to create a username and password pair shown as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c34f5d6f-8428-4a07-b5db-5a6fd36980d4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Select username and ensure to check Programmatic access to get the access ID
    and secret key to be used in our Python calls:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/201f9356-8f61-4288-8a8d-049d4ac83921.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We also need the user to be part of a certain group (for security restrictions).
    In our case we make it part of the admin group which has full rights on the AWS
    instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e6bc8d59-f148-4f45-8f9a-2fb4acf477ad.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we made our selections correctly, a user is created with the username we
    selected (`booktest`) with an access key and a secret access key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d2158071-32a0-469e-911e-fbc96cb771bf.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once we have this key, we go back to our Python installation and on the Command
    Prompt, call the AWS CLI command `aws configure`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b067f6ad-1546-486b-b4d8-baf6c6038c1d.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As per the questions asked, we fetch the values from the AWS web console and
    paste them in the CLI. The final question of `Default output format` can be `text`
    or `json`. However, for our purpose of automation and working with Python, we
    would select `json` instead of `text`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once we are done with this backend configuration, we are ready to test our scripts
    by calling the Boto 3 API in Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example of getting all running instances on the current AWS account
    for which we have the key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Since we have already configured the backend credentials and key with the `aws
    configure` CLI command, we do not need to specify any credentials in our scripts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0ab7156c-653b-4bbf-9abc-0da74b8ae3a2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As we see in the preceding output, we get back two instances which are EC2
    instances with their instance IDs. Additionally, we also get some other parameters
    for the currently configured instances. In some cases, if we do not want to use
    the current preconfigured keys, we can call the Python program by passing the
    values directly into Boto 3 functions as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see another example of fetching the private IP address and instance
    ID for each of the instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code gives the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e72a2534-f0bc-4b04-8209-2037ee842087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using the Boto 3 API, we can also spin up new instances in our subscription. Let's
    see a final example of spinning up a new **Virtual Machine**(**VM**) with EC2
    using Boto 3.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we call the Python to spin a new VM, we need to select which **Amazon
    Machine Image** (**AMI**) image to use for the instance. To find out the AMI image
    value, we need to open AMI in the AWS web console shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b89b8f02-0d74-4548-968d-aa99cb7e16ce.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once we have finalized the AMI, we call the easy part, spinning the new VM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: It will take some time for the script to execute, and the result value would
    be the instance with all its configured parameters based upon the AMI image ID
    selected. Similarly, we can spin up various type of instances or even new security
    filters using Boto 3 and ensure we have cloud controlling automation in place.
  prefs: []
  type: TYPE_NORMAL
- en: Programmable network devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Looking back at historic implementations, we had a fixed set of hardware or
    networks geared for catering services to the end users. End users also had a limited
    set of connection options to access a limited set of networks or connected resources. As
    the number of users increased, a simple solution was to add additional hardware
    or network gear. However, with the surge of different end user devices, such as
    mobile phones, and high data demand and up time requirements for end users, managing
    the increasing amount of hardware and additional connections becomes a complex
    task.
  prefs: []
  type: TYPE_NORMAL
- en: A simple device failure or cable failure might impact the entire set of connected
    hardware or network gears, which would create a widespread downtime for end users,
    resulting in a loss of man hours both in terms of productivity and trust. Think
    of a large **internet service provider** (**ISP**) with recurring outages, with
    each outage affecting a large set of both enterprise and home users. If a new
    ISP were to enter the market with reliability as its unique selling point, people
    would not think twice before jumping to the new provider. Effectively, this could
    result in a loss of business and ultimately, a closure situation for the earlier
    provider because of the decreasing reliability and trust among its current set
    of users.
  prefs: []
  type: TYPE_NORMAL
- en: To handle this type of situation, one solution that has emerged is the usability
    of the same set of devices or network hardware to perform different functions
    using the same hardware platform. This has been made possible through a combination
    of SDNand **programmable networks** (**PNs**).
  prefs: []
  type: TYPE_NORMAL
- en: SDN takes care of control plane configurations for data to automatically reroute
    to a path that is the best available for a specific source to the destination.
    For example, let's say we need to reach destination D from source A. The best
    path to reach D is A -> C -> D.
  prefs: []
  type: TYPE_NORMAL
- en: Now, in the case of legacy traffic flow, unless C is down or practically shut,
    the traffic will not flow from A -> B -> D (unless special complex configurations
    are done on each network gear/device). In an SDN environment, using OpenFlow as
    the underlying protocol, the controller will detect any issues in the path of
    A -> C -> D, and based upon certain issues (like packet drop or congestion in
    the path), would make an intelligent decision to ensure there is a new path for
    the data to flow from A -> B -> D.
  prefs: []
  type: TYPE_NORMAL
- en: As we see in this case, even with no physical issues on C, SDN already takes
    care of identifying the best path for the data to flow on, which effectively results
    in the best achievable performance for end users with reliability.
  prefs: []
  type: TYPE_NORMAL
- en: 'PN is an addition which is a collection of hardware devices in the network
    layer that can be programmed to behave in a different way based upon the requirements.
    Think of a switch acting as a router by changing its functionality through a written
    piece of code. Let''s say we get an influx of new end users and we need to have
    a high switching capacity in the network layer. Some of the devices can now act
    as a switch rather than a router. This ensures a two-fold benefit:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the same set of hardware based upon the demand and requirements, the hardware
    can be reused to handle new scenarios without introducing more complexity into
    the network by adding an additional set of hardware.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Better control over the flow of traffic with the additional capability of securing
    traffic through the same set of devices. This is introduced by adding ACLs for
    traffic to flow from a certain set of devices, and even ensuring that a device
    handles only a particular type of traffic and sends the remaining traffic to other
    devices that are specifically programmed to handle that particular traffic. Think
    of it, as video with voice traffic going from a different set of devices to ensure
    optimal performance and load on specific devices using the same set of hardware
    that we currently have.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A major component of PNs (the collective name for programmable network devices),
    is the use of APIs that are provided by various network vendors like Cisco, Arista,
    and Juniper. By calling these APIs we can ensure that each of the devices from
    specific vendors can easily talk to each other (exchange information is a unified
    format), and can change the behavior of a specific hardware based upon the API
    calls. One example that is common in today's market is Cisco Nexus 9000 series
    devices. These are modular or fixed switches (with different variations), and
    by using OpenFlow gives us the ability to programmatically alter their behavior
    based upon dynamic requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Taking this switch as an example, direct access to **application-specific integrated
    circuit** (**ASIC**) chip-level programming is also exposed, which ensures that
    the ASICs can also be programmed based upon the requirement along with the software-level
    variations. With SDN in place, controllers can take advantage of OpenFlow and
    the APIs exposed on these switches to control the role of these switches.
  prefs: []
  type: TYPE_NORMAL
- en: Cisco also provides a **Power on Auto Provisioning** (**PoAP**) feature to multiple
    devices (primarily on the Nexus platform) that helps achieve auto provisioning
    and commissioning as soon as a new device boots. A basic overview of this process
    is, if a Nexus device with the PoAP feature enabled boots and is unable to find
    any startup config, it locates a **Dynamic Host Configuration Protocol** (**DHCP**)
    server in the network and bootstraps using the IP address and DNS information
    obtained from that DHCP server. It also fetches a customized script that is executed
    on the device that has instructions to download and install the relevant software
    image files and specific configurations for that device.
  prefs: []
  type: TYPE_NORMAL
- en: A big advantage of this type of feature is that we can spin up new devices within
    one to two minutes by just powering it up and connecting it to a network which
    has DHCP functionality to fetch relevant information to new devices in the network.
    Think of the legacy way of bringing a router live with multiple hours of human
    intervention versus the current way of booting up a router, and the router taking
    care of itself without any human intervention.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, using the APIs (**NX-API** is the underlying terminology used for
    **Nexus API**), better visibility in terms of packet flow and monitoring is also
    being exposed from Cisco, and, using simple scripts written in any language (like
    Python), the path and flow of traffic can be modified based upon the results returned
    back through the call of those APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Taking another example, we have network device vendor Arista. Arista has introduced
    Arista **Extensible Operating System** (**EOS**), which is a highly modular and
    Linux-based network OS. Using Arista EOS, managing multiple devices becomes easy
    as it has the ability to provide extensive APIs (Linux kernel-based and additional
    ones related to Arista), and call APIs for various vendors to configure and deploy
    numerous end nodes. A feature introduced by Arista called **Smart System Upgrade**
    (**SSU**), ensures that as we perform OS upgrades on Arista devices, it restarts
    its services with the upgraded OS versions but without rebooting to ensure minimal
    traffic interruption during upgrades. These features ensure that we have resiliency
    and up time even when we have new patches and OS upgrades rolled out on the data
    centers or multiple devices at once.
  prefs: []
  type: TYPE_NORMAL
- en: Arista EOS provides extended functionality for the devices to be managed through
    APIs by providing a set of APIs call **eAPI**. eAPI can be used to configure Arista
    devices by calling the eAPI framework from any scripting or programmable language.
    Let's see a very basic example of how to manage an Arista switch using eAPI.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to configure eAPI on the Arista switch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the Arista eAPI functionality is enabled on the router, and
    we can use HTTP protocol to interact with the API. We can also switch between
    the options of eAPI available over HTTPS, by using the command `protocol https`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify if our configuration is correct, we use the command `show management
    api http-commands`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We can check if the eAPI framework is now accessible using the browser command
    `http://<ip of router>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A couple of examples from Arista depict the output that we get using the URL
    (in this case we have HTTPS enabled instead of HTTP):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8f8c0913-3109-4155-98bc-94f1f4da9513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here we see a set of commands passed (`show version` and `show hostname`),
    and the response from the API confirms the result set. Additionally, the Command
    Response Documentation tab shows us the available APIs that can be used for reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8693d414-a4dc-4b05-b348-f0e4ab76c21e.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s see how to call the same in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As a prerequisite we need to install `jsonrpclib`, which can be found at URL [https://pypi.python.org/pypi/jsonrpclib. ](https://pypi.python.org/pypi/jsonrpclib)This is
    used to parse the **remote procedure call** (**RPC**) in JSON format. Once done,
    the following code will result in the same set of values that we got using the
    browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code gives the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In a similar way, Arista has also introduced a library for Python that can be
    used as an alternate to `jsonrpclib`. The library `pyeapi`, which can be found
    at URL [https://pypi.python.org/pypi/pyeapi, ](https://pypi.python.org/pypi/pyeapi)is
    a Python wrapper for the Arista EOS eAPI. Going by the example, here is how we
    can access the same set of devices using `pyeapi`.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the developer page, here is an example that depicts how we can use `pyeapi`
    for API handling on Arista:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Looking at both Cisco and Arista (which are two major players in the cloud and
    SDN marketplace), we can combine both Arista eAPI and Cisco NX-API to manage our
    entire data center inventory, and work on some tasks like the provisioning of
    new devices or upgrading of current devices with no or minimal impact, which in
    turn ensures scalability, reliability, and uptime in the business processes.
  prefs: []
  type: TYPE_NORMAL
- en: Controller-based network fabric
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we come out of the legacy hardware era in which each physical path was connected
    and designed to take traffic from one point to another, and where a packet had
    limited availability to reach from one device to another, SDN is ensuring that
    we have a network fabric for our data to reach between different sources and destinations.
  prefs: []
  type: TYPE_NORMAL
- en: A **network fabric** is a collection of different network devices connected
    to each other by a common controller ensuring that each component in the network
    is optimized to send traffic among each of the nodes. The underlying switch fabric,
    which is a physical switchboard with ports (like Ethernet, ATM, and DSL), is also
    controlled and programmed by a controller which can ensure (by creating a path
    or specific port(s)) that a particular type of data can traverse through to reach
    its destinations.
  prefs: []
  type: TYPE_NORMAL
- en: In a typical network design we have Layer 2 (or switching domains) and Layer
    3 (or routing domains). If we do not have a controller-based approach, each network
    component can learn the behavior of traffic from its next connected component
    (like **Spanning Tree Protocol** (**STP**) for Layer 2) or some routing protocol
    (like OSPF for Layer 3). In this case, each device acts as its own controller
    and only has limited visibility to devices that it is directly connected to (also
    termed **neighbor devices**). There is no single view of the entire network on
    any device, and additionally, each component (or individual controller) acts as
    a single point of failure for its neighbor devices. A failure on any component
    would result in its neighbor devices re converging or even getting isolated owing
    to the failure of their connected component.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing that to a controller-based environment, theoretically each device
    has as many connections as it has number of ports connected. Hence, if we think
    of even three devices connected in a controller-based environment, we have multiple
    connections between each device owing to their physical connectivity to each other.
    In case of the failure of a component (or device), the controller can quickly
    make an intelligent decision to reconfigure a new path and alter the behavior
    of the other two network devices to ensure minimal disruption to traffic, keeping
    the same throughput and distributed load on all the other available links. A controller
    in theory eliminates the control plane behavior of each device and ensures an
    optimized forwarding table (to forward data to specific destinations) is updated
    on each device the controller is managing. This is because the controller starts
    acting as the main component which has the visibility of every device, with every
    entry and exit point of each device and the granularity of the data type that
    is flowing from each managed network device.
  prefs: []
  type: TYPE_NORMAL
- en: Going by the vendors, major players such as Cisco (with its open network environment),
    Juniper (with its QFabric switch), and Avaya (with its VENA switch), have provided
    the ability to act as controllers or be configured to be managed by a controller.
    Additionally, with the introduction of controller-to-manager network components,
    each network device can now virtually become a dump client with the controller
    making all the intelligent decisions, from learning to forwarding tables.
  prefs: []
  type: TYPE_NORMAL
- en: A controller acts as an abstraction layer between multi-vendor network devices
    and network tasks. As an end user, someone can configure specific tasks to be
    performed by the controller, and, using the underlying API model from different
    vendors (using JSON or XML), the controller can convert those specific tasks into
    various vendor-specific API calls, and devices can be configured by sending those
    specific instructions using those APIs to each of the vendor devices. The **Application
    Policy Infrastructure Controller** (**APIC**) component is responsible for controlling
    and programming the fabric on each network device component.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see an example of Cisco APIC and some basics on how we can use it. Cisco
    APIC is used to manage, automate, monitor, and program **Application Centric Infrastructure**
    (**ACI**). ACI is a collection of objects with each object representing a tenant.
    A tenant can be called a group of specific customers, groups, or business units
    based upon the business classifications. As an example, a single organization
    may covert its entire infrastructure into a single tenant, whereas an organization
    can separate out its tenants based upon its functions like HR and Finance. Tenants
    can further be divided into contexts, with each context as a separate forwarding
    plane, hence the same set of IP addresses can be used in each context as each
    set of IP addresses will be treated differently in each context.
  prefs: []
  type: TYPE_NORMAL
- en: Contexts contain **Endpoints** (**EPs**) and **Endpoint Groups** (**EPGs**).
    These EPs are physical components like hardware NICs, and EPGs are collections
    of items like DNSs, IP addresses, and so on, that dictate a similar functionality
    for a specific application (like a web application).
  prefs: []
  type: TYPE_NORMAL
- en: 'For programming with APIC, the major components required are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**APIC Rest Python Adaptor** (**ARYA**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is a tool created by Cisco to convert the APIC object returned in XML or
    JSON to direct Python code. Underlying, this leverages the COBRA SDK to perform
    this task. This can be installed in Python using `pip install arya`.
  prefs: []
  type: TYPE_NORMAL
- en: '**ACI SDK**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is the SDK that contains the API to directly call the APIs of the controller.
    We need to install `acicobra`, which can be found at [https://www.cisco.com/c/en/us/td/docs/switches/datacenter/aci/apic/sw/1-x/api/python/install/b_Install_Cisco_APIC_Python_SDK_Standalone.html, ](https://www.cisco.com/c/en/us/td/docs/switches/datacenter/aci/apic/sw/1-x/api/python/install/b_Install_Cisco_APIC_Python_SDK_Standalone.html)from
    Cisco to be able to call it into Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have this installed, here are some examples from Cisco which can be
    found at the URL [https://github.com/CiscoDevNet/python_code_samples_network/blob/master/acitoolkit_show_tenants/aci-show-tenants.py.](https://github.com/CiscoDevNet/python_code_samples_network/blob/master/acitoolkit_show_tenants/aci-show-tenants.py)
    This can help us understand creating an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Looking at the preceding concepts, we can enhance and ensure that our managed
    nodes in the controller can be controlled based on the application requirements
    rather than hardware limitations. This also ensures that the infrastructure is
    now tweaked as per application, and not vice versa, with the application performance
    restricted by hardware.
  prefs: []
  type: TYPE_NORMAL
- en: Network automation tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen throughout the previous chapters, we have multiple choices regarding
    automating a network. From a basic configuration for any device using Netmiko
    to deploying and creating configurations across various devices in a network using
    Ansible,there are many options for engineers to automate networks based upon various
    needs.
  prefs: []
  type: TYPE_NORMAL
- en: Python is extensively used in creating automation scenarios, owing to its open
    community support for various vendors and protocols. Nearly every major player
    in the industry has support for Python programming, tweaking their own tools or
    any supporting technology that they have. Another major aspect of network automation
    are the custom-based solutions that could be made for organization requirements.
    The self-service API model is a good start to ensuring that some of the tasks
    that are done manually can be converted to APIs, which can then be leveraged into
    any language based upon the automation needs.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see an example that can be used as a basic guide to understand the advantage
    of self or custom-created automation tools. The output of `show ip bgp summary`
    in Cisco is the same as `show bgp summary` in Juniper. Now, as an engineer who
    needs to validate the BGP on both the vendors, I need to understand both the commands
    and interpret the output.
  prefs: []
  type: TYPE_NORMAL
- en: Think of this situation by adding more vendors which have their own unique way
    of fetching BGP output. This becomes complex and a network engineer needs to be
    trained on a multi-vendor environment to be able to fetch the same type of output
    from each vendor.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's say we create an API (for example, `getbgpstatus`), which takes the
    input as some hostname. The API at the backend is intelligent enough to fetch
    the vendor model using SNMP, and based upon the vendor sends a specific command
    (like `show ip bgp summary` for Cisco or `show ip summary` for Juniper), and parses
    that output to a human-readable format, like only the IP address and status of
    that BGP neighbor.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, instead of printing the raw output of `show ip bgp summary` or
    `show bgp summary`, it parses the output like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This output can be returned as a JSON value back to the call of the API.
  prefs: []
  type: TYPE_NORMAL
- en: Hence, let's say we can call the API as `http://localhost/networkdevices/getbgpstatus?device=devicex`
    and the API from the backend will identify if `devicex` is Juniper or Cisco or
    any other vendor, and based upon this the vendor will fetch and parse the output
    relevant to that vendor. A return of that API call will be JSON text as we saw
    in the preceding example, that we can parse in our automation language.
  prefs: []
  type: TYPE_NORMAL
- en: Let us see a basic example of another popular tool, SolarWinds. There are many
    aspects of SolarWinds; it can auto-discover a device (based upon MIBs and SNMP),
    identify the vendor, and fetch relevant information from the device.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see some of the following screenshots for basic SolarWinds device management.
    SolarWinds is freely available as a trial download.
  prefs: []
  type: TYPE_NORMAL
- en: 'The prerequisite for SolarWinds device management is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to add a device in SolarWinds, shown as below:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d9163428-3e8e-45d1-aad5-c056a4ba0d2e.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, SolarWinds has the ability to discover devices (using network
    discovery), or we can add a specific IP address/hostname with the correct SNMP
    string for SolarWinds to detect the device.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the device is detected it will show as the monitored node, as in the below
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8bc6e99c-2d59-43d2-baee-ddd63462bdf9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Notice the green dot next to the IP address (or hostname). This signifies that
    the node is alive (reachable) and SolarWinds can interact with the node correctly.
  prefs: []
  type: TYPE_NORMAL
- en: '**Additional task(s) that can be performed post device discovery is as follows:**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have the node available or detected in SolarWinds, here are some of
    the additional tasks that can be performed in SolarWinds (as shown in screenshot
    below):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2be18c1d-a31d-4045-8593-d0a06638e4e8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We have selected the CONFIGS menu, under which we can perform config management
    for the devices. Additionally, as we can see in the following screenshot, we have
    the ability to create small scripts, (like we did here to `show running config`),
    which we can use to execute against a certain set of devices from SolarWinds itself
    (as in screenshot below):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e4aaef49-e77f-4c58-957e-8899d6f19977.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The result is retrieved and can be stored as a text file, or can even be sent
    as a report back to any email client if configured. Similarly, there are certain
    tasks (called **jobs** in SolarWinds), that can be done on a scheduled basis,
    as we can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2935a92f-e6ad-4ea6-9ec5-7aa7ea9da9e1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we can see in the preceding screenshot, we can Download Configs from Devices,
    and then select all or certain devices in the next step and schedule the job.
    This is very useful in terms of fetching a config from a previous date or in case
    a rollback is needed to a last known good config scenario. Also, there are times
    when auditing needs to be performed regarding who changed what and what was changed
    in configurations, and SolarWinds can extend this ability by sending reports and
    alerts. Programmatically, we have the additional ability to call the SolarWinds
    API to fetch the results from Python.
  prefs: []
  type: TYPE_NORMAL
- en: It is assumed that OrionSDK is already installed in Python. If not, we can install
    it using `pip install orionsdk`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Since SolarWinds supports a direct SQL query, we use the query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We are trying to fetch the `NodeID` and `DisplayName` (or the device name)
    for all the devices which have the vendor Cisco. Once we have the result, we print
    the result in a formatted way. In our case, the output will be (let''s assume
    our Cisco devices in SolarWinds are added as `mytestrouter1` and `mytestrouter2`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Using some of these automation tools and APIs, we can ensure that our tasks
    are focused on actual work with some of the basic or core tasks (like fetching
    values from devices and so on) being offloaded to the tools or APIs to take care
    of.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now create a basic automation tool from scratch that monitors the reachability
    of any node that is part of that monitoring tool, using a ping test. We can call
    it PingMesh or PingMatrix, as the tool will generate a web-based matrix to show
    the reachability of the routers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topology that we would be using is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/730b75ac-2225-4408-b7e7-0b043391c012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, we would be using four routers (`R1` to `R4`), and the `Cloud1` as our
    monitoring source. Each of the routers will try to reach each other through ping,
    and will report back to the script running on `Cloud1` which will interpret the
    results and display the web-based matrix through a web-based URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'The explanation of the preceding topology is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: What we are trying to do is log in to each router (preferably in parallel),
    ping each destination from each source, and report back the reachability status
    of each destination.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As an example, if we want to do the task manually, we would log in to `R1` and
    try to ping `R2`, `R3`, and `R4` from the source to check the reachability of
    each router from `R1`. The main script on `Cloud1` (acting as the controller)
    will interpret the result and update the web matrix accordingly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In our case all the routers (and the controller) are residing in `192.168.255.x`
    subnet, hence they are reachable to each other using a simple ping.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are going to create two separate Python programs (one to be called as the
    library for invoking the commands on various nodes, fetching the results from
    the nodes, interpreting the results, and sending the parsed data to the main program).
    The main program will be responsible for calling the library, and will use the
    results we get back to create the HTML web matrix.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the library or the program to be called in the main program first
    (we called it `getmeshvalues.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have created three main functions that we call in
    a thread (for parallel execution). The `getallvalues()` contains the list of IP
    addresses that we want to get the data from.  It then passes this information
    to `fetchallvalues()` with specific device information to fetch the ping values
    again in parallel execution. For executing the command on the router and fetching
    the results, we call the `fetchpingvalues()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the result of this code (by removing the remark on the code that
    calls the function). We need to pass the device IPs that we want to validate as
    a list. In our case, we have all the valid routers in the `192.168.255.x` range,
    and `4.2.2.2` is taken as an example of a non-reachable router:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code gives the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/27db4bff-4119-4e85-9d9f-015ca58654d2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we can see in the result, we get the reachability in terms of `True` or `False`
    from each node to the other node.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the first item in the list (`'192.168.255.240:192.168.255.240','True'`)interprets
    that from the source `192.168.255.240` to destination `192.168.255.240` (which
    is the same self IP) is reachable.  Similarly, the next item in the same list
    (`'192.168.255.240:192.168.255.245','True'`) confirms that from source IP `192.168.255.240`
    the destination `192.168.255.245` we have reachability from ping. This information
    is required to create a matrix based upon the results. Next we see the main code
    where we fetch these results and create a web-based matrix page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to create the main file (we''re calling it `pingmesh.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we have the following mappings in place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The last device named `Random`,is a test device which is not in our network
    and is non-reachable for test purposes. Once executed, it creates a file named
    `pingmesh.html` with standard HTML formats and a last-refreshed clock (from JavaScript)
    to confirm when the last refresh occurred. This is required if we want the script
    to be executed from the task scheduler (Let's say every five minutes), and anybody
    opening the HTML page will know when the probe occurred. The HTML file needs to
    be placed or saved in a folder which is mapped to a web folder so that it can
    be accessed using the URL `http://<server>/pingmesh.html`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When executed, here is the output from the Python script:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9f1a81d1-b0b1-4f46-94d4-7ab8c48f8af6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The HTML file, when placed in the web-mapped URL and called, looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/73a2b511-4c71-4ff9-bf5b-bc6376482369.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, in the PingMatrix there is an entire red row and column, which
    means that any connectivity between any router to the random router and from the
    random router to any router is not there. Green means that all the connectivity
    between all other routers is fine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, we have also configured a tooltip on each cell, and hovering
    the mouse over that specific cell would also show the source and destination IP
    address mapping for that particular cell, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d5dd0c8b-dd5d-422c-9916-151750f43c15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s see another screenshot, in which we shut down R2 to make it unreachable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b5b0edb8-bf44-4e23-8c27-f06c5f150f82.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, as we can see, the entire row and column of `R2` is red, and hence the
    PingMatrix shows that `R2` is now unreachable from everywhere else, and `R2` also
    cannot reach anyone else in the network.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see a final example, in which for test purposes we intentionally block
    the ping traffic from `R2` to `R4` (and vice versa) using an extended Cisco ACL,
    which in turn reports that `R4` and `R2` have reachability issues in the PingMatrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2ee3fc82-d864-4bbe-89ff-b2de50f9edb5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we see can in the preceding screenshot, the Random router is still a red
    or false, since it is not in our network, but now it is showing red/false between
    `R2` and `R4` and also between `R4` and `R2`. This gives us a quick view that
    even with multiple paths to reach each node with another node, we have a connectivity
    issue between the two nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Going by the preceding examples, we can enhance the tool to easily monitor and
    understand any routing/reachability issues, or even link down connectivity problems
    using a holistic view of all of the connections in our network. PingMesh/Matrix
    can be extended to check latency, and even packet drops in each connection between
    various nodes. Additionally, using syslog or email functionality (specific Python
    libraries are available for sending syslog messages from Python or even emails
    from Python code), alerts or tickets can also be generated in case of failures
    detected or high latency observed from the Python script itself.
  prefs: []
  type: TYPE_NORMAL
- en: This tool can easily become a central monitoring tool in any organization, and
    based upon patterns (such as green or red, and other color codes if needed), engineers
    can make decisions on the actual issues and take proactive actions instead of
    reactive actions to ensure the high reliability and uptime of the network.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the basic functionality of SDN controllers,
    programmable fabric, and some network automation tools. We have also seen how
    to work with cloud platforms and, with reference to a live example of managing
    AWS Cloud from Python, understood how we can control cloud operations using automation.
  prefs: []
  type: TYPE_NORMAL
- en: We gained a deep understanding about the role of controllers, and with some
    examples of Cisco controllers, went into details on how a controller can be programmed
    or called in programs/scripts to perform certain tasks. We also saw the basics
    of some popular network automation tools, such as SolarWinds, and created an in-house
    web-based automation tool for monitoring our network, called PingMatrix or PingMesh.
  prefs: []
  type: TYPE_NORMAL
