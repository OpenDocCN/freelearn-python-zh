- en: SDN Concepts in Network Automation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络自动化中的 SDN 概念
- en: As we have seen on our journey so far, there are numerous scenarios where we
    can automate a network, from daily or routine tasks, to managing infrastructure
    from a single controller-based architecture.  Building upon those concepts, we
    will now gain some additional insights for working in **software-defined networks**
    (**SDNs**) and look at some examples of working with cloud platforms.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们迄今为止所看到的，有许多场景可以自动化网络，从日常或常规任务，到从单一基于控制器的架构管理基础设施。在这些概念的基础上，我们将现在获得一些关于在
    **软件定义网络**（**SDNs**）中工作的额外见解，并查看一些与云平台一起工作的示例。
- en: 'Some of the key components we are going to cover are:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要介绍的一些关键组件包括：
- en: Cloud platform automation
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云平台自动化
- en: Network automation tools
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络自动化工具
- en: Controller-based network fabric
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于控制器的网络架构
- en: Programmable network devices
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可编程网络设备
- en: Managing cloud platforms
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理云平台
- en: We can use network automation techniques through Python to work on various cloud
    providers. From working on cloud instances, to spinning up new VMs, controlling
    full access like ACLs, and creating specific network layer tasks like VPNs, and
    network configurations of each instance, we can automate just about anything using
    available connectors or APIs in Python. Let's see some basic configuration and
    connections on the most popular cloud platform, **Amazon Web Services** (**AWS**)
    using Python.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过 Python 中的网络自动化技术来处理各种云提供商。从处理云实例，到启动新的虚拟机，控制完全访问，如 ACLs，以及创建特定网络层任务，如
    VPN 和每个实例的网络配置，我们可以使用 Python 中可用的连接器或 API 自动化几乎所有事情。让我们看看在最受欢迎的云平台 **Amazon Web
    Services**（**AWS**）上使用 Python 的一些基本配置和连接。
- en: AWS provides an extensive API through its SDK called Boto 3\. Boto 3 provides
    two types of APIs to be used, a low-level API set that is used to interact with
    direct AWS services, and a high-layer Python friendly API set for quick interactions
    with AWS. Along with Boto 3, we also would need to have the AWS CLI that is used
    as a **command-line interface** (**CLI**) to interact with AWS from the local
    machine. Think of this as a CLI based tool that is equally like DOS is to Windows
    from a CLI perspective.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: AWS 通过其 SDK Boto 3 提供了一个广泛的 API。Boto 3 提供两种类型的 API 供使用，一种用于与直接 AWS 服务交互的低级 API
    集合，以及一种用于与 AWS 快速交互的 Python 友好的高级 API 集合。除了 Boto 3 之外，我们还需要 AWS CLI，它用作 **命令行界面**（**CLI**）从本地机器与
    AWS 交互。从 CLI 角度来看，这就像 DOS 对 Windows 一样是一个基于 CLI 的工具。
- en: 'The installation of both the AWS CLI and Boto 3 is done using `pip`:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: AWS CLI 和 Boto 3 的安装都使用 `pip` 完成：
- en: 'To install from AWS CLI, use the following command:'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要从 AWS CLI 安装，请使用以下命令：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To install from Boto 3, use the following command:'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要从 Boto 3 安装，请使用以下命令：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Once installed, the packages are ready to use. However, we need to configure
    an access key in the AWS Web Management Console which will have a certain level
    of restrictions (that we will define while creating the access key).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，这些包就准备好使用了。然而，我们需要在 AWS 网络管理控制台中配置一个访问密钥，它将具有某种程度的限制（我们将在创建访问密钥时定义）。
- en: 'Let''s quickly set up a new access key to manage the AWS in Python from our
    local machine:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速设置一个新的访问密钥，以便从我们的本地机器管理 AWS：
- en: 'Log in to the AWS web console and select IAM as the option:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录 AWS 网络控制台，选择 IAM 选项：
- en: '![](img/d6dd3bb0-93e1-416b-b09b-dde6bf496236.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d6dd3bb0-93e1-416b-b09b-dde6bf496236.jpg)'
- en: 'Click on Add user to create a username and password pair shown as follows:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击添加用户以创建以下所示的用户名和密码对：
- en: '![](img/c34f5d6f-8428-4a07-b5db-5a6fd36980d4.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c34f5d6f-8428-4a07-b5db-5a6fd36980d4.jpg)'
- en: 'Select username and ensure to check Programmatic access to get the access ID
    and secret key to be used in our Python calls:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择用户名并确保勾选程序访问权限，以获取用于我们 Python 调用的访问 ID 和密钥：
- en: '![](img/201f9356-8f61-4288-8a8d-049d4ac83921.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/201f9356-8f61-4288-8a8d-049d4ac83921.jpg)'
- en: 'We also need the user to be part of a certain group (for security restrictions).
    In our case we make it part of the admin group which has full rights on the AWS
    instance:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要用户成为某个特定组的成员（出于安全限制）。在我们的例子中，我们将其设置为管理员组的成员，该组在 AWS 实例上拥有完全权限：
- en: '![](img/e6bc8d59-f148-4f45-8f9a-2fb4acf477ad.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e6bc8d59-f148-4f45-8f9a-2fb4acf477ad.jpg)'
- en: 'If we made our selections correctly, a user is created with the username we
    selected (`booktest`) with an access key and a secret access key:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们正确地选择了选项，将创建一个用户，用户名为我们选择的 (`booktest`)，并带有访问密钥和秘密访问密钥：
- en: '![](img/d2158071-32a0-469e-911e-fbc96cb771bf.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d2158071-32a0-469e-911e-fbc96cb771bf.jpg)'
- en: 'Once we have this key, we go back to our Python installation and on the Command
    Prompt, call the AWS CLI command `aws configure`:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们有了这个密钥，我们就回到我们的Python安装，在命令提示符下调用AWS CLI命令`aws configure`：
- en: '![](img/b067f6ad-1546-486b-b4d8-baf6c6038c1d.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b067f6ad-1546-486b-b4d8-baf6c6038c1d.jpg)'
- en: As per the questions asked, we fetch the values from the AWS web console and
    paste them in the CLI. The final question of `Default output format` can be `text`
    or `json`. However, for our purpose of automation and working with Python, we
    would select `json` instead of `text`.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据提出的问题，我们从AWS网络控制台获取值并将其粘贴到CLI中。`默认输出格式`可以是`text`或`json`。然而，为了我们的自动化目的和与Python一起工作，我们会选择`json`而不是`text`。
- en: Once we are done with this backend configuration, we are ready to test our scripts
    by calling the Boto 3 API in Python.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成了这个后端配置，我们就可以通过在Python中调用Boto 3 API来测试我们的脚本。
- en: 'Let''s see an example of getting all running instances on the current AWS account
    for which we have the key:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看获取当前AWS账户中所有运行实例的示例，其中我们拥有密钥：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Since we have already configured the backend credentials and key with the `aws
    configure` CLI command, we do not need to specify any credentials in our scripts.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已通过`aws configure` CLI命令配置了后端凭据和密钥，因此我们不需要在我们的脚本中指定任何凭据。
- en: 'The output of the preceding code is as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '![](img/0ab7156c-653b-4bbf-9abc-0da74b8ae3a2.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0ab7156c-653b-4bbf-9abc-0da74b8ae3a2.jpg)'
- en: 'As we see in the preceding output, we get back two instances which are EC2
    instances with their instance IDs. Additionally, we also get some other parameters
    for the currently configured instances. In some cases, if we do not want to use
    the current preconfigured keys, we can call the Python program by passing the
    values directly into Boto 3 functions as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的输出中看到的，我们得到了两个实例，它们是具有其实例ID的EC2实例。此外，我们还得到了一些当前配置实例的其他参数。在某些情况下，如果我们不想使用当前的预配置密钥，我们可以通过以下方式直接将值传递给Boto
    3函数来调用Python程序：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s see another example of fetching the private IP address and instance
    ID for each of the instances:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看获取每个实例的私有IP地址和实例ID的另一个示例：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The preceding code gives the following output:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码给出了以下输出：
- en: '![](img/e72a2534-f0bc-4b04-8209-2037ee842087.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e72a2534-f0bc-4b04-8209-2037ee842087.jpg)'
- en: Using the Boto 3 API, we can also spin up new instances in our subscription. Let's
    see a final example of spinning up a new **Virtual Machine**(**VM**) with EC2
    using Boto 3.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Boto 3 API，我们也可以在我们的订阅中启动新的实例。让我们看看使用Boto 3启动一个新的**虚拟机**（**VM**）的最终示例。
- en: 'Before we call the Python to spin a new VM, we need to select which **Amazon
    Machine Image** (**AMI**) image to use for the instance. To find out the AMI image
    value, we need to open AMI in the AWS web console shown as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们调用Python来启动新的VM之前，我们需要选择用于实例的哪个**亚马逊机器镜像**（**AMI**）图像。要找出AMI图像值，我们需要打开如以下所示的AWS网络控制台中的AMI：
- en: '![](img/b89b8f02-0d74-4548-968d-aa99cb7e16ce.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b89b8f02-0d74-4548-968d-aa99cb7e16ce.jpg)'
- en: 'Once we have finalized the AMI, we call the easy part, spinning the new VM:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成了AMI的最终确定，我们就进入了简单的部分，即启动新的VM：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It will take some time for the script to execute, and the result value would
    be the instance with all its configured parameters based upon the AMI image ID
    selected. Similarly, we can spin up various type of instances or even new security
    filters using Boto 3 and ensure we have cloud controlling automation in place.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本执行需要一些时间，结果值将是基于所选AMI图像ID配置的所有参数的实例。同样，我们可以使用Boto 3启动各种类型的实例，甚至可以启动新的安全过滤器，并确保我们拥有云控制自动化。
- en: Programmable network devices
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可编程网络设备
- en: Looking back at historic implementations, we had a fixed set of hardware or
    networks geared for catering services to the end users. End users also had a limited
    set of connection options to access a limited set of networks or connected resources. As
    the number of users increased, a simple solution was to add additional hardware
    or network gear. However, with the surge of different end user devices, such as
    mobile phones, and high data demand and up time requirements for end users, managing
    the increasing amount of hardware and additional connections becomes a complex
    task.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾历史实现，我们有一套固定的硬件或网络，专为向最终用户提供服务而设计。最终用户也有有限的连接选项来访问有限的网络或连接资源。随着用户数量的增加，一个简单的解决方案是添加额外的硬件或网络设备。然而，随着不同终端用户设备（如手机）的激增，以及最终用户对高数据需求和正常运行时间的要求，管理不断增加的硬件和额外连接变得复杂。
- en: A simple device failure or cable failure might impact the entire set of connected
    hardware or network gears, which would create a widespread downtime for end users,
    resulting in a loss of man hours both in terms of productivity and trust. Think
    of a large **internet service provider** (**ISP**) with recurring outages, with
    each outage affecting a large set of both enterprise and home users. If a new
    ISP were to enter the market with reliability as its unique selling point, people
    would not think twice before jumping to the new provider. Effectively, this could
    result in a loss of business and ultimately, a closure situation for the earlier
    provider because of the decreasing reliability and trust among its current set
    of users.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的设备故障或电缆故障可能会影响整个连接的硬件或网络设备，这将为最终用户造成广泛的中断，导致生产力和信任度下降。想象一下，一个大型**互联网服务提供商**（**ISP**）频繁出现故障，每次故障都会影响大量企业和家庭用户。如果一个新的ISP带着可靠性作为其独特的卖点进入市场，人们将毫不犹豫地跳转到新的提供商。实际上，这可能导致业务损失，最终，由于当前用户群中可靠性和信任度的下降，导致早期提供商关闭。
- en: To handle this type of situation, one solution that has emerged is the usability
    of the same set of devices or network hardware to perform different functions
    using the same hardware platform. This has been made possible through a combination
    of SDNand **programmable networks** (**PNs**).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理这种情况，出现了一种解决方案，即使用同一套设备或网络硬件，在相同的硬件平台上执行不同的功能。这是通过SDN和**可编程网络**（**PNs**）的组合实现的。
- en: SDN takes care of control plane configurations for data to automatically reroute
    to a path that is the best available for a specific source to the destination.
    For example, let's say we need to reach destination D from source A. The best
    path to reach D is A -> C -> D.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: SDN负责控制平面配置，以便数据能够自动重新路由到从特定源到目的地的最佳可用路径。例如，假设我们需要从源A到达目的地D。到达D的最佳路径是A -> C
    -> D。
- en: Now, in the case of legacy traffic flow, unless C is down or practically shut,
    the traffic will not flow from A -> B -> D (unless special complex configurations
    are done on each network gear/device). In an SDN environment, using OpenFlow as
    the underlying protocol, the controller will detect any issues in the path of
    A -> C -> D, and based upon certain issues (like packet drop or congestion in
    the path), would make an intelligent decision to ensure there is a new path for
    the data to flow from A -> B -> D.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在处理传统流量流的情况下，除非C出现故障或实际上关闭，否则流量不会从A -> B -> D流动（除非在每个网络设备/设备上执行特殊的复杂配置）。在SDN环境中，使用OpenFlow作为底层协议，控制器将检测A
    -> C -> D路径上的任何问题，并根据某些问题（如路径中的数据包丢失或拥塞），做出智能决策，确保有新的路径让数据从A -> B -> D流动。
- en: As we see in this case, even with no physical issues on C, SDN already takes
    care of identifying the best path for the data to flow on, which effectively results
    in the best achievable performance for end users with reliability.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在本例中看到的那样，即使C没有物理问题，SDN也已经负责确定数据流动的最佳路径，这有效地实现了对最终用户来说最佳的可实现性能，并且具有可靠性。
- en: 'PN is an addition which is a collection of hardware devices in the network
    layer that can be programmed to behave in a different way based upon the requirements.
    Think of a switch acting as a router by changing its functionality through a written
    piece of code. Let''s say we get an influx of new end users and we need to have
    a high switching capacity in the network layer. Some of the devices can now act
    as a switch rather than a router. This ensures a two-fold benefit:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: PN是一个补充，它是一组网络层的硬件设备，可以根据需求编程以不同的方式行为。想象一下，一个交换机通过编写一段代码来改变其功能，充当一个路由器。假设我们迎来了大量新的终端用户，并且需要在网络层拥有高交换能力。一些设备现在可以充当交换机而不是路由器。这确保了两方面的好处：
- en: Using the same set of hardware based upon the demand and requirements, the hardware
    can be reused to handle new scenarios without introducing more complexity into
    the network by adding an additional set of hardware.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据需求和需求使用同一套硬件，硬件可以重用于处理新的场景，而不会通过添加额外的硬件集来增加网络的复杂性。
- en: Better control over the flow of traffic with the additional capability of securing
    traffic through the same set of devices. This is introduced by adding ACLs for
    traffic to flow from a certain set of devices, and even ensuring that a device
    handles only a particular type of traffic and sends the remaining traffic to other
    devices that are specifically programmed to handle that particular traffic. Think
    of it, as video with voice traffic going from a different set of devices to ensure
    optimal performance and load on specific devices using the same set of hardware
    that we currently have.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过增加通过同一组设备安全传输流量的额外能力，更好地控制流量。这是通过为从一组特定设备流向流量的流量添加ACLs来实现的，甚至确保设备只处理特定类型的流量，并将剩余流量发送到专门编程以处理该特定流量的其他设备。想象一下，视频和语音流量从不同的设备流向，以确保使用我们目前拥有的相同硬件在特定设备上实现最佳性能和负载。
- en: A major component of PNs (the collective name for programmable network devices),
    is the use of APIs that are provided by various network vendors like Cisco, Arista,
    and Juniper. By calling these APIs we can ensure that each of the devices from
    specific vendors can easily talk to each other (exchange information is a unified
    format), and can change the behavior of a specific hardware based upon the API
    calls. One example that is common in today's market is Cisco Nexus 9000 series
    devices. These are modular or fixed switches (with different variations), and
    by using OpenFlow gives us the ability to programmatically alter their behavior
    based upon dynamic requirements.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 可编程网络设备（PNs）的一个主要组成部分是使用由各种网络供应商（如Cisco、Arista和Juniper）提供的API。通过调用这些API，我们可以确保来自特定供应商的每个设备可以轻松地相互通信（以统一格式交换信息），并且可以根据API调用改变特定硬件的行为。在当今市场上一个常见的例子是Cisco
    Nexus 9000系列设备。这些是模块化或固定交换机（具有不同的变体），通过使用OpenFlow，我们能够根据动态需求以编程方式改变它们的行为。
- en: Taking this switch as an example, direct access to **application-specific integrated
    circuit** (**ASIC**) chip-level programming is also exposed, which ensures that
    the ASICs can also be programmed based upon the requirement along with the software-level
    variations. With SDN in place, controllers can take advantage of OpenFlow and
    the APIs exposed on these switches to control the role of these switches.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以这个开关为例，直接访问**专用集成电路**（**ASIC**）芯片级编程也被暴露出来，这确保了ASIC也可以根据需求以及软件级别的变化进行编程。在SDN部署的情况下，控制器可以利用OpenFlow以及这些交换机上暴露的API来控制这些交换机的角色。
- en: Cisco also provides a **Power on Auto Provisioning** (**PoAP**) feature to multiple
    devices (primarily on the Nexus platform) that helps achieve auto provisioning
    and commissioning as soon as a new device boots. A basic overview of this process
    is, if a Nexus device with the PoAP feature enabled boots and is unable to find
    any startup config, it locates a **Dynamic Host Configuration Protocol** (**DHCP**)
    server in the network and bootstraps using the IP address and DNS information
    obtained from that DHCP server. It also fetches a customized script that is executed
    on the device that has instructions to download and install the relevant software
    image files and specific configurations for that device.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Cisco还为多个设备（主要在Nexus平台上）提供了一种**电源开启自动配置**（**PoAP**）功能，这有助于在新的设备启动时立即实现自动配置和部署。这个过程的基本概述是，如果一个启用了PoAP功能的Nexus设备启动后无法找到任何启动配置，它将在网络中定位一个**动态主机配置协议**（**DHCP**）服务器，并使用从该DHCP服务器获得的IP地址和DNS信息进行引导。它还会获取一个在设备上执行的定制脚本，该脚本包含下载和安装相关软件映像文件以及该设备的特定配置的指令。
- en: A big advantage of this type of feature is that we can spin up new devices within
    one to two minutes by just powering it up and connecting it to a network which
    has DHCP functionality to fetch relevant information to new devices in the network.
    Think of the legacy way of bringing a router live with multiple hours of human
    intervention versus the current way of booting up a router, and the router taking
    care of itself without any human intervention.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型功能的一个大优势是，我们只需打开电源并将其连接到具有DHCP功能以获取网络中新设备相关信息的网络，就可以在一到两分钟内启动新设备。想象一下，与需要数小时人工干预的传统方式相比，现在启动路由器的方式，路由器无需任何人工干预就能自行处理。
- en: Similarly, using the APIs (**NX-API** is the underlying terminology used for
    **Nexus API**), better visibility in terms of packet flow and monitoring is also
    being exposed from Cisco, and, using simple scripts written in any language (like
    Python), the path and flow of traffic can be modified based upon the results returned
    back through the call of those APIs.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，使用 API（**NX-API** 是用于 **Nexus API** 的底层术语），Cisco 也提供了关于数据包流和监控的更好可见性，并且可以使用任何语言（如
    Python）编写的简单脚本，根据通过调用这些 API 返回的结果修改路径和流量。
- en: Taking another example, we have network device vendor Arista. Arista has introduced
    Arista **Extensible Operating System** (**EOS**), which is a highly modular and
    Linux-based network OS. Using Arista EOS, managing multiple devices becomes easy
    as it has the ability to provide extensive APIs (Linux kernel-based and additional
    ones related to Arista), and call APIs for various vendors to configure and deploy
    numerous end nodes. A feature introduced by Arista called **Smart System Upgrade**
    (**SSU**), ensures that as we perform OS upgrades on Arista devices, it restarts
    its services with the upgraded OS versions but without rebooting to ensure minimal
    traffic interruption during upgrades. These features ensure that we have resiliency
    and up time even when we have new patches and OS upgrades rolled out on the data
    centers or multiple devices at once.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以另一个例子为例，我们有一个网络设备供应商 Arista。Arista 引入了 Arista **可扩展操作系统**（EOS），这是一个高度模块化和基于
    Linux 的网络操作系统。使用 Arista EOS，管理多个设备变得容易，因为它具有提供广泛 API（基于 Linux 内核和与 Arista 相关的附加
    API）的能力，并调用 API 为各种供应商配置和部署多个终端节点。Arista 引入的一个名为 **智能系统升级**（SSU）的功能确保，当我们对 Arista
    设备进行操作系统升级时，它将使用升级的操作系统版本重新启动其服务，但不会重启，以确保在升级期间最小化流量中断。这些功能确保即使在数据中心或多个设备上同时推出新的补丁和操作系统升级时，我们也有弹性和正常运行时间。
- en: Arista EOS provides extended functionality for the devices to be managed through
    APIs by providing a set of APIs call **eAPI**. eAPI can be used to configure Arista
    devices by calling the eAPI framework from any scripting or programmable language.
    Let's see a very basic example of how to manage an Arista switch using eAPI.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Arista EOS 通过提供一套 API 调用 **eAPI** 来为通过 API 管理的设备提供扩展功能。eAPI 可以通过从任何脚本或可编程语言中调用
    eAPI 框架来配置 Arista 设备。让我们看看如何使用 eAPI 管理一个 Arista 交换机的非常基本的例子。
- en: 'We need to configure eAPI on the Arista switch:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在 Arista 交换机上配置 eAPI：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This ensures that the Arista eAPI functionality is enabled on the router, and
    we can use HTTP protocol to interact with the API. We can also switch between
    the options of eAPI available over HTTPS, by using the command `protocol https`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这确保了 Arista eAPI 功能在路由器上已启用，我们可以使用 HTTP 协议与 API 进行交互。我们还可以通过使用命令 `protocol https`
    在 HTTPS 上可用的 eAPI 选项之间切换。
- en: 'To verify if our configuration is correct, we use the command `show management
    api http-commands`, as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证我们的配置是否正确，我们使用命令 `show management api http-commands`，如下所示：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We can check if the eAPI framework is now accessible using the browser command
    `http://<ip of router>`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用浏览器命令 `http://<路由器IP>` 来检查 eAPI 框架是否现在可以访问。
- en: 'A couple of examples from Arista depict the output that we get using the URL
    (in this case we have HTTPS enabled instead of HTTP):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Arista 的一些例子展示了我们使用 URL（在这种情况下我们启用了 HTTPS 而不是 HTTP）得到的输出：
- en: '![](img/8f8c0913-3109-4155-98bc-94f1f4da9513.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8f8c0913-3109-4155-98bc-94f1f4da9513.jpg)'
- en: 'Here we see a set of commands passed (`show version` and `show hostname`),
    and the response from the API confirms the result set. Additionally, the Command
    Response Documentation tab shows us the available APIs that can be used for reference:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到一组传递的命令（`show version` 和 `show hostname`），API 的响应确认了结果集。此外，命令响应文档选项卡显示了我们可以用于参考的可用
    API：
- en: '![](img/8693d414-a4dc-4b05-b348-f0e4ab76c21e.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8693d414-a4dc-4b05-b348-f0e4ab76c21e.jpg)'
- en: 'Let''s see how to call the same in Python:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在 Python 中调用相同的操作：
- en: 'As a prerequisite we need to install `jsonrpclib`, which can be found at URL [https://pypi.python.org/pypi/jsonrpclib. ](https://pypi.python.org/pypi/jsonrpclib)This is
    used to parse the **remote procedure call** (**RPC**) in JSON format. Once done,
    the following code will result in the same set of values that we got using the
    browser:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 作为先决条件，我们需要安装 `jsonrpclib`，可以在 URL [https://pypi.python.org/pypi/jsonrpclib.](https://pypi.python.org/pypi/jsonrpclib)
    找到。这个库用于解析 JSON 格式的 **远程过程调用**（RPC）。一旦完成，以下代码将产生与使用浏览器得到相同的一组值：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The preceding code gives the following output:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码给出了以下输出：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In a similar way, Arista has also introduced a library for Python that can be
    used as an alternate to `jsonrpclib`. The library `pyeapi`, which can be found
    at URL [https://pypi.python.org/pypi/pyeapi, ](https://pypi.python.org/pypi/pyeapi)is
    a Python wrapper for the Arista EOS eAPI. Going by the example, here is how we
    can access the same set of devices using `pyeapi`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式，Arista也引入了一个Python库，可以作为`jsonrpclib`的替代品。可以在URL [https://pypi.python.org/pypi/pyeapi](https://pypi.python.org/pypi/pyeapi)找到的`pyeapi`库，是Arista
    EOS eAPI的Python包装器。按照示例，以下是使用`pyeapi`访问相同设备集的方法。
- en: 'From the developer page, here is an example that depicts how we can use `pyeapi`
    for API handling on Arista:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 从开发者页面，这里有一个示例，展示了我们如何使用`pyeapi`在Arista上进行API处理：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Looking at both Cisco and Arista (which are two major players in the cloud and
    SDN marketplace), we can combine both Arista eAPI and Cisco NX-API to manage our
    entire data center inventory, and work on some tasks like the provisioning of
    new devices or upgrading of current devices with no or minimal impact, which in
    turn ensures scalability, reliability, and uptime in the business processes.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 观察Cisco和Arista（它们是云和SDN市场的主要参与者），我们可以结合Arista eAPI和Cisco NX-API来管理我们的整个数据中心库存，并在一些任务上工作，如新设备的提供或现有设备的升级，这些任务对业务流程的影响最小或没有影响，从而确保可扩展性、可靠性和正常运行时间。
- en: Controller-based network fabric
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于控制器的网络布线
- en: As we come out of the legacy hardware era in which each physical path was connected
    and designed to take traffic from one point to another, and where a packet had
    limited availability to reach from one device to another, SDN is ensuring that
    we have a network fabric for our data to reach between different sources and destinations.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们走出每个物理路径都是连接和设计用来从一个点到另一个点传输流量的传统硬件时代，以及数据包从一台设备到达另一台设备的可用性有限，SDN确保我们有网络布线，以便我们的数据在源和目的地之间传输。
- en: A **network fabric** is a collection of different network devices connected
    to each other by a common controller ensuring that each component in the network
    is optimized to send traffic among each of the nodes. The underlying switch fabric,
    which is a physical switchboard with ports (like Ethernet, ATM, and DSL), is also
    controlled and programmed by a controller which can ensure (by creating a path
    or specific port(s)) that a particular type of data can traverse through to reach
    its destinations.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**网络布线**是一组通过一个共同的控制器连接在一起的不同网络设备，确保网络中的每个组件都优化了发送流量到每个节点的性能。底层的交换布线，即带有端口（如以太网、ATM和DSL）的物理交换板，也由控制器控制和编程，可以确保（通过创建路径或特定的端口）特定的数据类型可以穿越到达到其目的地。'
- en: In a typical network design we have Layer 2 (or switching domains) and Layer
    3 (or routing domains). If we do not have a controller-based approach, each network
    component can learn the behavior of traffic from its next connected component
    (like **Spanning Tree Protocol** (**STP**) for Layer 2) or some routing protocol
    (like OSPF for Layer 3). In this case, each device acts as its own controller
    and only has limited visibility to devices that it is directly connected to (also
    termed **neighbor devices**). There is no single view of the entire network on
    any device, and additionally, each component (or individual controller) acts as
    a single point of failure for its neighbor devices. A failure on any component
    would result in its neighbor devices re converging or even getting isolated owing
    to the failure of their connected component.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的网络设计中，我们有第2层（或交换域）和第3层（或路由域）。如果我们没有基于控制器的方案，每个网络组件都可以从其下一个连接的组件学习流量的行为（如第2层的**生成树协议**（**STP**））或某些路由协议（如第3层的OSPF）。在这种情况下，每个设备都充当自己的控制器，并且只能有限地看到它直接连接的设备（也称为**邻居设备**）。在任何设备上都没有整个网络的单一视图，并且此外，每个组件（或单个控制器）都充当其邻居设备的单点故障。任何组件的故障都可能导致其邻居设备重新收敛，甚至由于连接组件的故障而隔离。
- en: Comparing that to a controller-based environment, theoretically each device
    has as many connections as it has number of ports connected. Hence, if we think
    of even three devices connected in a controller-based environment, we have multiple
    connections between each device owing to their physical connectivity to each other.
    In case of the failure of a component (or device), the controller can quickly
    make an intelligent decision to reconfigure a new path and alter the behavior
    of the other two network devices to ensure minimal disruption to traffic, keeping
    the same throughput and distributed load on all the other available links. A controller
    in theory eliminates the control plane behavior of each device and ensures an
    optimized forwarding table (to forward data to specific destinations) is updated
    on each device the controller is managing. This is because the controller starts
    acting as the main component which has the visibility of every device, with every
    entry and exit point of each device and the granularity of the data type that
    is flowing from each managed network device.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 与基于控制器的环境相比，理论上每个设备拥有的连接数与其连接的端口数相同。因此，如果我们考虑在基于控制器的环境中连接的三个设备，由于它们之间的物理连接，每个设备之间都有多个连接。在组件（或设备）故障的情况下，控制器可以迅速做出智能决策，重新配置新路径，并改变其他两个网络设备的行为，以确保对交通的最小干扰，保持所有其他可用链路上的相同吞吐量和分布式负载。从理论上讲，控制器消除了每个设备的控制平面行为，并确保控制器管理的每个设备上更新了优化的转发表（用于将数据转发到特定目的地）。这是因为控制器开始充当主要组件，它可以看到每个设备，包括每个设备的每个入口和出口点以及从每个受管理的网络设备流过的数据类型的粒度。
- en: Going by the vendors, major players such as Cisco (with its open network environment),
    Juniper (with its QFabric switch), and Avaya (with its VENA switch), have provided
    the ability to act as controllers or be configured to be managed by a controller.
    Additionally, with the introduction of controller-to-manager network components,
    each network device can now virtually become a dump client with the controller
    making all the intelligent decisions, from learning to forwarding tables.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 根据厂商，像思科（拥有其开放网络环境）、瞻博网络（拥有其QFabric交换机）和艾维雅（拥有其VENA交换机）这样的主要厂商已经提供了充当控制器或配置为被控制器管理的功能。此外，随着控制器到管理器网络组件的引入，每个网络设备现在可以虚拟地成为客户端，控制器做出所有智能决策，从学习到转发表。
- en: A controller acts as an abstraction layer between multi-vendor network devices
    and network tasks. As an end user, someone can configure specific tasks to be
    performed by the controller, and, using the underlying API model from different
    vendors (using JSON or XML), the controller can convert those specific tasks into
    various vendor-specific API calls, and devices can be configured by sending those
    specific instructions using those APIs to each of the vendor devices. The **Application
    Policy Infrastructure Controller** (**APIC**) component is responsible for controlling
    and programming the fabric on each network device component.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器充当多厂商网络设备和网络任务之间的抽象层。作为终端用户，某人可以配置控制器执行的具体任务，并且，使用来自不同厂商的底层API模型（使用JSON或XML），控制器可以将这些具体任务转换为各种厂商特定的API调用，通过使用这些API向每个厂商设备发送这些具体指令来配置设备。**应用策略基础设施控制器**（**APIC**）组件负责控制和编程每个网络设备组件上的布线。
- en: Let's see an example of Cisco APIC and some basics on how we can use it. Cisco
    APIC is used to manage, automate, monitor, and program **Application Centric Infrastructure**
    (**ACI**). ACI is a collection of objects with each object representing a tenant.
    A tenant can be called a group of specific customers, groups, or business units
    based upon the business classifications. As an example, a single organization
    may covert its entire infrastructure into a single tenant, whereas an organization
    can separate out its tenants based upon its functions like HR and Finance. Tenants
    can further be divided into contexts, with each context as a separate forwarding
    plane, hence the same set of IP addresses can be used in each context as each
    set of IP addresses will be treated differently in each context.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Cisco APIC的示例以及一些基本用法。Cisco APIC用于管理、自动化、监控和编程**应用中心基础设施**（**ACI**）。ACI是一组对象，每个对象代表一个租户。租户可以称为基于业务分类的特定客户群、组或业务单元。例如，一个单一的组织可能将其整个基础设施转换为一个单一租户，而一个组织可以根据其功能（如HR和财务）将租户分离出来。租户可以进一步细分为上下文，每个上下文作为一个单独的转发平面，因此每个上下文中都可以使用相同的IP地址集，因为在每个上下文中，IP地址集将被不同地处理。
- en: Contexts contain **Endpoints** (**EPs**) and **Endpoint Groups** (**EPGs**).
    These EPs are physical components like hardware NICs, and EPGs are collections
    of items like DNSs, IP addresses, and so on, that dictate a similar functionality
    for a specific application (like a web application).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文中包含**端点**（**EPs**）和**端点组**（**EPGs**）。这些EPs是物理组件，如硬件NICs，而EPGs是DNSs、IP地址等项目的集合，它们为特定应用程序（如Web应用程序）定义了类似的功能。
- en: 'For programming with APIC, the major components required are as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 使用APIC进行编程时，所需的主要组件如下：
- en: '**APIC Rest Python Adaptor** (**ARYA**)'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**APIC Rest Python Adaptor**（**ARYA**）'
- en: This is a tool created by Cisco to convert the APIC object returned in XML or
    JSON to direct Python code. Underlying, this leverages the COBRA SDK to perform
    this task. This can be installed in Python using `pip install arya`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个由Cisco创建的工具，用于将APIC返回的XML或JSON对象转换为直接Python代码。在底层，它利用COBRA SDK执行此任务。这可以通过`pip
    install arya`在Python中安装。
- en: '**ACI SDK**'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ACI SDK**'
- en: This is the SDK that contains the API to directly call the APIs of the controller.
    We need to install `acicobra`, which can be found at [https://www.cisco.com/c/en/us/td/docs/switches/datacenter/aci/apic/sw/1-x/api/python/install/b_Install_Cisco_APIC_Python_SDK_Standalone.html, ](https://www.cisco.com/c/en/us/td/docs/switches/datacenter/aci/apic/sw/1-x/api/python/install/b_Install_Cisco_APIC_Python_SDK_Standalone.html)from
    Cisco to be able to call it into Python.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个包含直接调用控制器API的API的SDK。我们需要安装`acicobra`，可以在以下网址找到：[https://www.cisco.com/c/en/us/td/docs/switches/datacenter/aci/apic/sw/1-x/api/python/install/b_Install_Cisco_APIC_Python_SDK_Standalone.html](https://www.cisco.com/c/en/us/td/docs/switches/datacenter/aci/apic/sw/1-x/api/python/install/b_Install_Cisco_APIC_Python_SDK_Standalone.html)，以便将其调用到Python中。
- en: 'Once we have this installed, here are some examples from Cisco which can be
    found at the URL [https://github.com/CiscoDevNet/python_code_samples_network/blob/master/acitoolkit_show_tenants/aci-show-tenants.py.](https://github.com/CiscoDevNet/python_code_samples_network/blob/master/acitoolkit_show_tenants/aci-show-tenants.py)
    This can help us understand creating an object:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了此软件，以下是一些来自Cisco的示例，可以在以下网址找到：[https://github.com/CiscoDevNet/python_code_samples_network/blob/master/acitoolkit_show_tenants/aci-show-tenants.py](https://github.com/CiscoDevNet/python_code_samples_network/blob/master/acitoolkit_show_tenants/aci-show-tenants.py)。这可以帮助我们理解创建对象：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Looking at the preceding concepts, we can enhance and ensure that our managed
    nodes in the controller can be controlled based on the application requirements
    rather than hardware limitations. This also ensures that the infrastructure is
    now tweaked as per application, and not vice versa, with the application performance
    restricted by hardware.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '在考虑前面的概念时，我们可以增强并确保控制器中的管理节点可以根据应用程序需求进行控制，而不是受硬件限制。这也确保了基础设施现在根据应用程序进行调整，而不是相反，应用程序性能受硬件限制。 '
- en: Network automation tools
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络自动化工具
- en: As we have seen throughout the previous chapters, we have multiple choices regarding
    automating a network. From a basic configuration for any device using Netmiko
    to deploying and creating configurations across various devices in a network using
    Ansible,there are many options for engineers to automate networks based upon various
    needs.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几章所述，我们在自动化网络方面有多种选择。从使用Netmiko为任何设备进行基本配置，到使用Ansible在网络中的各种设备上部署和创建配置，工程师们有许多选项可以根据不同的需求自动化网络。
- en: Python is extensively used in creating automation scenarios, owing to its open
    community support for various vendors and protocols. Nearly every major player
    in the industry has support for Python programming, tweaking their own tools or
    any supporting technology that they have. Another major aspect of network automation
    are the custom-based solutions that could be made for organization requirements.
    The self-service API model is a good start to ensuring that some of the tasks
    that are done manually can be converted to APIs, which can then be leveraged into
    any language based upon the automation needs.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Python 在创建自动化场景中被广泛使用，这得益于其对各种厂商和协议的开放社区支持。行业中的几乎每个主要参与者都支持 Python 编程，调整他们自己的工具或任何支持技术。网络自动化的另一个主要方面是为组织需求定制的解决方案。自服务
    API 模型是一个很好的起点，确保一些手动完成的任务可以转换为 API，然后可以根据自动化需求利用任何语言。
- en: Let's see an example that can be used as a basic guide to understand the advantage
    of self or custom-created automation tools. The output of `show ip bgp summary`
    in Cisco is the same as `show bgp summary` in Juniper. Now, as an engineer who
    needs to validate the BGP on both the vendors, I need to understand both the commands
    and interpret the output.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个可以作为基本指南的示例，以了解自建或自定义自动化工具的优势。在 Cisco 中 `show ip bgp summary` 的输出与在 Juniper
    中 `show bgp summary` 的输出相同。现在，作为一个需要验证两个厂商 BGP 的工程师，我需要理解这两个命令并解释输出。
- en: Think of this situation by adding more vendors which have their own unique way
    of fetching BGP output. This becomes complex and a network engineer needs to be
    trained on a multi-vendor environment to be able to fetch the same type of output
    from each vendor.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，通过添加更多具有自己独特方式获取 BGP 输出的厂商，这会变得复杂，网络工程师需要接受多厂商环境的培训，以便能够从每个厂商获取相同类型的输出。
- en: Now, let's say we create an API (for example, `getbgpstatus`), which takes the
    input as some hostname. The API at the backend is intelligent enough to fetch
    the vendor model using SNMP, and based upon the vendor sends a specific command
    (like `show ip bgp summary` for Cisco or `show ip summary` for Juniper), and parses
    that output to a human-readable format, like only the IP address and status of
    that BGP neighbor.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们创建一个 API（例如，`getbgpstatus`），它接受主机名作为输入。后端的 API 足够智能，能够使用 SNMP 获取厂商型号，并根据厂商发送特定的命令（如
    Cisco 的 `show ip bgp summary` 或 Juniper 的 `show ip summary`），并将该输出解析为人类可读的格式，例如仅包含该
    BGP 邻居的 IP 地址和状态。
- en: 'For example, instead of printing the raw output of `show ip bgp summary` or
    `show bgp summary`, it parses the output like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们不是打印 `show ip bgp summary` 或 `show bgp summary` 的原始输出，而是像这样解析输出：
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This output can be returned as a JSON value back to the call of the API.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 此输出可以作为 JSON 值返回到 API 的调用中。
- en: Hence, let's say we can call the API as `http://localhost/networkdevices/getbgpstatus?device=devicex`
    and the API from the backend will identify if `devicex` is Juniper or Cisco or
    any other vendor, and based upon this the vendor will fetch and parse the output
    relevant to that vendor. A return of that API call will be JSON text as we saw
    in the preceding example, that we can parse in our automation language.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，假设我们可以通过 `http://localhost/networkdevices/getbgpstatus?device=devicex` 调用
    API，后端的 API 将识别 `devicex` 是 Juniper、Cisco 还是其他厂商，并根据这一点，该厂商将获取并解析与该厂商相关的输出。该 API
    调用的返回将是类似于前面示例中的 JSON 文本，我们可以在我们的自动化语言中解析它。
- en: Let us see a basic example of another popular tool, SolarWinds. There are many
    aspects of SolarWinds; it can auto-discover a device (based upon MIBs and SNMP),
    identify the vendor, and fetch relevant information from the device.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一个流行工具 SolarWinds 的基本示例。SolarWinds 有许多方面；它可以自动发现设备（基于 MIBs 和 SNMP），识别厂商，并从设备中获取相关信息。
- en: Let's see some of the following screenshots for basic SolarWinds device management.
    SolarWinds is freely available as a trial download.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下截图，了解基本的 SolarWinds 设备管理。SolarWinds 作为试用版免费提供下载。
- en: 'The prerequisite for SolarWinds device management is as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: SolarWinds 设备管理的先决条件如下：
- en: 'We need to add a device in SolarWinds, shown as below:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在 SolarWinds 中添加一个设备，如下所示：
- en: '![](img/d9163428-3e8e-45d1-aad5-c056a4ba0d2e.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d9163428-3e8e-45d1-aad5-c056a4ba0d2e.jpg)'
- en: As we can see, SolarWinds has the ability to discover devices (using network
    discovery), or we can add a specific IP address/hostname with the correct SNMP
    string for SolarWinds to detect the device.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，SolarWinds 有能力发现设备（使用网络发现），或者我们可以添加一个特定的 IP 地址/主机名，并使用正确的 SNMP 字符串，以便
    SolarWinds 识别该设备。
- en: 'Once the device is detected it will show as the monitored node, as in the below
    screenshot:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦设备被检测到，它将显示为监控节点，如下面的屏幕截图所示：
- en: '![](img/8bc6e99c-2d59-43d2-baee-ddd63462bdf9.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8bc6e99c-2d59-43d2-baee-ddd63462bdf9.jpg)'
- en: Notice the green dot next to the IP address (or hostname). This signifies that
    the node is alive (reachable) and SolarWinds can interact with the node correctly.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 注意IP地址（或主机名）旁边的绿色点。这表示节点是活跃的（可到达的），SolarWinds可以正确地与节点交互。
- en: '**Additional task(s) that can be performed post device discovery is as follows:**'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**在设备发现之后可以执行的其他任务如下：**'
- en: 'Once we have the node available or detected in SolarWinds, here are some of
    the additional tasks that can be performed in SolarWinds (as shown in screenshot
    below):'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在SolarWinds中有了可用的节点或检测到的节点，以下是一些在SolarWinds中可以执行的其他任务（如下面的屏幕截图所示）：
- en: '![](img/2be18c1d-a31d-4045-8593-d0a06638e4e8.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2be18c1d-a31d-4045-8593-d0a06638e4e8.jpg)'
- en: 'We have selected the CONFIGS menu, under which we can perform config management
    for the devices. Additionally, as we can see in the following screenshot, we have
    the ability to create small scripts, (like we did here to `show running config`),
    which we can use to execute against a certain set of devices from SolarWinds itself
    (as in screenshot below):'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已选择CONFIGS菜单，在该菜单下我们可以对设备执行配置管理。此外，如以下屏幕截图所示，我们还有创建小脚本的能力（就像我们在这里对`show running
    config`所做的那样），我们可以使用这些脚本在SolarWinds本身针对一组特定的设备执行（如下面的屏幕截图所示）：
- en: '![](img/e4aaef49-e77f-4c58-957e-8899d6f19977.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e4aaef49-e77f-4c58-957e-8899d6f19977.jpg)'
- en: 'The result is retrieved and can be stored as a text file, or can even be sent
    as a report back to any email client if configured. Similarly, there are certain
    tasks (called **jobs** in SolarWinds), that can be done on a scheduled basis,
    as we can see in the following screenshot:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 检索到的结果可以存储为文本文件，或者如果配置了，甚至可以发送回任何电子邮件客户端作为报告。同样，有一些任务（在SolarWinds中称为**作业**），可以按计划执行，如下面的屏幕截图所示：
- en: '![](img/2935a92f-e6ad-4ea6-9ec5-7aa7ea9da9e1.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2935a92f-e6ad-4ea6-9ec5-7aa7ea9da9e1.jpg)'
- en: As we can see in the preceding screenshot, we can Download Configs from Devices,
    and then select all or certain devices in the next step and schedule the job.
    This is very useful in terms of fetching a config from a previous date or in case
    a rollback is needed to a last known good config scenario. Also, there are times
    when auditing needs to be performed regarding who changed what and what was changed
    in configurations, and SolarWinds can extend this ability by sending reports and
    alerts. Programmatically, we have the additional ability to call the SolarWinds
    API to fetch the results from Python.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个屏幕截图所示，我们可以从设备下载配置，然后在下一步中选择所有或某些设备并安排作业。这在从以前的日期获取配置或在需要回滚到最后已知良好配置场景时非常有用。此外，有时需要对配置更改进行审计，以了解谁更改了什么以及更改了什么，SolarWinds可以通过发送报告和警报来扩展这一功能。从编程的角度来看，我们还有额外的能力通过Python调用SolarWinds
    API来获取结果。
- en: It is assumed that OrionSDK is already installed in Python. If not, we can install
    it using `pip install orionsdk`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 假设OrionSDK已经安装在Python中。如果没有，我们可以使用`pip install orionsdk`来安装它。
- en: 'Consider the following example:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE13]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Since SolarWinds supports a direct SQL query, we use the query:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 由于SolarWinds支持直接SQL查询，我们使用以下查询：
- en: '[PRE14]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We are trying to fetch the `NodeID` and `DisplayName` (or the device name)
    for all the devices which have the vendor Cisco. Once we have the result, we print
    the result in a formatted way. In our case, the output will be (let''s assume
    our Cisco devices in SolarWinds are added as `mytestrouter1` and `mytestrouter2`):'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们试图获取所有具有思科供应商的设备的`NodeID`和`DisplayName`（或设备名称）。一旦我们有了结果，我们将以格式化的方式打印结果。在我们的例子中，输出将是（假设我们的思科设备在SolarWinds中已添加为`mytestrouter1`和`mytestrouter2`）：
- en: '[PRE15]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Using some of these automation tools and APIs, we can ensure that our tasks
    are focused on actual work with some of the basic or core tasks (like fetching
    values from devices and so on) being offloaded to the tools or APIs to take care
    of.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些自动化工具和API中的某些工具，我们可以确保我们的任务专注于实际工作，一些基本或核心任务（如从设备获取值等）被卸载到工具或API中处理。
- en: Let's now create a basic automation tool from scratch that monitors the reachability
    of any node that is part of that monitoring tool, using a ping test. We can call
    it PingMesh or PingMatrix, as the tool will generate a web-based matrix to show
    the reachability of the routers.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们从头开始创建一个基本的自动化工具，该工具使用ping测试来监控任何作为监控工具一部分的节点的可达性。我们可以将其称为PingMesh或PingMatrix，因为该工具将生成一个基于Web的矩阵来显示路由器的可达性。
- en: 'The topology that we would be using is as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要使用的拓扑如下：
- en: '![](img/730b75ac-2225-4408-b7e7-0b043391c012.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/730b75ac-2225-4408-b7e7-0b043391c012.jpg)'
- en: Here, we would be using four routers (`R1` to `R4`), and the `Cloud1` as our
    monitoring source. Each of the routers will try to reach each other through ping,
    and will report back to the script running on `Cloud1` which will interpret the
    results and display the web-based matrix through a web-based URL.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将使用四个路由器（`R1`到`R4`），以及`Cloud1`作为我们的监控源。每个路由器将尝试通过ping相互可达，并将结果报告给在`Cloud1`上运行的脚本，该脚本将解释结果并通过基于Web的URL显示网络矩阵。
- en: 'The explanation of the preceding topology is as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 前面拓扑的解释如下：
- en: What we are trying to do is log in to each router (preferably in parallel),
    ping each destination from each source, and report back the reachability status
    of each destination.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们试图做的是登录到每个路由器（最好是并行登录），从每个源ping每个目标，并报告每个目标的可达性状态。
- en: As an example, if we want to do the task manually, we would log in to `R1` and
    try to ping `R2`, `R3`, and `R4` from the source to check the reachability of
    each router from `R1`. The main script on `Cloud1` (acting as the controller)
    will interpret the result and update the web matrix accordingly.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 例如，如果我们想手动执行任务，我们会登录到`R1`并尝试从源ping `R2`、`R3`和`R4`，以检查每个路由器从`R1`的可达性。`Cloud1`上的主脚本（充当控制器）将解释结果并相应地更新网络矩阵。
- en: In our case all the routers (and the controller) are residing in `192.168.255.x`
    subnet, hence they are reachable to each other using a simple ping.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的案例中，所有路由器（以及控制器）都位于`192.168.255.x`子网中，因此它们可以通过简单的ping相互可达。
- en: We are going to create two separate Python programs (one to be called as the
    library for invoking the commands on various nodes, fetching the results from
    the nodes, interpreting the results, and sending the parsed data to the main program).
    The main program will be responsible for calling the library, and will use the
    results we get back to create the HTML web matrix.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建两个独立的Python程序（一个作为调用各种节点上命令、从节点获取结果、解释结果并将解析后的数据发送到主程序的库）。主程序将负责调用库，并使用我们得到的结果创建HTML网络矩阵。
- en: 'Let''s create the library or the program to be called in the main program first
    (we called it `getmeshvalues.py`):'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建主程序中要调用的库或程序（我们称之为`getmeshvalues.py`）：
- en: '[PRE16]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding code, we have created three main functions that we call in
    a thread (for parallel execution). The `getallvalues()` contains the list of IP
    addresses that we want to get the data from.  It then passes this information
    to `fetchallvalues()` with specific device information to fetch the ping values
    again in parallel execution. For executing the command on the router and fetching
    the results, we call the `fetchpingvalues()` function.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了三个主要函数，我们在一个线程中调用这些函数（用于并行执行）。`getallvalues()`包含我们想要获取数据的IP地址列表。然后它将此信息传递给`fetchallvalues()`，带有特定设备信息以并行执行再次获取ping值。对于在路由器上执行命令并获取结果，我们调用`fetchpingvalues()`函数。
- en: 'Let''s see the result of this code (by removing the remark on the code that
    calls the function). We need to pass the device IPs that we want to validate as
    a list. In our case, we have all the valid routers in the `192.168.255.x` range,
    and `4.2.2.2` is taken as an example of a non-reachable router:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个代码的结果（通过删除调用函数的注释）。我们需要传递一个列表，其中包含我们想要验证的设备IP。在我们的案例中，我们所有的有效路由器都在`192.168.255.x`范围内，`4.2.2.2`被用作一个不可达路由器的示例：
- en: '[PRE17]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The preceding code gives the following output:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码给出了以下输出：
- en: '![](img/27db4bff-4119-4e85-9d9f-015ca58654d2.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/27db4bff-4119-4e85-9d9f-015ca58654d2.jpg)'
- en: As we can see in the result, we get the reachability in terms of `True` or `False`
    from each node to the other node.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在结果中看到的那样，我们从每个节点到其他节点获得了可达性的`True`或`False`。
- en: For example, the first item in the list (`'192.168.255.240:192.168.255.240','True'`)interprets
    that from the source `192.168.255.240` to destination `192.168.255.240` (which
    is the same self IP) is reachable.  Similarly, the next item in the same list
    (`'192.168.255.240:192.168.255.245','True'`) confirms that from source IP `192.168.255.240`
    the destination `192.168.255.245` we have reachability from ping. This information
    is required to create a matrix based upon the results. Next we see the main code
    where we fetch these results and create a web-based matrix page.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，列表中的第一个项目`('192.168.255.240:192.168.255.240','True')`表示从源`192.168.255.240`到目标`192.168.255.240`（即相同的自IP）是可达的。同样，同一列表中的下一个项目`('192.168.255.240:192.168.255.245','True')`确认从源IP`192.168.255.240`到目标`192.168.255.245`我们通过ping有可达性。这些信息是创建基于结果的矩阵所必需的。接下来我们看到主要代码，其中我们获取这些结果并创建一个基于Web的矩阵页面。
- en: 'Next, we need to create the main file (we''re calling it `pingmesh.py`):'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建主文件（我们将其命名为`pingmesh.py`）：
- en: '[PRE18]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In this case, we have the following mappings in place:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们已设置以下映射：
- en: '[PRE19]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The last device named `Random`,is a test device which is not in our network
    and is non-reachable for test purposes. Once executed, it creates a file named
    `pingmesh.html` with standard HTML formats and a last-refreshed clock (from JavaScript)
    to confirm when the last refresh occurred. This is required if we want the script
    to be executed from the task scheduler (Let's say every five minutes), and anybody
    opening the HTML page will know when the probe occurred. The HTML file needs to
    be placed or saved in a folder which is mapped to a web folder so that it can
    be accessed using the URL `http://<server>/pingmesh.html`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个名为`Random`的设备是一个测试设备，它不在我们的网络中，并且为了测试目的不可达。一旦执行，它将创建一个名为`pingmesh.html`的文件，该文件使用标准的HTML格式和最后刷新时钟（来自JavaScript），以确认最后刷新发生的时间。如果我们想从任务计划程序（比如说每五分钟）执行脚本，并且任何人打开HTML页面都会知道探测发生的时间。HTML文件需要放置或保存在一个映射到Web文件夹的文件夹中，以便可以使用URL`http://<服务器>/pingmesh.html`访问。
- en: 'When executed, here is the output from the Python script:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行时，这里是Python脚本的输出：
- en: '![](img/9f1a81d1-b0b1-4f46-94d4-7ab8c48f8af6.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9f1a81d1-b0b1-4f46-94d4-7ab8c48f8af6.jpg)'
- en: 'The HTML file, when placed in the web-mapped URL and called, looks like this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当将HTML文件放置在Web映射的URL中并调用时，看起来是这样的：
- en: '![](img/73a2b511-4c71-4ff9-bf5b-bc6376482369.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/73a2b511-4c71-4ff9-bf5b-bc6376482369.jpg)'
- en: As we can see, in the PingMatrix there is an entire red row and column, which
    means that any connectivity between any router to the random router and from the
    random router to any router is not there. Green means that all the connectivity
    between all other routers is fine.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，在PingMatrix中存在一整行和一整列红色，这意味着任何路由器到随机路由器以及从随机路由器到任何路由器的连接都不存在。绿色表示所有其他路由器之间的连接都正常。
- en: 'Additionally, we have also configured a tooltip on each cell, and hovering
    the mouse over that specific cell would also show the source and destination IP
    address mapping for that particular cell, as shown in the following screenshot:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还在每个单元格上配置了工具提示，将鼠标悬停在该特定单元格上也会显示该特定单元格的源和目标IP地址映射，如下面的截图所示：
- en: '![](img/d5dd0c8b-dd5d-422c-9916-151750f43c15.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d5dd0c8b-dd5d-422c-9916-151750f43c15.jpg)'
- en: 'Let''s see another screenshot, in which we shut down R2 to make it unreachable:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一个截图，其中我们关闭了R2以使其不可达：
- en: '![](img/b5b0edb8-bf44-4e23-8c27-f06c5f150f82.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b5b0edb8-bf44-4e23-8c27-f06c5f150f82.jpg)'
- en: Now, as we can see, the entire row and column of `R2` is red, and hence the
    PingMatrix shows that `R2` is now unreachable from everywhere else, and `R2` also
    cannot reach anyone else in the network.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，正如我们所见，`R2`的整个行和列都是红色，因此PingMatrix显示`R2`现在从其他任何地方都不可达，并且`R2`也无法在网络中到达其他人。
- en: 'Let''s see a final example, in which for test purposes we intentionally block
    the ping traffic from `R2` to `R4` (and vice versa) using an extended Cisco ACL,
    which in turn reports that `R4` and `R2` have reachability issues in the PingMatrix:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个最终的例子，在这个例子中，为了测试目的，我们故意使用扩展的Cisco ACL阻止`R2`到`R4`（反之亦然）的ping流量，这反过来又报告说`R4`和`R2`在PingMatrix中存在可达性问题：
- en: '![](img/2ee3fc82-d864-4bbe-89ff-b2de50f9edb5.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2ee3fc82-d864-4bbe-89ff-b2de50f9edb5.jpg)'
- en: As we see can in the preceding screenshot, the Random router is still a red
    or false, since it is not in our network, but now it is showing red/false between
    `R2` and `R4` and also between `R4` and `R2`. This gives us a quick view that
    even with multiple paths to reach each node with another node, we have a connectivity
    issue between the two nodes.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个屏幕截图所示，随机路由器仍然显示为红色或错误，因为它不在我们的网络中，但现在它在`R2`和`R4`之间以及`R4`和`R2`之间显示为红色/错误。这让我们快速了解到，即使有多个路径可以到达每个节点，我们仍然存在两个节点之间的连接问题。
- en: Going by the preceding examples, we can enhance the tool to easily monitor and
    understand any routing/reachability issues, or even link down connectivity problems
    using a holistic view of all of the connections in our network. PingMesh/Matrix
    can be extended to check latency, and even packet drops in each connection between
    various nodes. Additionally, using syslog or email functionality (specific Python
    libraries are available for sending syslog messages from Python or even emails
    from Python code), alerts or tickets can also be generated in case of failures
    detected or high latency observed from the Python script itself.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的示例，我们可以增强这个工具，以便轻松监控和理解任何路由/可达性问题，甚至使用我们对网络中所有连接的整体视图来检测链路断开连接问题。PingMesh/Matrix可以扩展以检查延迟，甚至检查各个节点之间每个连接中的数据包丢失。此外，使用syslog或电子邮件功能（Python中可用于发送syslog消息的特定Python库，甚至可以从Python代码发送电子邮件），在检测到故障或从Python脚本本身观察到高延迟的情况下，还可以生成警报或工单。
- en: This tool can easily become a central monitoring tool in any organization, and
    based upon patterns (such as green or red, and other color codes if needed), engineers
    can make decisions on the actual issues and take proactive actions instead of
    reactive actions to ensure the high reliability and uptime of the network.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工具可以轻松地成为任何组织中的中心监控工具，工程师可以根据模式（如绿色或红色，以及如果需要其他颜色代码），对实际问题做出决策，并采取主动行动而不是被动行动，以确保网络的高可靠性和正常运行时间。
- en: Summary
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about the basic functionality of SDN controllers,
    programmable fabric, and some network automation tools. We have also seen how
    to work with cloud platforms and, with reference to a live example of managing
    AWS Cloud from Python, understood how we can control cloud operations using automation.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了SDN控制器的基本功能、可编程布线以及一些网络自动化工具。我们还了解了如何与云平台协同工作，并通过一个从Python管理AWS云的实时示例，理解了我们可以如何使用自动化来控制云操作。
- en: We gained a deep understanding about the role of controllers, and with some
    examples of Cisco controllers, went into details on how a controller can be programmed
    or called in programs/scripts to perform certain tasks. We also saw the basics
    of some popular network automation tools, such as SolarWinds, and created an in-house
    web-based automation tool for monitoring our network, called PingMatrix or PingMesh.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对控制器的作用有了深入的理解，并通过一些思科控制器的例子，详细介绍了控制器如何在程序/脚本中编程或调用以执行特定任务。我们还了解了某些流行的网络自动化工具的基础知识，例如SolarWinds，并创建了一个内部基于Web的自动化工具，用于监控我们的网络，称为PingMatrix或PingMesh。
