<html><head></head><body><div><div><h1 id="_idParaDest-142"><a id="_idTextAnchor146"/><a href="B16119_05_Final_PD_ePub.xhtml#_idTextAnchor146"><em class="italic">Chapter 5</em></a>: Importing, Exporting, and Module Data</h1>
			<p>Most Odoo module definitions, such as <strong class="bold">user interfaces</strong> and <strong class="bold">security rules</strong>, are data records that are stored in specific <strong class="bold">database tables</strong>. The XML and CSV files that are found in modules are not used by Odoo applications at runtime. They are a means of loading those definitions into database tables.</p>
			<p>Because of this, an important part of Odoo modules is representing data in files so that it can be loaded into a database upon module installation. Modules can also contain initial data and demonstration data. Data files allow us to add that to our modules.</p>
			<p>Additionally, understanding Odoo data representation formats is important for exporting and importing business data within the context of a project's implementation.</p>
			<p>The following topics will be covered in this chapter:</p>
			<ul>
				<li>Understanding the external identifier concept</li>
				<li>Exporting and importing data files</li>
				<li>Using CSV files</li>
				<li>Adding module data</li>
				<li>Using XML data files</li>
			</ul>
			<p>By the end of this chapter, you will be able to perform data exports and imports to populate initial data into a database and automate the creation of default and demonstration data in modules that have been created.</p>
			<h1 id="_idParaDest-143"><a id="_idTextAnchor147"/>Technical requirements</h1>
			<p>This chapter requires you to have an Odoo server running, with the library app base module installed.</p>
			<p>The code for this chapter can be found in this book's GitHub repository, <a href="https://github.com/PacktPublishing/Odoo-15-Development-Essentials">https://github.com/PacktPublishing/Odoo-15-Development-Essentials</a>, in the <code>ch05/</code> directory. It contains a copy of the original <code>library_app</code> that we created in <a href="B16119_03_Final_PD_ePub.xhtml#_idTextAnchor072"><em class="italic">Chapter 3</em></a>, <em class="italic">Your First Odoo Application</em>, with additional files added for this chapter.</p>
			<h1 id="_idParaDest-144"><a id="_idTextAnchor148"/>Understanding the external identifier concept</h1>
			<p>An <strong class="bold">external identifier</strong>, also <a id="_idIndexMarker360"/>called an <strong class="bold">XML ID</strong>, is a <em class="italic">human-readable string identifier</em> that uniquely identifies a particular record in Odoo. They are important for loading data into Odoo, allowing us to modify an existing data record or reference it in other data records.</p>
			<p>First, we will introduce how external identifiers work, and how we can inspect them. Then, we will learn how to use the web client to find the external identifiers for particular data records, since this is frequently needed when creating add-on modules, thus extending existing features.</p>
			<h2 id="_idParaDest-145"><a id="_idTextAnchor149"/>How external identifiers work</h2>
			<p>Let's begin by understanding how <a id="_idIndexMarker361"/>identifiers work. The actual database identifier for a record is an automatically assigned sequential number, and there is no way to know ahead of time what ID will be assigned to each record during module installation. External identifiers let us reference a related record without the need to know the actual database ID that's been assigned to it. The XML ID provides a convenient alias for the database ID so that we can use it whenever we need to reference a particular record.</p>
			<p>Records defined in Odoo module data files use <em class="italic">XML IDs</em>. One reason for this is to avoid creating duplicate records when upgrading a module. The module upgrade will load the data files into the database again. We want it to detect pre-existing records for them to be updated, instead of creating duplicate records.</p>
			<p>Another reason to use XML IDs is to support interrelated data: data records that need to reference other data records. Since we can't know the actual database ID, we can use the XML ID, so the translation will be transparently handled by the <strong class="bold">Odoo framework</strong>.</p>
			<p>Odoo takes care of translating the external identifier names into the actual database IDs that have been assigned to them. The mechanism behind this is quite simple: Odoo keeps a table with the mapping between the named external identifiers and their corresponding numeric database IDs: the <code>ir.model.data</code> model.</p>
			<p>We must have <strong class="bold">Developer mode</strong> enabled to have the menu option available. Check whether you have the <em class="italic">Developer mode</em> bug icon in the top right, next to the user's avatar icon. If not, you should enable it now in the <strong class="bold">Settings</strong> top menu. Please refer to <a href="B16119_01_Final_PD_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Quick Start Using the Developer Mode</em>, for more details.</p>
			<p>We can inspect the existing mappings using the <code>library_app</code> module, we will see the external identifiers that have been generated by the module we created, as<a id="_idIndexMarker362"/> shown in the following screenshot:</p>
			<div><div><img src="img/image_00_001.jpg" alt="Figure 5.1 – External identifiers generated by the library_app module&#13;&#10;" width="1211" height="637"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.1 – External identifiers generated by the library_app module</p>
			<p>Here, we can see that the external identifiers have <code>library_app.action_library_book</code>.</p>
			<p>External identifiers only need to be unique inside an Odoo module so that there is no risk of two modules conflicting because of accidentally choosing the same identifier name. The globally unique identifier is built by joining the module name with the actual external identifier name. This is what you can see in the <strong class="bold">Complete ID</strong> field.</p>
			<p>When using an external identifier in a data file, we can choose to use either the complete identifier or just the external identifier name. Usually, it's simpler to just use the external identifier name, but the complete identifier enables us to reference data records from other modules. When doing so, make sure that those modules are included in the module dependencies to ensure that those records are loaded before ours.</p>
			<p>There are some cases where the complete ID is needed, even if we're referring to an XML ID from the same module.</p>
			<p>At the top of the list, we can see the <code>library_app.action_library_book</code> complete identifier. This is the menu action we created for the module, which is also referenced in the corresponding menu item. By clicking on it, we go to the form view, which contains its details. There, we can see that the <code>action_library_book</code> external identifier in the <code>library_app</code> module maps to a specific record ID in the <code>ir.actions.act_window</code> model, which is <code>87</code> in this case.</p>
			<p>By clicking on the <a id="_idIndexMarker363"/>record's line, the information can be seen in a form view, as shown in the following screenshot:</p>
			<div><div><img src="img/image_00_002.jpg" alt="Figure 5.2 – Form view for the library_app.action_library_book external identifier&#13;&#10;" width="1212" height="456"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.2 – Form view for the library_app.action_library_book external identifier</p>
			<p>Besides providing a way for records to easily reference other records, external identifiers also allow you to avoid data duplication on repeated imports. If the external identifier is already present, the existing record will be updated, avoiding a new, duplicate record being created.</p>
			<h2 id="_idParaDest-146"><a id="_idTextAnchor150"/>Finding external identifiers</h2>
			<p>When we're <a id="_idIndexMarker364"/>writing data records for our modules, we frequently need to look up the existing external identifiers to use for our reference. So, it is important to know how to find these identifiers.</p>
			<p>One way to do this is to use the <strong class="bold">Settings</strong> | <strong class="bold">Technical</strong> | <strong class="bold">Sequences &amp; Identifiers</strong> | <strong class="bold">External Identifiers</strong> menu, which was shown earlier in <em class="italic">Figure 5.1</em>. We can also use the <strong class="bold">Developer</strong> menu for this. As you may recall from <a href="B16119_01_Final_PD_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Quick Start Using the Developer Mode</em>, the <strong class="bold">Developer</strong> menu can be activated in the <strong class="bold">Settings</strong> dashboard, at the bottom right.</p>
			<p>To find the external identifier for a data record, we should open the corresponding form view, select the <strong class="bold">Developer</strong> menu, and then choose the <strong class="bold">View Metadata</strong> option. This will display a dialog containing the record's database ID and external identifier (also known as the XML ID).</p>
			<p>For example, to look up the <code>demo</code> user ID, we should navigate to the users form view at <code>demo</code> user form, and then select the <code>base.user_demo</code> and that the database ID is <code>6</code>:</p>
			<div><div><img src="img/image_00_003.jpg" alt="Figure 5.3 – The View Metadata dialog window&#13;&#10;" width="1230" height="507"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.3 – The View Metadata dialog window</p>
			<p>To find the external identifier for view elements, such as <strong class="bold">form</strong>, <strong class="bold">tree</strong>, <strong class="bold">search</strong>, or <strong class="bold">action</strong>, the <strong class="bold">Developer</strong> menu is also a good source of help. For this, we can use the appropriate <strong class="bold">Edit View</strong> option to open a form containing the details of the corresponding view. There, we will find an <strong class="bold">External ID</strong> field, which provides the information we are looking for.</p>
			<p>For example, in the following<a id="_idIndexMarker365"/> screenshot, we can see that the <code>base.view_users_form</code>:</p>
			<div><div><img src="img/image_00_004.jpg" alt="Figure 5.4 – The Edit View window showing the External ID property for a form view&#13;&#10;" width="1211" height="507"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.4 – The Edit View window showing the External ID property for a form view</p>
			<p>With that, we have learned about <strong class="bold">External IDs</strong> and how they can be used as aliases to reference database records. We have also looked at several ways to find the <strong class="bold">XML IDs</strong> that will be needed to reference records in the data files. Next, we will learn how to create data files where these <strong class="bold">XML IDs</strong> will be useful.</p>
			<h1 id="_idParaDest-147"><a id="_idTextAnchor151"/>Exporting and importing CSV data files</h1>
			<p>An easy way to generate data files and get insight into what structure the files should have is to use the built-in export feature.</p>
			<p>With generated CSV files, we <a id="_idIndexMarker366"/>can learn about the format that's needed to import data manually<a id="_idIndexMarker367"/> into the system, edit them to perform mass updates, or even use them to produce demo data for our add-on modules.</p>
			<p>In this section, we will learn about the basics of exporting and importing data from Odoo's user interface.</p>
			<h2 id="_idParaDest-148"><a id="_idTextAnchor152"/>Exporting data</h2>
			<p><strong class="bold">Data exporting</strong> is a standard<a id="_idIndexMarker368"/> feature that's available in any list view. To use it, we must pick the rows to export by selecting the corresponding checkboxes, on the far left, and then selecting the <strong class="bold">Export</strong> option from the <strong class="bold">Action</strong> button at the top of the list.</p>
			<p>First, we should add a couple of Odoo books to the <code>Odoo Development Essentials 11</code> and <code>Odoo 11 Development Cookbook</code>.</p>
			<p>We also need to have the <strong class="bold">Contacts</strong> app installed so that we can see a <strong class="bold">Partner</strong> list view and can export those records from there. Notice that the default view is <strong class="bold">Kanban</strong> for the contact cards, so we need to switch to the <strong class="bold">list</strong> view:</p>
			<div><div><img src="img/image_00_005.jpg" alt="Figure 5.5 – The Export option in the Action menu&#13;&#10;" width="1256" height="334"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.5 – The Export option in the Action menu</p>
			<p>We can also tick the checkbox in the header of the column to select all of the available records that match the current search criteria.</p>
			<p>The <strong class="bold">Export</strong> option takes us to the <strong class="bold">Export Data</strong> dialog form, where we can choose what and how to export. We are concerned with exporting in a way that allows us to import that file later, either manually or as part of an add-on module:</p>
			<div><div><img src="img/image_00_006.jpg" alt="Figure 5.6 – The Export Data dialog window&#13;&#10;" width="1126" height="568"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.6 – The Export Data dialog window</p>
			<p>At the top of the <a id="_idIndexMarker369"/>dialog form, we have two selections available:</p>
			<ul>
				<li><strong class="bold">I want to update data (import-compatible export)</strong>: Enable this checkbox so that the data is exported in a format-friendly manner for a later import.</li>
				<li><strong class="bold">Export format</strong>: You can choose between <strong class="bold">CSV</strong> or <strong class="bold">XLSX</strong> here. We will choose a <strong class="bold">CSV</strong> file to get a better understanding of the raw export format, which is still understood by any spreadsheet application.</li>
			</ul>
			<p>Next, pick the columns to export. In this example, a very simple export was done by choosing only the <strong class="bold">Name</strong> field. By clicking on the <strong class="bold">Export</strong> button, an exported data file will be available. The exported CSV file should look like this:</p>
			<pre>"id","name"
"__export__.res_partner_43_f82d2ecc","Alexandre Fayolle"
"__export__.res_partner_41_30a5bc3c","Daniel Reis"
"__export__.res_partner_44_6be5a130","Holger Brunn"
"__export__.res_partner_42_38b48275","Packt Publishing"</pre>
			<p>The first row contains the <strong class="bold">field names</strong>, which will be used during the import to automatically map the columns to their destination.</p>
			<p>The first row has the selected <code>name</code> column, as expected. An initial ID column was automatically added because the import-compatible export option was selected.</p>
			<p>The automatically added <code>id</code> column has the external ID assigned to each record. This allows the exported data file to be edited and reimported later, to update the records, instead of creating duplicated ones.</p>
			<p>Missing external<a id="_idIndexMarker370"/> identifiers are automatically generated using the <code>__export__</code> prefix, as shown in the previous file export example.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Because of the automatically generated record identifiers, the export or import features can be used to mass edit Odoo data – export the data to CSV, use spreadsheet software to mass edit it, and then import it back into Odoo.</p>
			<h2 id="_idParaDest-149"><a id="_idTextAnchor153"/>Importing data</h2>
			<p>Once we have a properly<a id="_idIndexMarker371"/> formatted data file ready, we want to import it into Odoo. Let's learn how this is can be done through the web client user interface.</p>
			<p>First, we have to make sure that the import feature is <em class="italic">enabled</em>. It should be enabled by default. If not, the option is available in the <strong class="bold">Settings</strong> app, under the <strong class="bold">General Settings</strong> menu item. Under the <strong class="bold">Permissions</strong> section, the <strong class="bold">Import &amp; Export</strong> option should be checked.</p>
			<p>With this option enabled, the list view search widget will show an <strong class="bold">Import records</strong> option in the <strong class="bold">Favorites</strong> menu, next to the <strong class="bold">Filters</strong> and <strong class="bold">Group By</strong> menus.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <code>base_import</code> module, which is responsible for providing this feature.</p>
			<p>Let's try performing a bulk edit on our <em class="italic">Contact</em> or <em class="italic">Partner</em> data. Open the CSV file we just downloaded in a spreadsheet or a text editor and change a few values. We can also add some new rows, leaving the <code>id</code> column blank for them.</p>
			<p>As we mentioned previously, the first column, <code>id</code>, provides a unique identifier for each row. This allows pre-existing records to be updated instead of us needing to duplicate them when we import the data back to Odoo. If we edit any of the names in the exported file, the corresponding record will be updated when we import the file.</p>
			<p>For the new rows that have been added to the CSV file, we can choose to either provide an external identifier of our choice or we can leave the <code>id</code> column blank. Either way, a new record will be created for them. As an example, we added a line with no <code>id</code> and the name <code>Phillip K. Dick</code> to be created in the database:</p>
			<pre>,Phillip K. Dick</pre>
			<p>After saving these <a id="_idIndexMarker372"/>changes to the <strong class="bold">CSV</strong> file, click on the <strong class="bold">Import</strong> option, in the <strong class="bold">Favorites</strong> menu. The next page allows us to upload the data file. Then, the import assistant will be presented:</p>
			<div><div><img src="img/image_00_007.jpg" alt="Figure 5.7 – The Import a File assistant&#13;&#10;" width="1126" height="533"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.7 – The Import a File assistant</p>
			<p>Here, we should select the CSV file's location on the disk and then click on the <strong class="bold">Test</strong> button, at the top left, to check it for correctness.</p>
			<p>Since the file to import is based on an Odoo export, there is a good chance that it will be valid and that the columns will be automatically mapped to their proper destination in the database. Depending on the application that's used to edit the data file, you may have to play with the separator and encoding options to get the best results.</p>
			<p>Now, click on <strong class="bold">Import</strong>, and there you go – the modifications and new records should have been loaded into Odoo!</p>
			<h2 id="_idParaDest-150"><a id="_idTextAnchor154"/>Related records in CSV data files</h2>
			<p>The examples in the previous section <a id="_idIndexMarker373"/>were quite simple, but the data files can become more complex once we start using relational fields, linking records from several tables.</p>
			<p>Previously, we handled <em class="italic">Partner</em> records that were used in <em class="italic">Books</em>. We will now look at how we can represent the reference for these Partners in a CSV file for book data. In particular, we have a many-to-one (or a foreign key) relationship for the Publisher (the <code>publisher_id</code> field) and a many-to-many relationship for the Authors (the <code>author_ids</code> field).</p>
			<p>In the CSV file header line, relationship columns should have <code>/id</code> appended to their names. It will reference the related records using external identifiers. In our example, we will load the book publisher into a <code>publisher_id/id</code> field, using the external ID for the related partner as a value.</p>
			<p>It is possible to use <code>/.id</code> instead so that we can use the actual database IDs (the real numeric identifier that's been assigned), but this is rarely what we need. Unless you have good reason to do otherwise, always use external IDs instead of database IDs. Also, remember that database IDs are specific to a particular Odoo database, so, most of the time, it won't work correctly if it's imported into a database other than the original one.</p>
			<p>Many-to-many fields can also be imported through <code>CSV</code> data files. It's as easy as providing a comma-separated list of external IDs, surrounded by double quotes. For example, to load the book authors, we would have an <code>author_ids/id</code> column, where we would use a comma-separated list of the external IDs of the Partners to link as values. Here is an example of what a to-many field would look like in a CSV file:</p>
			<pre>id, name, author_ids/id
book_odc11, "Odoo 11 Development Cookbook", "__export__.res_partner_43_f82d2ecc,__export__.res_partner_44_6be5a130"</pre>
			<p>One-to-many fields often represent headers or lines, or parent or child relationships, and there is special support to import these types of relationships – for the same parent record, we can have several related lines.</p>
			<p>Here, we have an example of a one-to-many field in the <em class="italic">Partners</em> model: a company partner can have several child contacts. If we export the data from the <em class="italic">Partner</em> model and include the <strong class="bold">Contacts</strong>/<strong class="bold">Name</strong> field, we will see the structure that can be used to import this type of data:</p>
			<div><div><img src="img/image_00_008.jpg" alt="Figure 5.8 – Data file example importing to-many related records&#13;&#10;" width="920" height="97"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.8 – Data file example importing to-many related records</p>
			<p>The <code>id</code> and <code>name</code> columns are<a id="_idIndexMarker374"/> for the parent records, while the <code>child_ids</code> columns are for the child records. Notice how the parent record columns are left blank for the child records after the first one.</p>
			<p>The preceding table, which is represented as a CSV file, looks as follows:</p>
			<pre>"id","name","child_ids/id","child_ids/name"
"base.res_partner_12","Azure Interior","base.res_partner_address_15","Brandon Freeman"
"","","base.res_partner_address_28","Colleen Diaz"
"","","base.res_partner_address_16","Nicole Ford"</pre>
			<p>Here, we can see that the first two columns, <code>id</code> and <code>name</code>, have values in the first line and are empty in the next two lines. They have data for the parent record, which is the <em class="italic">Contact's Company</em>.</p>
			<p>The other two columns are both prefixed with <code>child_ids/</code> and have values on all three lines. They contain data for the contacts related to the parent company. The first line contains data for both the company and the first contact, while the lines that follow contain data for the columns of the child contacts.</p>
			<h1 id="_idParaDest-151"><a id="_idTextAnchor155"/>Adding module data</h1>
			<p>Modules use data files to load <a id="_idIndexMarker375"/>their default data, demonstration data, user interface definitions, and other configurations into the database. For this, we can use both CSV and XML files.</p>
			<p class="callout-heading">Changes in Odoo 12</p>
			<p class="callout">The YAML file format was also supported until Odoo 11 and was removed in Odoo 12. Still, for a usage example, you can look at the <code>l10n_be</code> official module in Odoo 11, and for information on the YAML<a id="_idIndexMarker376"/> format, you can visit <a href="http://yaml.org/">http://yaml.org/</a>.</p>
			<p>CSV files that are used by modules are the same as those we have seen and used for the import feature. When using them in modules, the filename must match the name of the model that the data will be loaded into. For example, a CSV file for loading data into the <code>library.book</code> model must be named <code>library.book.csv</code>.</p>
			<p>A common usage of data CSV <a id="_idIndexMarker377"/>files is for accessing security definitions that have been loaded into the <code>ir.model.access</code> model. They usually use CSV files in a <code>security/</code> subdirectory, named <code>ir.model.access.csv</code>.</p>
			<h2 id="_idParaDest-152"><a id="_idTextAnchor156"/>Demonstration data</h2>
			<p>Odoo add-on modules may install <a id="_idIndexMarker378"/>demonstration data, and it is considered good practice to do so. This is useful for providing usage examples for a module and the datasets to be used in tests. Demonstration data for a module is declared using the <code>demo</code> attribute of the <code>__manifest__.py</code> manifest file. Just like the <code>data</code> attribute, it is a list of filenames with the corresponding relative paths inside the module.</p>
			<p>Some demonstration data should be added to the <code>library.book</code> module. An easy way to do this is to export some data from the development database with the module installed.</p>
			<p>The convention is to place data files in a <code>data/</code> subdirectory. We should save these data files in the <code>library_app</code> add-on module as <code>data/library.book.csv</code>. Since this data will be owned by our module, we should edit the <code>id</code> values to remove the <code>__export__</code> prefix in the identifiers that are generated by the export feature.</p>
			<p>As an example, our <code>res.partner.csv</code> data file might look as follows:</p>
			<pre><strong class="bold">id,name</strong> 
res_partner_alexandre,"Alexandre Fayolle" 
res_partner_daniel,"Daniel Reis" 
res_partner_holger,"Holger Brunn"
res_partner_packt,"Packt Publishing"</pre>
			<p>The <code>library.book.csv</code> data file containing the Book demo data will look as follows:</p>
			<pre><strong class="bold">"id","name","date_published","publisher_id/id","author_ids/id"</strong>
library_book_ode11,"Odoo Development Essentials 11","2018-03-01",res_partner_packt,res_partner_daniel
library_book_odc11,"Odoo 11 Development Cookbook","2018-01-01",res_partner_packt,"res_partner_alexandre,res_partner_holger"</pre>
			<p>Do not forget to add these data files to the <code>__manifest__.py</code> manifest's <code>demo</code> attribute:</p>
			<pre>"demo": [
    "data/res.partner.csv",
    "data/library.book.csv",
],</pre>
			<p>The files are loaded in the<a id="_idIndexMarker379"/> order they are declared. This is important since records in a file cannot reference other records that haven't been created yet.</p>
			<p>The next time the module is updated, the content of the file will be imported, so long as it is installed with the demo data enabled.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">While data files are also re-imported on module upgrades, this is not the case for the demo data files: these are only imported upon module installation.</p>
			<p>Of course, XML files can also be used to load or initialize data, leveraging the additional features they provide, compared to plain CSV files. In the next section, we will discuss using data files in XML format.</p>
			<h1 id="_idParaDest-153"><a id="_idTextAnchor157"/>Using XML data files</h1>
			<p>While CSV files <a id="_idIndexMarker380"/>provide a simple and compact format to represent data, XML files are more powerful and give more control over the loading process. For example, their filenames are not required to match the model to be loaded. This is because the XML format is much richer and more information regarding what to load can be provided through the XML elements inside the file.</p>
			<p>We used XML data files in the previous chapters. The user interface components, such as the views and menu items, are, in fact, records that are stored in system models. The XML files in the modules are used to load these records into the instance database.</p>
			<p>To showcase this, a second data file will be added to the <code>library_app</code> module, <code>data/book_demo.xml</code>, with the following content:</p>
			<pre>&lt;?xml version="1.0"?&gt;
&lt;odoo noupdate="1"&gt;
  &lt;!-- Data to load --&gt;
  &lt;record model="res.partner" id="res_partner_huxley"&gt; 
    &lt;field name="name"&gt;Aldous Huxley&lt;/field&gt; 
  &lt;/record&gt; 
  &lt;record model="library.book" id="library_book_bnw"&gt;
    &lt;field name="name"&gt;Brave New World&lt;/field&gt;
    &lt;field name="author_ids"
           eval="[(4, ref('res_partner_huxley'))]" /&gt;
    &lt;field name="date_published"&gt;1932-01-01&lt;/field&gt;
  &lt;/record&gt;
&lt;/odoo&gt;</pre>
			<p>As usual, the new <a id="_idIndexMarker381"/>data file must be declared in the <code>__manifest__.py</code> file:</p>
			<pre>"demo": [
    "data/res.partner.csv",
    "data/library.book.csv",
<strong class="bold">    "data/book_demo.xml",</strong>
],</pre>
			<p>Similar to the CSV data file we saw in the previous section, this file also loads data into the <em class="italic">Library Books</em> model.</p>
			<p>XML data files have an <code>&lt;odoo&gt;</code> top element, inside of which there can be several <code>&lt;record&gt;</code> elements, which are the equivalent to data rows in CSV files.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <code>&lt;odoo&gt;</code> top element in data files was introduced in version 9.0 and replaces the former <code>&lt;openerp&gt;</code> tag. A <code>&lt;data&gt;</code> section inside the top element is still supported, but it's now optional. In fact, now, <code>&lt;odoo&gt;</code> and <code>&lt;data&gt;</code> are equivalent, so we could use either one as the top element for our XML data files.</p>
			<p>A <code>&lt;record&gt;</code> element <a id="_idIndexMarker382"/>has two mandatory attributes, <code>model</code> and <code>id</code>, for the external identifier for the record, and contains a <code>&lt;field&gt;</code> tag for each field to write on.</p>
			<p>Note that the slash notation in the field names is not available here; we can't use <code>&lt;field name="publisher_id/id"&gt;</code>. Instead, the <code>ref</code> special attribute is used to reference external identifiers. We'll discuss the values of the relational to-many fields in a moment.</p>
			<p>You may have noticed the <code>noupdate="1"</code> attribute in the top <code>&lt;odoo&gt;</code> element. This prevents the data records from being loaded on module upgrades so that any later edits that are made to them are not lost.</p>
			<h2 id="_idParaDest-154"><a id="_idTextAnchor158"/>The noupdate data attribute</h2>
			<p>When a module is upgraded, the data <a id="_idIndexMarker383"/>file loading is repeated, and the module's records are rewritten. This means that upgrading a module will overwrite any manual changes that might have been made to the module's data.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Notably, if views were manually modified to add quick customizations, these changes will be lost with the next module upgrade. To avoid this, the correct approach is to create inherited views with the changes we want to introduce.</p>
			<p>This rewrite behavior is the default, but it can be changed so that some of the data is only imported at install time, and is ignored in later module upgrades. This can be done using the <code>noupdate="1"</code> attribute in the <code>&lt;odoo&gt;</code> or <code>&lt;data&gt;</code> elements.</p>
			<p>This is useful for data that is to be used for the initial configuration but is expected to be customized later since these manually made customizations will be safe from module upgrades. For example, it is frequently used for record access rules, allowing them to be adapted to implementation-specific needs.</p>
			<p>It is possible to have more than one <code>&lt;data&gt;</code> section in the same <code>XML</code> file. We can take advantage of this to separate data to import only once, with <code>noupdate="1"</code>, and data that can be re-imported on each upgrade, with <code>noupdate="0"</code>. <code>noupdate="0"</code> is the default, so we can just omit it if we prefer. Note that we need to have a top-level XML element, so in this case, we will use two <code>&lt;data&gt;</code> sections. They must be inside a top-level <code>&lt;odoo&gt;</code> or <code>&lt;data&gt;</code> element.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">The <code>noupdate</code> attribute can be tricky when we're developing modules because changes that are made to the data later will be ignored. One solution is to, instead of upgrading the module with the <code>-u</code> option, reinstall it using the <code>-i</code> option. Reinstalling from the command line using the <code>-i</code> option ignores the <code>noupdate</code> flags on data records.</p>
			<p>The <code>noupdate</code> flag is<a id="_idIndexMarker384"/> stored in the <strong class="bold">External Identifier</strong> information for each record. It's possible to manually edit it directly using the <strong class="bold">External Identifier</strong> form, which is available in the <strong class="bold">Technical</strong> menu, by using the <strong class="bold">Non Updatable</strong> checkbox.</p>
			<p class="callout-heading">Changes in Odoo 12</p>
			<p class="callout">In <strong class="bold">Developer Menu</strong>, when accessing <strong class="bold">View Metadata</strong>, the dialog box now also shows the value for the <strong class="bold">No Update</strong> flag, along with the record's <strong class="bold">XML ID</strong>. Furthermore, <strong class="bold">No Update flag</strong> can be changed there by clicking on it.</p>
			<h2 id="_idParaDest-155"><a id="_idTextAnchor159"/>Defining records in XML</h2>
			<p>In an <code>XML</code> data file, each <code>&lt;record&gt;</code> element has two basic attributes, <code>id</code> and <code>model</code>, and contains <code>&lt;field&gt;</code> elements that assign values to each column. The <code>id</code> attribute corresponds to the record's external<a id="_idIndexMarker385"/> identifier, while the <code>model</code> attribute corresponds to the target <a id="_idIndexMarker386"/>model. The <code>&lt;field&gt;</code> elements have a few different ways to assign values. Let's look at them in detail.</p>
			<h3>Setting field values directly</h3>
			<p>The <code>name</code> attribute<a id="_idIndexMarker387"/> of a <code>&lt;field&gt;</code> element identifies the field to write on.</p>
			<p>The value to write is the element's content: the text between the field's opening and closing tag. For dates and date-times, <code>eval</code> attributes with expressions that return <code>date</code> or <code>datetime</code> objects will work. Returning strings with <code>"YYYY-mm-dd"</code> and <code>"YYYY-mm-dd HH:MM:SS"</code> will be converted properly. For boolean fields, the <code>"0"</code> and <code>"False"</code> values are converted into <code>False</code>, and any other non-empty values will be converted into <code>True</code>.</p>
			<p class="callout-heading">Changes in Odoo 10</p>
			<p class="callout">The way Boolean <code>False</code> values are read from data files has been improved in Odoo 10. In previous versions, any non-empty values, including <code>"0"</code> and <code>"False"</code>, were converted into <code>True</code>. Until Odoo 9, Boolean values should be set using the <code>eval</code> attribute, such as <code>eval="False"</code>.</p>
			<h3>Setting values using expressions</h3>
			<p>A more elaborate<a id="_idIndexMarker388"/> alternative for setting a field value is using the <code>eval</code> attribute. It<a id="_idIndexMarker389"/> evaluates a Python expression and assigns the result to the field.</p>
			<p>The expression is evaluated in a context that, besides Python built-ins, also has some additional identifiers that are available to build the expression to evaluate.</p>
			<p>To handle dates, the following Python modules are available: <code>time</code>, <code>datetime</code>, <code>timedelta</code>, and <code>relativedelta</code>. They allow you to calculate date values, something that is frequently used in demonstrations and test data so that the dates used are close to the module installation date. For more information about these Python modules, see the documentation at <a href="https://docs.python.org/3/library/datatypes.html">https://docs.python.org/3/library/datatypes.html</a>.</p>
			<p>For example, to set a value to yesterday, we can use the following code:</p>
			<pre>&lt;field name="date_published"
       <strong class="bold">eval="(datetime.now() + timedelta(-1))</strong>" /&gt;</pre>
			<p>Also available in the evaluation context is the <code>ref()</code> function, which is used to translate an external identifier into the corresponding database ID. This can be used to set values for relational fields. Here is an example:</p>
			<pre>&lt;field name="publisher_id" <strong class="bold">eval="ref('res_partner_packt')</strong>" /&gt;</pre>
			<p>This example sets a value for the <code>publisher_id</code> field using the <code>eval</code> attribute. The evaluated expression is Python code that uses the special <code>ref()</code> function, which is used to translate an <em class="italic">XML ID</em> into the corresponding database ID.</p>
			<h3>Setting values on many-to-one relationship fields</h3>
			<p>For many-to-one<a id="_idIndexMarker390"/> relationship fields, the value to write is the<a id="_idIndexMarker391"/> database ID for the linked record. In XML files, we usually know the <em class="italic">XML ID</em> for the record, and we need to have it translated into the actual database ID.</p>
			<p>One way to do this is to use the <code>eval</code> attribute with a <code>ref()</code> function, like we just did in the previous section.</p>
			<p>A simpler alternative is to use the <code>ref</code> attribute, which is available for <code>&lt;field&gt;</code> elements; for example:</p>
			<pre>&lt;field name="publisher_id" <strong class="bold">ref="res_partner_packt"</strong> /&gt;</pre>
			<p>This example sets a value for the <code>publisher_id</code> many-to-one field, referencing the database record with an <em class="italic">XML ID</em> of <code>res_partner_packt</code>.</p>
			<h3>Setting values on to-many relationship fields</h3>
			<p>For <a id="_idIndexMarker392"/>one-to-many and many-to-many fields, instead of a single ID, a <a id="_idIndexMarker393"/>list of related IDs is expected. Furthermore, several operations can be performed – we may want to replace the current list of related records with a new one, or append a few records to it, or even unlink some records.</p>
			<p>To support write operations on to-many fields, we can use a special syntax in the <code>eval</code> attribute. To write to a to-many field, we can use a <em class="italic">list</em> of <em class="italic">triples</em>. Each <em class="italic">triple</em> is a <code>write</code> command that does different things based on the code that was used in the first element.</p>
			<p>To overwrite the list of authors of a book, we would use the following code:</p>
			<pre>&lt;field name="author_ids"
       eval="[(6, 0, 
              [ref('res_partner_alexandre'), 
               ref('res_partner_holger')] 
              )]"
/&gt;</pre>
			<p>To append a linked record to the current list of the authors of a book, we would use the following code:</p>
			<pre>&lt;field name="author_ids" 
       eval="[(4, ref('res_partner_daniel'))]"
/&gt;</pre>
			<p>The preceding examples are the most common. In both cases, we used just one command, but we could chain several commands in the outer list. The <code>append (4)</code> and <code>replace (6)</code> commands are the most used. In the case of <code>append (4)</code>, the last value of the triple is not used and is not needed, so it can be omitted, as we did in the preceding code sample.</p>
			<p>The complete list of <a id="_idIndexMarker394"/>available <strong class="bold">to-many write commands</strong> is as follows:</p>
			<ul>
				<li><code>(0, _ , {'field': value})</code> creates a new record and links it to this one.</li>
				<li><code>(1, id, {'field': value})</code> updates the values on an already linked record.</li>
				<li><code>(2, id, _)</code> removes the link to and deletes the id-related record.</li>
				<li><code>(3, id, _)</code> removes the link to, but does not delete, the id-related record. This is usually what you will use to delete related records on many-to-many fields.</li>
				<li><code>(4, id, _)</code> links <a id="_idIndexMarker395"/>an already existing record. This can only <a id="_idIndexMarker396"/>be used for many-to-many fields.</li>
				<li><code>(5, _, _)</code> removes all the links, without deleting the linked records.</li>
				<li><code>(6, _, [ids])</code> replaces the list of linked records with the provided list.</li>
			</ul>
			<p>The <code>_</code> underscore symbol that was used in the preceding list represents irrelevant values, usually filled with <code>0</code> or <code>False</code>.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">The trailing irrelevant values can be safely omitted. For example, <code>(4, id, _)</code> can be used as <code>(4, id)</code>.</p>
			<p>In this section, we learned how to use the <code>&lt;record&gt;</code> tag to load records into the database. As an alternative, there are a few shortcut tags that can be used in place of a regular <code>&lt;record&gt;</code> tag. The next section will introduce these to us.</p>
			<h2 id="_idParaDest-156"><a id="_idTextAnchor160"/>Shortcuts for frequently used models</h2>
			<p>If we go back to <a href="B16119_03_Final_PD_ePub.xhtml#_idTextAnchor072"><em class="italic">Chapter 3</em></a>, <em class="italic">Your First Odoo Application</em>, we will find elements other than <code>&lt;record&gt;</code> in the XML files, such as <code>&lt;menuitem&gt;</code>.</p>
			<p>These are convenient shortcuts for frequently used models, with a more compact notation compared to the regular <code>&lt;record&gt;</code> elements. They are used to load data into base models that support the user interface, and they will be explored in more detail later, in <a href="B16119_10_Final_PD_ePub.xhtml#_idTextAnchor287"><em class="italic">Chapter 10</em></a>, <em class="italic">Backend Views – Designing the User Interface</em>.</p>
			<p>For reference, these are the shortcut elements available, along with the corresponding models they load data into:</p>
			<ul>
				<li><code>&lt;menuitem&gt;</code> is for the menu items model, <code>ir.ui.menu</code>.</li>
				<li><code>&lt;template&gt;</code> is for <em class="italic">QWeb</em> templates stored in the <code>ir.ui.view</code> model.<p class="callout-heading">Changes in Odoo 14</p><p class="callout">Past versions of Odoo used to support additional shortcut tags, which are not supported anymore. There was an <code>&lt;act_window&gt;</code> for the window action model, <code>ir.actions.act_window</code>, and a <code>&lt;report&gt;</code> for the report action model, <code>ir.actions.report.xml</code>.</p></li>
			</ul>
			<p>It is important to note that, when used to modify existing records, the shortcut elements overwrite all the fields. This differs from the <code>&lt;record&gt;</code> basic element, which only writes to the fields provided. So, for cases where we need to modify just a particular field of a user interface element, we should do so using a <code>&lt;record&gt;</code> element instead.</p>
			<h2 id="_idParaDest-157"><a id="_idTextAnchor161"/>Using other actions in XML data files</h2>
			<p>So far, we have seen how to <a id="_idIndexMarker397"/>add or update data using XML files. But XML files also allow you to delete data and execute arbitrary model methods. This can be useful for more complex data setups. In the following sections, we will learn how the delete and function call XML features can be used.</p>
			<h3>Deleting records</h3>
			<p>To delete a<a id="_idIndexMarker398"/> data record, we <a id="_idIndexMarker399"/>can use the <code>&lt;delete&gt;</code> element, providing it with either an ID or a search domain to find the target records.</p>
			<p>For example, using a search domain to find the record to delete looks as follows:</p>
			<pre>&lt;delete
  model="res.partner"
  search="[('id','=',ref(
    'library_app.res_partner_daniel'))]"
/&gt;</pre>
			<p>If we know the<a id="_idIndexMarker400"/> specific ID to delete, we can use it with the <code>id</code> attribute instead. This was <a id="_idIndexMarker401"/>the case for the previous example, so it could also be written like this:</p>
			<pre>&lt;delete model="res.partner" id="library_app.res_partner_daniel" /&gt;</pre>
			<p>This has the same effect as the previous example. Since we know the ID to look for, instead of using the <code>search</code> attribute with a domain expression, we can simply use the <code>id</code> attribute with the <em class="italic">XML ID</em>.</p>
			<h3>Calling model methods</h3>
			<p>An <code>XML</code> file can <a id="_idIndexMarker402"/>also execute<a id="_idIndexMarker403"/> arbitrary methods during its load process through the <code>&lt;function&gt;</code> element. This can be used to set up demo and test data.</p>
			<p>For example, the <strong class="bold">Notes</strong> app, which is bundled with Odoo, uses it to set up demonstration data:</p>
			<pre>&lt;data noupdate="1"&gt; 
&lt;function  
   model="res.users"  
   name="_init_data_user_note_stages"
   eval="[]" /&gt;
&lt;/data&gt;</pre>
			<p>This calls the <code>_init_data_user_note_stages</code> method of the <code>res.users</code> model, passing no arguments. The argument list is provided by the <code>eval</code> attribute, which is an empty list in this case.</p>
			<p>This completes everything we need to know to use XML data files. We provided an overview of <code>&lt;data&gt;</code> elements and the <code>noupdate</code> flag. We then learned how to use the <code>&lt;record&gt;</code> element to load data<a id="_idIndexMarker404"/> records, as well as how to set values on related fields. We also learned about record shortcuts, such as <code>&lt;menuitem&gt;</code> and <code>&lt;template&gt;</code>. Finally, we learned how to delete records and make<a id="_idIndexMarker405"/> arbitrary function calls with the <code>&lt;delete&gt;</code> and <code>&lt;function&gt;</code> elements.</p>
			<p>With this, we should be prepared to use XML data files for whatever data needs our project might have.</p>
			<h1 id="_idParaDest-158"><a id="_idTextAnchor162"/>Summary</h1>
			<p>In this chapter, we learned how to represent data in text files. These can be used to manually import data into Odoo or include it in add-on modules as default or <em class="italic">demonstration data</em>.</p>
			<p>At this point, we should be able to export and import CSV data files from the web interface and leverage <em class="italic">external IDs</em> to detect and update records that already exist in the database. They can also be used to perform a mass edit on data, by editing and reimporting a CSV file that has been exported from Odoo.</p>
			<p>We also learned about how XML data files are structured, and all the features they provide, in more detail. These were not only set values on fields but also actions such as deleting records and calling model methods.</p>
			<p>In the next chapter, we will focus on how to use <em class="italic">records</em> to work with the data contained in models. This will give us the necessary tools to then implement our application's business logic and rules.</p>
			<h1 id="_idParaDest-159"><a id="_idTextAnchor163"/>Further reading</h1>
			<p>The official Odoo documentation provides additional resources on data files: <a href="https://www.odoo.com/documentation/15.0/developer/reference/backend/data.html">https://www.odoo.com/documentation/15.0/developer/reference/backend/data.html</a>.</p>
		</div>
	</div></body></html>