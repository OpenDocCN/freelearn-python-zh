<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer052">
			<h1 id="_idParaDest-142"><a id="_idTextAnchor146"/><a href="B16119_05_Final_PD_ePub.xhtml#_idTextAnchor146"><em class="italic">Chapter 5</em></a>: Importing, Exporting, and Module Data</h1>
			<p>Most Odoo module definitions, such as <strong class="bold">user interfaces</strong> and <strong class="bold">security rules</strong>, are data records that are stored in specific <strong class="bold">database tables</strong>. The XML and CSV files that are found in modules are not used by Odoo applications at runtime. They are a means of loading those definitions into database tables.</p>
			<p>Because of this, an important part of Odoo modules is representing data in files so that it can be loaded into a database upon module installation. Modules can also contain initial data and demonstration data. Data files allow us to add that to our modules.</p>
			<p>Additionally, understanding Odoo data representation formats is important for exporting and importing business data within the context of a project's implementation.</p>
			<p>The following topics will be covered in this chapter:</p>
			<ul>
				<li>Understanding the external identifier concept</li>
				<li>Exporting and importing data files</li>
				<li>Using CSV files</li>
				<li>Adding module data</li>
				<li>Using XML data files</li>
			</ul>
			<p>By the end of this chapter, you will be able to perform data exports and imports to populate initial data into a database and automate the creation of default and demonstration data in modules that have been created.</p>
			<h1 id="_idParaDest-143"><a id="_idTextAnchor147"/>Technical requirements</h1>
			<p>This chapter requires you to have an Odoo server running, with the library app base module installed.</p>
			<p>The code for this chapter can be found in this book's GitHub repository, <a href="https://github.com/PacktPublishing/Odoo-15-Development-Essentials">https://github.com/PacktPublishing/Odoo-15-Development-Essentials</a>, in the <strong class="source-inline">ch05/</strong> directory. It contains a copy of the original <strong class="source-inline">library_app</strong> that we created in <a href="B16119_03_Final_PD_ePub.xhtml#_idTextAnchor072"><em class="italic">Chapter 3</em></a>, <em class="italic">Your First Odoo Application</em>, with additional files added for this chapter.</p>
			<h1 id="_idParaDest-144"><a id="_idTextAnchor148"/>Understanding the external identifier concept</h1>
			<p>An <strong class="bold">external identifier</strong>, also <a id="_idIndexMarker360"/>called an <strong class="bold">XML ID</strong>, is a <em class="italic">human-readable string identifier</em> that uniquely identifies a particular record in Odoo. They are important for loading data into Odoo, allowing us to modify an existing data record or reference it in other data records.</p>
			<p>First, we will introduce how external identifiers work, and how we can inspect them. Then, we will learn how to use the web client to find the external identifiers for particular data records, since this is frequently needed when creating add-on modules, thus extending existing features.</p>
			<h2 id="_idParaDest-145"><a id="_idTextAnchor149"/>How external identifiers work</h2>
			<p>Let's begin by understanding how <a id="_idIndexMarker361"/>identifiers work. The actual database identifier for a record is an automatically assigned sequential number, and there is no way to know ahead of time what ID will be assigned to each record during module installation. External identifiers let us reference a related record without the need to know the actual database ID that's been assigned to it. The XML ID provides a convenient alias for the database ID so that we can use it whenever we need to reference a particular record.</p>
			<p>Records defined in Odoo module data files use <em class="italic">XML IDs</em>. One reason for this is to avoid creating duplicate records when upgrading a module. The module upgrade will load the data files into the database again. We want it to detect pre-existing records for them to be updated, instead of creating duplicate records.</p>
			<p>Another reason to use XML IDs is to support interrelated data: data records that need to reference other data records. Since we can't know the actual database ID, we can use the XML ID, so the translation will be transparently handled by the <strong class="bold">Odoo framework</strong>.</p>
			<p>Odoo takes care of translating the external identifier names into the actual database IDs that have been assigned to them. The mechanism behind this is quite simple: Odoo keeps a table with the mapping between the named external identifiers and their corresponding numeric database IDs: the <strong class="source-inline">ir.model.data</strong> model.</p>
			<p>We must have <strong class="bold">Developer mode</strong> enabled to have the menu option available. Check whether you have the <em class="italic">Developer mode</em> bug icon in the top right, next to the user's avatar icon. If not, you should enable it now in the <strong class="bold">Settings</strong> top menu. Please refer to <a href="B16119_01_Final_PD_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Quick Start Using the Developer Mode</em>, for more details.</p>
			<p>We can inspect the existing mappings using the <strong class="bold">Settings</strong> | <strong class="bold">Technical</strong> | <strong class="bold">Sequences &amp; Identifiers</strong> | <strong class="bold">External Identifiers</strong> menu item. For example, if we visit the external identifiers list and filter it by the <strong class="source-inline">library_app</strong> module, we will see the external identifiers that have been generated by the module we created, as<a id="_idIndexMarker362"/> shown in the following screenshot:</p>
			<div>
				<div id="_idContainer044" class="IMG---Figure">
					<img src="Images/image_00_001.jpg" alt="Figure 5.1 – External identifiers generated by the library_app module&#13;&#10;" width="1211" height="637"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.1 – External identifiers generated by the library_app module</p>
			<p>Here, we can see that the external identifiers have <strong class="bold">Complete ID</strong> labels. Notice how they are composed of the module name and the identifier name, joined with a dot; for example, <strong class="source-inline">library_app.action_library_book</strong>.</p>
			<p>External identifiers only need to be unique inside an Odoo module so that there is no risk of two modules conflicting because of accidentally choosing the same identifier name. The globally unique identifier is built by joining the module name with the actual external identifier name. This is what you can see in the <strong class="bold">Complete ID</strong> field.</p>
			<p>When using an external identifier in a data file, we can choose to use either the complete identifier or just the external identifier name. Usually, it's simpler to just use the external identifier name, but the complete identifier enables us to reference data records from other modules. When doing so, make sure that those modules are included in the module dependencies to ensure that those records are loaded before ours.</p>
			<p>There are some cases where the complete ID is needed, even if we're referring to an XML ID from the same module.</p>
			<p>At the top of the list, we can see the <strong class="source-inline">library_app.action_library_book</strong> complete identifier. This is the menu action we created for the module, which is also referenced in the corresponding menu item. By clicking on it, we go to the form view, which contains its details. There, we can see that the <strong class="source-inline">action_library_book</strong> external identifier in the <strong class="source-inline">library_app</strong> module maps to a specific record ID in the <strong class="source-inline">ir.actions.act_window</strong> model, which is <strong class="source-inline">87</strong> in this case.</p>
			<p>By clicking on the <a id="_idIndexMarker363"/>record's line, the information can be seen in a form view, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer045" class="IMG---Figure">
					<img src="Images/image_00_002.jpg" alt="Figure 5.2 – Form view for the library_app.action_library_book external identifier&#13;&#10;" width="1212" height="456"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.2 – Form view for the library_app.action_library_book external identifier</p>
			<p>Besides providing a way for records to easily reference other records, external identifiers also allow you to avoid data duplication on repeated imports. If the external identifier is already present, the existing record will be updated, avoiding a new, duplicate record being created.</p>
			<h2 id="_idParaDest-146"><a id="_idTextAnchor150"/>Finding external identifiers</h2>
			<p>When we're <a id="_idIndexMarker364"/>writing data records for our modules, we frequently need to look up the existing external identifiers to use for our reference. So, it is important to know how to find these identifiers.</p>
			<p>One way to do this is to use the <strong class="bold">Settings</strong> | <strong class="bold">Technical</strong> | <strong class="bold">Sequences &amp; Identifiers</strong> | <strong class="bold">External Identifiers</strong> menu, which was shown earlier in <em class="italic">Figure 5.1</em>. We can also use the <strong class="bold">Developer</strong> menu for this. As you may recall from <a href="B16119_01_Final_PD_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Quick Start Using the Developer Mode</em>, the <strong class="bold">Developer</strong> menu can be activated in the <strong class="bold">Settings</strong> dashboard, at the bottom right.</p>
			<p>To find the external identifier for a data record, we should open the corresponding form view, select the <strong class="bold">Developer</strong> menu, and then choose the <strong class="bold">View Metadata</strong> option. This will display a dialog containing the record's database ID and external identifier (also known as the XML ID).</p>
			<p>For example, to look up the <strong class="source-inline">demo</strong> user ID, we should navigate to the users form view at <strong class="bold">Settings</strong> | <strong class="bold">Users</strong>, open the <strong class="source-inline">demo</strong> user form, and then select the <strong class="bold">View Metadata</strong> option from the <strong class="bold">Developer Tools</strong> menu. In the following screenshot, we can see that the XML ID is <strong class="source-inline">base.user_demo</strong> and that the database ID is <strong class="source-inline">6</strong>:</p>
			<div>
				<div id="_idContainer046" class="IMG---Figure">
					<img src="Images/image_00_003.jpg" alt="Figure 5.3 – The View Metadata dialog window&#13;&#10;" width="1230" height="507"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.3 – The View Metadata dialog window</p>
			<p>To find the external identifier for view elements, such as <strong class="bold">form</strong>, <strong class="bold">tree</strong>, <strong class="bold">search</strong>, or <strong class="bold">action</strong>, the <strong class="bold">Developer</strong> menu is also a good source of help. For this, we can use the appropriate <strong class="bold">Edit View</strong> option to open a form containing the details of the corresponding view. There, we will find an <strong class="bold">External ID</strong> field, which provides the information we are looking for.</p>
			<p>For example, in the following<a id="_idIndexMarker365"/> screenshot, we can see that the <strong class="bold">External ID</strong> property for the user's form view is <strong class="source-inline">base.view_users_form</strong>:</p>
			<div>
				<div id="_idContainer047" class="IMG---Figure">
					<img src="Images/image_00_004.jpg" alt="Figure 5.4 – The Edit View window showing the External ID property for a form view&#13;&#10;" width="1211" height="507"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.4 – The Edit View window showing the External ID property for a form view</p>
			<p>With that, we have learned about <strong class="bold">External IDs</strong> and how they can be used as aliases to reference database records. We have also looked at several ways to find the <strong class="bold">XML IDs</strong> that will be needed to reference records in the data files. Next, we will learn how to create data files where these <strong class="bold">XML IDs</strong> will be useful.</p>
			<h1 id="_idParaDest-147"><a id="_idTextAnchor151"/>Exporting and importing CSV data files</h1>
			<p>An easy way to generate data files and get insight into what structure the files should have is to use the built-in export feature.</p>
			<p>With generated CSV files, we <a id="_idIndexMarker366"/>can learn about the format that's needed to import data manually<a id="_idIndexMarker367"/> into the system, edit them to perform mass updates, or even use them to produce demo data for our add-on modules.</p>
			<p>In this section, we will learn about the basics of exporting and importing data from Odoo's user interface.</p>
			<h2 id="_idParaDest-148"><a id="_idTextAnchor152"/>Exporting data</h2>
			<p><strong class="bold">Data exporting</strong> is a standard<a id="_idIndexMarker368"/> feature that's available in any list view. To use it, we must pick the rows to export by selecting the corresponding checkboxes, on the far left, and then selecting the <strong class="bold">Export</strong> option from the <strong class="bold">Action</strong> button at the top of the list.</p>
			<p>First, we should add a couple of Odoo books to the <strong class="bold">Library</strong> app, along with their publishers and authors. For this example, we created <strong class="source-inline">Odoo Development Essentials 11</strong> and <strong class="source-inline">Odoo 11 Development Cookbook</strong>.</p>
			<p>We also need to have the <strong class="bold">Contacts</strong> app installed so that we can see a <strong class="bold">Partner</strong> list view and can export those records from there. Notice that the default view is <strong class="bold">Kanban</strong> for the contact cards, so we need to switch to the <strong class="bold">list</strong> view:</p>
			<div>
				<div id="_idContainer048" class="IMG---Figure">
					<img src="Images/image_00_005.jpg" alt="Figure 5.5 – The Export option in the Action menu&#13;&#10;" width="1256" height="334"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.5 – The Export option in the Action menu</p>
			<p>We can also tick the checkbox in the header of the column to select all of the available records that match the current search criteria.</p>
			<p>The <strong class="bold">Export</strong> option takes us to the <strong class="bold">Export Data</strong> dialog form, where we can choose what and how to export. We are concerned with exporting in a way that allows us to import that file later, either manually or as part of an add-on module:</p>
			<div>
				<div id="_idContainer049" class="IMG---Figure">
					<img src="Images/image_00_006.jpg" alt="Figure 5.6 – The Export Data dialog window&#13;&#10;" width="1126" height="568"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.6 – The Export Data dialog window</p>
			<p>At the top of the <a id="_idIndexMarker369"/>dialog form, we have two selections available:</p>
			<ul>
				<li><strong class="bold">I want to update data (import-compatible export)</strong>: Enable this checkbox so that the data is exported in a format-friendly manner for a later import.</li>
				<li><strong class="bold">Export format</strong>: You can choose between <strong class="bold">CSV</strong> or <strong class="bold">XLSX</strong> here. We will choose a <strong class="bold">CSV</strong> file to get a better understanding of the raw export format, which is still understood by any spreadsheet application.</li>
			</ul>
			<p>Next, pick the columns to export. In this example, a very simple export was done by choosing only the <strong class="bold">Name</strong> field. By clicking on the <strong class="bold">Export</strong> button, an exported data file will be available. The exported CSV file should look like this:</p>
			<p class="source-code">"id","name"</p>
			<p class="source-code">"__export__.res_partner_43_f82d2ecc","Alexandre Fayolle"</p>
			<p class="source-code">"__export__.res_partner_41_30a5bc3c","Daniel Reis"</p>
			<p class="source-code">"__export__.res_partner_44_6be5a130","Holger Brunn"</p>
			<p class="source-code">"__export__.res_partner_42_38b48275","Packt Publishing"</p>
			<p>The first row contains the <strong class="bold">field names</strong>, which will be used during the import to automatically map the columns to their destination.</p>
			<p>The first row has the selected <strong class="source-inline">name</strong> column, as expected. An initial ID column was automatically added because the import-compatible export option was selected.</p>
			<p>The automatically added <strong class="source-inline">id</strong> column has the external ID assigned to each record. This allows the exported data file to be edited and reimported later, to update the records, instead of creating duplicated ones.</p>
			<p>Missing external<a id="_idIndexMarker370"/> identifiers are automatically generated using the <strong class="source-inline">__export__</strong> prefix, as shown in the previous file export example.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Because of the automatically generated record identifiers, the export or import features can be used to mass edit Odoo data – export the data to CSV, use spreadsheet software to mass edit it, and then import it back into Odoo.</p>
			<h2 id="_idParaDest-149"><a id="_idTextAnchor153"/>Importing data</h2>
			<p>Once we have a properly<a id="_idIndexMarker371"/> formatted data file ready, we want to import it into Odoo. Let's learn how this is can be done through the web client user interface.</p>
			<p>First, we have to make sure that the import feature is <em class="italic">enabled</em>. It should be enabled by default. If not, the option is available in the <strong class="bold">Settings</strong> app, under the <strong class="bold">General Settings</strong> menu item. Under the <strong class="bold">Permissions</strong> section, the <strong class="bold">Import &amp; Export</strong> option should be checked.</p>
			<p>With this option enabled, the list view search widget will show an <strong class="bold">Import records</strong> option in the <strong class="bold">Favorites</strong> menu, next to the <strong class="bold">Filters</strong> and <strong class="bold">Group By</strong> menus.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <strong class="bold">Import &amp; Export</strong> setting installs the <strong class="source-inline">base_import</strong> module, which is responsible for providing this feature.</p>
			<p>Let's try performing a bulk edit on our <em class="italic">Contact</em> or <em class="italic">Partner</em> data. Open the CSV file we just downloaded in a spreadsheet or a text editor and change a few values. We can also add some new rows, leaving the <strong class="source-inline">id</strong> column blank for them.</p>
			<p>As we mentioned previously, the first column, <strong class="source-inline">id</strong>, provides a unique identifier for each row. This allows pre-existing records to be updated instead of us needing to duplicate them when we import the data back to Odoo. If we edit any of the names in the exported file, the corresponding record will be updated when we import the file.</p>
			<p>For the new rows that have been added to the CSV file, we can choose to either provide an external identifier of our choice or we can leave the <strong class="source-inline">id</strong> column blank. Either way, a new record will be created for them. As an example, we added a line with no <strong class="source-inline">id</strong> and the name <strong class="source-inline">Phillip K. Dick</strong> to be created in the database:</p>
			<p class="source-code">,Phillip K. Dick</p>
			<p>After saving these <a id="_idIndexMarker372"/>changes to the <strong class="bold">CSV</strong> file, click on the <strong class="bold">Import</strong> option, in the <strong class="bold">Favorites</strong> menu. The next page allows us to upload the data file. Then, the import assistant will be presented:</p>
			<div>
				<div id="_idContainer050" class="IMG---Figure">
					<img src="Images/image_00_007.jpg" alt="Figure 5.7 – The Import a File assistant&#13;&#10;" width="1126" height="533"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.7 – The Import a File assistant</p>
			<p>Here, we should select the CSV file's location on the disk and then click on the <strong class="bold">Test</strong> button, at the top left, to check it for correctness.</p>
			<p>Since the file to import is based on an Odoo export, there is a good chance that it will be valid and that the columns will be automatically mapped to their proper destination in the database. Depending on the application that's used to edit the data file, you may have to play with the separator and encoding options to get the best results.</p>
			<p>Now, click on <strong class="bold">Import</strong>, and there you go – the modifications and new records should have been loaded into Odoo!</p>
			<h2 id="_idParaDest-150"><a id="_idTextAnchor154"/>Related records in CSV data files</h2>
			<p>The examples in the previous section <a id="_idIndexMarker373"/>were quite simple, but the data files can become more complex once we start using relational fields, linking records from several tables.</p>
			<p>Previously, we handled <em class="italic">Partner</em> records that were used in <em class="italic">Books</em>. We will now look at how we can represent the reference for these Partners in a CSV file for book data. In particular, we have a many-to-one (or a foreign key) relationship for the Publisher (the <strong class="source-inline">publisher_id</strong> field) and a many-to-many relationship for the Authors (the <strong class="source-inline">author_ids</strong> field).</p>
			<p>In the CSV file header line, relationship columns should have <strong class="source-inline">/id</strong> appended to their names. It will reference the related records using external identifiers. In our example, we will load the book publisher into a <strong class="source-inline">publisher_id/id</strong> field, using the external ID for the related partner as a value.</p>
			<p>It is possible to use <strong class="source-inline">/.id</strong> instead so that we can use the actual database IDs (the real numeric identifier that's been assigned), but this is rarely what we need. Unless you have good reason to do otherwise, always use external IDs instead of database IDs. Also, remember that database IDs are specific to a particular Odoo database, so, most of the time, it won't work correctly if it's imported into a database other than the original one.</p>
			<p>Many-to-many fields can also be imported through <strong class="source-inline">CSV</strong> data files. It's as easy as providing a comma-separated list of external IDs, surrounded by double quotes. For example, to load the book authors, we would have an <strong class="source-inline">author_ids/id</strong> column, where we would use a comma-separated list of the external IDs of the Partners to link as values. Here is an example of what a to-many field would look like in a CSV file:</p>
			<p class="source-code">id, name, author_ids/id</p>
			<p class="source-code">book_odc11, "Odoo 11 Development Cookbook", "__export__.res_partner_43_f82d2ecc,__export__.res_partner_44_6be5a130"</p>
			<p>One-to-many fields often represent headers or lines, or parent or child relationships, and there is special support to import these types of relationships – for the same parent record, we can have several related lines.</p>
			<p>Here, we have an example of a one-to-many field in the <em class="italic">Partners</em> model: a company partner can have several child contacts. If we export the data from the <em class="italic">Partner</em> model and include the <strong class="bold">Contacts</strong>/<strong class="bold">Name</strong> field, we will see the structure that can be used to import this type of data:</p>
			<div>
				<div id="_idContainer051" class="IMG---Figure">
					<img src="Images/image_00_008.jpg" alt="Figure 5.8 – Data file example importing to-many related records&#13;&#10;" width="920" height="97"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.8 – Data file example importing to-many related records</p>
			<p>The <strong class="source-inline">id</strong> and <strong class="source-inline">name</strong> columns are<a id="_idIndexMarker374"/> for the parent records, while the <strong class="source-inline">child_ids</strong> columns are for the child records. Notice how the parent record columns are left blank for the child records after the first one.</p>
			<p>The preceding table, which is represented as a CSV file, looks as follows:</p>
			<p class="source-code">"id","name","child_ids/id","child_ids/name"</p>
			<p class="source-code">"base.res_partner_12","Azure Interior","base.res_partner_address_15","Brandon Freeman"</p>
			<p class="source-code">"","","base.res_partner_address_28","Colleen Diaz"</p>
			<p class="source-code">"","","base.res_partner_address_16","Nicole Ford"</p>
			<p>Here, we can see that the first two columns, <strong class="source-inline">id</strong> and <strong class="source-inline">name</strong>, have values in the first line and are empty in the next two lines. They have data for the parent record, which is the <em class="italic">Contact's Company</em>.</p>
			<p>The other two columns are both prefixed with <strong class="source-inline">child_ids/</strong> and have values on all three lines. They contain data for the contacts related to the parent company. The first line contains data for both the company and the first contact, while the lines that follow contain data for the columns of the child contacts.</p>
			<h1 id="_idParaDest-151"><a id="_idTextAnchor155"/>Adding module data</h1>
			<p>Modules use data files to load <a id="_idIndexMarker375"/>their default data, demonstration data, user interface definitions, and other configurations into the database. For this, we can use both CSV and XML files.</p>
			<p class="callout-heading">Changes in Odoo 12</p>
			<p class="callout">The YAML file format was also supported until Odoo 11 and was removed in Odoo 12. Still, for a usage example, you can look at the <strong class="source-inline">l10n_be</strong> official module in Odoo 11, and for information on the YAML<a id="_idIndexMarker376"/> format, you can visit <a href="http://yaml.org/">http://yaml.org/</a>.</p>
			<p>CSV files that are used by modules are the same as those we have seen and used for the import feature. When using them in modules, the filename must match the name of the model that the data will be loaded into. For example, a CSV file for loading data into the <strong class="source-inline">library.book</strong> model must be named <strong class="source-inline">library.book.csv</strong>.</p>
			<p>A common usage of data CSV <a id="_idIndexMarker377"/>files is for accessing security definitions that have been loaded into the <strong class="source-inline">ir.model.access</strong> model. They usually use CSV files in a <strong class="source-inline">security/</strong> subdirectory, named <strong class="source-inline">ir.model.access.csv</strong>.</p>
			<h2 id="_idParaDest-152"><a id="_idTextAnchor156"/>Demonstration data</h2>
			<p>Odoo add-on modules may install <a id="_idIndexMarker378"/>demonstration data, and it is considered good practice to do so. This is useful for providing usage examples for a module and the datasets to be used in tests. Demonstration data for a module is declared using the <strong class="source-inline">demo</strong> attribute of the <strong class="source-inline">__manifest__.py</strong> manifest file. Just like the <strong class="source-inline">data</strong> attribute, it is a list of filenames with the corresponding relative paths inside the module.</p>
			<p>Some demonstration data should be added to the <strong class="source-inline">library.book</strong> module. An easy way to do this is to export some data from the development database with the module installed.</p>
			<p>The convention is to place data files in a <strong class="source-inline">data/</strong> subdirectory. We should save these data files in the <strong class="source-inline">library_app</strong> add-on module as <strong class="source-inline">data/library.book.csv</strong>. Since this data will be owned by our module, we should edit the <strong class="source-inline">id</strong> values to remove the <strong class="source-inline">__export__</strong> prefix in the identifiers that are generated by the export feature.</p>
			<p>As an example, our <strong class="source-inline">res.partner.csv</strong> data file might look as follows:</p>
			<p class="source-code"><strong class="bold">id,name</strong> </p>
			<p class="source-code">res_partner_alexandre,"Alexandre Fayolle" </p>
			<p class="source-code">res_partner_daniel,"Daniel Reis" </p>
			<p class="source-code">res_partner_holger,"Holger Brunn"</p>
			<p class="source-code">res_partner_packt,"Packt Publishing"</p>
			<p>The <strong class="source-inline">library.book.csv</strong> data file containing the Book demo data will look as follows:</p>
			<p class="source-code"><strong class="bold">"id","name","date_published","publisher_id/id","author_ids/id"</strong></p>
			<p class="source-code">library_book_ode11,"Odoo Development Essentials 11","2018-03-01",res_partner_packt,res_partner_daniel</p>
			<p class="source-code">library_book_odc11,"Odoo 11 Development Cookbook","2018-01-01",res_partner_packt,"res_partner_alexandre,res_partner_holger"</p>
			<p>Do not forget to add these data files to the <strong class="source-inline">__manifest__.py</strong> manifest's <strong class="source-inline">demo</strong> attribute:</p>
			<p class="source-code">"demo": [</p>
			<p class="source-code">    "data/res.partner.csv",</p>
			<p class="source-code">    "data/library.book.csv",</p>
			<p class="source-code">],</p>
			<p>The files are loaded in the<a id="_idIndexMarker379"/> order they are declared. This is important since records in a file cannot reference other records that haven't been created yet.</p>
			<p>The next time the module is updated, the content of the file will be imported, so long as it is installed with the demo data enabled.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">While data files are also re-imported on module upgrades, this is not the case for the demo data files: these are only imported upon module installation.</p>
			<p>Of course, XML files can also be used to load or initialize data, leveraging the additional features they provide, compared to plain CSV files. In the next section, we will discuss using data files in XML format.</p>
			<h1 id="_idParaDest-153"><a id="_idTextAnchor157"/>Using XML data files</h1>
			<p>While CSV files <a id="_idIndexMarker380"/>provide a simple and compact format to represent data, XML files are more powerful and give more control over the loading process. For example, their filenames are not required to match the model to be loaded. This is because the XML format is much richer and more information regarding what to load can be provided through the XML elements inside the file.</p>
			<p>We used XML data files in the previous chapters. The user interface components, such as the views and menu items, are, in fact, records that are stored in system models. The XML files in the modules are used to load these records into the instance database.</p>
			<p>To showcase this, a second data file will be added to the <strong class="source-inline">library_app</strong> module, <strong class="source-inline">data/book_demo.xml</strong>, with the following content:</p>
			<p class="source-code">&lt;?xml version="1.0"?&gt;</p>
			<p class="source-code">&lt;odoo noupdate="1"&gt;</p>
			<p class="source-code">  &lt;!-- Data to load --&gt;</p>
			<p class="source-code">  &lt;record model="res.partner" id="res_partner_huxley"&gt; </p>
			<p class="source-code">    &lt;field name="name"&gt;Aldous Huxley&lt;/field&gt; </p>
			<p class="source-code">  &lt;/record&gt; </p>
			<p class="source-code">  &lt;record model="library.book" id="library_book_bnw"&gt;</p>
			<p class="source-code">    &lt;field name="name"&gt;Brave New World&lt;/field&gt;</p>
			<p class="source-code">    &lt;field name="author_ids"</p>
			<p class="source-code">           eval="[(4, ref('res_partner_huxley'))]" /&gt;</p>
			<p class="source-code">    &lt;field name="date_published"&gt;1932-01-01&lt;/field&gt;</p>
			<p class="source-code">  &lt;/record&gt;</p>
			<p class="source-code">&lt;/odoo&gt;</p>
			<p>As usual, the new <a id="_idIndexMarker381"/>data file must be declared in the <strong class="source-inline">__manifest__.py</strong> file:</p>
			<p class="source-code">"demo": [</p>
			<p class="source-code">    "data/res.partner.csv",</p>
			<p class="source-code">    "data/library.book.csv",</p>
			<p class="source-code"><strong class="bold">    "data/book_demo.xml",</strong></p>
			<p class="source-code">],</p>
			<p>Similar to the CSV data file we saw in the previous section, this file also loads data into the <em class="italic">Library Books</em> model.</p>
			<p>XML data files have an <strong class="source-inline">&lt;odoo&gt;</strong> top element, inside of which there can be several <strong class="source-inline">&lt;record&gt;</strong> elements, which are the equivalent to data rows in CSV files.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <strong class="source-inline">&lt;odoo&gt;</strong> top element in data files was introduced in version 9.0 and replaces the former <strong class="source-inline">&lt;openerp&gt;</strong> tag. A <strong class="source-inline">&lt;data&gt;</strong> section inside the top element is still supported, but it's now optional. In fact, now, <strong class="source-inline">&lt;odoo&gt;</strong> and <strong class="source-inline">&lt;data&gt;</strong> are equivalent, so we could use either one as the top element for our XML data files.</p>
			<p>A <strong class="source-inline">&lt;record&gt;</strong> element <a id="_idIndexMarker382"/>has two mandatory attributes, <strong class="source-inline">model</strong> and <strong class="source-inline">id</strong>, for the external identifier for the record, and contains a <strong class="source-inline">&lt;field&gt;</strong> tag for each field to write on.</p>
			<p>Note that the slash notation in the field names is not available here; we can't use <strong class="source-inline">&lt;field name="publisher_id/id"&gt;</strong>. Instead, the <strong class="source-inline">ref</strong> special attribute is used to reference external identifiers. We'll discuss the values of the relational to-many fields in a moment.</p>
			<p>You may have noticed the <strong class="source-inline">noupdate="1"</strong> attribute in the top <strong class="source-inline">&lt;odoo&gt;</strong> element. This prevents the data records from being loaded on module upgrades so that any later edits that are made to them are not lost.</p>
			<h2 id="_idParaDest-154"><a id="_idTextAnchor158"/>The noupdate data attribute</h2>
			<p>When a module is upgraded, the data <a id="_idIndexMarker383"/>file loading is repeated, and the module's records are rewritten. This means that upgrading a module will overwrite any manual changes that might have been made to the module's data.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Notably, if views were manually modified to add quick customizations, these changes will be lost with the next module upgrade. To avoid this, the correct approach is to create inherited views with the changes we want to introduce.</p>
			<p>This rewrite behavior is the default, but it can be changed so that some of the data is only imported at install time, and is ignored in later module upgrades. This can be done using the <strong class="source-inline">noupdate="1"</strong> attribute in the <strong class="source-inline">&lt;odoo&gt;</strong> or <strong class="source-inline">&lt;data&gt;</strong> elements.</p>
			<p>This is useful for data that is to be used for the initial configuration but is expected to be customized later since these manually made customizations will be safe from module upgrades. For example, it is frequently used for record access rules, allowing them to be adapted to implementation-specific needs.</p>
			<p>It is possible to have more than one <strong class="source-inline">&lt;data&gt;</strong> section in the same <strong class="source-inline">XML</strong> file. We can take advantage of this to separate data to import only once, with <strong class="source-inline">noupdate="1"</strong>, and data that can be re-imported on each upgrade, with <strong class="source-inline">noupdate="0"</strong>. <strong class="source-inline">noupdate="0"</strong> is the default, so we can just omit it if we prefer. Note that we need to have a top-level XML element, so in this case, we will use two <strong class="source-inline">&lt;data&gt;</strong> sections. They must be inside a top-level <strong class="source-inline">&lt;odoo&gt;</strong> or <strong class="source-inline">&lt;data&gt;</strong> element.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">The <strong class="source-inline">noupdate</strong> attribute can be tricky when we're developing modules because changes that are made to the data later will be ignored. One solution is to, instead of upgrading the module with the <strong class="source-inline">-u</strong> option, reinstall it using the <strong class="source-inline">-i</strong> option. Reinstalling from the command line using the <strong class="source-inline">-i</strong> option ignores the <strong class="source-inline">noupdate</strong> flags on data records.</p>
			<p>The <strong class="source-inline">noupdate</strong> flag is<a id="_idIndexMarker384"/> stored in the <strong class="bold">External Identifier</strong> information for each record. It's possible to manually edit it directly using the <strong class="bold">External Identifier</strong> form, which is available in the <strong class="bold">Technical</strong> menu, by using the <strong class="bold">Non Updatable</strong> checkbox.</p>
			<p class="callout-heading">Changes in Odoo 12</p>
			<p class="callout">In <strong class="bold">Developer Menu</strong>, when accessing <strong class="bold">View Metadata</strong>, the dialog box now also shows the value for the <strong class="bold">No Update</strong> flag, along with the record's <strong class="bold">XML ID</strong>. Furthermore, <strong class="bold">No Update flag</strong> can be changed there by clicking on it.</p>
			<h2 id="_idParaDest-155"><a id="_idTextAnchor159"/>Defining records in XML</h2>
			<p>In an <strong class="source-inline">XML</strong> data file, each <strong class="source-inline">&lt;record&gt;</strong> element has two basic attributes, <strong class="source-inline">id</strong> and <strong class="source-inline">model</strong>, and contains <strong class="source-inline">&lt;field&gt;</strong> elements that assign values to each column. The <strong class="source-inline">id</strong> attribute corresponds to the record's external<a id="_idIndexMarker385"/> identifier, while the <strong class="source-inline">model</strong> attribute corresponds to the target <a id="_idIndexMarker386"/>model. The <strong class="source-inline">&lt;field&gt;</strong> elements have a few different ways to assign values. Let's look at them in detail.</p>
			<h3>Setting field values directly</h3>
			<p>The <strong class="source-inline">name</strong> attribute<a id="_idIndexMarker387"/> of a <strong class="source-inline">&lt;field&gt;</strong> element identifies the field to write on.</p>
			<p>The value to write is the element's content: the text between the field's opening and closing tag. For dates and date-times, <strong class="source-inline">eval</strong> attributes with expressions that return <strong class="source-inline">date</strong> or <strong class="source-inline">datetime</strong> objects will work. Returning strings with <strong class="source-inline">"YYYY-mm-dd"</strong> and <strong class="source-inline">"YYYY-mm-dd HH:MM:SS"</strong> will be converted properly. For boolean fields, the <strong class="source-inline">"0"</strong> and <strong class="source-inline">"False"</strong> values are converted into <strong class="source-inline">False</strong>, and any other non-empty values will be converted into <strong class="source-inline">True</strong>.</p>
			<p class="callout-heading">Changes in Odoo 10</p>
			<p class="callout">The way Boolean <strong class="source-inline">False</strong> values are read from data files has been improved in Odoo 10. In previous versions, any non-empty values, including <strong class="source-inline">"0"</strong> and <strong class="source-inline">"False"</strong>, were converted into <strong class="source-inline">True</strong>. Until Odoo 9, Boolean values should be set using the <strong class="source-inline">eval</strong> attribute, such as <strong class="source-inline">eval="False"</strong>.</p>
			<h3>Setting values using expressions</h3>
			<p>A more elaborate<a id="_idIndexMarker388"/> alternative for setting a field value is using the <strong class="source-inline">eval</strong> attribute. It<a id="_idIndexMarker389"/> evaluates a Python expression and assigns the result to the field.</p>
			<p>The expression is evaluated in a context that, besides Python built-ins, also has some additional identifiers that are available to build the expression to evaluate.</p>
			<p>To handle dates, the following Python modules are available: <strong class="source-inline">time</strong>, <strong class="source-inline">datetime</strong>, <strong class="source-inline">timedelta</strong>, and <strong class="source-inline">relativedelta</strong>. They allow you to calculate date values, something that is frequently used in demonstrations and test data so that the dates used are close to the module installation date. For more information about these Python modules, see the documentation at <a href="https://docs.python.org/3/library/datatypes.html">https://docs.python.org/3/library/datatypes.html</a>.</p>
			<p>For example, to set a value to yesterday, we can use the following code:</p>
			<p class="source-code">&lt;field name="date_published"</p>
			<p class="source-code">       <strong class="bold">eval="(datetime.now() + timedelta(-1))</strong>" /&gt;</p>
			<p>Also available in the evaluation context is the <strong class="source-inline">ref()</strong> function, which is used to translate an external identifier into the corresponding database ID. This can be used to set values for relational fields. Here is an example:</p>
			<p class="source-code">&lt;field name="publisher_id" <strong class="bold">eval="ref('res_partner_packt')</strong>" /&gt;</p>
			<p>This example sets a value for the <strong class="source-inline">publisher_id</strong> field using the <strong class="source-inline">eval</strong> attribute. The evaluated expression is Python code that uses the special <strong class="source-inline">ref()</strong> function, which is used to translate an <em class="italic">XML ID</em> into the corresponding database ID.</p>
			<h3>Setting values on many-to-one relationship fields</h3>
			<p>For many-to-one<a id="_idIndexMarker390"/> relationship fields, the value to write is the<a id="_idIndexMarker391"/> database ID for the linked record. In XML files, we usually know the <em class="italic">XML ID</em> for the record, and we need to have it translated into the actual database ID.</p>
			<p>One way to do this is to use the <strong class="source-inline">eval</strong> attribute with a <strong class="source-inline">ref()</strong> function, like we just did in the previous section.</p>
			<p>A simpler alternative is to use the <strong class="source-inline">ref</strong> attribute, which is available for <strong class="source-inline">&lt;field&gt;</strong> elements; for example:</p>
			<p class="source-code">&lt;field name="publisher_id" <strong class="bold">ref="res_partner_packt"</strong> /&gt;</p>
			<p>This example sets a value for the <strong class="source-inline">publisher_id</strong> many-to-one field, referencing the database record with an <em class="italic">XML ID</em> of <strong class="source-inline">res_partner_packt</strong>.</p>
			<h3>Setting values on to-many relationship fields</h3>
			<p>For <a id="_idIndexMarker392"/>one-to-many and many-to-many fields, instead of a single ID, a <a id="_idIndexMarker393"/>list of related IDs is expected. Furthermore, several operations can be performed – we may want to replace the current list of related records with a new one, or append a few records to it, or even unlink some records.</p>
			<p>To support write operations on to-many fields, we can use a special syntax in the <strong class="source-inline">eval</strong> attribute. To write to a to-many field, we can use a <em class="italic">list</em> of <em class="italic">triples</em>. Each <em class="italic">triple</em> is a <strong class="source-inline">write</strong> command that does different things based on the code that was used in the first element.</p>
			<p>To overwrite the list of authors of a book, we would use the following code:</p>
			<p class="source-code">&lt;field name="author_ids"</p>
			<p class="source-code">       eval="[(6, 0, </p>
			<p class="source-code">              [ref('res_partner_alexandre'), </p>
			<p class="source-code">               ref('res_partner_holger')] </p>
			<p class="source-code">              )]"</p>
			<p class="source-code">/&gt;</p>
			<p>To append a linked record to the current list of the authors of a book, we would use the following code:</p>
			<p class="source-code">&lt;field name="author_ids" </p>
			<p class="source-code">       eval="[(4, ref('res_partner_daniel'))]"</p>
			<p class="source-code">/&gt;</p>
			<p>The preceding examples are the most common. In both cases, we used just one command, but we could chain several commands in the outer list. The <strong class="source-inline">append (4)</strong> and <strong class="source-inline">replace (6)</strong> commands are the most used. In the case of <strong class="source-inline">append (4)</strong>, the last value of the triple is not used and is not needed, so it can be omitted, as we did in the preceding code sample.</p>
			<p>The complete list of <a id="_idIndexMarker394"/>available <strong class="bold">to-many write commands</strong> is as follows:</p>
			<ul>
				<li><strong class="source-inline">(0, _ , {'field': value})</strong> creates a new record and links it to this one.</li>
				<li><strong class="source-inline">(1, id, {'field': value})</strong> updates the values on an already linked record.</li>
				<li><strong class="source-inline">(2, id, _)</strong> removes the link to and deletes the id-related record.</li>
				<li><strong class="source-inline">(3, id, _)</strong> removes the link to, but does not delete, the id-related record. This is usually what you will use to delete related records on many-to-many fields.</li>
				<li><strong class="source-inline">(4, id, _)</strong> links <a id="_idIndexMarker395"/>an already existing record. This can only <a id="_idIndexMarker396"/>be used for many-to-many fields.</li>
				<li><strong class="source-inline">(5, _, _)</strong> removes all the links, without deleting the linked records.</li>
				<li><strong class="source-inline">(6, _, [ids])</strong> replaces the list of linked records with the provided list.</li>
			</ul>
			<p>The <strong class="source-inline">_</strong> underscore symbol that was used in the preceding list represents irrelevant values, usually filled with <strong class="source-inline">0</strong> or <strong class="source-inline">False</strong>.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">The trailing irrelevant values can be safely omitted. For example, <strong class="source-inline">(4, id, _)</strong> can be used as <strong class="source-inline">(4, id)</strong>.</p>
			<p>In this section, we learned how to use the <strong class="source-inline">&lt;record&gt;</strong> tag to load records into the database. As an alternative, there are a few shortcut tags that can be used in place of a regular <strong class="source-inline">&lt;record&gt;</strong> tag. The next section will introduce these to us.</p>
			<h2 id="_idParaDest-156"><a id="_idTextAnchor160"/>Shortcuts for frequently used models</h2>
			<p>If we go back to <a href="B16119_03_Final_PD_ePub.xhtml#_idTextAnchor072"><em class="italic">Chapter 3</em></a>, <em class="italic">Your First Odoo Application</em>, we will find elements other than <strong class="source-inline">&lt;record&gt;</strong> in the XML files, such as <strong class="source-inline">&lt;menuitem&gt;</strong>.</p>
			<p>These are convenient shortcuts for frequently used models, with a more compact notation compared to the regular <strong class="source-inline">&lt;record&gt;</strong> elements. They are used to load data into base models that support the user interface, and they will be explored in more detail later, in <a href="B16119_10_Final_PD_ePub.xhtml#_idTextAnchor287"><em class="italic">Chapter 10</em></a>, <em class="italic">Backend Views – Designing the User Interface</em>.</p>
			<p>For reference, these are the shortcut elements available, along with the corresponding models they load data into:</p>
			<ul>
				<li><strong class="source-inline">&lt;menuitem&gt;</strong> is for the menu items model, <strong class="source-inline">ir.ui.menu</strong>.</li>
				<li><strong class="source-inline">&lt;template&gt;</strong> is for <em class="italic">QWeb</em> templates stored in the <strong class="source-inline">ir.ui.view</strong> model.<p class="callout-heading">Changes in Odoo 14</p><p class="callout">Past versions of Odoo used to support additional shortcut tags, which are not supported anymore. There was an <strong class="source-inline">&lt;act_window&gt;</strong> for the window action model, <strong class="source-inline">ir.actions.act_window</strong>, and a <strong class="source-inline">&lt;report&gt;</strong> for the report action model, <strong class="source-inline">ir.actions.report.xml</strong>.</p></li>
			</ul>
			<p>It is important to note that, when used to modify existing records, the shortcut elements overwrite all the fields. This differs from the <strong class="source-inline">&lt;record&gt;</strong> basic element, which only writes to the fields provided. So, for cases where we need to modify just a particular field of a user interface element, we should do so using a <strong class="source-inline">&lt;record&gt;</strong> element instead.</p>
			<h2 id="_idParaDest-157"><a id="_idTextAnchor161"/>Using other actions in XML data files</h2>
			<p>So far, we have seen how to <a id="_idIndexMarker397"/>add or update data using XML files. But XML files also allow you to delete data and execute arbitrary model methods. This can be useful for more complex data setups. In the following sections, we will learn how the delete and function call XML features can be used.</p>
			<h3>Deleting records</h3>
			<p>To delete a<a id="_idIndexMarker398"/> data record, we <a id="_idIndexMarker399"/>can use the <strong class="source-inline">&lt;delete&gt;</strong> element, providing it with either an ID or a search domain to find the target records.</p>
			<p>For example, using a search domain to find the record to delete looks as follows:</p>
			<p class="source-code">&lt;delete</p>
			<p class="source-code">  model="res.partner"</p>
			<p class="source-code">  search="[('id','=',ref(</p>
			<p class="source-code">    'library_app.res_partner_daniel'))]"</p>
			<p class="source-code">/&gt;</p>
			<p>If we know the<a id="_idIndexMarker400"/> specific ID to delete, we can use it with the <strong class="source-inline">id</strong> attribute instead. This was <a id="_idIndexMarker401"/>the case for the previous example, so it could also be written like this:</p>
			<p class="source-code">&lt;delete model="res.partner" id="library_app.res_partner_daniel" /&gt;</p>
			<p>This has the same effect as the previous example. Since we know the ID to look for, instead of using the <strong class="source-inline">search</strong> attribute with a domain expression, we can simply use the <strong class="source-inline">id</strong> attribute with the <em class="italic">XML ID</em>.</p>
			<h3>Calling model methods</h3>
			<p>An <strong class="source-inline">XML</strong> file can <a id="_idIndexMarker402"/>also execute<a id="_idIndexMarker403"/> arbitrary methods during its load process through the <strong class="source-inline">&lt;function&gt;</strong> element. This can be used to set up demo and test data.</p>
			<p>For example, the <strong class="bold">Notes</strong> app, which is bundled with Odoo, uses it to set up demonstration data:</p>
			<p class="source-code">&lt;data noupdate="1"&gt; </p>
			<p class="source-code">&lt;function  </p>
			<p class="source-code">   model="res.users"  </p>
			<p class="source-code">   name="_init_data_user_note_stages"</p>
			<p class="source-code">   eval="[]" /&gt;</p>
			<p class="source-code">&lt;/data&gt;</p>
			<p>This calls the <strong class="source-inline">_init_data_user_note_stages</strong> method of the <strong class="source-inline">res.users</strong> model, passing no arguments. The argument list is provided by the <strong class="source-inline">eval</strong> attribute, which is an empty list in this case.</p>
			<p>This completes everything we need to know to use XML data files. We provided an overview of <strong class="source-inline">&lt;data&gt;</strong> elements and the <strong class="source-inline">noupdate</strong> flag. We then learned how to use the <strong class="source-inline">&lt;record&gt;</strong> element to load data<a id="_idIndexMarker404"/> records, as well as how to set values on related fields. We also learned about record shortcuts, such as <strong class="source-inline">&lt;menuitem&gt;</strong> and <strong class="source-inline">&lt;template&gt;</strong>. Finally, we learned how to delete records and make<a id="_idIndexMarker405"/> arbitrary function calls with the <strong class="source-inline">&lt;delete&gt;</strong> and <strong class="source-inline">&lt;function&gt;</strong> elements.</p>
			<p>With this, we should be prepared to use XML data files for whatever data needs our project might have.</p>
			<h1 id="_idParaDest-158"><a id="_idTextAnchor162"/>Summary</h1>
			<p>In this chapter, we learned how to represent data in text files. These can be used to manually import data into Odoo or include it in add-on modules as default or <em class="italic">demonstration data</em>.</p>
			<p>At this point, we should be able to export and import CSV data files from the web interface and leverage <em class="italic">external IDs</em> to detect and update records that already exist in the database. They can also be used to perform a mass edit on data, by editing and reimporting a CSV file that has been exported from Odoo.</p>
			<p>We also learned about how XML data files are structured, and all the features they provide, in more detail. These were not only set values on fields but also actions such as deleting records and calling model methods.</p>
			<p>In the next chapter, we will focus on how to use <em class="italic">records</em> to work with the data contained in models. This will give us the necessary tools to then implement our application's business logic and rules.</p>
			<h1 id="_idParaDest-159"><a id="_idTextAnchor163"/>Further reading</h1>
			<p>The official Odoo documentation provides additional resources on data files: <a href="https://www.odoo.com/documentation/15.0/developer/reference/backend/data.html">https://www.odoo.com/documentation/15.0/developer/reference/backend/data.html</a>.</p>
		</div>
	</div></body></html>