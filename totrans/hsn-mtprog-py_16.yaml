- en: '*Chapter 13*: Applying GOF Design Patterns – Part 2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第13章*：应用GOF设计模式——第二部分'
- en: In this chapter, we will continue looking at the concept of design patterns
    in Python 3 and its various categories and their implementation while developing
    software using Python.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章，我们将继续探讨Python 3中的设计模式概念及其各种类别及其在软件开发中的实现。
- en: In the previous chapter, we learned how to apply behavioral design patterns
    with examples. In this chapter, we will continue looking at the remaining two
    categories – structural and creational design patterns. We will see how they can
    be applied in Python using our core example of *ABC Megamart*.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何通过示例应用行为型设计模式。在本章中，我们将继续探讨剩余的两个类别——结构型和创建型设计模式。我们将看到它们如何通过我们的核心示例
    *ABC Megamart* 在Python中应用。
- en: 'In this chapter, we will be looking at the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章，我们将探讨以下主要主题：
- en: Understanding structural design patterns
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解结构型设计模式
- en: Understanding creational design patterns
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解创建型设计模式
- en: By the end of this chapter, you should be able to understand some of the examples
    of important structural and creational design patterns and learn how they can
    be implemented in various applications.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你应该能够理解一些重要的结构和创建型设计模式的例子，并学习它们如何在各种应用中实现。
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code examples shared in this chapter are available on GitHub under the
    code for this chapter here: [https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter13](https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter13).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中分享的代码示例可在GitHub上找到，地址为[https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter13](https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter13)。
- en: Exploring structural design patterns
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索结构型设计模式
- en: As the name suggests, structural design patterns are used to design the structure
    of classes and their implementation in such a way that the classes and objects
    can be extended or reused effectively. In this section, we will be covering three
    such structural design patterns — bridge, façade, and proxy patterns. We are considering
    these three design patterns because they are unique and they represent three different
    aspects of how structural design patterns can be used.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，结构型设计模式用于设计类及其实现的结构，以便类和对象可以有效地扩展或重用。在本节中，我们将介绍三种这样的结构型设计模式——桥接模式、外观模式和代理模式。我们考虑这三种设计模式是因为它们是独特的，并且代表了结构型设计模式可以使用的三个不同方面。
- en: Understanding the bridge pattern
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解桥接模式
- en: 'The bridge design pattern is applied to bridge multiple elements or operations
    of implementation using the concept of abstraction or the abstract method. To
    explain this further and to implement this design pattern, our code should have
    the following elements:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 桥接设计模式通过抽象或抽象方法的概念应用于桥接多个实现元素或操作。为了进一步解释这一点并实现这个设计模式，我们的代码应该包含以下元素：
- en: '**Abstraction superclass**: The base class with the abstract method to perform
    a specific action, along with methods to bridge any additional implementation'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**抽象超类**：具有执行特定操作的抽象方法的基础类，以及桥接任何额外实现的方法'
- en: '**Abstraction subclasses**: One or more subclasses that implement the abstract
    method from the abstraction superclass to perform their respective action'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**抽象子类**：一个或多个子类，它们从抽象超类实现抽象方法以执行它们各自的操作'
- en: '**Implementation superclass**: A base that adds an additional implementation
    or design over the abstraction'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实现超类**：一个基础类，它添加了额外的实现或设计在抽象之上'
- en: '**Implementation subclasses**: Subclasses that inherit the implementation superclass'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实现子类**：继承实现超类的子类'
- en: 'Let’s look at the bridge pattern with an example. In this example, we will
    look at printing the business card for branch managers that belong to two different
    supermarkets – *ABC Megamart* and *XYZ Megamart*. Let’s see how:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来了解桥接模式。在这个例子中，我们将查看打印属于两个不同超市——*ABC Megamart* 和 *XYZ Megamart* 的分支经理的商务名片。让我们看看如何：
- en: 'To illustrate the design pattern further, let’s create an abstraction superclass
    named `PrintCard`, and add three methods. The `add_name` method adds the name
    of the supermarket, and the `add_manager` method adds the formatting specific
    to a manager. The `add_manager` method gets the formatting input from the implementation
    subclass, which we will discuss later in this section. The third method is the
    `printcard` method, which is an abstract method and will be defined in the subclasses:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了进一步说明设计模式，让我们创建一个名为 `PrintCard` 的抽象超类，并添加三个方法。`add_name` 方法添加超市的名称，`add_manager`
    方法添加特定于管理员的格式。`add_manager` 方法从实现子类获取格式输入，我们将在本节后面讨论。第三个方法是 `printcard` 方法，它是一个抽象方法，将在子类中定义：
- en: '[PRE0]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let’s further create an abstraction subclass named `CardABC`. This class will
    initialize the logo, name from the super class, and manager from the super class.
    The `printcard` method will print the logo, the name of the supermarket, and the
    address of the branch:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们进一步创建一个名为 `CardABC` 的抽象子类。这个类将从超类初始化标志、名称和管理员。`printcard` 方法将打印标志、超市的名称和分店的地址：
- en: '[PRE1]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, create an abstraction subclass named `CardXYZ`. It will initialize the
    following variables – style, logo, name from super class, and manager from the
    superclass. The `printcard` method will print the logo, the style for the card,
    the name of the supermarket, and the address of the branch:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个名为 `CardXYZ` 的抽象子类。它将初始化以下变量 – 风格、标志、从超类继承的名称和管理员。`printcard` 方法将打印标志、卡片的风格、超市的名称和分店的地址：
- en: '[PRE2]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, let’s create the implementation superclass named `Manager` with a method
    named `formatting`:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个名为 `Manager` 的实现超类，其中包含一个名为 `formatting` 的方法：
- en: '[PRE3]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, create an implementation subclass named `Manager_manhattan` to add formatting
    to the business card, specifically for the branch manager from the Manhattan branch:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个名为 `Manager_manhattan` 的实现子类，以添加针对曼哈顿分店经理的商务卡的格式：
- en: '[PRE4]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let’s now create an implementation subclass named `Manager_albany` to add formatting
    for the business card specifically for the branch manager from the Albany branch:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个名为 `Manager_albany` 的实现子类，以添加针对阿尔巴尼分店经理的商务卡的特定格式：
- en: '[PRE5]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, instantiate `CardABC`, which is an abstraction subclass. The three input
    parameters for this class are the format of the logo, the name of the supermarket,
    and the branch from where the formatting will be added to the card:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，实例化 `CardABC`，这是一个抽象子类。此类的三个输入参数是标志的格式、超市的名称以及添加格式的分店：
- en: '[PRE6]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And now we will print the card:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将打印这张卡片：
- en: '[PRE7]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output is represented as follows, with the formatting as provided in the
    class instantiation:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示，格式与类实例化时提供的一致：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let’s now instantiate `CardXYZ`, which is an abstraction subclass. The four
    input parameters for this class are the style, the format of the logo, the name
    of the supermarket, and the branch from where the formatting will be added to
    the card:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们实例化 `CardXYZ`，这是一个抽象子类。此类的四个输入参数是风格、标志的格式、超市的名称以及添加格式的分店：
- en: '[PRE9]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now, let’s print the card.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们打印这张卡片。
- en: '[PRE10]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The output is represented as follows, with the style and formatting as provided
    in the class instantiation:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示，风格和格式与类实例化时提供的一致：
- en: '[PRE11]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let’s connect the elements of this design pattern with their corresponding
    objects in the example with the following graphical representation:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用以下图形表示法将此设计模式的元素与示例中的相应对象联系起来：
- en: '![Figure 13.1 – Bridge pattern classes ](img/Figure_13.1_B13426.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.1 – 桥接模式类](img/Figure_13.1_B13426.jpg)'
- en: Figure 13.1 – Bridge pattern classes
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.1 – 桥接模式类
- en: So, the bridge pattern has been implemented by creating a bridge between the
    abstraction and the implementation classes. With this understanding, let’s look
    at the facade pattern.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过在抽象类和实现类之间创建桥梁，已经实现了桥接模式。有了这个理解，让我们来看看外观模式。
- en: Understanding the facade pattern
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解外观模式
- en: 'In this section, we will look at the facade pattern, where we will design a
    black box kind of implementation to hide the complexity of a system that handles
    multiple subsystems from the end user or client. To explain this further and to
    implement this design/core pattern, our code needs the following elements:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨外观模式，我们将设计一种类似黑盒的实现，以隐藏处理多个子系统的系统的复杂性，从而保护最终用户或客户端。为了进一步解释并实现这个设计/核心模式，我们的代码需要以下元素：
- en: '**Functionality**: The core functionalities that need to be implemented for
    a system are defined in these functionality classes.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**功能**：需要为系统实现的核心功能定义在这些功能类中。'
- en: '**Facade**: This is the class that wraps the core functionalities and their
    implementation from the end users.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**外观**：这是一个封装核心功能和其实现的类，供最终用户使用。'
- en: '**End user**: The function, method, or class using which the core functionalities
    of a system are accessed using the facade class.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最终用户**：使用外观类访问系统核心功能的功能、方法或类。'
- en: 'To understand the facade pattern further, let’s create a set of functionalities
    that starts from adding items to the shopping cart, moving to the counter, scanning
    bar codes, billing, and finally, printing the invoice:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步理解外观模式，让我们创建一系列功能，从添加购物车中的商品开始，到结账，扫描条形码，开账单，最后打印发票：
- en: 'The first functionality class in this series is `Cart`, where items will be
    added to the shopping cart in the `return_cart` method:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个系列中的第一个功能类是 `Cart`，其中将在 `return_cart` 方法中将商品添加到购物车中：
- en: '[PRE12]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The second functionality class is the `Counter` class, where the name of the
    counter is returned in the `goto_counter` method:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个功能类是 `Counter` 类，其中 `goto_counter` 方法返回收银台的名字：
- en: '[PRE13]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The third functionality class is the `BarCode` class, where the scanned bar
    codes are returned in the `scan_bar_code` method:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三个功能类是 `BarCode` 类，其中 `scan_bar_code` 方法返回扫描的条形码：
- en: '[PRE14]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The fourth functionality is the `Billing` class, where the price is tagged
    to the bar codes and returned as a dictionary object in the `add_billing` method:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第四个功能是 `Billing` 类，其中在 `add_billing` 方法中将价格标记到条形码上，并作为字典对象返回：
- en: '[PRE15]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The next functionality is the `Tax` class, where tax values are returned using
    the `add_tax` method in the class:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个功能类是 `Tax` 类，其中使用类中的 `add_tax` 方法返回税率：
- en: '[PRE16]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The functionality after this is the `FinalBill` class, where we will be calculating
    the final bill using the `calc_bill` method:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此后的功能是 `FinalBill` 类，我们将使用 `calc_bill` 方法计算最终账单：
- en: '[PRE17]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The final functionality class in the facade pattern is the `Invoice` class,
    where we will be creating a `print_invoice` method to print the final invoice:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 外观模式中的最后一个功能类是 `Invoice` 类，我们将创建一个 `print_invoice` 方法来打印最终的发票：
- en: '[PRE18]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, let’s create the `Facade` class named `Queue`. It has two functions –
    the `pipeline` method to explicitly run some of the methods in the functionality
    classes, and the `pipeline_implicit` method to run the `print_invoice` method
    from the `Invoice` class, which will in turn call all other methods in the rest
    of the functionality classes:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建名为 `Queue` 的 `Facade` 类。它有两个功能 – `pipeline` 方法用于显式运行功能类中的某些方法，以及 `pipeline_implicit`
    方法用于从 `Invoice` 类运行 `print_invoice` 方法，这将反过来调用其他功能类中的所有其他方法：
- en: '[PRE19]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let’s create an end user function to run the methods in functionality classes
    using the `Facade` class by creating an instance for `Queue` and calling the `pipeline`
    method:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个最终用户功能，通过为 `Queue` 创建一个实例并调用 `pipeline` 方法，使用 `Facade` 类来运行功能类中的方法：
- en: '[PRE20]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, let’s call the `run_facade` method to test the design pattern:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们调用 `run_facade` 方法来测试设计模式：
- en: '[PRE21]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output for the preceding test is as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 前面测试的输出如下：
- en: '[PRE22]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Finally, let’s create another end user function to run the methods in functionality
    classes using the `Facade` class by creating an instance for `Queue` and calling
    the `pipeline_implicit` method:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们创建另一个最终用户功能，通过为 `Queue` 创建一个实例并调用 `pipeline_implicit` 方法，使用 `Facade` 类来运行功能类中的方法：
- en: '[PRE23]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, let’s call the `run_facade_implicit` method to test the design pattern:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，让我们调用 `run_facade_implicit` 方法来测试设计模式：
- en: '[PRE24]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The output for the preceding test is as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 前面测试的输出如下：
- en: '[PRE25]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let’s connect the elements of this design pattern with their corresponding
    objects in the example in the following graphical representation:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在以下图形表示中连接这个设计模式的元素及其对应的对象：
- en: '![Figure 13.2 – Facade pattern classes ](img/Figure_13.2_B13426.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.2 – 外观模式类](img/Figure_13.2_B13426.jpg)'
- en: Figure 13.2 – Facade pattern classes
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.2 – 外观模式类
- en: So, the facade pattern has been implemented by creating a black box that provides
    the end users with an interface to access the functions of a complex system without
    worrying about the implementation details. Now, let’s look at the proxy pattern.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，外观模式是通过创建一个黑盒来实现的，它为最终用户提供了一个接口，以便在不担心实现细节的情况下访问复杂系统的功能。现在，让我们看看代理模式。
- en: Understanding the proxy pattern
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解代理模式
- en: 'In this section, we will look at the proxy design pattern. As the name implies,
    the proxy pattern is applied to create a proxy around the actual functionality
    so that the actual functionality is executed only when the proxy allows it based
    on certain preconditions. To explain this further and to implement this design
    pattern, our code needs the following elements:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨代理设计模式。正如其名所示，代理模式用于在真实功能周围创建一个代理，以便只有在代理根据某些先决条件允许时，才会执行实际功能。为了进一步解释这一点并实现此设计模式，我们的代码需要以下元素：
- en: '**Functionality class**: The base functionalities of the system are designed
    in this class as methods.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**功能类**：系统的基本功能设计在这个类中，作为方法。'
- en: '`functionality` class and it provides restrictions as to when to execute the
    base functionalities from the `functionality` class.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`functionality` 类，并提供在何时从 `functionality` 类执行基本功能的限制。'
- en: 'In this example, let’s consider the NYC branch of *ABC Megamart* and create
    a class named `NYC`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，让我们考虑 *ABC Megamart* 的纽约分公司，并创建一个名为 `NYC` 的类：
- en: 'The `NYC` class is initialized with four empty dictionary parameters named
    `manager`, `branch`, `product`, and `sales`. Let’s also add three methods named
    `set_parameters` (to set the four dictionary parameters), `get_parameters` (to
    return the parameters), and `calc_tax_nyc` (to calculate the tax and return the
    parameters along with selling price data):'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`NYC` 类使用四个名为 `manager`、`branch`、`product` 和 `sales` 的空字典参数进行初始化。让我们也添加三个方法，分别命名为
    `set_parameters`（用于设置四个字典参数）、`get_parameters`（用于返回参数）和 `calc_tax_nyc`（用于计算税费并返回参数以及销售价格数据）：'
- en: '[PRE26]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The next step of the implementation is to create a proxy `ReturnBook` class
    to call the methods from the `NYC` class to set parameters, get parameters, and
    calculate tax:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现的下一步是创建一个代理 `ReturnBook` 类，以调用 `NYC` 类的方法来设置参数、获取参数和计算税费：
- en: '[PRE27]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let’s now instantiate the proxy `ReturnBook` class and provide the `NYC` functionality
    class as the input parameter:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们实例化代理 `ReturnBook` 类，并将 `NYC` 功能类作为输入参数提供：
- en: '[PRE28]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To set the parameters from the `NYC` class, we will be calling the `add_book_details`
    method from the proxy class. The parameters will be set in the `NYC` class only
    if the conditions provided in `add_book_details` are successfully met by the input
    state parameter:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要从 `NYC` 类设置参数，我们将从代理类调用 `add_book_details` 方法。只有当输入状态参数成功满足 `add_book_details`
    中提供的条件时，参数才会设置在 `NYC` 类中：
- en: '[PRE29]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let’s further call the `show_book_details` method to get the parameters from
    the `NYC` class, provided that the state parameter in the input is `NY`, `NYC`,
    or `New York`:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们进一步调用 `show_book_details` 方法来获取 `NYC` 类的参数，前提是输入的状态参数为 `NY`、`NYC` 或 `New
    York`：
- en: '[PRE30]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE31]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Let’s further call the `calc_tax` method from the proxy class to calculate
    the selling price, provided the state parameters are successful:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们进一步从代理类调用 `calc_tax` 方法来计算销售价格，前提是状态参数成功：
- en: '[PRE32]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Let’s test the restrictions in the proxy methods by providing incorrect input
    to the state parameter:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过向状态参数提供错误输入来测试代理方法中的限制：
- en: '[PRE33]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE34]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Similarly, let’s also test the `show_book_details` method:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，让我们也测试 `show_book_details` 方法：
- en: '[PRE35]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE36]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Finally, let’s test the `calc_tax` method from the proxy:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们测试代理中的 `calc_tax` 方法：
- en: '[PRE37]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The output is as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE38]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Let’s connect the elements of this design pattern with their corresponding
    objects in the example in the following graphical representation:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将此设计模式的元素与以下图形表示中的相应对象相连接：
- en: '![Figure 13.3 – Proxy design pattern classes ](img/Figure_13.3_B13426.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.3 – 代理设计模式类](img/Figure_13.3_B13426.jpg)'
- en: Figure 13.3 – Proxy design pattern classes
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.3 – 代理设计模式类
- en: So, the proxy pattern has been implemented by creating a proxy class that adds
    the required conditions to execute the actual functionalities. Next, we’re moving
    on to exploring the creational design patterns.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，代理模式是通过创建一个代理类来实现的，该代理类添加了执行实际功能所需的条件。接下来，我们将继续探索创建型设计模式。
- en: Exploring creational design patterns
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索创建型设计模式
- en: Creational design patterns are various methods to add abstraction in the process
    of object creation. In this section, we will be looking at three such design patterns,
    namely the factory method, prototype pattern, and singleton pattern.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 创建型设计模式是添加对象创建过程中的抽象的各种方法。在本节中，我们将探讨三种这样的设计模式，即工厂方法、原型模式和单例模式。
- en: Understanding the factory method
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解工厂方法
- en: 'The factory design pattern is a method of abstraction where a factory class
    is created to create an object for the class from the factory class instead of
    directly instantiating the object. To explain this further and to implement this
    design pattern, our code needs the following elements:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂设计模式是一种抽象方法，其中创建一个工厂类来创建工厂类中的对象，而不是直接实例化对象。为了进一步解释这一点并实现此设计模式，我们的代码需要以下元素：
- en: '**Abstract class**: The abstract class with the abstract methods for functionalities
    to be defined in the subclasses.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**抽象类**：具有在子类中定义的功能的抽象方法的抽象类。'
- en: '**Abstraction subclasses**: The subclasses are inherited from the abstract
    class and overwrite the abstract methods.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**抽象子类**：子类继承自抽象类并覆盖了抽象方法。'
- en: '**Factory class**: The class to create objects for the abstraction subclasses.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工厂类**：用于为抽象子类创建对象的类。'
- en: '**End user method**: The class or method to test or call the factory method.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**终端用户方法**：用于测试或调用工厂方法的类或方法。'
- en: 'For this example, let’s implement using another scenario from *ABC Megamart*:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，让我们使用来自 *ABC Megamart* 的另一个场景来实现：
- en: 'Let’s create an abstract class with two methods, `buy_product` and `maintenance_cost`:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个具有两个方法 `buy_product` 和 `maintenance_cost` 的抽象类：
- en: '[PRE39]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, let’s create a subclass for the `Branch` class named `Brooklyn` and implement
    the `buy_product` and `maintenance_cost` methods:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们为 `Branch` 类创建一个名为 `Brooklyn` 的子类，并实现 `buy_product` 和 `maintenance_cost`
    方法：
- en: '[PRE40]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Similarly, let’s create another subclass, named `Manhattan`, which inherits
    the `Branch` class, as follows:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，让我们创建另一个名为 `Manhattan` 的子类，它继承自 `Branch` 类，如下所示：
- en: '[PRE41]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Let’s further define a method named `buy_product` to return the product price,
    product name, and promotion in cases where the product is electronic:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们进一步定义一个名为 `buy_product` 的方法，在产品是电子产品的场合返回产品价格、产品名称和促销信息：
- en: '[PRE42]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Let’s now define another method to calculate the maintenance cost:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们定义另一个方法来计算维护成本：
- en: '[PRE43]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In the next step, let’s create a factory class named `BranchFactory`, which
    creates the instance for the branch subclasses, `Brooklyn` or `Manhattan`:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一步中，让我们创建一个名为 `BranchFactory` 的工厂类，它为分支子类 `Brooklyn` 或 `Manhattan` 创建实例：
- en: '[PRE44]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, let’s test the factory method by creating a function named `test_factory`:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们通过创建一个名为 `test_factory` 的函数来测试工厂方法：
- en: '[PRE45]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Let’s now call the `test_factory` function with inputs as `Brooklyn`, `Milk`,
    `10.5`, and `FMCG` as follows:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用以下输入调用 `test_factory` 函数：`Brooklyn`、`Milk`、`10.5` 和 `FMCG`：
- en: '[PRE46]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The output for the preceding code is as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE47]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, call the `test_factory` function with inputs as `manhattan`, `iPhone`,
    `1000`, `1`, and `Electronics` as follows:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用以下输入调用 `test_factory` 函数：`manhattan`、`iPhone`、`1000`、`1` 和 `Electronics`：
- en: '[PRE48]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The output for the preceding code is as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE49]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Let’s connect the elements of this design pattern with their corresponding
    objects in the example with the following graphical representation:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用以下图形表示法将此设计模式的元素与示例中的相应对象联系起来：
- en: '![Figure 13.4 – Factory pattern classes ](img/Figure_13.4_B13426.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.4 – 工厂模式类](img/Figure_13.4_B13426.jpg)'
- en: Figure 13.4 – Factory pattern classes
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.4 – 工厂模式类
- en: So, the factory pattern has been implemented by creating a factory class that
    instantiates the `Abstraction` subclasses. With this implementation, we have learned
    about the creational design pattern with an example.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过创建一个工厂类来实例化 `Abstraction` 子类，我们已经通过一个示例学习了创建型设计模式。
- en: Understanding the prototype method
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解原型方法
- en: 'The prototype design pattern is also used to implement abstraction during the
    creation of a Python object. A prototype can be used by the end user to create
    a copy of an object of a class without the overhead of understanding the detailed
    implementation behind it. To explain this further and to implement this design
    pattern, our code needs the following elements:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 原型设计模式也用于在创建 Python 对象时实现抽象。终端用户可以使用原型来创建类的对象的副本，而不需要理解其背后的详细实现。为了进一步解释这一点并实现此设计模式，我们的代码需要以下元素：
- en: '**Prototype class**: This class has a method to clone or copy another Python
    object that has the implementation.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原型类**：这个类有一个方法可以克隆或复制具有实现的另一个 Python 对象。'
- en: '**Implementation class**: This class has the actual implementation of the functionalities
    as attributes and methods.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实现类**：这个类具有作为属性和方法的实际功能实现。'
- en: 'For this example, let’s implement using another scenario from *ABC Megamart*:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，让我们使用来自 *ABC Megamart* 的另一个场景来实现：
- en: 'Let’s create a class named `Prototype` and define a method named `clone` to
    copy the Python object provided as input to the method:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个名为 `Prototype` 的类，并定义一个名为 `clone` 的方法来复制作为方法输入提供的 Python 对象：
- en: '[PRE50]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Let’s now create an implementation class named `FMCG` and initialize a set
    of variables pertaining to the supplier details, and add a method to get the supplier
    details:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们创建一个名为 `FMCG` 的实现类，并初始化一组与供应商详情相关的变量，并添加一个获取供应商详情的方法：
- en: '[PRE51]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In the next step, let’s create an object named `fmcg_supplier` for the `FMCG`
    class:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一步中，让我们为 `FMCG` 类创建一个名为 `fmcg_supplier` 的对象：
- en: '[PRE52]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Let’s also create an object for the `Prototype` class, named `proto`:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们也为 `Prototype` 类创建一个名为 `proto` 的对象：
- en: '[PRE53]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now, we can directly clone the `fmcg_supplier` object without passing all the
    attributes of the `FMCG` class as input. To do this, we will make use of the `clone`
    method from the `Prototype` class:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以直接克隆 `fmcg_supplier` 对象，而无需传递 `FMCG` 类的所有属性作为输入。为此，我们将使用 `Prototype`
    类中的 `clone` 方法：
- en: '[PRE54]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The `fmcg_supplier_reuse` object is a clone of the `fmcg_supplier` object and
    it is not the same object itself. This can be verified by looking at the ID of
    both of these objects:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`fmcg_supplier_reuse` 对象是 `fmcg_supplier` 对象的克隆，并且它本身不是同一个对象。这可以通过查看这两个对象的
    ID 来验证：'
- en: '[PRE55]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The output is as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE56]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Similarly, we can also look at the ID of the cloned object:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，我们也可以查看克隆对象的 ID：
- en: '[PRE57]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The output is as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE58]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Let’s also verify that the cloned object can be modified without impacting
    the actual object:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们也验证一下克隆的对象可以被修改而不会影响实际对象：
- en: '[PRE59]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The output is as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE60]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'In the preceding output, we have modified the cloned object and this should
    not impact the original object. Let’s verify the original object:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的输出中，我们已经修改了克隆的对象，这不应该影响原始对象。让我们验证原始对象：
- en: '[PRE61]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The output is as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE62]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: So, the prototype pattern has been implemented by creating a `Prototype` class
    that copies the object of the implementation class. Now that you’ve understood
    this, let’s look at the singleton design pattern.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过创建一个 `Prototype` 类来复制实现类的对象，我们已经实现了原型模式。现在你已经理解了这个，让我们看看单例设计模式。
- en: Understanding the singleton pattern
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解单例模式
- en: As the name suggests, the singleton pattern is a design pattern where we can
    limit the number of class instances created for a class while initializing the
    class itself. To explain this further and implement this design pattern, we need
    to develop the elements of the **singleton class** in our code.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，单例模式是一种设计模式，其中我们可以在初始化类本身的同时限制为该类创建的实例数量。为了进一步解释并实现这个设计模式，我们需要在我们的代码中开发
    **单例类** 的元素。
- en: Unlike the other patterns, this pattern has only one element – the singleton
    class. A singleton class will have a constraint set within its `init` method to
    limit the number of instances to one.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他模式不同，这个模式只有一个元素——单例类。单例类将在其 `init` 方法中设置一个约束，以限制实例数量为一个是。
- en: 'For this example, let’s implement using another scenario from *ABC Megamart*:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，让我们使用来自 *ABC Megamart* 的另一个场景来实现：
- en: 'Let’s define a class named `SingletonBilling`. This class will have the attributes
    required to generate a bill for a product:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们定义一个名为 `SingletonBilling` 的类。这个类将包含生成产品账单所需的属性：
- en: '[PRE63]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Let’s add a constraint in the `init` method of this class to limit the number
    of class instances to one:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在该类的 `init` 方法中添加一个约束来限制类实例的数量为一个是：
- en: '[PRE64]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'In the next step, let’s also add a `generate_bill` method to perform the function
    of generating a bill for a product based on the class attributes:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一步中，让我们也添加一个 `generate_bill` 方法来根据类的属性生成产品的账单：
- en: '[PRE65]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'In the next step, we can instantiate the class object for the first time and
    call its `generate_bill` method:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一步中，我们可以首次实例化类对象并调用其 `generate_bill` 方法：
- en: '[PRE66]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The output is displayed as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE67]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Let’s now test the singleton pattern by instantiating one more instance for
    the class:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们通过为类实例化另一个实例来测试单例模式：
- en: '[PRE68]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The second instance could not be created for the class due to its singleton
    property. The output is as expected:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其单例属性，无法为该类创建第二个实例。输出符合预期：
- en: '[PRE69]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: So, the singleton pattern has been implemented by restricting the singleton
    class from creating more than one instance. With this example, we have covered
    three types of creational design patterns and their implementation.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，单例模式是通过限制单例类不能创建超过一个实例来实现的。通过这个例子，我们已经涵盖了三种类型的创建型设计模式及其实现。
- en: Summary
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned about the concept of structural and creational
    design patterns by applying some of these design patterns in Python 3\. We implemented
    the bridge design pattern and understood each of its elements. We understood the
    facade design pattern and its various elements. We also implemented the proxy
    design pattern with an example. We also covered creational design patterns such
    as the factory method, prototype, and singleton patterns with their corresponding
    examples.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过在Python 3中应用一些这些设计模式，学习了结构型和创建型设计模式的概念。我们实现了桥接设计模式并理解了其各个元素。我们还理解了外观设计模式及其各种元素。此外，我们还通过一个示例实现了代理设计模式。我们还涵盖了创建型设计模式，如工厂方法、原型和单例模式及其相应的示例。
- en: Similar to other chapters covered in this book, this chapter, which explains
    the second part of design patterns, also focused on metaprogramming and its impact
    on Python code.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 与本书中涵盖的其他章节类似，本章解释设计模式的第二部分，也专注于元编程及其对Python代码的影响。
- en: In the next chapter, we will continue the code generation with some examples.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过一些示例继续进行代码生成。
