- en: '*Chapter 13*: Applying GOF Design Patterns – Part 2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will continue looking at the concept of design patterns
    in Python 3 and its various categories and their implementation while developing
    software using Python.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how to apply behavioral design patterns
    with examples. In this chapter, we will continue looking at the remaining two
    categories – structural and creational design patterns. We will see how they can
    be applied in Python using our core example of *ABC Megamart*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be looking at the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding structural design patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding creational design patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you should be able to understand some of the examples
    of important structural and creational design patterns and learn how they can
    be implemented in various applications.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code examples shared in this chapter are available on GitHub under the
    code for this chapter here: [https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter13](https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter13).'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring structural design patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the name suggests, structural design patterns are used to design the structure
    of classes and their implementation in such a way that the classes and objects
    can be extended or reused effectively. In this section, we will be covering three
    such structural design patterns — bridge, façade, and proxy patterns. We are considering
    these three design patterns because they are unique and they represent three different
    aspects of how structural design patterns can be used.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the bridge pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The bridge design pattern is applied to bridge multiple elements or operations
    of implementation using the concept of abstraction or the abstract method. To
    explain this further and to implement this design pattern, our code should have
    the following elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Abstraction superclass**: The base class with the abstract method to perform
    a specific action, along with methods to bridge any additional implementation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Abstraction subclasses**: One or more subclasses that implement the abstract
    method from the abstraction superclass to perform their respective action'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Implementation superclass**: A base that adds an additional implementation
    or design over the abstraction'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Implementation subclasses**: Subclasses that inherit the implementation superclass'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s look at the bridge pattern with an example. In this example, we will
    look at printing the business card for branch managers that belong to two different
    supermarkets – *ABC Megamart* and *XYZ Megamart*. Let’s see how:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate the design pattern further, let’s create an abstraction superclass
    named `PrintCard`, and add three methods. The `add_name` method adds the name
    of the supermarket, and the `add_manager` method adds the formatting specific
    to a manager. The `add_manager` method gets the formatting input from the implementation
    subclass, which we will discuss later in this section. The third method is the
    `printcard` method, which is an abstract method and will be defined in the subclasses:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s further create an abstraction subclass named `CardABC`. This class will
    initialize the logo, name from the super class, and manager from the super class.
    The `printcard` method will print the logo, the name of the supermarket, and the
    address of the branch:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, create an abstraction subclass named `CardXYZ`. It will initialize the
    following variables – style, logo, name from super class, and manager from the
    superclass. The `printcard` method will print the logo, the style for the card,
    the name of the supermarket, and the address of the branch:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s create the implementation superclass named `Manager` with a method
    named `formatting`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, create an implementation subclass named `Manager_manhattan` to add formatting
    to the business card, specifically for the branch manager from the Manhattan branch:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s now create an implementation subclass named `Manager_albany` to add formatting
    for the business card specifically for the branch manager from the Albany branch:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, instantiate `CardABC`, which is an abstraction subclass. The three input
    parameters for this class are the format of the logo, the name of the supermarket,
    and the branch from where the formatting will be added to the card:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And now we will print the card:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is represented as follows, with the formatting as provided in the
    class instantiation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s now instantiate `CardXYZ`, which is an abstraction subclass. The four
    input parameters for this class are the style, the format of the logo, the name
    of the supermarket, and the branch from where the formatting will be added to
    the card:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, let’s print the card.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is represented as follows, with the style and formatting as provided
    in the class instantiation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s connect the elements of this design pattern with their corresponding
    objects in the example with the following graphical representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.1 – Bridge pattern classes ](img/Figure_13.1_B13426.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.1 – Bridge pattern classes
  prefs: []
  type: TYPE_NORMAL
- en: So, the bridge pattern has been implemented by creating a bridge between the
    abstraction and the implementation classes. With this understanding, let’s look
    at the facade pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the facade pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will look at the facade pattern, where we will design a
    black box kind of implementation to hide the complexity of a system that handles
    multiple subsystems from the end user or client. To explain this further and to
    implement this design/core pattern, our code needs the following elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Functionality**: The core functionalities that need to be implemented for
    a system are defined in these functionality classes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Facade**: This is the class that wraps the core functionalities and their
    implementation from the end users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**End user**: The function, method, or class using which the core functionalities
    of a system are accessed using the facade class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To understand the facade pattern further, let’s create a set of functionalities
    that starts from adding items to the shopping cart, moving to the counter, scanning
    bar codes, billing, and finally, printing the invoice:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first functionality class in this series is `Cart`, where items will be
    added to the shopping cart in the `return_cart` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The second functionality class is the `Counter` class, where the name of the
    counter is returned in the `goto_counter` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The third functionality class is the `BarCode` class, where the scanned bar
    codes are returned in the `scan_bar_code` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The fourth functionality is the `Billing` class, where the price is tagged
    to the bar codes and returned as a dictionary object in the `add_billing` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next functionality is the `Tax` class, where tax values are returned using
    the `add_tax` method in the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The functionality after this is the `FinalBill` class, where we will be calculating
    the final bill using the `calc_bill` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The final functionality class in the facade pattern is the `Invoice` class,
    where we will be creating a `print_invoice` method to print the final invoice:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s create the `Facade` class named `Queue`. It has two functions –
    the `pipeline` method to explicitly run some of the methods in the functionality
    classes, and the `pipeline_implicit` method to run the `print_invoice` method
    from the `Invoice` class, which will in turn call all other methods in the rest
    of the functionality classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s create an end user function to run the methods in functionality classes
    using the `Facade` class by creating an instance for `Queue` and calling the `pipeline`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s call the `run_facade` method to test the design pattern:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output for the preceding test is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let’s create another end user function to run the methods in functionality
    classes using the `Facade` class by creating an instance for `Queue` and calling
    the `pipeline_implicit` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, let’s call the `run_facade_implicit` method to test the design pattern:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output for the preceding test is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s connect the elements of this design pattern with their corresponding
    objects in the example in the following graphical representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.2 – Facade pattern classes ](img/Figure_13.2_B13426.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.2 – Facade pattern classes
  prefs: []
  type: TYPE_NORMAL
- en: So, the facade pattern has been implemented by creating a black box that provides
    the end users with an interface to access the functions of a complex system without
    worrying about the implementation details. Now, let’s look at the proxy pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the proxy pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will look at the proxy design pattern. As the name implies,
    the proxy pattern is applied to create a proxy around the actual functionality
    so that the actual functionality is executed only when the proxy allows it based
    on certain preconditions. To explain this further and to implement this design
    pattern, our code needs the following elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Functionality class**: The base functionalities of the system are designed
    in this class as methods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`functionality` class and it provides restrictions as to when to execute the
    base functionalities from the `functionality` class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this example, let’s consider the NYC branch of *ABC Megamart* and create
    a class named `NYC`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `NYC` class is initialized with four empty dictionary parameters named
    `manager`, `branch`, `product`, and `sales`. Let’s also add three methods named
    `set_parameters` (to set the four dictionary parameters), `get_parameters` (to
    return the parameters), and `calc_tax_nyc` (to calculate the tax and return the
    parameters along with selling price data):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next step of the implementation is to create a proxy `ReturnBook` class
    to call the methods from the `NYC` class to set parameters, get parameters, and
    calculate tax:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s now instantiate the proxy `ReturnBook` class and provide the `NYC` functionality
    class as the input parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To set the parameters from the `NYC` class, we will be calling the `add_book_details`
    method from the proxy class. The parameters will be set in the `NYC` class only
    if the conditions provided in `add_book_details` are successfully met by the input
    state parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s further call the `show_book_details` method to get the parameters from
    the `NYC` class, provided that the state parameter in the input is `NY`, `NYC`,
    or `New York`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s further call the `calc_tax` method from the proxy class to calculate
    the selling price, provided the state parameters are successful:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s test the restrictions in the proxy methods by providing incorrect input
    to the state parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, let’s also test the `show_book_details` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let’s test the `calc_tax` method from the proxy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s connect the elements of this design pattern with their corresponding
    objects in the example in the following graphical representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.3 – Proxy design pattern classes ](img/Figure_13.3_B13426.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.3 – Proxy design pattern classes
  prefs: []
  type: TYPE_NORMAL
- en: So, the proxy pattern has been implemented by creating a proxy class that adds
    the required conditions to execute the actual functionalities. Next, we’re moving
    on to exploring the creational design patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring creational design patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creational design patterns are various methods to add abstraction in the process
    of object creation. In this section, we will be looking at three such design patterns,
    namely the factory method, prototype pattern, and singleton pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the factory method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The factory design pattern is a method of abstraction where a factory class
    is created to create an object for the class from the factory class instead of
    directly instantiating the object. To explain this further and to implement this
    design pattern, our code needs the following elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Abstract class**: The abstract class with the abstract methods for functionalities
    to be defined in the subclasses.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Abstraction subclasses**: The subclasses are inherited from the abstract
    class and overwrite the abstract methods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Factory class**: The class to create objects for the abstraction subclasses.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**End user method**: The class or method to test or call the factory method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For this example, let’s implement using another scenario from *ABC Megamart*:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create an abstract class with two methods, `buy_product` and `maintenance_cost`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s create a subclass for the `Branch` class named `Brooklyn` and implement
    the `buy_product` and `maintenance_cost` methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Similarly, let’s create another subclass, named `Manhattan`, which inherits
    the `Branch` class, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s further define a method named `buy_product` to return the product price,
    product name, and promotion in cases where the product is electronic:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s now define another method to calculate the maintenance cost:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the next step, let’s create a factory class named `BranchFactory`, which
    creates the instance for the branch subclasses, `Brooklyn` or `Manhattan`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s test the factory method by creating a function named `test_factory`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s now call the `test_factory` function with inputs as `Brooklyn`, `Milk`,
    `10.5`, and `FMCG` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output for the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, call the `test_factory` function with inputs as `manhattan`, `iPhone`,
    `1000`, `1`, and `Electronics` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output for the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s connect the elements of this design pattern with their corresponding
    objects in the example with the following graphical representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.4 – Factory pattern classes ](img/Figure_13.4_B13426.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.4 – Factory pattern classes
  prefs: []
  type: TYPE_NORMAL
- en: So, the factory pattern has been implemented by creating a factory class that
    instantiates the `Abstraction` subclasses. With this implementation, we have learned
    about the creational design pattern with an example.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the prototype method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The prototype design pattern is also used to implement abstraction during the
    creation of a Python object. A prototype can be used by the end user to create
    a copy of an object of a class without the overhead of understanding the detailed
    implementation behind it. To explain this further and to implement this design
    pattern, our code needs the following elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Prototype class**: This class has a method to clone or copy another Python
    object that has the implementation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Implementation class**: This class has the actual implementation of the functionalities
    as attributes and methods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For this example, let’s implement using another scenario from *ABC Megamart*:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a class named `Prototype` and define a method named `clone` to
    copy the Python object provided as input to the method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s now create an implementation class named `FMCG` and initialize a set
    of variables pertaining to the supplier details, and add a method to get the supplier
    details:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the next step, let’s create an object named `fmcg_supplier` for the `FMCG`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s also create an object for the `Prototype` class, named `proto`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can directly clone the `fmcg_supplier` object without passing all the
    attributes of the `FMCG` class as input. To do this, we will make use of the `clone`
    method from the `Prototype` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `fmcg_supplier_reuse` object is a clone of the `fmcg_supplier` object and
    it is not the same object itself. This can be verified by looking at the ID of
    both of these objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we can also look at the ID of the cloned object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s also verify that the cloned object can be modified without impacting
    the actual object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding output, we have modified the cloned object and this should
    not impact the original object. Let’s verify the original object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: So, the prototype pattern has been implemented by creating a `Prototype` class
    that copies the object of the implementation class. Now that you’ve understood
    this, let’s look at the singleton design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the singleton pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the name suggests, the singleton pattern is a design pattern where we can
    limit the number of class instances created for a class while initializing the
    class itself. To explain this further and implement this design pattern, we need
    to develop the elements of the **singleton class** in our code.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the other patterns, this pattern has only one element – the singleton
    class. A singleton class will have a constraint set within its `init` method to
    limit the number of instances to one.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this example, let’s implement using another scenario from *ABC Megamart*:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s define a class named `SingletonBilling`. This class will have the attributes
    required to generate a bill for a product:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s add a constraint in the `init` method of this class to limit the number
    of class instances to one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the next step, let’s also add a `generate_bill` method to perform the function
    of generating a bill for a product based on the class attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the next step, we can instantiate the class object for the first time and
    call its `generate_bill` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is displayed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s now test the singleton pattern by instantiating one more instance for
    the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The second instance could not be created for the class due to its singleton
    property. The output is as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: So, the singleton pattern has been implemented by restricting the singleton
    class from creating more than one instance. With this example, we have covered
    three types of creational design patterns and their implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned about the concept of structural and creational
    design patterns by applying some of these design patterns in Python 3\. We implemented
    the bridge design pattern and understood each of its elements. We understood the
    facade design pattern and its various elements. We also implemented the proxy
    design pattern with an example. We also covered creational design patterns such
    as the factory method, prototype, and singleton patterns with their corresponding
    examples.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to other chapters covered in this book, this chapter, which explains
    the second part of design patterns, also focused on metaprogramming and its impact
    on Python code.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will continue the code generation with some examples.
  prefs: []
  type: TYPE_NORMAL
