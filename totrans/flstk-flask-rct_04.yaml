- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fetching Data with React APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over the past few years, there has been an increase in the demand for database-driven
    web applications. This increase is a consequence of the abundance of data available
    at this present time. With widespread internet adoption, businesses leverage web
    applications to interact with customers, employees, and other stakeholders.
  prefs: []
  type: TYPE_NORMAL
- en: More than ever, web developers are constantly faced with tasks such as the organization
    and consumption of data. Both internal and external data require us to have smart
    and business-oriented database-driven web applications.
  prefs: []
  type: TYPE_NORMAL
- en: As a full stack software engineer, some of your frontend tasks will be to consume
    data, either from an internally developed API or a third-party API. Before we
    delve into approaches or tools you can use to fetch data in React projects, let’s
    briefly discuss what APIs are all about and why they are redefining ways of building
    user interfaces and web applications.
  prefs: []
  type: TYPE_NORMAL
- en: An API simply allows communication among systems using a set of rules in a standard
    accepted format. In web development, HTTP protocols define the set of rules for
    web-based systems communication. HTTP is a data exchange protocol used to fetch
    resources across the internet.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two major formats for exchanging data: **XML** and **JSON**. JSON
    is winning the popularity contest between these two widely used formats for data
    exchange. JSON is specifically designed for data interchange, handles arrays seamlessly,
    and is used widely among developers.'
  prefs: []
  type: TYPE_NORMAL
- en: In the React ecosystem, developers have access to a range of exposed interfaces
    designed to facilitate data fetching from various sources. These APIs are aimed
    at empowering React developers to create intuitive user interfaces and enhance
    the overall user experience when interacting with web applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to learn about some of the methods and techniques
    used in React frontend development to fetch data from disparate sources. In this
    chapter, we will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Fetching data using the Fetch API in React
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fetching data using `async/await` syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fetching data using Axios
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fetching data using React Query
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The complete code for this chapter is available on GitHub at: [https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter04](https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter04).'
  prefs: []
  type: TYPE_NORMAL
- en: Fetching data using the Fetch API in React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Fetch API** is an inbuilt API in a web browser that provides the JavaScript
    interface for communication over the internet using HTTP. Every web browser has
    a JavaScript engine as a runtime to compile and run JavaScript code.'
  prefs: []
  type: TYPE_NORMAL
- en: The React ecosystem relies inarguably on JavaScript. This is a fact and one
    of the reasons you are expected to understand modern JavaScript before delving
    into React application development.
  prefs: []
  type: TYPE_NORMAL
- en: As a React developer, you will need network resources to build web applications.
    The `fetch()` method provides you with the means to access and manipulate HTTP
    object requests and HTTP protocol responses. Let’s say that in our web application,
    we want to display the list of conference speakers and their associated data.
    This information is housed in another resource database server.
  prefs: []
  type: TYPE_NORMAL
- en: 'From a third-party public API, we are going to consume the user’s resource
    to fetch hypothetical data to be used in our React application as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s discuss the preceding `fetch` data snippet in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '`import React, { useEffect, useState } from ''react''`: This line imports React’s
    core functions and some Hooks for use in our component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Initializing the `useState`: We initialize our state by calling `useState`
    in our component as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `useState` accepts an initial state of an empty array (`useState([])`)
    and returns two values, `data` and `setData`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`data`: The current state'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setData`: State updater function (this function is responsible for the new
    state of the initial state)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`useState([])` is `useState` with the initial value of empty array`[]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following snippet has a global `fetch()` method that accepts the URL of
    the endpoint, `https://jsonplaceholder.typicode.com/users`, where we have the
    hypothetical resource for speakers:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The URL in the preceding code is our resource endpoint. It returns JSON as data.
    `setData()` accepts the new state, which is the returned data in JSON.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `useEffect` Hook is used to invoke the `getSpeaker` function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`map()` is invoked on the data array and used to iterate on the speakers’ data
    to display details on the screen:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In sum, `fetch()` accepts the resource URL ([https://jsonplaceholder.typicode.com/users](https://jsonplaceholder.typicode.com/users))
    as an argument, which is the path to the resource over the network we are interested
    in, and returns to a promise that moves to the status of fulfilled once the requested
    resource response is available.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In real-world applications, it’s crucial to manage network errors effectively,
    especially when data retrieval encounters issues or when the absence of data occurs.
    Additionally, implementing a loading state can significantly enhance the overall
    user experience.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we are going to look at another technique for fetching data in React projects
    using `async/await` using the ECMAScript 2017 feature.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching data using async/await syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are three ways to write asynchronous codes in vanilla JavaScript: callbacks,
    promises, and `async/await`. In this section, we are going to focus on `async`
    `/await` and see how it can be used in React web applications. `async/await` is
    an improvement on promises.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet explains how `async/await` can be used to fetch data
    from an API using a promise-based approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s discuss the preceding code snippet, which demonstrates how to use `async/await`
    to fetch data asynchronously:'
  prefs: []
  type: TYPE_NORMAL
- en: '`import React, { useEffect, useState } from ''react''`: This line imports React
    core functions and some Hooks for use in our component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Initializing the `useState`: We initialize our state by calling `useState`
    in our component as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`useState` accepts an initial state of empty array (`useState([])`) and returns
    two values, `data` and `setData`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`data`: The current state'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setData`: State updater function (this function is responsible for the new
    state of the initial state)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`useState([])` is `useState` with the initial value of empty array`[]`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have the hypothetical resource for speakers in the preceding endpoint. This
    is our resource endpoint. It returns JSON as data. `setData()` accepts the new
    state, which is the returned data in JSON.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `useEffect` Hook is used to invoke the `fetchSpeakers` function, which
    fetches data asynchronously from the endpoint `const API_URL = "`[https://dummyjson.com/users](https://dummyjson.com/users)`"`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The array dependency is supplied with the data state. When the data state changes,
    maybe because of the addition or removal of speakers in the list, the component
    re-renders and shows the updated state.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, `map()` is invoked on the data, and it is used to iterate on the speakers’
    data to render details to the screen:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `async/await` approach of fetching data gives your codes better organization
    and improves the responsiveness and performance of your React applications. The
    non-blocking mode of `async/await` means you can carry on with the rest of the
    code operations while you await responses from a large amount of data running
    tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we are going to look at another approach for fetching data from an API,
    using a third-party npm package called Axios.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching data using Axios
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Axios** is simply a lightweight JavaScript, promise-based HTTP client used
    to consume API services. It is mainly used in the browser and Node.js. To use
    Axios in our project, open the project terminal and type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s see how to use Axios in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s examine the preceding code snippet to see how Axios can be used in data
    fetching:'
  prefs: []
  type: TYPE_NORMAL
- en: '`import React, { useEffect, useState } from ''react''`: This line imports React
    core functions and some Hooks for use in our component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`import axios from "axios"`: This line brings in the already installed Axios
    package for use in the project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Initializing `useState`: We initialize our state by calling `useState` in our
    component as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`useState` accepts an initial state of an empty array (`useState([])`) and
    returns two values, `data` and `setData`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`data`: The current state'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setData`: State updater function (this function is responsible for the new
    state of the initial state)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`useState([])` is `useState` with the initial value of empty array`[]`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is our resource endpoint. It returns JSON as data. The `setData()` accepts
    the new state, which is the returned data in JSON.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `getSpeakers` function uses `axios.get()` to fetch external data from the
    endpoint and return a promise. The state value is updated, and we have a new state
    in `setData` from the response object:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `useEffect` Hook is used to call `getSpeaker()` and renders the component:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, `map()` is used to iterate on the speakers’ data and display names
    and emails on the screen.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Moving on to data fetching techniques in React, we are going to look at another
    approach to fetching data using React Query.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching data using the React Query in React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**React Query** is an npm package library created for data fetching purposes
    with a ton of functionalities loaded with it. In React Query, the state management,
    pre-fetching of data, request retries, and caching are handled out of the box.
    React Query is a critical component of the React ecosystem with over a million
    downloads weekly.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s refactor the code snippet we used in the *Fetching data using Axios*
    section and experience the awesomeness of React Query:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, install React Query. In the root directory of the project, do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside `App.js`, add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Check the preceding *Fetching data using Axios* section to compare the code
    snippet. The React Query snippet is way shorter and more concise. The need for
    `useState` and `useEffect` Hooks have been handled out of the box by the `useQuery()`
    Hook.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s dissect the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`useQuery` accepts two arguments: the query key (`speakers`) and a callback
    function that uses `axios()` to fetch a hypothetical speaker from the resource
    endpoint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`useQuery` is destructured with variables – `{data, isLoading, error}`. We
    then check to see whether there is an error message coming from the error object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once we have data, then the `return()` function returns an array of speakers’
    data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Inside `index.js`, add the following code. The existing `index.js` codes are
    presumed present:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s have some explanation of the code snippet in `index.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the `{ QueryClient, QueryClientProvider }` from React Query: `QueryClient`
    allows us to leverage the global defaults for all queries and mutations in React
    Query. The `QueryClientProvider` connects and provides a `QueryClient` to the
    application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create a new `QueryClient` instance, `queryClient`: Wrap your component with
    `QueryClientProvider`—in this case, `<App` `/>` is the component—and pass the
    new instance as an attribute value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now run `npm start` if `localhost:3000` is not running. The following should
    be displayed on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Screenshot showing the usage of React Query in fetching data](img/Figure_4.1_B18554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – Screenshot showing the usage of React Query in fetching data
  prefs: []
  type: TYPE_NORMAL
- en: React Query is very effective at fetching data from API resources. It encapsulates
    functions that may be required by `useState` and `useEffect`. React Query radically
    redefines the way we fetch data in React applications by introducing a powerful
    caching mechanism with the `queryKey`.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of manually managing data fetching and caching, React Query handles
    it transparently. React Query allows developers to easily fetch and cache data
    with just a few lines of code, reducing boilerplate and improving performance.
  prefs: []
  type: TYPE_NORMAL
- en: The library provides various Hooks and utilities that simplify data fetching,
    error handling, and data synchronization with the server, leading to a more efficient
    and seamless user experience. Exploring React Query further can open up a world
    of possibilities in handling complex data fetching scenarios and optimizing data
    management in React applications.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Handling data is a critical component of any web application. React has proven
    to be very efficient and scalable in handling data at scale. In this chapter,
    we discussed various approaches you can utilize in your project to handle data
    fetching. We discussed fetching data using the Fetch API, `async/await`, Axios,
    and React Query.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to discuss JSX and how you can display lists
    in React.
  prefs: []
  type: TYPE_NORMAL
