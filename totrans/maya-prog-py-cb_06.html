<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Making Things Move – Scripting for Animation</h1></div></div></div><p>This chapter will cover various recipes related to animating objects with scripting:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Querying animation data</li><li class="listitem" style="list-style-type: disc">Working with animation layers</li><li class="listitem" style="list-style-type: disc">Copying animation from one object to another</li><li class="listitem" style="list-style-type: disc">Setting keyframes</li><li class="listitem" style="list-style-type: disc">Creating expressions via script</li></ul></div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec45"/>Introduction</h1></div></div></div><p>In this chapter, we'll be looking at how to use scripting to create animation and set <strong>keyframes</strong>. We'll <a id="id231" class="indexterm"/>also see how to work with animation layers and create expressions from code.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec46"/>Querying animation data</h1></div></div></div><p>In this <a id="id232" class="indexterm"/>example, we'll be looking at how to retrieve information about animated objects, including which attributes are animated and both the location and value of keyframes. Although this script is unlikely to be useful by itself, knowing the number, time, and values of keyframes is sometimes a prerequisite for more complex animation tasks.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec121"/>Getting ready</h2></div></div></div><p>To make get the most out of this script, you'll need to have an object with some animation curves defined. Either load up a scene with animation or skip ahead to the recipe on setting keyframes.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec122"/>How to do it...</h2></div></div></div><p>Create a new file and add the following code:</p><div><pre class="programlisting">import maya.cmds as cmds

def getAnimationData():
    objs = cmds.ls(selection=True)
    obj = objs[0]

    animAttributes = cmds.listAnimatable(obj);

    for attribute in animAttributes:

        numKeyframes = cmds.keyframe(attribute, query=True, keyframeCount=True)

        if (numKeyframes &gt; 0):
            print("---------------------------")
            print("Found ", numKeyframes, " keyframes on ", attribute)

            times = cmds.keyframe(attribute, query=True, index=(0,numKeyframes), timeChange=True)
            values = cmds.keyframe(attribute, query=True, index=(0,numKeyframes), valueChange=True)

            print('frame#, time, value')
            for i in range(0, numKeyframes):
                print(i, times[i], values[i])

            print("---------------------------")

getAnimationData()</pre></div><p>If you select <a id="id233" class="indexterm"/>an object with animation curves and run the script, you should see a readout of the time and value for each keyframe on each animated attribute. For example, if we had a simple bouncing ball animation with the following curves:</p><div><img src="img/4657_06_02.jpg" alt="How to do it..."/></div><p>We would see <a id="id234" class="indexterm"/>something like the following output in the script editor:</p><div><pre class="programlisting">---------------------------
('Found ', 2, ' keyframes on ', u'|bouncingBall.translateX')
frame#, time, value
(0, 0.0, 0.0)
(1, 190.0, 38.0)
---------------------------
---------------------------
('Found ', 20, ' keyframes on ', u'|bouncingBall.translateY')
frame#, time, value
(0, 0.0, 10.0)
(1, 10.0, 0.0)
(2, 20.0, 8.0)
(3, 30.0, 0.0)
(4, 40.0, 6.4000000000000004)
(5, 50.0, 0.0)
(6, 60.0, 5.120000000000001)
(7, 70.0, 0.0)
(8, 80.0, 4.096000000000001)
(9, 90.0, 0.0)
(10, 100.0, 3.276800000000001)
(11, 110.0, 0.0)
(12, 120.0, 2.6214400000000011)
(13, 130.0, 0.0)
(14, 140.0, 2.0971520000000008)
(15, 150.0, 0.0)
(16, 160.0, 1.6777216000000008)
(17, 170.0, 0.0)
(18, 180.0, 1.3421772800000007)
(19, 190.0, 0.0)
---------------------------</pre></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec123"/>How it works...</h2></div></div></div><p>We start out <a id="id235" class="indexterm"/>by grabbing the selected object, as usual. Once we've done that, we'll iterate over all the <code class="literal">keyframeable</code> attributes, determine if they have any keyframes and, if they do, run through the times and values. To get the list of <code class="literal">keyframeable</code> attributes, we use the <code class="literal">listAnimateable</code> command:</p><div><pre class="programlisting">objs = cmds.ls(selection=True)
obj = objs[0]

animAttributes = cmds.listAnimatable(obj)</pre></div><p>This will give us a list of all the attributes on the selected object that can be animated, including any custom attributes that have been added to it.</p><p>If you were to print out the contents of the <code class="literal">animAttributes</code> array, you would likely see something like the following:</p><div><pre class="programlisting">|bouncingBall.rotateX
|bouncingBall.rotateY
|bouncingBall.rotateZ</pre></div><p>Although the <code class="literal">bouncingBall.rotateX</code> part likely makes sense, you may be wondering about the <code class="literal">|</code> symbol. This symbol is used by Maya to indicate hierarchical relationships between nodes in order to provide fully qualified node and attribute names. If the <code class="literal">bouncingBall</code> object was a child of a group named <code class="literal">ballGroup</code>, we would see this instead:</p><div><pre class="programlisting">|ballGroup|bouncingBall.rotateX</pre></div><p>Every such fully qualified name will contain at least one pipe (<code class="literal">|</code>) symbol, as we see in the first, nongrouped example, but there can be many more—one for each additional layer of hierarchy. While this can lead to long strings for attribute names, it allows Maya to make use of objects that may have the same name, but under different parts of a larger hierarchy (to have control objects named <code class="literal">handControl</code> for each hand of a character, for example).</p><p>Now that we have a list of all of the possibly animated attributes for the object, we'll next want to determine if there are any keyframes set on it. To do this, we can use the <code class="literal">keyframe</code> command in the query mode.</p><div><pre class="programlisting">    for attribute in animAttributes:
        numKeyframes = cmds.keyframe(attribute, query=True, keyframeCount=True)</pre></div><p>At this point, we have a variable (<code class="literal">numKeyframes</code>) that will be greater than zero for any attribute with at least one keyframe. Getting the total number of keyframes on an attribute is only one of the things that the <code class="literal">keyframe</code> command can do; we'll also use it to grab the time and value for each of the keyframes.</p><p>To do<a id="id236" class="indexterm"/> this, we'll call it two more times, both in the query mode—once to get the times and once to get the values:</p><div><pre class="programlisting">times = cmds.keyframe(attribute, query=True, index=(0,numKeyframes), timeChange=True)
values = cmds.keyframe(attribute, query=True, index=(0,numKeyframes), valueChange=True)</pre></div><p>These two lines are identical in everything except what type of information we're asking for. The important thing to note here is the index flag, which is used to tell Maya which keyframes we're interested in. The command requires a two-element argument representing the first (inclusive) and last (exclusive) index of keyframes to examine. So, if we had a total 20 keyframes, we would pass in (<code class="literal">0</code>,<code class="literal">20</code>), which would examine the keys with indices from 0 to 19.</p><p>The flags we're using to get the values likely look a bit odd—both <code class="literal">valueChange</code> and <code class="literal">timeChange</code> might lead you to believe that we would be getting relative values, rather than absolute. However, when used in the previously mentioned manner, the command will give us what we want—the actual time and value for each keyframe, as they appear in the graph editor.</p><p>If you want to query information on a single keyframe, you still have to pass in a pair of values—just use the index that you're interested in twice—to get the fourth frame, for example, use (<code class="literal">3</code>,<code class="literal">3</code>).</p><p>At this point, we have two arrays—the <code class="literal">times</code> array, which contains the time value for each keyframe, and the <code class="literal">values</code> array that contains the actual attribute value. All that's left is to print out the information that we've found:</p><div><pre class="programlisting">print('frame#, time, value')
for i in range(0, numKeyframes):
    print(i, times[i], values[i])</pre></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec124"/>There's more...</h2></div></div></div><p>Using the indices to get data on keyframes is an easy way to run through all of the data for a curve, but it's not the only way to specify a range. The <code class="literal">keyframe</code> command can also accept time values. If we wanted to know how many keyframes existed on a given attribute between frame 1 and frame 100, for example, we could do the following:</p><div><pre class="programlisting">numKeyframes = cmds.keyframe(attributeName, query=True, time=(1,100) keyframeCount=True)</pre></div><p>Also, if you <a id="id237" class="indexterm"/>find yourself with highly nested objects and need to extract just the object and attribute names, you may find Python's built-in split function helpful. You can call split on a string to have Python break it up into a list of parts. By default, Python will break up the input string by spaces, but you can specify a particular string or character to split on. Assume that you have a string like the following:</p><div><pre class="programlisting">|group4|group3|group2|group1|ball.rotateZ</pre></div><p>Then, you could use split to break it apart based on the <code class="literal">|</code> symbol. It would give you a list, and using <code class="literal">−1</code> as an index would give you just <code class="literal">ball.rotateZ</code>. Putting that into a function that can be used to extract the object/attribute names from a full string would be easy, and it would look something like the following:</p><div><pre class="programlisting">def getObjectAttributeFromFull(fullString):
    parts = fullString.split("|")
    return parts[-1]</pre></div><p>Using it would look something like this:</p><div><pre class="programlisting">inputString = "|group4|group3|group2|group1|ball.rotateZ"
result = getObjectAttributeFromFull(inputString)
print(result) # outputs "ball.rotateZ"</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec47"/>Working with animation layers</h1></div></div></div><p>Maya <a id="id238" class="indexterm"/>offers the ability to create multiple layers of animation in a scene, which can be a good way to build up complex animation. The layers can then be independently enabled or disabled, or blended together, granting the user a great deal of control over the end result.</p><p>In this example, we'll be looking at how to examine the layers that exist in a scene, and building a script will ensure that we have a layer of a given name. For example, we might want to create a script that would add additional randomized motion to the rotations of selected objects without overriding their existing motion. To do this, we would want to make sure that we had an animation layer named <code class="literal">randomMotion</code>, which we could then add keyframes to.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec125"/>How to do it...</h2></div></div></div><p>Create a new script and add the following code:</p><div><pre class="programlisting">import maya.cmds as cmds

def makeAnimLayer(layerName):

    baseAnimationLayer = cmds.animLayer(query=True, root=True)

    foundLayer = False

    if (baseAnimationLayer != None):
        childLayers = cmds.animLayer(baseAnimationLayer, query=True, children=True)

        if (childLayers != None) and (len(childLayers) &gt; 0):
            if layerName in childLayers:
                foundLayer = True

    if not foundLayer:
        cmds.animLayer(layerName)
    else:
        print('Layer ' + layerName + ' already exists')

makeAnimLayer("myLayer")</pre></div><p>Run the script, and you should see an animation layer named <code class="literal">myLayer</code> appear in the <strong>Anim</strong> tab of the channel box.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec126"/>How it works...</h2></div></div></div><p>The first <a id="id239" class="indexterm"/>thing that we want to do is to find out if there is already an animation layer with the given name present in the scene. To do this, we start by grabbing the name of the root animation layer:</p><div><pre class="programlisting">baseAnimationLayer = cmds.animLayer(query=True, root=True)</pre></div><p>In almost all cases, this should return one of two possible values—either <code class="literal">BaseAnimation</code> or (if there aren't any animation layers yet) Python's built-in <code class="literal">None</code> value.</p><p>We'll want to create a new layer in either of the following two possible cases:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">There are no animation layers yet</li><li class="listitem" style="list-style-type: disc">There are animation layers, but none with the target name</li></ul></div><p>In order to make the testing for the above a bit easier, we first create a variable to hold whether or not we've found an animation layer and set it to <code class="literal">False</code>:</p><div><pre class="programlisting">foundLayer = False</pre></div><p>Now we need to check to see whether it's true that <em>both</em> animation layers exist and one of them has the given name. First off, we check that there was, in fact, a base animation layer:</p><div><pre class="programlisting">if (baseAnimationLayer != None):</pre></div><p>If this is the case, we want to grab all the children of the base animation layer and check to see whether any of them have the name we're looking for. To grab the children animation layers, we'll use the <code class="literal">animLayer</code> command again, again in the query mode:</p><div><pre class="programlisting">childLayers = cmds.animLayer(baseAnimationLayer, query=True, children=True)</pre></div><p>Once we've <a id="id240" class="indexterm"/>done that, we'll want to see if any of the child layers match the one we're looking for. We'll also need to account for the possibility that there were no child layers (which could happen if animation layers were created then later deleted, leaving only the base layer):</p><div><pre class="programlisting">if (childLayers != None) and (len(childLayers) &gt; 0):
    if layerName in childLayers:
        foundLayer = True</pre></div><p>If there were child layers and the name we're looking for was found, we set our <code class="literal">foundLayer</code> variable to <code class="literal">True</code>.</p><p>If the layer wasn't found, we create it. This's easily done by using the <code class="literal">animLayer</code> command one more time, with the name of the layer we're trying to create:</p><div><pre class="programlisting">if not foundLayer:
    cmds.animLayer(layerName)</pre></div><p>Finally, we finish off by printing a message, if the layer was found, to let the user know.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec127"/>There's more...</h2></div></div></div><p>Having animation layers is great, in that we can make use of them when creating or modifying keyframes. However, we can't actually add animation to layers without first adding the objects in question to the animation layer.</p><p>Let's say that we had an object named <code class="literal">bouncingBall</code>, and we wanted to set some keyframes on its <code class="literal">translateY</code> attribute, in the <code class="literal">bounceLayer</code> animation layer. The actual command to set the keyframe(s) would look something like this:</p><div><pre class="programlisting">cmds.setKeyframe("bouncingBall.translateY", value=yVal, time=frame, animLayer="bounceLayer")</pre></div><p>However, this would only work as expected if we had first added the <code class="literal">bouncingBall</code> object to the <code class="literal">bounceLayer</code> animation layer. To do it, we could use the <code class="literal">animLayer</code> command in the edit mode, with the <code class="literal">addSelectedObjects</code> flag. Note that because the flag operates on the currently selected objects, we would need to first select the object we want to add:</p><div><pre class="programlisting">cmds.select("bouncingBall", replace=True)
cmds.animLayer("bounceLayer", edit=True, addSelectedObjects=True)</pre></div><p>Adding the object will, by default, add all of its animatable attributes. You can also add specific attributes, rather than entire objects. For example, if we only wanted to add the <code class="literal">translateY</code> attribute to <a id="id241" class="indexterm"/>our animation layer, we could do the following:</p><div><pre class="programlisting">cmds.animLayer("bounceLayer", edit=True, attribute="bouncingBall.translateY")</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec48"/>Copying animation from one object to another</h1></div></div></div><p>In this example, we'll <a id="id242" class="indexterm"/>create a script that will copy all of the animation data on one object to one or more additional objects, which could be useful to duplicate motion across a range of objects.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec128"/>Getting ready</h2></div></div></div><p>For the script to work, you'll need an object with some keyframes set. Either create some simple animation or skip ahead to the example on creating keyframes with script, later in this chapter.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec129"/>How to do it...</h2></div></div></div><p>Create a new script and add the following code:</p><div><pre class="programlisting">import maya.cmds as cmds

def getAttName(fullname):
    parts = fullname.split('.')
    return parts[-1]

def copyKeyframes():
    objs = cmds.ls(selection=True)

    if (len(objs) &lt; 2):
        cmds.error("Please select at least two objects")

    sourceObj = objs[0]

    animAttributes = cmds.listAnimatable(sourceObj);

    for attribute in animAttributes:

        numKeyframes = cmds.keyframe(attribute, query=True, keyframeCount=True)

        if (numKeyframes &gt; 0):

            cmds.copyKey(attribute)

            for obj in objs[1:]:
                cmds.pasteKey(obj, attribute=getAttName(attribute), option="replace")

copyKeyframes()</pre></div><p>Select the animated object, shift-select at least one other object, and run the script. You'll see that all of the objects have the same motion.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec130"/>How it works...</h2></div></div></div><p>The very <a id="id243" class="indexterm"/>first part of our script is a helper function that we'll be using to strip the attribute name off a full object name/attribute name string. More on it will be given later.</p><p>Now on to the bulk of the script. First off, we run a check to make sure that the user has selected at least two objects. If not, we'll display a friendly error message to let the user know what they need to do:</p><div><pre class="programlisting">objs = cmds.ls(selection=True)

if (len(objs) &lt; 2):
    cmds.error("Please select at least two objects")</pre></div><p>The <code class="literal">error</code> command will also stop the script from running, so if we're still going, we know that we had at least two objects selected. We'll set the first one to be selected to be our source object. We could just as easily use the second-selected object, but that would mean using the first selected object as the destination, limiting us to a single target:</p><div><pre class="programlisting">    sourceObj = objs[0]</pre></div><p>Now we're ready to start copying animation, but first, we'll need to determine which attributes are currently animated, through a combination of finding all the attributes that <em>can</em> be animated, and checking each one to see whether there are any keyframes on it:</p><div><pre class="programlisting">animAttributes = cmds.listAnimatable(sourceObj);

for attribute in animAttributes:
    numKeyframes = cmds.keyframe(attribute, query=True, keyframeCount=True)</pre></div><p>If we have at least one keyframe for the given attribute, we move forward with the copying:</p><div><pre class="programlisting">        if (numKeyframes &gt; 0):
            cmds.copyKey(attribute)</pre></div><p>The <code class="literal">copyKey</code> command will cause the keyframes for a given object to be temporarily held in memory. If used without any additional flags, it will grab all of the keyframes for the specified attribute, exactly what we want in this case. If we wanted only a subset of the keyframes, we could use the time flag to specify a range.</p><p>We're passing<a id="id244" class="indexterm"/> in each of the values that were returned by the <code class="literal">listAnimatable</code> function. These will be full names (both object name and attribute). That's fine for the <code class="literal">copyKey</code> command, but will require a bit of additional work for the paste operation.</p><p>Since we're copying the keys onto a different object than the one that we copied them from, we'll need to separate out the object and attribute names. For example, our <code class="literal">attribute</code> value might be something like this:</p><div><pre class="programlisting">|group1|bouncingBall.rotateX</pre></div><p>From this, we'll want to trim off just the attribute name (<code class="literal">rotateX</code>) since we're getting the object name from the selection list. To do this, we created a simple helper function that takes a full-length object/attribute name and returns just the attribute name. That's easy enough to do by just breaking the name/attribute string apart on the <code class="literal">.</code> and returning the last element, which in this case is the attribute:</p><div><pre class="programlisting">def getAttName(fullname):
    parts = fullname.split('.')
    return parts[-1]</pre></div><p>Python's <code class="literal">split</code> function breaks apart the string into an array of strings, and using a negative index will count back from the end, with <code class="literal">−1</code> giving us the last element.</p><p>Now we can actually paste our keys. We'll run through all the remaining selected objects, starting with the second, and paste our copied keyframes:</p><div><pre class="programlisting">for obj in objs[1:]:
    cmds.pasteKey(obj, attribute=getAttName(attribute), option="replace")</pre></div><p>Note that we're using the nature of Python's for loops to make the code a bit more readable. Rather than using an index, as would be the case in most other languages, we can just use the <code class="literal">for x in y</code> construction. In this case, <code class="literal">obj</code> will be a temporary variable, scoped to the for loop, that takes on the value of each item in the list. Also note that instead of passing in the entire list, we use <code class="literal">objs[1:]</code> to indicate the entire list, starting at index <code class="literal">1</code> (the second element). The colon allows us to specify a subrange of the <code class="literal">objs</code> list, and leaving the right-hand side blank will cause Python to include all the items to the end of the list.</p><p>We pass in the name of the object (from our original selection), the attribute (stripped from full name/attribute string via our helper function), and we use <code class="literal">option="replace"</code> to ensure that the keyframes we're pasting in replace anything that's already there.</p><div><img src="img/4657_06_01.jpg" alt="How it works..."/><div><p>Original animation (top). Here, we see the result of pasting keys with the default settings (left) and with the replace option (right). Note that the default results still contain the original curves, just pushed to later frames</p></div></div><p>If we didn't <a id="id245" class="indexterm"/>include the <code class="literal">option</code> flag, Maya would default to inserting the pasted keyframes while moving any keyframes already present forward in the timeline.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec131"/>There's more...</h2></div></div></div><p>There are a lot of other options for the option flag, each of which handles possible conflicts with the keys you're pasting and the ones that may already exist in a slightly different way. Be sure to have a look at the built-in documentation for the <code class="literal">pasteKeys</code> command for more information.</p><p>Another, and perhaps better option to control how pasted keys interact with existing one is to paste the new keys into a separate animation layer. For example, if we wanted to make sure that our pasted keys end up in an animation layer named <code class="literal">extraAnimation</code>, we could modify the call to <code class="literal">pasteKeys</code> as follows:</p><div><pre class="programlisting">cmds.pasteKey(objs[i], attribute=getAttName(attribute), option="replace", animLayer="extraAnimation")</pre></div><p>Note that if there was no animation layer named <code class="literal">extraAnimation</code> present, Maya would fail to copy the keys. See the section on working with animation layers for more information on how to query existing layers and create new ones.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec49"/>Setting keyframes</h1></div></div></div><p>While there <a id="id246" class="indexterm"/>are certainly a variety of ways to get things to move in Maya, the vast majority of motion is driven by keyframes. In this example, we'll be looking at how to create keyframes with code by making that old animation standby—a bouncing ball.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec132"/>Getting ready</h2></div></div></div><p>The script we'll be creating will animate the currently selected object, so make sure that you have an object—either the traditional sphere or something else you'd like to make bounce.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec133"/>How to do it...</h2></div></div></div><p>Create a new file and add the following code:</p><div><pre class="programlisting">import maya.cmds as cmds

def setKeyframes():
    objs = cmds.ls(selection=True)
    obj = objs[0]

    yVal = 0
    xVal = 0
    frame = 0

    maxVal = 10

    for i in range(0, 20):
        frame = i * 10
        xVal = i * 2

        if i % 2 == 1:
            yVal = 0
        else:
            yVal = maxVal
            maxVal *= 0.8

        cmds.setKeyframe(obj + '.translateY', value=yVal, time=frame)
        cmds.setKeyframe(obj + '.translateX', value=xVal, time=frame)

setKeyframes()</pre></div><p>Run the preceding script with an object selected and trigger playback. You should see the object move up and down.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec134"/>How it works...</h2></div></div></div><p>In order to get<a id="id247" class="indexterm"/> our object to bounce, we'll need to set keyframes such that the object alternates between a <em>Y</em>-value of zero and an ever-decreasing maximum so that the animation mimics the way a falling object loses velocity with each bounce. We'll also make it move forward along the x-axis as it bounces.</p><p>We start by grabbing the currently selected object and setting a few variables to make things easier to read as we run through our loop. Our <code class="literal">yVal</code> and <code class="literal">xVal</code> variables will hold the current value that we want to set the position of the object to. We also have a frame variable to hold the current frame and a <code class="literal">maxVal</code> variable, which will be used to hold the <em>Y</em>-value of the object's current height.</p><div><div><h3 class="title"><a id="note08"/>Note</h3><p>This example is sufficiently simple that we don't really need separate variables for frame and the attribute values, but setting things up this way makes it easier to swap in more complex math or logic to control where keyframes get set and to what value.</p></div></div><p>This gives us the following:</p><div><pre class="programlisting">    yVal = 0
    xVal = 0
    frame = 0

    maxVal = 10</pre></div><p>The bulk of the script is a single loop, in which we set keyframes on both the <em>X</em> and <em>Y</em> positions.</p><p>For the <code class="literal">xVal</code> variable, we'll just be multiplying a constant value (in this case, 2 units). We'll do the same thing for our frame. For the <code class="literal">yVal</code> variable, we'll want to alternate between an ever-decreasing value (for the successive peaks) and zero (for when the ball hits the ground).</p><p>To alternate between zero and non-zero, we'll check to see whether our loop variable is divisible by two. One easy way to do this is to take the value <em>modulo</em> (<code class="literal">%</code>) 2. This will give us the remainder when the value is divided by two, which will be zero in the case of even numbers and one in the case of odd numbers.</p><p>For odd values, we'll set <code class="literal">yVal</code> to zero, and for even ones, we'll set it to <code class="literal">maxVal</code>. To make sure that the ball bounces a little less each time, we set <code class="literal">maxVal</code> to 80% of its current value each time we make use of it.</p><p>Putting all of that together gives us the following loop:</p><div><pre class="programlisting">for i in range(0, 20):
    frame = i * 10
    xVal = i * 2

    if (i % 2) == 1:
        yVal = 0
    else:
        yVal = maxVal
        maxVal *= 0.8</pre></div><p>Now we're finally ready to actually set keyframes on our object. This is easily done with the <code class="literal">setKeyframe</code> command. We'll need to specify the following three things:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The attribute to keyframe (object name and attribute)</li><li class="listitem" style="list-style-type: disc">The time at which to set the keyframe</li><li class="listitem" style="list-style-type: disc">The actual value to set the attribute to</li></ul></div><p>In this case, this ends up looking like the following:</p><div><pre class="programlisting">cmds.setKeyframe(obj + '.translateY', value=yVal, time=frame)
cmds.setKeyframe(obj + '.translateX', value=xVal, time=frame)</pre></div><p>And that's it! A proper bouncing ball (or other object) animated with pure code.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec135"/>There's more...</h2></div></div></div><p>By default, the <code class="literal">setKeyframe</code> command will create keyframes with both in tangent and out tangent <a id="id248" class="indexterm"/>being set to spline. That's fine for a lot of things, but will result in overly smooth animation for something that's supposed to be striking a hard surface.</p><p>We can improve our bounce animation by keeping smooth tangents for the keyframes when the object reaches its maximum height, but setting the tangents at its minimum to be linear. This will give us a nice sharp change every time the ball strikes the ground.</p><p>To do this, all we need to do is to set both the <code class="literal">inTangentType</code> and <code class="literal">outTangentType</code> flags to <code class="literal">linear</code>, as follows:</p><div><pre class="programlisting">cmds.setKeyframe(obj + ".translateY", value=animVal, time=frame, inTangentType="linear", outTangentType="linear")</pre></div><p>To make sure that we only have linear tangents when the ball hits the ground, we could set up a variable to hold the tangent type, and set it to one of two values in much the same way that we set the <code class="literal">yVal</code> variable.</p><p>This would end up looking like this:</p><div><pre class="programlisting">tangentType = "auto"

for i in range(0, 20):
    frame =  i * 10
    if i % 2 == 1:
        yVal = 0
        tangentType = "linear"
    else:
        yVal = maxVal
        tangentType = "spline"
        maxVal *= 0.8

    cmds.setKeyframe(obj + '.translateY', value=yVal, time=frame, inTangentType=tangentType, outTangentType=tangentType)</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec50"/>Creating expressions via script</h1></div></div></div><p>While most <a id="id249" class="indexterm"/>animation in Maya is created manually, it can often be useful to drive attributes directly via script, especially for mechanical objects or background items. One way to approach this is through Maya's expression editor.</p><p>In addition to <a id="id250" class="indexterm"/>creating expressions via the expression editor, it is also possible to create expressions with scripting, in a beautiful example of code-driven code. In this example, we'll be creating a script that can be used to create a sine wave-based expression to smoothly alter a given attribute between two values. Note that expressions cannot actually use Python code directly; they require the code to be written in the MEL syntax. But this doesn't mean that we can't use Python to <em>create</em> expressions, which is what we'll do in this example.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec136"/>Getting ready</h2></div></div></div><p>Before we dive into the script, we'll first need to have a good handle on the kind of expression we'll be creating. There are a lot of different ways to approach expressions, but in this instance, we'll keep things relatively simple and tie the attribute to a sine wave based on the current time.</p><p>Why a sine wave? Sine waves are great because they alter smoothly between two values, with a nice easing into and out of both the minimum and maximums. While the minimum and maximum values range from −1 to 1, it's easy enough to alter the output to move between any two numbers we want. We'll also make things a bit more flexible by setting up the expression to rely on a custom <code class="literal">speed</code> attribute that can be used to control the rate at which the attribute animates.</p><p>The end result will be a value that varies smoothly between any two numbers at a user-specified (and keyframeable) rate.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec137"/>How to do it...</h2></div></div></div><p>Create a new <a id="id251" class="indexterm"/>script and add the following code:</p><div><pre class="programlisting">import maya.cmds as cmds

def createExpression(att, minVal, maxVal, speed):
    objs = cmds.ls(selection=True)
    obj = objs[0]

    cmds.addAttr(obj, longName="speed", shortName="speed", min=0, keyable=True)

    amplitude = (maxVal – minVal)/2.0
    offset = minVal + amplitude

    baseString =  "{0}.{1} = ".format(obj, att)
    sineClause = '(sin(time * ' + obj + '.speed)'
    valueClause = ' * ' + str(amplitude) + ' + ' + str(offset) + ')'

    expressionString = baseString + sineClause + valueClause

    cmds.expression(string=expressionString)

createExpression('translateY', 5, 10, 1)</pre></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec138"/>How it works...</h2></div></div></div><p>The first that <a id="id252" class="indexterm"/>we do is to add a <code class="literal">speed</code> attribute to our object, as in the custom attribute recipe in <a class="link" href="ch05.html" title="Chapter 5. Adding Controls – Scripting for Rigging">Chapter 5</a>, <em>Adding Controls – Scripting for Rigging</em>. We'll be sure to make it keyable for later animation:</p><div><pre class="programlisting">cmds.addAttr(obj, longName="speed", shortName="speed", min=0, keyable=True)</pre></div><p>It's generally a good idea to include at least one keyframeable attribute when creating expressions. While math-driven animation is certainly a powerful technique, you'll likely still want to be able to alter the specifics. Giving yourself one or more keyframeable attributes is an easy way to do just that.</p><p>Now we're ready to build up our expression. But first, we'll need to understand exactly what we want; in this case, a value that smoothly varies between two extremes, with the ability to control its speed. We can easily build an expression to do that using the sine function, with the current time as the input. Here's what it looks like in a general form:</p><div><pre class="programlisting">animatedValue = (sin(time * S) * M) + O;</pre></div><p>Where:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">S</code> is a value that will either speed up (if greater than 1) or slow down (if less) the rate at which the input to the sine function changes</li><li class="listitem" style="list-style-type: disc"><code class="literal">M</code> is a multiplier to alter the overall range through which the value changes</li><li class="listitem" style="list-style-type: disc"><code class="literal">O</code> is an offset to ensure that the minimum and maximum values are correct</li></ul></div><p>You <a id="id253" class="indexterm"/>can <a id="id254" class="indexterm"/>also think about it visually—<code class="literal">S</code> will cause our wave to stretch or shrink along the horizontal (time) axis, <code class="literal">M</code> will expand or contract it vertically, and <code class="literal">O</code> will move the entire shape of the curve either up or down.</p><p>
<code class="literal">S</code> is already taken care of; it's our newly created "speed" attribute. <code class="literal">M</code> and <code class="literal">O</code> will need to be calculated, based on the fact that sine functions always produce values ranging from <code class="literal">−1</code> to <code class="literal">1</code>.</p><p>The overall range of values should be from our <code class="literal">minVal</code> to our <code class="literal">maxVal</code>, so you might think that <code class="literal">M</code> should be equal to <em>(maxVal – minVal)</em>. However, since it gets applied to both <code class="literal">−1</code> and <code class="literal">1</code>, this would leave us with double the desired change. So, the final value we want is instead <em>(maxVal – minVal)/2</em>. We store that into our amplitude variable as follows:</p><div><pre class="programlisting">amplitude = (maxVal – minVal)/2.0</pre></div><p>Next up is the offset value <code class="literal">O</code>. We want to move our graph such that the minimum and maximum values are where they should be. It might seem like that would mean just adding our <code class="literal">minVal</code>, but if we left it at that, our output would dip below the minimum for 50% of the time (anytime the sine function is producing negative output). To fix it, we set <code class="literal">O</code> to <em>(minVal + M)</em> or in the case of our script:</p><div><pre class="programlisting">offset = minVal + amplitude</pre></div><p>This way, we move the <code class="literal">0</code> position of the wave to be midway between our <code class="literal">minVal</code> and <code class="literal">maxVal</code>, which is exactly what we want.</p><p>To make things clearer, let's look at the different parts we're tacking onto <code class="literal">sin()</code>, and the way they effect the minimum and maximum values the expression will output. We'll assume that the end result we're looking for is a range from <code class="literal">0</code> to <code class="literal">4</code>.</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Expression </p>
</th><th style="text-align: left" valign="bottom">
<p>Additional component</p>
</th><th style="text-align: left" valign="bottom">
<p>Minimum</p>
</th><th style="text-align: left" valign="bottom">
<p>Maximum </p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<em>sin(time)</em>
</p>
</td><td style="text-align: left" valign="top">
<p>None- raw sin function</p>
</td><td style="text-align: left" valign="top">
<p>−1</p>
</td><td style="text-align: left" valign="top">
<p>1</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<em>sin(time * speed)</em>
</p>
</td><td style="text-align: left" valign="top">
<p>Multiply input by "speed"</p>
</td><td style="text-align: left" valign="top">
<p>−1 (faster)</p>
</td><td style="text-align: left" valign="top">
<p>1 (faster)</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<em>sin(time * speed) * 2</em>
</p>
</td><td style="text-align: left" valign="top">
<p>Multiply output by 2</p>
</td><td style="text-align: left" valign="top">
<p>−2</p>
</td><td style="text-align: left" valign="top">
<p>2</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<em>(sin(time * speed) * 2) + 2</em>
</p>
</td><td style="text-align: left" valign="top">
<p>Add 2 to output</p>
</td><td style="text-align: left" valign="top">
<p>0</p>
</td><td style="text-align: left" valign="top">
<p>4</p>
</td></tr></tbody></table></div><p>Note that <em>2 = (4-0)/2</em> and <em>2 = 0 + 2</em>.</p><p>Here's what the preceding progression looks like when graphed:</p><div><img src="img/4657_06_03.jpg" alt="How it works..."/><div><p>Four steps in building up an expression to var an attribute from 0 to 4 with a sine function.</p></div></div><p>Okay, now that <a id="id255" class="indexterm"/>we have the math locked down, we're ready to translate that into Maya's expression syntax. If we wanted an object named <code class="literal">myBall</code> to animate along <em>Y</em> with the previous values, we would want to end up with:</p><div><pre class="programlisting">myBall.translateY = (sin(time * myBall.speed) * 5) + 12;</pre></div><p>This would <a id="id256" class="indexterm"/>work as expected if entered into Maya's expression editor, but we want to make sure that we have a more general-purpose solution that can be used with any object and any values. That's straightforward enough and just requires building up the preceding string from various literals and variables, which is what we do in the next few lines:</p><div><pre class="programlisting">baseString = "{0}.{1} = ".format(obj, att)
sineClause = '(sin(time * ' + obj + '.speed)'
valueClause = ' * ' + str(amplitude) + ' + ' + str(offset) + ')'

expressionString = baseString + sineClause + valueClause</pre></div><p> I've broken up the string creation into a few different lines to make things clearer, but it's by no means necessary. The key idea here is that we're switching back and forth between literals (<code class="literal">sin(time *</code>, <code class="literal">.speed</code>, and so on) and variables (<code class="literal">obj</code>, <code class="literal">att</code>, <code class="literal">amplitude</code>, and <code class="literal">offset</code>) to build the overall string. Note that we have to wrap numbers in the <code class="literal">str()</code> function to keep Python from complaining when we combine them with strings.</p><p>At this point, we <a id="id257" class="indexterm"/>have our expression string ready to go. All that's left is to actually add it to the scene as an expression, which is easily done with the <code class="literal">expression</code> command:</p><div><pre class="programlisting">cmds.expression(string=expressionString)</pre></div><p>And that's it! We will now have an attribute that varies smoothly between any two values.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec139"/>There's more...</h2></div></div></div><p>There are <a id="id258" class="indexterm"/>tons of other ways to use expressions to drive animation, and all sorts of simple mathematical tricks that can be employed.</p><p>For example, you can easily get a value to move smoothly to a target value with a nice easing-in to the target by running this every frame:</p><div><pre class="programlisting">animatedAttribute = animatedAttribute + (targetValue – animatedAttribute) * 0.2;</pre></div><p>This will add 20% of the current difference between the target and the current value to the attribute, which will move it towards the target. Since the amount that is added is always a percentage of the current difference, the per-frame effect reduces as the value approaches the target, providing an ease-in effect.</p><p>If we were to combine this with some code to randomly choose a new target value, we would end up with an easy way to, say, animate the heads of background characters to randomly look in different positions (maybe to provide a stadium crowd).</p><p>Assume that we had added custom attributes for <code class="literal">targetX</code>, <code class="literal">targetY</code>, and <code class="literal">targetZ</code> to our object that would end up looking something like the following:</p><div><pre class="programlisting">if (frame % 20 == 0)
{
    myCone.targetX = rand(time) * 360;
    myCone.targetY = rand(time) * 360;
    myCone.targetZ = rand(time) * 360;
}

myObject.rotateX += (myObject.targetX - myCone.rotateX) * 0.2;
myObject.rotateY += (myObject.targetY - myCone.rotateY) * 0.2;
myObject.rotateZ += (myObject.targetZ - myCone.rotateZ) * 0.2;</pre></div><p>Note that we're using the modulo (<code class="literal">%</code>) operator to do something (setting the target) only when the frame is an even multiple of 20. We're also using the current time as the seed value for the <code class="literal">rand()</code> function to ensure that we get different results as the animation progresses.</p><p>The previously mentioned example is how the code would look if we entered it directly into Maya's expression editor; note the MEL-style (rather than Python) syntax. Generating this <a id="id259" class="indexterm"/>code via Python would be a bit more involved than our <a id="id260" class="indexterm"/>sine wave example, but would use all the same principles—building up a string from literals and variables, then passing that string to the <code class="literal">expression</code> command.</p></div></div></body></html>