<html><head></head><body>
		<div><div></div>
		</div>
		<div><h1 id="_idParaDest-391"><a id="_idTextAnchor408"/>14. Testing</h1>
		</div>
		<div><p class="callout-heading">Overview</p>
			<p class="callout">This chapter introduces you to the concept of testing Django web applications. You will learn about the importance of testing in software development and, more importantly, in building web applications. You will write unit tests for your Django application's components, such as <strong class="bold">views</strong>, <strong class="bold">models</strong>, and <strong class="bold">endpoints</strong>. Completing this chapter will equip you with the skills to write test cases for Django web applications. That way, you can ensure that your application code works the way you expect.</p>
			<h1 id="_idParaDest-392"><a id="_idTextAnchor409"/>Introduction</h1>
			<p>In the preceding chapters, we have focused upon building our web application in Django by writing different components such as database models, views, and templates. We did all that to provide our users with an interactive application where they can create a profile and write reviews for the books they have read.</p>
			<p>Apart from building and running the application, there is another important aspect of making sure that the application code works the way we expect it to work. This is ensured by a technique called <strong class="bold">testing</strong>. In testing, we run the different parts of the web application and check whether the output of the executed component matches the output we expected. If the output matches, we can say that the component was tested successfully, and if the output does not match, we say that the component failed to work as intended.</p>
			<p>In this chapter, as we go through the different sections, we will learn why testing is important, what the different ways to test a web application are, and how we can build a strong testing strategy that will help us ensure that the web application we build is robust. Let us start our journey by learning about the importance of testing.</p>
			<h1 id="_idParaDest-393"><a id="_idTextAnchor410"/>The Importance of Testing</h1>
			<p>Making sure that an application works the way it was designed to work is an important aspect of development efforts because, otherwise, our users might keep on encountering weird behaviors that will usually drive them away from engaging with the application.</p>
			<p>The efforts we put into testing help us ensure that the different kinds of problems that we intend to solve are indeed being solved correctly. Imagine a case where a developer is building an online event scheduling platform. On this platform, users can schedule events on their calendars as per their local time zone. Now, what if, on this platform, users can schedule events as expected, but due to a bug, the events are scheduled in an incorrect time zone? It is such issues that tend to drive many users away.</p>
			<p>That is why a lot of companies spend a huge amount of money making sure that the applications they are building have undergone thorough testing. That way, they ensure that they do not release a buggy product or a product that is far away from satisfying user requirements.</p>
			<p>In brief, testing helps us achieve the following goals:</p>
			<ul>
				<li>Ensuring that the components of the application work according to specifications</li>
				<li>Ensuring interoperability with different infrastructure platforms: if an application can be deployed on a different operating system, such as Linux, Windows, and so on</li>
				<li>Reducing the probability of introducing a bug while refactoring the application code</li>
			</ul>
			<p>Now, a common assumption many people make about testing is that they have to test all the components manually as they are developed to make sure each component works according to its specifications, and repeat this exercise every time a change is made, or a new component is added to the application. While this is true, this does not provide a complete picture of testing. Testing as a technique has grown to be very powerful with time, and as a developer, you can reduce a huge amount of testing effort by implementing <strong class="bold">automated test cases</strong>. So, what are these automated test cases? Or, in other words, what is <strong class="bold">automation testing</strong>? Let us find out.</p>
			<h1 id="_idParaDest-394"><a id="_idTextAnchor411"/>Automation Testing</h1>
			<p>Testing a whole application repeatedly when a single component is modified can turn out to be a challenging task, and even more so if that application consists of a large codebase. The size of the codebase could be due to the sheer number of features or the complexity of the problem it solves.</p>
			<p>As we develop applications, it is important to make sure that the changes being made to these applications can be tested easily, so that we can verify whether there is something that is breaking. That is where the concept of automation testing comes in handy. The focus of automation testing is to write tests as code, such that the individual components of an application can be tested in isolation as well as in terms of their interaction with each other.</p>
			<p>With this aspect, it now becomes important for us to define the different kinds of automation tests that can be done for applications.</p>
			<p>Automation testing can be broadly categorized into five different types:</p>
			<ul>
				<li><strong class="bold">Unit Testing</strong>: In this type of testing, the individual isolated units of code are tested. For example, a unit test can target a single method or a single isolated API. This kind of testing is performed to make sure the basic units of the application work according to their specification.</li>
				<li><strong class="bold">Integration Testing</strong>: In this type of testing, the individual isolated units of code are merged to form a logical grouping. Once this grouping is formed, testing is performed on this logical group to make sure that the group works in the way it is expected to.</li>
				<li><strong class="bold">Functional Testing</strong>: In this kind of testing, the overall functionality of the different components of the application is tested. This may include different APIs, user interfaces, and so on.</li>
				<li><strong class="bold">Smoke Testing</strong>: In this kind of testing, the stability of the deployed application is tested to make sure that the application continues to remain functional as users interact with it, without causing a crash.</li>
				<li><strong class="bold">Regression Testing</strong>: This kind of testing is done to make sure that the changes being made to the application do not degrade the previously built functionality of the application.</li>
			</ul>
			<p>As we can see, testing is a big domain that takes time to master, and entire books have been written on this topic. To make sure we highlight the important aspects of testing, we are going to focus on the aspect of unit testing in this chapter. </p>
			<h1 id="_idParaDest-395"><a id="_idTextAnchor412"/>Testing in Django</h1>
			<p>Django is a feature-packed framework that aims to make web application development rapid. It provides a full-featured way of testing an application. It also provides a well-integrated module that allows application developers to write unit tests for their applications. This module is based on the Python <code>unittest</code> library that ships with most Python distributions.</p>
			<p>Let us get started with understanding how we can write basic test cases in Django and how to leverage the framework-provided modules to test our application code.</p>
			<h2 id="_idParaDest-396"><a id="_idTextAnchor413"/>Implementing Test Cases</h2>
			<p>When working on implementing mechanisms for testing your code, the first thing that needs to be understood is how this implementation can be logically grouped, such that modules that are closely related to each other are tested in one logical unit.</p>
			<p>This is simplified by implementing a <strong class="bold">test case</strong>. A test case is nothing more than a logical unit that groups together tests that are related to logically similar units, such that all the common logic to initialize the environment for the test cases can be combined in the same place, hence avoiding duplication of work while implementing application testing code.</p>
			<h2 id="_idParaDest-397"><a id="_idTextAnchor414"/>Unit Testing in Django</h2>
			<p>Now, with our basic understanding of the tests clear, let us look at how we can do unit testing inside Django. In the context of Django, a unit test consists of two major parts:</p>
			<ul>
				<li>A <code>TestCase</code> class, which wraps the different test cases that are grouped for a given module</li>
				<li>An actual test case, which needs to be executed to test the flow of a particular component</li>
			</ul>
			<p>The class implementing a unit test should inherit from the <code>TestCase</code> class provided by Django's <code>test</code> module. By default, Django provides a <code>tests.py</code> file in every application directory, which can be used to store the test cases for the application module.</p>
			<p>Once these unit tests are written, they can also be executed easily by running them directly using the provided <code>test</code> command in <code>manage.py</code> as follows:</p>
			<pre>python manage.py test</pre>
			<h2 id="_idParaDest-398"><a id="_idTextAnchor415"/>Utilizing Assertions</h2>
			<p>An important part of writing tests is validating whether the test passed or failed. Generally, to implement such decisions inside a testing environment, we utilize something known as <strong class="bold">assertions</strong>.</p>
			<p>Assertions are a common concept in software testing. They take in two operands and validate whether the value of the operand on the <strong class="bold">left-hand side (LHS)</strong> matches the value of the operand on the <strong class="bold">right-hand side (RHS)</strong>. If the value on the LHS matches the value on the RHS, an assertion is considered to be successful, whereas if the values differ, the assertion is considered to have failed.</p>
			<p>An assertion evaluating to <code>False</code> essentially causes a test case to be evaluated as a failure, which is then reported to the user.</p>
			<p>Assertions in Python are quite easy to implement and they use a simple keyword called <code>assert</code>. For example, the following code snippet shows a very simple assertion:</p>
			<pre>assert 1 == 1</pre>
			<p>The preceding assertion takes in a single expression, which evaluates to <code>True</code>. If this assertion were a part of a test case, the test would have succeeded.</p>
			<p>Now, let us see how we can implement test cases using the Python <code>unittest</code> library. Doing so is quite easy and can be accomplished in a few easy-to-follow steps:</p>
			<ol>
				<li>Import the <code>unittest</code> module, which allows us to build the test cases:<pre>import unittest</pre></li>
				<li>Once the module is imported, you can create a class whose name starts with <code>Test</code>, which inherits from the <code>TestCase</code> class provided by the <code>unittest</code> module:<pre>class TestMyModule(unittest.TestCase):
    def test_method_a(self):
        assert &lt;expression&gt;</pre><p>Only if the <code>TestMyModule</code> class inherits the <code>TestCase</code> class will Django be able to run it automatically with full integration with the framework. Once the class is defined, we can implement a new method inside the class named <code>test_method_a()</code>, which validates an assertion. </p><p class="callout-heading">Note</p><p class="callout">An important part to note here is the naming scheme for the test cases and test functions. The test cases being implemented should be prefixed with the name <code>test</code>, such that the test execution modules can detect them as valid test cases and execute them. The same rule applies to the naming of testing methods.</p></li>
				<li>Once the test case is written, it can be simply executed by running the following command:<pre>python manage.py test</pre><p>Now, with our basic understanding of implementing test cases clarified, let us write a very simple unit test to see how the unit testing framework behaves inside Django.</p></li>
			</ol>
			<h2 id="_idParaDest-399"><a id="_idTextAnchor416"/>Exercise 14.01: Writing a Simple Unit Test</h2>
			<p>In this exercise, you will write a simple unit test to understand how the Django unit testing framework works and use this knowledge to implement your first test case that validates a couple of simple expressions.</p>
			<ol>
				<li value="1">To get started, open the <code>tests.py</code> file under the <code>reviews</code> application of the <code>Bookr</code> project. By default, this file will contain only a single line that imports Django's <code>TestCase</code> class from the <code>test</code> module. In case the file already has a couple of test cases, you can remove all the lines in the file except the one which imports the <code>TestCase</code> class as shown next:<pre>from django.test import TestCase</pre></li>
				<li>Add the following lines of code in the <code>tests.py</code> file you just opened:<pre>class TestSimpleComponent(TestCase):
    def test_basic_sum(self):
        assert 1+1 == 2</pre><p>Here, you created a new class named <code>TestSimpleComponent</code>, which inherits from the <code>TestCase</code> class provided by Django's <code>test</code> module. The <code>assert</code> statement will compare the expression on the left-hand side (<code>1 + 1</code>) with the one on the right (<code>2</code>). </p></li>
				<li>Once you have written the test case, navigate back to the project folder, and run the following command:<pre>python manage.py test</pre><p>The following output should be generated:</p><pre>% ./manage.py test
Creating test database for alias 'default'...
System check identified no issues (0 silenced).
.
----------------------------------------------------------------------
Ran 1 test in 0.001s
OK
Destroying test database for alias 'default'...</pre><p>The preceding output signifies that Django's test runner executed one test case, which successfully passed the evaluation.</p></li>
				<li>With the test case confirmed to be working and passing, now try to add another assertion at the end of the <code>test_basic_sum()</code> method, as shown in the following code snippet:<pre>    assert 1+1 == 3</pre></li>
				<li>With the <code>assert</code> statement added to <code>tests.py</code>, now execute the test cases by running the following command from the project folder:<pre>python manage.py test</pre></li>
			</ol>
			<p>At this point, you will notice Django reporting that the execution of the test cases has failed. </p>
			<p>With this, you now have an understanding of how test cases can be written in Django and how assertions can be used to validate whether the output generated from your method calls under test is correct or not. </p>
			<h3 id="_idParaDest-400"><a id="_idTextAnchor417"/>Types of Assertions</h3>
			<p>In <em class="italic">Exercise 14.01</em>, <em class="italic">Writing a Simple Unit Test</em>, we had a brief encounter with assertions when we came across the following <code>assert</code> statement:</p>
			<pre>assert 1+1 == 2</pre>
			<p>These assertion statements are simple and use the Python <code>assert</code> keyword. There are a few different types of assertions possible that can be tested inside a unit test while using the <code>unittest</code> library. Let us look at those:</p>
			<ul>
				<li><code>assertIsNone</code>: This assertion is used to check whether an expression evaluates to <code>None</code> or not. For example, this type of assertion can be used in cases where a query to a database returns <code>None</code> because no records were found for the specified filtering criteria.</li>
				<li><code>assertIsInstance</code>: This assertion is used to validate whether a provided object evaluates to an instance of the provided type. For example, we can validate whether the value returned by a method is indeed of a specific type, such as list, dict, tuple, and so on.</li>
				<li><code>assertEquals</code>: This is a very basic function that takes in two arguments and checks whether the provided arguments to it are equal in value or not. This can be useful when you plan to compare the values of data structures that do not guarantee ordering.</li>
				<li><code>assertRaises</code>: This method is used to validate whether the name of the method provided to it when called raises a specified exception or not. This is helpful when we are writing test cases where a code path that raises an exception needs to be tested. As an example, this kind of assertion can be useful when we want to want to make sure an exception is raised by a method performing a database query (say, to let us know if the database connection is not yet established).</li>
			</ul>
			<p>These were just a small set of useful assertions that we can make in our test cases. The <code>unittest</code> module on top of which Django's testing library is built provides a lot more assertions that can be tested for.</p>
			<h2 id="_idParaDest-401"><a id="_idTextAnchor418"/>Performing Pre-Test Setup and Cleanup after Every Test Case Run</h2>
			<p>Sometimes while writing test cases, we may need to perform some repetitive tasks; for example, setting up some variables that will be required for the test. Once the test is over, we would want to clean up all the changes made to the test variables, such that any new test starts with a fresh instance.</p>
			<p>Luckily, the <code>unittest</code> library provides a useful way through which we can automate our repetitive efforts of setting up the environment before every test case runs and cleaning it up after the test case is finished. This is achieved using the following two methods, which we can implement in <code>TestCase</code>.</p>
			<p><code>setUp()</code>: This method is called before the execution of every <code>test</code> method inside the <code>TestCase</code> class. It implements the code required to set up the test case's environment before the test executes. This method can be a good place to set up any local database instance or test variables that may be required for the test cases.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <code>setUp()</code> method is valid only for test cases written inside the <code>TestCase</code> class.</p>
			<p>For example, the following example illustrates a simple definition of how the <code>setUp()</code> method is used inside a <code>TestCase</code> class:</p>
			<pre>class MyTestCase(unittest.TestCase):
    def setUp(self):
        # Do some initialization work
    def test_method_a(self):
        # code for testing method A
    def test_method_b(self):
        # code for testing method B</pre>
			<p>In the preceding example, when we try to execute the test cases, the <code>setUp()</code> method we defined here will be called every time before a <code>test</code> method executes. In other words, the <code>setUp()</code> method will be called before the execution of the <code>test_method_a()</code> call and then it will be called again before <code>test_method_b()</code> is called.</p>
			<p><code>tearDown()</code>: This method is called once the <code>test</code> function finishes execution and cleans up the variables and their values once the test case execution is finished. This method is executed no matter whether the test case evaluates to <code>True</code> or <code>False</code>. An example of using the <code>tearDown()</code> method is shown next:</p>
			<pre>class MyTestCase(unittest.TestCase):
    def setUp(self):
        # Do some initialization work
    def test_method_a(self):
        # code for testing method A
    def test_method_b(self):
        # code for testing method B
    def tearDown(self):
        # perform cleanup</pre>
			<p>In the preceding example, the <code>tearDown()</code> method will be called every time a <code>test</code> method finishes execution, that is, once <code>test_method_a()</code> finishes execution and again once after <code>test_method_b()</code> finishes execution.</p>
			<p>Now, we are aware of the different components of writing test cases. Let us now look at how we can test the different aspects of a Django application using the provided test framework.</p>
			<h1 id="_idParaDest-402"><a id="_idTextAnchor419"/>Testing Django Models</h1>
			<p>Models in Django are object-based representations of how the data will be stored inside the database of an application. They provide methods that can help us validate the data input provided for a given record, as well as performing any processing on the data before it is inserted into the database.</p>
			<p>As easy as it is to create models in Django, it is equally easy to test them. Now, let us look at how Django models can be tested using the Django test framework.</p>
			<h2 id="_idParaDest-403"><a id="_idTextAnchor420"/>Exercise 14.02: Testing Django Models</h2>
			<p>In this exercise, you will create a new Django model and write test cases for it. The test case will validate whether your model can correctly insert and retrieve the data from the database. These kinds of test cases that work on database models can turn out to be useful in cases where a team of developers is collaborating on a large project and the same database model may get modified by multiple developers over time. Implementing test cases for database models allows developers to pre-emptively identify potentially breaking changes that they may inadvertently introduce as a part of their work:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To ensure we get a good hang of running tests from scratch on newly created apps, we'll be creating a new application called <code>bookr_test</code>. This application's code is independent of the main <code>bookr</code> application and consequently, we won't be including this app's files in the <code>final/bookr</code> folder. Upon completion of this chapter, we recommend you practice what you learned by writing similar tests for various components of the main <code>bookr</code> application. </p>
			<ol>
				<li value="1">Create a new application, which you will use for the exercises in this chapter. To do this, run the following command, which will set up a new application for your use case:<pre>python manage.py startapp bookr_test</pre></li>
				<li>To make sure the <code>bookr_test</code> application behaves the same way as any other application in the Django project, add this application to our <code>INSTALLED_APPS</code> section of the <code>bookr</code> project. To do this, open the <code>settings.py</code> file in your <code>bookr</code> project and append the following code to the <code>INSTALLED_APPS</code> list:<pre>INSTALLED_APPS = [….,\
                  ….,\
                  <strong class="bold">'bookr_test'</strong>]</pre></li>
				<li>Now, with the application setup complete, create a new database model, which you will use for testing purposes. For this exercise, you are going to create a new model named <code>Publisher</code>, which will store the details about the book publisher in our database. To create the model, open the <code>models.py</code> file under the <code>bookr_test</code> directory and add the following code to it:<pre>from django.db import models
class Publisher(models.Model):
    """A company that publishes books."""
    name = models.CharField\
           (max_length=50,\
            help_text="The name of the Publisher.")
    website = models.URLField\
              (help_text="The Publisher's website.")
    email = models.EmailField\
            (help_text="The Publisher's email address.")
    def __str__(self):
        return self.name</pre><p>In the preceding code snippet, you have created a new class named <code>Publisher</code>, which inherits from the <code>Model</code> class of Django's <code>models</code> module, defining the class as a Django model, which will be used to store data about the publisher:</p><pre>class Publisher(models.Model)</pre><p>Inside this model, you have added three fields, which will act as the properties of the model:</p><p><code>name</code>: The name of the publisher</p><p><code>website</code>: The website belonging to the publisher</p><p><code>email</code>: The email address of the publisher</p><p>Once this is done, you create a class method, <code>__str__()</code>, which defines how the string representation of the model will look.</p></li>
				<li>Now, with the model created, you first need to migrate this model before you can run a test on it. To do this, run the following commands:<pre>python manage.py makemigrations
python manage.py migrate</pre></li>
				<li>With the model now set up, write the test case with which you are going to test the model created in <em class="italic">step 3</em>. For this, open the <code>tests.py</code> file under the <code>bookr_test</code> directory and add the following code to it:<pre>from django.test import TestCase
from .models import Publisher
class TestPublisherModel(TestCase):
    """Test the publisher model."""
    def setUp(self):
        self.p = Publisher(name='Packt', \
                           website='www.packt.com', \
                           email='contact@packt.com')
    def test_create_publisher(self):
        self.assertIsInstance(self.p, Publisher)
    def test_str_representation(self):
        self.assertEquals(str(self.p), "Packt")</pre><p>In the preceding code snippet, there are a couple of things worth exploring.</p><p>At the start, after importing the <code>TestCase</code> class from the Django <code>test</code> module, you imported the <code>Publisher</code> model from the <code>bookr_test</code> directory, which is going to be used for testing.</p><p>Once the required libraries were imported, you created a new class named <code>TestPublisherModel</code>, which inherits the <code>TestCase</code> class and is used for grouping the unit tests related to the <code>Publisher</code> model:</p><pre>class TestPublisherModel(TestCase):</pre><p>Inside this class, you defined a couple of methods. First, you defined a new method named <code>setUp()</code> and added the <code>Model</code> object creation code inside it such that the <code>Model</code> object is created every time a new <code>test</code> method is executed inside this test case. This <code>Model</code> object is stored as a class member, such that it can be accessed inside other methods without a problem:</p><pre>def setUp(self):
    self.p = Publisher(name='Packt', \
                       website='www.packt.com', \
                       email='contact@packt.com')</pre><p>The first test case validates whether the <code>Model</code> object for the <code>Publisher</code> model was created successfully or not. To do this, you created a new method named <code>test_create_publisher()</code>, inside which you check whether the created Model object points to an object of the <code>Publisher</code> type. If this <code>Model</code> object was not created successfully, your test will fail:</p><pre>    def test_create_publisher(self):
        self.assertIsInstance(self.p, Publisher)</pre><p>If you check carefully, you are using the <code>assertIsInstance()</code> method of the <code>unittest</code> library here to assert whether the <code>Model</code> object belongs to the <code>Publisher</code> type or not.</p><p>The next test validates whether the string representation of the model is the same as what you expected it to be. From the code definition, the string representation of the <code>Publisher</code> model should output the name of the publisher. To test this, you create a new method named <code>test_str_representation()</code> and check whether the generated string representation of the model matches the one you are expecting:</p><pre>def test_str_representation(self):
    self.assertEquals(str(self.p), "Packt")</pre><p>To perform this validation, you use the <code>assertEquals</code> method of the <code>unittest</code> library, which validates whether the two values provided to it are equal or not.</p></li>
				<li>With the test cases now in place, you can run them to check what happens. To run these test cases, run the following command:<pre>python manage.py test</pre><p>Once the command finishes execution, you will see an output that resembles the one shown here (your output may differ slightly, though):</p><pre>% python manage.py test
Creating test database for alias 'default'...
System check identified no issues (0 silenced).
..
----------------------------------------------------------------------
Ran 2 tests in 0.002s
OK
Destroying test database for alias 'default'...</pre><p>As you can see from the preceding output, the test cases are executed successfully, hence validating that the operations such as the creation of a new <code>Publisher</code> object and its string representation when fetched are being done correctly.</p></li>
			</ol>
			<p>With this exercise, we got to see how we can write test cases for our Django models easily and validate their functioning, involving the creation of objects, their retrieval, and representation.</p>
			<p>Also, there is an important line to notice in the output from this exercise:</p>
			<pre>"Destroying test database for alias 'default'..."</pre>
			<p>This happens because when there are test cases that require the data to be persisted inside a database, instead of using the production database, Django creates a new empty database for the test cases, which it uses to persist the value for the test case.</p>
			<h1 id="_idParaDest-404"><a id="_idTextAnchor421"/>Testing Django Views</h1>
			<p>Views in Django control the rendering of the HTTP response for users based on the URL they visit in a web application. In this section, we will get on to understand how we can test views inside Django. Imagine you are working on a website where a lot of <strong class="bold">Application Programming Interface</strong> (<strong class="bold">API</strong>) endpoints are required. An interesting question to ask would be, how will you be able to validate every new endpoint? If done manually, you will have to first deploy the application every time a new endpoint is added, then manually visit the endpoint in the browser to validate whether it is working fine or not. Such an approach may work out when the number of endpoints is low but may become extremely cumbersome if there are hundreds of endpoints.</p>
			<p>Django provides a very comprehensive way of testing application views. This happens with the use of a testing client class provided by Django's <code>test</code> module. This class can be used to visit URLs mapped to the views and capture the output generated by visiting the URL endpoint. Then we can use the captured output to test whether the URLs are generating a correct response or not. This client can be used by importing the <code>Client</code> class from the Django <code>test</code> module and then initializing it as shown in the following snippet:</p>
			<pre>from django.test import Client
c = Client()</pre>
			<p>The client object supports several methods that can be used to simulate the different HTTP calls a user can make, namely, <code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code>, and so on. An example of making such a request will look like this:</p>
			<pre>response = c.get('/welcome')</pre>
			<p>The response generated by the view is then captured by the client and gets exposed as a <code>response</code> object, which can then be queried to validate the output of the view.</p>
			<p>With this knowledge, now let us look at how we can write test cases for our Django views.</p>
			<h2 id="_idParaDest-405"><a id="_idTextAnchor422"/>Exercise 14.03: Writing Unit Tests for Django Views</h2>
			<p>In this exercise, you will use the Django test client to write a test case for your Django view, which will be mapped to a specific URL. These test cases will help you validate whether your view function generates the correct response when visited using its mapped URL:</p>
			<ol>
				<li value="1">For this exercise, you are going to use the <code>bookr_test</code> application that was created in <em class="italic">step 1</em> of <em class="italic">Exercise 14.02</em>, <em class="italic">Testing Django Models</em>. To get started, open the <code>views.py</code> file under the bookr_test directory and add the following code to it:<pre>from django.http import HttpResponse
def greeting_view(request):
    """Greet the user."""
    return HttpResponse("Hey there, welcome to Bookr!")\
                       ("Your one stop place")\
                       ("to review books.")</pre><p>Here, you have created a simple Django view, which will be used to greet the user with a welcome message whenever they visit an endpoint mapped to the provided view.</p></li>
				<li>Once this view is created, you need to map it to a URL endpoint, which can then be visited in a browser or a test client. To do this, open the <code>urls.py</code> file under the <code>bookr_test</code> directory and add the highlighted code to the <code>urlpatterns</code> list:<pre>from django.urls import path
from . import views
urlpatterns = [<code>greeting_view</code> to the <code>'test/greeting'</code> endpoint for the application by setting the path in the <code>urlpatterns</code> list.</p></li>
				<li>Once this path is set up, you need to make sure that it is also identified by your project. To do this, you need to add this entry to the <code>bookr</code> project's URL mapping. To achieve that, open the <code>urls.py</code> file in the <code>bookr</code> directory and append the following highlighted line to the end of the <code>urlpatterns</code> list, as shown next:<pre>urlpatterns = [….,\
               ….,\
               <code>urls.py</code> file should look like this now: <a href="http://packt.live/3nF8Sdb">http://packt.live/3nF8Sdb</a>.</p></li>
				<li>Once the view is set up, validate whether it works correctly. Do this by running the following command:<pre>python manage.py runserver localhost:8080</pre><p>Then visit <code>http://localhost:8080/test/greeting</code> in your web browser. Once the page opens, you should see the following text, which you added to the greeting view in <em class="italic">step 1</em>, being displayed in the browser:</p><pre>Hey there, welcome to Bookr! Your one stop place to review books.</pre></li>
				<li>Now, you are ready to write the test cases for <code>greeting_view</code>. In this exercise, you are going to write a test case that checks whether, on visiting the <code>/test/greeting</code> endpoint, you get a successful result or not. To implement this test case, open the <code>tests.py</code> file under the <code>bookr_test</code> directory and add the following code at the end of the file:<pre>from django.test import TestCase, Client
class TestGreetingView(TestCase):
    """Test the greeting view."""
    def setUp(self):
        self.client = Client()
    def test_greeting_view(self):
        response = self.client.get('/test/greeting')
        self.assertEquals(response.status_code, 200)</pre><p>In the preceding code snippet, you have defined a test case that helps in validating whether the greeting view is working fine or not. </p><p>This is done by first importing Django's test client, which allows testing views mapped to the URLs by making calls to them and analyzing the generated response:</p><pre>from django.test import TestCase, Client</pre><p>Once the import is done, you now create a new class named <code>TestGreetingView</code>, which will group the test cases related to the greeting view that you created in <em class="italic">step 2</em>:</p><pre>class TestGreetingView(TestCase):</pre><p>Inside this test case, you defined two methods, <code>setUp()</code> and <code>test_greeting_view()</code>. The <code>test_greeting_view()</code> method implements your test case. Inside this, you first make an HTTP <code>GET</code> call to the URL that is mapped to the greeting view and then store the response generated by the view inside the <code>response</code> object created:</p><pre>response = self.client.get('/test/greeting')</pre><p>Once this call finishes, you will have its HTTP response code, contents, and headers available inside the <code>response</code> variable. Next, with the following code, you make an assertion validating whether the status code generated by the call matches the status code for successful HTTP calls (<code>HTTP 200</code>):</p><pre>self.assertEquals(response.status_code, 200)</pre><p>With this, you are now ready to run the tests.</p></li>
				<li>With the test case written, let's look at what happens when you run the test case:<pre>python manage.py test</pre><p>Once the command executes, you can expect to see an output like the one shown in the following snippet:</p><pre>% python manage.py test
Creating test database for alias 'default'...
System check identified no issues (0 silenced).
...
----------------------------------------------------------------------
Ran 3 tests in 0.006s
OK
Destroying test database for alias 'default'...</pre><p>As you can see from the output, your test cases executed successfully, hence validating that the response generated by the <code>greeting_view()</code> method is as per your expectations.</p></li>
			</ol>
			<p>In this exercise, you learned how you can implement a test case for a Django view function and use <code>TestClient</code> provided by Django to assert that the output generated by the view function matches the one that the developer should see.</p>
			<h2 id="_idParaDest-406"><a id="_idTextAnchor423"/>Testing Views with Authentication</h2>
			<p>In the previous example, we looked at how we can test views inside Django. An important part to be highlighted about this view is that the view we created could be accessed by anyone and is not protected by any authentication or login checks. Now imagine a case where a view should only be accessible if the user is logged in. For example, imagine implementing a view function that renders the profile page of a registered user of our web application. To make sure that only logged-in users can view the profile page for their account, you might want to restrict the view to logged-in users only.</p>
			<p>With this, we now have an important question: <em class="italic">How can we test views that require authentication?</em></p>
			<p>Luckily, Django's test client provides this functionality through which we can log in to our views and then run tests on them. This result can be achieved by using Django's test client <code>login()</code> method. When this method is called, Django's test client performs an authentication operation against the service and if the authentication succeeds, it stores the login cookie internally, which it can then use for further test runs. The following code snippet shows how you can set up Django's test client to simulate a logged-in user:</p>
			<pre>login = self.client.login(username='testuser', password='testpassword')</pre>
			<p>The <code>login</code> method requires a username and password for the test user that we are going to test with, as will be shown in the next exercise. So, let us look at how we can test a flow that requires user authentication.</p>
			<h2 id="_idParaDest-407"><a id="_idTextAnchor424"/>Exercise 14.04: Writing Test Cases to Validate Authenticated Users</h2>
			<p>In this exercise, you will write test cases for views that require the user to be authenticated. As part of this, you will validate the output generated by the view method when a user who is not logged in tries to visit the page and when a user who is logged in tries to visit the page mapped to the view function:</p>
			<ol>
				<li value="1">For this exercise, you are going to use the <code>bookr_test</code> application that you created in <em class="italic">step 1</em> of <em class="italic">Exercise 14.02</em>, <em class="italic">Testing Django Models</em>. To get started, open the <code>views.py</code> file under the bookr_test application and add the following code to it:<pre>from django.http import HttpResponse
from django.contrib.auth.decorators import login_required</pre><p>Once the preceding code snippet is added, create a new function, <code>greeting_view_user()</code>, at the end of the file, as shown in the following code snippet:</p><pre>@login_required
def greeting_view_user(request):
    """Greeting view for the user."""
    user = request.user
    return HttpResponse("Welcome to Bookr! {username}"\
                        .format(username=user))</pre><p>With this, you have created a simple Django view that will be used to greet the logged-in user with a welcome message whenever they visit an endpoint mapped to the provided view.</p></li>
				<li>Once this view is created, you need to map this view to a URL endpoint that can then be visited in a browser or a test client. To do this, open the <code>urls.py</code> file under the <code>bookr_test</code> directory and add the following highlighted code to it:<pre>from django.urls import path
from . import views
urlpatterns = [<code>greeting_view_user</code> to the <code>'test/greet_user'</code> endpoint for the application by setting the path in the <code>urlpatterns</code> list. If you have followed the previous exercises, this URL should already be set up for detection in the project and no further steps are required to configure the URL mapping.</p></li>
				<li>Once the view is set up, the next thing you need to do is to validate whether it works correctly. To do this, run the following command:<pre>python manage.py runserver localhost:8080</pre><p>Then visit <code>http://localhost:8080/test/greet_user</code> in your web browser.</p><p>If you are not logged in already, by visiting the preceding URL, you will be redirected to the login page for the project.</p></li>
				<li>Now, write the test cases for <code>greeting_view_user</code>, which checks whether, on visiting the <code>/test/greet_user</code> endpoint, you get a successful result. To implement this test case, open the <code>tests.py</code> file under the <code>bookr_test</code> directory and add the following code to it:<pre>from django.contrib.auth.models import User
class TestLoggedInGreetingView(TestCase):
    """Test the greeting view for the authenticated users."""
    def setUp(self):
        test_user = User.objects.create_user\
                    (username='testuser', \
                     password='test@#628password')
        test_user.save()
        self.client = Client()
    def test_user_greeting_not_authenticated(self):
        response = self.client.get('/test/greet_user')
        self.assertEquals(response.status_code, 302)
    def test_user_authenticated(self):
        login = self.client.login\
                (username='testuser', \
                 password='test@#628password')
        response = self.client.get('/test/greet_user')
        self.assertEquals(response.status_code, 200)</pre><p>In the preceding code snippet, you have implemented a test case that checks the views that have authentication enabled before their content can be seen.</p><p>With this, you first imported the required classes and methods that will be used to define the test case and initialize a testing client:</p><pre>from django.test import TestCase, Client</pre><p>The next thing you require is the <code>User</code> model from Django's <code>auth</code> module:</p><pre>from django.contrib.auth.models import User</pre><p>This model is required because for the test cases requiring authentication, you will need to initialize a new test user. Next up, you created a new class named <code>TestLoggedInGreetingView</code>, which wraps your tests related to the <code>greeting_user</code> view (which requires authentication). Inside this class, you defined three methods, namely: <code>setUp()</code>, <code>test_user_greeting_not_authenticated()</code>, and <code>test_user_authenticated()</code>. The <code>setUp()</code> method is used to first initialize a test user, which you will use for authentication. This is a required step because a test environment inside Django is a completely isolated environment that doesn't use data from your production application, hence all the required models and objects are to be instantiated separately inside the test environment.</p><p>You then created the test user and initiated the test client using the following code:</p><pre>test_user = User.objects.create_user\
            (username='testuser', \
             password='test@#628password')
test_user.save()
self.client = Client()</pre><p>Next up, you wrote the test case for the <code>greet_user</code> endpoint when the user is not authenticated. Inside this, you should expect Django to redirect the user to the login endpoint. This redirect can be detected by checking the HTTP status code of the response, which should be set to <code>HTTP 302</code>, indicating a redirect operation:</p><pre>def test_user_greeting_not_authenticated(self):
    response = self.client.get('/test/greet_user')
    self.assertEquals(response.status_code, 302)</pre><p>Next, you wrote another test case to check whether the <code>greet_user</code> endpoint renders successfully when the user is authenticated. To authenticate the user, you first call the <code>login()</code> method of the test client and perform authentication by providing the username and password of the test user you created in the <code>setUp()</code> method as follows: </p><pre>login = self.client.login\
        (username='testuser', \
         password='test@#628password')</pre><p>Once the login is completed, you make an <code>HTTP GET</code> request to the <code>greet_user</code> endpoint and validate whether the endpoint generates a correct result or not by checking the HTTP status code of the returned response:</p><pre>response = self.client.get('/test/greet_user')
self.assertEquals(response.status_code, 200)</pre></li>
				<li>With the test cases written, it is time to check how they run. For this, run the following command:<pre>python manage.py test</pre><p>Once the execution finishes, you can expect to see a response that resembles the one that follows:</p><pre>% python manage.py test
Creating test database for alias 'default'...
System check identified no issues (0 silenced).
.....
----------------------------------------------------------------------
Ran 5 tests in 0.366s
OK
Destroying test database for alias 'default'...</pre><p>As we can see from the preceding output, our test cases have passed successfully, validating that the view we created generates the desired response of redirecting the user if the user is unauthenticated to the website, and allows the user to see the page if the user is authenticated.</p></li>
			</ol>
			<p>In this exercise, we just implemented a test case where we can test the output generated by a view function regarding the authentication status of the user. </p>
			<h1 id="_idParaDest-408"><a id="_idTextAnchor425"/>Django Request Factory</h1>
			<p>Till now, we have been using Django's test client to test the views we have created for our application. The test client class simulates a browser and uses this simulation to make calls to the required APIs. But what if we did not want to use the test client and its associated simulation of being a browser, but rather wanted to test the view functions directly by passing the request parameter? How can we do that? </p>
			<p>To help us in such cases, we can leverage the <code>RequestFactory</code> class provided by Django. The <code>RequestFactory</code> class helps us provide the <code>request</code> object, which we can pass to our view functions to evaluate their working. The following object for <code>RequestFactory</code> can be created by instantiating the class as follows:</p>
			<pre>factory = RequestFactory()</pre>
			<p>The <code>factory</code> object thus created supports only HTTP methods such as <code>get()</code>, <code>post()</code>, <code>put()</code>, and others, to simulate a call to any URL endpoint. Let us look at how we can modify the test case that we wrote in <em class="italic">Exercise 14.04</em>, <em class="italic">Writing Test Cases to Validate Authenticated Users</em>, to use <code>RequestFactory</code>.</p>
			<h2 id="_idParaDest-409"><a id="_idTextAnchor426"/>Exercise 14.05: Using a Request Factory to Test Views</h2>
			<p>In this exercise, you will use a request factory to test view functions in Django:</p>
			<ol>
				<li value="1">For this exercise, you are going to use the existing <code>greeting_view_user</code> view function, which you created earlier, in <em class="italic">step 1</em> of <em class="italic">Exercise 14.04</em>, <em class="italic">Writing Test Cases to Validate Authenticated Users</em>, which is shown as follows:<pre>@login_required
def greeting_view_user(request):
    """Greeting view for the user."""
    user = request.user
    return HttpResponse("Welcome to Bookr! {username}"\
                        .format(username=user))</pre></li>
				<li>Next, modify the existing test case, <code>TestLoggedInGreetingView</code>, defined inside the <code>tests.py</code> file under the <code>bookr_test</code> directory. Open the <code>tests.py</code> file and make the following changes.<p>First, you need to add the following import to use <code>RequestFactory</code> inside the test cases:</p><pre>from django.test import RequestFactory</pre><p>The next thing you need is an import for the <code>AnonymousUser</code> class from Django's <code>auth</code> module and the <code>greeting_view_user</code> view method from the <code>views</code> module. This is required to test the view functions with a simulated user who is not logged in. This can be done by adding the following code:</p><pre>from django.contrib.auth.models import AnonymousUser
from .views import greeting_view_user</pre></li>
				<li>Once the <code>import</code> statements are added, modify the <code>setUp()</code> method of the <code>TestLoggedInGreetingView</code> class and change its contents to resemble the one shown next:<pre>def setUp(self):
    self.test_user = User.objects.create_user\
                     (username='testuser', \
                      password='test@#628password')
    self.test_user.save()
    self.factory = RequestFactory()</pre><p>In this method, you first created a <code>user</code> object and stored it as a class member such that you can use it later in the tests. Once the <code>user</code> object is created, then instantiate a new instance of the <code>RequestFactory</code> class to use it for testing our view function.</p></li>
				<li>With the <code>setUp()</code> method now defined, modify the existing tests to use the <code>RequestFactory</code> instance. For the test for a non-authenticated call to the view function, modify the <code>test_user_greeting_not_authenticated</code> method to have the following contents:<pre>def test_user_greeting_not_authenticated(self):
    request = self.factory.get('/test/greet_user')
    request.user = AnonymousUser()
    response = greeting_view_user(request)
    self.assertEquals(response.status_code, 302)</pre><p>In this method, you first created a <code>request</code> object using the <code>RequestFactory</code> instance you defined in the <code>setUp()</code> method. Once that was done, you assigned an <code>AnonymousUser()</code> instance to the <code>request.user</code> property. Assigning the <code>AnonymousUser()</code> instance to the property makes the view function think that the user making the request is not logged in:</p><pre>request.user = AnonymousUser()</pre><p>Once this is done, you made a call to the <code>greeting_view_user()</code> view method and passed to it the <code>request</code> object you created. Once the call is successful, you capture the output of the method in the <code>response</code> variable using the following code:</p><pre>response = greeting_view_user(request)</pre><p>For the unauthenticated user, you expect to get a redirect response, which can be tested by checking the HTTP status code of the response as follows:</p><pre>self.assertEquals(response.status_code, 302)</pre></li>
				<li>Once this is done, go ahead and modify the other method, <code>test_user_authenticated()</code>, similarly by using the <code>RequestFactory</code> instance as follows:<pre>def test_user_authenticated(self):
    request = self.factory.get('/test/greet_user')
    request.user = self.test_user
    response = greeting_view_user(request)
    self.assertEquals(response.status_code, 200)</pre><p>As you can see, most of the code resembles the code you wrote in the <code>test_user_greeting_not_authenticated</code> method, with the small change that, in this method, instead of using <code>AnonymousUser</code> for our <code>request.user</code> property, you are using <code>test_user</code>, which you created in our <code>setUp()</code> method:</p><pre>request.user = self.test_user</pre><p>With the changes done, it is time to run the tests.</p></li>
				<li>To run the tests and validate whether the request factory works as expected, run the following command:<pre>python manage.py test</pre><p>Once the command executes, you can expect to see an output that resembles the one shown next:</p><pre>% python manage.py test   
Creating test database for alias 'default'...
System check identified no issues (0 silenced).
......
----------------------------------------------------------------------
Ran 6 tests in 0.248s
OK
Destroying test database for alias 'default'...</pre><p>As we can see from the output, the test cases written by us have passed successfully, hence validating the behavior of the <code>RequestFactory</code> class.</p></li>
			</ol>
			<p>With this exercise, we learned how we can write test cases for view functions leveraging <code>RequestFactory</code> and passing the <code>request</code> object directly to the view function, rather than simulating a URL visit using the test client approach, and hence allowing more direct testing.</p>
			<h2 id="_idParaDest-410"><a id="_idTextAnchor427"/>Testing Class-Based Views</h2>
			<p>In the previous exercise, we saw how we can test views defined as methods. But what about class-based views? How can we test those?</p>
			<p>As it turns out, it is quite easy to test class-based views. For example, if we have a class-based view defined with the name <code>ExampleClassView(View)</code>, to test the view, all we need to do is to use the following syntax:</p>
			<pre>response = ExampleClassView.as_view()(request)</pre>
			<p>It is as simple as that.</p>
			<p>A Django application generally consists of several different components that can work in isolation, such as models, and some other components that need to interact with the URL mapping and other parts of the framework to work. Testing these different components may require some steps that are common only to those components. For example, when testing a model, we might first want to create certain objects of the <code>Model</code> class before we start testing, or for views, we might first want to initialize a test client with user credentials.</p>
			<p>As it turns out, Django also provides some other classes based on top of the <code>TestCase</code> class, which can be used to write test cases of specific types about the type of the component being used. Let us look at these different classes provided by Django.</p>
			<h1 id="_idParaDest-411"><a id="_idTextAnchor428"/>Test Case Classes in Django</h1>
			<p>Beyond the base <code>TestCase</code> class provided by Django, which can be used to define a multitude of test cases for different components, Django also provides some specialized classes derived from the <code>TestCase</code> class. These classes are used for specific types of test cases based on the capabilities they provide to the developer. </p>
			<p>Let us take a quick look at them.</p>
			<h2 id="_idParaDest-412"><a id="_idTextAnchor429"/>SimpleTestCase</h2>
			<p>This class is derived from the <code>TestCase</code> class provided by Django's <code>test</code> module and should be used for writing simple test cases that test the view functions. Usually, the class is not preferred when your test case involves making database queries. The class also provides a lot of useful features, such as the following:</p>
			<ul>
				<li>The ability to check for exceptions raised by a view function</li>
				<li>The ability to test form fields</li>
				<li>A built-in test client</li>
				<li>The ability to verify a redirect by a view function</li>
				<li>Matching the equality of two HTML, JSON, or XML outputs generated by the view functions</li>
			</ul>
			<p>Now, with a basic idea of what <code>SimpleTestCase</code> is, let us try to understand another type of test case class that helps in writing test cases involving interaction with databases.</p>
			<h2 id="_idParaDest-413"><a id="_idTextAnchor430"/>TransactionTestCase</h2>
			<p>This class is derived from the <code>SimpleTestCase</code> class and should be used when writing test cases that involve interaction with the database, such as database queries, model object creations, and so on.</p>
			<p>The class provides the following added features:</p>
			<ul>
				<li>The ability to reset the database to a default state before a test case runs</li>
				<li>Skipping tests based on database features – this feature can come in handy if the database being used for testing does not support all the features of a production database</li>
			</ul>
			<h2 id="_idParaDest-414"><a id="_idTextAnchor431"/>LiveServerTestCase</h2>
			<p>This class is like the <code>TransactionTestCase</code> class, but with the small difference that the test cases written in the class use a live server created by Django (instead of using the default test client).</p>
			<p>This ability to run the live server for testing comes in handy when writing test cases that test for the rendered web pages and any interaction with them, which is not possible while using the default test client.</p>
			<p>Such test cases can leverage tools such as <strong class="bold">Selenium</strong>, which can be used to build interactive test cases that modify the state of the rendered page by interacting with it.</p>
			<h2 id="_idParaDest-415"><a id="_idTextAnchor432"/>Modularizing Test Code</h2>
			<p>In the previous exercises, we have seen how we can write test cases for different components of our project. But an important aspect to note is that, till now, we have written the test cases for all the components in a single file. This approach is okay when the application does not have a lot of views and models. But this can become problematic as our application grows because now our single <code>tests.py</code> file will be hard to maintain.</p>
			<p>To avoid running into such scenarios, we should try to modularize our test cases such that the test cases for models are kept separately from test cases related to the views, and so on. To achieve this modularization, all we need to do is two simple steps:</p>
			<ol>
				<li value="1">Create a new directory named <code>tests</code> inside your application directory by running the following command:<pre>mkdir tests</pre></li>
				<li>Create a new empty file named <code>__init__.py</code> inside your tests directory by running the following command:<pre>touch __init__.py</pre><p>This <code>__init__.py</code> file is required by Django to correctly detect the <code>tests</code> directory we created as a module and not a regular directory.</p></li>
			</ol>
			<p>Once the preceding steps are done, you can go ahead and create new testing files for the different components in your application. For example, to write test cases for your models, you can create a new file named <code>test_models.py</code> inside the tests directory and add any associated code for your model testing inside this file.</p>
			<p>Also, you do not need to take any other additional steps to run your tests. The same command will work perfectly fine for your modular testing code base as well:</p>
			<pre>python manage.py test</pre>
			<p>With this, we have now understood how we can write test cases for our projects. So, how about we assess this knowledge by writing test cases for the Bookr project that we are working on?</p>
			<h2 id="_idParaDest-416"><a id="_idTextAnchor433"/>Activity 14.01: Testing Models and Views in Bookr</h2>
			<p>In this activity, you will implement test cases for the Bookr project. You will implement test cases to validate the functioning of the models created inside the <code>reviews</code> application of the Bookr project, and then you will implement a simple test case for validating the <code>reviews</code> application.</p>
			<p>The following steps will help you work through this activity:</p>
			<ol>
				<li value="1">Create a directory named <code>tests</code> inside the <code>reviews</code> application directory, such that all our test cases for the <code>reviews</code> application can be modularized.</li>
				<li>Create an empty <code>__init__.py</code> file, such that the directory is considered not as a general directory, but rather a Python module directory.</li>
				<li>Create a new file, <code>test_models.py</code>, for implementing the code that tests the models. Inside this file, import the models you want to test.</li>
				<li>Inside <code>test_models.py</code>, create a new class that inherits from the <code>TestCase</code> class of the <code>django.tests</code> module and implements methods to validate the creation and reading of the <code>Model</code> objects.</li>
				<li>To test the view function, create a new file named <code>test_views.py</code> inside the <code>tests</code> directory, which was created in <em class="italic">step 1</em>.</li>
				<li>Inside the <code>test_views.py</code> file, import the test <code>Client</code> class from the <code>django.tests</code> module and the <code>index</code> view function from the <code>reviews</code> application's <code>views.py</code> file.</li>
				<li>Inside the <code>test_views.py</code> file created in <em class="italic">step 5</em>, create a new <code>TestCase</code> class, and implement methods to validate the index view.</li>
				<li>Inside the <code>TestCase</code> class created in <em class="italic">step 7</em>, create a new function, <code>setUp()</code>, inside which you should initialize an instance of <code>RequestFactory</code>, which will be used to create a <code>request</code> object that can be directly passed to the view function for testing.</li>
				<li>Once the previous steps are done and the test cases are written, run the test cases by executing the <code>python manage.py</code> test to validate that the test cases pass.</li>
			</ol>
			<p>Upon completing this activity, all test cases should pass successfully.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution to this activity can be found at <a href="http://packt.live/2Nh1NTJ">http://packt.live/2Nh1NTJ</a>.</p>
			<h1 id="_idParaDest-417"><a id="_idTextAnchor434"/>Summary</h1>
			<p>Throughout this chapter, we looked at how we can write test cases for different components of our web application project with Django. We learned about why testing plays a crucial role in the development of any web application and the different types of testing techniques that are employed in the industry to make sure the application code they ship is stable and bug-free.</p>
			<p>We then looked at how we can use the <code>TestCase</code> class provided by Django's <code>test</code> module to implement our unit tests, which can be used to test the models as well as views. We also looked at how we can use Django's <code>test</code> client to test our view functions that require or do not require the user to be authenticated. We also glanced over another approach of using <code>RequestFactory</code> to test method views and class-based views.</p>
			<p>We concluded the chapter by understanding the predefined classes provided by Django and where they should be used and looked at how we can modularize our testing codebase to make it appear clean.</p>
			<p>As we move on to the next chapter, we will try to understand how we can make our Django application more powerful by integrating third-party libraries into our project. This functionality will then be used to implement third-party authentication into our Django application and thus allow users to log in to the application using popular services such as Google Sign-In, Facebook Login, and more.</p>
		</div>
	</body></html>