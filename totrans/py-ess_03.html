<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Expressions and Output</h1></div></div></div><p>Expressions are central to Python programming. As noted in <a class="link" href="ch01.html" title="Chapter 1. Getting Started">Chapter 1</a>, <em>Getting Started</em>, Python has a rich collection of operators and built-in functions. In this chapter, we'll summarize the relationship between data types and the operators they support.</p><p>Perhaps the most fundamental program possible is one that performs a calculation and displays output. To demonstrate this, we'll look at the <code class="literal">print()</code> function in this chapter. We'll expand on the basics by looking at a number of ways to produce nicely-formatted text output.</p><p>We'll need to look in detail at the Python syntax rules. This will be essential for writing scripts with more complex sequences of statements. It will also set the stage for looking at compound statements in <a class="link" href="ch05.html" title="Chapter 5. Logic, Comparisons, and Conditions">Chapter 5</a>, <em>Logic, Comparisons, and Conditions</em>.</p><p>This chapter will also demonstrate some additional string processing techniques. We'll summarize some of the standard library modules that are focused on string processing. We'll look closely at the <code class="literal">re</code> module; we use this to build regular expressions that help parse string input. Between the built-in methods of the <code class="literal">str</code> class, and the <code class="literal">re</code> module, we can handle a wide variety of text input conversion.</p><div><div><div><div><h1 class="title"><a id="ch03lvl1sec26"/>Expressions, operators, and data types</h1></div></div></div><p>Python expressions<a class="indexterm" id="id189"/> are built from<a class="indexterm" id="id190"/> operators and operands. In <a class="link" href="ch02.html" title="Chapter 2. Simple Data Types">Chapter 2</a>, <em>Simple Data Types</em>, we introduced some of the basics of number and<a class="indexterm" id="id191"/> string operands, and looked at the variety of operators. We'll summarize the details here so that we can address some additional operator features.</p><p>Our numeric operands form a "tower", with types including:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Type</p>
</th><th style="text-align: left" valign="bottom">
<p>Cardinality</p>
</th><th style="text-align: left" valign="bottom">
<p>Number of operators</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">complex</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Ideally, the<a class="indexterm" id="id192"/> most distinct values built from a pair of irrational numbers, ∞×∞.</p>
<p>Actually (<code class="literal">float</code> × <code class="literal">float</code>) or about <img alt="Expressions, operators, and data types" src="img/B03671_03_01.jpg"/> values.</p>
</td><td style="text-align: left" valign="top">
<p>The fewest operators; only arithmetic, some built-in functions, and the <code class="literal">cmath</code> module.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">float</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Ideally<a class="indexterm" id="id193"/> this is a rational number union with irrational numbers (∞+∞).</p>
<p>Actually closer to <img alt="Expressions, operators, and data types" src="img/B03671_03_02.jpg"/> distinct values.</p>
</td><td style="text-align: left" valign="top">
<p>Arithmetic operators, comparisons. Many additional <code class="literal">math</code> modules and built-in functions.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">fractions.Fraction</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Ideally, these<a class="indexterm" id="id194"/> are rational numbers (∞×∞).</p>
<p>Actually only limited by available memory to represent two integers.</p>
</td><td style="text-align: left" valign="top">
<p>Arithmetic operators, comparisons, built-in functions.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">decimal.Decimal</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Ideally, rational<a class="indexterm" id="id195"/> numbers.</p>
<p>Actually only limited by memory</p>
</td><td style="text-align: left" valign="top">
<p>Arithmetic operators, comparisons, built-in functions.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">int</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Ideally, natural <a class="indexterm" id="id196"/>numbers, ∞.</p>
<p>Actually limited only by memory.</p>
</td><td style="text-align: left" valign="top">
<p>Arithmetic operators, comparisons, plus bit-handling operators, libraries and built-in functions.</p>
</td></tr></tbody></table></div><p>The <code class="literal">Fraction</code> and <code class="literal">Decimal</code> class definitions must be imported, the other three classes are built-in. We typically use a statement such as <code class="literal">from fractions import Fraction</code>.</p><p>The idea behind the tower is that many arithmetic operators coerce operands up the tower from integer to float to complex. Most of the time, this fits with our implicit mathematical expectations. We would be unhappy if we had to write explicit conversions to compute <code class="literal">2.333*3</code>. Python's arithmetic rules assure us that we'll get the expected floating-point result.</p><p>The <code class="literal">Decimal</code> class doesn't fit well with the implicit coercion rules: in the rare case of trying to do arithmetic between <code class="literal">float</code> and <code class="literal">Decimal</code>, it's unclear how to go about it. An attempt to make a <code class="literal">Decimal</code> value from a <code class="literal">float</code> value will expose tiny errors because <code class="literal">float</code> values are an approximation. An attempt to make a <code class="literal">float</code> value from a <code class="literal">Decimal</code> value subverts the <code class="literal">Decimal</code> objective of yielding exact results. In the face of this ambiguity, an exception will be raised. This means that we'll need to write explicit conversions.</p><p>String objects are not implicitly coerced into numeric values. We must explicitly convert a string to a number. The <code class="literal">int()</code>, <code class="literal">float()</code>, <code class="literal">complex()</code>, <code class="literal">Fraction()</code>, and <code class="literal">Decimal()</code> functions convert a string to a number object of the appropriate class.</p><p>We can group <a class="indexterm" id="id197"/>operators into a number of categories.</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Arithmetic</strong>: <code class="literal">+</code>, <code class="literal">-</code>, <code class="literal">*</code>, <code class="literal">**</code>, <code class="literal">/</code>, <code class="literal">//</code>, <code class="literal">%</code></li><li class="listitem" style="list-style-type: disc"><strong>Bit-oriented</strong>: <code class="literal">&lt;&lt;</code>, <code class="literal">&gt;&gt;</code>, <code class="literal">&amp;</code>, <code class="literal">|</code>, <code class="literal">^</code>, <code class="literal">~</code></li><li class="listitem" style="list-style-type: disc"><strong>Comparison</strong>: <code class="literal">&lt;</code>, <code class="literal">&gt;</code>, <code class="literal">&lt;=</code>, <code class="literal">&gt;=</code>, <code class="literal">==</code>, <code class="literal">!=</code></li></ul></div><p>The <a class="indexterm" id="id198"/>bit-oriented operators are<a class="indexterm" id="id199"/> supported by operands of the <code class="literal">int</code> class. The other number classes don't have useful implementations of these operators. The bit-oriented operators are also defined for sets, something we'll look at in <a class="link" href="ch06.html" title="Chapter 6. More Complex Data Types">Chapter 6</a>, <em>More Complex Data Types</em>.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec33"/>Using operators on non-numeric data</h2></div></div></div><p>We can<a class="indexterm" id="id200"/> apply some of the arithmetic operators to strings, bytes, and tuples. The results are focused on creating larger strings or larger tuples from smaller pieces. Here are some examples of this:</p><div><pre class="programlisting">&gt;&gt;&gt; "Hello " + "world"
'Hello world'
&gt;&gt;&gt; "&lt;+&gt;"*4
'&lt;+&gt;&lt;+&gt;&lt;+&gt;&lt;+&gt;'
&gt;&gt;&gt; "&lt;+&gt;"*-2
''</pre></div><p>In the first example, we applied <code class="literal">+</code> to two strings. In the second example, we applied <code class="literal">*</code> between a <code class="literal">str</code> and an <code class="literal">int</code>. Interestingly, Python produces a string result by concatenating several copies of the original string object. Multiplying by any negative number creates a zero-length string.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec27"/>The print() function</h1></div></div></div><p>When working <a class="indexterm" id="id201"/>with Python's REPL, we can enter an expression and Python prints the result. In other contexts, we must use the <code class="literal">print()</code> function to see results. The <code class="literal">print()</code> function implicitly writes to <code class="literal">sys.stdout</code>, so the results will be visible on the console where we ran the Python script.</p><p>We can provide any number of expressions to the <code class="literal">print()</code> function. Each value is converted to a string using the <code class="literal">repr()</code> function. The strings are combined with a default separator of <code class="literal">' '</code> and printed with a default line ending of <code class="literal">'\n'</code>. We can change the separator and line ending characters. Here are some examples of this:</p><div><pre class="programlisting">&gt;&gt;&gt; print("value", 355/113)
value 3.1415929203539825
&gt;&gt;&gt; print("value", 355/113, sep='=')
value=3.1415929203539825
&gt;&gt;&gt; print("value", 355/113, sep='=', end='!\n')
value=3.1415929203539825!</pre></div><p>We've printed a string and the floating-point result of an expression. In the second example, we changed the separator string from a space to <code class="literal">'='</code>. In the third example, we changed the separator string to <code class="literal">'='</code> and the end-of-line string to <code class="literal">'!\n'</code>.</p><p>Note that the <code class="literal">sep</code> and <code class="literal">end</code> parameters <a class="indexterm" id="id202"/>must be provided by name; these are called <a class="indexterm" id="id203"/>
<strong>keyword arguments</strong>. Python syntax rules require that keyword argument values are provided after all of the positional arguments. We'll examine the rules in detail in <a class="link" href="ch07.html" title="Chapter 7. Basic Function Definitions">Chapter 7</a>, <em>Basic Function Definitions</em>.</p><p>We can use <code class="literal">,</code> as a separator to create simple <a class="indexterm" id="id204"/>
<strong>comma-separated values</strong> (<strong>CSV</strong>) files. We can also use <code class="literal">\t</code> to create a kind of CSV file with a tab character as the column separator. The <code class="literal">csv</code> library module does an even more complete job of CSV formatting, specifically including proper escapes or quoting for data items which contain the separator character.</p><p>To write to the standard error file, we'll need to import the <code class="literal">sys</code> module, where that object is defined. For example:</p><div><pre class="programlisting">import sys
print("Error Message", file=sys.stderr)</pre></div><p>We've imported the <code class="literal">sys</code> module. This contains definitions of <code class="literal">sys.stderr</code> and <code class="literal">sys.stdout</code> for the standard output files. By using the <code class="literal">file=</code> keyword parameter, we can direct a specific line of output to the <code class="literal">stderr</code> file instead of the default of <code class="literal">stdout</code>.</p><p>This can work well in a script file. Using the standard error file doesn't look very interesting at the REPL prompt since, by default, both standard output and standard error go to the console. Some IDE's will color-code the standard error output. We'll look at many ways to open and write to other files in <a class="link" href="ch10.html" title="Chapter 10. Files, Databases, Networks, and Contexts">Chapter 10</a>, <em>Files, Databases, Networks, and Contexts</em>.</p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec28"/>Examining syntax rules</h1></div></div></div><p>There are<a class="indexterm" id="id205"/> nine fundamental syntax rules in section 2.1 of the <em>Python Language Reference</em>. We'll summarize those rules here:</p><div><ol class="orderedlist arabic"><li class="listitem">There are two species of statements: simple and compound. Simple statements must be complete on a single logical line. A compound statement starts with a single logical line and must contain indented statements. The initial clause of a compound statement ends with a <code class="literal">:</code> character. It's possible, using rules 5 and 6, to join a number of physical lines together to create a single logical line.<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Here's a typical simple statement, complete in a single logical line:<div><pre class="programlisting">from decimal import Decimal</pre></div></li><li class="listitem" style="list-style-type: disc">Here's a typical compound statement with a nested simple statement, spread across two logical lines:<div><pre class="programlisting">if a &gt; b:
    print(a, "is larger")</pre></div></li></ul></div></li><li class="listitem">A <strong>physical line</strong><a class="indexterm" id="id206"/> ends with <code class="literal">\n</code>. In Windows, <code class="literal">\r\n</code> is also accepted.</li><li class="listitem">A <strong>comment</strong><a class="indexterm" id="id207"/> starts with <code class="literal">#</code> and continues to the end of the physical line. It will end the logical line.<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Here's an example of a comment:<div><pre class="programlisting">from fractions import Fraction # We'll use this to improve accuracy</pre></div></li></ul></div></li><li class="listitem">A <a class="indexterm" id="id208"/>special comment can be used to annotate the file encoding. This is generally not needed, since most IDE's and text editors handle the file encoding politely. We should generally save Python files in UTF-8 encoding. Older files may be saved in ASCII.</li><li class="listitem">Physical lines can be joined explicitly into a logical line using the <code class="literal">\</code> as an escape character in front of the physical end-of-line character. This is rarely used and generally discouraged.</li><li class="listitem">Physical lines can be joined implicitly into a logical line using <code class="literal">()</code>, <code class="literal">[]</code>, or <code class="literal">{}</code>; these must pair properly for the logical line to be complete. An expression beginning with <code class="literal">(</code> can span multiple physical lines until there is a matching <code class="literal">)</code>. This is used frequently and is strongly encouraged.<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Here's an example of a statement that relies on <code class="literal">()</code> to join four physical lines into one logical line:<div><pre class="programlisting">print (
    "big number",
    2 ** 2048
)</pre></div></li></ul></div></li><li class="listitem">Blank lines contain only spaces, tabs and newlines. The interactive REPL uses a blank line to end a compound statement; the REPL is the only context in which a blank line is meaningful.</li><li class="listitem">Leading whitespace is <strong>required</strong> to properly group statements inside the clauses of compound statements. Either spaces or tabs can be used to indent. Consistency is essential. A four space indent is widely used and strongly encouraged.</li><li class="listitem">Except at the beginning of the line,—where it determines nesting of compound statements—whitespace can be used freely between tokens. Note that there are some preferences regarding precisely how spaces are used within a statement; the <strong>Python Enhancement Proposal</strong> (<strong>PEP</strong>) number 8 provides<a class="indexterm" id="id209"/> some advice. See <a class="ulink" href="https://www.python.org/dev/peps/pep-0008/">https://www.python.org/dev/peps/pep-0008/</a> for fodder for endless disputes.</li></ol></div><p>Perhaps the most important two rules are rule 6 and rule 8. Rule 6 means that it is very common to use <code class="literal">()</code>, <code class="literal">[]</code>, and <code class="literal">{}</code> to force multiple physical lines to be joined into a single logical line.</p><p>Rule 8 requires<a class="indexterm" id="id210"/> that our indentation is done consistently: indents and outdents must be matched. While it's legal to use tabs, spaces, and any haphazard—but consistent—mix of tabs and spaces, four spaces is highly recommended. Tabs are discouraged because they're hard to distinguish from spaces. Most editors can be set to replace the tab key with four spaces. A good text editor can recognize the basics of Python syntax and can handle indents and outdents gracefully.</p><div><div><h3 class="title"><a id="tip06"/>Tip</h3><p>Use <code class="literal">()</code> to allow a statement to span multiple physical lines; avoid <code class="literal">\</code> at end-of-line.</p><p>Use a four space indent.</p></div></div><p>Also note that Python will merge adjacent strings when parsing the source. We can have code that looks like this:</p><div><pre class="programlisting">&gt;&gt;&gt; message = ("Hello"
... "world")
&gt;&gt;&gt; message
'Helloworld'</pre></div><p>This assignment statement used a gratuitous <code class="literal">()</code> pair to allow the logical line to span multiple physical lines. The expression is simply two adjacent strings, <code class="literal">"Hello"</code> and <code class="literal">"world"</code>. When Python parses the source text, these two adjacent strings are merged; only a single string is used when evaluating the statement.</p><p>Additionally, note that the REPL prompt changed from <code class="literal">&gt;&gt;&gt;</code> to … because the REPL recognized the first physical line as a partial statement. This is a handy reminder that our statement isn't complete. When the final <code class="literal">)</code> was parsed, the statement was complete and the prompt switched back to <code class="literal">&gt;&gt;&gt;</code>.</p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec29"/>Splitting, partitioning, and joining strings</h1></div></div></div><p>In <a class="link" href="ch02.html" title="Chapter 2. Simple Data Types">Chapter 2</a>, <em>Simple Data Types</em>, we looked at different processing methods for a string object. We can transform a string into a new string, create strings from non-string data, access a string to determine properties or locations within the string, and parse a string to decompose it.</p><p>In many cases, we <a class="indexterm" id="id211"/>need to extract elements of a string. The <code class="literal">split()</code> method is <a class="indexterm" id="id212"/>used to locate repeating list-like structures within a string. The <code class="literal">partition()</code> method is used to separate the head and tail of a string.</p><p>For example, given a <a class="indexterm" id="id213"/>string of the form <code class="literal">"numerator=355,denominator=115"</code> we can use these two methods to locate the various names and values. Here's how we can decompose this complex string into pieces:</p><div><pre class="programlisting">&gt;&gt;&gt; text="numerator=355,denominator=115"
&gt;&gt;&gt; text.split(",")
['numerator=355', 'denominator=115']
&gt;&gt;&gt; items= _
&gt;&gt;&gt; items[0].partition("=")
('numerator', '=', '355')
&gt;&gt;&gt; items[1].partition("=")
('denominator', '=', '115')</pre></div><p>We've used the <code class="literal">split(",")</code> method to break the longer string on each <code class="literal">,</code> character, creating a list object which has two substrings. The REPL automatically assigns all expression results to a variable named <code class="literal">_</code>. We assigned the object to the <code class="literal">items</code> variable because the value of <code class="literal">_</code> gets overwritten by each expression statement.</p><p>We used the <code class="literal">partition("=")</code> method on each item in the <code class="literal">items</code> variable to break the assignment down into name, <code class="literal">=</code>, and value. A more complex application would probably perform more complex processing on the names and values.</p><p>The <code class="literal">join()</code> method is the inverse of the <code class="literal">split()</code> method. This works with a sequence of string objects to create a single long string from many smaller strings. Here's an example of using a tuple of strings to create a longer string:</p><div><pre class="programlisting">&gt;&gt;&gt; options = ("x", "y", "z")
&gt;&gt;&gt; "|".join(options)
'x|y|z'</pre></div><p>We've created a sequence of three strings and assigned it to a variable named <code class="literal">options</code>. We then used the string <code class="literal">"|"</code> to join the items in the <code class="literal">options</code> sequence. The result is a longer string with the items separated by the given string.</p><p>The <code class="literal">split()</code> and <code class="literal">join()</code> methods <a class="indexterm" id="id214"/>work well with singletons. If we try to split a single item with no punctuation, we get a sequence with a single item. If we join a singleton item, the separator will not be used.</p><p>Python's string<a class="indexterm" id="id215"/> methods give us the tools to handle a variety of string <a class="indexterm" id="id216"/>parsing and decomposition. For a more general solution, we'll have to resort to even more powerful tools. We'll look at the regular expression module, <code class="literal">re</code>, later.</p><p>If we want to create complex strings, we use the <code class="literal">format()</code> method. We'll look at this next.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec34"/>Using the format() method to make more readable output</h2></div></div></div><p>Sophisticated<a class="indexterm" id="id217"/> string creation can be done with the <code class="literal">format()</code> method. We create a template string and values which can be plugged into the template. Here's an example of how this works:</p><div><pre class="programlisting">&gt;&gt;&gt; c=42
&gt;&gt;&gt; "{0:d}°C is {1:.1f}°F".format(c, 32+9*c/5)
'42°C is 107.6°F'</pre></div><p>We've created a variable, <code class="literal">c</code>, with a value of 42. We've used a template, <code class="literal">"{0:d}°C is {1:.1f}°F"</code>, to format two values. The argument value with an index of 0 is <code class="literal">c</code>, the argument value with an index of 1 is the value of the expression <code class="literal">32+9*c/5</code>.</p><p>The template string includes literal characters, plus replacement fields. Each replacement field is surrounded by <code class="literal">{}</code>. The replacement field has two components with a syntax of <code class="literal">{index:specification}</code>. The <em>index</em> component identifies which item is taken from the positional arguments to the <code class="literal">format()</code> method. The <em>specification</em> component shows us how to format the selected object.</p><p>The example gives two specifications. One specification is the character <code class="literal">d</code>, which is the decimal integer conversion. The other is the slightly more complex <code class="literal">.1f</code>, which is a floating-point conversion with one digit to the right of the decimal point.</p><p>There is considerable sophistication available in the format specifications. There are eight fields to a format specification. The syntax gloss looks like this:</p><div><pre class="programlisting">[[fill]align][sign][#][0][width][,][.precision][type]</pre></div><p>We've surrounded each field with <code class="literal">[]</code> to group the names visually. Note that all the fields are actually optional and have default values.</p><p>We'll summarize the<a class="indexterm" id="id218"/> fields from right to left in order of importance.</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Type</strong>: This specifies the overall type of conversion. Depending on the kind of Python object, there are a number of type codes available:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">For string values, the type code of <code class="literal">s</code> is used.</li><li class="listitem" style="list-style-type: disc">For integer values, type codes of <code class="literal">d</code>, <code class="literal">n</code>, <code class="literal">b</code>, <code class="literal">o</code>, <code class="literal">x</code>, or <code class="literal">X</code> can be used. These provide decimal, locale-aware numbers, binary, octal, or hexadecimal output.</li><li class="listitem" style="list-style-type: disc">For float values, type codes are <code class="literal">e</code>, <code class="literal">E</code>, <code class="literal">f</code>, <code class="literal">F</code>, <code class="literal">g</code>, <code class="literal">G</code>, <code class="literal">n</code>, or <code class="literal">%</code>. The <code class="literal">e</code> formats provide explicit exponents. The <code class="literal">f</code> codes show <code class="literal">float</code> values with no exponent. The <code class="literal">g</code> values are called <strong>general</strong> and choose <code class="literal">e</code> or <code class="literal">f,</code> depending on the size of the number. The <code class="literal">n</code> code is locale-aware, using the locale settings for floating-point presentation. The <code class="literal">%</code> multiplies by 100 and includes the <code class="literal">%</code> symbol.</li></ul></div></li><li class="listitem" style="list-style-type: disc"><strong>Precision</strong>: The <code class="literal">.precision</code> value is only used for floating-point formats. It's the number of positions to the right of the decimal point.</li><li class="listitem" style="list-style-type: disc"><strong>The , separator</strong>: If a <code class="literal">,</code> character is used, then US-style <code class="literal">,</code> as 1,000's separators are included. This isn't locale-aware, so it can't be overridden by the OS and the Python locale module.</li><li class="listitem" style="list-style-type: disc"><strong>Width</strong>: If omitted, the number is formatted as wide as necessary. If provided, the number is filled out to this width. By default, the fill uses leading spaces, but this can be changed by providing values for the <em>fill</em> and <em>align</em> fields.</li><li class="listitem" style="list-style-type: disc"><strong>0</strong>: This forces filling to the required width with leading zeroes. This is the same as a fill and align of <code class="literal">0=</code>.</li><li class="listitem" style="list-style-type: disc"><strong>#</strong>: This is used with <code class="literal">b</code>, <code class="literal">o</code>, and <code class="literal">x</code> formatting to include a prefix of <code class="literal">0b</code>, <code class="literal">0o</code>, or <code class="literal">0x</code> in front of the number.</li><li class="listitem" style="list-style-type: disc"><strong>Sign</strong>: By default, positive numbers have no sign and negative numbers have a leading <code class="literal">-</code>. Providing a <em>sign</em> field of <code class="literal">+</code> means that all signs are shown explicitly. Providing a <em>sign</em> field of <code class="literal">-</code> means that an extra space is included for positive numbers, assuring that positive and negative numbers will align in columns when printed using a fixed-width font.</li><li class="listitem" style="list-style-type: disc"><strong>Fill and align</strong>: This fills up the space to the value of the <em>width</em> field. If we provide <em>align</em> without a specific <em>fill</em> character, the default character is a space. We can't provide a <em>fill</em> character on its own, though. There are four codes we can use:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">&lt;</code> or <em>fill</em><code class="literal">&lt;</code> will push the data to the left, and the filling will be on the right.</li><li class="listitem" style="list-style-type: disc"><code class="literal">&gt;</code> or <em>fill</em><code class="literal">&gt;</code> will push the data to the right, the fill character will be used on the left.</li><li class="listitem" style="list-style-type: disc"><code class="literal">^</code> or <em>fill</em><code class="literal">^</code> will center the data, filling both left and right.</li><li class="listitem" style="list-style-type: disc"><code class="literal">=</code> or <em>fill</em><code class="literal">=</code> will put the sign first, and the fill character will be used after the sign. This will make the signs more prominent in a column of numbers.</li></ul></div></li></ul></div><p>Here's an example<a class="indexterm" id="id219"/> that uses a fairly complex format specification:</p><div><pre class="programlisting">&gt;&gt;&gt; amount=Decimal("234.56")
&gt;&gt;&gt; "Pay: ${0:*&gt;10n} dollars".format(amount)
'Pay: $****234.56 dollars'</pre></div><p>We've created an object, <code class="literal">amount</code>, with a <code class="literal">Decimal</code> value. We then used a format specification of <code class="literal">*&gt;10n</code> on this number. This used leading <code class="literal">*</code> characters to fill out the number to 10 characters.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec30"/>Summary of the standard string libraries</h1></div></div></div><p>Python's standard <a class="indexterm" id="id220"/>library offers a number of modules with additional string processing features.</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">string</code>: The<a class="indexterm" id="id221"/> string module <a class="indexterm" id="id222"/>contains constants that decompose the ASCII characters into letters, numbers, whitespace, and so on. It contains the full definition of the formatter that is used by the <code class="literal">str.format()</code> method. We'll look at this in the next section. It also contains the <code class="literal">Template</code> class which defines a string template into which values can be interpolated.</li><li class="listitem" style="list-style-type: disc"><code class="literal">re</code>: The <a class="indexterm" id="id223"/>regular expression library allows us to define a pattern<a class="indexterm" id="id224"/> that can be used to parse input strings. We'll look at this in the next section.</li><li class="listitem" style="list-style-type: disc"><code class="literal">difflib</code>: The <a class="indexterm" id="id225"/><code class="literal">difflib</code> module <a class="indexterm" id="id226"/>is used to compare sequences of strings, typically from text files. There are a number of comparison algorithms available in this module.</li><li class="listitem" style="list-style-type: disc"><code class="literal">textwrap</code>: We can use the <a class="indexterm" id="id227"/><code class="literal">textwrap</code> module <a class="indexterm" id="id228"/>to format large blocks of text.</li><li class="listitem" style="list-style-type: disc"><code class="literal">unicodedata</code>: The <code class="literal">unicodedata</code><a class="indexterm" id="id229"/> module <a class="indexterm" id="id230"/>provides functions for determining what kind of Unicode character is present. Unicode Standard Annex 44 defines a collection of properties that apply to the Unicode characters. One commonly-used function is the general category of a character; this includes simple Latin rules like "Lu" for uppercase letter or "Nd" for decimal number. The general category codes also include "Sk" which is for non-letter like modifier symbols.</li><li class="listitem" style="list-style-type: disc"><code class="literal">stringprep</code>: This is<a class="indexterm" id="id231"/> an implementation <a class="indexterm" id="id232"/>of RFC 3454, which prepares Unicode text strings in order to support sensible string comparisons.</li></ul></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec35"/>Using the re module to parse strings</h2></div></div></div><p>Regular expressions<a class="indexterm" id="id233"/> give us a simple way to specify a set of related strings by describing the pattern they have in common. A regular expression is an element of set theory that could (in theory) define the set of all possible related strings. The theoretical matching process would be a quick check to see if a given string in this set of all possible strings is generated by the expression. Since the set of all possible strings generated from a pattern could potentially be infinite, this isn't how things work in practice.</p><p>When we use the <code class="literal">re</code> module, we generally do three things. Firstly, we specify the pattern string. Secondly, we compile the pattern into an object that efficiently determines if and where a given string matches the pattern. Finally, we repeatedly use the <code class="literal">pattern</code> object to efficiently match, search, or parse the given input strings.</p><p>As a concrete example, we need to process input which contains lines like this: <code class="literal">Birth Date: 3/8/1987</code> or <code class="literal">Birth Date: 1/18/59</code>. Note that the number of digits in each date and the amount of whitespace is allowed to vary.</p><p>We may perform any of the following three common kinds of processing:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A <strong>matching</strong> regular expression<a class="indexterm" id="id234"/> might be <code class="literal">Birth Date:\s+\d+/\d+/\d+</code>. The <code class="literal">\s+</code> subexpression means one or more spaces. The <code class="literal">\d+</code> subexpression of this means one or more digits. A match pattern is usually designed to match the whole string.</li><li class="listitem" style="list-style-type: disc">A <strong>searching</strong> regular expression<a class="indexterm" id="id235"/> might be <code class="literal">\d+/\d+/\d+</code>. This search pattern includes one or more digits, <code class="literal">\d+</code>, and literal punctuation, <code class="literal">/</code>. This expression describes a substring that can be found somewhere within the given string.</li><li class="listitem" style="list-style-type: disc">A <strong>parsing</strong> pattern<a class="indexterm" id="id236"/> separates the various digit groups from the surrounding context. This is a slight modification to one of the previous examples to include <code class="literal">()</code>, that specifies what to capture. We might use <code class="literal">(\d+)/(\d+)/(\d+)</code> to show that the digit groups should be extracted for further processing.</li></ul></div><p>We can accomplish these matching, searching, and parsing operations with the <code class="literal">re</code> module in Python.</p><div><div><div><div><h3 class="title"><a id="ch03lvl3sec07"/>Using regular expressions</h3></div></div></div><p>The general recipe <a class="indexterm" id="id237"/>for using regular expressions in a Python program has three essential steps. Of course, we must use import re to include the required module. The three steps are:</p><div><ol class="orderedlist arabic"><li class="listitem">Define the pattern string. This will almost always be a raw string, starting with <code class="literal">r"</code>, because the regular expression string will be full of <code class="literal">\</code> characters that we don't want to be treated as escapes by Python. Because <code class="literal">\</code> begins a Python language escape, if we want to write a standalone <code class="literal">\</code> character, we have to double them up in a non-raw string. It is better to use a raw string to write <code class="literal">r"\d+/\d+/\d+"</code> than <code class="literal">\\d+/\\d+/\\d+</code>.</li><li class="listitem">Evaluate the <code class="literal">re.compile()</code> function to create a <code class="literal">pattern</code> object. The resulting object will do the real work of matching a given target string against the regular expression <code class="literal">pattern</code> object.<p>We can combine the pattern and the compile in one statement like this:</p><div><pre class="programlisting">&gt;&gt;&gt; date_pattern = re.compile(r"Birth Date:\s+(.*)")</pre></div></li><li class="listitem">Use the compiled <code class="literal">pattern</code> object to match or search the candidate strings. The result of a successful match or search will be a <code class="literal">Match</code> object. We can then use the match object, where necessary, to extract fields. For example:<div><pre class="programlisting">&gt;&gt;&gt; match = date_pattern.match("Should Not Match")
&gt;&gt;&gt; match
&gt;&gt;&gt; match = date_pattern.match("Birth Date: 3/8/87")
&gt;&gt;&gt; match
&lt;_sre.SRE_Match object at 0X82e60&gt;</pre></div><p>In the first example, the <code class="literal">date_pattern.match()</code> expression returned <code class="literal">None</code> because the given string didn't match the regular expression. In the second example, the given string did match the regular expression pattern, and a <code class="literal">Match</code> object was created. If our regular expression is used for parsing, we'll interrogate the <code class="literal">Match</code> object to get the various substrings.</p></li></ol></div><p>When we have a <code class="literal">Match</code> object, it can have captured substrings that match parts of the overall pattern. We'll usually make use of the various <code class="literal">group()</code> methods to get substrings. Here are some examples:</p><div><pre class="programlisting">&gt;&gt;&gt; match.group()
'Birth Date: 3/8/87'
&gt;&gt;&gt; match.group(1)
'3/8/87'
&gt;&gt;&gt; match.groups()
('3/8/87',)</pre></div><p>In the first example, we saw all of the matching content. In the second example, we saw the value of group <a class="indexterm" id="id238"/>number one, the first portion of the regular expression wrapped in <code class="literal">()</code>. In the final example, we saw all <code class="literal">()</code>-wrapped groups in the regular expression. Since there was only one such group, the value of <code class="literal">groups()</code> is a single-item <code class="literal">tuple</code> with matching text.</p></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec08"/>Creating a regular expression string</h3></div></div></div><p>There are <a class="indexterm" id="id239"/>numerous rules for creating regular expression patterns, and we'll look at a few of them here. The definitive list is in the <em>Python Standard Library</em> documentation for the <code class="literal">re</code> module, in section 6.2.1. For more information on this topic, see <em>Mastering Python Regular Expressions</em> from Packt Books. See <a class="ulink" href="https://www.packtpub.com/application-development/mastering-python-regular-expressions">https://www.packtpub.com/application-development/mastering-python-regular-expressions</a>.</p><p>First we'll look at the "atomic" regular expressions. Then we'll look at the rules for combining regular expressions into a larger regular expression. Here are some simple, atomic regular expressions:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Any single character. With a few exceptions, this means just about any printable character. The exceptions are the characters which have special meaning in the regular expression language, including <code class="literal">.</code>, <code class="literal">*</code>, <code class="literal">?</code>, <code class="literal">(</code>, <code class="literal">)</code>, <code class="literal">[</code>, <code class="literal">]</code>, <code class="literal">|</code> among others.</li><li class="listitem" style="list-style-type: disc">A <code class="literal">.</code> matches any character. To match a period, the <code class="literal">\</code> escape character is used: <code class="literal">\.</code> matches a period.</li><li class="listitem" style="list-style-type: disc">Some escape sequences match whole classes of characters.<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">\d</code> matches any digit. <code class="literal">\D</code> matches any non-digit character.</li><li class="listitem" style="list-style-type: disc"><code class="literal">\s</code> matches any whitespace character. <code class="literal">\S</code> matches any non-space character.</li><li class="listitem" style="list-style-type: disc"><code class="literal">\w</code> matches any word character. <code class="literal">\W</code> matches any non-word character. By default, these follow the Unicode rules. We can override this to follow a considerably simpler set of ASCII-only rules.</li></ul></div></li></ul></div><p>There are some suffixes that we can put after a regular expression.</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A <code class="literal">*</code> suffix means the previous expression can be matched zero or more times. This has the effect of making the previous RE pattern optional as well as eligible for repetition.</li><li class="listitem" style="list-style-type: disc">A <code class="literal">+</code> suffix means the previous expression can be matched one or more times. This means that the previous pattern is mandatory and can also be repeated.</li><li class="listitem" style="list-style-type: disc">A <code class="literal">?</code> suffix means the previous expression is optional; it can be matched zero times or just one time.</li><li class="listitem" style="list-style-type: disc">To actually match a suffix character, use the <code class="literal">\</code> escape. For example, <code class="literal">\*</code> matches an asterisk.</li></ul></div><p>We can combine individual<a class="indexterm" id="id240"/> expressions into larger patterns. Here are some common techniques for doing this:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A sequence of regular expressions is a regular expression. We simply put the expressions one after another inside the pattern string. When we write an expression like <code class="literal">Birth</code> it's a sequence of five atomic expressions which match each individual character.</li><li class="listitem" style="list-style-type: disc">A sequence of characters in <code class="literal">[]</code> matches any one of the given characters. This is generally used with single-character expressions; often we'll see constructs like <code class="literal">[a-zA-Z0-9_]</code> to match any letter or digit or <code class="literal">_</code>. To match multiple-character strings we use a suffix after the <code class="literal">[]</code>. We can use <code class="literal">r"[0-9a-fA-F]+"</code> to match one or more hexadecimal digits. To make <code class="literal">-</code> one of the alternative characters, it must be first or last within the list of characters inside the <code class="literal">[]</code>.</li><li class="listitem" style="list-style-type: disc">Two regular expressions separated by <code class="literal">|</code> is a regular expression. Either one can match. We might be looking at a pattern like <code class="literal">true|false</code>. We must match one of the two regular expressions: either <code class="literal">true</code> or <code class="literal">false</code>. To match the pipe character, <code class="literal">|</code>, it must be escaped like this <code class="literal">\|</code>.</li><li class="listitem" style="list-style-type: disc">A regular expression surrounded by <code class="literal">()</code>'s is a regular expression. It's also preserved as a group, so that we can use the matching characters while parsing. To match parentheses, they must be escaped, <code class="literal">\(</code> matches a <code class="literal">(</code>. Substrings captured via <code class="literal">()</code> are available via the <code class="literal">group()</code> method of the match object.</li></ul></div><p>These rules help us examine the details of a specific pattern. Here's a pattern we might use to parse some input:</p><div><pre class="programlisting">r"(\w+)\s*[=:]\s*(.*)"</pre></div><p>This is a regular expression which is a sequence of 5 regular expressions.</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The characters <code class="literal">(\w+)</code> make a regular expression, <code class="literal">\w</code>, with a <code class="literal">+</code> suffix enclosed in <code class="literal">()</code>. This matches any sequence of one or more word characters.</li><li class="listitem" style="list-style-type: disc"><code class="literal">\s*</code> is a regular expression. It's a simple expression <code class="literal">\s</code> with a suffix of <code class="literal">*</code>. It matches zero or more whitespace characters. This means that spaces are optional after the initial word. If spaces are present, any number may be used.</li><li class="listitem" style="list-style-type: disc"><code class="literal">[=:]</code> is a regular expression built from two single-character expressions, <code class="literal">=</code> and <code class="literal">:</code>. It matches either one of the two characters.</li><li class="listitem" style="list-style-type: disc"><code class="literal">\s*</code> is used a second time to permit any number of whitespace characters between the <code class="literal">=</code> or <code class="literal">:</code> and the value.</li><li class="listitem" style="list-style-type: disc">The final regular expression is <code class="literal">(.*)</code> which matches any sequence of characters.</li></ul></div><p>When we use this regular<a class="indexterm" id="id241"/> expression, if a <code class="literal">Match</code> object is created, it will have two groups. We can then extract the name and value matched by the patterns within this regular expression.</p></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec09"/>Working with Unicode, ASCII, and bytes</h3></div></div></div><p>The <code class="literal">re</code> module <a class="indexterm" id="id242"/>works with bytes as well as Unicode strings. We must provide proper pattern literals depending on which kind of string we're working with. With Unicode, we use pattern literals with the <code class="literal">r</code> prefix: <code class="literal">r"\w+"</code>. With bytes, we use the <code class="literal">rb</code> prefix, <code class="literal">rb"\w+"</code>; the <code class="literal">rb</code> means raw bytes instead of raw Unicode characters.</p><p>The rules for the character classes are, of course, different. A Unicode string that matches the <code class="literal">"\w+"</code> pattern can have any of a wide variety of Unicode "word" characters. A bytes object that uses<a class="indexterm" id="id243"/> the <code class="literal">"\w+"</code> pattern <a class="indexterm" id="id244"/>will match ASCII characters from the set <code class="literal">a-z</code>, <code class="literal">A-Z</code>, <code class="literal">0-9</code> and <code class="literal">_</code>.</p><div><div><h3 class="title"><a id="tip07"/>Tip</h3><p>We must explicitly use bytes for the pattern literals when parsing, searching, or matching with bytes.</p></div></div><p>We can use an option in the <code class="literal">re.compile()</code> to force a Unicode pattern to follow the simplified ASCII rules. If we write <code class="literal">re.compile(r"\w+", re.ASCII)</code> we've replaced the default Unicode assumption for <code class="literal">\w</code> with the ASCII rule for <code class="literal">\w</code> even though we're doing Unicode string matching.</p></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec36"/>Using the locale module for personalization</h2></div></div></div><p>When<a class="indexterm" id="id245"/> looking at the <code class="literal">str.format()</code> method, we saw that the <code class="literal">n</code> format type produced a number with formatting based on the user's locale. This means that the formatting varies according to the OS locale settings. Users in different countries will see that their personal locale settings are used properly.</p><p>Here's an example of using the <code class="literal">locale</code> module to get locale-specific formatting:</p><div><pre class="programlisting">&gt;&gt;&gt; import locale
&gt;&gt;&gt; locale.setlocale(locale.LC_ALL,'')
'en_US.UTF-8'
&gt;&gt;&gt; "{0:n}".format(23.456)
'23.456'
&gt;&gt;&gt; locale.setlocale(locale.LC_ALL,'sv_SE')
'sv_SE'
&gt;&gt;&gt; "{0:n}".format(23.456)
'23,456'</pre></div><p>This script used <a class="indexterm" id="id246"/>the <code class="literal">locale</code> module to set the Python locale to match the prevailing OS locale. The locale is reported to be English as used in the US (<code class="literal">en_US</code>) and the preferred Unicode encoding is shown as UTF-8.</p><p>The formatted value of <code class="literal">23.456</code> showed up with a US English decimal point. This fits the expectations of users in the US.</p><p>We then switched the locale to Sweden. The language was reported as <code class="literal">sv_SE</code>, which means the Swedish language, as used in Sweden. The formatted value switched to <code class="literal">23,456</code> with a decimal comma, which is appropriate for users in Sweden.</p><p>Let's continue this example, and use the <code class="literal">locale.currency()</code> formatting function:</p><div><pre class="programlisting">&gt;&gt;&gt; locale.currency(23.54)
'23,54 kr'</pre></div><p>The amount was formatted using <code class="literal">,</code> for the decimal separator and <code class="literal">kr</code> as the local currency in Sweden. The locale module includes the currency names.</p><p>Note that we provided the numeric value, <code class="literal">23.54</code>, in Python syntax, which does not vary by locale. Python floating-point literals always use decimal points. Only the output string from the <code class="literal">currency()</code> function uses the <code class="literal">,</code> character as a decimal place separator.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec31"/>Summary</h1></div></div></div><p>In this chapter, we've reviewed the essential numeric types and the operators available on Python. We've looked at some expressions that involve a mixture of string and numeric data.</p><p>In order to view the output from our scripts, we've looked at the <code class="literal">print()</code> function. This is used widely to produce output. The <code class="literal">print()</code> function is a very handy tool for debugging particularly complex functions or classes.</p><p>Additionally, we've looked at how we can use the <code class="literal">str.format()</code> method to produce elaborately formatted data. This gives us a wide variety of techniques for converting Python objects to strings that can be displayed. We've also looked at some ways that we can parse strings using string method functions such as <code class="literal">split()</code> and <code class="literal">partition()</code>.</p><p>Beyond the basics of string processing, we've looked at how we can use the <code class="literal">re</code> module to match, search, and parse strings. This module is sophisticated and has a large number of features for extracting useful information from input strings.</p><p>In <a class="link" href="ch04.html" title="Chapter 4. Variables, Assignment and Scoping Rules">Chapter 4</a>, <em>Variables, Assignment and Scoping Rules</em>, we'll expand on our script-writing by using variables to store intermediate results. We'll also look at how objects are created and removed. These rules will lead to an understanding of which variables are visible in which portions of a complex program.</p></div></body></html>