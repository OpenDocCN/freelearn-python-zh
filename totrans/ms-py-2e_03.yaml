- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pythonic Syntax and Common Pitfalls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to write Pythonic code, along with finding
    out about some of the common pitfalls of Python and how to work around them. The
    pitfalls range from passing a list or dictionary (which are mutable) as an argument
    to more advanced pitfalls, such as late-binding in closures. You will also see
    how to fix or work around circular imports in a clean way. Some of the techniques
    used in the examples in this chapter might seem a bit too advanced for such an
    early chapter. Do not worry, though, as the inner workings will be covered later
    on.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will explore the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Code style (PEP 8, `pyflakes`, `flake8`, and more)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common pitfalls (lists as function arguments, pass by value versus pass by reference,
    and inheritance behavior)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The definition of Pythonic code used in this chapter is based on commonly accepted
    coding guidelines and my subjective opinions. When working on a project, it is
    most important to stay consistent with the coding styles of that project.
  prefs: []
  type: TYPE_NORMAL
- en: A brief history of Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Python project started in December 1989 as a hobby project for Guido van
    Rossum during his week off around Christmas. His goal was to write an easy-to-use
    successor for the ABC programming language and to fix the issues that limited
    the applicability of the it. One of the main design goals of Python is, and has
    always been, readability. That is what the first part of the chapter is about:
    readability.'
  prefs: []
  type: TYPE_NORMAL
- en: To facilitate new features and to maintain that readability, the **Python Enhancement
    Proposal** (**PEP**) process was developed. This process allows **anyone** to
    submit a PEP for a new feature, library, or other addition. After a discussion
    on the Python mailing lists and some improvements, a decision is made to either
    accept or reject the proposal.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python style guide (PEP 8: [https://peps.python.org/pep-0008/](https://peps.python.org/pep-0008/))
    was once submitted as one of those PEPs, was accepted, and has been improved regularly
    ever since. It has a lot of great and widely accepted conventions, as well as
    a few disputed ones. In particular, the maximum line length of 79 characters is
    a topic of much discussion. Limiting a line to 79 characters does have some merits,
    however. Originally, this choice was made because terminals were 80 characters
    wide, but these days, larger monitors allow you to place multiple files next to
    each other. For docstrings and comments, a 72-character limit is recommended to
    increase readability. Additionally, it’s the common convention for Linux/Unix
    man (manual) pages.'
  prefs: []
  type: TYPE_NORMAL
- en: 'While just the style guide itself does not make code Pythonic, as *The Zen
    of Python* (PEP 20: [https://peps.python.org/pep-0020/](https://peps.python.org/pep-0020/))
    elegantly puts it: “Beautiful is better than ugly.” PEP 8 defines how code should
    be formatted in an exact way, while PEP 20 is more of a philosophy and mindset
    than anything else.'
  prefs: []
  type: TYPE_NORMAL
- en: For almost 30 years, all major decisions for the Python project were made by
    Guido van Rossum, lovingly called the **BDFL** (**Benevolent Dictator For Life**).
    Unfortunately, the “For Life” part of BDFL was not to be after a heated debate
    over PEP 572\. PEP 572 (covered later in this chapter) was a proposal about assignment
    operators, the ability to set a variable inside an `if` statement, a common practice
    in languages such as C, C++, C# and others. Guido van Rossum was not a fan of
    the syntax and opposed the PEP. This triggered a huge debate and he was met with
    such resistance that it moved him to step down as BDFL. It saddened many people
    that Guido van Rossum, universally loved by the community, felt he had to do this.
    I, for one, will certainly miss his insights as the decision-maker. I hope we
    will still see his “Time Machine” in action a few times. Guido van Rossum is thought
    to have a time machine, as he has repeatedly answered feature requests with “I
    just implemented that last night.”
  prefs: []
  type: TYPE_NORMAL
- en: 'Without the BDFL to make the final decisions, the Python community had to come
    up with a new way of decision-making, and a whole list of proposals have been
    written to solve this issue:'
  prefs: []
  type: TYPE_NORMAL
- en: 'PEP 8010: Continue status quo (ish): [https://peps.python.org/pep-8010/](https://peps.python.org/pep-8010/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'PEP 8011: Like status quo but with three co-leaders: [https://peps.python.org/pep-8011/](https://peps.python.org/pep-8011/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'PEP 8012: No central authority: [https://peps.python.org/pep-8012/](https://peps.python.org/pep-8012/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'PEP 8013: Non-core oversight: [https://peps.python.org/pep-8013/](https://peps.python.org/pep-8013/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'PEP 8014: Core oversight: [https://peps.python.org/pep-8014/](https://peps.python.org/pep-8014/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'PEP 8015: Organization of the Python community: [https://peps.python.org/pep-8015/](https://peps.python.org/pep-8015/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'PEP 8016: The Steering Council Model: [https://peps.python.org/pep-8016/](https://peps.python.org/pep-8016/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After a small debate, PEP 8016 - the steering council model - was accepted as
    the solution. PEP 81XX has been reserved for future elections of the steering
    council, with PEP 8100 for the 2019 election, PEP 8101 for the 2020 election,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Code style – What is Pythonic code?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you first hear of Pythonic code, you might think it is a programming paradigm,
    similar to object-oriented or functional programming. It is actually more of a
    design philosophy. Python leaves you free to choose to program in an object-oriented,
    procedural, functional, aspect-oriented, or even logic-oriented way. These freedoms
    make Python a great language to write in, but they have the drawback of requiring
    more discipline to keep code clean and readable. PEP 8 tells us how to format
    code and PEP 20 is about style and how to write Pythonic code. PEP 20, the Pythonic
    philosophy, is about code that is:'
  prefs: []
  type: TYPE_NORMAL
- en: Clean
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Beautiful
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explicit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Readable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most of these sound like common sense, and I think they should be. There are
    cases, however, where there is not a single obvious way to write your code (unless
    you’re Dutch, of course, as you’ll read later in this chapter). That is the goal
    of this chapter—to help you to learn how to write beautiful Python code and understand
    why certain decisions have been made in the Python style guide.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s get started.
  prefs: []
  type: TYPE_NORMAL
- en: Whitespace instead of braces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most common complaints about Python for non-Python programmers is
    the use of whitespace instead of braces. Something can be said for both cases,
    and in the end, it doesn’t matter that much. Since nearly every programming language
    already defaults to similar indenting rules even with braces, why not skip the
    braces altogether and make things more readable? That’s what Guido van Rossum
    must have thought when designing the Python language.
  prefs: []
  type: TYPE_NORMAL
- en: 'At one point, some programmers asked Guido van Rossum whether Python would
    ever support braces. Since that day, braces have been available through a `__future__`
    import. Just give it a try:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Next, let’s talk about formatting strings.
  prefs: []
  type: TYPE_NORMAL
- en: Formatting strings – printf, str.format, or f-strings?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python has supported both the printf style (`%`) and `str.format` for a long
    time, so you are most likely familiar with both already. With the introduction
    of Python 3.6, an extra option became available, the f-string (PEP 498). The f-string
    is a convenient shorthand for `str.format`, which helps with brevity (and therefore,
    I would argue, readability).
  prefs: []
  type: TYPE_NORMAL
- en: 'PEP 498 – Literal String Interpolation: [https://peps.python.org/pep-0498/](https://peps.python.org/pep-0498/)'
  prefs: []
  type: TYPE_NORMAL
- en: The previous edition of this book mainly used the printf style because brevity
    is important in code samples. While the maximum line length as per PEP 8 is 79
    characters, this book is limited to 66 characters before wrapping occurs. With
    f-strings, we finally have a concise alternative to the printf style.
  prefs: []
  type: TYPE_NORMAL
- en: '**Tip for running the code in this book**'
  prefs: []
  type: TYPE_NORMAL
- en: Since a large portion includes the `>>>` prefix, simply copy/paste it into IPython
    and it will execute the code as regular Python code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, the GitHub repository for the book has a script to automatically
    convert a sample from doctest style to regular Python: [https://github.com/mastering-python/code_2/blob/master/doctest_to_python.py](https://github.com/mastering-python/code_2/blob/master/doctest_to_python.py)'
  prefs: []
  type: TYPE_NORMAL
- en: To show the power of f-strings, let’s see a few examples of `str.format` and
    the printf style next to each other.
  prefs: []
  type: TYPE_NORMAL
- en: The examples in this chapter show the output as returned by the Python console.
    For a regular Python file, you need to add `print()` to see the output.
  prefs: []
  type: TYPE_NORMAL
- en: Simple formatting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Formatting a simple string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Formatting a floating-point number with two decimals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The first real advantage comes when using a variable multiple times. That is
    not possible with the printf style without resorting to named values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we used `name` twice by using the reference `{0}`.
  prefs: []
  type: TYPE_NORMAL
- en: Named variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using named variables is fairly similar and this is where we get introduced
    to the magic of f-strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, with the f-strings, the variables are fetched from the scope
    automatically. It’s basically a shorthand for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Arbitrary expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Arbitrary expressions are where the real power of f-strings becomes visible.
    The features of f-strings go far beyond the string interpolation of the printf-style
    features. The f-strings also support full Python expressions, which means they
    support complex objects, calling methods, `if` statements, and even loops:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: PEP 20, the Zen of Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*The Zen of Python*, as mentioned in the *A brief history of Python* section
    earlier, is about code that not only works, but is Pythonic. Pythonic code is
    readable, concise, and maintainable. PEP 20 says it best:'
  prefs: []
  type: TYPE_NORMAL
- en: “Long time Pythoneer Tim Peters succinctly channels the BDFL’s guiding principles
    for Python’s design into 20 aphorisms, only 19 of which have been written down.”
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The next few paragraphs will explain the intentions of these 19 aphorisms with
    some example code.
  prefs: []
  type: TYPE_NORMAL
- en: 'For clarity, let’s see these aphorisms before we begin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Beautiful is better than ugly
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Beauty is subjective, of course, but there are still some style rules that
    are good to adhere to. Rules such as (from PEP 8):'
  prefs: []
  type: TYPE_NORMAL
- en: Indent using spaces instead of tabs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Line length limits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each statement on a separate line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each import on a separate line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When in doubt, always keep in mind that consistency is more important than fixed
    rules. If a project prefers to use tabs instead of spaces, or vice versa, it’s
    better to keep the tabs/spaces like that than to potentially break existing code
    (and revision control history) by replacing the tabs/spaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'In short, instead of hard-to-read code like this, which shows all odd numbers
    below 10:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'I would prefer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: It is simpler, easier to read, and a bit more beautiful!
  prefs: []
  type: TYPE_NORMAL
- en: These examples are an early introduction to generators. Generators will be discussed
    more thoroughly in *Chapter 7*, *Generators and Coroutines – Infinity, One Step
    at a Time*.
  prefs: []
  type: TYPE_NORMAL
- en: Explicit is better than implicit
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Imports, arguments, and variable names are just some of the many cases where
    explicit code is far easier to read at the cost of a little bit more effort and/or
    verbosity when writing the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of how this can go wrong:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Where does `wait` come from, in this case? You might say that it’s obvious—it
    comes from `os`. But you would be wrong, sometimes. On Windows, the `os` module
    doesn’t have a `wait` function, so it would be `asyncio.wait` instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'It could be even worse: many editors and code clean-up tools have a sort-imports
    feature. If the sort order of your import changes, the behavior of your project
    will change.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The immediate fix is simple enough:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'With this method, we have at least a way to find out where `wait` came from.
    But I would recommend going a step further and importing by module instead, so
    the executing code immediately shows which function is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The same can be said for `*args` and `**kwargs`. While they are very useful,
    they can make the usage of your functions and classes a lot less obvious:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Without looking at the code within the function, you cannot know what to pass
    as `**kwargs` or what `*args` does. A reasonable function name can help here,
    of course:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Documentation can obviously help for cases like these, and I use `*args` and
    `**kwargs` very often, but it is definitely a good idea to keep at least the most
    common arguments explicit. Even when it requires you to repeat the arguments for
    a parent class, it just makes the code much clearer. When refactoring the parent
    class in the future, you’ll know whether there are subclasses that still use some
    parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Simple is better than complex
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: ”Simple is better than complex. Complex is better than complicated.”
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Keeping things simple is often much harder than you would expect. Complexity
    has a tendency to creep up on you. You start with a beautiful little script and,
    before you know it, feature creep has turned it into a complex (or worse, complicated)
    mess:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: At first glance, this code might look a bit difficult. If you’re familiar with
    the sieve of Eratosthenes however, you’ll quickly realize what is happening. With
    just a little bit of effort, you will see that the algorithm isn’t all that complicated
    but uses a few tricks to reduce the necessary computations.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do better, however; let’s see a different example featuring the Python
    3.8 assignment operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This algorithm looks a bit less intimidating, but I wouldn’t call it immediately
    obvious at first glance. The `prime := next(numbers)` is the Python 3.8 version
    of setting a variable and immediately returning it in the same statement. The
    `prime.__rmod__` does a modulo with the given number to sieve in a similar fashion
    to the previous example.
  prefs: []
  type: TYPE_NORMAL
- en: 'What might be confusing, however, is that the `numbers` variable is being reassigned
    with added filters on each iteration. Let’s see a better solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now we’ve come to one of the most obvious methods of generating prime numbers.
    The `is_prime` function is really simple and immediately shows what `is_prime`
    is doing. And the `primes_simple` function is nothing more than a loop with a
    filter.
  prefs: []
  type: TYPE_NORMAL
- en: Unless you have a really good reason to go for the complicated approach, try
    to keep your code as simple as you can. You (and perhaps someone else) will be
    grateful when reading your code in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Flat is better than nested
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Nested code quickly becomes unreadable and hard to understand. There are no
    strict rules here, but generally, when you have multiple levels of nested loops,
    it is time to refactor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just take a look at the following example, which prints a list of two-dimensional
    matrices. While nothing specific is wrong here, splitting it into a few more functions
    might make it easier to understand the purpose and also make it easier to test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the flatter version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This example might be a bit contrived, but the idea is sound. Deeply nested
    code can easily become very unreadable and splitting code into multiple lines
    or even functions can help readability a lot.
  prefs: []
  type: TYPE_NORMAL
- en: Sparse is better than dense
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Whitespace is generally a good thing. Yes, it will make your files longer and
    your code will take up more space, but it can help a lot with readability if you
    split your code logically. Let’s take an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'By looking at the output and the code, you might be able to guess that this
    is the factorial function. But its workings are probably not immediately obvious.
    Let’s try rewriting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: By using a proper name, expanding the `if` statement, and explicitly returning
    `1`, it is suddenly much more obvious what is happening.
  prefs: []
  type: TYPE_NORMAL
- en: Readability counts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Shorter does not always mean easier to read. Let’s take the Fibonacci numbers.
    There are many ways of writing this code, many of them hard to read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Even though there is a kind of beauty and elegance in the solutions, they are
    not readable. With just a few minor changes, we can change these functions to
    more readable functions that function similarly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Practicality beats purity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: ”Special cases aren’t special enough to break the rules. Although practicality
    beats purity.”
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Breaking the rules can be tempting at times, but it’s a slippery slope. If your
    quick fix is going to break the rules, you should really try to refactor it immediately.
    Chances are that you won’t have the time to fix it later and will regret it.
  prefs: []
  type: TYPE_NORMAL
- en: No need to go overboard, though. If the solution is good enough and refactoring
    would be much more work, then choosing the working method might be better. Even
    though all of these examples pertain to imports, this guideline applies to nearly
    all cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'To prevent long lines, imports can be made shorter by using a few methods,
    adding a backslash, adding parentheses, or just shortening the imports. I will
    illustrate some options next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This case can easily be avoided by using parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Or my personal preference, importing modules instead of the separate objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: But what about really long imports?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In that case, I would recommend using parentheses. If you need to split the
    imports across multiple lines, I would recommend one line per import for readability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Errors should never pass silently
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: ”Errors should never pass silently. Unless explicitly silenced.”
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Handling errors the right way is really difficult and there is no one method
    that works for every situation. There are, however, better and worse methods to
    catch errors.
  prefs: []
  type: TYPE_NORMAL
- en: Bare or too-broad exception catching can be a quick way to make your life a
    bit more difficult in the case of bugs. Not passing exception info at all can
    make you (or some other person working on the code) wonder for ages about what
    is happening.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate a bare exception, the worst option is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'A much better solution is to explicitly capture only the error you need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, if you really need to capture all exceptions, make sure to log
    them properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'When using multiple lines inside a `try` block, the issue of tracing bugs is
    aggravated even further because there is even more code that could be responsible
    for the hidden exception. The tracing of bugs also becomes much more difficult
    when the `except` is accidently capturing exceptions from functions a few levels
    deep. For example, consider the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: If an exception is raised, which line is causing it? With silent catching of
    the error, there is no way to know without running the code in a debugger. The
    exception could even be caused a few levels deeper in the code if, instead of
    `int()`, you are using a more complex function.
  prefs: []
  type: TYPE_NORMAL
- en: If you are testing for a specific exception in a specific block of code, the
    safer method is using the `else` in the `try`/`except`. The `else` is only executed
    if there was no exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate the full strength of the `try`/`except:`, here is an example
    of all variants including the `else`, `finally`, and `BaseException`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In the face of ambiguity, refuse the temptation to guess
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While guesses will work in many cases, they can bite you if you’re not careful.
    As already demonstrated in the *Explicit is better than implicit* section, when
    you have a few `from ... import *`, you cannot always be certain which module
    is providing you with the variable you were expecting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Clear and unambiguous code generates fewer bugs so it’s always a good idea
    to think about what happens when someone else reads your code. A prime example
    of ambiguity is function calling. Take, for example, the following two function
    calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: These two calls have the exact same result. However, it’s obvious in the second
    call that the `-1` is configuring the buffer. You probably know the first two
    arguments of `open()` by heart but the others are less common.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless, without seeing `help(open)` or viewing the documentation in another
    manner, it’s impossible to say whether the two are identical.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that I don’t think you should use keyword arguments in all cases, but
    if there are many arguments involved and/or hard-to-identify parameters (such
    as numbers), it can be a good idea. A good alternative is using good variable
    names, which make the function call a lot more obvious:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: One obvious way to do it
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: “There should be one—and preferably only one—obvious way to do it. Although
    that way may not be obvious at first unless you’re Dutch.”
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In general, after thinking about a difficult problem for a while, you will find
    that there is one solution that is clearly preferable over the alternatives. There
    are times where this is not the case, however, and in such instances, it can be
    useful if you’re Dutch. The joke here is that Guido van Rossum, the original author
    of Python, is Dutch (as am I) and that only Guido knows the obvious way in some
    cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other joke is that the Perl programming language slogan is the opposite:
    “There’s more than one way to do it.”'
  prefs: []
  type: TYPE_NORMAL
- en: Now is better than never
  prefs: []
  type: TYPE_NORMAL
- en: “Now is better than never. Although never is often better than *right* now.”
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'It’s better to fix a problem right now than push it into the future. There
    are cases, however, where fixing it right away is not an option. In those cases,
    a good alternative can be to mark a function as deprecated instead so that there
    is no chance of accidentally forgetting the problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Hard to explain, easy to explain
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: “If the implementation is hard to explain, it’s a bad idea. If the implementation
    is easy to explain, it may be a good idea.”
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: As always, keep things as simple as you can. While complicated code can be nice
    to test with, it is more prone to bugs. The simpler you can keep things, the better.
  prefs: []
  type: TYPE_NORMAL
- en: Namespaces are one honking great idea
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: “Namespaces are one honking great idea—let’s do more of those!”
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Namespaces can make code a lot clearer to use. Naming them properly makes it
    even better. For example, assume the `import` isn’t on your screen in a larger
    file. What does the `loads` line do?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s take the version with the namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Now it is obvious that `loads()` is the `json` loader and not any other type
    of loader.
  prefs: []
  type: TYPE_NORMAL
- en: 'Namespace shortcuts are still useful, though. Let’s look at the `User` class
    in Django, which is used in nearly every Django project. The `User` class is stored
    in `django.contrib.auth.models.User` by default (can be overridden). Many projects
    use the object in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'While this is fairly clear, projects might be using multiple classes named
    `User`, which obscures the import. Also, it might make someone think that the
    `User` class is local to the current class. Doing the following instead lets people
    know that it is in a different module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This quickly clashes with other models’ imports, though, so I personally use
    the following instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Or the shorter version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you should have some idea of what the Pythonic ideology is about—creating
    code that is:'
  prefs: []
  type: TYPE_NORMAL
- en: Beautiful
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Readable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unambiguous
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explicit enough
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not completely void of whitespace
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So let’s move on to some more examples of how to create beautiful, readable,
    and simple code using the Python style guide.
  prefs: []
  type: TYPE_NORMAL
- en: Explaining PEP 8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The previous sections have already shown a lot of examples of using PEP 20 as
    a reference, but there are a few other important guidelines to note as well. The
    PEP 8 style guide specifies the standard Python coding conventions.
  prefs: []
  type: TYPE_NORMAL
- en: Simply following the PEP 8 standard doesn’t make your code Pythonic, though,
    but it is most certainly a good start. Which style you use is really not that
    much of a concern as long as you are consistent. The only thing worse than not
    using a proper style guide is being inconsistent with it.
  prefs: []
  type: TYPE_NORMAL
- en: Duck typing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Duck typing is a method of handling variables by behavior. To quote Alex Martelli
    (one of my Python heroes, also nicknamed the MartelliBot by many):'
  prefs: []
  type: TYPE_NORMAL
- en: '“Don’t check whether it IS-a duck: check whether it QUACKS-like-a duck, WALKS-like-a
    duck, etc, etc, depending on exactly what subset of duck-like behavior you need
    to play your language-games with. If the argument fails this specific-ducklyhood-subset-test,
    then you can shrug, ask “why a duck?”'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In many cases, when people make a comparison such as `if spam != '':`, they
    are actually just looking for anything that is considered a true value. While
    you can compare the value to the string value `''`, you generally don’t have to
    make it so specific. In many cases, simply doing `if spam:` is more than enough
    and actually functions better.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following lines of code use the value of `timestamp` to generate
    a filename:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the variable is named `timestamp`, you might be tempted to check whether
    it is actually a `date` or `datetime` object, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: While this is not inherently wrong, comparing types is considered a bad practice
    in Python, as there is often no need.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, the commonly used style is **EAFP** (**easier to ask for forgiveness
    than permission**: [https://docs.python.org/3/glossary.html#term-eafp](https://docs.python.org/3/glossary.html#term-eafp)),
    which assumes no errors but catches them if needed. Within the Python interpreter,
    a `try`/`except` block is extremely efficient if no exception is raised. Actually
    catching an exception is expensive, however, so this approach is mainly recommended
    when you don’t expect the `try` to fail often.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The opposite of EAFP is **LBYL** (**look before you leap**: [https://docs.python.org/3/glossary.html#term-lbyl](https://docs.python.org/3/glossary.html#term-lbyl)),
    which tests for pre-conditions before other calls or lookups are made. The notable
    downside of this method is the potential for race conditions in multi-threaded
    environments. While you are checking for the existence of a key in a `dict`, another
    thread may have removed it already.'
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s why in Python, duck typing is often preferred. Just test the variable
    for the features you need and don’t worry about the actual type. To illustrate
    how little difference this can make to the end result, see the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Versus a string instead of a `date`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the result is identical.
  prefs: []
  type: TYPE_NORMAL
- en: The same goes for converting a number to a float or an integer; instead of enforcing
    a certain type, just require certain features. Need something that can pass as
    a number? Just try to convert to `int` or `float`. Need a `file` object? Why not
    just check whether there is a `read` method with `hasattr`?
  prefs: []
  type: TYPE_NORMAL
- en: Differences between value and identity comparisons
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are many methods of comparing objects in Python: greater than, bitwise
    operators, equal, etc., but there is one comparator that is special: the identity
    comparison operator. Instead of using `if spam == eggs`, you would use `if spam
    is eggs`. The first compares the value and the second compares the identity or
    **memory address**. Because it only compares the memory address, it’s one of the
    lightest and strictest lookups you can get. Whereas a value check needs to make
    sure that the types are comparable and perhaps check the sub-values, the identity
    check just checks whether the unique identifier is the same.'
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve ever written Java, you should be familiar with this principle. In
    Java, a regular string comparison (`spam == eggs`) will use the identity instead
    of the value. To compare the value, you need to use `spam.equals(eggs)` to get
    the correct results.
  prefs: []
  type: TYPE_NORMAL
- en: 'These comparisons are recommended to be used when the identity of the object
    is expected to be constant. One obvious example of this is a comparison with `True`,
    `False`, or `None`. To demonstrate this behavior, let’s look at values that evaluate
    to `True` or `False` when comparing by value, but are actually different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, you need to be careful with `if` statements and `None` values, which
    is a common pattern with default function arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The second one indeed needed the default argument, but the first one had an
    actual value that should have been used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Now we actually get the value that we passed along because we used an identity
    instead of a value check for `arg`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few gotchas with the identities, though. Let’s look at an example
    that doesn’t make any sense:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: While the values are the same, the identities are different. The catch is that
    Python keeps an internal array of integer objects for all integers between `-5`
    and `256`; that’s why it works for `256` but not for `257`.
  prefs: []
  type: TYPE_NORMAL
- en: To look at what Python is actually doing internally with the `is` operator,
    you can use the `id` function. When executing `if spam is eggs`, Python will execute
    the equivalent of `if id(spam) == id(eggs)` internally and `id()` (at least for
    CPython) returns the memory address.
  prefs: []
  type: TYPE_NORMAL
- en: Loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Coming from other languages, one might be tempted to use `for` loops or `while`
    loops with counters to process the items of a `list`, `tuple`, `str`, and so on.
    While valid, it is more complex than needed. For example, consider this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Within Python, there is no need to build a custom loop: you can simply loop
    the iterable object instead. Although enumerating including a counter is easily
    possible too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be written even shorter, of course (albeit not 100% identically, since
    we’re not using `print`), but I wouldn’t recommend that for the sake of readability
    in most cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The last option might be clear to some but not all. A common recommendation
    is to limit the usage of `list`/`dict`/`set` comprehensions and `map`/`filter`
    statements to cases where the entire statement fits on a single line.
  prefs: []
  type: TYPE_NORMAL
- en: Maximum line length
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many Python programmers think 79 characters is too constricting and just keep
    the lines longer. While I am not going to argue for 79 characters specifically,
    setting a low limit is a good idea so you can easily keep multiple editors side
    by side. I often have four Python files open next to each other. If the line width
    were more than 79 characters, that simply wouldn’t fit.
  prefs: []
  type: TYPE_NORMAL
- en: 'PEP 8 tells us to use backslashes in cases where lines get too long. While
    I agree that backslashes are preferable over long lines, I still think they should
    be avoided, if possible, since they easily generate syntax errors when manipulating
    code by copying/pasting and rearranging. Here’s an example from PEP 8:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of using backslashes, I would reformat the code by introducing extra
    variables so all lines are easy to read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Or in this specific case of filenames, by using `pathlib`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: This is not always an option, of course, but it’s a good consideration to keep
    the code short and readable. It actually provides a bonus of adding more information
    to the code. If, instead of `filename_1`, you use a name that conveys the goal
    of the filename, it immediately becomes clearer what you are trying to do.
  prefs: []
  type: TYPE_NORMAL
- en: Verifying code quality, pep8, pyflakes, and more
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many tools for checking code quality and style in Python. The options
    range from `pycodestyle` (previously named `pep8`) for checking rules pertaining
    to PEP 8, to tools such as `flake8`, which bundles a lot of tools and can help
    refactor code and track down bugs in code that appears to work.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go into more detail.
  prefs: []
  type: TYPE_NORMAL
- en: pycodestyle/pep8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `pycodestyle` package (previously named `pep8`) is the default code style
    checker to start with. The `pycodestyle` checker attempts to validate many of
    the rules suggested in PEP 8 that are considered to be the standard by the community.
    It doesn’t check everything that is in the PEP 8 standard, but it goes a long
    way and is still updated regularly to add new checks. Some of the most important
    things checked by `pycodestyle` are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Indentation: While Python will not check how many spaces you use to indent,
    it does not help with the readability of your code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Missing whitespace, such as `spam=123`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Too much whitespace, such as `def eggs(spam = 123):`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Too many or too few blank lines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Too long lines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Syntax and indentation errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Incorrect and/or superfluous comparisons (`not in`, `is not`, `if spam is True`,
    and type comparisons without `isinstance`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If some of the specific rules are not to your liking, you can easily tweak them
    to fit your purpose. Beyond that, the tool is not too opinionated, which makes
    it an ideal starting point for any Python project.
  prefs: []
  type: TYPE_NORMAL
- en: 'An honorable mention goes out to the `black` project, which is a Python formatter
    that automatically formats your code to largely adhere to the PEP 8 style. The
    name `black` stems from Henry Ford’s quote: “Any customer can have a car painted
    any color that he wants so long as it is black.”'
  prefs: []
  type: TYPE_NORMAL
- en: 'That immediately shows the downside of `black`: it offers very little in the
    way of customization. If you don’t like one of the rules, you are most likely
    out of luck.'
  prefs: []
  type: TYPE_NORMAL
- en: pyflakes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `pyflakes` checker is meant to detect errors and potential bugs in your
    code by parsing (not importing) the code. This makes it ideal for editor integration,
    but it can also be used to warn you about potential issues in your code beyond
    that. It will warn you about:'
  prefs: []
  type: TYPE_NORMAL
- en: Unused imports
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wildcard imports (`from module import *`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Incorrect `__future__` imports (after other imports)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'More importantly, it warns you about potential bugs, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Redefinitions of names that were imported
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usage of undefined variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Referencing variables before assignment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Duplicate argument names
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unused local variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: pep8-naming
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last bit of PEP 8 is covered by the `pep8-naming` package. It makes sure
    that your naming is close to the standard dictated by PEP 8:'
  prefs: []
  type: TYPE_NORMAL
- en: Class names as `CapWord`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function, variable, and argument names all in lowercase
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constants as full uppercase and being treated as constants
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first argument of instance methods and class methods as `self` and `cls`,
    respectively
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: McCabe
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Lastly, there is the McCabe complexity. It checks the complexity of code by
    looking at the **Abstract Syntax Tree** (**AST**), which Python builds from the
    source code internally. It finds out how many lines, levels, and statements are
    there and warns you if your code has more complexity than a preconfigured threshold.
    Generally, you will use McCabe through `flake8`, but a manual call is possible
    as well. Using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'McCabe will give us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: At first, when you look at the `1` generated by `noop`, you might think `mccabe`
    counts the lines of code. Upon further inspection, you can see this isn’t the
    case. Having multiple `noop` operators does not increase the count and nor do
    the `print` statements in the `print_cube` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `mccabe` tool checks the cyclomatic complexity of code. In a nutshell,
    this means that it counts the number of possible execution paths. Code without
    any control flow statements such as `if`/`for`/`while` counts as 1, as you can
    see in the `noop` function. A simple `if` or `if`/`else` results in two options:
    one where the `if` statement is `True` and one where the `if` statement is `False`.
    If there is a nested `if` or an `elif`, this would increase further. Loops count
    as 2 since there is the flow of going inside the loop if there are items, and
    not going into the loop if there are no items.'
  prefs: []
  type: TYPE_NORMAL
- en: The warning threshold for `mccabe` is set to 10 by default, but is configurable.
    If your code actually has a score of more than 10, it is time for some refactoring.
    Remember the advice from PEP 20.
  prefs: []
  type: TYPE_NORMAL
- en: Mypy
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Mypy is a tool used to check the variable types within your code. While specifying
    fixed types goes against duck typing, there are certainly cases where this is
    useful and where it will protect you from bugs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Taking the following code, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The `mypy` command will tell us we’ve made a mistake:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that this syntax depends on the type hinting introduced in Python 3.5\.
    For older Python versions, you can use comments for type hints instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Even if you’re not using code hinting in your own code, this can still be useful
    to check whether your calls to external libraries are correct. If the arguments
    for a function of an external library changed with an update, this can quickly
    tell you something is wrong at the location of the mistake instead of having to
    trace a bug throughout your code.
  prefs: []
  type: TYPE_NORMAL
- en: flake8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To run all of these tests combined, you can use `flake8`, a tool that runs `pycodestyle`,
    `pyflakes`, and `mccabe` by default. After running these commands, `flake8` combines
    their outputs into a single report. Some of the warnings generated by `flake8`
    might not fit your taste, so each and every one of the checks can be disabled,
    both per file and for the entire project if needed. For example, I personally
    disable `W391` for all my projects, which warns you about blank lines at the end
    of a file.
  prefs: []
  type: TYPE_NORMAL
- en: This is something I find useful while working on code so that I can easily jump
    to the end of the file and start writing code instead of having to append a few
    lines first.
  prefs: []
  type: TYPE_NORMAL
- en: There are also many plugins available to make `flake8` even more powerful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some example plugins are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pep8-naming`: Tests PEP naming conventions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`flake8-docstrings`: Tests whether docstrings follow the PEP 257, NumPy, or
    Google convention. More about these conventions will be in the chapter about documentation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`flake8-bugbear`: Finds likely bugs and design problems in your code, such
    as bare excepts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`flake8-mypy`: Tests whether the types of values are consistent with the declared
    types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In general, before committing your code and/or putting it online, just run `flake8`
    from your source directory to check everything recursively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a demonstration with some poorly formatted code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'It results in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Recent additions to the Python syntax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Python syntax has remained largely unchanged in the last decade, but we
    have seen a few additions, such as the f-strings, type hinting, and async functions,
    of course. We already covered f-strings at the beginning of this chapter, and
    the other two are covered by *Chapter 9* and *Chapter 13*, respectively, but there
    have a been a few other recent additions to the Python syntax that you might have
    missed. Additionally, in *Chapter 4* you will see the dictionary merge operators
    added in Python 3.9.
  prefs: []
  type: TYPE_NORMAL
- en: 'PEP 572: Assignment expressions/the walrus operator'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We already covered this briefly earlier in this chapter, but since Python 3.8,
    we have assignment expressions. If you have experience with C or C++, you have
    most likely seen something like this before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Within C, this opens a file using `fopen()`, stores the result of `fopen()`
    in `fh`, and checks whether the result of the `fopen()` call is `NULL`. Until
    Python 3.8, we always had to split these two operations into an assignment and
    an `if` statement, assuming we also had `fopen()` and `NULL` available in our
    Python code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Since Python 3.8, we can use assignment expressions to do this in a single
    line, similar to C:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'With the := operator you can assign and check the result in one operation.
    This can be useful when reading user input, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: This operator is often called the walrus operator because it looks slightly
    like the eyes and tusks of a walrus (:=).
  prefs: []
  type: TYPE_NORMAL
- en: 'PEP 634: Structural pattern matching, the switch statement'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many programmers who are new to Python wonder why it does not have a switch
    statement like most common programming languages. Often the lack of a switch statement
    has been addressed with dictionary lookups or, simply, a chain of `if`/`elif`/`elif`/`elif`/`else`
    statements. While those solutions work fine, I personally feel that at times my
    code could have been prettier and more readable with a switch statement.
  prefs: []
  type: TYPE_NORMAL
- en: Since Python 3.10, we finally have a feature that is very comparable to a switch
    statement but so much more powerful. As is the case with the Python ternary operator
    (i.e. `true_value if condition else false_value`), the syntax is far from a literal
    copy of other languages. In this case, especially, this is for the better. With
    most programming languages, it can be really easy to forget the `break` statement
    in a switch, which can cause unintended side effects.
  prefs: []
  type: TYPE_NORMAL
- en: At a glance, the Python implementation appears much simpler in syntax and features.
    Without the `break` statement, you might wonder how you can match multiple patterns
    in a single go. Stay tuned and find out! The pattern matching feature is *very
    powerful* and offers many more features than you might expect.
  prefs: []
  type: TYPE_NORMAL
- en: The basic match statement
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First, let’s look at a basic example. This one offers little benefit but can
    still be easier to read than a regular `if`/`elif`/`else` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Since we have both the `if` and the `match` statement here, you can easily compare
    them. In this case, I would go for the `if` statement, but the main advantage
    of not having to repeat the `some_variable ==` part can still be useful.
  prefs: []
  type: TYPE_NORMAL
- en: The `_` is the special wild card case for the match statement. It matches any
    value, so it can be seen as the equivalent of the `else` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Storing the fallback as a variable
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A slightly more useful example is to automatically store the result when it
    doesn’t match. The previous example uses an underscore (`_`), which is not actually
    stored in `_` because it is a special case, but if we name the variable differently,
    we can store the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: In this case we store the `else` case in the `other` variable. Note that you
    cannot use `_` and a variable name at the same time since they do the same thing,
    which would be useless.
  prefs: []
  type: TYPE_NORMAL
- en: Matching from variables
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You saw that a case such as `case other:` will store the result in `other`
    instead of comparing it with the value of `other`, so you might be wondering if
    we can do the equivalent of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The answer is that we can, with a caveat. Since any bare `case variable:` will
    result in storing into a variable, we need to have something that does not match
    that pattern. The common way to work around this limitation is by introducing
    a dot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: As long as it cannot be interpreted as a variable name, this will work for you.
    When comparing with a local variable, an `if` statement can always be used as
    well, of course.
  prefs: []
  type: TYPE_NORMAL
- en: Matching multiple values in a single case
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you’re familiar with the `switch` statement in many other programming languages,
    you might be wondering whether you can have multiple `case` statements before
    you `break`, like this, for example (C++):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'This roughly means that if `variable` is either equal to `LEFT` or `RIGHT`,
    print the `"Going horizontal"` line and `break`. Since the Python `match` statement
    does not have a `break`, how can we match something like this? Well, some syntax
    was introduced specifically for that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, using the `|` operator (which is also used for bitwise operations),
    you can test for multiple values at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Matching values with guards or extra conditions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There are times when you want a more advanced comparison such as `if variable
    > value:`. Luckily, even that is possible with the `match` statement using a feature
    called guards:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that this uses the variable name that I just introduced, but it’s a regular
    Python expression, so you could also compare something else. However, you always
    need to have the variable name before the `if`. This will *not* work: `case if
    ...`.'
  prefs: []
  type: TYPE_NORMAL
- en: Matching lists, tuples, and other sequences
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you are familiar with `tuple` unpacking, you can probably guess how sequence
    matching works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The first case explicitly matches both of the given values, which is identical
    to `if value == (0, 1):`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second case explicitly matches `0` for the first value, but leaves the
    second value as a variable and stores it in `y`. Effectively this comes down to
    `if value[0] == 0: y = value[1]`.'
  prefs: []
  type: TYPE_NORMAL
- en: The last case stores a variable for both the `x` and `y` values and will match
    any sequence with exactly two items.
  prefs: []
  type: TYPE_NORMAL
- en: Matching sequence patterns
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you thought the previous example with the unpacking of the variables was
    useful, you will love this section. One of the really powerful features of the
    `match` statement is matching based on patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s assume we have a function that takes up to three parameters, `host`,
    `port`, and `protocol`. For `port` and `protocol`, we can assume `443` and `https`,
    respectively, so that only leaves the `hostname` as a required parameter. How
    can we match this so one, two, three, or more parameters are all supported and
    work correctly? Let’s find out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the `match` statement also handles different length sequences,
    which is a very useful tool to have. You could do this with `if` statements as
    well, but I’ve never found a way to handle that in a really pretty fashion. Naturally
    you could still combine this with the earlier examples, so you could have a `case`
    such as: `case (hostname, port, ''http''):` if you want to invoke specific behavior.
    You can also apply `*variable` to capture all extra variables. The `*` matches
    0 or more extra items in the sequence.'
  prefs: []
  type: TYPE_NORMAL
- en: Capturing sub-patterns
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In addition to specifying a variable name to save all values into, you can
    also store explicit value matches:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: In this case we explicitly match `0` as the first part of `value`, and `1` or
    `2` as the second part of `value`. And we store those in the variables `x` and
    `y`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note here that within the context of a `case` statement the
    `|` operator will always work as a or for the `case`, instead of a bitwise or
    for the variables/values. Normally `1 | 2` would result in `3` because in binary
    `1 = 0001`, `2 = 0010` , and the combination of those is `3 = 0011`.
  prefs: []
  type: TYPE_NORMAL
- en: Matching dictionaries and other mappings
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Naturally it is also possible to match mappings (such as `dict`) by key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Note that `match` only checks for the given keys and values and does not care
    about extra keys in the mapping. This is why the first case matches both of the
    first two items.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the preceding example, matching happens sequentially and it
    will stop at the first match, not the best match. The second case is never reached
    in this scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Matching using isinstance and attributes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you thought the previous examples of the `match` statement were impressive,
    get ready to be completely amazed. The way the `match` statement can match instances
    including properties is amazingly powerful and can be incredibly useful. Just
    look at the following example and try to understand what is happening:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: While I will admit that the syntax is slightly confusing and, dare I say it,
    unPythonic, it is so useful that it still makes sense.
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, we will look at the `case Person() as person:`. We’re discussing this
    first because it is important to understand what is happening here before we continue
    with the other examples. This line is effectively identical to `if isinstance(value,
    Person):`. It does *not* actually instantiate the `Person` class at this point,
    which is a bit confusing.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, the `case Person(name='Rick')` matches the instance type `Person`
    and it requires the instance to have an attribute `name` with value `Rick`.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, the `case Person(occupation='Programmer')` matches `value` to be a `Person`
    instance and have an attribute called `occupation` with the value `Programmer`.
    Since that attribute does not exist, it ignores that issue silently.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that this also works for built-in types and supports nesting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: We have covered several examples of how the new pattern matching feature works,
    but you could think of many more. Since all parts can be nested, the possibilities
    really are endless. It might not be the perfect solution for everything, and the
    syntax might feel a little odd, but it is such a powerful solution that I would
    recommend any Python programmer learns it by heart.
  prefs: []
  type: TYPE_NORMAL
- en: Common pitfalls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python is a language meant to be clear and readable without any ambiguities
    and unexpected behaviors. Unfortunately, these goals are not achievable in all
    cases, and that is why Python does have a few corner cases where it might do something
    different than what you were expecting.
  prefs: []
  type: TYPE_NORMAL
- en: This section will show you some issues that you might encounter when writing
    Python code.
  prefs: []
  type: TYPE_NORMAL
- en: Scope matters!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a few cases in Python where you might not be using the scope that
    you are actually expecting. Some examples are when declaring a class and with
    function arguments, but the most annoying one is accidentally trying to overwrite
    a `global` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Global variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A common problem when accessing variables from the `global` scope is that setting
    a variable makes it local, even when accessing the `global` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'This works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'But the following does not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: The problem is that `g += 1` actually translates to `g = g + 1`, and anything
    containing `g =` makes the variable local to your scope. Since the local variable
    is being assigned at that point, it has no value yet and you are trying to use
    it.
  prefs: []
  type: TYPE_NORMAL
- en: For these cases, there is the `global` statement, although it is generally recommended
    to avoid writing to `global` variables altogether because it can make your life
    a lot more difficult while debugging. Modern editors can help a lot to track who
    or what is writing to your `global` variables, but restructuring your code so
    it purposefully passes and modifies values in a clear path can help you to avoid
    many bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Pass by reference with mutable variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Within Python, variables are passed by reference. This means that when you do
    something like `x = y`, both `x` and `y` will point to the same variable. When
    you change the value (not the object) of either `x` or `y`, the other will change
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: Since most variable types such as strings, integers, floats, and tuples are
    immutable, this is not a problem. Doing `x = 123` won’t affect `y` since we aren’t
    changing the value of `x,` but we are replacing `x` with a new object that has
    the value `123`.
  prefs: []
  type: TYPE_NORMAL
- en: 'With mutable variables, however, we can change the value of the object. Let’s
    illustrate this behavior and how to work around it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Unless you explicitly copy the variable as we did with `z`, your new variable
    will point to the same object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you might be wondering whether `copy()` always works. As you might suspect,
    it doesn’t. The `copy()` function only copies the object itself, not the values
    within the object. For that we have `deepcopy()`, which even handles recursion
    safely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Mutable function default arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While the issues with mutable arguments can be easily avoided and seen in most
    cases, the scenario of default arguments for functions is a lot less obvious:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Note that this is the case for `dict`, `list`, `set`, and several of the types
    in `collections`. Additionally, the classes you define yourself are mutable by
    default.
  prefs: []
  type: TYPE_NORMAL
- en: 'To work around this issue, you could consider changing the function to the
    following instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Note that we had to use `if list_ is None` here. If we had done `if not list_`
    instead, it would have ignored the given `list_` if an empty `list` was passed.
  prefs: []
  type: TYPE_NORMAL
- en: Class properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The problem of mutable variables also occurs when defining classes. It is very
    easy to mix class attributes and instance attributes. This can be confusing, especially
    when you are coming from other languages such as C#. Let’s illustrate it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: As with the function arguments, the list and dictionaries are shared. So if
    you want a mutable property for a class that isn’t shared between all instances,
    you will need to define it from within the `__init__` or any other instance method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another important thing to note when dealing with classes is that a class property
    will be inherited, and that’s where things might prove to be confusing. When inheriting,
    the original properties will stay references (unless overwritten) to the original
    values, even in subclasses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: While this is to be expected due to inheritance, someone else using the class
    might not expect the variable to change in the meantime. After all, we modified
    `Parent`, not `Child`.
  prefs: []
  type: TYPE_NORMAL
- en: There are two easy ways to prevent this. It is obviously possible to simply
    set the properties for every class separately. But the better solution is never
    to modify class properties outside of the class definition. It’s easy to forget
    that the property will change in multiple locations, and if it has to be modifiable
    anyway, it’s usually better to put it in an instance variable instead.
  prefs: []
  type: TYPE_NORMAL
- en: Overwriting and/or creating extra built-ins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While it can be useful in some cases, generally you will want to avoid overwriting
    global functions. The PEP 8 convention for naming your functions—similar to built-in
    statements, functions, and variables—is to use a trailing underscore.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, do not use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'For lists and such, this is just a good convention. For statements such as
    `from`, `import`, and `with`, it’s a requirement. Forgetting about this can lead
    to very confusing errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'If you actually want to define a built-in that is available everywhere without
    requiring an import, that is possible. For debugging purposes, I’ve been known
    to add this code to a project while developing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: This is much too hacky for production code, but it is still useful when working
    on a large project where you need print statements to debug. Alternative (and
    better) debugging solutions can be found in *Chapter 11*, *Debugging – Solving
    the Bugs*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The usage is quite simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Modifying while iterating
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At one point or another, you will run into this problem: while iterating through
    some mutable objects such as `dict` and `set`, you cannot modify them. All of
    these result in a `RuntimeError` telling you that you cannot modify the object
    during iteration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'For a list, it does work, but can result in very strange results, so it should
    definitely be avoided as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'While these issues can be avoided by copying the collections before usage,
    in many cases you are doing something wrong if you run into this issue. If manipulation
    is actually needed, building a new collection is often the easier way to go because
    the code will look more obvious. Whenever someone looks at code like this in the
    future, they might try to refactor it by removing the `list()` since it looks
    futile at first glance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: Catching and storing exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When catching and storing exceptions in Python, you must keep in mind that
    for performance reasons, the stored exception is local to the `except` block.
    The result is that you need to explicitly store the exception in a *different*
    variable. Simply declaring the variable before the `try`/`except` block does not
    work and will make your variable disappear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Storing the result in a new variable does work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: As you can probably see already, this code does have a bug now. If we don’t
    end up in an exception, `new_exception` will not be defined yet. We will either
    need to add an `else` to the `try`/`except` or, better yet, pre-declare the variable
    before the `try`/`except`.
  prefs: []
  type: TYPE_NORMAL
- en: We really need to save it explicitly because Python 3 automatically deletes
    anything saved with `as variable` at the end of the `except` statements. The reason
    for this is that exceptions in Python 3 contain a `__traceback__` attribute. Having
    this attribute makes it much more difficult for the garbage collector to detect
    which memory should be freed as it introduces a recursive self-referencing cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, this is `exception -> traceback -> exception -> traceback ...`
    .
  prefs: []
  type: TYPE_NORMAL
- en: This does mean that you should keep in mind that storing these exceptions can
    introduce memory leaks into your program.
  prefs: []
  type: TYPE_NORMAL
- en: The Python garbage collector is smart enough to understand that the variables
    are not visible anymore and will delete the variable eventually, but it can take
    a lot more time because it is a far more complicated garbage collection procedure.
    How the garbage collection actually works is covered in *Chapter 12*, *Performance
    – Tracking and Reducing Your Memory and CPU Usage*.
  prefs: []
  type: TYPE_NORMAL
- en: Late binding and closures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Closures are a method of implementing local scopes in code. They make it possible
    to locally define variables without overriding variables in the parent (or global)
    scope and hide the variables from the outside scope later. The problem with closures
    in Python is that Python tries to bind its variables as late as possible for performance
    reasons. While generally useful, it does have some unexpected side effects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: You were probably expecting `0, 1, 2` instead. Due to late binding, however,
    all functions get the last value of `i` instead, which is `2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'What should we do instead? As with the cases in earlier paragraphs, the variable
    needs to be made local. One option is to force immediate binding by currying the
    function with `partial`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: A better solution would be to avoid binding problems altogether by not introducing
    extra scopes (the `lambda`) that use external variables. If `i` is specified as
    an argument to `lambda`, this will not be a problem.
  prefs: []
  type: TYPE_NORMAL
- en: Circular imports
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even though Python is fairly tolerant of circular imports, there are some cases
    where you will get errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s assume we have two files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`T_28_circular_imports_a.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '`T_28_circular_imports_b.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Running either of these files results in a circular import error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: There are several ways to work around this problem. The simplest solution is
    to move the `import` statement so the circular import doesn’t occur anymore. In
    this case, the `import` in import `T_28_circular_imports_a.py` needs to be moved
    between `FileA` and `FileB`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In most cases, the better solution is to restructure the code, however. Move
    the common base class to a separate file so there is no need for a circular import
    anymore. For the example above, that would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`T_29_circular_imports_a.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '`T_29_circular_imports_b.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '`T_29_circular_imports_c.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: If that is also not possible, it can be useful to import from a function at
    runtime instead of at import time. Naturally this is not an easy option for class
    inheritance, but if you only need the import at runtime, you can defer the importing.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, there is the option of dynamic imports, such as what the Django framework
    uses for the `ForeignKey` fields. In addition to actual classes, the `ForeignKey`
    fields also support strings, which will be imported automatically when needed.
  prefs: []
  type: TYPE_NORMAL
- en: While this is a very effective way of working around the problem, it does mean
    that your editor, linting tools, and other tools won’t understand the object you
    are dealing with. To those tools, it will look like a string, so unless specific
    hacks are added to those, they will not assume the value to be anything besides
    a string.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, because the `import` only happens at runtime, you will not notice
    import problems until you execute the function. That means that errors that normally
    would have presented themselves as soon as you run the script or application will
    now only show up when the function is called. This is a great recipe for hard-to-trace
    bugs that won’t occur for you but will for other users of the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The pattern is still useful for cases such as plugin systems, however, as long
    as care is taken to avoid the caveats mentioned. Here’s a simple example to import
    dynamically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: Using `importlib`, it is fairly easy to dynamically `import` a module and by
    using `getattr`, you can get a specific object from the module.
  prefs: []
  type: TYPE_NORMAL
- en: Import collisions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One problem that can be extremely confusing is having colliding imports—multiple
    packages/modules with the same name. I have had more than a few bug reports on
    my packages about cases like these.
  prefs: []
  type: TYPE_NORMAL
- en: My `numpy-stl` project, for example, houses the code in a package named `stl`.
    Many people create a test file named `stl.py`. When importing `stl` from `stl.py`,
    it will import itself instead of the `stl` package.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to this, there is also the problem of packages being incompatible
    with each other. Common names might be used by several packages, so be careful
    when installing a bunch of similar packages since they might be sharing the same
    name. When in doubt, just create a new virtual environment and try again. Doing
    this can save you a lot of debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter showed you what the Pythonic philosophy is all about and some of
    the reasoning behind it. Additionally, you have learned about the Zen of Python
    and what is considered beautiful and ugly within the Python community. While code
    style is highly personal, Python has a few very helpful guidelines that at least
    keep people mostly on the same page and style.
  prefs: []
  type: TYPE_NORMAL
- en: In the end, we are all consenting adults; everyone has the right to write code
    as they sees fit. But I do request that you please read through the style guides
    and try to adhere to them unless you have a really good reason not to.
  prefs: []
  type: TYPE_NORMAL
- en: With all that power comes great responsibility, and a few pitfalls, though there
    aren’t too many. Some are tricky enough to fool me regularly and I’ve been writing
    Python for a long time! Python improves all the time though. Many pitfalls have
    been taken care of since Python 2, but some will always remain. For example, circular
    imports and definitions can easily bite you in most languages that support them,
    but that doesn’t mean we’ll stop trying to improve Python.
  prefs: []
  type: TYPE_NORMAL
- en: A good example of the improvements in Python over the years is the `collections`
    module. It contains many useful collections that have been added by users because
    there was a need. Most of them are actually implemented in pure Python, and because
    of that, they are easy enough to be read by anyone. Understanding them might take
    a bit more effort, but I truly believe that if you make it to the end of this
    book, you will have no problem understanding what the collections do. Fully understanding
    how the internals work is something I cannot promise, though; some parts of that
    speak more to generic computer science than Python mastery.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will show you some of the collections available in Python and
    how they are constructed internally. Even though you are undoubtedly familiar
    with collections such as lists and dictionaries, you might not be aware of the
    performance characteristics involved with some of the operations. If some of the
    examples in this chapter were less than clear, you don’t have to worry. The next
    chapter will at least revisit some of them, and more will come in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers: [https://discord.gg/QMzJenHuJf](https://discord.gg/QMzJenHuJf)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code156081100001293319171.png)'
  prefs: []
  type: TYPE_IMG
