- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Pythonic Syntax and Common Pitfalls
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pythonic语法和常见陷阱
- en: In this chapter, you will learn how to write Pythonic code, along with finding
    out about some of the common pitfalls of Python and how to work around them. The
    pitfalls range from passing a list or dictionary (which are mutable) as an argument
    to more advanced pitfalls, such as late-binding in closures. You will also see
    how to fix or work around circular imports in a clean way. Some of the techniques
    used in the examples in this chapter might seem a bit too advanced for such an
    early chapter. Do not worry, though, as the inner workings will be covered later
    on.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何编写Python风格的代码，同时了解一些Python的常见陷阱以及如何规避它们。这些陷阱从将列表或字典（可变对象）作为参数传递到更高级的陷阱，如闭包中的后期绑定。你还将了解如何以干净的方式解决循环导入问题。本章示例中使用的某些技术可能对于如此早期的章节来说显得有些高级。不过，不要担心，因为其内部工作原理将在后面的内容中介绍。
- en: 'We will explore the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将探讨以下主题：
- en: Code style (PEP 8, `pyflakes`, `flake8`, and more)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码风格（PEP 8、`pyflakes`、`flake8`等）
- en: Common pitfalls (lists as function arguments, pass by value versus pass by reference,
    and inheritance behavior)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见陷阱（将列表或字典（可变对象）作为函数参数，值传递与引用传递，以及继承行为）
- en: The definition of Pythonic code used in this chapter is based on commonly accepted
    coding guidelines and my subjective opinions. When working on a project, it is
    most important to stay consistent with the coding styles of that project.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的Pythonic代码的定义基于普遍接受的编码指南和我的主观意见。在项目工作中，保持与项目编码风格的一致性是最重要的。
- en: A brief history of Python
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python简史
- en: 'The Python project started in December 1989 as a hobby project for Guido van
    Rossum during his week off around Christmas. His goal was to write an easy-to-use
    successor for the ABC programming language and to fix the issues that limited
    the applicability of the it. One of the main design goals of Python is, and has
    always been, readability. That is what the first part of the chapter is about:
    readability.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Python项目始于1989年12月，是Guido van Rossum在圣诞节休假期间的一个业余项目。他的目标是编写一个易于使用的ABC编程语言的继任者，并修复限制其适用性的问题。Python的主要设计目标之一，并且始终如此，就是可读性。这就是本章第一部分的内容：可读性。
- en: To facilitate new features and to maintain that readability, the **Python Enhancement
    Proposal** (**PEP**) process was developed. This process allows **anyone** to
    submit a PEP for a new feature, library, or other addition. After a discussion
    on the Python mailing lists and some improvements, a decision is made to either
    accept or reject the proposal.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于添加新功能和保持可读性，开发了**Python增强提案**（**PEP**）流程。此流程允许**任何人**提交一个PEP以添加新功能、库或其他内容。经过在Python邮件列表上的讨论和一些改进后，将决定接受或拒绝该提案。
- en: 'The Python style guide (PEP 8: [https://peps.python.org/pep-0008/](https://peps.python.org/pep-0008/))
    was once submitted as one of those PEPs, was accepted, and has been improved regularly
    ever since. It has a lot of great and widely accepted conventions, as well as
    a few disputed ones. In particular, the maximum line length of 79 characters is
    a topic of much discussion. Limiting a line to 79 characters does have some merits,
    however. Originally, this choice was made because terminals were 80 characters
    wide, but these days, larger monitors allow you to place multiple files next to
    each other. For docstrings and comments, a 72-character limit is recommended to
    increase readability. Additionally, it’s the common convention for Linux/Unix
    man (manual) pages.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Python风格指南（PEP 8：[https://peps.python.org/pep-0008/](https://peps.python.org/pep-0008/））最初作为那些PEP之一被提交，被接受，并且自那时起一直得到定期改进。它包含许多广受好评的约定，以及一些有争议的约定。特别是，79个字符的最大行长度是讨论的焦点。将行限制在79个字符确实有一些优点。最初，这个选择是因为终端宽度为80个字符，但如今，更大的显示器允许你将多个文件并排放置。对于文档字符串和注释，建议使用72个字符的限制以提高可读性。此外，这是Linux/Unix
    man（手册）页面的常见约定。
- en: 'While just the style guide itself does not make code Pythonic, as *The Zen
    of Python* (PEP 20: [https://peps.python.org/pep-0020/](https://peps.python.org/pep-0020/))
    elegantly puts it: “Beautiful is better than ugly.” PEP 8 defines how code should
    be formatted in an exact way, while PEP 20 is more of a philosophy and mindset
    than anything else.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然仅仅风格指南本身并不能使代码具有Python风格，正如*Python的禅宗*（PEP 20：[https://peps.python.org/pep-0020/](https://peps.python.org/pep-0020/））优雅地所说：“优美胜于丑陋。”PEP
    8以精确的方式定义了代码的格式，而PEP 20则更多地是一种哲学和心态。
- en: For almost 30 years, all major decisions for the Python project were made by
    Guido van Rossum, lovingly called the **BDFL** (**Benevolent Dictator For Life**).
    Unfortunately, the “For Life” part of BDFL was not to be after a heated debate
    over PEP 572\. PEP 572 (covered later in this chapter) was a proposal about assignment
    operators, the ability to set a variable inside an `if` statement, a common practice
    in languages such as C, C++, C# and others. Guido van Rossum was not a fan of
    the syntax and opposed the PEP. This triggered a huge debate and he was met with
    such resistance that it moved him to step down as BDFL. It saddened many people
    that Guido van Rossum, universally loved by the community, felt he had to do this.
    I, for one, will certainly miss his insights as the decision-maker. I hope we
    will still see his “Time Machine” in action a few times. Guido van Rossum is thought
    to have a time machine, as he has repeatedly answered feature requests with “I
    just implemented that last night.”
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎30年来，Python项目的所有重大决策都是由Guido van Rossum做出的，他被亲切地称为**BDFL**（**终身仁慈独裁者**）。不幸的是，BDFL中的“终身”部分在关于PEP
    572的激烈辩论后并未实现。PEP 572（本章后面将详细介绍）是一个关于赋值运算符的提案，它允许在`if`语句内设置变量，这是C、C++、C#等语言中的常见做法。Guido
    van Rossum并不喜欢这种语法，并反对了PEP。这引发了一场巨大的辩论，他遇到了如此大的阻力，以至于他不得不辞去BDFL的职务。许多人对此感到悲伤，因为Guido
    van Rossum，这位社区普遍喜爱的决策者，觉得他不得不这样做。至少对我来说，我将非常怀念他作为决策者的洞察力。我希望我们还能看到他的“时间机器”发挥作用几次。Guido
    van Rossum被认为拥有时间机器，因为他反复用“我昨晚刚刚实现了那个功能”来回答功能请求。
- en: 'Without the BDFL to make the final decisions, the Python community had to come
    up with a new way of decision-making, and a whole list of proposals have been
    written to solve this issue:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 没有BDFL做出最终决定，Python社区不得不想出一种新的决策方式，为此已经撰写了一系列提案来解决这一问题：
- en: 'PEP 8010: Continue status quo (ish): [https://peps.python.org/pep-8010/](https://peps.python.org/pep-8010/)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PEP 8010：维持现状（ish）：[https://peps.python.org/pep-8010/](https://peps.python.org/pep-8010/)
- en: 'PEP 8011: Like status quo but with three co-leaders: [https://peps.python.org/pep-8011/](https://peps.python.org/pep-8011/)'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PEP 8011：类似于现状但有三位共同领导者：[https://peps.python.org/pep-8011/](https://peps.python.org/pep-8011/)
- en: 'PEP 8012: No central authority: [https://peps.python.org/pep-8012/](https://peps.python.org/pep-8012/)'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PEP 8012：无中央权威：[https://peps.python.org/pep-8012/](https://peps.python.org/pep-8012/)
- en: 'PEP 8013: Non-core oversight: [https://peps.python.org/pep-8013/](https://peps.python.org/pep-8013/)'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PEP 8013：非核心监督：[https://peps.python.org/pep-8013/](https://peps.python.org/pep-8013/)
- en: 'PEP 8014: Core oversight: [https://peps.python.org/pep-8014/](https://peps.python.org/pep-8014/)'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PEP 8014：核心监督：[https://peps.python.org/pep-8014/](https://peps.python.org/pep-8014/)
- en: 'PEP 8015: Organization of the Python community: [https://peps.python.org/pep-8015/](https://peps.python.org/pep-8015/)'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PEP 8015：Python社区组织：[https://peps.python.org/pep-8015/](https://peps.python.org/pep-8015/)
- en: 'PEP 8016: The Steering Council Model: [https://peps.python.org/pep-8016/](https://peps.python.org/pep-8016/)'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PEP 8016：指导委员会模型：[https://peps.python.org/pep-8016/](https://peps.python.org/pep-8016/)
- en: After a small debate, PEP 8016 - the steering council model - was accepted as
    the solution. PEP 81XX has been reserved for future elections of the steering
    council, with PEP 8100 for the 2019 election, PEP 8101 for the 2020 election,
    and so on.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一番小辩论后，PEP 8016——指导委员会模型——被接受为解决方案。PEP 81XX已被预留用于未来指导委员会的选举，其中PEP 8100用于2019年的选举，PEP
    8101用于2020年的选举，以此类推。
- en: Code style – What is Pythonic code?
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码风格 - 什么是Pythonic代码？
- en: 'When you first hear of Pythonic code, you might think it is a programming paradigm,
    similar to object-oriented or functional programming. It is actually more of a
    design philosophy. Python leaves you free to choose to program in an object-oriented,
    procedural, functional, aspect-oriented, or even logic-oriented way. These freedoms
    make Python a great language to write in, but they have the drawback of requiring
    more discipline to keep code clean and readable. PEP 8 tells us how to format
    code and PEP 20 is about style and how to write Pythonic code. PEP 20, the Pythonic
    philosophy, is about code that is:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当你第一次听说Pythonic代码时，你可能会认为它是一种编程范式，类似于面向对象或函数式编程。实际上，它更多的是一种设计哲学。Python让你自由选择以面向对象、过程式、函数式、面向方面或甚至逻辑导向的方式编程。这些自由使得Python成为了一种极佳的编程语言，但它们也有缺点，即需要更多的纪律来保持代码的整洁和可读性。PEP
    8告诉我们如何格式化代码，而PEP 20则是关于风格以及如何编写Pythonic代码。PEP 20，Pythonic哲学，是关于以下方面的代码：
- en: Clean
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整洁
- en: Simple
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单
- en: Beautiful
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 美观
- en: Explicit
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 明确性
- en: Readable
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可读性
- en: Most of these sound like common sense, and I think they should be. There are
    cases, however, where there is not a single obvious way to write your code (unless
    you’re Dutch, of course, as you’ll read later in this chapter). That is the goal
    of this chapter—to help you to learn how to write beautiful Python code and understand
    why certain decisions have been made in the Python style guide.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 其中大部分听起来像是常识，我认为它们应该是。然而，有些情况下，编写代码并没有一个明显的方法（除非你是荷兰人，当然，你将在本章后面读到这一点）。这就是本章的目标——帮助你学习如何编写漂亮的Python代码，并理解Python风格指南中某些决策的原因。
- en: Let’s get started.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: Whitespace instead of braces
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用空白符而不是花括号
- en: One of the most common complaints about Python for non-Python programmers is
    the use of whitespace instead of braces. Something can be said for both cases,
    and in the end, it doesn’t matter that much. Since nearly every programming language
    already defaults to similar indenting rules even with braces, why not skip the
    braces altogether and make things more readable? That’s what Guido van Rossum
    must have thought when designing the Python language.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 对于非Python程序员来说，Python最常见的一个抱怨是使用空白符而不是花括号。两种情况都有可说的，最终，这并不那么重要。由于几乎每种编程语言默认都使用类似的缩进规则，即使有花括号，为什么不尽可能省略花括号，使代码更易读呢？这就是Guido
    van Rossum在设计Python语言时可能想到的。
- en: 'At one point, some programmers asked Guido van Rossum whether Python would
    ever support braces. Since that day, braces have been available through a `__future__`
    import. Just give it a try:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时候，一些程序员问Guido van Rossum Python是否将支持花括号。从那天起，通过`__future__`导入已经可以使用花括号了。试一试：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Next, let’s talk about formatting strings.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们谈谈字符串的格式化。
- en: Formatting strings – printf, str.format, or f-strings?
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串格式化——printf、str.format还是f-string？
- en: Python has supported both the printf style (`%`) and `str.format` for a long
    time, so you are most likely familiar with both already. With the introduction
    of Python 3.6, an extra option became available, the f-string (PEP 498). The f-string
    is a convenient shorthand for `str.format`, which helps with brevity (and therefore,
    I would argue, readability).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Python长期以来一直支持printf风格（`%`）和`str.format`，因此你很可能已经熟悉这两种方法。随着Python 3.6的引入，又增加了一个选项，即f-string（PEP
    498）。f-string是`str.format`的便捷简写，有助于简洁（因此，我会争辩说，可读性）。
- en: 'PEP 498 – Literal String Interpolation: [https://peps.python.org/pep-0498/](https://peps.python.org/pep-0498/)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: PEP 498 – 字面字符串插值：[https://peps.python.org/pep-0498/](https://peps.python.org/pep-0498/)
- en: The previous edition of this book mainly used the printf style because brevity
    is important in code samples. While the maximum line length as per PEP 8 is 79
    characters, this book is limited to 66 characters before wrapping occurs. With
    f-strings, we finally have a concise alternative to the printf style.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的前一版主要使用了printf风格，因为在代码示例中简洁性很重要。虽然按照PEP 8的规定最大行长度为79个字符，但本书在换行前限制为66个字符。有了f-string，我们终于有了printf风格的简洁替代方案。
- en: '**Tip for running the code in this book**'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**本书运行代码的小贴士**'
- en: Since a large portion includes the `>>>` prefix, simply copy/paste it into IPython
    and it will execute the code as regular Python code.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大部分代码包含`>>>`前缀，只需将其复制/粘贴到IPython中，它就会像常规Python代码一样执行。
- en: 'Alternatively, the GitHub repository for the book has a script to automatically
    convert a sample from doctest style to regular Python: [https://github.com/mastering-python/code_2/blob/master/doctest_to_python.py](https://github.com/mastering-python/code_2/blob/master/doctest_to_python.py)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，本书的GitHub仓库有一个脚本来自动将doctest风格示例转换为常规Python：[https://github.com/mastering-python/code_2/blob/master/doctest_to_python.py](https://github.com/mastering-python/code_2/blob/master/doctest_to_python.py)
- en: To show the power of f-strings, let’s see a few examples of `str.format` and
    the printf style next to each other.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示f-string的力量，让我们看看`str.format`和printf风格并排的几个示例。
- en: The examples in this chapter show the output as returned by the Python console.
    For a regular Python file, you need to add `print()` to see the output.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的示例显示了Python控制台返回的输出。对于常规Python文件，您需要添加`print()`才能看到输出。
- en: Simple formatting
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简单格式化
- en: 'Formatting a simple string:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 格式化一个简单的字符串：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Formatting a floating-point number with two decimals:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 使用两位小数格式化浮点数：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The first real advantage comes when using a variable multiple times. That is
    not possible with the printf style without resorting to named values:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个真正的优势在于多次使用变量时。在不使用命名值的情况下，printf风格无法做到这一点：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, we used `name` twice by using the reference `{0}`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们通过使用引用`{0}`两次来使用`name`。
- en: Named variables
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命名变量
- en: 'Using named variables is fairly similar and this is where we get introduced
    to the magic of f-strings:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命名变量相当类似，这也是我们接触到f字符串魔力的地方：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As you can see, with the f-strings, the variables are fetched from the scope
    automatically. It’s basically a shorthand for:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，使用f字符串，变量会自动从作用域中获取。这基本上是一个简写形式：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Arbitrary expressions
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 任意表达式
- en: 'Arbitrary expressions are where the real power of f-strings becomes visible.
    The features of f-strings go far beyond the string interpolation of the printf-style
    features. The f-strings also support full Python expressions, which means they
    support complex objects, calling methods, `if` statements, and even loops:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 任意表达式是f字符串真正强大之处。f字符串的功能远超printf风格的字符串插值。f字符串还支持完整的Python表达式，这意味着它们支持复杂对象、调用方法、`if`语句，甚至循环：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: PEP 20, the Zen of Python
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PEP 20，Python的禅意
- en: '*The Zen of Python*, as mentioned in the *A brief history of Python* section
    earlier, is about code that not only works, but is Pythonic. Pythonic code is
    readable, concise, and maintainable. PEP 20 says it best:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*Python的禅意*，如前文*Python简史*部分所述，是关于不仅能够工作，而且具有Python风格的代码。Python风格的代码是可读的、简洁的且易于维护。PEP
    20说得最好：'
- en: “Long time Pythoneer Tim Peters succinctly channels the BDFL’s guiding principles
    for Python’s design into 20 aphorisms, only 19 of which have been written down.”
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “长期Python程序员Tim Peters简洁地传达了BDFL（Python之父）为Python设计所制定的指导原则，仅用20条格言，其中只有19条被记录下来。”
- en: The next few paragraphs will explain the intentions of these 19 aphorisms with
    some example code.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几段将用一些示例代码解释这19条格言的意图。
- en: 'For clarity, let’s see these aphorisms before we begin:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清晰起见，让我们在开始之前看看这些格言：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Beautiful is better than ugly
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 美比丑更好
- en: 'Beauty is subjective, of course, but there are still some style rules that
    are good to adhere to. Rules such as (from PEP 8):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 美是主观的，当然，但仍然有一些风格规则是值得遵守的。例如（来自PEP 8）的规则：
- en: Indent using spaces instead of tabs
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用空格而不是制表符缩进
- en: Line length limits
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行长度限制
- en: Each statement on a separate line
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个语句都在单独的一行
- en: Each import on a separate line
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个导入都在单独的一行
- en: When in doubt, always keep in mind that consistency is more important than fixed
    rules. If a project prefers to use tabs instead of spaces, or vice versa, it’s
    better to keep the tabs/spaces like that than to potentially break existing code
    (and revision control history) by replacing the tabs/spaces.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当有疑问时，始终牢记一致性比固定规则更重要。如果一个项目更喜欢使用制表符而不是空格，或者反之，最好是保持这种制表符/空格，而不是通过替换制表符/空格来可能破坏现有的代码（和版本控制历史）。
- en: 'In short, instead of hard-to-read code like this, which shows all odd numbers
    below 10:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，与其使用这种难以阅读的代码，它显示了10以下的奇数：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'I would prefer:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我更愿意：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It is simpler, easier to read, and a bit more beautiful!
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 它更简单，更容易阅读，而且稍微更美观！
- en: These examples are an early introduction to generators. Generators will be discussed
    more thoroughly in *Chapter 7*, *Generators and Coroutines – Infinity, One Step
    at a Time*.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这些例子是生成器的早期介绍。生成器将在*第7章*，*生成器和协程——一次一步的无限*中更详细地讨论。
- en: Explicit is better than implicit
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 明确优于隐晦
- en: Imports, arguments, and variable names are just some of the many cases where
    explicit code is far easier to read at the cost of a little bit more effort and/or
    verbosity when writing the code.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 导入、参数和变量名只是许多情况下显式代码更容易阅读的例子，代价是编写代码时需要更多的努力和/或冗长。
- en: 'Here is an example of how this can go wrong:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子说明这可能会出错：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Where does `wait` come from, in this case? You might say that it’s obvious—it
    comes from `os`. But you would be wrong, sometimes. On Windows, the `os` module
    doesn’t have a `wait` function, so it would be `asyncio.wait` instead.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`wait`从哪里来？你可能会说这很明显——它来自`os`。但有时你会犯错。在Windows上，`os`模块没有`wait`函数，所以应该是`asyncio.wait`。
- en: 'It could be even worse: many editors and code clean-up tools have a sort-imports
    feature. If the sort order of your import changes, the behavior of your project
    will change.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 情况可能更糟：许多编辑器和代码清理工具都有排序导入功能。如果你的导入顺序发生变化，你的项目行为也会发生变化。
- en: 'The immediate fix is simple enough:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 立即的修复方法很简单：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'With this method, we have at least a way to find out where `wait` came from.
    But I would recommend going a step further and importing by module instead, so
    the executing code immediately shows which function is executed:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，我们至少有了一种找出`wait`从何而来途径。但我建议更进一步，通过模块导入，这样执行代码立即显示哪个函数被调用：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The same can be said for `*args` and `**kwargs`. While they are very useful,
    they can make the usage of your functions and classes a lot less obvious:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `*args` 和 `**kwargs` 也是如此。虽然它们非常有用，但它们可能会使你的函数和类的使用变得不那么明显：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Without looking at the code within the function, you cannot know what to pass
    as `**kwargs` or what `*args` does. A reasonable function name can help here,
    of course:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 不看函数内部的代码，你无法知道应该传递什么作为 `**kwargs` 或 `*args` 做了什么。当然，一个合理的函数名在这里能有所帮助：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Documentation can obviously help for cases like these, and I use `*args` and
    `**kwargs` very often, but it is definitely a good idea to keep at least the most
    common arguments explicit. Even when it requires you to repeat the arguments for
    a parent class, it just makes the code much clearer. When refactoring the parent
    class in the future, you’ll know whether there are subclasses that still use some
    parameters.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些情况，文档显然是有帮助的，我经常使用 `*args` 和 `**kwargs`，但确实是一个好主意，至少让最常见的参数明确。即使这要求你为父类重复参数，这也使得代码更加清晰。在将来重构父类时，你会知道是否有子类仍在使用某些参数。
- en: Simple is better than complex
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简单优于复杂
- en: ”Simple is better than complex. Complex is better than complicated.”
  id: totrans-96
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “简单优于复杂。复杂优于复杂化。”
- en: 'Keeping things simple is often much harder than you would expect. Complexity
    has a tendency to creep up on you. You start with a beautiful little script and,
    before you know it, feature creep has turned it into a complex (or worse, complicated)
    mess:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 保持事物简单往往比你想象的要困难得多。复杂性有逐渐渗透的趋势。你从一个美丽的脚本开始，然后不知不觉中，特性膨胀使其变得复杂（或者更糟，复杂化）。
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: At first glance, this code might look a bit difficult. If you’re familiar with
    the sieve of Eratosthenes however, you’ll quickly realize what is happening. With
    just a little bit of effort, you will see that the algorithm isn’t all that complicated
    but uses a few tricks to reduce the necessary computations.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 初看，这段代码可能看起来有些困难。然而，如果你熟悉欧几里得筛法，你会很快意识到正在发生什么。只需一点努力，你就会发现这个算法并不复杂，但使用了一些技巧来减少必要的计算。
- en: 'We can do better, however; let’s see a different example featuring the Python
    3.8 assignment operator:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做得更好；让我们看看一个不同的例子，它展示了 Python 3.8 的赋值运算符：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This algorithm looks a bit less intimidating, but I wouldn’t call it immediately
    obvious at first glance. The `prime := next(numbers)` is the Python 3.8 version
    of setting a variable and immediately returning it in the same statement. The
    `prime.__rmod__` does a modulo with the given number to sieve in a similar fashion
    to the previous example.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法看起来不那么令人畏惧，但我不认为它一开始就那么明显。`prime := next(numbers)` 是 Python 3.8 中在同一个语句中设置变量并立即返回它的版本。`prime.__rmod__`
    使用给定的数字进行取模操作，类似于之前的例子。
- en: 'What might be confusing, however, is that the `numbers` variable is being reassigned
    with added filters on each iteration. Let’s see a better solution:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，可能令人困惑的是，`numbers` 变量在每个迭代中都被重新分配，并添加了过滤器。让我们看看更好的解决方案：
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now we’ve come to one of the most obvious methods of generating prime numbers.
    The `is_prime` function is really simple and immediately shows what `is_prime`
    is doing. And the `primes_simple` function is nothing more than a loop with a
    filter.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来到了生成素数的最明显的方法之一。`is_prime` 函数非常简单，立即显示了 `is_prime` 正在做什么。而 `primes_simple`
    函数不过是一个带有过滤器的循环。
- en: Unless you have a really good reason to go for the complicated approach, try
    to keep your code as simple as you can. You (and perhaps someone else) will be
    grateful when reading your code in the future.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你真的有充分的理由选择复杂的方法，否则尽量让你的代码尽可能简单。当你未来阅读代码时，你（也许还有其他人）会为此感到感激。
- en: Flat is better than nested
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 平铺优于嵌套
- en: Nested code quickly becomes unreadable and hard to understand. There are no
    strict rules here, but generally, when you have multiple levels of nested loops,
    it is time to refactor.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套的代码很快就会变得难以阅读和理解。这里没有严格的规则，但一般来说，当你有多个嵌套循环级别时，就是时候重构了。
- en: 'Just take a look at the following example, which prints a list of two-dimensional
    matrices. While nothing specific is wrong here, splitting it into a few more functions
    might make it easier to understand the purpose and also make it easier to test:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 只需看看以下示例，它打印了一个二维矩阵列表。虽然这里没有什么具体的问题，但将其拆分成更多函数可能会更容易理解其目的，也更容易进行测试：
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here’s the flatter version:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这是更简洁的版本：
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This example might be a bit contrived, but the idea is sound. Deeply nested
    code can easily become very unreadable and splitting code into multiple lines
    or even functions can help readability a lot.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可能有点牵强，但想法是合理的。深层嵌套的代码很容易变得难以阅读，将代码拆分成多行甚至函数可以大大提高可读性。
- en: Sparse is better than dense
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 稀疏比密集好
- en: 'Whitespace is generally a good thing. Yes, it will make your files longer and
    your code will take up more space, but it can help a lot with readability if you
    split your code logically. Let’s take an example:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 空白通常是一件好事。是的，它会使你的文件更长，你的代码会占用更多空间，但如果你的代码逻辑上拆分得好，它可以帮助提高可读性。让我们举一个例子：
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'By looking at the output and the code, you might be able to guess that this
    is the factorial function. But its workings are probably not immediately obvious.
    Let’s try rewriting:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看输出和代码，你可能能够猜出这是一个阶乘函数。但它的运作原理可能并不立即明显。让我们尝试重新编写：
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: By using a proper name, expanding the `if` statement, and explicitly returning
    `1`, it is suddenly much more obvious what is happening.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用合适的名称，扩展`if`语句，并明确返回`1`，它突然变得非常明显发生了什么。
- en: Readability counts
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可读性很重要
- en: 'Shorter does not always mean easier to read. Let’s take the Fibonacci numbers.
    There are many ways of writing this code, many of them hard to read:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 短不一定意味着更容易阅读。让我们以斐波那契数为例。有很多人写这段代码的方法，其中许多很难阅读：
- en: '[PRE22]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Even though there is a kind of beauty and elegance in the solutions, they are
    not readable. With just a few minor changes, we can change these functions to
    more readable functions that function similarly:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管解决方案中存在一种美和优雅，但它们并不易读。只需进行一些小的修改，我们就可以将这些函数改为更易读的函数，其功能相似：
- en: '[PRE23]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Practicality beats purity
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实用性胜过纯粹性
- en: ”Special cases aren’t special enough to break the rules. Although practicality
    beats purity.”
  id: totrans-126
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “特殊情况并不足以打破规则。尽管实用性胜过纯粹性。”
- en: Breaking the rules can be tempting at times, but it’s a slippery slope. If your
    quick fix is going to break the rules, you should really try to refactor it immediately.
    Chances are that you won’t have the time to fix it later and will regret it.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 有时打破规则可能很有吸引力，但这是一个滑稽的斜坡。如果你的快速修复会打破规则，你真的应该立即尝试重构它。很可能你以后没有时间修复它，并且会后悔。
- en: No need to go overboard, though. If the solution is good enough and refactoring
    would be much more work, then choosing the working method might be better. Even
    though all of these examples pertain to imports, this guideline applies to nearly
    all cases.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然没有必要做得太过分。如果解决方案足够好，重构会花费更多的工作，那么选择工作方法可能更好。尽管所有这些例子都涉及导入，但这个指南几乎适用于所有情况。
- en: 'To prevent long lines, imports can be made shorter by using a few methods,
    adding a backslash, adding parentheses, or just shortening the imports. I will
    illustrate some options next:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止长行，可以通过使用几种方法来缩短导入，添加反斜杠，添加括号，或者只是缩短导入。我将在下面展示一些选项：
- en: '[PRE24]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This case can easily be avoided by using parentheses:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这个情况可以通过使用括号轻松避免：
- en: '[PRE25]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Or my personal preference, importing modules instead of the separate objects:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我个人的偏好，导入模块而不是单独的对象：
- en: '[PRE26]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: But what about really long imports?
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 但关于真正长的导入呢？
- en: '[PRE27]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In that case, I would recommend using parentheses. If you need to split the
    imports across multiple lines, I would recommend one line per import for readability:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在那种情况下，我建议使用括号。如果你需要将导入拆分到多行，我建议每行一个导入以提高可读性：
- en: '[PRE28]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Errors should never pass silently
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 错误绝不应该默默通过
- en: ”Errors should never pass silently. Unless explicitly silenced.”
  id: totrans-140
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “错误绝不应该默默通过。除非明确地被压制。”
- en: Handling errors the right way is really difficult and there is no one method
    that works for every situation. There are, however, better and worse methods to
    catch errors.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 正确处理错误真的很困难，没有一种方法适用于所有情况。然而，有一些方法比其他方法更好或更差来捕获错误。
- en: Bare or too-broad exception catching can be a quick way to make your life a
    bit more difficult in the case of bugs. Not passing exception info at all can
    make you (or some other person working on the code) wonder for ages about what
    is happening.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 裸露或过于宽泛的异常捕获可能会在出现错误时使你的生活变得有些困难。完全不传递异常信息可能会让你（或正在编写代码的其他人）长时间对发生的事情感到困惑。
- en: 'To illustrate a bare exception, the worst option is as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明一个裸露的异常，最糟糕的选择如下：
- en: '[PRE29]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'A much better solution is to explicitly capture only the error you need:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的解决方案是明确捕获你需要的错误：
- en: '[PRE30]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Alternatively, if you really need to capture all exceptions, make sure to log
    them properly:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你真的需要捕获所有异常，请确保正确地记录它们：
- en: '[PRE31]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'When using multiple lines inside a `try` block, the issue of tracing bugs is
    aggravated even further because there is even more code that could be responsible
    for the hidden exception. The tracing of bugs also becomes much more difficult
    when the `except` is accidently capturing exceptions from functions a few levels
    deep. For example, consider the following code block:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当在`try`块中使用多行时，由于有更多的代码可能负责隐藏的异常，跟踪错误的难题进一步加剧。当`except`意外地捕获了几层深处的函数的异常时，跟踪错误也变得更加困难。例如，考虑以下代码块：
- en: '[PRE32]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If an exception is raised, which line is causing it? With silent catching of
    the error, there is no way to know without running the code in a debugger. The
    exception could even be caused a few levels deeper in the code if, instead of
    `int()`, you are using a more complex function.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果抛出了异常，是哪一行引起的？在没有运行调试器的情况下，通过静默捕获错误，你无法知道。如果，而不是使用`int()`，你使用了一个更复杂的函数，异常甚至可能是在代码的几层深的地方引起的。
- en: If you are testing for a specific exception in a specific block of code, the
    safer method is using the `else` in the `try`/`except`. The `else` is only executed
    if there was no exception.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个特定的代码块中测试特定的异常，更安全的方法是在`try`/`except`中使用`else`。`else`只有在没有异常的情况下才会执行。
- en: 'To illustrate the full strength of the `try`/`except:`, here is an example
    of all variants including the `else`, `finally`, and `BaseException`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明`try`/`except:`的全部威力，这里是一个包括`else`、`finally`和`BaseException`的所有变体的例子：
- en: '[PRE33]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the face of ambiguity, refuse the temptation to guess
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 面对歧义，拒绝猜测的诱惑
- en: While guesses will work in many cases, they can bite you if you’re not careful.
    As already demonstrated in the *Explicit is better than implicit* section, when
    you have a few `from ... import *`, you cannot always be certain which module
    is providing you with the variable you were expecting.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管猜测在很多情况下都会有效，但如果你不小心，它们可能会给你带来麻烦。正如在*明确优于隐含*部分所展示的，当你有少量`from ... import *`时，你无法总是确定哪个模块为你提供了你期望的变量。
- en: 'Clear and unambiguous code generates fewer bugs so it’s always a good idea
    to think about what happens when someone else reads your code. A prime example
    of ambiguity is function calling. Take, for example, the following two function
    calls:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 清晰且无歧义的代码会产生更少的错误，因此始终考虑当别人阅读你的代码时会发生什么总是一个好主意。一个歧义性的主要例子是函数调用。例如，以下两个函数调用：
- en: '[PRE34]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: These two calls have the exact same result. However, it’s obvious in the second
    call that the `-1` is configuring the buffer. You probably know the first two
    arguments of `open()` by heart but the others are less common.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个调用具有完全相同的结果。然而，在第二个调用中，很明显`-1`正在配置缓冲区。你可能对`open()`的前两个参数了如指掌，但其他参数则不太常见。
- en: Regardless, without seeing `help(open)` or viewing the documentation in another
    manner, it’s impossible to say whether the two are identical.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 无论怎样，没有看到`help(open)`或以其他方式查看文档，你无法说这两个是否相同。
- en: 'Note that I don’t think you should use keyword arguments in all cases, but
    if there are many arguments involved and/or hard-to-identify parameters (such
    as numbers), it can be a good idea. A good alternative is using good variable
    names, which make the function call a lot more obvious:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我认为你不必在所有情况下都使用关键字参数，但如果涉及许多参数和/或难以识别的参数（例如数字），这可能是一个好主意。一个好的替代方案是使用好的变量名，这可以使函数调用更加明显：
- en: '[PRE35]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: One obvious way to do it
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 做这件事的一个明显方法
- en: “There should be one—and preferably only one—obvious way to do it. Although
    that way may not be obvious at first unless you’re Dutch.”
  id: totrans-164
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “应该有一个——最好是只有一个——明显的做法。虽然这个方法可能一开始并不明显，除非你是荷兰人。”
- en: In general, after thinking about a difficult problem for a while, you will find
    that there is one solution that is clearly preferable over the alternatives. There
    are times where this is not the case, however, and in such instances, it can be
    useful if you’re Dutch. The joke here is that Guido van Rossum, the original author
    of Python, is Dutch (as am I) and that only Guido knows the obvious way in some
    cases.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，思考一段时间困难的问题后，你会发现有一个解决方案明显优于其他替代方案。然而，有时情况并非如此，在这种情况下，如果你是荷兰人，这可能是有用的。这里的笑话是，Python的原始作者Guido
    van Rossum是荷兰人（我也是），而且在某些情况下，只有Guido知道明显的做法。
- en: 'The other joke is that the Perl programming language slogan is the opposite:
    “There’s more than one way to do it.”'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个笑话是 Perl 编程语言的口号正好相反：“有多种方法可以做到。”
- en: Now is better than never
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在比永远不做好
- en: “Now is better than never. Although never is often better than *right* now.”
  id: totrans-168
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “现在比永远不做好。尽管永远通常比 *现在* 做好。”
- en: 'It’s better to fix a problem right now than push it into the future. There
    are cases, however, where fixing it right away is not an option. In those cases,
    a good alternative can be to mark a function as deprecated instead so that there
    is no chance of accidentally forgetting the problem:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 立即解决问题比将其推迟到未来更好。然而，在某些情况下，立即解决问题并不是一个选择。在这种情况下，一个好的替代方案是将函数标记为已弃用，这样就没有忘记问题的风险：
- en: '[PRE36]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Hard to explain, easy to explain
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 难以解释，容易解释
- en: “If the implementation is hard to explain, it’s a bad idea. If the implementation
    is easy to explain, it may be a good idea.”
  id: totrans-172
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “如果实现难以解释，那是个坏主意。如果实现容易解释，那可能是个好主意。”
- en: As always, keep things as simple as you can. While complicated code can be nice
    to test with, it is more prone to bugs. The simpler you can keep things, the better.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 总是保持尽可能简单。虽然复杂的代码可以很好地进行测试，但它更容易出现错误。你越能保持简单，就越好。
- en: Namespaces are one honking great idea
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命名空间是一个非常好的想法
- en: “Namespaces are one honking great idea—let’s do more of those!”
  id: totrans-175
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “命名空间是一个非常好的想法——让我们做更多这样的！”
- en: Namespaces can make code a lot clearer to use. Naming them properly makes it
    even better. For example, assume the `import` isn’t on your screen in a larger
    file. What does the `loads` line do?
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间可以使代码更易于使用。正确命名它们会使它变得更好。例如，假设在更大的文件中 `import` 没有显示在你的屏幕上。`loads` 行做什么？
- en: '[PRE37]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now let’s take the version with the namespace:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看带有命名空间版本的示例：
- en: '[PRE38]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Now it is obvious that `loads()` is the `json` loader and not any other type
    of loader.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在很明显 `loads()` 是 `json` 加载器，而不是任何其他类型的加载器。
- en: 'Namespace shortcuts are still useful, though. Let’s look at the `User` class
    in Django, which is used in nearly every Django project. The `User` class is stored
    in `django.contrib.auth.models.User` by default (can be overridden). Many projects
    use the object in the following way:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间快捷方式仍然很有用。让我们看看 Django 中的 `User` 类，它在几乎每个 Django 项目中都被使用。默认情况下，`User` 类存储在
    `django.contrib.auth.models.User` 中（可以被覆盖）。许多项目以以下方式使用该对象：
- en: '[PRE39]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'While this is fairly clear, projects might be using multiple classes named
    `User`, which obscures the import. Also, it might make someone think that the
    `User` class is local to the current class. Doing the following instead lets people
    know that it is in a different module:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这相当清晰，但项目可能会使用多个名为 `User` 的类，这会模糊导入。此外，这也可能让人误以为 `User` 类是当前类的本地类。通过以下方式做可以让人知道它位于不同的模块中：
- en: '[PRE40]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This quickly clashes with other models’ imports, though, so I personally use
    the following instead:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这很快就会与其他模型的导入发生冲突，所以我个人使用以下方法代替：
- en: '[PRE41]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Or the shorter version:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 或者更简短的说法：
- en: '[PRE42]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now you should have some idea of what the Pythonic ideology is about—creating
    code that is:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该对 Python 主义有所了解——创建以下代码：
- en: Beautiful
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 美观
- en: Readable
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易读
- en: Unambiguous
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清晰无误
- en: Explicit enough
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 足够明确
- en: Not completely void of whitespace
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不是完全没有空格
- en: So let’s move on to some more examples of how to create beautiful, readable,
    and simple code using the Python style guide.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们继续看看如何使用 Python 风格指南创建美观、易读和简单的代码的一些更多示例。
- en: Explaining PEP 8
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解释 PEP 8
- en: The previous sections have already shown a lot of examples of using PEP 20 as
    a reference, but there are a few other important guidelines to note as well. The
    PEP 8 style guide specifies the standard Python coding conventions.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的部分已经展示了使用 PEP 20 作为参考的许多示例，但还有一些其他重要的指南需要注意。PEP 8 风格指南指定了标准的 Python 编码约定。
- en: Simply following the PEP 8 standard doesn’t make your code Pythonic, though,
    but it is most certainly a good start. Which style you use is really not that
    much of a concern as long as you are consistent. The only thing worse than not
    using a proper style guide is being inconsistent with it.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 仅遵循 PEP 8 标准并不能使你的代码具有 Python 风格，但它确实是一个很好的开始。你使用哪种风格并不是那么重要，只要你保持一致。最糟糕的事情不是使用合适的风格指南，而是对其不一致。
- en: Duck typing
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Duck typing
- en: 'Duck typing is a method of handling variables by behavior. To quote Alex Martelli
    (one of my Python heroes, also nicknamed the MartelliBot by many):'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Duck typing 是一种通过行为处理变量的方法。引用 Alex Martelli（我的 Python 英雄之一，也被许多人昵称为 MartelliBot）的话：
- en: '“Don’t check whether it IS-a duck: check whether it QUACKS-like-a duck, WALKS-like-a
    duck, etc, etc, depending on exactly what subset of duck-like behavior you need
    to play your language-games with. If the argument fails this specific-ducklyhood-subset-test,
    then you can shrug, ask “why a duck?”'
  id: totrans-201
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “不要检查它是否是一只鸭子：检查它是否像鸭子一样嘎嘎叫，像鸭子一样走路，等等，具体取决于你需要用鸭子行为的一个子集来玩你的语言游戏。如果这个参数没有通过这个特定的鸭子属性子集测试，那么你可以耸耸肩，问‘为什么是一只鸭子？’”
- en: In many cases, when people make a comparison such as `if spam != '':`, they
    are actually just looking for anything that is considered a true value. While
    you can compare the value to the string value `''`, you generally don’t have to
    make it so specific. In many cases, simply doing `if spam:` is more than enough
    and actually functions better.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，当人们进行`if spam != ''`这样的比较时，他们实际上只是在寻找任何被认为是真值的对象。虽然你可以将值与字符串值`''`进行比较，但你通常不必做得如此具体。在许多情况下，简单地做`if
    spam:`就足够了，而且实际上效果更好。
- en: 'For example, the following lines of code use the value of `timestamp` to generate
    a filename:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码行使用`timestamp`的值来生成一个文件名：
- en: '[PRE43]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Because the variable is named `timestamp`, you might be tempted to check whether
    it is actually a `date` or `datetime` object, like this:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 因为变量命名为`timestamp`，你可能会想检查它实际上是否是一个`date`或`datetime`对象，如下所示：
- en: '[PRE44]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: While this is not inherently wrong, comparing types is considered a bad practice
    in Python, as there is often no need.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这本身并没有错，但在Python中，比较类型被认为是一种不好的做法，因为通常没有必要这么做。
- en: 'In Python, the commonly used style is **EAFP** (**easier to ask for forgiveness
    than permission**: [https://docs.python.org/3/glossary.html#term-eafp](https://docs.python.org/3/glossary.html#term-eafp)),
    which assumes no errors but catches them if needed. Within the Python interpreter,
    a `try`/`except` block is extremely efficient if no exception is raised. Actually
    catching an exception is expensive, however, so this approach is mainly recommended
    when you don’t expect the `try` to fail often.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，常用的风格是**EAFP**（**求原谅比求许可更容易**：[https://docs.python.org/3/glossary.html#term-eafp](https://docs.python.org/3/glossary.html#term-eafp)），它假设不会出错，但在需要时可以捕获错误。在Python解释器中，如果没有抛出异常，`try`/`except`块非常高效。然而，实际捕获异常是昂贵的，因此这种方法主要推荐在你不期望`try`经常失败的情况下使用。
- en: 'The opposite of EAFP is **LBYL** (**look before you leap**: [https://docs.python.org/3/glossary.html#term-lbyl](https://docs.python.org/3/glossary.html#term-lbyl)),
    which tests for pre-conditions before other calls or lookups are made. The notable
    downside of this method is the potential for race conditions in multi-threaded
    environments. While you are checking for the existence of a key in a `dict`, another
    thread may have removed it already.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: EAFP（**先做后检查**：[https://docs.python.org/3/glossary.html#term-lbyl](https://docs.python.org/3/glossary.html#term-lbyl)）的相反做法是**LBYL**（**跳之前先看**），在执行其他调用或查找之前检查先决条件。这种方法的一个显著缺点是在多线程环境中可能存在竞争条件。当你正在检查字典中键的存在时，另一个线程可能已经将其移除了。
- en: 'That’s why in Python, duck typing is often preferred. Just test the variable
    for the features you need and don’t worry about the actual type. To illustrate
    how little difference this can make to the end result, see the following code:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么在Python中，鸭子类型通常更受欢迎。只需测试变量是否具有你需要的特性，而不用担心实际的类型。为了说明这可能会对最终结果产生多小的差异，请看以下代码：
- en: '[PRE45]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Versus a string instead of a `date`:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 与字符串而不是日期进行比较：
- en: '[PRE46]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: As you can see, the result is identical.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，结果是相同的。
- en: The same goes for converting a number to a float or an integer; instead of enforcing
    a certain type, just require certain features. Need something that can pass as
    a number? Just try to convert to `int` or `float`. Need a `file` object? Why not
    just check whether there is a `read` method with `hasattr`?
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，将数字转换为浮点数或整数也是如此；而不是强制执行某种类型，只需要求某些特性。需要能通过作为数字的？只需尝试将其转换为`int`或`float`。需要一个`file`对象？为什么不检查是否有`read`方法呢，使用`hasattr`？
- en: Differences between value and identity comparisons
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 值比较和身份比较之间的差异
- en: 'There are many methods of comparing objects in Python: greater than, bitwise
    operators, equal, etc., but there is one comparator that is special: the identity
    comparison operator. Instead of using `if spam == eggs`, you would use `if spam
    is eggs`. The first compares the value and the second compares the identity or
    **memory address**. Because it only compares the memory address, it’s one of the
    lightest and strictest lookups you can get. Whereas a value check needs to make
    sure that the types are comparable and perhaps check the sub-values, the identity
    check just checks whether the unique identifier is the same.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve ever written Java, you should be familiar with this principle. In
    Java, a regular string comparison (`spam == eggs`) will use the identity instead
    of the value. To compare the value, you need to use `spam.equals(eggs)` to get
    the correct results.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'These comparisons are recommended to be used when the identity of the object
    is expected to be constant. One obvious example of this is a comparison with `True`,
    `False`, or `None`. To demonstrate this behavior, let’s look at values that evaluate
    to `True` or `False` when comparing by value, but are actually different:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Similarly, you need to be careful with `if` statements and `None` values, which
    is a common pattern with default function arguments:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The second one indeed needed the default argument, but the first one had an
    actual value that should have been used:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Now we actually get the value that we passed along because we used an identity
    instead of a value check for `arg`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few gotchas with the identities, though. Let’s look at an example
    that doesn’t make any sense:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: While the values are the same, the identities are different. The catch is that
    Python keeps an internal array of integer objects for all integers between `-5`
    and `256`; that’s why it works for `256` but not for `257`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: To look at what Python is actually doing internally with the `is` operator,
    you can use the `id` function. When executing `if spam is eggs`, Python will execute
    the equivalent of `if id(spam) == id(eggs)` internally and `id()` (at least for
    CPython) returns the memory address.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Loops
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Coming from other languages, one might be tempted to use `for` loops or `while`
    loops with counters to process the items of a `list`, `tuple`, `str`, and so on.
    While valid, it is more complex than needed. For example, consider this code:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Within Python, there is no need to build a custom loop: you can simply loop
    the iterable object instead. Although enumerating including a counter is easily
    possible too:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This can be written even shorter, of course (albeit not 100% identically, since
    we’re not using `print`), but I wouldn’t recommend that for the sake of readability
    in most cases:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The last option might be clear to some but not all. A common recommendation
    is to limit the usage of `list`/`dict`/`set` comprehensions and `map`/`filter`
    statements to cases where the entire statement fits on a single line.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Maximum line length
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最大行长度
- en: Many Python programmers think 79 characters is too constricting and just keep
    the lines longer. While I am not going to argue for 79 characters specifically,
    setting a low limit is a good idea so you can easily keep multiple editors side
    by side. I often have four Python files open next to each other. If the line width
    were more than 79 characters, that simply wouldn’t fit.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 许多Python程序员认为79个字符的限制太严格，因此他们只是让行更长。虽然我不会为79个字符的具体数字辩护，但设定一个低限是一个好主意，这样你可以轻松地将多个编辑器并排打开。我经常有四个Python文件并排打开。如果行宽超过79个字符，那就无法适应了。
- en: 'PEP 8 tells us to use backslashes in cases where lines get too long. While
    I agree that backslashes are preferable over long lines, I still think they should
    be avoided, if possible, since they easily generate syntax errors when manipulating
    code by copying/pasting and rearranging. Here’s an example from PEP 8:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: PEP 8告诉我们，当行过长时应该使用反斜杠。虽然我同意反斜杠比长行更可取，但我仍然认为如果可能的话应该避免使用，因为它们在通过复制/粘贴和重新排列代码时很容易产生语法错误。以下是一个来自PEP
    8的例子：
- en: '[PRE54]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Instead of using backslashes, I would reformat the code by introducing extra
    variables so all lines are easy to read:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是使用反斜杠，我会通过引入额外的变量来重新格式化代码，这样所有行都容易阅读：
- en: '[PRE55]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Or in this specific case of filenames, by using `pathlib`:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 或者在这个特定的文件名案例中，通过使用 `pathlib`：
- en: '[PRE56]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This is not always an option, of course, but it’s a good consideration to keep
    the code short and readable. It actually provides a bonus of adding more information
    to the code. If, instead of `filename_1`, you use a name that conveys the goal
    of the filename, it immediately becomes clearer what you are trying to do.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这并不总是可行的选择，但保持代码简短和可读性是一个很好的考虑。实际上，这实际上为代码添加了更多信息。如果你使用的是 `filename_1` 而不是传达文件名目标的名称，那么你立即就能清楚地知道你试图做什么。
- en: Verifying code quality, pep8, pyflakes, and more
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证代码质量，pep8，pyflakes等
- en: There are many tools for checking code quality and style in Python. The options
    range from `pycodestyle` (previously named `pep8`) for checking rules pertaining
    to PEP 8, to tools such as `flake8`, which bundles a lot of tools and can help
    refactor code and track down bugs in code that appears to work.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中有很多检查代码质量和风格的工具。选项从检查与PEP 8相关的规则的 `pycodestyle`（之前命名为 `pep8`）到捆绑了许多工具的
    `flake8`，这些工具可以帮助重构代码并追踪看似正常工作的代码中的错误。
- en: Let’s go into more detail.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地探讨一下。
- en: pycodestyle/pep8
  id: totrans-250
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: pycodestyle/pep8
- en: 'The `pycodestyle` package (previously named `pep8`) is the default code style
    checker to start with. The `pycodestyle` checker attempts to validate many of
    the rules suggested in PEP 8 that are considered to be the standard by the community.
    It doesn’t check everything that is in the PEP 8 standard, but it goes a long
    way and is still updated regularly to add new checks. Some of the most important
    things checked by `pycodestyle` are as follows:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`pycodestyle` 包（之前命名为 `pep8`）是开始时的默认代码风格检查器。`pycodestyle` 检查器试图验证许多在PEP 8中提出的规则，这些规则被认为是社区的标准。它并不检查PEP
    8标准中的所有内容，但它已经走了很长的路，并且仍然定期更新以添加新的检查。`pycodestyle` 检查的一些最重要的内容如下：'
- en: 'Indentation: While Python will not check how many spaces you use to indent,
    it does not help with the readability of your code'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缩进：虽然Python不会检查你使用多少空格来缩进，但这并不有助于提高代码的可读性
- en: Missing whitespace, such as `spam=123`
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺少空白，例如 `spam=123`
- en: Too much whitespace, such as `def eggs(spam = 123):`
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过多的空白，例如 `def eggs(spam = 123):`
- en: Too many or too few blank lines
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空行过多或过少
- en: Too long lines
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行过长
- en: Syntax and indentation errors
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语法和缩进错误
- en: Incorrect and/or superfluous comparisons (`not in`, `is not`, `if spam is True`,
    and type comparisons without `isinstance`)
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不正确和/或多余的比较（`not in`，`is not`，`if spam is True`，以及没有 `isinstance` 的类型比较）
- en: If some of the specific rules are not to your liking, you can easily tweak them
    to fit your purpose. Beyond that, the tool is not too opinionated, which makes
    it an ideal starting point for any Python project.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果某些特定规则不符合你的喜好，你可以轻松地调整它们以适应你的目的。除此之外，该工具并不太具有主观性，这使得它成为任何Python项目的理想起点。
- en: 'An honorable mention goes out to the `black` project, which is a Python formatter
    that automatically formats your code to largely adhere to the PEP 8 style. The
    name `black` stems from Henry Ford’s quote: “Any customer can have a car painted
    any color that he wants so long as it is black.”'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是 `black` 项目，这是一个Python格式化工具，可以自动将你的代码格式化为大量遵循PEP 8风格的代码。`black` 这个名字来源于亨利·福特的名言：“任何顾客都可以得到一辆任何颜色的车，只要它是黑色的。”
- en: 'That immediately shows the downside of `black`: it offers very little in the
    way of customization. If you don’t like one of the rules, you are most likely
    out of luck.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这立即显示了`black`的缺点：它在定制方面提供的非常有限。如果你不喜欢其中的某条规则，你很可能运气不佳。
- en: pyflakes
  id: totrans-262
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: pyflakes
- en: 'The `pyflakes` checker is meant to detect errors and potential bugs in your
    code by parsing (not importing) the code. This makes it ideal for editor integration,
    but it can also be used to warn you about potential issues in your code beyond
    that. It will warn you about:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`pyflakes`检查器通过解析（而不是导入）代码来检测你代码中的错误和潜在的错误。这使得它非常适合与编辑器集成，但它也可以用来警告你代码中可能存在的问题。它将警告你关于以下内容：'
- en: Unused imports
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未使用的导入
- en: Wildcard imports (`from module import *`)
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通配符导入（`from module import *`）
- en: Incorrect `__future__` imports (after other imports)
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不正确的`__future__`导入（在其他导入之后）
- en: 'More importantly, it warns you about potential bugs, such as the following:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，它警告你关于潜在的错误，例如以下内容：
- en: Redefinitions of names that were imported
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新定义已导入的名称
- en: Usage of undefined variables
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用未定义的变量
- en: Referencing variables before assignment
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在赋值之前引用变量
- en: Duplicate argument names
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复的参数名称
- en: Unused local variables
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未使用的局部变量
- en: pep8-naming
  id: totrans-273
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: pep8-naming
- en: 'The last bit of PEP 8 is covered by the `pep8-naming` package. It makes sure
    that your naming is close to the standard dictated by PEP 8:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: PEP 8的最后一点由`pep8-naming`包处理。它确保你的命名接近PEP 8指定的标准：
- en: Class names as `CapWord`
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类名使用`CapWord`
- en: Function, variable, and argument names all in lowercase
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数、变量和参数名称全部小写
- en: Constants as full uppercase and being treated as constants
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常量使用全大写并被视为常量
- en: The first argument of instance methods and class methods as `self` and `cls`,
    respectively
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例方法和类方法的第一参数分别为`self`和`cls`
- en: McCabe
  id: totrans-279
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: McCabe
- en: 'Lastly, there is the McCabe complexity. It checks the complexity of code by
    looking at the **Abstract Syntax Tree** (**AST**), which Python builds from the
    source code internally. It finds out how many lines, levels, and statements are
    there and warns you if your code has more complexity than a preconfigured threshold.
    Generally, you will use McCabe through `flake8`, but a manual call is possible
    as well. Using the following code:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，是McCabe复杂度。它通过查看Python从源代码内部构建的**抽象语法树（AST**）来检查代码的复杂度。它找出有多少行、级别和语句，并在你的代码复杂度超过预配置的阈值时发出警告。通常，你会通过`flake8`使用McCabe，但也可以手动调用。使用以下代码：
- en: '[PRE57]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'McCabe will give us the following output:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: McCabe将给出以下输出：
- en: '[PRE58]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: At first, when you look at the `1` generated by `noop`, you might think `mccabe`
    counts the lines of code. Upon further inspection, you can see this isn’t the
    case. Having multiple `noop` operators does not increase the count and nor do
    the `print` statements in the `print_cube` function.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，当你看到`noop`生成的`1`时，你可能会认为`mccabe`计算的是代码行数。经过进一步检查，你可以看到这并不是事实。有多个`noop`操作符不会增加计数，`print_cube`函数中的`print`语句也不会增加计数。
- en: 'The `mccabe` tool checks the cyclomatic complexity of code. In a nutshell,
    this means that it counts the number of possible execution paths. Code without
    any control flow statements such as `if`/`for`/`while` counts as 1, as you can
    see in the `noop` function. A simple `if` or `if`/`else` results in two options:
    one where the `if` statement is `True` and one where the `if` statement is `False`.
    If there is a nested `if` or an `elif`, this would increase further. Loops count
    as 2 since there is the flow of going inside the loop if there are items, and
    not going into the loop if there are no items.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`mccabe`工具检查代码的循环复杂度。简而言之，这意味着它计算可能的执行路径数量。没有任何控制流语句（如`if`/`for`/`while`）的代码计为1，正如你在`noop`函数中看到的那样。一个简单的`if`或`if`/`else`会产生两个选项：一个`if`语句为`True`的情况和一个`if`语句为`False`的情况。如果有嵌套的`if`或`elif`，这将进一步增加。循环计为2，因为有项目时进入循环的流程，没有项目时不进入循环。'
- en: The warning threshold for `mccabe` is set to 10 by default, but is configurable.
    If your code actually has a score of more than 10, it is time for some refactoring.
    Remember the advice from PEP 20.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`mccabe`的默认警告阈值设置为10，但可以配置。如果你的代码实际得分超过10，那么是时候进行一些重构了。记住PEP 20的建议。'
- en: Mypy
  id: totrans-287
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Mypy
- en: Mypy is a tool used to check the variable types within your code. While specifying
    fixed types goes against duck typing, there are certainly cases where this is
    useful and where it will protect you from bugs.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: Mypy是一种用于检查代码中变量类型的工具。虽然指定固定类型与鸭子类型相矛盾，但确实有一些情况下这很有用，并且可以保护你免受错误的影响。
- en: 'Taking the following code, for example:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 以以下代码为例：
- en: '[PRE59]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The `mypy` command will tell us we’ve made a mistake:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`mypy`命令会告诉我们我们犯了一个错误：'
- en: '[PRE60]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Note that this syntax depends on the type hinting introduced in Python 3.5\.
    For older Python versions, you can use comments for type hints instead:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个语法依赖于Python 3.5中引入的类型提示。对于较旧的Python版本，你可以使用注释来代替类型提示：
- en: '[PRE61]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Even if you’re not using code hinting in your own code, this can still be useful
    to check whether your calls to external libraries are correct. If the arguments
    for a function of an external library changed with an update, this can quickly
    tell you something is wrong at the location of the mistake instead of having to
    trace a bug throughout your code.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你不在自己的代码中使用代码提示，这也可以用来检查你的外部库调用是否正确。如果一个外部库的函数参数在更新中发生了变化，这可以快速告诉你错误位置有问题，而不是需要追踪整个代码中的错误。
- en: flake8
  id: totrans-296
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: flake8
- en: To run all of these tests combined, you can use `flake8`, a tool that runs `pycodestyle`,
    `pyflakes`, and `mccabe` by default. After running these commands, `flake8` combines
    their outputs into a single report. Some of the warnings generated by `flake8`
    might not fit your taste, so each and every one of the checks can be disabled,
    both per file and for the entire project if needed. For example, I personally
    disable `W391` for all my projects, which warns you about blank lines at the end
    of a file.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行所有这些测试的组合，你可以使用默认运行`pycodestyle`、`pyflakes`和`mccabe`的`flake8`工具。运行这些命令后，`flake8`将它们的输出合并成单个报告。`flake8`生成的某些警告可能不符合你的口味，所以每个检查都可以禁用，无论是按文件还是按整个项目（如果需要的话）。例如，我个人为所有项目禁用了`W391`，它会警告你文件末尾有空白行。
- en: This is something I find useful while working on code so that I can easily jump
    to the end of the file and start writing code instead of having to append a few
    lines first.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我工作时发现很有用的一点，这样我就可以轻松地跳到文件末尾并开始编写代码，而不是先添加几行。
- en: There are also many plugins available to make `flake8` even more powerful.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多插件可以使`flake8`更加强大。
- en: 'Some example plugins are:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 一些示例插件包括：
- en: '`pep8-naming`: Tests PEP naming conventions'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pep8-naming`：测试PEP命名约定'
- en: '`flake8-docstrings`: Tests whether docstrings follow the PEP 257, NumPy, or
    Google convention. More about these conventions will be in the chapter about documentation.'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flake8-docstrings`：测试docstrings是否遵循PEP 257、NumPy或Google约定。关于这些约定的更多内容将在关于文档的章节中介绍。'
- en: '`flake8-bugbear`: Finds likely bugs and design problems in your code, such
    as bare excepts.'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flake8-bugbear`：在代码中查找可能的错误和设计问题，例如裸露的except。'
- en: '`flake8-mypy`: Tests whether the types of values are consistent with the declared
    types.'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flake8-mypy`：测试值类型是否与声明的类型一致。'
- en: In general, before committing your code and/or putting it online, just run `flake8`
    from your source directory to check everything recursively.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在提交代码和/或将代码上线之前，只需从你的源目录中运行`flake8`来递归地检查一切。
- en: 'Here is a demonstration with some poorly formatted code:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些格式不佳的代码的演示：
- en: '[PRE62]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'It results in the following:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这会导致以下结果：
- en: '[PRE63]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Recent additions to the Python syntax
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python语法的最近添加
- en: The Python syntax has remained largely unchanged in the last decade, but we
    have seen a few additions, such as the f-strings, type hinting, and async functions,
    of course. We already covered f-strings at the beginning of this chapter, and
    the other two are covered by *Chapter 9* and *Chapter 13*, respectively, but there
    have a been a few other recent additions to the Python syntax that you might have
    missed. Additionally, in *Chapter 4* you will see the dictionary merge operators
    added in Python 3.9.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去十年中，Python语法在很大程度上保持不变，但我们已经看到了一些添加，比如f-strings、类型提示和异步函数，当然。我们已经在本章开头介绍了f-strings，其他两个分别在*第9章*和*第13章*中介绍，但还有一些其他最近添加到Python语法中的内容，你可能错过了。此外，在*第4章*中，你将看到Python
    3.9中添加的字典合并操作符。
- en: 'PEP 572: Assignment expressions/the walrus operator'
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PEP 572：赋值表达式/海象操作符
- en: 'We already covered this briefly earlier in this chapter, but since Python 3.8,
    we have assignment expressions. If you have experience with C or C++, you have
    most likely seen something like this before:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章前面已经简要地介绍过这一点，但自从Python 3.8版本以来，我们有了赋值表达式。如果你有C或C++的经验，你很可能之前见过类似的东西：
- en: '[PRE64]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Within C, this opens a file using `fopen()`, stores the result of `fopen()`
    in `fh`, and checks whether the result of the `fopen()` call is `NULL`. Until
    Python 3.8, we always had to split these two operations into an assignment and
    an `if` statement, assuming we also had `fopen()` and `NULL` available in our
    Python code:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C 中，使用 `fopen()` 打开文件，将 `fopen()` 的结果存储在 `fh` 中，并检查 `fopen()` 调用的结果是否为 `NULL`。直到
    Python 3.8，我们总是必须将这些两个操作分成一个赋值和一个 `if` 语句，假设我们的 Python 代码中也有 `fopen()` 和 `NULL`：
- en: '[PRE65]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Since Python 3.8, we can use assignment expressions to do this in a single
    line, similar to C:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 自从 Python 3.8 以来，我们可以使用赋值表达式在一行中完成这个操作，类似于 C：
- en: '[PRE66]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'With the := operator you can assign and check the result in one operation.
    This can be useful when reading user input, for example:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 := 运算符，您可以在一个操作中分配和检查结果。这在读取用户输入时非常有用，例如：
- en: '[PRE67]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This operator is often called the walrus operator because it looks slightly
    like the eyes and tusks of a walrus (:=).
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这个运算符通常被称为海象运算符，因为它看起来有点像海象的眼睛和獠牙（:=）。
- en: 'PEP 634: Structural pattern matching, the switch statement'
  id: totrans-322
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PEP 634：结构化模式匹配，switch 语句
- en: Many programmers who are new to Python wonder why it does not have a switch
    statement like most common programming languages. Often the lack of a switch statement
    has been addressed with dictionary lookups or, simply, a chain of `if`/`elif`/`elif`/`elif`/`else`
    statements. While those solutions work fine, I personally feel that at times my
    code could have been prettier and more readable with a switch statement.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 许多刚开始接触 Python 的程序员想知道为什么它不像大多数常见编程语言那样有 switch 语句。通常，switch 语句的缺失是通过字典查找或简单地使用一系列
    `if`/`elif`/`elif`/`elif`/`else` 语句来解决的。虽然这些解决方案可以正常工作，但我个人觉得有时我的代码如果使用 switch
    语句可能会更美观、更易读。
- en: Since Python 3.10, we finally have a feature that is very comparable to a switch
    statement but so much more powerful. As is the case with the Python ternary operator
    (i.e. `true_value if condition else false_value`), the syntax is far from a literal
    copy of other languages. In this case, especially, this is for the better. With
    most programming languages, it can be really easy to forget the `break` statement
    in a switch, which can cause unintended side effects.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 自从 Python 3.10 以来，我们终于拥有了一个与 switch 语句非常相似但功能更强大的特性。正如 Python 的三元运算符（即 `true_value
    if condition else false_value`）的情况一样，其语法与其它语言的直接复制相去甚远。在这种情况下，这反而更好。在大多数编程语言中，很容易忘记
    switch 中的 `break` 语句，这可能会导致意外的副作用。
- en: At a glance, the Python implementation appears much simpler in syntax and features.
    Without the `break` statement, you might wonder how you can match multiple patterns
    in a single go. Stay tuned and find out! The pattern matching feature is *very
    powerful* and offers many more features than you might expect.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 从表面上看，Python 的实现语法和功能似乎更简单。没有 `break` 语句，你可能会想知道如何一次性匹配多个模式。请耐心等待，我们将揭晓！模式匹配功能非常强大，并且提供了比您预期的更多功能。
- en: The basic match statement
  id: totrans-326
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 基本的匹配语句
- en: 'First, let’s look at a basic example. This one offers little benefit but can
    still be easier to read than a regular `if`/`elif`/`else` statement:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看一个基本示例。这个例子提供的帮助不大，但仍然比常规的 `if`/`elif`/`else` 语句更容易阅读：
- en: '[PRE68]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Since we have both the `if` and the `match` statement here, you can easily compare
    them. In this case, I would go for the `if` statement, but the main advantage
    of not having to repeat the `some_variable ==` part can still be useful.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们这里既有 `if` 语句也有 `match` 语句，您可以轻松地进行比较。在这种情况下，我会选择 `if` 语句，但不需要重复 `some_variable
    ==` 部分的主要优势仍然很有用。
- en: The `_` is the special wild card case for the match statement. It matches any
    value, so it can be seen as the equivalent of the `else` statement.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '`_` 是 match 语句的特殊通配符情况。它匹配任何值，因此它可以看作是 `else` 语句的等价物。'
- en: Storing the fallback as a variable
  id: totrans-331
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将后备存储为变量
- en: 'A slightly more useful example is to automatically store the result when it
    doesn’t match. The previous example uses an underscore (`_`), which is not actually
    stored in `_` because it is a special case, but if we name the variable differently,
    we can store the result:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 一个稍微更有用的例子是在不匹配时自动存储结果。前面的例子使用了下划线（`_`），实际上并没有存储在 `_` 中，因为它是一个特殊的情况，但如果我们给变量起不同的名字，我们就可以存储结果：
- en: '[PRE69]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: In this case we store the `else` case in the `other` variable. Note that you
    cannot use `_` and a variable name at the same time since they do the same thing,
    which would be useless.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将 `else` 情况存储在 `other` 变量中。请注意，您不能同时使用 `_` 和变量名，因为它们做的是同一件事，这将是没有用的。
- en: Matching from variables
  id: totrans-335
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从变量中进行匹配
- en: 'You saw that a case such as `case other:` will store the result in `other`
    instead of comparing it with the value of `other`, so you might be wondering if
    we can do the equivalent of:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到，例如 `case other:` 这样的情况会将结果存储在 `other` 中，而不是与 `other` 的值进行比较，所以你可能想知道我们是否可以做等效的操作：
- en: '[PRE70]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The answer is that we can, with a caveat. Since any bare `case variable:` will
    result in storing into a variable, we need to have something that does not match
    that pattern. The common way to work around this limitation is by introducing
    a dot:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是我们可以，但有一个前提。由于任何裸露的 `case variable:` 都会导致将值存储到变量中，我们需要有某种不匹配该模式的东西。常见的绕过这种限制的方法是通过引入一个点：
- en: '[PRE71]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: As long as it cannot be interpreted as a variable name, this will work for you.
    When comparing with a local variable, an `if` statement can always be used as
    well, of course.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 只要它不能被解释为变量名，这对你来说就会起作用。当然，在比较局部变量时，也可以使用 `if` 语句。
- en: Matching multiple values in a single case
  id: totrans-341
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在单个情况中匹配多个值
- en: 'If you’re familiar with the `switch` statement in many other programming languages,
    you might be wondering whether you can have multiple `case` statements before
    you `break`, like this, for example (C++):'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉许多其他编程语言中的 `switch` 语句，你可能想知道在你 `break` 之前是否可以有多个 `case` 语句，例如（C++）：
- en: '[PRE72]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'This roughly means that if `variable` is either equal to `LEFT` or `RIGHT`,
    print the `"Going horizontal"` line and `break`. Since the Python `match` statement
    does not have a `break`, how can we match something like this? Well, some syntax
    was introduced specifically for that:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 这大致意味着如果 `variable` 等于 `LEFT` 或 `RIGHT`，则打印 `"Going horizontal"` 行并 `break`。由于
    Python 的 `match` 语句没有 `break`，我们如何匹配这样的内容？嗯，为了这个目的，引入了一些特定的语法：
- en: '[PRE73]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: As you can see, using the `|` operator (which is also used for bitwise operations),
    you can test for multiple values at the same time.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，使用 `|` 操作符（它也用于位运算），你可以同时测试多个值。
- en: Matching values with guards or extra conditions
  id: totrans-347
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 guards 或额外条件匹配值
- en: 'There are times when you want a more advanced comparison such as `if variable
    > value:`. Luckily, even that is possible with the `match` statement using a feature
    called guards:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你想要更高级的比较，比如 `if variable > value:`。幸运的是，即使这样也可以通过使用带有称为 guards 的 `match`
    语句来实现。
- en: '[PRE74]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Note that this uses the variable name that I just introduced, but it’s a regular
    Python expression, so you could also compare something else. However, you always
    need to have the variable name before the `if`. This will *not* work: `case if
    ...`.'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这使用了刚刚引入的变量名，但它是一个常规的 Python 正则表达式，所以你也可以比较其他内容。然而，你总是需要在 `if` 前面有变量名。这不会起作用：`case
    if ...`。
- en: Matching lists, tuples, and other sequences
  id: totrans-351
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 匹配列表、元组和其它序列
- en: 'If you are familiar with `tuple` unpacking, you can probably guess how sequence
    matching works:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉 `tuple` 解包，你可能可以猜出序列匹配是如何工作的：
- en: '[PRE75]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The first case explicitly matches both of the given values, which is identical
    to `if value == (0, 1):`.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个情况明确匹配了给定的两个值，这等同于 `if value == (0, 1):`。
- en: 'The second case explicitly matches `0` for the first value, but leaves the
    second value as a variable and stores it in `y`. Effectively this comes down to
    `if value[0] == 0: y = value[1]`.'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '第二个情况明确匹配第一个值为 `0`，但将第二个值作为一个变量，并存储在 `y` 中。实际上这相当于 `if value[0] == 0: y = value[1]`。'
- en: The last case stores a variable for both the `x` and `y` values and will match
    any sequence with exactly two items.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个情况为 `x` 和 `y` 值存储一个变量，并将匹配任何恰好有两个元素的序列。
- en: Matching sequence patterns
  id: totrans-357
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 匹配序列模式
- en: If you thought the previous example with the unpacking of the variables was
    useful, you will love this section. One of the really powerful features of the
    `match` statement is matching based on patterns.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为之前的变量解包示例很有用，你将喜欢这一部分。`match` 语句的一个真正强大的功能是基于模式进行匹配。
- en: 'Let’s assume we have a function that takes up to three parameters, `host`,
    `port`, and `protocol`. For `port` and `protocol`, we can assume `443` and `https`,
    respectively, so that only leaves the `hostname` as a required parameter. How
    can we match this so one, two, three, or more parameters are all supported and
    work correctly? Let’s find out:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个函数，它接受最多三个参数，`host`、`port` 和 `protocol`。对于 `port` 和 `protocol`，我们可以假设
    `443` 和 `https`，这样只剩下 `hostname` 作为必需的参数。我们如何匹配这样，使得一个、两个、三个或更多的参数都得到支持并正确工作？让我们来看看：
- en: '[PRE76]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'As you can see, the `match` statement also handles different length sequences,
    which is a very useful tool to have. You could do this with `if` statements as
    well, but I’ve never found a way to handle that in a really pretty fashion. Naturally
    you could still combine this with the earlier examples, so you could have a `case`
    such as: `case (hostname, port, ''http''):` if you want to invoke specific behavior.
    You can also apply `*variable` to capture all extra variables. The `*` matches
    0 or more extra items in the sequence.'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`match` 语句还处理不同长度的序列，这是一个非常有用的工具。你当然也可以用 `if` 语句来做这件事，但我从未找到一种真正漂亮的方式来处理它。当然，你仍然可以将其与前面的示例结合起来，所以如果你想要调用特定的行为，你可以有一个
    `case`，例如：`case (hostname, port, 'http'):`。你还可以使用 `*variable` 来捕获所有额外的变量。`*` 匹配序列中的0个或多个额外项。
- en: Capturing sub-patterns
  id: totrans-362
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 捕获子模式
- en: 'In addition to specifying a variable name to save all values into, you can
    also store explicit value matches:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 除了指定一个变量名来保存所有值之外，你还可以存储显式的值匹配：
- en: '[PRE77]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: In this case we explicitly match `0` as the first part of `value`, and `1` or
    `2` as the second part of `value`. And we store those in the variables `x` and
    `y`, respectively.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们明确地将 `0` 作为 `value` 的第一部分进行匹配，将 `1` 或 `2` 作为 `value` 的第二部分进行匹配。并将这些分别存储在变量
    `x` 和 `y` 中。
- en: It is important to note here that within the context of a `case` statement the
    `|` operator will always work as a or for the `case`, instead of a bitwise or
    for the variables/values. Normally `1 | 2` would result in `3` because in binary
    `1 = 0001`, `2 = 0010` , and the combination of those is `3 = 0011`.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的是，在 `case` 语句的上下文中，`|` 运算符始终按或操作符对 `case` 起作用，而不是按位或操作符对变量/值。通常 `1 |
    2` 会得到 `3`，因为在二进制中 `1 = 0001`，`2 = 0010`，这两个数的组合是 `3 = 0011`。
- en: Matching dictionaries and other mappings
  id: totrans-367
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 匹配字典和其他映射
- en: 'Naturally it is also possible to match mappings (such as `dict`) by key:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，也可以通过键来匹配映射（如 `dict`）：
- en: '[PRE78]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Note that `match` only checks for the given keys and values and does not care
    about extra keys in the mapping. This is why the first case matches both of the
    first two items.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`match` 只检查给定的键和值，并不关心映射中的额外键。这就是为什么第一个案例匹配前两个项目。
- en: As you can see in the preceding example, matching happens sequentially and it
    will stop at the first match, not the best match. The second case is never reached
    in this scenario.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前一个示例所示，匹配是按顺序发生的，并且它会在第一个匹配项处停止，而不是在最佳匹配项处停止。在这种情况下，第二个案例永远不会被触及。
- en: Matching using isinstance and attributes
  id: totrans-372
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 isinstance 和属性进行匹配
- en: 'If you thought the previous examples of the `match` statement were impressive,
    get ready to be completely amazed. The way the `match` statement can match instances
    including properties is amazingly powerful and can be incredibly useful. Just
    look at the following example and try to understand what is happening:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为之前的 `match` 语句示例很令人印象深刻，那么你准备好完全惊讶吧。`match` 语句可以匹配包括属性在内的实例的方式非常强大，并且可以非常实用。只需看看以下示例，并尝试理解正在发生的事情：
- en: '[PRE79]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: While I will admit that the syntax is slightly confusing and, dare I say it,
    unPythonic, it is so useful that it still makes sense.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我必须承认语法有点令人困惑，甚至可以说不够 Pythonic，但它非常实用，所以仍然有意义。
- en: Firstly, we will look at the `case Person() as person:`. We’re discussing this
    first because it is important to understand what is happening here before we continue
    with the other examples. This line is effectively identical to `if isinstance(value,
    Person):`. It does *not* actually instantiate the `Person` class at this point,
    which is a bit confusing.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将查看 `case Person() as person:`。我们首先讨论这个，因为在我们继续其他示例之前，理解这里发生的事情非常重要。这一行实际上与
    `if isinstance(value, Person):` 相同，在这个点上它并没有真正实例化 `Person` 类，这有点令人困惑。
- en: Secondly, the `case Person(name='Rick')` matches the instance type `Person`
    and it requires the instance to have an attribute `name` with value `Rick`.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，`case Person(name='Rick')` 匹配实例类型 `Person`，并且要求实例具有名为 `name` 的属性，其值为 `Rick`。
- en: Lastly, the `case Person(occupation='Programmer')` matches `value` to be a `Person`
    instance and have an attribute called `occupation` with the value `Programmer`.
    Since that attribute does not exist, it ignores that issue silently.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`case Person(occupation='Programmer')` 匹配 `value` 是一个 `Person` 实例，并且有一个名为
    `occupation` 的属性，其值为 `Programmer`。由于该属性不存在，它默默地忽略了这个问题。
- en: 'Note that this also works for built-in types and supports nesting:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这也适用于内置类型，并支持嵌套：
- en: '[PRE80]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: We have covered several examples of how the new pattern matching feature works,
    but you could think of many more. Since all parts can be nested, the possibilities
    really are endless. It might not be the perfect solution for everything, and the
    syntax might feel a little odd, but it is such a powerful solution that I would
    recommend any Python programmer learns it by heart.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了几个新模式匹配功能的工作示例，但你可能还会想到更多。由于所有部分都可以嵌套，可能性真的是无限的。这可能不是解决所有问题的完美方案，语法可能感觉有点奇怪，但它是一个非常强大的解决方案，我建议任何Python程序员都应牢记于心。
- en: Common pitfalls
  id: totrans-382
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见陷阱
- en: Python is a language meant to be clear and readable without any ambiguities
    and unexpected behaviors. Unfortunately, these goals are not achievable in all
    cases, and that is why Python does have a few corner cases where it might do something
    different than what you were expecting.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: Python是一种旨在清晰和易于阅读的语言，没有任何歧义和意外行为。不幸的是，这些目标并不是在所有情况下都能实现的，这就是为什么Python确实有一些边缘情况，它可能会做与你预期不同的事情。
- en: This section will show you some issues that you might encounter when writing
    Python code.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将向你展示在编写Python代码时可能会遇到的一些问题。
- en: Scope matters!
  id: totrans-385
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 范围很重要！
- en: There are a few cases in Python where you might not be using the scope that
    you are actually expecting. Some examples are when declaring a class and with
    function arguments, but the most annoying one is accidentally trying to overwrite
    a `global` variable.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，有些情况下你可能会没有使用你实际期望的作用域。一些例子是在声明类和函数参数时，但最令人烦恼的是意外尝试覆盖一个`global`变量。
- en: Global variables
  id: totrans-387
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 全局变量
- en: A common problem when accessing variables from the `global` scope is that setting
    a variable makes it local, even when accessing the `global` variable.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 从全局作用域访问变量时，一个常见问题是设置变量使其成为局部变量，即使是在访问全局变量时。
- en: 'This works:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点是有效的：
- en: '[PRE81]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'But the following does not:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 但以下是不正确的：
- en: '[PRE82]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The problem is that `g += 1` actually translates to `g = g + 1`, and anything
    containing `g =` makes the variable local to your scope. Since the local variable
    is being assigned at that point, it has no value yet and you are trying to use
    it.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于`g += 1`实际上翻译为`g = g + 1`，任何包含`g =`的操作都会使变量成为你作用域内的局部变量。由于在那个点正在分配局部变量，它还没有值，而你却在尝试使用它。
- en: For these cases, there is the `global` statement, although it is generally recommended
    to avoid writing to `global` variables altogether because it can make your life
    a lot more difficult while debugging. Modern editors can help a lot to track who
    or what is writing to your `global` variables, but restructuring your code so
    it purposefully passes and modifies values in a clear path can help you to avoid
    many bugs.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些情况，有`global`语句，尽管通常建议完全避免写入`global`变量，因为这可能会在调试时使你的生活变得非常困难。现代编辑器可以大量帮助跟踪谁或什么正在写入你的`global`变量，但重构你的代码，使其明确地通过清晰路径传递和修改值，可以帮助你避免许多错误。
- en: Pass by reference with mutable variables
  id: totrans-395
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可变变量的引用传递
- en: Within Python, variables are passed by reference. This means that when you do
    something like `x = y`, both `x` and `y` will point to the same variable. When
    you change the value (not the object) of either `x` or `y`, the other will change
    as well.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，变量是通过引用传递的。这意味着当你做类似`x = y`的操作时，`x`和`y`都将指向同一个变量。当你更改任一`x`或`y`的值（不是对象）时，另一个也会相应改变。
- en: Since most variable types such as strings, integers, floats, and tuples are
    immutable, this is not a problem. Doing `x = 123` won’t affect `y` since we aren’t
    changing the value of `x,` but we are replacing `x` with a new object that has
    the value `123`.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大多数变量类型，如字符串、整数、浮点数和元组是不可变的，所以这不是问题。执行`x = 123`不会影响`y`，因为我们没有改变`x`的值，而是用一个新的具有值`123`的对象替换了`x`。
- en: 'With mutable variables, however, we can change the value of the object. Let’s
    illustrate this behavior and how to work around it:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于可变变量，我们可以改变对象的值。让我们说明这种行为以及如何绕过它：
- en: '[PRE83]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Unless you explicitly copy the variable as we did with `z`, your new variable
    will point to the same object.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你明确地复制变量，就像我们用`z`做的那样，否则你的新变量将指向同一个对象。
- en: 'Now you might be wondering whether `copy()` always works. As you might suspect,
    it doesn’t. The `copy()` function only copies the object itself, not the values
    within the object. For that we have `deepcopy()`, which even handles recursion
    safely:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能想知道`copy()`是否总是有效。正如你可能猜到的，它并不总是有效。`copy()`函数只复制对象本身，而不是对象内的值。为此，我们有`deepcopy()`，它可以安全地处理递归：
- en: '[PRE84]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Mutable function default arguments
  id: totrans-403
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可变函数默认参数
- en: 'While the issues with mutable arguments can be easily avoided and seen in most
    cases, the scenario of default arguments for functions is a lot less obvious:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以轻松避免可变参数的问题，并在大多数情况下看到这些问题，但函数默认参数的情况就明显不那么明显了：
- en: '[PRE85]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Note that this is the case for `dict`, `list`, `set`, and several of the types
    in `collections`. Additionally, the classes you define yourself are mutable by
    default.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这对于`dict`、`list`、`set`以及`collections`中的几种类型都适用。此外，你自己定义的类默认是可变的。
- en: 'To work around this issue, you could consider changing the function to the
    following instead:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，你可以考虑将函数改为以下形式：
- en: '[PRE86]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Note that we had to use `if list_ is None` here. If we had done `if not list_`
    instead, it would have ignored the given `list_` if an empty `list` was passed.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在这里必须使用`if list_ is None`。如果我们使用`if not list_`，那么如果传递了一个空的`list`，它将忽略给定的`list_`。
- en: Class properties
  id: totrans-410
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类属性
- en: 'The problem of mutable variables also occurs when defining classes. It is very
    easy to mix class attributes and instance attributes. This can be confusing, especially
    when you are coming from other languages such as C#. Let’s illustrate it:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 可变变量的问题在定义类时也会出现。很容易混淆类属性和实例属性。这可能会让人感到困惑，尤其是当你来自像C#这样的其他语言时。让我们通过以下示例来说明：
- en: '[PRE87]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: As with the function arguments, the list and dictionaries are shared. So if
    you want a mutable property for a class that isn’t shared between all instances,
    you will need to define it from within the `__init__` or any other instance method.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 就像函数参数一样，列表和字典是共享的。所以，如果你想为类定义一个不共享于所有实例的可变属性，你需要在`__init__`或其他任何实例方法中定义它。
- en: 'Another important thing to note when dealing with classes is that a class property
    will be inherited, and that’s where things might prove to be confusing. When inheriting,
    the original properties will stay references (unless overwritten) to the original
    values, even in subclasses:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理类时，还有另一个需要注意的重要事项，那就是类的属性将会被继承，这可能会让人感到困惑。在继承过程中，原始属性将保持对原始值的引用（除非被覆盖），即使在子类中也是如此：
- en: '[PRE88]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: While this is to be expected due to inheritance, someone else using the class
    might not expect the variable to change in the meantime. After all, we modified
    `Parent`, not `Child`.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然由于继承这是可以预料的，但其他人使用这个类时可能不会预料到变量会在同时改变。毕竟，我们修改的是`Parent`，而不是`Child`。
- en: There are two easy ways to prevent this. It is obviously possible to simply
    set the properties for every class separately. But the better solution is never
    to modify class properties outside of the class definition. It’s easy to forget
    that the property will change in multiple locations, and if it has to be modifiable
    anyway, it’s usually better to put it in an instance variable instead.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种简单的方法可以防止这种情况。显然，你可以简单地为每个类分别设置属性。但更好的解决方案是从不修改类属性，除非在类定义之外。很容易忘记属性将在多个位置改变，而且如果它必须可修改，通常最好将其放在实例变量中。
- en: Overwriting and/or creating extra built-ins
  id: totrans-418
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 覆盖和/或创建额外的内建函数
- en: While it can be useful in some cases, generally you will want to avoid overwriting
    global functions. The PEP 8 convention for naming your functions—similar to built-in
    statements, functions, and variables—is to use a trailing underscore.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在某些情况下可能很有用，但通常你想要避免覆盖全局函数。PEP 8的函数命名约定——类似于内建语句、函数和变量——是使用尾随下划线。
- en: 'So, do not use this:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，不要这样做：
- en: '[PRE89]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Instead, use the following:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，使用以下方法：
- en: '[PRE90]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'For lists and such, this is just a good convention. For statements such as
    `from`, `import`, and `with`, it’s a requirement. Forgetting about this can lead
    to very confusing errors:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 对于列表等，这只是一个好的约定。对于`from`、`import`和`with`等语句，这是必需的。忘记这一点可能会导致非常令人困惑的错误：
- en: '[PRE91]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'If you actually want to define a built-in that is available everywhere without
    requiring an import, that is possible. For debugging purposes, I’ve been known
    to add this code to a project while developing:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你确实想定义一个在任何地方都可以使用而不需要导入的内建函数，这是可能的。为了调试目的，我在开发过程中曾将此代码添加到项目中：
- en: '[PRE92]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: This is much too hacky for production code, but it is still useful when working
    on a large project where you need print statements to debug. Alternative (and
    better) debugging solutions can be found in *Chapter 11*, *Debugging – Solving
    the Bugs*.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码对于生产环境来说过于简陋，但在处理大型项目且需要打印语句进行调试时仍然很有用。替代（且更好的）调试解决方案可以在*第11章*，*调试 – 解决错误*中找到。
- en: 'The usage is quite simple:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方法相当简单：
- en: '[PRE93]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Here is the output:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出：
- en: '[PRE94]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Modifying while iterating
  id: totrans-433
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在迭代时修改
- en: 'At one point or another, you will run into this problem: while iterating through
    some mutable objects such as `dict` and `set`, you cannot modify them. All of
    these result in a `RuntimeError` telling you that you cannot modify the object
    during iteration:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时刻，你将遇到这个问题：在迭代一些可变对象，如`dict`和`set`时，你不能修改它们。所有这些都会导致一个`RuntimeError`，告诉你不能在迭代过程中修改对象：
- en: '[PRE95]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'For a list, it does work, but can result in very strange results, so it should
    definitely be avoided as well:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 对于列表来说，这确实可行，但可能会导致非常奇怪的结果，因此绝对应该避免：
- en: '[PRE96]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'While these issues can be avoided by copying the collections before usage,
    in many cases you are doing something wrong if you run into this issue. If manipulation
    is actually needed, building a new collection is often the easier way to go because
    the code will look more obvious. Whenever someone looks at code like this in the
    future, they might try to refactor it by removing the `list()` since it looks
    futile at first glance:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些问题可以通过在使用前复制集合来避免，但在许多情况下，如果你遇到这个问题，那么你做的是错误的。如果确实需要操作，构建一个新的集合通常是更简单的方法，因为代码看起来会更明显。当未来有人查看这样的代码时，他们可能会尝试通过移除`list()`来重构它，因为乍一看这似乎是徒劳的：
- en: '[PRE97]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Catching and storing exceptions
  id: totrans-440
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 捕获和存储异常
- en: 'When catching and storing exceptions in Python, you must keep in mind that
    for performance reasons, the stored exception is local to the `except` block.
    The result is that you need to explicitly store the exception in a *different*
    variable. Simply declaring the variable before the `try`/`except` block does not
    work and will make your variable disappear:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中捕获和存储异常时，你必须记住，出于性能原因，存储的异常是`except`块本地的。结果是，你需要显式地将异常存储在*不同的*变量中。在`try`/`except`块之前简单地声明变量是不起作用的，并且会使你的变量消失：
- en: '[PRE98]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Storing the result in a new variable does work:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 将结果存储在新变量中是有效的：
- en: '[PRE99]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: As you can probably see already, this code does have a bug now. If we don’t
    end up in an exception, `new_exception` will not be defined yet. We will either
    need to add an `else` to the `try`/`except` or, better yet, pre-declare the variable
    before the `try`/`except`.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 如你或许已经看到的，这段代码现在确实有一个错误。如果我们没有遇到异常，`new_exception`还没有被定义。我们可能需要给`try`/`except`添加一个`else`，或者，更好的做法是在`try`/`except`之前预先声明变量。
- en: We really need to save it explicitly because Python 3 automatically deletes
    anything saved with `as variable` at the end of the `except` statements. The reason
    for this is that exceptions in Python 3 contain a `__traceback__` attribute. Having
    this attribute makes it much more difficult for the garbage collector to detect
    which memory should be freed as it introduces a recursive self-referencing cycle.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确实需要显式地保存它，因为Python 3在`except`语句结束时自动删除使用`as variable`保存的任何内容。原因在于Python 3中的异常包含一个`__traceback__`属性。拥有这个属性使得垃圾收集器更难检测到哪些内存应该被释放，因为它引入了递归自引用循环。
- en: Specifically, this is `exception -> traceback -> exception -> traceback ...`
    .
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，这是 `exception -> traceback -> exception -> traceback ...` 的过程。
- en: This does mean that you should keep in mind that storing these exceptions can
    introduce memory leaks into your program.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实意味着你应该记住，存储这些异常可能会将内存泄漏引入到你的程序中。
- en: The Python garbage collector is smart enough to understand that the variables
    are not visible anymore and will delete the variable eventually, but it can take
    a lot more time because it is a far more complicated garbage collection procedure.
    How the garbage collection actually works is covered in *Chapter 12*, *Performance
    – Tracking and Reducing Your Memory and CPU Usage*.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: Python的垃圾收集器足够智能，能够理解变量不再可见，并最终删除变量，但这可能需要更多的时间，因为这是一个更复杂的垃圾收集过程。垃圾收集是如何实际工作的，在*第12章*，*性能
    – 跟踪和减少你的内存和CPU使用*中有详细说明。
- en: Late binding and closures
  id: totrans-450
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态绑定和闭包
- en: 'Closures are a method of implementing local scopes in code. They make it possible
    to locally define variables without overriding variables in the parent (or global)
    scope and hide the variables from the outside scope later. The problem with closures
    in Python is that Python tries to bind its variables as late as possible for performance
    reasons. While generally useful, it does have some unexpected side effects:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包是实现代码中局部作用域的一种方法。它们使得可以在局部定义变量而不覆盖父（或全局）作用域中的变量，并在之后将变量隐藏在外部作用域中。Python中闭包的问题在于，Python为了性能原因尽可能晚地绑定其变量。虽然通常很有用，但它确实有一些意外的副作用：
- en: '[PRE100]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: You were probably expecting `0, 1, 2` instead. Due to late binding, however,
    all functions get the last value of `i` instead, which is `2`.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能期望的是 `0, 1, 2`，但由于延迟绑定，所有函数都获取 `i` 的最后一个值，即 `2`。
- en: 'What should we do instead? As with the cases in earlier paragraphs, the variable
    needs to be made local. One option is to force immediate binding by currying the
    function with `partial`:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该怎么做呢？与前面段落中的情况一样，变量需要被本地化。一个选项是通过使用 `partial` 强制立即绑定函数：
- en: '[PRE101]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: A better solution would be to avoid binding problems altogether by not introducing
    extra scopes (the `lambda`) that use external variables. If `i` is specified as
    an argument to `lambda`, this will not be a problem.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的解决方案是避免绑定问题，不引入额外的作用域（如 `lambda`）使用外部变量。如果将 `i` 指定为 `lambda` 的参数，这就不会是问题。
- en: Circular imports
  id: totrans-457
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 循环导入
- en: Even though Python is fairly tolerant of circular imports, there are some cases
    where you will get errors.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Python对循环导入相当宽容，但仍然有一些情况下你会遇到错误。
- en: 'Let’s assume we have two files:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有两个文件：
- en: '`T_28_circular_imports_a.py`:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '`T_28_circular_imports_a.py`:'
- en: '[PRE102]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '`T_28_circular_imports_b.py`:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '`T_28_circular_imports_b.py`:'
- en: '[PRE103]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Running either of these files results in a circular import error:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这些文件中的任何一个都会导致循环导入错误：
- en: '[PRE104]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: There are several ways to work around this problem. The simplest solution is
    to move the `import` statement so the circular import doesn’t occur anymore. In
    this case, the `import` in import `T_28_circular_imports_a.py` needs to be moved
    between `FileA` and `FileB`.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法有几个。最简单的解决方案是将 `import` 语句移动，使得循环导入不再发生。在这种情况下，`import T_28_circular_imports_a.py`
    需要在 `FileA` 和 `FileB` 之间移动。
- en: 'In most cases, the better solution is to restructure the code, however. Move
    the common base class to a separate file so there is no need for a circular import
    anymore. For the example above, that would look something like this:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，更好的解决方案是重构代码。将公共基类移动到单独的文件中，这样就不需要再进行循环导入了。对于上面的例子，它看起来可能像这样：
- en: '`T_29_circular_imports_a.py`:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '`T_29_circular_imports_a.py`:'
- en: '[PRE105]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '`T_29_circular_imports_b.py`:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: '`T_29_circular_imports_b.py`:'
- en: '[PRE106]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '`T_29_circular_imports_c.py`:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '`T_29_circular_imports_c.py`:'
- en: '[PRE107]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: If that is also not possible, it can be useful to import from a function at
    runtime instead of at import time. Naturally this is not an easy option for class
    inheritance, but if you only need the import at runtime, you can defer the importing.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这也行不通，可以在运行时而不是导入时从函数中导入，这可能很有用。当然，这对于类继承来说不是一个容易的选择，但如果你只需要在运行时导入，你可以推迟导入。
- en: Lastly, there is the option of dynamic imports, such as what the Django framework
    uses for the `ForeignKey` fields. In addition to actual classes, the `ForeignKey`
    fields also support strings, which will be imported automatically when needed.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还有动态导入的选项，例如Django框架用于 `ForeignKey` 字段的选项。除了实际的类之外，`ForeignKey` 字段还支持字符串，这些字符串在需要时将自动导入。
- en: While this is a very effective way of working around the problem, it does mean
    that your editor, linting tools, and other tools won’t understand the object you
    are dealing with. To those tools, it will look like a string, so unless specific
    hacks are added to those, they will not assume the value to be anything besides
    a string.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一个非常有效的解决方法，但它确实意味着你的编辑器、linting工具和其他工具不会理解你正在处理的对象。对这些工具来说，它看起来就像一个字符串，所以除非为这些工具添加特定的黑客技巧，否则它们不会假设值除了字符串之外的其他任何内容。
- en: In addition, because the `import` only happens at runtime, you will not notice
    import problems until you execute the function. That means that errors that normally
    would have presented themselves as soon as you run the script or application will
    now only show up when the function is called. This is a great recipe for hard-to-trace
    bugs that won’t occur for you but will for other users of the code.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于 `import` 只在运行时发生，你只有在执行函数时才会注意到导入问题。这意味着那些通常会在你运行脚本或应用程序时立即出现的错误现在只有在调用函数时才会显示出来。这是一个很好的难以追踪的bug配方，它不会发生在你身上，但会发生在其他代码使用者身上。
- en: 'The pattern is still useful for cases such as plugin systems, however, as long
    as care is taken to avoid the caveats mentioned. Here’s a simple example to import
    dynamically:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式对于插件系统等场景仍然很有用，但只要小心避免提到的注意事项。这里有一个简单的例子来动态导入：
- en: '[PRE108]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Using `importlib`, it is fairly easy to dynamically `import` a module and by
    using `getattr`, you can get a specific object from the module.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `importlib`，动态导入模块相当容易，通过使用 `getattr`，你可以从模块中获取特定的对象。
- en: Import collisions
  id: totrans-481
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入冲突
- en: One problem that can be extremely confusing is having colliding imports—multiple
    packages/modules with the same name. I have had more than a few bug reports on
    my packages about cases like these.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: My `numpy-stl` project, for example, houses the code in a package named `stl`.
    Many people create a test file named `stl.py`. When importing `stl` from `stl.py`,
    it will import itself instead of the `stl` package.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: In addition to this, there is also the problem of packages being incompatible
    with each other. Common names might be used by several packages, so be careful
    when installing a bunch of similar packages since they might be sharing the same
    name. When in doubt, just create a new virtual environment and try again. Doing
    this can save you a lot of debugging.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-485
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter showed you what the Pythonic philosophy is all about and some of
    the reasoning behind it. Additionally, you have learned about the Zen of Python
    and what is considered beautiful and ugly within the Python community. While code
    style is highly personal, Python has a few very helpful guidelines that at least
    keep people mostly on the same page and style.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: In the end, we are all consenting adults; everyone has the right to write code
    as they sees fit. But I do request that you please read through the style guides
    and try to adhere to them unless you have a really good reason not to.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: With all that power comes great responsibility, and a few pitfalls, though there
    aren’t too many. Some are tricky enough to fool me regularly and I’ve been writing
    Python for a long time! Python improves all the time though. Many pitfalls have
    been taken care of since Python 2, but some will always remain. For example, circular
    imports and definitions can easily bite you in most languages that support them,
    but that doesn’t mean we’ll stop trying to improve Python.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: A good example of the improvements in Python over the years is the `collections`
    module. It contains many useful collections that have been added by users because
    there was a need. Most of them are actually implemented in pure Python, and because
    of that, they are easy enough to be read by anyone. Understanding them might take
    a bit more effort, but I truly believe that if you make it to the end of this
    book, you will have no problem understanding what the collections do. Fully understanding
    how the internals work is something I cannot promise, though; some parts of that
    speak more to generic computer science than Python mastery.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will show you some of the collections available in Python and
    how they are constructed internally. Even though you are undoubtedly familiar
    with collections such as lists and dictionaries, you might not be aware of the
    performance characteristics involved with some of the operations. If some of the
    examples in this chapter were less than clear, you don’t have to worry. The next
    chapter will at least revisit some of them, and more will come in later chapters.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: Join our community on Discord
  id: totrans-491
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers: [https://discord.gg/QMzJenHuJf](https://discord.gg/QMzJenHuJf)'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的 Discord 空间，与作者和其他读者进行讨论：[https://discord.gg/QMzJenHuJf](https://discord.gg/QMzJenHuJf)
- en: '![](img/QR_Code156081100001293319171.png)'
  id: totrans-493
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code156081100001293319171.png)'
