<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch10"/>Chapter 10. The Final Project – a Remote Home Monitoring System</h1></div></div></div><p>It is now time to combine every topic that we learned in the previous chapters into a project that combines <a id="id959" class="indexterm"/>Arduino programming, Python GUI development, MQTT messaging protocol, and a Python-based cloud application. As you might have already figured out from the chapter title, we are going to develop a remote home monitoring system using these components.</p><p>The first section of the chapter covers the project design process, including goals, requirements, architecture, and UX. Once we are done with the design process, we will jump into the actual development of the project, which is divided into three separate stages. Next, we will cover common troubleshooting topics that are usually faced while working with large projects. In our efforts to develop utilizable DIY projects, the later section covers tips and features to extend the project. As this is quite a large project compared to other projects in the book, we are not going to jump straight into the actual development process without having any strategy. Let's start by getting ourselves familiar with the standard design methodology for hardware projects.</p><div><div><div><div><h1 class="title"><a id="ch10lvl1sec65"/>The design methodology for IoT projects</h1></div></div></div><p>The process of <a id="id960" class="indexterm"/>developing<a id="id961" class="indexterm"/> a complex product that tightly couples hardware devices with high-level software services requires an additional level of planning. For this project, we will exercise a proper product development approach to help you get familiar with the process of creating real-world hardware projects. This method can then be used to plan your own projects and take them to the next level. The following diagram describes a typical prototype development process, which always begins by defining the major goals that you want to achieve with your product:</p><div><img src="img/5938OS_10_01.jpg" alt="The design methodology for IoT projects"/></div><p>Once you have defined the set of major goals, you need to break them down into project requirements that include every detail of the tasks that your prototype should execute to achieve these goals. Using the project requirements, you need to sketch out the overall architecture of the system. The next step includes the process of defining the UX flow that will help you to lay out the user interaction points for your system. At this stage, you will be able to identify any changes that are required in the system architecture and the hardware and software components to start the development.</p><p>As you have defined the interaction points, now you need to distribute the entire project development process into multiple stages and delegate the tasks between these stages. Once<a id="id962" class="indexterm"/> you have completed the development of these stages, you will have to interface these stages with each other according to your architecture and debug the components<a id="id963" class="indexterm"/> if it is needed. At the end, you will have to test your project as a whole system and troubleshoot minor problems. In hardware projects, it is very difficult to work on your electric circuits again after the completion of complex development processes, as the changes can have recurring effects on all other components. This process will help you to minimize any hardware rework and subsequent software modifications.</p><p>Now that you have learned about the methodology, let's begin with the actual development process for our remote home monitoring system.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec66"/>Project overview</h1></div></div></div><p>The smart home is <a id="id964" class="indexterm"/>one of the most well-defined and popular subdomains of the IoT. The most important feature of any smart home is its capability to monitor the physical environment. Fortunately, the exercises and projects that we covered in the previous chapters include components and features that can be used for the same purpose. In this chapter, we are going to define a project that will utilize these existing components and programming exercises. In the midterm project of <a class="link" href="ch07.html" title="Chapter 7. The Midterm Project – a Portable DIY Thermostat">Chapter 7</a>, <em>The Midterm Project – a Portable DIY Thermostat</em>, we created a deployable thermostat with the ability to measure temperature, humidity, and ambient light. If we want to utilize this midterm project, the nearest IoT project that we can build on top of it is the remote home monitoring system. The project will have Arduino as the main point of interaction between the physical environment and the software-based services. We will have a Python program as the middle layer, which will bridge the sensor information coming from Arduino with the user-facing graphical interface. Let's start by defining the goals that we want to achieve and the project requirements to satisfy these goals.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec128"/>The project goals</h2></div></div></div><p>The <a id="id965" class="indexterm"/>Nest thermostat provides an idea of the type of features that a properly designed remote monitoring system with professional features should have. Achieving this level of system capabilities requires a lot of development effort from a large team. Although it will be difficult to include each of the features that are supported by a commercial system in our project, we will still try to implement the common features that can be incorporated by a prototype project.</p><p>The top-level features that we are planning to incorporate in this project can be described by the following goals.</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Observe the physical environment and make it accessible remotely</li><li class="listitem" style="list-style-type: disc">Provide basic level controls to the user to interact with the system</li><li class="listitem" style="list-style-type: disc">Demonstrate a primitive level of built-in situational awareness</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec129"/>The project requirements</h2></div></div></div><p>Now that we <a id="id966" class="indexterm"/>have defined the major goals, let's convert them into detailed system requirements. On the completion of the project, the system should be able to satisfy the following requirements:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It must be able to observe physical phenomenon such as temperature, humidity, motion, and ambient light.</li><li class="listitem" style="list-style-type: disc">It should provide local access to sensor information and control over actuators such as a buzzer, a button switch, and an LED.</li><li class="listitem" style="list-style-type: disc">The monitoring should be done by a unit that is developed using the open source hardware platform, Arduino.</li><li class="listitem" style="list-style-type: disc">The monitoring unit should be limited to collect sensor information and communicate it to the control unit.</li><li class="listitem" style="list-style-type: disc">The control unit should not comprise of a desktop computer or laptop. Instead, it should be made deployable using a platform such as a Raspberry Pi.</li><li class="listitem" style="list-style-type: disc">The control unit should demonstrate a primitive level of situation awareness capability by utilizing the collected sensor information.</li><li class="listitem" style="list-style-type: disc">The control unit should have a graphical interface to provide the sensor's observation and the current state of the system.</li><li class="listitem" style="list-style-type: disc">The system must be accessible via the Internet using cloud-based services.</li><li class="listitem" style="list-style-type: disc">The web application that provides remote access should have the capability to display the sensor's observations through a web browser.</li><li class="listitem" style="list-style-type: disc">The system should also provide basic control of the actuators to complete the remote access experience by using the web application.</li><li class="listitem" style="list-style-type: disc">As the monitoring unit can be constrained by computation resources, the system should use hardware-oriented messaging protocols to transfer information.</li></ul></div><p>Although there are many other minor requirements that can be part of our project, they have been skipped in this book. If you have any additional plans for your remote home <a id="id967" class="indexterm"/>monitoring system, this is the time that you must define these requirements before you jump into designing the architecture. Any future changes to the requirements can significantly affect the development stage and make hardware and software modification difficult. In the last section of the chapter, we have laid down a number of additional features that you may want to consider implementing for your future projects.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec130"/>Designing system architecture</h2></div></div></div><p>Continuing from <a id="id968" class="indexterm"/>project <a id="id969" class="indexterm"/>goals, first, you need to sketch out a high-level architecture of the system. This architectural sketch should include major components that enable the system to pass on information between the sensors and the remote users. The following figure shows an architectural sketch for our project:</p><div><img src="img/5938OS_10_02.jpg" alt="Designing system architecture"/></div><p>According to the goals, the user should be able to access the system using the Internet; this means that we need cloud components in the architecture. The system also needs to monitor the physical environment using a resource-constrained device, and this can be executed using Arduino. The middle layer, which connects the cloud service and the sensor system, can be built using a Raspberry Pi. In the last project, we connected Arduino and the Raspberry Pi using a serial connection, but we want to move away from serial connections and start using our home's Ethernet network to make the system deployable. Hence, the Arduino-based unit is connected to the network using Ethernet while the Raspberry Pi uses Wi-Fi to connect to the same network.</p><p>In order to lay out the overall system architecture, let's utilize the sketch that we designed, which can be <a id="id970" class="indexterm"/>seen in the preceding figure. As you can see in the next figure, we have converted the overall system into three main architectural units:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Monitoring station</li><li class="listitem" style="list-style-type: disc">Control center</li><li class="listitem" style="list-style-type: disc">Cloud service</li></ul></div><p>In this figure, we <a id="id971" class="indexterm"/>have addressed each and every major component that we are going to utilize in the project along with their association to each other. In the following sections, we are going to define these three main units briefly. The comprehensive description and implementation steps for these units are provided later in the chapter under separate sections.</p><div><img src="img/5938OS_10_03.jpg" alt="Designing system architecture"/></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec113"/>The monitoring station</h3></div></div></div><p>We need a resource-constrained <a id="id972" class="indexterm"/>and robust unit that will communicate with the physical environment periodically. This monitoring unit can be built using Arduino since low-level microcontroller programming can provide uninterrupted stream of sensor data. The usage of Arduino at this stage will also help us to avoid the direct interfacing of basic low-level sensors with computers that are running on complex operating systems. The sensors and the actuators are connected to Arduino using digital, analog, PWM, and I2C interfaces.</p></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec114"/>The control center</h3></div></div></div><p>The control center <a id="id973" class="indexterm"/>behaves as the main user interaction point between the sensor information and the user. It is also responsible for conveying the sensor information from the monitoring station to the cloud services. The control center can be developed using your regular computer or a single-board computer such as a Raspberry Pi. We are going to utilize a Raspberry Pi since it can be easily deployed as a hardware unit and it is also capable enough at hosting Python programs. We will replace a computer screen with a small TFT LCD screen for the Raspberry Pi to display the GUI.</p></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec115"/>The cloud services</h3></div></div></div><p>The main purpose <a id="id974" class="indexterm"/>of the cloud services is to provide an Internet-based interface for the control center so that the user can access it remotely. Before we host a web application to perform this operation, we will need an intermediate data relay. This sensor data relay works as a host between the cloud-based web application and the control center. In this project, we will be using Xively as the platform to collect this sensor data. The web application can be hosted on an Internet server; in our case, we are going to use Amazon AWS due to our familiarity with it.</p></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec131"/>Defining UX flow</h2></div></div></div><p>Now, although we <a id="id975" class="indexterm"/>know what the architecture of the overall system looks like, we haven't defined how the user is going to interact with it. This process of designing user interaction for our system will also help us to figure out data flow between major components.</p><p>Let's begin with the components that are operating locally at your house, that is, the monitoring station and the control center. As you can see from the following figure, we have our first user interaction point at the control center. The user can observe the information or act upon it if the system's status is an alert. The user action to dismiss the alert prompts <a id="id976" class="indexterm"/>multiple operations to take place at the control center and the monitoring station. We recommend you thoroughly examine the figure to better understand the flow of the system.</p><div><img src="img/5938OS_10_04.jpg" alt="Defining UX flow"/></div><p>Similarly, the second user interaction point is located at the web application. The web application displays the observations and system's status that we calculated at the control center and provides an interface to dismiss the alert. In this scenario, the dismiss action will travel through Xively to the control center where the appropriate actions for the control center will remain the same as in the previous scenario. However, in the web application, the user has to load the web browser every time to request the data, which was happening automatically at the control center. Take a look at the following figure to understand the UX flow for the web application:</p><div><img src="img/5938OS_10_05.jpg" alt="Defining UX flow"/></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec132"/>The list of required components</h2></div></div></div><p>The necessary <a id="id977" class="indexterm"/>components <a id="id978" class="indexterm"/>for the project are derived using three main criteria:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Ease of availability</li><li class="listitem" style="list-style-type: disc">Compatibility with the Arduino board</li><li class="listitem" style="list-style-type: disc">Familiarity with the components due to previous utilization in this book</li></ul></div><p>This is the list of the components that you will need to start working on the project. If you have completed the previous exercises and projects, you should already have most of the components. If you don't want to disassemble the projects, you can obtain them from the websites of SparkFun, Adafruit, or Amazon, whose links are provide in the next table.</p><p>The hardware components <a id="id979" class="indexterm"/>for the monitoring station are as follows:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Component (first stage)</p>
</th><th style="text-align: left" valign="bottom">
<p>Quantity</p>
</th><th style="text-align: left" valign="bottom">
<p>Link</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Arduino Uno</p>
</td><td style="text-align: left" valign="top">
<p>1</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="https://www.sparkfun.com/products/11021">https://www.sparkfun.com/products/11021</a>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Arduino Ethernet Shield</p>
</td><td style="text-align: left" valign="top">
<p>1</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="https://www.sparkfun.com/products/9026">https://www.sparkfun.com/products/9026</a>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Breadboard</p>
</td><td style="text-align: left" valign="top">
<p>1</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="https://www.sparkfun.com/products/9567">https://www.sparkfun.com/products/9567</a>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>TMP102 temperature sensor</p>
</td><td style="text-align: left" valign="top">
<p>1</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="https://www.sparkfun.com/products/11931">https://www.sparkfun.com/products/11931</a>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>HIH-4030 humidity sensor</p>
</td><td style="text-align: left" valign="top">
<p>1</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="https://www.sparkfun.com/products/9569">https://www.sparkfun.com/products/9569</a>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Mini photocell</p>
</td><td style="text-align: left" valign="top">
<p>1</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="https://www.sparkfun.com/products/9088">https://www.sparkfun.com/products/9088</a>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>PIR motion sensor</p>
</td><td style="text-align: left" valign="top">
<p>1</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="https://www.sparkfun.com/products/8630">https://www.sparkfun.com/products/8630</a>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Super-flux RGB LED, common anode</p>
</td><td style="text-align: left" valign="top">
<p>1</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="http://www.adafruit.com/product/314">http://www.adafruit.com/product/314</a>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Buzzer</p>
</td><td style="text-align: left" valign="top">
<p>1</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="http://www.adafruit.com/products/160">http://www.adafruit.com/products/160</a>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Push button switch</p>
</td><td style="text-align: left" valign="top">
<p>1</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="https://www.sparkfun.com/products/97">https://www.sparkfun.com/products/97</a>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>USB cable for Arduino</p>
<p>(for development stage)</p>
</td><td style="text-align: left" valign="top">
<p>1</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="https://www.sparkfun.com/products/512">https://www.sparkfun.com/products/512</a>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Arduino power supply</p>
<p>(for deployment stage)</p>
</td><td style="text-align: left" valign="top">
<p>1</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="http://www.amazon.com/Arduino-9V-1A-Power-Adapter/dp/B00CP1QLSC/">http://www.amazon.com/Arduino-9V-1A-Power-Adapter/dp/B00CP1QLSC/</a>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Resistors</p>
</td><td style="text-align: left" valign="top">
<p>As required</p>
</td><td style="text-align: left" valign="top">
<p>220 ohm, 1 kilo-ohm, and 10 kilo-ohm</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Connection wires</p>
</td><td style="text-align: left" valign="top">
<p>As required</p>
</td><td style="text-align: left" valign="top"> </td></tr></tbody></table></div><p>The hardware components <a id="id980" class="indexterm"/>for the control center are as follows:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Component (first stage)</p>
</th><th style="text-align: left" valign="bottom">
<p>Quantity</p>
</th><th style="text-align: left" valign="bottom">
<p>Link</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Raspberry Pi</p>
</td><td style="text-align: left" valign="top">
<p>1</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="https://www.sparkfun.com/products/11546">https://www.sparkfun.com/products/11546</a>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>TFT LCD screen</p>
</td><td style="text-align: left" valign="top">
<p>1</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="http://www.amazon.com/gp/product/B00GASHVDU/">http://www.amazon.com/gp/product/B00GASHVDU/</a>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>SD card (8 GB)</p>
</td><td style="text-align: left" valign="top">
<p>1</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="https://www.sparkfun.com/products/12998">https://www.sparkfun.com/products/12998</a>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Wi-Fi dongle</p>
</td><td style="text-align: left" valign="top">
<p>1</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="http://www.amazon.com/Edimax-EW-7811Un-150Mbps-Raspberry-Supports/dp/B003MTTJOY">http://www.amazon.com/Edimax-EW-7811Un-150Mbps-Raspberry-Supports/dp/B003MTTJOY</a>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Raspberry Pi power supply</p>
</td><td style="text-align: left" valign="top">
<p>1</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="http://www.amazon.com/CanaKit-Raspberry-Supply-Adapter-Charger/dp/B00GF9T3I0">http://www.amazon.com/CanaKit-Raspberry-Supply-Adapter-Charger/dp/B00GF9T3I0</a>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Keyboard, mouse, USB hub, and monitor</p>
</td><td style="text-align: left" valign="top">
<p>As required</p>
</td><td style="text-align: left" valign="top">
<p>Requried for development and debugging stages</p>
</td></tr></tbody></table></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec133"/>Defining the project development stages</h2></div></div></div><p>As per the <a id="id981" class="indexterm"/>system <a id="id982" class="indexterm"/>architecture, we have three main units that collaboratively create the remote home monitoring project. The overall hardware and software development process is also aligned with these three units and can be distributed as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Monitoring station development stage</li><li class="listitem" style="list-style-type: disc">Control center development stage</li><li class="listitem" style="list-style-type: disc">Web application development stage</li></ul></div><p>The software development for the monitoring station stage includes developing the Arduino code to monitor sensors and perform actuator actions on one side, while publishing this information to the control center on the other side. The middle layer of the development stage, that is, the Raspberry Pi-based control center, hosts the Mosquitto broker. This stage also contains the Python program that contains the GUI, situation awareness logic, and subroutines to communicate with the Xively cloud service. The last stage, the cloud services, includes two distinct components, sensor data relay and a web application. We will be using the Xively platform as our sensor data relay and the web application will be developed in Python on the Amazon AWS cloud instance. Now, let's jump into the actual development process and our first stop will be the Arduino-based monitoring station.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec67"/>Stage 1 – a monitoring station using Arduino</h1></div></div></div><p>As we discussed, the <a id="id983" class="indexterm"/>main tasks <a id="id984" class="indexterm"/>of the monitoring systems are to interface sensor components and communicate the information generated by these sensors to the observers. You will be using Arduino Uno as the central microcontroller component to integrate these sensors and actuators. We also need a means of communication between the Arduino Uno and the control center and we will be utilizing the Arduino Ethernet Shield for this purpose. Let's discuss the hardware architecture of the monitoring station and its components.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec134"/>Designing the monitoring station</h2></div></div></div><p>We already designed <a id="id985" class="indexterm"/>units based on Arduino and the Ethernet Shield in various exercises in <a class="link" href="ch08.html" title="Chapter 8. Introduction to Arduino Networking">Chapter 8</a>, <em>Introduction to Arduino Networking</em>, and <a class="link" href="ch09.html" title="Chapter 9. Arduino and the Internet of Things">Chapter 9</a>, <em>Arduino and the Internet of Things</em>. Therefore, we have assumed that you are familiar with interfacing the Ethernet Shield with the Arduino board. We will connect various sensors and actuators with the Arduino board, as displayed in the following diagram. As you can see in this diagram, the sensors will provide the data to the Arduino board while the actuators will seek the data from the Arduino board. Although we are automatically collecting environment data for these sensors, the data from the button will be collected from manual user inputs.</p><div><img src="img/5938OS_10_06.jpg" alt="Designing the monitoring station"/></div><p>Check out the following Fritzing diagram for the detailed connections in the monitoring station. As you can see in our hardware design, the temperature sensor TMP102 is connected through the I2C interface, which means that we will need the SDA and SCL lines. We will be using analog pins 5 and 6 of the Arduino board to interface SDA and SCL respectively. The humidity (HIH-4030) and ambient light sensors also provide analog output and are connected to the analog pins of the Arduino board. Meanwhile, the buzzer, the button switch, and the PIR motion sensor are connected through the digital I/O pins. The super-flux RGB LED is a common anode LED; this means that it is always powered using the common anode pins and the R, G, and B pins are controlled by using the PWM pins.</p><p>Make sure that you properly connect all the components to the pins that are specified in the following<a id="id986" class="indexterm"/> diagram:</p><div><img src="img/5938OS_10_07.jpg" alt="Designing the monitoring station"/></div><div><div><h3 class="title"><a id="note54"/>Note</h3><p>You can learn more about the interfacing of RGB LED with Arduino from the tutorial at <a class="ulink" href="https://learn.adafruit.com/all-about-leds">https://learn.adafruit.com/all-about-leds</a>.</p></div></div><p>If you are using an Arduino board other than Arduino Uno, you will have to adjust the appropriate pin numbers in the Arduino code. In addition, make sure that this Arduino board is compatible with the Ethernet Shield.</p><p>In terms of circuit connections, you can use a breadboard as shown in the previous diagram, or if you are comfortable, you can use a PCB prototype board and solder the <a id="id987" class="indexterm"/>components. In our setup, we first tested the components on the breadboard and once they were tested, we soldered the components, as shown in the following figure. If you venture to solder the PCB board, make sure that you have the necessary components for the job. The PCB prototype will yield a robust performance compared to the breadboard, but it will also make it difficult for you to debug and change the components afterwards.</p><div><img src="img/5938OS_10_08.jpg" alt="Designing the monitoring station"/></div><p>If you are ready with your circuit connection, connect your Arduino to your computer using the USB cable. Also, connect the Ethernet Shield to your home router using an Ethernet cable.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec135"/>The Arduino sketch for the monitoring station</h2></div></div></div><p>Before<a id="id988" class="indexterm"/> jumping into the <a id="id989" class="indexterm"/>coding stage, make sure that you have collected the prebuilt Arduino code for the project. You can find it in the code folder of this chapter with the filename <code class="literal">Arduino_monitoring_station.ino</code>. The code implements the necessary logic to support the overall UX flow at the monitoring station, which we discussed in the previous section. In the following sections, we will go through the major areas of the program so that you can better understand these code snippets. Now, open this sketch in the Arduino IDE. You are already familiar with setting up the IP address for Arduino. You also learned how to use the Arduino MQTT library <code class="literal">PubSubClient</code> in the previous chapter, which means that your Arduino IDE should already have the <code class="literal">PubSubClient</code> library installed on it. At the beginning of the code, we have also declared few constants, such as the IP addresses of the MQTT server and Arduino and the pin numbers of various sensor and actuators.</p><div><div><h3 class="title"><a id="note55"/>Note</h3><p>You will have to change the IP address of the monitoring station and the control center according to your network setup. Make sure that you perform these modifications before uploading the Arduino code.</p></div></div><p>In the code structure, we have two mandatory Arduino functions, <code class="literal">setup()</code> and <code class="literal">loop()</code>. In the <code class="literal">setup()</code> function, we will set up the Arduino pin types and the MQTT subscriber channels. In the same function, we will also attach an interrupt for the press of the button while setting up the timer for the <code class="literal">publishData()</code> function.</p><div><div><div><div><h3 class="title"><a id="ch10lvl3sec116"/>Publishing sensor information</h3></div></div></div><p>The <code class="literal">publishData()</code> function <a id="id990" class="indexterm"/>reads the sensor inputs and publishes this data to the Mosquitto broker that is located on the control center. As you can see in the following code snippet, we are measuring sensors values one by one and publishing them to the broker using the <code class="literal">client.publish()</code> method:</p><div><pre class="programlisting">void publishData (){
    Wire.requestFrom(partAddress,2);
    byte MSB = Wire.read();
    byte LSB = Wire.read();
    
    int TemperatureData = ((MSB &lt;&lt; 8) | LSB) &gt;&gt; 4; 
  
    float celsius = TemperatureData*0.0625;
    temperatureC = dtostrf(celsius, 5, 2, message_buff2);
    client.publish("MonitoringStation/temperature", temperatureC);
    
    float humidity = getHumidity(celsius);
    humidityC = dtostrf(humidity, 5, 2, message_buff2);
    client.publish("MonitoringStation/humidity", humidityC);

    int motion = digitalRead(MotionPin);
    motionC = dtostrf(motion, 5, 2, message_buff2);
    client.publish("MonitoringStation/motion", motionC);
    
    int light = analogRead(LightPin);
    lightC = dtostrf(light, 5, 2, message_buff2);
    client.publish("MonitoringStation/light", lightC);
}</pre></div><p>If you check <a id="id991" class="indexterm"/>out the <code class="literal">setup()</code> function, you will notice that we have used a library called <code class="literal">SimpleTimer</code> to set up a <code class="literal">timer</code> method for this function. This method executes the <code class="literal">publishData()</code> function periodically without interrupting and blocking the actual flow of the Arduino execution cycle. In the following code snippet, the number <code class="literal">300000</code> represents the time delay in milliseconds, that is, 5 minutes:</p><div><pre class="programlisting">timer.setInterval(300000, publishData);</pre></div><div><div><h3 class="title"><a id="note56"/>Note</h3><p>You will need to download and import the <code class="literal">SimpleTimer</code> library to compile and run the code successfully. You can download the library from <a class="ulink" href="https://github.com/infomaniac50/SimpleTimer">https://github.com/infomaniac50/SimpleTimer</a>.</p></div></div></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec117"/>Subscribing to actuator actions</h3></div></div></div><p>You can<a id="id992" class="indexterm"/> see in the <code class="literal">setup()</code> function that we are initializing the code by subscribing to the <code class="literal">MonitoringStation/led</code> and <code class="literal">MonitoringStation/buzzer</code> channels. The <code class="literal">client.subscribe()</code> method will make sure that whenever the Mosquitto broker gets any updates for these channels, the Arduino-based monitoring system gets notified:</p><div><pre class="programlisting">if (client.connect("MonitoringStation")) {
    client.subscribe("MonitoringStation/led");
    client.subscribe("MonitoringStation/buzzer");
  }</pre></div></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec118"/>Programming an interrupt to handle the press of a button</h3></div></div></div><p>We have taken <a id="id993" class="indexterm"/>care of the publishing and subscribing functions of the monitoring station. Now, we will need to integrate the button switch that is controlled by inputs from the user. In the Arduino programming routines, we run a periodic loop to check the status of the pins. However, this may not be useful if the button is pressed since it requires immediate action. This action of pressing the button is handled using the Arduino interrupts, as shown in the following line of code:</p><div><pre class="programlisting">attachInterrupt(0, buttonPress, RISING);</pre></div><p>The preceding line of code associates an interrupt at pin 0 (digital pin 2) with the <code class="literal">buttonPress()</code> function. This function sets off the buzzers whenever the state of the interrupt is changed. In other words, when the button is pressed by the user, the buzzer will be instantaneously turned off irrespective of the current status of the buzzer:</p><div><pre class="programlisting">void buttonPress(){
    digitalWrite(BUZZER, LOW);
    Serial.println("Set buzzer off");
}</pre></div></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec136"/>Testing</h2></div></div></div><p>The current <a id="id994" class="indexterm"/>Arduino code communicates with the control center for publishing and subscribing the data, but we haven't yet set up the Mosquitto broker to handle these requests. You can still go ahead and upload the Arduino sketch to your monitoring station using the USB cable. This will not result in any fruitful actions from the monitoring station and you will only be able to use the <code class="literal">Serial.prinln()</code> command to print various sensor measurements. Therefore, we will develop the control center next so that we can start addressing communication requests from the monitoring station.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec68"/>Stage 2 – a control center using Python and the Raspberry Pi</h1></div></div></div><p>In order to<a id="id995" class="indexterm"/> deliver the<a id="id996" class="indexterm"/> status of the system and other sensor observations to the user, the control center needs to perform various operations that include obtaining raw sensor data from the monitoring station, calculating the status of the system, reporting this data to the cloud services, and displaying observation using GUI. While the control center includes two major hardware components (the Raspberry Pi and TFT LCD screen), it is also comprised of two major software components (the Mosquitto broker and Python code) to handle the control center logic.</p><div><div><h3 class="title"><a id="tip16"/>Tip</h3><p>We are using a Raspberry Pi instead of a regular computer as we want the control center to be a deployable and portable unit that can be mounted on a wall.</p><p>You can still use your own computer to edit and test the Python code for development purposes instead of using a Raspberry Pi directly. However, we recommend that you switch back to the Raspberry Pi once you are ready for deployment.</p></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec137"/>The control center architecture</h2></div></div></div><p>The <a id="id997" class="indexterm"/>Raspberry Pi is the main computation unit of the control center and works as the brain of the entire system. Since the Raspberry Pi is used as a replacement for a regular computer, the architecture of the control center can interchangeably use a computer in place of the Raspberry Pi. As you can see in the following diagram, the control center is connected to the home network using Wi-Fi and this will make it accessible to the monitoring station. The control center includes the Mosquitto broker; this is used as the communication point between the monitoring station and the Python program for the control center. The Python program utilizes the <code class="literal">Tkinter</code> library for GUI and the <code class="literal">paho_mqtt</code> library to communicate with the Mosquitto broker. By utilizing these two libraries, we can convey sensor information from the monitoring station to the user. However, we will need a separate arrangement to establish communication between the control center and cloud services. In our overall system architecture, the control center is designed to communicate with the intermediate data relay, Xively. The Python code uses the <code class="literal">xively-python</code> library to enable this communication.</p><div><img src="img/5938OS_10_09.jpg" alt="The control center architecture"/></div><p>In <a class="link" href="ch08.html" title="Chapter 8. Introduction to Arduino Networking">Chapter 8</a>, <em>Introduction to Arduino Networking</em>, we already provided you with methods to install the <a id="id998" class="indexterm"/>Mosquitto broker, the <code class="literal">Python-mosquitto</code> library, and the <code class="literal">xively-python</code> library. We also learned the process of setting up the TFT LCD screen with the Raspberry Pi in <a class="link" href="ch07.html" title="Chapter 7. The Midterm Project – a Portable DIY Thermostat">Chapter 7</a>, <em>The Midterm Project – a Portable DIY Thermostat</em>. Please refer to those tutorials in case you haven't completed those exercises yet. Assuming that you have configured the Mosquitto broker and the required Python libraries, you can move on to the next section, which includes the actual Python programming.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec138"/>The Python code for the control center</h2></div></div></div><p>Before you <a id="id999" class="indexterm"/>start interfacing these libraries in the Python code, start your Mosquitto broker first from the command line using this simple command:</p><div><pre class="programlisting">
<strong>$ mosquitto</strong>
</pre></div><p>Make sure that you restart your monitoring station every time you start or restart the Mosquitto broker. This action will make sure that your monitoring station is connected to the Mosquitto broker, since the process of establishing the connection only gets executed once in our Arduino code, that is, at the beginning of the setup process.</p><p>The Python code for the current project is located in the code folder of this chapter with the name <code class="literal">controlCenter.py</code>. Open this file using your Python IDE and modify the values of the appropriate parameters before executing it. These parameters include the IP address of the Mosquitto broker along with the feed ID and the API key of the Xively virtual device. You should already have the feed ID and the API key of your Xively virtual device from the previous chapter:</p><div><pre class="programlisting">cli.connect("10.0.0.18", 1883, 15)
FEED_ID = "&lt;feed-id&gt;"
API_KEY = "&lt;api-key"</pre></div><p>If you are <a id="id1000" class="indexterm"/>using a local instance of the Mosquitto broker, you can replace the IP address with <code class="literal">127.0.0.1</code>. Otherwise, replace the <code class="literal">10.0.0.18</code> address with the appropriate IP address of the computer that is hosting the Mosquitto broker. Let's try to understand the code now.</p><div><div><h3 class="title"><a id="note57"/>Note</h3><p>Sometimes on Mac OS X, you won't be able to run <code class="literal">Tkinter</code> window and Python threads in parallel due to an unknown bug. You should be able to execute the program successfully in Windows and Linux environments. This program has been tested with the Raspberry Pi, which means you won't encounter the same bug while deploying the control center.</p></div></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec119"/>Creating the GUI using Tkinter</h3></div></div></div><p>In the previous <a id="id1001" class="indexterm"/>exercises, we always used a single Python thread to run the program. This practice will not help us to perform multiple tasks in parallel such as obtaining sensor observation from the monitoring station and simultaneously updating the GUI with that information. As a solution, we have introduced multithreading in this exercise. As we need two separate loops, one each for <code class="literal">Tkinter</code> and <code class="literal">paho-mqtt</code>, we will be running them independently in separate threads. The main thread will run methods that are related to Mosquitto and the cloud services, while the second thread will handle the <code class="literal">Tkinter</code> GUI. In the following code snippet, you can see that we have initialized the <code class="literal">controlCenterWindow()</code> class with the <code class="literal">threading.thread</code> parameter. Therefore, when we execute <code class="literal">window = controlCenterWindow()</code> in the main program, it will create another thread for this class. Basically, this class creates the GUI window while populating labels and other GUI components. The labels need to be updated when new sensor observations arrive, are declared as class variables, and are accessible from the class instant. As you can see in the following code snippet, we have declared the labels for temperature, humidity, light, and motion as class variables:</p><div><pre class="programlisting">class controlCenterWindow(threading.Thread):
    def __init__(self):
        # Tkinter canvas
        threading.Thread.__init__(self)
        self.start()
    def callback(self):
        self.top.quit()
    def run(self):
        self.top = Tkinter.Tk()
        self.top.protocol("WM_DELETE_WINDOW", self.callback)
        self.top.title("Control Center")
        self.statusValue = Tkinter.StringVar()
        self.statusValue.set("Normal")
        self.tempValue = Tkinter.StringVar()
        self.tempValue.set('-')
        self.humdValue = Tkinter.StringVar()
        self.humdValue.set('-')
        self.lightValue = Tkinter.StringVar()
        self.lightValue.set('-')
        self.motionValue = Tkinter.StringVar()
        self.motionValue.set('No')

        # Begin code subsection 
        # Declares Tkinter components
        # Included in the code sample of the chapter
        # End code subsection

        self.top.mainloop()</pre></div><p>The previous code <a id="id1002" class="indexterm"/>snippet doesn't contain the portion where we declared the <code class="literal">Tkinter</code> components, as it is similar to what we coded in the midterm project. If you have questions regarding Tkinter-related issues, please refer to <a class="link" href="ch06.html" title="Chapter 6. Storing and Plotting Arduino Data">Chapter 6</a>, <em>Storing and Plotting Arduino Data</em>, and <a class="link" href="ch07.html" title="Chapter 7. The Midterm Project – a Portable DIY Thermostat">Chapter 7</a>, <em>The Midterm Project – a Portable DIY Thermostat</em>.</p></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec120"/>Communicating with the Mosquitto broker</h3></div></div></div><p>At the control <a id="id1003" class="indexterm"/>center level, we subscribe to topics that are published from the monitoring station, that is, <code class="literal">MonitoringStation/temperature</code>, <code class="literal">MonitoringStation/humidity</code>, and so on. If you have performed any modification to the Arduino code to change the MQTT topics, you need to reflect those changes in this section. If the topics published by the monitoring station do not match the topics in the control center's code, you will not get any updates. As you can see in the Python code, we are associating the <code class="literal">on_message</code> and <code class="literal">on_publish</code> methods with very important function. Whenever a message arrives from the subscriber, the client will call the functions associated with the <code class="literal">on_message</code> method. However, every time a message gets published from the Python code, the <code class="literal">onPublish()</code> function will get called:</p><div><pre class="programlisting">cli = mq.Client('ControlCenter')
cli.on_message = onMessage
cli.on_publish = onPublish

cli.connect("10.0.0.18", 1883, 15)

cli.subscribe("MonitoringStation/temperature", 0)
cli.subscribe("MonitoringStation/humidity", 0)
cli.subscribe("MonitoringStation/motion", 0)
cli.subscribe("MonitoringStation/light", 0)
cli.subscribe("MonitoringStation/buzzer", 0)
cli.subscribe("MonitoringStation/led", 0)</pre></div></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec121"/>Calculating the system's status and situation awareness</h3></div></div></div><p>The control center <a id="id1004" class="indexterm"/>is assigned with the task of calculating the status of the overall system. The control center calculates the status of the system as <code class="literal">Alert</code>, <code class="literal">Caution</code>, or <code class="literal">Normal</code> using the current values of temperature and humidity. To calculate the status, the control center executes the <code class="literal">calculateStatus()</code> function every time it gets an update for the temperature or humidity from the monitoring station. According to the current situation awareness logic, if the temperature is measured above 45 degree Celsius or below 5 degree Celsius, we call the system's status as <code class="literal">Alert</code>. Similarly, you can identify the range of temperature and humidity values for <code class="literal">Caution</code> and <code class="literal">Normal</code> statuses from the following code snippet:</p><div><pre class="programlisting">def calculateStatus():
    if (tempG &gt; 45):
        if (humdG &gt; 80):
            status = "High Temperature, High Humidity"
        elif (humdG &lt; 20):
            status = "High Temperature, Low Humidity"
        else:
            status = "High Temperature"
        setAlert(status)
        
    elif (tempG &lt; 5):
        if (humdG &gt; 80):
            status = "Low Temperature, High Humidity"
        elif (humdG &lt; 20):
            status = "Low Temperature, Low Humidity"
        else:
            status = "Low Temperature"
        setAlert(status)
    else:
        if (humdG &gt; 80):
            status = "High Humidity"
            setCaution(status)
        elif (humdG &lt; 20):
            status = "Low Humidity"
            setCaution(status)
        else:
            status = "Normal"
            setNormal(status)</pre></div></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec122"/>Communicating with Xively</h3></div></div></div><p>The control center is <a id="id1005" class="indexterm"/>also required to communicate with Xively when it receives a message from the subscribed topics. We are already familiar with the process of setting up virtual devices and data streams on Xively. Open your Xively account and create a virtual device called <code class="literal">ControlCenter</code>. Note down the feed ID and API key for this device and replace them in the current code. Once you have these values, create the <code class="literal">Temperature</code>, <code class="literal">Humidity</code>, <code class="literal">Light</code>, <code class="literal">Motion</code>, <code class="literal">Buzzer</code>, and <code class="literal">Status</code> channels in this virtual device.</p><p>Looking at the Python code, you can see that we have declared the individual data stream for each topic and associated them with the appropriate Xively channel. The following code snippet shows the data stream for just the temperature observation, but the code also contains a similar configuration for all the other sensor observations:</p><div><pre class="programlisting">try:
  datastreamTemp = feed.datastreams.get("Temperature")
except HTTPError as e:
  print "HTTPError({0}): {1}".format(e.errno, e.strerror)
  datastreamTemp = feed.datastreams.create("Temperature", tags="C")
  print "Creating new channel 'Temperature'"</pre></div><p>Once the control center receives a message from the monitoring station, it updates the data stream with the latest values and pushes these changes to Xively. At the same time, we will also update the appropriate label in the <code class="literal">Tkinter</code> GUI using the <code class="literal">onMessage()</code> function. We will use the same code snippet for all the subscribed channels:</p><div><pre class="programlisting">if msg.topic == "MonitoringStation/temperature":
  tempG = float(msg.payload)
  window.tempValue.set(tempG)
  datastreamTemp.current_value = tempG
  try:
    datastreamTemp.update()
  except HTTPError as e:
    print "HTTPError({0}): {1}".format(e.errno, e.strerror)</pre></div><p>The control center <a id="id1006" class="indexterm"/>also implements the function to set the system's status across the system, once it is calculated using the <code class="literal">calculateStatus()</code> function. There are three different functions to perform this task using a method that is similar to what we described in the previous code snippet. These functions include <code class="literal">setAlert()</code>, <code class="literal">setCaution()</code>, and <code class="literal">setNormal()</code> and these are associated with <code class="literal">Alert</code>, <code class="literal">Caution</code>, and <code class="literal">Normal</code> respectively. While updating the system's status, these functions also perform buzzer and LED actions by publishing the LED and buzzer values to the Mosquitto broker:</p><div><pre class="programlisting">def setAlert(status):
    window.statusValue.set(status)
    datastreamStatus.current_value = "Alert"
    try:
        datastreamStatus.update()
    except HTTPError as e:
        print "HTTPError({0}): {1}".format(e.errno, e.strerror)
    cli.publish("MonitoringStation/led", 'red')
    cli.publish("MonitoringStation/buzzer", 'ON')</pre></div></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec123"/>Checking and updating the buzzer's status</h3></div></div></div><p>In the control center, we<a id="id1007" class="indexterm"/> set the <a id="id1008" class="indexterm"/>buzzer's status to <code class="literal">ON</code> if the system's status is determined as <code class="literal">Alert</code>. If you look back at the UX flow, you will notice that we also want to include a feature for the user to manually turn off the buzzer. The <code class="literal">checkBuzzerFromXively()</code> function keeps track of the buzzer's status from Xively and if the user manually turns off the buzzer using the web application, this function sets off the buzzer.</p><p>To continue this process independently from the GUI and situation awareness threads, we will need to create another thread for this function. The timer on this thread will automatically execute the function every 30 seconds:</p><div><pre class="programlisting">def checkBuzzerFromXively():
  try:
    datastreamBuzzer = feed.datastreams.get("Buzzer")
    buzzerValue = datastreamBuzzer.current_value
    buzzerValue = str(buzzerValue)
    cli.publish("MonitoringStation/buzzer", buzzerValue)
  except HTTPError as e:
    print "HTTPError({0}): {1}".format(e.errno, e.strerror)
    print "Requested channel doesn't exist"
  threading.Timer(30, checkBuzzerFromXively).start()</pre></div><p>With this function running in a separate thread every 30 seconds, the control center will check the <a id="id1009" class="indexterm"/>status <a id="id1010" class="indexterm"/>of the Xively channel and stop the buzzer if the status is set to <code class="literal">OFF</code>. We will explain how the user can update the Xively channel for the buzzer in the next section.</p></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec139"/>Testing the control center with the monitoring station</h2></div></div></div><p>Assuming your <a id="id1011" class="indexterm"/>Mosquitto broker is running, execute the <code class="literal">controlCenter.py</code> code with the changed parameters. Then, start the monitoring station. After a few moments, you will see on the terminal that the control center has already started getting messages from the publishers that are initialized on the monitoring station. The update interval for the messages from the publisher at the control center depends upon the configured publishing interval at the monitoring station.</p><div><div><h3 class="title"><a id="note58"/>Note</h3><p>The Arduino code executes the process of connecting to the Mosquitto broker only once after powering on. If you start your Mosquitto broker after that, it won't be able to communicate with the broker. So, you need to make sure that you start the Mosquitto broker before powering on the monitoring station.</p><p>If you need to restart the Mosquitto broker for any reason, remove and restart the monitoring station first.</p></div></div><div><img src="img/5938OS_10_10.jpg" alt="Testing the control center with the monitoring station"/></div><p>On execution of the program, you will be able to see a small GUI window, as shown in the following screenshot. This window displays the sensor's values for temperature, humidity, ambient light, and motion. Along with these values, the GUI also displays the status of the system, which is <strong>Normal</strong> in this screenshot. You can also observe that every time the control center gets updates from the monitoring station, the system's status and sensor observations change in real time:</p><div><img src="img/5938OS_10_11.jpg" alt="Testing the control center with the monitoring station"/></div><p>If this setup is <a id="id1012" class="indexterm"/>working correctly on your computer, let's move on to deploy the control center on the Raspberry Pi.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec140"/>Setting up the control center on the Raspberry Pi</h2></div></div></div><p>The process of installing <a id="id1013" class="indexterm"/>the Raspbian operating system is explained in <a class="link" href="ch07.html" title="Chapter 7. The Midterm Project – a Portable DIY Thermostat">Chapter 7</a>, <em>The Midterm Project – a Portable DIY Thermostat</em>. You can use the same module that you used in the Midterm project or set up a new one. Once you have installed Raspbian and configured the TFT screen, connect the Wi-Fi dongle through a USB port. At this stage, we assume that your Raspberry Pi is connected with a monitor, a keyboard, and a mouse to perform the basic changes. Although we won't recommend it, you can also use the TFT screen for the following operations, if you are comfortable with it:</p><div><ol class="orderedlist arabic"><li class="listitem">Start your Raspberry Pi and log in. At the command prompt, execute the following command to enter the visual desktop mode:<div><pre class="programlisting">
<strong>$ startx</strong>
</pre></div></li><li class="listitem">Once your graphical desktop starts, you will be able to see the icon of the <strong>WiFi config</strong> utility. Double-click on this icon and open the <strong>WiFi config</strong> utility. Scan for wireless networks and connect to the Wi-Fi network that has the monitoring station. When asked, enter the password of your network in the form window called <strong>PSK</strong>, and connect to your network.</li><li class="listitem">Now, your Raspberry Pi is connected to the local home network and to the Internet through it. It's time to update the existing packages and install the required ones. To update the Raspberry Pi's existing system, execute the following commands in the terminal:<div><pre class="programlisting">
<strong>$ sudo apt-get update</strong>
<strong>$ sudo apt-get upgrade</strong>
</pre></div></li><li class="listitem">Once <a id="id1014" class="indexterm"/>your system is updated with the latest version, it's time to install the Mosquitto broker on your Raspberry Pi. The Raspbian OS has Mosquitto in the default repository, but it doesn't have the current version that we need. To install the latest version of Mosquitto, execute following commands in the terminal:<div><pre class="programlisting">
<strong>$ curl -O http://repo.mosquitto.org/debian/mosquitto-repo.gpg.key</strong>
<strong>$ sudo apt-key add mosquitto-repo.gpg.key</strong>
<strong>$ rm mosquitto-repo.gpg.key</strong>
<strong>$ cd /etc/apt/sources.list.d/</strong>
<strong>$ sudo curl -O http://repo.mosquitto.org/debian/mosquitto-repo.list</strong>
<strong>$ sudo apt-get update</strong>
<strong>$ sudo apt-get install mosquitto, mosquitto-clients</strong>
</pre></div></li><li class="listitem">To install other Python dependencies, let's first install the Setuptools package using <code class="literal">apt-get</code>:<div><pre class="programlisting">
<strong>$ sudo apt-get install python-setuptools</strong>
</pre></div></li><li class="listitem">Using Setuptools, we can now install all the required Python libraries such as <code class="literal">paho_mqtt</code>, <code class="literal">xively-python</code>, and <code class="literal">web.py</code>:<div><pre class="programlisting">
<strong>$ sudo easy_install pip</strong>
<strong>$ sudo pip install xively-python web.py paho_mqtt</strong>
</pre></div></li></ol></div><p>Now that we have installed all the necessary software tools that are required to run our control center on the Raspberry Pi, it is time to configure the Raspberry Pi so that it can provide uninterrupted operation for a critical system such as a remote home monitoring system: </p><div><ol class="orderedlist arabic"><li class="listitem">In the current configuration of the Raspberry Pi, the screen of the Raspberry Pi will go to sleep after some time and the Wi-Fi connection will be terminated when this happens. To avoid this problem and force the screen to remain active, you will need to perform the following changes. Open the <code class="literal">lightdm.conf</code> file using the following command:<div><pre class="programlisting">
<strong>$ sudo nano /etc/lightdm/lightdm.conf</strong>
</pre></div></li><li class="listitem">In the file, navigate to the <code class="literal">SetDefaults</code> section and edit the following line:<div><pre class="programlisting">xserver-command-X –s 0 dpms</pre></div></li><li class="listitem">Now that your Raspberry Pi is set up, it is time to copy the program file from your computer to the Raspberry Pi. You can use SCP, PuTTY, or just a USB drive to transfer the necessary file to the Raspberry Pi.</li></ol></div><p>If you install <a id="id1015" class="indexterm"/>and configure everything as specified, your program should run without any errors. You can run the Python program constantly in the background using the following command:</p><div><pre class="programlisting">
<strong>$ nohup python controlCenter.py &amp;</strong>
</pre></div><p>The last thing that we want to set up on the Raspberry Pi is the TFT LCD screen. The installation and configuration processes of the TFT LCD screen are described in <a class="link" href="ch07.html" title="Chapter 7. The Midterm Project – a Portable DIY Thermostat">Chapter 7</a>, <em>The Midterm Project – a Portable DIY Thermostat</em>. Please follow the steps in the given order to set up the screen. The control center module along with the Raspberry Pi and the TFT screen can now be deployed in any part of your house.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec69"/>Stage 3 – a web application using Xively, Python, and Amazon cloud service</h1></div></div></div><p>The<a id="id1016" class="indexterm"/> cloud services module of <a id="id1017" class="indexterm"/>the overall system enables remote access to your monitoring station through the Internet. The unit interacts with the user via a web application as an extended version of the control center. With the use of this web application, the user can observe the sensor information from the monitoring station and the system's status calculated by the control center while having remote control to turn off the buzzer. So, what does the architecture of the cloud services look like?</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec141"/>Architecture of the cloud services</h2></div></div></div><p>The architecture <a id="id1018" class="indexterm"/>of the cloud services module with its associated components is displayed in the following diagram. In the cloud services architecture, we are using Xively as the intermediate data relay between the web application and the control center. The control center pushes the observations obtained from the monitoring station to the Xively channels. Xively <a id="id1019" class="indexterm"/>stores and relays the data to the web application that is hosted on the Amazon AWS. The server instance on the Amazon AWS is used to make the web application accessible through the Internet. The server instance runs the Ubuntu operating system and the web application that is developed using the <code class="literal">web.py</code> library in Python.</p><div><img src="img/5938OS_10_12.jpg" alt="Architecture of the cloud services"/></div><p>In the previous <a id="id1020" class="indexterm"/>stage, we already covered the process of setting up Xively and the channels to accommodate sensor data. In the control center code, we also explained how we can push the updated observations to the appropriate Xively channels. Therefore, we really do not have any ground to cover for the Xively platform at this stage and we can move on to the web application.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec142"/>Python web application hosted on Amazon AWS</h2></div></div></div><p>In the previous chapter, we <a id="id1021" class="indexterm"/>set up an Amazon AWS cloud instance to host a web application. You can use the same instance to host the web application for the remote home monitoring system too. However, make sure that you have installed the <code class="literal">web.py</code> library on your server.</p><div><ol class="orderedlist arabic"><li class="listitem">In your computer, open the <code class="literal">Web_Application</code> folder and then the <code class="literal">RemoteMonitoringApplication.py</code> file in your editor.</li><li class="listitem">In the code, you will be able to see that we just expand the web application program that we created in <a class="link" href="ch09.html" title="Chapter 9. Arduino and the Internet of Things">Chapter 9</a>, <em>Arduino and the Internet of Things</em>. We use the templates based on <code class="literal">web.py</code> and the <code class="literal">GET()</code> and <code class="literal">POST()</code> functions to enable the web application.</li><li class="listitem">In the application, we fetch information from each Xively channel and process it via a separate function. For example, the <code class="literal">fetchTempXively()</code> function obtains the temperature information from Xively. Every time the <code class="literal">POST()</code> function is executed, the <code class="literal">fetchTempXively()</code> function fetches the latest value of temperature reading from Xively. This also means that the web application does not populate and refresh the latest information automatically and waits for <code class="literal">POST()</code> to execute the appropriate functions:<div><pre class="programlisting">def fetchTempXively():
  try:
    datastreamTemp = feed.datastreams.get("Temperature")
  except HTTPError as e:
    print "HTTPError({0}): {1}".format(e.errno, e.strerror)
    print "Requested channel doesn't exist"
  return datastreamTemp.current_value</pre></div></li><li class="listitem">The web <a id="id1022" class="indexterm"/>application also provides access to control the buzzer from the user interface. The following code snippet adds the <strong>Buzzer Off</strong> button with other <code class="literal">Form</code> components. When the form is submitted after this button is pressed, the web application executes the <code class="literal">setBuzzer()</code> function:<div><pre class="programlisting">inputData = web.input()
if inputData.btn == "buzzerOff":
    setBuzzer("OFF")</pre></div></li><li class="listitem">The <code class="literal">setBuzzer()</code> function access the Xively channel, <code class="literal">Buzzer</code>, and sends the off value if the <strong>Buzzer Off</strong> button is pressed. The current web application doesn't include the <strong>Buzzer On</strong> button, but you can easily implement this functionality by reusing the code that we developed for the <strong>Buzzer Off</strong> button. This function provides the reference code for other control points, which you can reuse with minor modifications:<div><pre class="programlisting">def setBuzzer(statusTemp):
  try:
    datastream = feed.datastreams.get("Buzzer")
  except HTTPError as e:
    print "HTTPError({0}): {1}".format(e.errno, e.strerror)
    datastream = feed.datastreams.create("Buzzer", 
                                         tags="buzzer")
    print "Creating new Channel 'Buzzer"
  datastream.current_value = statusTemp
  try:
    datastream.update()
  except HTTPError as e:
    print "HTTPError({0}): {1}".format(e.errno, e.strerror)</pre></div></li><li class="listitem">In the code, you will also have to modify the Xively feed ID and the API key and replace them with the values that your obtained from your virtual device. Once you have performed this modification, run the following command. If everything goes as planned, you will be able to open the web application in your web browser.<div><pre class="programlisting">
<strong>$ python RemoteMonitoringApplication.py</strong>
</pre></div></li></ol></div><p>If you are running the <a id="id1023" class="indexterm"/>Python code on your computer, you can open <code class="literal">http://127.0.0.1:8080</code> to access the application. If you are running the application on the cloud server, you need to enter the IP address or domain name of your server to access the web application, <code class="literal">http://&lt;AWS-IP-address&gt;:8080</code>. If the web application is running from the cloud, it can be accessed from anywhere using the Internet, which was one of the original project requirements. With this last step, you have successfully completed the development of the remote home monitoring system that is based on Arduino and Python.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec143"/>Testing the web application</h2></div></div></div><p>When you open the <a id="id1024" class="indexterm"/>web application in a browser, you will be able to see a similar output as shown in the following screenshot. As you can see, the web application displays the temperature, humidity, light, and motion values. The <strong>Refresh</strong> button fetches the sensor data from Xively again and loads the application once more. The <strong>Buzzer Off</strong> button sets the value of the Xively's <code class="literal">Buzzer</code> channel to <code class="literal">OFF</code>, which then get picked up by the control center, and it turns off the buzzer at the monitoring station subsequently:</p><div><img src="img/5938OS_10_13.jpg" alt="Testing the web application"/></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec70"/>Testing and troubleshooting</h1></div></div></div><p>Due to the <a id="id1025" class="indexterm"/>number of components<a id="id1026" class="indexterm"/> involved and complex programming associated with them, the overall project is a complex system to test and debug. Before you jump into troubleshooting, make sure that you have properly followed the steps that were described in the previous sections in order. The following are a few solutions to possible problems that can occur during the execution of the project:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Troubleshoot individual sensor performance:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If your sensor measurements are way off the expected values, the first thing that you want to evaluate is the connection of the sensor pins to the Arduino board. Make sure that you have connected the digital, analog, and PWM pins correctly.</li><li class="listitem" style="list-style-type: disc">Check whether your Ethernet Shield board is properly connected to Arduino Uno.</li><li class="listitem" style="list-style-type: disc">Evaluate the connections of the 5V power supply and ground for each component.</li></ul></div></li><li class="listitem" style="list-style-type: disc">Avoid Xively's update limit<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Xively imposes a limit on the maximum number of transactions that you can perform in a limited amount of time. While running your control <a id="id1027" class="indexterm"/>center code, if you encounter an error for exceeding the limit, wait for 5 minutes before your access limit gets lifted.</li><li class="listitem" style="list-style-type: disc">Increase the delay between consecutive Xively updates at the control center level:<div><pre class="programlisting">threading.Timer(120, checkBuzzerFromXively).start()</pre></div></li><li class="listitem" style="list-style-type: disc">Reduce the frequency of published messages at the monitoring station:<div><pre class="programlisting">timer.setInterval(600000, publishData);</pre></div></li><li class="listitem" style="list-style-type: disc">You can also combine various Xively channels by formatting data into JSON or XML.</li></ul></div></li><li class="listitem" style="list-style-type: disc">Working with the maximum current draw limitation of Arudino:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The +5V power pin and digital pin of Arduino can provide a maximum current of 200 mA and 40 mA respectively. When running sensors directly from the Arduino board, make sure that you do not exceed these limits.</li><li class="listitem" style="list-style-type: disc">Make sure the combined current requirement of all the sensors is less than 200 mA. Otherwise, the components won't be able to get enough power to run and this will translate into faulty sensor information.</li><li class="listitem" style="list-style-type: disc">You can provide external power to the components that require large amounts of current and control this power mechanism via Arduino itself. You will need a transistor that is acting as a switch that can then be controlled using the digital pins of Arduino. The tutorial at <a class="ulink" href="https://learn.adafruit.com/adafruit-arduino-lesson-13-dc-motors/transistors">https://learn.adafruit.com/adafruit-arduino-lesson-13-dc-motors/transistors</a> shows a similar example for a DC motor.</li></ul></div></li><li class="listitem" style="list-style-type: disc">Solve network problems:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">In some<a id="id1028" class="indexterm"/> scenarios, your <a id="id1029" class="indexterm"/>monitoring station won't be able to communicate with the control center due to network problems.</li><li class="listitem" style="list-style-type: disc">This problem can be solved by using manual IP addresses for both, Arduino and the Raspberry Pi. In our project, we use a manual IP address for the Arduino, but the Raspberry Pi is connected using the Wi-Fi network. In most cases, when you are using your home Wi-Fi network, Wi-Fi routers are set up to provide dynamic IP addresses to the device every time they reconnect to the router.</li><li class="listitem" style="list-style-type: disc">You can solve this by configuring your Wi-Fi router to a fixed IP address for the Raspberry Pi. As the type and model of the Wi-Fi router is different for every scenario, you will have to use its user manual or online help forums for setting it up.</li></ul></div></li><li class="listitem" style="list-style-type: disc">Working with buzzer-related issues:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Sometimes the buzzer sound can be too loud or too quiet, depending upon the sensor that you are using. You can use PWM to configure the intensity of the buzzer. In our project, we used the Arduino digital pin 9 to connect the buzzer. This pin also supports PWM. In your Arduino code, modify the line to reflect changes for the PWM pin. Replace the <code class="literal">digitalWrite(BUZZER, HIGH);</code> line with <code class="literal">analogWrite(BUZZER, 127);</code>.</li><li class="listitem" style="list-style-type: disc">This routine will reduce the intensity of the buzzer by half from the original level. You can also change the PWM value from 0 to 255 and set the intensity of the buzzer sound from lowest to highest.</li></ul></div></li><li class="listitem" style="list-style-type: disc">Control center GUI calibration:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Depending upon the size of the TFT LCD screen that you are using, you will have to adjust the size of the main window of <code class="literal">Tkinter</code>.</li><li class="listitem" style="list-style-type: disc">First, run the current code on your Raspberry Pi and if you see that the GUI window does not match the screen, add the following line of code after initializing the main window:<div><pre class="programlisting">top.minsize(320,200)</pre></div></li><li class="listitem" style="list-style-type: disc">This code will fix the problem with the size for a 2.8 inch TFT LCD screen. In the previous code snippet, <code class="literal">320</code> and <code class="literal">200</code> represent the pixel sizes for width and length respectively. For other screen sizes, change the pixel size accordingly.</li></ul></div></li><li class="listitem" style="list-style-type: disc">Test the LED:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">In current <a id="id1030" class="indexterm"/>code configuration, the LED is turned on only when the system changes to <code class="literal">Alert</code> or <code class="literal">Caution</code>. That means you won't be able to test the LEDs unless these situations occur. To check whether they are working correctly, execute the following command at the control center:<div><pre class="programlisting">
<strong>$ mosquitto_pub –t "MonitoringStation/led" –m "red"</strong>
</pre></div></li><li class="listitem" style="list-style-type: disc">This command will light up the LED in red. To turn off the LED, just use <code class="literal">off</code> instead of <code class="literal">red</code> in the previous code.</li><li class="listitem" style="list-style-type: disc">If nothing <a id="id1031" class="indexterm"/>lights up, you should check the connection wires of the LEDs. In addition, check for network-related issues as the Mosquitto itself might not be working.</li><li class="listitem" style="list-style-type: disc">If you see any color other than red, this means that you haven't connected the LED correctly and you need to interchange the pin configuration of your LED. If you are using an LED different than super-flux RGB, you should check out the pin layout in the datasheet and reorganize the connections. </li></ul></div></li></ul></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec71"/>Extending your remote home monitoring system</h1></div></div></div><p>To successfully create <a id="id1032" class="indexterm"/>commercial products from DIY project prototypes, you will need an additional layer of features on top of basic functionalities. These features actually make things convenient for a user when they interact with the system. The other distinguishable feature is the tangibility of the system, which makes large-scale production and support possible. Although there are plenty of features that you can implement, we recommend the following major improvements to elevate the level of the current project.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec144"/>Utilizing multiple monitoring stations</h2></div></div></div><p>In this project, we <a id="id1033" class="indexterm"/>developed a monitoring station as a prototype with a range of functionality that is demonstrated by a remote home monitoring system. A remote monitoring system can have multiple numbers of monitoring stations to cover various geographical locations, such as different rooms inside a house, or different office cubicles. Basically, a large number of monitoring stations can cover an extended area and provide efficient surveillance of the domain that you are trying to monitor. If you want to extend the current project with an array of monitoring stations, you will require some of the following modifications:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Each monitoring station can have its own control center or a centralized control center for all of them, depending upon the application requirements.</li><li class="listitem" style="list-style-type: disc">You will have to update the Python code for the control center to accommodate the changes. Examples of these changes include modifying topic titles for MQTT, coordinating between these monitoring stations, updating data models for Xively updates, and so on.</li><li class="listitem" style="list-style-type: disc">The free Xively account may not be able to handle the large amounts of data coming from the monitoring stations. In this case, you can either optimize the update rate and/or payload size or upgrade your Xively account to comply with the requirements. You can also resort to other free services such as ThingSpeak, Dweet.io, and Carriots, but you will have to make substantial modifications to the existing code structure.</li><li class="listitem" style="list-style-type: disc">You can also update the web application to provide you with a selection menu for the monitoring stations or display all of them at once. You will also have to change the code to yield the modified data models.</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec145"/>Extending sensory capabilities</h2></div></div></div><p>In term of sensors, we <a id="id1034" class="indexterm"/>are only interfacing temperature, humidity, ambient light, and motion sensors. However, the actuation is limited to the buzzer and LED. You can implement the following changes to improve the sensory capabilities of the project.</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">In a real scenario, a remote home monitoring system should be able to interface with other existing sensors such as the security system, monitoring cameras, refrigerator sensors, door sensors, and garage sensors throughout a home.</li><li class="listitem" style="list-style-type: disc">You can also interface this project with other appliances such as the air conditioner, heater, and security alarm, which can help you to control the environment that you are already monitoring. As a trial, these components can be interfaced using a set of relays and switches.</li><li class="listitem" style="list-style-type: disc">You can upgrade the current sensors at the monitoring station with more powerful, efficient, and accurate sensors. However, the monitoring station with the upgraded sensors may require a more powerful version of Arduino with more I/O pins and computation capabilities.</li><li class="listitem" style="list-style-type: disc">You can <a id="id1035" class="indexterm"/>also use additional sensors other than those used in this project at the monitoring station. There are large amount of heterogeneous, Arduino-supported DIY sensors that you can buy off the shelf. Examples of these sensors include the Alcohol Gas Sensor (MQ-3), LPG Gas Sensor (MQ-6), Carbon Monoxide Sensor (MQ-7), Methane Gas Sensor (MQ-4), and so on. These sensors can be simply interfaced with the Arduino just like the other sensors that we connected earlier.</li><li class="listitem" style="list-style-type: disc">To accommodate these changes, you will be required to change the control center logic and algorithms. If you are interfacing a third-party component, you may also have to revisit the system architecture and adjust it.</li><li class="listitem" style="list-style-type: disc">Similarly, you will also have to run frequent updates to Xively for the additional number of sensors, making the free version inadequate. To resolve this, you can pay for the commercial version of a Xively account or use a limited number of requests using a JSON file format similar to the one displayed in the following code snippet:<div><pre class="programlisting">{
    "version": "1.0.0",
    "datastreams": [
        {
            "id": "example",
            "current_value": "333"
        },
        {
            "id": "key",
            "current_value": "value"
        },
        {
            "id": "datastream",
            "current_value": "1337"
        }
    ]
}</pre></div></li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec146"/>Improving UX</h2></div></div></div><p>When we <a id="id1036" class="indexterm"/>designed the user experience for this project, our goal was to demonstrate the usefulness of a UX design in developing the software flow. In the current UX design, the control center and the web application have limited control and features for a user. The following are a few changes that you need to implement to improve the UX of the project:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Add tooltips and proper naming conventions for the various descriptions. Implement a proper layout to differentiate between the various information categories.</li><li class="listitem" style="list-style-type: disc">Add buttons for the buzzer and the LED control on the control center GUI.</li><li class="listitem" style="list-style-type: disc">In the web application, use a JavaScript and Ajax-based interface to automatically refresh the changes in sensor values.</li><li class="listitem" style="list-style-type: disc">Provide a UI mechanism so that the user can change the update interval at the control center and the web application. Once these changes are made, propagate them through each program so that the monitoring station can start publishing messages at the new interval.</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec147"/>Expanding cloud-based features</h2></div></div></div><p>In the <a id="id1037" class="indexterm"/>current setup, we are using two stages to provide cloud-based capabilities and enable remote monitoring. We have Xively as a data relay and Amazon AWS to host the web application. If you are working on a commercial-grade product and want to reduce the complexity of the architecture, you can implement the following changes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">You can develop your own data relay on your cloud instance using open source tools such as ThingSpeak. Your control center will then communicate directly to your server and eliminate dependency on third-party IoT services.</li><li class="listitem" style="list-style-type: disc">If Xively is your platform, you can also use additional features, such as graphs on your smart phone, which are provided by Xively. Once your phone is paired with Xively, you can access this feature directly.</li><li class="listitem" style="list-style-type: disc">Alternatively, you can use other cloud services such as Microsoft Azure and Google App engine instead of Amazon AWS. You can also set up your own cloud server, depending upon your familiarity with cloud computing. Although having your own cloud will give you complete control of the server, third-party services such as Amazon can be more cost effective and require less maintenance compared to self-hosted servers.</li><li class="listitem" style="list-style-type: disc">If you are planning to develop a large-scale system that is based on the current architecture, you can increase the computing capability of your existing <a id="id1038" class="indexterm"/>cloud instance. You can also implement a distributed server system to accommodate the large number of remote monitoring systems that can be accessed by an even greater number of users.</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec148"/>Improving intelligence for situation awareness</h2></div></div></div><p>In this project, we have used four different sensors to monitor the physical environment—each sensor obtains user inputs with two types of actuators for notification. Although <a id="id1039" class="indexterm"/>we are using a good amount of information sources, our situation awareness algorithm is limited to identifying out-of-range temperature and humidity values. You can implement a few extended features to make your system more versatile and useful:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Implement different logic for day and night scenarios, which can help you to avoid unwarranted false alarms at night.</li><li class="listitem" style="list-style-type: disc">Implement an intruder detection algorithm using the motion sensor for when you are not at home.</li><li class="listitem" style="list-style-type: disc">Utilize a combination of ambient light sensor values with motion sensors to identify energy wastage. For example, a scenario in which more light is recorded during the night when the motions are significantly low explains that you may have forgotten to turn off the lights during the night.</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec149"/>Creating an enclosure for hardware components</h2></div></div></div><p>Just like<a id="id1040" class="indexterm"/> software-based features, the hardware components also require a major revamp if you develop a commercial-grade product. Nowadays, 3D printers have become viable and it is really easy to design and print plastic 3D components. You can also use professional 3D printing services such as Shapeways (<a class="ulink" href="http://www.shapeways.com">http://www.shapeways.com</a>), Sculpteo (<a class="ulink" href="http://www.sculpteo.com">http://www.sculpteo.com</a>), or makexyz (<a class="ulink" href="http://www.makexyz.com">http://www.makexyz.com</a>) for your enclosures. You can even use a laser cutter or other means of model making to create the hardware enclosures. These are a few hardware improvements that you can implement:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The sensor and actuators that are assembled on a prototype board can be organized on a PCB and permanently fixed for stable and robust operation.</li><li class="listitem" style="list-style-type: disc">A hardware enclosure for the monitoring station can make it portable and easily deployable in any environment. When designing this enclosure, you should also consider the proper placement of the motion sensor and the ambient light sensor, along with a button to make them accessible to the user.</li><li class="listitem" style="list-style-type: disc">The <a id="id1041" class="indexterm"/>Raspberry Pi and TFT LCD screen, which make up the control center hardware, can also be enclosed in a mountable package.</li><li class="listitem" style="list-style-type: disc">Adding touch screen capabilities to the TFT LCD screen can enable additional control over the system, expanding the UX use cases.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec72"/>Summary</h1></div></div></div><p>In this chapter, we developed a working prototype of a remote home monitoring system and also learned the process of hardware product development simultaneously. In the project, we utilized most of the hardware components and software tools that we used throughout the book. We began by designing the system architecture so that we could coordinate the utilization of these tools. Later, we ventured into the actual development stages, which included designing the hardware units and developing programs to run these units. In the end, we provided a list of improvements to make this prototype into a real commercial product. You are welcome to use this methodology to develop your future projects and products, as you now have experience working with this one.</p><p>In the last chapter, we are going to utilize the same project development methodology to create an interesting project that utilizes your messages from a social network website to give you control over your hardware.</p></div></body></html>