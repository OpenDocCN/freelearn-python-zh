- en: Chapter 3. Database Abstraction Layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a model from a csv file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Batch upload of your data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving your data from one database to another
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a model from existing MySQL and PostgreSQL databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Efficiently searching by tag
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing your database from multiple applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hierarchical category tree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating records on demand
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OR, LIKE, BELONGS, and more on Google App Engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replacing slow virtual fields with DB views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Database Abstraction Layer (DAL)** is probably the major strength of web2py.
    The DAL exposes a simple **Applications Programming Interface (API)** to the underlying
    SQL syntax, and this may hide its true power. In the recipes of this chapter,
    we provide examples of non-trivial applications of the DAL, such as building queries
    to search by tags efficiently and building a hierarchical category tree.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As shown in the recipes in the previous chapter, most applications require a
    database, and building the database model is the first step in the design of the
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here we assume that you have a newly created application, and you will be putting
    the models in a file called `models/db_custom.py`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First of all, you need a database connection. This is created by the DAL object.
    For example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that this line is already in the file `models/db.py`, and therefore you
    may not need it, unless you deleted it or need to connect to a different database.
    By default, web2py connects to an `sqlite` database stored in file storage.sqlite.
    This file is located in the application's databases folder. If the file is not
    there, it is created by web2py when the application is first executed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: SQLite is fast, and stores all data in one single file. This means that your
    data can be easily transferred from one application to another. In fact, the `sqlite`
    database(s) are packaged by web2py together with the applications. It provides
    full SQL support, including translations, joins, and aggregates. Moreover SQLite
    comes standard with Python 2.5 and later, and therefore, it is already available
    to your web2py installation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There are two disadvantages of SQLite. One is that it does not enforce column
    types, and there is no `ALTER TABLE` except for adding and dropping columns. The
    other disadvantage is that the entire database is locked by any transaction that
    requires write access. Therefore, the database cannot be accessed concurrently
    except for reading.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: These features make it a good option for development purposes and low-traffic
    websites, but not a viable solution for high-traffic sites.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the following recipe, we will show you how to connect to a different type
    of database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once we have a `db` object, we can use the `define_table` method to define
    new tables. For example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The syntax is always the same. The first argument is the **table name**, and
    it is followed by a list of Field(s). The field constructor takes the following
    arguments:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**The field name**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The field type:** This can take values having any of the following datatypes
    - `string` (default), `text, boolean, integer, double, password, date, time, datetime,
    upload, blob, reference other_table, list:string, list:integer`, and `list:reference
    other_table`. Internally, `upload, password`, and `list` types are equivalent
    to `string`, but at the web2py level, they are handled differently.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`length=512:` This is the maximum length for string-based fields. It is ignored
    for non-text based fields.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default=None:` This is the default value when a new record is inserted. The
    value of this attribute can be a function that is called when a value is needed
    (for example, on record insert, if no value is specified).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`update=None:` This works the same as default, but the value is used only on
    update, not on insert.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ondelete=''CASCADE'':` This maps onto the corresponding SQL `ON DELETE` attribute.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`notnull=False:` This specifies whether the field value can be `NULL` or not
    (enforced at database level).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unique=False:` This specifies whether the field value must be unique or not
    (enforced at database level).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`requires=[]:` This is a list of web2py validators (enforced at the level of
    web2py forms). Most field types have default validators.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`required=False:` This is not to be confused with requires, and it tells web2py
    that a value for this field must be specified during insert and update. For a
    `required` field, default and update values are ignored. Unless used together
    with `notnull=True`, the `None` value is an acceptable value, even if the field
    is required.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`readable=True:` This specifies whether the field is readable in forms or not.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`writable=True:` This specifies whether the field is writable in forms or not.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`represent=(lambda value: value):` This is a function that is used to display
    the value of the field in forms and tables.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`widget=SQLHTML.widgets.string.widget:` This is a function that will build
    the input widget in forms.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`label="Field Name":` This is the label to be used for this field in forms.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`comment="...":` This is a comment to be added to this field in forms.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Field` constructor has other attributes that are specific to upload type
    fields. See the web2py book for further information.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `define_table` method also takes three named arguments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`migrate=True:` This instructs web2py to create the table if it does not exist,
    or alter it if it does not match the model definition. This process is accompanied
    by the creation of metadata files. The metadata files have the form `databases/<hash>_<name>.table`,
    and will be used to keep track of changes in the model, and perform automatic
    migrations. Set `migrate=False` to disable automatic migrations.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fake_migrate=False:` Sometimes the above metadata gets corrupt (or accidentally
    deleted), and needs to be re-created. If the model matches the database table
    content, then set `fake_migrate=True`, and web2py will rebuild the metadata.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`format=''%(id)s'':` This is a format string that determines how records of
    this table should be represented when referenced by another table in forms (for
    example in select dropboxes). The format can be a function that takes a row object
    that returns a string.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In all databases, but SQLite and Google App Engine datastore, if you change
    a table definition, an `ALTER TABLE` is issued to make sure the database matches
    the model. In SQLite, the `ALTER TABLE` is only performed when a column is added
    or deleted, not when a field type changes (because SQLite does not enforce it).
    In Google App Engine datastore, there is no concept of `ALTER TABLE`, and columns
    can be added but not deleted; web2py will ignore columns not listed in the model.
  prefs: []
  type: TYPE_NORMAL
- en: Completely removing a `define_table` from the model does not result in a `DROP
    TABLE`. The table simply becomes inaccessible to web2py until the corresponding
    `define_table` is put back. This prevents accidental deletion of data. You can
    drop tables in web2py using the command `db.<name>.drop()`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a model from a CSV file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Consider the scenario in which you have a CSV file and you do not know much
    about it. Yet you want to create a web application to access the data in the CSV
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I will assume you have the csv file in a folder
  prefs: []
  type: TYPE_NORMAL
- en: '`/tmp/mydata.csv`'
  prefs: []
  type: TYPE_NORMAL
- en: You will also need a program called `csvstudio`, which you can download from
    [http://csvstudio.googlecode.com/hg/csvstudio.py](http://csvstudio.googlecode.com/hg/csvstudio.py).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This first step consists of looking at the csv file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the file is not corrupt, and it is in a standard csv format, then csvstudio
    will generate a report listing the CSV columns, data types, and data ranges.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the file is in a non-standard CSV format, or is, for example, in XLS, try
    importing it in Excel, and save it again in CSV.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: You may also want to try using **Google Refine** to clean up the CSV file.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once you know that `csvstudio` can correctly read the file, run the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: csvstudio creates a file called db1.py that contains a web2py model that is
    compatible with the data. mytable, here, is the name you choose to give to the
    table.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Move this file into your application's `models` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now you need to clean up the data, so that you can import it in web2py.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The file, `mydata2.csv`, now contains the same data as the original file, but
    the column names have been cleaned up to be compatible with the generated model.
    The field values have been stripped of any leading and trailing spaces.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: At this point, all you have to do is run your application and call `appadmin`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You should see the model you generated. Click on the model name, and you will
    see an upload link at the bottom. Upload the `mydata2.csv` file to populate your
    table.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you prefer to upload the csv file from a shell instead of using the `appadmin`
    interface, you can do so.
  prefs: []
  type: TYPE_NORMAL
- en: 'From insider the main web2py folder, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You will get a web2py shell (-S app opens the shell in the application context,
    `-M` loads the models, and `-N` prevents cron jobs from running).
  prefs: []
  type: TYPE_NORMAL
- en: 'From inside the shell do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Et voila, the data is in the database. When you use the shell do not forget
    to `db.commit()`.
  prefs: []
  type: TYPE_NORMAL
- en: If for any reason this does not work (perhaps because the CSV file is non-standard,
    and there is no way to normalize it), try following our next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Batch upload of your data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, we will assume you have data in a flat file of known `structure`. You
    want to create a database model and import the data in the database.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For same of the argument, we will assume the file is in /tmp/data.txt, and
    has the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Each row is a record ending in `\n`. The fields are separated by &mdash;. The
    first column contains`<first name> <last name>`. The second column contains an
    annual salary value.
  prefs: []
  type: TYPE_NORMAL
- en: As usual, we will assume you have a new application called `app`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing you do is create a model in your `app` called `models/db1.py`
    containing the following data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, you would write a script, for example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This script can read the data, parse it, and put it into the db, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, from the web2py folder run the following script:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the importer is a Python script, but not a module (that is why we
    put it in the `private` folder and not the `modules` folder. It is executed in
    our application context, as if it were a controller. In fact, you can copy the
    code into a controller, and run it from a browser as well.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The previous script works fine if the data is clean. You may need to validate
    each record before inserting it. This is again a two-step procedure. First you
    need to add validators to your model, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Then you need to call validators on import and check for errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Records that cause errors will not be inserted, and you can deal with them manually.
  prefs: []
  type: TYPE_NORMAL
- en: Moving your data from one database to another
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, at this point, you have built your application, and you have data in your
    SQLite database. But let's say you need to move to a production MySQL or PostgreSQL
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here we assume you have an application called `app`, data in the `sqlite://storage.sqlite`
    database, and you want to move your data to a different database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Edit your model `db.py`, and replace the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a file called `applications/app/private/mover.py` that contains the
    following data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run this file with the following command (run it only once or you end up with
    duplicate records):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change the model `db.py`, and change the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Actually, web2py comes with the following script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This script performs tasks and variations using command-line options. Read the
    file for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a model from existing MySQL and PostgreSQL databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is often necessary to access an existing database from a web2py application.
    This is possible under some conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to connect to an existing database, it must be one that''s supported.
    At the time of writing, this includes **MySQL, PostgreSQL, MSSQL, DB2, Oracle,
    Informix, FireBase**, and **Sybase**. You must know the database type (for example
    `mysql` or `postgres)`, the database name (for example, `mydb)`, and the hostname
    and port where the database server is running (for example `127.0.0.1:3306` for
    `mysql` or `127.0.0.1:5432` for `postgres)`. You must have a valid username and
    password to access the database. In summary, you must know the following URI strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mysql://username:password@127.0.0.1:3306/mydb`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`postgres://username:password@127.0.0.1:5432/mydb`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Assuming you can connect to this database, you will only be able to access
    those tables that meet the following conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: Each table to be accessed must have a unique auto-increment integer primary
    key (whether called `id` or not). For PostgreSQL, you can also have compound primary
    keys (comprised of several fields), and not necessarily of `SERIAL` type (see
    **keyed tables** on web2py book).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Records must be referenced by their primary key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The web2py model must include a `define_table` statement for each table to be
    accessed, listing all fields and their types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following, we will also assume your system supports the `mysql` command
    to access the database locally (to extract MySQL models), or your system has installed
    the `psycopg2` python module (to extract PostgreSQL models, see installation recipes).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First you need to query the database and come up with a possible model compatible
    with the content of the database. This can be done by running the following scripts
    that comes with web2py:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To build web2py models from a MySQL database, use:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'To build web2py models from a PostgreSQL database, use:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The scripts are not perfect, but they will generate a db1.py file that describes
    the database tables.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Edit this model to remove tables that you do not need to access. Improve the
    field types (for example, a string field may be a password), and add validators.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then move this file into the `models/` folder of your application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, edit the original `db.py` model, and replace the URI string with the
    one for this database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For MySQL, write:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For PostgreSQL, write:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We disable all migrations, because the table already exists and web2py should
    not attempt to create or alter it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Unfortunately, accessing the existing database is one of the most tricky tasks
    in web2py, because the database was not created by web2py, and web2py needs to
    make some guesses. The only way to fix these problems is by manually editing the
    model file, and using independent knowledge of the database content.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Actually, the `extract_pgsql_models.py` has the following additional features:'
  prefs: []
  type: TYPE_NORMAL
- en: It uses ANSI Standard `INFORMATION_SCHEMA` (this might work with other RDBMS)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It detects legacy keyed tables (not having an `id` as its primary key)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It connects directly to running databases, so there's no need to do an SQL dump
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It handles `notnull, unique`, and referential constraints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It detects the most common datatypes and default values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It supports PostgreSQL columns comments (that is, for documentation)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you have to use it against other RDBMS that support ANSI `INFORMATION_SCHEMA`
    (for example, MSSQL Server), import and use the proper Python connector, and remove
    the `postgreSQL` specific queries (pg_ `tables` for comments)
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You cannot mix references between normal auto-increment primary keys tables
    (type='id') and keyed tables (primarykey=['field1',`'field2'])`. If you use both
    in your database, you have to manually define auto-increment primary keys as keyed
    tables at the web2py model (removing `id` type, and adding the primary key parameter
    to `define_table)`.
  prefs: []
  type: TYPE_NORMAL
- en: Efficiently searching by tag
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whether you are building a social network, a content management system, or an
    ERP system, you eventually need the ability to tag records. This recipe shows
    you a way to efficiently search for records by tag.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here we assume the following two models:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A model for containing the data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A model for storing the tags:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, `name` is the tag name.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We want to search all records having at least one of the tags in the list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For this purpose, we create a search function:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Similarly, if you want to search for records that have all the tags (as opposed
    to one of those in the list):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that these two functions work for any table that is passed as first argument.
  prefs: []
  type: TYPE_NORMAL
- en: In both functions, the query involves two tables.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: web2py interprets this as join.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This system works great if users are free to choose the tag names. Sometimes,
    you want to restrict tags to a well defined set. In that case, the model needs
    to be updated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Here, the link table implements a many-to-many relation between data records
    and tag items.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we need to modify our search functions, so first we convert a
    list of tag names (tags) into a list of tag IDs, and then perform the previous
    query. This can be done using a `subquery:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The technique we implemented here is known as the **Toxi** method, and is described
    in a more general and abstract way at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.pui.ch/phred/archives/2005/04/tags-database-schemas.html](http://www.pui.ch/phred/archives/2005/04/tags-database-schemas.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Accessing your database from multiple applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One way to build distributed applications, is by having the same database available
    to multiple applications. Unfortunately, this is more than a matter of connecting
    to the database. In fact, the different applications need to be aware of the table
    content and other metadata, which is stored in the model definition.
  prefs: []
  type: TYPE_NORMAL
- en: There are three ways to do this, and they are not equivalent. It depends on
    whether the applications share a file system, and the degree of autonomy you want
    to give to the two applications.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will assume you have two web2py applications, one called `app1`, and one
    called `app2`, where `app1` connects to a database through the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Here, URI is some connection string. It does not matter whether this is SQLite
    or a client/server database. We will also assume that the model used by `app1`
    is stored in `models/db1.py`, although the name is unimportant here.
  prefs: []
  type: TYPE_NORMAL
- en: Now we want `app2` to connect to the same database.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is also a common scenario that you want the two applications to be autonomous,
    although able to share data. **Autonomous** means that you want to be able to
    distribute each application without the other one.
  prefs: []
  type: TYPE_NORMAL
- en: If this is the case, each application needs its own copy of the model and its
    own database metadata. The only way to achieve this is by duplication of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You must follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the URI string of `app2` so that it looks the same as `app1`, but disable
    migrations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Copy the model file `models/d1.py` from `app1` into `app2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notice that only `app1` will be able to perform migrations (if both were able
    to do it, the situation would get very confused). If you change the model in `app1`,
    you will have to copy the model file again.
  prefs: []
  type: TYPE_NORMAL
- en: Although this solution breaks the **Don't Repeat Yourself** (DRY) pattern, it
    guarantees complete autonomy to each application, and they can access the same
    database even if running on separate servers.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the two applications are running on the same server, instead of copying
    the model file, you can just make a symbolic link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Now you have only one model file.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes you need a script (not a web application) to be able to access a web2py
    model. This can be done by accessing the metadata only, without executing the
    actual model file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a python script (not a web2py model) that can do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Notice the `auto_import=True`. It tells the DAL to look in the specified folder
    for the meta-data associated to the URI connection, and rebuilds the models on
    the fly, in memory. Models defined in this way have the right names and field
    types, but they will not have the correct values of other attributes, such as
    readable, writable, default, validators, and so on. This is because those attributes
    cannot be serialized in the metadata, and are probably not needed in this scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Hierarchical category tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sooner or later, any application needs a way to categorize data, and categories
    must be stored in a tree, because each category has a parent and possibly subcategories.
    A category without a subcategory is a leaf of the tree. If there are categories
    without a parent, we create a fictitious root tree node, and append all of them
    as subcategories of the root.
  prefs: []
  type: TYPE_NORMAL
- en: The main issue is how to store categories with parent-child relations in a database
    table, and efficiently add nodes and queries for ancestors and descendants of
    a node.
  prefs: []
  type: TYPE_NORMAL
- en: This can be done using a modified pre-order tree traversal algorithm, described
    as follows.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The key trick consists of storing each node in its own record with two integer
    attributes, left and right, so that all its ancestors have a left attribute lower
    than or equal to the left attribute of the current node, and a right attribute
    larger than the one of the current node. Similarly, all descendants will have
    a left larger or equal than the current left and a right smaller than the current
    right. In formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '`A` is parent of `B` if `A.ileft<=B.ileft`, and `A.iright>B.iright`.'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that `A.iright - A.ileft` is always the number of descendants.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a possible implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This allows us to perform the following operations:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define your own tree table (mytree) and proxy object (treeproxy):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Insert a new node:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Append some nodes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Search ancestors and descendants:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Delete a node and all its descendants:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Creating records on demand
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is common that we need to get a record or update a record, based on a condition,
    yet the record may not exist. If the record does not exist, we want to create
    it. In this recipe, we will show two utility functions that can serve this purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '`get_or_create`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`update_or_create`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For this to work, we need to pass enough `field:value` pairs to create the missing
    record.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here is the code for `get_or_create:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how table(**fields) selects a record from the table, matching the requested
    fields, and returns None if the record does not exist. In this latter case, the
    record is inserted. Then, table.insert(...) returns a reference to the inserted
    record, which, for practical purposes, gets the record just inserted.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Here is an example of usage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The code for `update_or_create` is very similar, but we need two sets of variables&mdash;
    variables for the **search** (before update) and variables to be **updated:**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And here is an example of usage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: OR, LIKE, BELONGS, and more on Google App Engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A major limitation of the **Google App Engine** (GAE) is the inability to perform
    queries that use the OR, BELONGS(IN), and LIKE operators.
  prefs: []
  type: TYPE_NORMAL
- en: The web2py DAL provides a system for abstracting database queries, and it works
    on **Relational Databases** (RDBS) as well as on GAE but, still, it is crippled
    by the limitations mentioned. Here we show some workarounds.
  prefs: []
  type: TYPE_NORMAL
- en: We have created an additional API that allows merging, filtering, and sorting
    records after they are extracted from the GAE storage, at the web2py level. They
    can be used to mimic the missing features, and will make your GAE code portable
    to RDBS too.
  prefs: []
  type: TYPE_NORMAL
- en: Current supported RDBS are SQLite, MySQL, PostgreSQL, MSSQL, DB2, Informix,
    Oracle, FireBird, and Ingres.
  prefs: []
  type: TYPE_NORMAL
- en: GAE is the only currently supported NoDB. Other adapters are under development.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the following recipe, we plan to develop an application to run on GAE, and
    we connect to the database using the following logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We assume the following models, as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After setting up the GAE model that we described previously, let's see how to
    do insert and update records, do joins and other manipulations in the following
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: Record insert
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To test the rest of the code, you may want to insert some records in the tables.
    You can do this with `appadmin` or programmatically. The following code will work
    fine on GAE with the caveats that the IDs returned by the `insert` method are
    not sequential on GAE:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Record update
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `update` on GAE works as you would normally expect. Both syntaxes are supported:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'And also:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Joins
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'On a relational database, you can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: This does not work on GAE. You have to perform the query without the join, using
    recursive `selects`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Here, `row.product.name` performs recursive `selects`, and gets you the name
    of the product referenced by `row.product.`
  prefs: []
  type: TYPE_NORMAL
- en: Logical OR
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'On an RDBS, you can implement `OR` in queries using the &mdash; operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'This does not work on GAE, because `OR` is not supported (at the time of writing).
    If the queries involve the same field, you can use the `IN` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: This is a portable and efficient solution. In the most general case, you may
    need to perform the `OR` operation at the web2py level as opposed to at the database
    level.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: In this latter case, the`&mdash`; is not between queries, but between rows object,
    and it is performed after the records are fetched. This presents some problems
    because the original order is lost, and because of the increased memory and resource
    consumption penalty.
  prefs: []
  type: TYPE_NORMAL
- en: OR with orderby
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'On a relational database you can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'But, again on GAE, you have to perform the `OR` at web2py level. Therefore
    you also have to sort at the web2py level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The `sort` method of the `rows` objects take a function of the row, and must
    return an expression to sort about. They can also be used with RDBS to implement
    sorting, when the expression is too complex to implement at the database level.
  prefs: []
  type: TYPE_NORMAL
- en: OR with more complex orderby
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consider the following query that involves a `OR`, a `JOIN`, and an ordering,
    and would only work on RDBS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'You can rewrite it for GAE using the `sort` method, and a recursive `select`
    in the `sort` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: This works, but it may be inefficient. You may want to cache the mapping of
    `row.buyer` into `buyer_names:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Here, `buyer_names` is a mapping between `ids` and `names`, and it is cached
    every hour (3600 seconds). `sort` tries to pick the names from `buyer_names` if
    possible, or else it performs the recursive select.
  prefs: []
  type: TYPE_NORMAL
- en: LIKE
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'On a relational database, you can, for example, search all records with a name
    starting with the letter `C` followed by anything (%):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'But GAE neither supports full text search, nor anything that resembles the
    SQL `LIKE` operator. Once more, we have to select all records and perform the
    filtering at the web2py level. We can use the `find` method of the `rows` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Of course, this is expensive, and not recommended for large tables (more than
    a few hundred records). If this kind of search is critical for your application,
    perhaps you should not be using GAE.
  prefs: []
  type: TYPE_NORMAL
- en: date and datetime manipulations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The same problem occurs for queries involving other expressions, such as date
    and datetime manipulations. Consider the following query that works on relational
    databases but not on GAE:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'On GAE you would have to rewrite it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Replacing slow virtual fields with DB views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Consider the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: You need to add a field called `total price` that is computed when records are
    retrieved, and is defined as the product of price by quantity for each record.
  prefs: []
  type: TYPE_NORMAL
- en: The normal way to do it is by using **virtual fields:**
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Then you can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: This is fine, but computing virtual fields at the web2py level can be slow.
    Moreover, you would not be used to involving the virtual fields in queries.
  prefs: []
  type: TYPE_NORMAL
- en: Here we propose an alternate solution that involves creating a database view
    for the table, which includes the column with computed fields, and provides a
    way for web2py to access it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Given the table, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Now, you can use `db.purchase_plus` anywhere you would use `db.numbers_plus`,
    except for inserts, with a performance increase when compared to the `VirtualFields`
    solution.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following line checks whether the view has been created already:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, it instructs the database to create it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, it defines a new web2py model, which maps into the table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: This model includes all fields from the `db.purchase` table, the new field `total_price`,
    and sets `migrate=False`, so that web2py does not attempt to create the table
    (it should not because this is not a new table, it's a view, and has been already
    created).
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Notice that not all supported databases support views, and not all of those
    that do have an `information_schema.tables`. Therefore, this recipe is not guaranteed
    to work on all supported databases, and will make your application not portable.
  prefs: []
  type: TYPE_NORMAL
