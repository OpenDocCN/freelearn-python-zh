<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Expanding your Toolset</h1></div></div></div><p>This chapter is less about rendering and more about making life easier for the day-to-day use of Blender by extending its functionality. It uses some external libraries that need to be installed, and at some point the Python scripting used is perhaps a little bit harder to read for a novice. Also, from an artist's point of view, it might be a little less visually pleasing as these scripts don't lend themselves to pretty illustrations. Nevertheless, these scripts do add genuine useful functionality, especially for a script developer, so please read on.</p><div><img alt="Expanding your Toolset" src="img/0400-09-01.jpg"/></div><p>In this chapter, we will learn how to:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">List and archive assets such as image maps</li><li class="listitem" style="list-style-type: disc">Publish a rendered image automatically with FTP</li><li class="listitem" style="list-style-type: disc">Extend the functionality of the built-in editor with regular expression searches</li><li class="listitem" style="list-style-type: disc">Speed up computations by using Psyco—a just-in-time compiler</li><li class="listitem" style="list-style-type: disc">Add version control to your scripts with Subversion</li></ul></div><div><div><div><div><h1 class="title"><a id="ch09lvl1sec70"/>To the Web and beyond—publish a finished render with FTP</h1></div></div></div><a class="indexterm" id="id611"/><p>We can save a rendered image to any location as long as it is visible in the filesystem, but not all platforms offer the possibility to make a remote FTP server accessible via a local directory (folder). This script offers us a simple option to store a rendered image on a remote FTP server and remembers the server name, the username, and (optionally) the password for later reuse.</p><a class="indexterm" id="id612"/><p>The <strong>File</strong> <strong>Transfer</strong> <strong>Protocol</strong> (<strong>FTP)</strong> that we will be using is somewhat more complicated than, for instance, the <code class="literal">HTTP</code> protocol as it uses more than one connection. Fortunately for us, all the intricacies of an FTP client are nicely encapsulated in the standard Python module <code class="literal">ftplib</code><a class="indexterm" id="id613"/>. We not only import this module's <code class="literal">FTP</code> class but a number of other standard Python modules as well, notably those for pathname manipulation (<code class="literal">os.path</code>) and for reading the standard <code class="literal">.netrc</code> file<a class="indexterm" id="id614"/> (which enables us to store passwords outside our script if we need passwords to log in to the FTP server). We will discuss each module where necessary.</p><div><pre class="programlisting">from ftplib import FTP
import os.path
import re
import netrc
import tempfile
from Blender import Image,Registry,Draw</pre></div><p>Python is almost as platform independent as it gets, but of course, sometimes there are intricacies that are not fully covered. For example, we want to use usernames and passwords stored in a <code class="literal">.netrc</code> file that is commonly used by FTP programs (and others) and the FTP client expects this file to reside in the user's home directory, which it hopes to find in an environment variable <code class="literal">HOME</code>. On Windows, however, the concept of a home directory isn't that well defined and different schemes exist to store data that is restricted to a single user; not every implementation of Python resolves this in the same way.</p><p>We, therefore, define a small utility function that checks if there is a <code class="literal">HOME</code> variable present in the environment (always the case on Unix-like operating systems and on some versions of Windows). If not, it checks whether the <code class="literal">USERPROFILE</code> variable is present (present on most versions of Windows including XP where it typically points to a directory <code class="literal">C:\Documents and Settings\&lt;yourusername&gt;</code>). If it is present it sets the <code class="literal">HOME</code> variable to the contents of this <code class="literal">USERPROFILE</code> variable:</p><div><pre class="programlisting">def sethome():
   from os import environ
   if not 'HOME' in environ:
      if 'USERPROFILE'in environ:
         environ['HOME'] = environ['USERPROFILE']</pre></div><a class="indexterm" id="id615"/><p>Our next task is to find out which FTP server the user wants to upload the rendered result to. We store this in a Blender registry key so that we don't have to bother the user with a prompt each time he wants to upload a render. The <code class="literal">getftphost()</code> function<a class="indexterm" id="id616"/> takes an argument <code class="literal">reuse</code> that may be used to clear this key if set to <code class="literal">False</code> (to allow for the possibility of choosing  a different FTP server), but rewriting the user interface to offer the user such an option is left as an exercise to the reader.</p><p>The actual code starts with retrieving the key from the registry (from disk if necessary, hence the <code class="literal">True</code> argument, highlighted). If there isn't a key present or it doesn't contain a host entry, we prompt the user for the name of the FTP server with a pop up. If the user does not specify, one we bail out by raising an exception. Otherwise, we store the hostname in the host entry—first create the dictionary if it is not present and store this dictionary in Blender's registry. Finally, we return the stored hostname.</p><div><pre class="programlisting">def getftphost(reuse=True):
   dictname = 'ftp'
   if reuse == False:
      Registry.RemoveKey(dictname)
      
<strong>   d = Registry.GetKey(dictname,True)</strong>
   if d == None or not 'host' in d:
      host = Draw.PupStrInput("Ftp hostname:", "", 45)
      if host == None or len(host) == 0 :
         raise Exception("no hostname specified")
      if d == None :
         d ={}
      d['host'] = host
      Registry.SetKey(dictname,d,True)
   return d['host']</pre></div><p>We need another utility function to make sure that a Blender image is stored on disk as the last rendered image is present as an image with the name <code class="literal">Render</code> <code class="literal">Result</code>, but this image isn't written to disk automatically. The function <code class="literal">imagefilename()</code><a class="indexterm" id="id617"/> takes a Blender image as an argument and first checks if it has a valid filename associated with it (highlighted). If not, it creates a filename from the name of the image by appending a <code class="literal">.tga</code> extension (images can be saved as TARGA files only). The full path is then constructed from this filename and the path of the <code class="literal">temp</code> directory. Now when there is a valid filename present it is saved to call the <code class="literal">save()</code> method<a class="indexterm" id="id618"/> and return the filename:</p><div><pre class="programlisting">def imagefilename(im):
<strong>   filename = im.getFilename()</strong>
<strong>   if filename == None or len(filename) == 0:</strong>
      filename = im.getName()+'.tga'
      filename = os.path.join(tempfile.gettempdir(),filename)
      im.setFilename(filename)
   im.save()
   return filename</pre></div><a class="indexterm" id="id619"/><p>When we upload a file to an FTP server we want to make sure that we do not overwrite any existing file. If we do find that a file with a given name is already present we'd like to have a function that creates a new filename in a predictable fashion—much like the way Blender behaves when creating names for Blender objects. We'd like to preserve the extension of the filename so we cannot simply stick to a numerical suffix. The <code class="literal">nextfile()</code> function,<a class="indexterm" id="id620"/> therefore, starts by splitting the pathname and extension parts of the filename. It uses the <code class="literal">split()</code><a class="indexterm" id="id621"/> and <code class="literal">splitext()</code><a class="indexterm" id="id622"/> functions from the <code class="literal">os.path</code> module to leave us with the bare <code class="literal">name</code>.</p><p>If the name already ends in a suffix consisting of a dot and some number (for example, <code class="literal">.42</code>) we'd like to increment this number. This is exactly what the rather daunting highlighted lines accomplish. The <code class="literal">sub()</code> function<a class="indexterm" id="id623"/> of Python's <code class="literal">re</code> module takes a regular expression as a first argument (we use a raw string here so we don't have to escape any backslashes) and checks whether this regular expression matches its third argument (<code class="literal">name</code> in this case). The regular expression used here (<code class="literal">\.(\d+)$</code>) matches a dot followed by one or more decimal digits if and only if these digits are the last characters. If this pattern does match it is replaced by the second argument of the <code class="literal">sub()</code> function. In this case the replacement is not a simple string but a <code class="literal">lambda</code> (that is, unnamed) function that will be passed a <code class="literal">match</code> object and is expected to return a string.</p><p>As we surrounded the digits part of our regular expression with parentheses, we can retrieve just these digits—without the leading dot—with a call to the <code class="literal">match</code> object's <code class="literal">group()</code> method<a class="indexterm" id="id624"/>. We pass it a <code class="literal">1</code> as argument, as the first opening parenthesis marks the first group (group 0 would be the whole pattern). We convert this string of digits to an integer by using the built-in <code class="literal">int()</code> function<a class="indexterm" id="id625"/>, add 1 to it, and convert it back again to a string with the <code class="literal">str()</code> function<a class="indexterm" id="id626"/>. Before this result is automatically returned from the <code class="literal">lambda</code> function<a class="indexterm" id="id627"/> we prepend a dot again to conform to our desired pattern.</p><p>We finish by checking if the resulting name is different from the original one. If they are the same the original name did not match our pattern and we just append <code class="literal">.1</code> to the name. Finally, we reconstruct the full filename by adding the extension and calling the <code class="literal">join()</code> function<a class="indexterm" id="id628"/> from <code class="literal">os.path</code> to add the path in a platform-independent way:</p><div><pre class="programlisting">def nextfile(filename):
   (path,base) = os.path.split(filename)
   (name,ext) = os.path.splitext(base)
<strong>   new = re.sub(r'\.(\d+)$',lambda m:'.'+str(1+int(m.group(1))),name)</strong>
   if new == name :
      new = name + '.1'
   return os.path.join(path,new+ext)</pre></div><p>Now, we are all set to do the real work of uploading a file to an FTP server. First, we make sure that our environment has a suitable <code class="literal">HOME</code> variable by calling the <code class="literal">sethome()</code> function<a class="indexterm" id="id629"/>
<a class="indexterm" id="id630"/>. Then, we retrieve the hostname of the FTP server we want to upload to (it is perfectly valid, by the way, to enter an IP address instead of a hostname):</p><div><pre class="programlisting">if __name__ == "__main__":
   sethome()
   host = getftphost()</pre></div><a class="indexterm" id="id631"/><p>Next, we retrieve the user's credentials for the selected host from the <code class="literal">.netrc</code> file if there is one present (highlighted). This may fail for various reasons (there might not be a <strong>.</strong><code class="literal">netrc</code> file or the given host has no entry in this file); in which case an exception will be raised. If this happens we inform the user and ask for a username and password instead with suitable pop ups:</p><div><pre class="programlisting">   try:
<strong>      (user,acct,password) = netrc.netrc().authenticators(host)</strong>
   except:
      acct=None
      user = Draw.PupStrInput('No .netrc file found, enter username:',
"",75)
      password = Draw.PupStrInput('Enter password:',"",75)</pre></div><p>The rendered image will have been stored as a Blender <code class="literal">Image</code> object with the name <code class="literal">Render</code> <code class="literal">Result</code>. The next thing we do is retrieve a reference to this image and make sure it is stored on disk. The <code class="literal">imagefilename()</code> function<a class="indexterm" id="id632"/> that we defined earlier will return the filename of the stored image.</p><p>The next step is to connect to the FTP server by using the hostname and credentials we retrieved earlier (highlighted). Once the connection is established we retrieve a list of filenames with the <code class="literal">nlst()</code> method:<a class="indexterm" id="id633"/>
</p><div><pre class="programlisting">   im = Image.Get('Render Result')
   filename = imagefilename(im)
      
<strong>   ftp = FTP(host,user,password,acct)</strong>
   files = ftp.nlst()</pre></div><p>Because we want to make sure that we do not overwrite any files on the FTP server, we strip the path from the filename of our stored image with the <code class="literal">basename()</code> function<a class="indexterm" id="id634"/> and compare the result to the list of filenames retrieved from the server (highlighted). If the filename is already present we generate a new filename with the <code class="literal">nextfile()</code> function<a class="indexterm" id="id635"/> and check again and keep on doing that until we finally have a filename that isn't used yet on the FTP server.</p><div><pre class="programlisting">   dstfilename = os.path.basename(filename)
<strong>   while dstfilename in files:</strong>
      dstfilename = nextfile(dstfilename)</pre></div><a class="indexterm" id="id636"/><p>Then, we upload our image file by calling the <code class="literal">storbinary()</code> method<a class="indexterm" id="id637"/>. This method will take the destination filename prefixed with <code class="literal">STOR</code> as the first argument and an open file descriptor as the second argument. We provide the latter by calling Python's built-in <code class="literal">open()</code> function<a class="indexterm" id="id638"/> with the name of our image file as the single argument. (For more details on the rather outlandish behavior of the <code class="literal">ftplib</code> module, refer to its documentation on <a class="ulink" href="http://docs.python.org/library/ftplib.html.">http://docs.python.org/library/ftplib.html.</a>) We gracefully end the connection to the FTP server by calling the <code class="literal">quit()</code> method and inform the user about the completion of the task by showing a message that mentions the destination filename as this might be different than expected if a similarly named file exists:</p><div><pre class="programlisting">   ftp.storbinary('STOR '+dstfilename,open(filename))
   
   ftp.quit()
   
   Draw.PupMenu('Render result stored as "%s"%s|Ok'%(dstfilename,'%t'))</pre></div><p>The full code is available as <code class="literal">ftp.py</code> in <code class="literal">ftp.blend</code>. It may be run from the text editor but in this case it is certainly far more convenient to put <code class="literal">ftp.py</code> in Blender's <code class="literal">scripts</code> directory. The script is configured to make itself available in the <strong>File | Export</strong> menu.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec71"/>Spring cleaning—archive unused images</h1></div></div></div><a class="indexterm" id="id639"/><p>After a while, any long-running project gathers a lot of cruft. For example, texture images that were tried once but were discarded in favor of better ones. This script will help us retain a bit of order by finding all files in a selected directory that are not referenced by our <code class="literal">.blend</code> file and packing them into a <strong>ZIP</strong> <strong>archive</strong><a class="indexterm" id="id640"/>.</p><p>We will take care not to move any <code class="literal">.blend</code> files to the ZIP archive (after all, those we normally want to be able to render) nor the ZIP archive itself (to prevent endless recursion). Any file that we archive we subsequently try to remove, and if removing a file leaves an empty directory, we remove that directory as well unless it is the directory our <code class="literal">.blend</code> file resides in.</p><p>The file manipulation functions are provided by Python's <code class="literal">os</code> and <code class="literal">os.path</code> modules and ZIP files that can be used both on Windows and open platforms can be manipulated with the use of the <code class="literal">zipfile</code> module<a class="indexterm" id="id641"/>. The <code class="literal">zipfile</code> that we move the unused files to we will name <code class="literal">Attic.zip</code>:</p><div><pre class="programlisting">import Blender
from os import walk,remove,rmdir,removedirs
import os.path
from zipfile import ZipFile

zipname = 'Attic.zip'</pre></div><p>The first challenge is to generate a list of all files in the directory where our <code class="literal">.blend</code> file sits. The function <code class="literal">listfiles()</code> <a class="indexterm" id="id642"/>uses the <code class="literal">walk()</code> function<a class="indexterm" id="id643"/> from Python's <code class="literal">os</code> module to recursively descend into the tree of directories and produces a list of files along the way.</p><a class="indexterm" id="id644"/><p>By default, the <code class="literal">walk()</code> function traverses the directory tree's depth first that allows us to alter the list of directories on the fly. This feature is used here to remove any directories that start with a dot (highlighted). This isn't necessary for the current and parent directories (represented by <strong>..</strong> and <strong>.</strong> respectively) because <code class="literal">walk()</code> already filters them out, but this allows us, for example, to also filter out any <code class="literal">.svn</code> directories that we may encounter.</p><p>The line containing the <code class="literal">yield</code> statement returns the results one file at a time so our function may be used as an iterator. (For more on iterators, refer to the online documentation at <a class="ulink" href="http://docs.python.org/reference/simple_stmts.html#yield">http://docs.python.org/reference/simple_stmts.html#yield</a>) We join the filename proper and the path to form a complete filename and normalize it (that is, remove double path separators and the like); although normalizing here isn't strictly necessary because <code class="literal">walk()</code> is expected to return any paths in normalized form:</p><div><pre class="programlisting">def listfiles(dir):
   for root,dirs,files in walk(dir):
      for file in files:
         if not file.startswith('.'):
            yield os.path.normpath(os.path.join(root,file))
      for d in dirs:
<strong>         if d.startswith('.'):</strong>
            dirs.remove(d)</pre></div><p>Before we can compare the list of files our <code class="literal">.blend</code> file uses to the list of files present in the directory, we make sure any packed file is unpacked to its original file location. This isn't strictly necessary but ensures that we don't move any files to the archive that are not directly used but do have a copy inside the <code class="literal">.blend</code> file<a class="indexterm" id="id645"/>:</p><div><pre class="programlisting">def run():
   Blender.UnpackAll(Blender.UnpackModes.USE_ORIGINAL)</pre></div><p>The <code class="literal">GetPaths()</code> function<a class="indexterm" id="id646"/> from the Blender module produces a list of all files used by the <code class="literal">.blend</code> file (except for the <code class="literal">.blend</code> file itself). We pass it an absolute argument set to <code class="literal">True</code> to retrieve filenames with a full path instead of paths relative to the current directory in order to compare these properly with the list produced by the <code class="literal">listfiles()</code> function.</p><p>Again, we normalize these filenames as well. The highlighted line shows how we retrieve the absolute path of the current directory by passing the shorthand for the current Bender directory ( <code class="literal">//</code> ) to the <code class="literal">expandpath()</code> function<a class="indexterm" id="id647"/>:</p><div><pre class="programlisting">   files = [os.path.normpath(f) for f inBlender.GetPaths(absolute=True)]
<strong>   currentdir = Blender.sys.expandpath('//')</strong>
</pre></div><a class="indexterm" id="id648"/><p>Next we create a <code class="literal">ZipFile</code> object in <em>write</em> mode. This will truncate any existing archive with the same name and enables us to add files to the archive. The full name of the archive is constructed by joining the current Blender directory and the name we want to use for the archive. The use of the <code class="literal">join()</code> function from the <code class="literal">os.path</code> module ensures that we construct the full name in a platform-independent way. We set the <code class="literal">debug</code> argument of the <code class="literal">ZipFile</code> object to <code class="literal">3</code> to report anything unusual to the console when creating the archive:</p><div><pre class="programlisting">   zip = ZipFile(os.path.join(currentdir,zipname),'w')
   zip.debug = 3</pre></div><p>The <code class="literal">removefiles</code> variable<a class="indexterm" id="id649"/> will record the names of the files we want to remove after we have constructed the archive. We can only safely remove files and directories after we have created the archive or we might refer to directories that no longer exist.</p><p>The archive is constructed by looping over the list of all the files in the current Blender directory and comparing them to the list of files used by our <code class="literal">.blend</code> file. Any file with an extension such as <code class="literal">.blend</code> or <code class="literal">.blend1</code> is skipped (highlighted) as is the archive itself. The files are added to the ZIP file using the <code class="literal">write()</code> method<a class="indexterm" id="id650"/>, which accepts as a parameter, the filename with a path relative to the archive (and hence the current directory). That way it is easier to unpack the archive in a new location. Any references to files outside the current directory tree are unaffected by the <code class="literal">relpath()</code> function. Any file we add to the archive is marked for removal by adding it to the <code class="literal">removefiles</code> list. <a class="indexterm" id="id651"/>Finally, we close the archive—an important step because omitting it may leave us with a corrupted archive:</p><div><pre class="programlisting">   removefiles = []
   for f in listfiles(currentdir):
<strong>      if not (f in files </strong>
<strong>or os.path.splitext(f)[1].startswith('.blend') </strong>
<strong>or os.path.basename(f) == zipname):</strong>
         rf = os.path.relpath(f,currentdir)
         zip.write(rf)
         removefiles.append(f)
            
   zip.close()</pre></div><p>The last task left is to remove the files we moved to the archive. The <code class="literal">remove()</code> function<a class="indexterm" id="id652"/> from Python's <code class="literal">os</code> module will accomplish that but we also want to remove any directory that ends up empty after removing the files. Therefore, for each file we remove we determine the name of its directory. We also check if this directory doesn't point to the current directory because we want to make absolutely sure we do not remove it as this is where our <code class="literal">.blend</code> files reside. Although an unlikely scenario, it is possible to open a <code class="literal">.blend</code> file in Blender and remove the <code class="literal">.blend</code> file itself that might leave an empty directory. If we remove this directory any subsequent (auto) save would fail. The <code class="literal">relpath()</code> function<a class="indexterm" id="id653"/> will return a dot if the directory passed as its first argument points to the same directory as the directory passed as its second argument. (The <code class="literal">samefile()</code> function<a class="indexterm" id="id654"/> is more robust and direct but not available on Windows.)</p><a class="indexterm" id="id655"/><p>If we made certain we are not referring to the current directory we use the <code class="literal">removedirs()</code> function<a class="indexterm" id="id656"/> to remove the directory. If the directory is not empty this will fail with an <code class="literal">OSError</code> exception (that is, the file we removed was not the last file in the directory), which we ignore. The <code class="literal">removedirs()</code> function will also remove all parent directories leading to the directory iff they are empty, which is exactly what we want:</p><div><pre class="programlisting">   for f in removefiles:
      remove(f)
      d = os.path.dirname(f)
      if os.path.relpath(d,currentdir) != '.':
         try:
            removedirs(d)
         except OSError:
            pass
      
if __name__ == '__main__':
   run()</pre></div><p>The full code is available as <code class="literal">zip.py</code> in <code class="literal">attic.blend</code>.</p></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec72"/>Extending the editor—searching with regular expressions</h1></div></div></div><a class="indexterm" id="id657"/><p>The <strong>editor</strong> already provides basic search and replace functionality but if you are used to other editors you might miss the possibility to search using <strong>regular expressions</strong>. This plug-in provides this functionality.</p><a class="indexterm" id="id658"/><p>Regular expressions are very powerful and many programmers love their versatility (and many others loathe their poor readability). Whether you love or hate them, they are very expressive: matching any decimal number can simply be expressed as <code class="literal">\d+</code> for example (one or more digits). If you are looking for a word that is spelled differently in British or American English, such as colour/color, you can match any of them with the expression <code class="literal">colou?r</code> (color with an optional <em>u</em>).</p><p>The following code will show that Blender's built-in editor can be equipped with this useful search tool with just a few lines of code. The script provided should be installed in Blender's <code class="literal">scripts</code> directory and can then be invoked from the text editor menu as <strong>Text | Text Plugins | Regular Expression Search</strong> or by a hot key <em>Alt + Ctrl + R</em>. It will pop up a small input widget where the user may enter a regular expression (this pop up will remember the last regular expression entered) and if the user clicks on the <strong>OK</strong> button or hits <em>Enter</em> the cursor will be positioned at the first occurrence that matches the regular expression, highlighting the extent of the match.</p><div><img alt="Extending the editor—searching with regular expressions" src="img/0400-09-02.jpg"/></div><p>To register the script as a text plug-in with the designated hot key the first lines of the script consist of the customary headers augmented with a <code class="literal">Shortcut:</code> entry (highlighted below):</p><div><pre class="programlisting">#!BPY
"""
Name: 'Regular Expression Search'
Blender: 249
Group: 'TextPlugin'
<strong>Shortcut: 'Ctrl+Alt+R'</strong>
Tooltip: 'Find text matching a regular expression'
"""</pre></div><p>The next step is to import the necessary modules. Python supplies us with a standard <code class="literal">re</code> module, which is well documented (the online docs are sufficient even for novice users unfamiliar with regular expressions), and we import Blender's <code class="literal">bpy</code> module.<a class="indexterm" id="id659"/> In this book we do not often use this module as it is marked as experimental, but in this case we need it to find out which text buffer is the active one:</p><div><pre class="programlisting">from Blender import Draw,Text,Registry
import bpy
import re</pre></div><p>To signal any error conditions, such as an illegal regular expression or when nothing matches, we define a simple <code class="literal">popup()</code> function:<a class="indexterm" id="id660"/>
</p><div><pre class="programlisting">def popup(msg):
   Draw.PupMenu(msg+'%t|Ok')
   return</pre></div><p>Because we want to remember the last regular expression the user entered we will be using Blender's registry and, therefore, we define a key to use:</p><div><pre class="programlisting">keyname = 'regex'</pre></div><p>The <code class="literal">run()</code> function <a class="indexterm" id="id661"/>ties all functionality together; it retrieves the active text buffer and bails out if there isn't one:</p><div><pre class="programlisting">def run():
   
   txt = bpy.data.texts.active
   if not txt: return</pre></div><p>Subsequently, it retrieves the cursor position within this buffer:</p><div><pre class="programlisting">   row,col = txt.getCursorPos()</pre></div><p>B<a class="indexterm" id="id662"/>efore presenting the user with a pop up to enter a regular expression we check if we stored one earlier in the registry. We simply retrieve it and if it fails we set the default expression to the empty string (highlighted). Note that we do not pass any extra parameters to the <code class="literal">GetKey()</code> function <a class="indexterm" id="id663"/>because we do want to store any information on disk in this case. If the user enters an empty string we simply return without searching:</p><div><pre class="programlisting">   d=Registry.GetKey(keyname)
   try:
      default = d['regex']
   except:
<strong>      default = ''</strong>
   pattern = Draw.PupStrInput('Regex: ',default,40)
   if pattern == None or len(pattern) == 0 : return</pre></div><p>We compile the regular expression to see if it's valid and if this fails we show a message and return:</p><div><pre class="programlisting">   try:
      po = re.compile(pattern)
   except:
      popup('Illegal expression')
      return</pre></div><p>Now that we know the regular expression is correct, we iterate over all lines of the text buffer starting at the line the cursor is on (highlighted). For each line we match our compiled regular expression to the string (or the part after the cursor if it is the first line).</p><div><pre class="programlisting">   first = True
<strong>   for string in txt.asLines(row):</strong>
      if first :
         string = string[col:]
      mo = re.search(po,string)</pre></div><p>If there is a match we note the start of the match within the line and the length of the match (suitably set off if it's the first line) and set the cursor position to the current line and the start of the match (highlighted). We also set the "select position" to the position of the match plus the length of the match so our match will be highlighted and then returned. If there is no match within the line we increment the row index and continue the iteration.</p><p>I<a class="indexterm" id="id664"/>f there is nothing left to iterate over, we signal the user that we did not find any match. In all cases, we store the regular expression in the registry for reuse:</p><div><pre class="programlisting">      if mo != None :
         i = mo.start()
         l = mo.end()-i
         if first :
            i += col
<strong>         txt.setCursorPos(row,i)</strong>
         txt.setSelectPos(row,i+l)
         break
      row += 1
      first = False
      
   else :
      popup('No match')
   Registry.SetKey(keyname,{'regex':pattern})

if __name__ == '__main__':
   run()</pre></div><p>The full code is available as <code class="literal">regex.py</code> in <code class="literal">regex.blend</code> but should be installed in Blender's <code class="literal">scripts</code> directory with a suitable name, such as <code class="literal">textplugin_regex.py</code>.</p></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec73"/>Extending the editor—interacting with Subversion</h1></div></div></div><p>W<a class="indexterm" id="id665"/>
<a class="indexterm" id="id666"/>hen actively developing scripts it can be difficult to keep track of changes or to revert to previous versions. This is not unique to writing Python scripts in Blender and over the years a number of <strong>version control</strong> systems <a class="indexterm" id="id667"/>have evolved. One of the better known, and widely used ones is <strong>Subversion</strong> <a class="indexterm" id="id668"/>(<a class="ulink" href="http://subversion.tigris.org">http://subversion.tigris.org</a>). In this section, we show how the editor can be augmented to commit or update a text file from a repository.</p><p>Interaction with a Subversion repository is not provided by a bundled Python module so we have to get that from somewhere else. The <strong>Downloads</strong> section of <a class="ulink" href="http://pysvn.tigris.org">http://pysvn.tigris.org</a> contains both source and binary distributions for many platforms. Be sure to get the right one since both the supported version of Subversion and the version of Python may differ. The scripts we develop here are tested against Subversion 1.6.x and Python 2.6.x but should work with earlier versions of Subversion as well.</p><p>We will be implementing the functionality to commit a text file to a repository and to update a file (that is, get the latest revision from the repository). If we try to commit a file that is not part of the repository yet we will add it, but we will not implement tools to create a repository or check out a working copy. A tool such as <strong>TortoiseSVN</strong> <a class="indexterm" id="id669"/>on Windows (<a class="ulink" href="http://tortoisesvn.tigris.org/">http://tortoisesvn.tigris.org/</a>) or any number of tools for open platforms are far better equipped for that. We just assume a checked-out working directory where we store our Blender text files. (This working directory might be completely different from your Blender project directory.)</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec94"/>Committing a file to the repository</h2></div></div></div><p>C<a class="indexterm" id="id670"/>ommitting a text buffer to the repository is a two-step process. First, we have to save the contents of the text buffer to a file and then we commit this file to the repository. We have to check whether the text block has an associated filename and prompt the user to save the file first if it hasn't got one yet. The user must save the file to a checked out directory in order to commit the file to a repository.</p><p>Just like the extension that allowed us to search with regular expressions, this one starts with a suitable header to identify it as a text editor plug-in and to assign a keyboard shortcut. We define the mnemonic <em>Ctrl + Alt + C</em> for committing (highlighted) as we will define <em>Ctrl + Alt + U</em> for updating in its companion script. We also import the necessary modules, notably the <code class="literal">pysvn</code> module:<a class="indexterm" id="id671"/>
</p><div><pre class="programlisting">#!BPY
"""
Name: 'SVNCommit'
Blender: 249
Group: 'TextPlugin'
<strong>Shortcut: 'Ctrl+Alt+C'</strong>
Tooltip: 'Commit current textbuffer to svn'
"""


from Blender import Draw,Text,Registry
import bpy
import pysvn

def popup(msg):
   Draw.PupMenu(msg+'%t|Ok')
   return</pre></div><p>T<a class="indexterm" id="id672"/>he <code class="literal">run()</code> function <a class="indexterm" id="id673"/>first tries to get the active text buffer and will return without a croak if there isn't one. Then it checks if there is a filename defined for this text buffer (highlighted). If not, it reminds the user to save the file first (thus defining a filename and placing the file in a checked out directory) and returns.</p><div><pre class="programlisting">def run():
   
   txt = bpy.data.texts.active
   if not txt: return
   
   fn = txt.getFilename()
<strong>   if fn == None or len(fn) == 0:</strong>
      popup('No filename defined: save it first')
      return</pre></div><p>The next step is to create a <code class="literal">pysvn</code> client object that will enable us to interact with a repository. Its <code class="literal">info()</code> method <a class="indexterm" id="id674"/>allows us to retrieve information about the repository status of a file (highlighted). If there is no information the file will not have been added to the repository yet—a situation that we correct by calling the <code class="literal">add()</code> method:<a class="indexterm" id="id675"/>
</p><div><pre class="programlisting">   svn = pysvn.Client()
<strong>   info = svn.info(fn)</strong>
   if info == None:
      popup('not yet added to repository, will do that now')
      svn.add(fn)</pre></div><p>Next, we write out the current contents of the text buffer by joining all the lines in it to a single chunk of data and writing that to the file object we opened on the filename associated with the buffer:</p><div><pre class="programlisting">   file=open(fn,'wb')
   file.write('\n'.join(txt.asLines()))
   file.close()</pre></div><p>T<a class="indexterm" id="id676"/>his file will be committed to the repository with the <code class="literal">checkin()</code> method <a class="indexterm" id="id677"/>to which we pass a rather uninformative commit message. It might be a good idea to prompt the user for a more sensible message. Finally, we inform the user of the resulting revision.</p><div><div><h3 class="title"><a id="note29"/>Note</h3><p>Note that Subversion revision numbers are not associated with a file but with a repository, so this number may differ by more than one from the previous file commit if meanwhile other files were committed.</p></div></div><div><pre class="programlisting">   version = svn.checkin(fn,'Blender commit')
   popup('updated to rev. '+str(version))
 
if __name__ == '__main__':
   run()</pre></div><p>The full code is available as <code class="literal">textplugin_commit</code> in <code class="literal">svn.blend</code> but should be installed in Blender's <code class="literal">scripts</code> directory.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec95"/>Updating a file from the repository</h2></div></div></div><p>T<a class="indexterm" id="id678"/>he whole purpose of a repository is being able to collaborate, which means that others may change the files we are working on as well and we must be able to retrieve those committed changes. This is called updating a file and means that we copy the latest version that resides in the repository to our working directory.</p><p>Besides checking whether the text buffer is saved and the file is already added to the repository, we must also check whether our current version is newer or altered from the version in the repository. If so, we offer the user the choice of discarding these changes and reverting to the version in the repository or to commit the version residing in the text buffer. (A third option, merging the differences is not provided here; although Subversion is certainly able to do that, at least for text files, but this is better left to more versatile tools such as TortoiseSVN.)</p><p>The first part of the script is very similar to the commit script. The main difference is a different shortcut key:</p><div><pre class="programlisting">#!BPY
"""
Name: 'SVNUpdate'
Blender: 249
Group: 'TextPlugin'
Shortcut: 'Ctrl+Alt+U'
Tooltip: 'Update current textbuffer from svn'
"""

from Blender import Draw,Text,Registry
import bpy
import re
import pysvn

def popup(msg):
   Draw.PupMenu(msg+'%t|Ok')
   return</pre></div><p>T<a class="indexterm" id="id679"/>he <code class="literal">run()</code> function also starts off quite similar as it retrieves the active text buffer (if any) and checks whether the text buffer has an associated filename (highlighted). It also checks if the filename was already added to the repository and if not, corrects this by calling the <code class="literal">add()</code> method and informs the user with a pop up:</p><div><pre class="programlisting">def run():
   
   txt = bpy.data.texts.active
   if not txt: return
   
   fn = txt.getFilename()
<strong>   if fn == None or len(fn) == 0:</strong>
      popup('No filename defined: save it first')
      return
   svn = pysvn.Client()
   info = svn.info(fn)
   if info == None:
      popup('not yet added to repository, will do that now')
      svn.add(fn)</pre></div><p>After writing the contents of the text buffer to its associated file it calls the <code class="literal">status()</code> method to see if the file we have written (and therefore the contents of the text buffer) is modified compared to the version in the repository (highlighted). The <code class="literal">status()</code> method <a class="indexterm" id="id680"/>may be passed a <em>list</em> of filenames as well and always returns a list of results, even when we pass it just a single filename—hence the <code class="literal">[0]</code> index. If our text buffer is modified we inform the user and offer a choice: either discard the changes and retrieve the version stored in the repository or commit the current version. It is also possible to cancel the action altogether by clicking outside the menu, in which case <code class="literal">PupMenu()</code> will return <code class="literal">-1</code>:</p><div><pre class="programlisting">   file=open(fn,'wb')
   file.write('\n'.join(txt.asLines()))
   file.close()
   
<strong>   if svn.status(fn)[0].text_status == pysvn.wc_status_kind.modified:</strong>
      c=Draw.PupMenu('file probably newer than version in'+
           'repository%t|Commit|Discard changes')
      if c==1:
         svn.checkin(fn,'Blender')
         return
      elif c==2:
         svn.revert(fn)</pre></div><p>After retrieving the version from the repository we refresh the contents of our text buffer:</p><div><pre class="programlisting">   txt.clear()
   file=open(fn)
   txt.write(file.read())
   file.close()</pre></div><p>F<a class="indexterm" id="id681"/>inally, we inform the user with a pop up what the revision number is of the content in the text buffer by calling the <code class="literal">status()</code> method again and fetching the <code class="literal">commit_revision</code> field:</p><div><pre class="programlisting">   popup('updated to rev. '+str(svn.status(fn)[0].entry.commit_revision))
   
if __name__ == '__main__':
   run()</pre></div><p>The full code is available as <code class="literal">textplugin_svnupdate</code> in <code class="literal">svn.blend</code>, and like its commit counterpart it should be installed in Blender's <code class="literal">scripts</code> directory.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec96"/>Working with a repository</h2></div></div></div><p>A<a class="indexterm" id="id682"/>lthough a full tutorial on working with Subversion is out of scope of this book, it might be useful to sketch a workflow for a Blender project where scripted components are versioned.</p><p>It is important to understand that a Blender project itself does not have to be under version control. We may organize our Blender project in any way that makes sense and have a <code class="literal">scripts</code> directory within it that is under version control.</p><p>Say we have created a repository for scripts on a network storage device and created a Blender project directory on our local machine. In order to bring our scripts under version control we have to perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Check out the script's repository within our Blender project directory (this is called the <strong>working copy</strong> of the repository).</li><li class="listitem">Create a script within our <code class="literal">.blend</code> file with the built-in editor.</li><li class="listitem">Save this script to the working copy.</li><li class="listitem">Every time we change something, we press <em>Ctrl + Alt + C</em> to commit our changes.</li><li class="listitem">Every time we start working on our script again we press <em>Ctrl + Alt + U</em> first to see if someone else has changed anything.</li></ol></div><p>N<a class="indexterm" id="id683"/>ote that there is nothing against bringing all assets, such as textures or <code class="literal">.blend</code> files that act as libraries under version control but we have to use a separate client to commit changes. It would be an interesting exercise to create some scripts that commit or update all files in the current Blender directory.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec74"/>The need for speed—using Psyco</h1></div></div></div><p>P<a class="indexterm" id="id684"/>ython is an interpreted language: all instructions in a script are interpreted and executed again and again when they are encountered. This may sound inefficient but for a developer of a program the advantage of being able to quickly develop and test a program may outweigh the disadvantage of a slower running program. And interpreting might be inefficient but that is not identical to slow. Python is a very high-level language so a single language element might be equivalent to a lot of low-level instructions. Besides, given modern hardware even a slow script might be finished faster than a user expects a result.</p><p>Nevertheless, there are situations where any speed increase is welcome. From all the examples we have seen in this book Pynodes are probably the most computationally intensive as the instructions are run for every visible pixel in a texture or shader and often even many more times per pixel if oversampling is taken into account. Saving a few milliseconds from a script that takes less than a second to execute doesn't amount to much, but saving 20% of the rendering time amounts to a significant amount of time saved when rendering a 500 frame shot.</p><p>
<strong>Enter</strong><a class="indexterm" id="id685"/>
<a class="indexterm" id="id686"/> <strong>Psyco</strong>: Psyco is a Python extension that tries to speed up the execution of a script by compiling frequently used parts of a script to machine instructions and storing them for reuse. This process is often called <strong>just-in-time compilation</strong> <a class="indexterm" id="id687"/>and is akin to just-in-time compilation in other languages such as Java. (The implementation is similar in concept but quite different in implementation due to Python's dynamic typing. This is of no concern to developers of Python scripts.) What matters is that Psyco may be used in any script without any changes in the code except for adding a few lines.</p><p>Psyco is available as a binary package for Windows and can be compiled from source on other platforms. Full instructions are available on the Psyco website: <a class="ulink" href="http://psyco.sourceforge.net/">http://psyco.sourceforge.net/</a>.</p><p>Do verify that you install the version that fits your Python installation because although the site states that the version compiled for Python 2.5 should work for 2.6 as well, it still might fail, so rather use the version specifically compiled for 2.6. Now, what speed increase might we expect? That is difficult to estimate but easy enough to measure! Just render a frame and note the time it took, then import psyco in your code, render again, and note the difference. If it is significant leave the code in, otherwise you might remove it again.</p><p>In the following table some results are listed for the test scene provided in <code class="literal">pysco.blend</code> but your mileage may vary. Also note that the test scene is a rather optimistic scenario as most of the render is covered by a texture generated by a Pynode. If this were less, the gain in speed would be less, but this does give an estimate of what is possible with Psyco. A factor two for the relevant code is readily achievable. The following table lists some illustrating sample timings:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Time in seconds</p>
</th><th style="text-align: left" valign="bottom">
<p>Without Psyco</p>
</th><th style="text-align: left" valign="bottom">
<p>With Psyco</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Netbook</p>
</td><td style="text-align: left" valign="top">
<p>52.7</p>
</td><td style="text-align: left" valign="top">
<p>26.3</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Desktop</p>
</td><td style="text-align: left" valign="top">
<p>14.01</p>
</td><td style="text-align: left" valign="top">
<p>6.98</p>
</td></tr></tbody></table></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec97"/>Enabling Psyco</h2></div></div></div><a class="indexterm" id="id688"/><p>The following code shows the additional lines needed to enable psyco on our previously encountered <code class="literal">raindrops</code> Pynode. Changes are indicated in bold.</p><div><pre class="programlisting">&lt;... all other code unchanged ...&gt;

__node__ = Raindrops

<strong>try:</strong>
<strong>   import psyco</strong>
<strong>   psyco.bind(Raindrops.__call__)</strong>
<strong>   print 'Psyco configured'</strong>
<strong>except ImportError:</strong>
<strong>   print 'Psycho not configured, continuing'</strong>
<strong>   pass   </strong>
</pre></div><p>So basically, only a few lines are added after the definition of the Pynode. Make sure to click on the <strong>Update</strong> button on the Pynode otherwise the code will not be recompiled and changes will not be visible.</p><p>The previous code just tries to import the <code class="literal">psyco</code> module. If this fails (for any reason) an informative message is printed on the console but the code will run correctly, nevertheless. If it is imported we instruct Psyco to optimize the <code class="literal">__call__()</code> method by calling the <code class="literal">bind()</code> function with a reference to this <code class="literal">__call__</code> method as an argument and inform the user on the console that we successfully configured Psyco.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec75"/>Summary</h1></div></div></div><p>In this chapter we looked beyond 3D and rendering and saw how to make life happier for a Python developer and artist alike by providing some scripts to help in some common housekeeping tasks by extending the functionality of the built-in editor with regular expression searches and version control and showed how to save valuable rendering time in some situations by using Psyco. Specifically, we learned:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">How to list and archive assets such as image maps</li><li class="listitem" style="list-style-type: disc">How to publish a rendered image automatically with FTP</li><li class="listitem" style="list-style-type: disc">How to extend the functionality of the built-in editor with regular expression searches</li><li class="listitem" style="list-style-type: disc">How to speed up computations using Psyco—a just-in-time compiler</li><li class="listitem" style="list-style-type: disc">How to add version control to your scripts with Subversion</li></ul></div></div></body></html>