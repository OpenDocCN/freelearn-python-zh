<html><head></head><body>
  <div id="sbo-rt-content"><div class="chapter" title="Chapter 7. Retrieving Data from the Real World with Sensors"><div class="titlepage"><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Retrieving Data from the Real World with Sensors</h1></div></div></div><p>In this chapter, we will work with a variety of sensors to retrieve data from the real world. We will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Understanding sensors and their connection types</li><li class="listitem" style="list-style-type: disc">Learn the most important things we must consider when choosing sensors</li><li class="listitem" style="list-style-type: disc">Take advantage of the <code class="literal">upm</code> library with many different sensors</li><li class="listitem" style="list-style-type: disc">Measure the magnitude and direction of proper acceleration or g-force with an accelerometer</li><li class="listitem" style="list-style-type: disc">Work with a three axis analog accelerometer</li><li class="listitem" style="list-style-type: disc">Use a digital accelerometer that works with the I<sup>2</sup>C bus</li><li class="listitem" style="list-style-type: disc">Work with the <code class="literal">mraa</code> library and the I<sup>2</sup>C bus to control a digital accelerometer</li><li class="listitem" style="list-style-type: disc">Measure ambient temperature with an analog sensor</li><li class="listitem" style="list-style-type: disc">Use a digital temperature and humidity sensor that works with the I<sup>2</sup>C bus</li></ul></div><div class="section" title="Understanding sensors and their connection types"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec62"/>Understanding sensors and their connection types</h1></div></div></div><p>In <a class="link" href="ch06.html" title="Chapter 6. Working with Analog Inputs and Local Storage">Chapter 6</a>, <span class="emphasis"><em>Working with Analog Inputs and Local Storage</em></span>, we used a photoresistor that is included<a id="id317" class="indexterm"/> in a voltage divider and we connected it to an analog input pin. We were able to measure the ambient light and we determined different darkness levels and change the brightness levels of an RGB LED. The photoresistor, also known as<a id="id318" class="indexterm"/> <span class="strong"><strong>LDR</strong></span> (short for <span class="strong"><strong>Light-Dependent Resistor</strong></span>) or photocell, is a sensor. We just needed to include it in a voltage divider to make the changes in the resistance value of the photoresistor via the ambient light. These variations in the resistance value will generate changes in the voltage value in our analog pin. Thus, we worked with a configuration of electronic components that generated an analog sensor, capable of transforming changes in the environment light into voltage values.</p><p>There are a huge number of sensors that allow us to retrieve data from the real world and convert it into analog or digital values that we can collect with the different communications ports included in the Intel Galileo Gen 2 board and process with Python and different libraries. When we worked with the photoresistor to measure the environment light, we wired the configuration to an analog pin and we worked with the <code class="literal">mraa</code> library and then the <code class="literal">wiring-x86</code> library to take advantage of the analog to digital converter to retrieve the values.</p><p>In <a class="link" href="ch02.html" title="Chapter 2. Working with Python on Intel Galileo Gen 2">Chapter 2</a>, <span class="emphasis"><em>Working with Python on Intel Galileo Gen 2</em></span>, we installed the latest available version of the <code class="literal">upm</code> library. This library provides high level interfaces for sensors and actuators. Whenever <a id="id319" class="indexterm"/>we work with a sensor, it is usually convenient to check whether the <code class="literal">upm</code> library includes support for it because the high level interface can save us a lot of time and make it easier for us to start retrieving the values from the sensor and perform the necessary conversions to the different measuring units.</p><p>In this chapter, we will take advantage of the <code class="literal">upm</code> library with many different sensors. However, we must take into account that sometimes the features included in the <code class="literal">upm</code> library for a specific sensor might not be enough and we might need to write our own low level code to interact with the sensor with either the <code class="literal">mraa</code> or the <code class="literal">wiring-x86</code> library. As we will analyze later, depending on the connection type, only the <code class="literal">mraa</code> will provide us with all the necessary features when the sensor is not supported in the <code class="literal">upm</code> library.</p><p>Obviously, the first thing that we must consider when selecting a sensor is what we want to measure, for example, temperature. However, that is not the only thing we have to consider to select a specific sensor. When we select sensors, we must take into account their features, their measurement range, their precision and their connection types, among other things. The following <a id="id320" class="indexterm"/>list enumerates the most important things we must consider and their explanation:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Compatibility with Intel Galileo Gen 2 board and the voltage supply that we are using (5V or 3.3V)</strong></span>: Sometimes, we have to wire more than one sensor to the board, and therefore, it is important to check whether all the sensors we are selecting can work with the voltage configuration we have for the board. Some sensors are only capable to work with the board if we have a specific setting.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Power consumption</strong></span>: We must take into account that some sensors have different working modes. For example, some sensors have a high performance mode that requires more power than a normal mode. As we might work with more than one sensor wired to the board, it is also important to consider the overall power consumption with all the sensors connected to the board and in the modes in which we will use them. In addition, some sensors switch to power saving modes when we don't use them.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Connection type</strong></span>: We <a id="id321" class="indexterm"/>need to answer a few questions in order to decide the most convenient connection type. Do we have the necessary connections, communications or interface ports? Are they available? Do the connection type and the distance we need have any impact on the accuracy for the measured values? In addition, when we select the first sensor for our board, all the connections might be available, but the situation changes as we add more sensors and it can force the decision to select a sensor with a different connection type. Let's consider the following situation, we are already measuring ambient light in 6 different positions. We have 6 photoresistors connected with 6 voltage divider configurations and wired to the 6 available analog input pins, and therefore, we don't have additional analog pins available. If we have to add a temperature sensor, we cannot add an analog sensor that requires an analog input pin because all of them are wired to the light sensors. In this case, we have to use a digital temperature sensor that we can wire to either the I<sup>2</sup>C or the SPI buses. Another option is to use a digital temperature sensor that we can wire to the UART port. We will dive deep on the different connection types for the sensors later.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Measurement ranges</strong></span>: The specifications for the sensors indicate their measurement ranges. For example, a temperature sensor measuring ambient temperature can have a measurement range of -40ºF to 185ºF (equivalent to -40ºC to 85ºC). In case we need to measure ambient temperatures that can reach 90ºC, we have to select a temperature sensor with a higher upper range. For example, another sensor that measuring ambient temperature provides a measurement range of -40ºF to 257ºF (equivalent to -40ºC to 125ºC) will be suitable for this job.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Sensitivity and precision</strong></span>: Each sensor is sensitive and might offer different configurable precision levels. We have to make sure the accuracy provided by the sensor is compatible with our needs. As the measured value changes, it is important to consider the sensitivity, also known as measurement resolution. For example, if we have to measure temperature and we must be able to determine changes of at least 2ºF or 1ºC based on the unit of measure we are using, we have to make sure that the sensor is capable providing the required sensitivity.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip48"/>Tip</h3><p>When we start the process of selecting the appropriate sensor, it is very important to pay attention to the units of measure when we analyze measurement ranges, sensitivity and precision. A typical example is a temperature sensor that can express the values in either degrees Celsius (ºC) or degrees Fahrenheit (ºF).</p></div></div></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Latency</strong></span>: It is <a id="id322" class="indexterm"/>very important to determine how much can we wait for the sensor to gather a new value and whether it is capable of providing us with a real new value in this amount of time. When the measure value changes in the real environment or object that we are measuring, the sensor takes some time to be able to provide us with the new measured value. Sometimes, they are microseconds but in other cases, they can be milliseconds or even seconds. It depends on the sensor and we have to take it into account when selecting the appropriate sensor for our project. For example, we might need a temperature sensor to allow us to measure 2 temperature values per second, and therefore, we must work with a sensor with a latency lower than 500 milliseconds (0.5 seconds) to achieve our goal. Specifically, we can select a temperature sensor with a latency of 200 milliseconds. Unluckily, sometimes we have to dive deep on the datasheets to check the latency value for some sensors and the electronic components that it uses.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Operating range and special environment requirements</strong></span>: It is very important to consider the operating range for the sensor. Sometimes, the sensors have to work in specific environment conditions that might not be suitable for all of the available sensors. The following are some examples of rough environment requirements: high shock survivability, water resistance, extremely high temperatures, and very high humidity levels.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Dimensions</strong></span>: Sensors come with different dimensions. Sometimes only specific dimensions are suitable for our project.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Protocol, support in the upm library and Python bindings</strong></span>: We will end up processing the data retrieved from the sensor with Python code, and therefore, it is very important to make sure that we can work with the sensor in Python. In some cases, we don't want to write low-level code and we want to make sure that the sensor is supported in the <code class="literal">upm</code> library. In other cases, we have to make sure that we have the necessary Python libraries to work with the protocols that some digital sensors use. For example, many temperature sensors that work with the UART port use the MODBUS serial communications protocol. If they aren't supported in the <code class="literal">upm</code> library, we have to work with specific Python libraries to establish communications using the MODBUS <a id="id323" class="indexterm"/>serial communications protocol and it might require additional work on our side in case we don't have previous experience with this protocol.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Cost</strong></span>: Obviously, we have to take into account the sensor's cost. Perhaps the best sensor that complies with all our requirements is extremely expensive and we might decide to use another sensor with less features or less precision but with a lower cost. We have a huge number of cheap sensors with impressive features that are compatible with the Intel Galileo Gen 2 board. However, we always have to take into account how much each sensor costs to select it according to our needs and our budget.</li></ul></div><p>The sensors or modules that include sensors that we can wire to an Intel Galileo Gen 2 board can use the following connection types. The list enumerates the acronym that manufacturers usually<a id="id324" class="indexterm"/> use to describe the connection type for the modules and their explanation:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>AIO</strong></span>: The module requires one or more analog input pins. The sensors that require analog input pins are known as analog sensors.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>GPIO</strong></span>: The module requires one or more GPIO pins.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>I<sup>2</sup>C</strong></span>: The module requires two wires to connect to the two I<sup>2</sup>C bus lines: <span class="strong"><strong>SCL</strong></span> (short for <span class="strong"><strong>S</strong></span>erial <span class="strong"><strong>CL</strong></span>ock) and <span class="strong"><strong>SDA</strong></span> (short for <span class="strong"><strong>S</strong></span>erial <span class="strong"><strong>DA</strong></span>ta). We can connect many devices to this bus as long as each of them have a different I<sup>2</sup>C address.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>SPI</strong></span>: The module requires three wires to connect to the three SPI bus lines: <span class="strong"><strong>MISO</strong></span> (short for <span class="strong"><strong>Master In Slave Out</strong></span>), <span class="strong"><strong>MOSI</strong></span> (short for <span class="strong"><strong>Master Out Slave In</strong></span>) and <span class="strong"><strong>SCK</strong></span> (short for <span class="strong"><strong>Serial Clock</strong></span>).</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>UART</strong></span>: The module works with a serial connection (RX/TX), and therefore, requires two wires to connect to the two pins for the UART port: <span class="strong"><strong>TX-&gt;1</strong></span> and <span class="strong"><strong>RX&lt;-0</strong></span>. An <span class="strong"><strong>UART</strong></span> port stands for <span class="strong"><strong>Universal Asynchronous Receiver/Transmitter</strong></span>.</li></ul></div><p>The modules that work with the I<sup>2</sup>C bus, the SPI bus or an UART port are known as <span class="strong"><strong>digital sensors</strong></span> because they use a digital interface. Some modules combine one of the buses or an UART port with GPIO pins.</p><p>We already worked with analog inputs and the analog to digital converter with both the <code class="literal">mraa</code> and <code class="literal">wiring-x86</code> libraries. We also worked with GPIO pins configured as input pins with these libraries. However, we still didn't work with the I<sup>2</sup>C bus, the SPI bus or the UART ports.</p><p>The<a id="id325" class="indexterm"/> <code class="literal">mraa</code> library provides the following classes that allow us to work with the previously mentioned serial buses and the UART ports:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">mraa.I2c</code>: The<a id="id326" class="indexterm"/> class represents an I<sup>2</sup>C bus master device (the board) that can talk to multiple I<sup>2</sup>C bus slave devices by selecting their address. It is possible to create many instances of this class to interact with many slave devices. The class allows us to write data to and read data from slave devices connected to the I<sup>2</sup>C bus.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Mraa.Spi</code>: The<a id="id327" class="indexterm"/> class represents an SPI bus and its chip select. The class allows us to write data to and read data from devices connected to the SPI bus.</li><li class="listitem" style="list-style-type: disc"><code class="literal">mraa.UART</code>: The<a id="id328" class="indexterm"/> class represents an UART port and allow us to configure, send data to and receive data from an UART port.</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip49"/>Tip</h3><p>We can use the previously explained classes provided by the <code class="literal">mraa</code> library to interact with any of the digital modules. However, this would require us to spend some time reading the datasheets for the modules, understanding their working modes, writing code that writes data to and reads data from the appropriate bus or UART port. Each module has its own API and we have to compose requests and process responses through the serial buses or the UART port.</p></div></div><p>First, we will take advantage of the <code class="literal">upm</code> library for each of the modules. In a few cases, we will also use the appropriate classes in the <code class="literal">mraa</code> library to understand how to interact with the sensors with a lower level interface. This way, in case we have to work with a module that isn't supported in the <code class="literal">upm</code> library, we can analyze the information provided in the datasheets and write code to interact with the module.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Working with accelerometers"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec63"/>Working with accelerometers</h1></div></div></div><p>An <a id="id329" class="indexterm"/>accelerometer allows us to measure the magnitude and direction of proper acceleration or g-force. Tablets and smartphones use accelerometers to automatically switch between portrait and landscape modes depending on the direction in which we hold the device. In addition, the built-in accelerometer allows us to control apps by making small movements of different intensity with the device in the different directions.</p><p>An accelerometer <a id="id330" class="indexterm"/>allows us to detect how an object is oriented with respect to the Earth's surface by measuring acceleration due to gravity. In addition, an accelerometer is extremely useful when we want to detect when an object starts or stops moving. Accelerometers are also capable of detecting vibration and when an object is falling down.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip50"/>Tip</h3><p>Accelerometers usually measure proper acceleration in g-force, abbreviated with a <code class="literal">g</code>. It is important to avoid the confusion generated by the force word included in the name of the unit of measure because we are measuring proper acceleration and not a force. Some accelerometers use meters per second squared (m/s2) as their unit of measure instead of g-force.</p></div></div><p>Nowadays, most accelerometers are capable of measuring acceleration in three axes and are known as 3-axis accelerometers or triple axis accelerometers. A 3-axis accelerometer can measure acceleration for the <span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span> and <span class="emphasis"><em>z</em></span> axis. If we want to measure small accelerations or vibrations, it will be more convenient to work with a small range 3-axis accelerometer because they provide the necessary sensitivity.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Wiring an analog accelerometer to the analog input pins"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec64"/>Wiring an analog accelerometer to the analog input pins</h1></div></div></div><p>The <a id="id331" class="indexterm"/>easiest way to understand how an accelerometer works is to use it in a simple example. Now, we will work with an analog 3-axis accelerometer with a full sensing range from -3g to +3g. This kind of accelerometer requires three analog input pins, one for each measured axes. The accelerometer supplies voltage levels based on the measured acceleration for each axes.</p><p>We will use the three analog pins labeled <span class="strong"><strong>A0</strong></span>, <span class="strong"><strong>A1</strong></span> and <span class="strong"><strong>A2</strong></span> to connect the positive voltage outputs of an analog accelerometer breakout board. After we finish the necessary wirings, we will write Python code to measure and display the acceleration for the three axis: x, y and z. This way, we will read the result of converting an analog value to its digital representation and we will map it to the acceleration value.</p><p>We need a SparkFun triple axis accelerometer breakout ADXL335 to work with this example. The following URL provides detailed information about this breakout board: <a class="ulink" href="https://www.sparkfun.com/products/9269">https://www.sparkfun.com/products/9269</a>. The breakout board incorporates the ADXL335 accelerometer sensor from Analog Devices.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip51"/>Tip</h3><p>The power supplied to the breakout board should be between 1.8VDC and 3.6VDC, and therefore, we will use the power pin labeled <span class="strong"><strong>3V3</strong></span> as the power supply to make sure we supply 3.3V and we never supply <span class="strong"><strong>5V</strong></span> to the breakout board.</p></div></div><p>It is also <a id="id332" class="indexterm"/>possible to use a Seeedstudio Grove 3-axis analog accelerometer to work with this example. The following URL provides detailed information about this module: <a class="ulink" href="http://www.seeedstudio.com/depot/Grove-3Axis-Analog-Accelerometer-p-1086.html">http://www.seeedstudio.com/depot/Grove-3Axis-Analog-Accelerometer-p-1086.html</a>. If you use this module, you can use either the power pin labeled <span class="strong"><strong>3V3</strong></span> or <span class="strong"><strong>5V</strong></span> as the power supply because the breakout board is capable of working with voltage supplies from 3V to 5V. The full sensing range is the same than the SparkFun breakout board and both use the same accelerometer sensor. The wirings are compatible for both modules.</p><p>The following diagram shows a SparkFun triple axis accelerometer breakout ADXL335, the necessary wirings and the wirings from the Intel Galileo Gen 2 board to the breadboard. The Fritzing file for the sample is <code class="literal">iot_fritzing_chapter_07_01.fzz</code> and the following picture is the breadboard view:</p><div class="mediaobject"><img src="images/B05042_07_01.jpg" alt="Wiring an analog accelerometer to the analog input pins"/></div><p>The following <a id="id333" class="indexterm"/>picture shows the schematic with the electronic components represented as symbols:</p><div class="mediaobject"><img src="images/B05042_07_02.jpg" alt="Wiring an analog accelerometer to the analog input pins"/></div><p>As seen in<a id="id334" class="indexterm"/> the previous schematic, we have the following connections:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The analog input pin labeled <span class="strong"><strong>A0</strong></span> is connected to the accelerometer output pin labeled <span class="strong"><strong>X</strong></span> (<span class="strong"><strong>XOUT</strong></span> in the breakout board's symbol)</li><li class="listitem" style="list-style-type: disc">The analog input pin labeled <span class="strong"><strong>A1</strong></span> is connected to the accelerometer output pin labeled <span class="strong"><strong>Y</strong></span> (<span class="strong"><strong>YOUT</strong></span> in the breakout board's symbol)</li><li class="listitem" style="list-style-type: disc">The analog input pin labeled <span class="strong"><strong>A2</strong></span> is connected to the accelerometer output pin labeled <span class="strong"><strong>Z</strong></span> (<span class="strong"><strong>ZOUT</strong></span> in the breakout board's symbol)</li><li class="listitem" style="list-style-type: disc">The power pin labeled <span class="strong"><strong>3V3</strong></span> is connected to the accelerometer power pin labeled <span class="strong"><strong>VCC</strong></span></li><li class="listitem" style="list-style-type: disc">The ground pin labeled <span class="strong"><strong>GND</strong></span> is connected to the accelerometer ground pin labeled <span class="strong"><strong>GND</strong></span></li></ul></div><p>Now, it is<a id="id335" class="indexterm"/> time make all the necessary wirings. Don't forget to shutdown the Yocto Linux, wait for all the onboard LEDs to turn off, and unplug the power supply from the Intel Galileo Gen 2 board before adding or removing any wire from the board's pins. Make sure you use large wires to allow you to move the accelerometer breakout board in different directions without accidentally unplugging cables.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Measuring three axis acceleration with an analog accelerometer"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec65"/>Measuring three axis acceleration with an analog accelerometer</h1></div></div></div><p>The <code class="literal">upm</code> library <a id="id336" class="indexterm"/>includes support for the three axis analog accelerometer breakout board in the <code class="literal">pyupm_adxl335</code> module. The <code class="literal">ADXL335</code> class declared in this module represents a three axis<a id="id337" class="indexterm"/> analog accelerometer connected to our board. The class makes it easy to calibrate the accelerometer and convert the raw values read from the analog inputs into values expressed in the <code class="literal">g</code> unit. </p><p>We will create a new <code class="literal">Accelerometer</code> class to represent the accelerometer and make it easier for us to retrieve the acceleration values without worrying about type conversion that are necessary when working with an instance of the <code class="literal">ADXL335</code> class. We will use the <code class="literal">ADXL335</code> class to interact with the accelerometer. The following lines show the code for the new <code class="literal">Accelerometer</code> class that works with the <code class="literal">upm</code> library, specifically with the <code class="literal">pyupm_adxl335</code> module. The code file for the sample is <code class="literal">iot_python_chapter_07_01.py</code>.</p><div class="informalexample"><pre class="programlisting">import pyupm_adxl335 as upmAdxl335
import time


class Accelerometer:
    def __init__(self, pinX, pinY, pinZ):
        self.accelerometer = upmAdxl335.ADXL335(
            pinX, pinY, pinZ)
        self.accelerometer.calibrate()
        self.x_acceleration_fp = upmAdxl335.new_floatPointer()
        self.y_acceleration_fp = upmAdxl335.new_floatPointer()
        self.z_acceleration_fp = upmAdxl335.new_floatPointer()
        self.x_acceleration = 0.0
        self.y_acceleration = 0.0
        self.z_acceleration = 0.0

    def calibrate(self):
        self.accelerometer.calibrate()

    def measure_acceleration(self):
        # Retrieve the acceleration values for the three axis
        self.accelerometer.acceleration(
            self.x_acceleration_fp,
            self.y_acceleration_fp,
            self.z_acceleration_fp)
        self.x_acceleration = upmAdxl335.floatPointer_value(
            self.x_acceleration_fp)
        self.y_acceleration = upmAdxl335.floatPointer_value(
            self.y_acceleration_fp)
        self.z_acceleration = upmAdxl335.floatPointer_value(
            self.z_acceleration_fp)</pre></div><p>We<a id="id338" class="indexterm"/> have to specify the analog<a id="id339" class="indexterm"/> pin numbers to which each axes pin is connected when we create an instance of the <code class="literal">Accelerometer</code> class in the <code class="literal">pinX</code>, <code class="literal">pinY</code>, and <code class="literal">pinZ</code> required arguments. The constructor, that is, the <code class="literal">__init__</code> method, creates a new <code class="literal">upmAdxl335.ADXL335</code> instance with the received <code class="literal">pinX</code>, <code class="literal">pinY</code>, and <code class="literal">pinZ</code> arguments and saves its reference in the <code class="literal">accelerometer</code> attribute.</p><p>The <code class="literal">upmAdxl335.ADXL335</code> instance requires working with floating point pointers to retrieve the acceleration values for the three axis. Thus, the constructor saves the three objects of type <code class="literal">float *</code> (float pointers) in the following three attributes by calling <code class="literal">upmAdxl335.new_floatPointer()</code>.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">x_acceleration_fp</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">y_acceleration_fp</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">z_acceleration_fp</code></li></ul></div><p>Finally, the constructor creates and initializes three attributes with <code class="literal">0.0</code>: <code class="literal">x_acceleration</code>, <code class="literal">y_acceleration</code> and <code class="literal">z_acceleration</code>. After the constructor is executed, we must calibrate the accelerometer and then, we will be ready to retrieve acceleration values for the three axis: <span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span> and <span class="emphasis"><em>z</em></span>.</p><p>The<a id="id340" class="indexterm"/> class defines the following two methods:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">calibrate</code>: Calls the calibrate method for <code class="literal">self.accelerometer</code> to calibrate the analog accelerometer.</li><li class="listitem" style="list-style-type: disc"><code class="literal">measure_acceleration</code>: Retrieves the acceleration values for the three axis and saves them in the following three attributes: <code class="literal">x_acceleration</code>, <code class="literal">y_acceleration</code> and <code class="literal">z_acceleration</code>. The acceleration values are expressed in g-force (<code class="literal">g</code>). First, the code calls the <code class="literal">acceleration</code> method for <code class="literal">self.accelerometer</code> with the three objects of type <code class="literal">float *</code> as arguments. The method reads the raw values retrieved from the three analog pins, converts them to the appropriate values in g-force (g) and changes the floating point values for the objects of type <code class="literal">float*</code> received as arguments with the updated values. Then, the code calls the <code class="literal">upmAdxl335.floatPointer_value</code> method to retrieve the floating point values from the objects of type <code class="literal">float*</code> and update the three attributes: <code class="literal">x_acceleration</code>, <code class="literal">y_acceleration</code> and <code class="literal">z_acceleration</code>.</li></ul></div><p>Now, we<a id="id341" class="indexterm"/> will write a loop that will run a calibration, retrieve and display the acceleration values for the three axis expressed in g-force (<code class="literal">g</code>) every 500 milliseconds, that is, twice per second. The code file for the sample is <code class="literal">iot_python_chapter_07_01.py</code>.</p><div class="informalexample"><pre class="programlisting">if __name__ == "__main__":
    # The accelerometer is connected to analog pins A0, A1 and A2
    # A0 -&gt; x
    # A1 -&gt; y
    # A2 -&gt; z
    accelerometer = Accelerometer(0, 1, 2)
    # Calibrate the accelerometer
    accelerometer.calibrate()

    while True:
        accelerometer.measure_acceleration()
        print("Acceleration for x: {0}g".format(accelerometer.x_acceleration))
        print("Acceleration for y: {0}g".format(accelerometer.y_acceleration))
        print("Acceleration for z: {0}g".format(accelerometer.z_acceleration))
        # Sleep 0.5 seconds (500 milliseconds)
        time.sleep(0.5)</pre></div><p>The<a id="id342" class="indexterm"/> first line creates an instance of the previously coded <code class="literal">Accelerometer</code> class with <code class="literal">0</code>, <code class="literal">1</code> and <code class="literal">2</code> as the values of the <code class="literal">pinX</code>, <code class="literal">pinY</code> and <code class="literal">pinZ</code> arguments. This way, the instance will read the analog values from the pins labeled <span class="strong"><strong>A0</strong></span>, <span class="strong"><strong>A1</strong></span> and <span class="strong"><strong>A2</strong></span>. Then, the code calls the <code class="literal">calibrate</code> method for the <code class="literal">Accelerometer</code> instance to calibrate the analog accelerometer.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip52"/>Tip</h3><p>The calibration measures the <span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span> and <span class="emphasis"><em>z</em></span> axis values while the sensor is still, and then, the sensor uses these values as the zero values, that is, as a baseline. The default sensitivity for this analog sensor is 0.25V/g.</p></div></div><p>Then, the <a id="id343" class="indexterm"/>code runs a loop forever, that is, until you interrupt the execution by pressing <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>C</em></span> or the button to stop the process, in case you are using a Python IDE with remote development features to run the code in your board. The loop calls the <code class="literal">measure_acceleration</code> method to update the acceleration values and then prints them, expressed in g-force (g).</p><p>The following line will start the example. Don't forget that you need to transfer the Python source code file to the Yocto Linux with an SFTP client. Before you start the example, make sure that the accelerometer breakout board is located on stable surface that doesn't vibrate. This way, the calibration will work OK.</p><div class="informalexample"><pre class="programlisting">python iot_python_chapter_07_01.py</pre></div><p>After you run the example, perform the following actions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Make small movements to the accelerometer breakout board in different directions</li><li class="listitem" style="list-style-type: disc">Make large movements to the accelerometer breakout board in specific directions</li><li class="listitem" style="list-style-type: disc">Leave the accelerometer breakout board on a stable surface that doesn't vibrate</li></ul></div><p>As a result of the previous actions, you will see the different acceleration values measured for the three axis. The following lines show some sample output lines generated when we make large movements with the breakout board:</p><div class="informalexample"><pre class="programlisting">Acceleration for x: 0.0g
Acceleration for y: 0.4296875g
Acceleration for z: 0.0g
Acceleration for x: 0.0g
Acceleration for y: 0.52734375g
Acceleration for z: 0.0g
Acceleration for x: 0.0g
Acceleration for y: 0.60546875g
Acceleration for z: 0.0g
Acceleration for x: 0.01953125g
Acceleration for y: 0.68359375g
Acceleration for z: 0.0g</pre></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Wiring a digital accelerometer to the I2C bus"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec66"/>Wiring a digital accelerometer to the I<sup>2</sup>C bus</h1></div></div></div><p>Digital accelerometers <a id="id344" class="indexterm"/>usually provide a better precision, higher resolution and more sensitivity than analog accelerometers. Now, we will work with a digital 3-axis accelerometer with a full sensing range from -16g to +16g. We will use a breakout board that uses the I<sup>2</sup>C bus to allow the board to communicate with the accelerometer.</p><p>We will use the two pins labeled <span class="strong"><strong>SDA</strong></span> and <span class="strong"><strong>SCL</strong></span> to connect the data and clock lines of the I<sup>2</sup>C bus to the corresponding pins in the digital accelerometer breakout board. After we finish the necessary wirings, we will write Python code to measure and display the acceleration for the three axis: <span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span> and <span class="emphasis"><em>z</em></span>. This way, we will read the result of sending commands to the accelerometer through the I<sup>2</sup>C bus, reading the responses and decoding them into the appropriate acceleration values expressed in g-force (<code class="literal">g</code>).</p><p>We need a SparkFun triple axis accelerometer breakout ADXL345 to work with this example. The following URL provides detailed information about this breakout board: <a class="ulink" href="https://www.sparkfun.com/products/9836">https://www.sparkfun.com/products/9836</a>. The breakout board incorporates the ADXL345 digital accelerometer sensor from Analog Devices and provides support for both the SPI and I<sup>2</sup>C buses. In this case, we will only use the I<sup>2</sup>C bus.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip53"/>Tip</h3><p>The power supplied to the breakout board should be between 2.0VDC and 3.6VDC, and therefore, we must use the power pin labeled <span class="strong"><strong>3V3</strong></span> as the power supply to make sure we supply 3.3V and we never supply <span class="strong"><strong>5V</strong></span> to the breakout board.</p></div></div><p>It is also possible to use a Seeedstudio Grove 3-axis digital accelerometer to work with this example. The following URL provides detailed information about this module: <a class="ulink" href="http://www.seeedstudio.com/depot/Grove-3Axis-Digital-Accelerometer16g-p-1156.html">http://www.seeedstudio.com/depot/Grove-3Axis-Digital-Accelerometer16g-p-1156.html</a>. If you use this module, you can use either the power pin labeled <span class="strong"><strong>3V3</strong></span> or <span class="strong"><strong>5V</strong></span> as the power supply because the breakout board is capable of working with voltage supplies from 3V to 5V. The full sensing range is the same than the SparkFun breakout board and both use the same accelerometer sensor. The wirings are compatible for both modules.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip54"/>Tip</h3><p>The Seeedstudio Grove 3-axis digital accelerometer is prepared to use cables to plug it into a Grove base shield. The Grove base shield is a board that you can plug in your Intel Galileo Gen 2 board and provides digital, analog and I<sup>2</sup>C ports that you can use with the appropriate cables to easily wire Grove sensors to the underlying Intel Galileo Gen 2 board. In our examples, we won't be using the Grove base shield and we will continue to use wirings to connect each different sensor. However, you will achieve the same results if you decide to use the Grove base shield in combination with Grove sensors. Other Grove sensors that we will use in the next examples will also be prepared to work with the Grove base shield. The latest version of the Grove base shield is V2 and you can gather more information about it in the following URL: <a class="ulink" href="http://www.seeedstudio.com/depot/Base-Shield-V2-p-1378.html">http://www.seeedstudio.com/depot/Base-Shield-V2-p-1378.html</a>
</p></div></div><p>The following <a id="id345" class="indexterm"/>diagram shows a Seeedstudio Grove 3-axis digital accelerometer breakout ADXL345, the necessary wirings and the wirings from the Intel Galileo Gen 2 board to the breadboard. The Fritzing file for the sample is <code class="literal">iot_fritzing_chapter_07_02.fzz</code> and the following picture is the breadboard view.</p><div class="mediaobject"><img src="images/B05042_07_03.jpg" alt="Wiring a digital accelerometer to the I2C bus"/></div><p>The following<a id="id346" class="indexterm"/> picture shows the schematic with the electronic components represented as symbols.</p><div class="mediaobject"><img src="images/B05042_07_04.jpg" alt="Wiring a digital accelerometer to the I2C bus"/></div><p>As seen in the <a id="id347" class="indexterm"/>previous schematic, we have the following connections:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="strong"><strong>SDA</strong></span> pin is connected to the accelerometer pin labeled <span class="strong"><strong>SDA</strong></span>. This way, we connect the digital accelerometer to the serial data line for the I<sup>2</sup>C bus. The <span class="strong"><strong>SDA</strong></span> pin in the Intel Galileo Gen 2 board is connected to the analog input pin labeled <span class="strong"><strong>A4</strong></span>, and therefore, the board's symbol uses the <span class="strong"><strong>A4/SDA</strong></span> label. The pin labeled <span class="strong"><strong>SDA</strong></span> is in a different location than the pin labeled <span class="strong"><strong>A4</strong></span>, but they are internally connected.</li><li class="listitem" style="list-style-type: disc">The <span class="strong"><strong>SCL</strong></span> pin is connected to the accelerometer pin labeled <span class="strong"><strong>SCL</strong></span>. This way, we connect the digital accelerometer to the serial clock line for the I<sup>2</sup>C bus. The <span class="strong"><strong>SCL</strong></span> pin in the Intel Galileo Gen 2 board is connected to the analog input pin labeled <span class="strong"><strong>A5</strong></span>, and therefore, the board's symbol uses the <span class="strong"><strong>A5/SCL</strong></span> label. The pin labeled <span class="strong"><strong>SCL</strong></span> is in a different location than the pin labeled <span class="strong"><strong>A5</strong></span>, but they are internally connected.</li><li class="listitem" style="list-style-type: disc">The power pin labeled <span class="strong"><strong>5V</strong></span> is connected to the accelerometer power pin labeled <span class="strong"><strong>VCC</strong></span>. In case you work with the SparkFun triple axis accelerometer breakout ADXL345, the power pin labeled <span class="strong"><strong>3V3</strong></span> is connected to the accelerometer power pin labeled <span class="strong"><strong>VCC</strong></span>.</li><li class="listitem" style="list-style-type: disc">The ground pin labeled <span class="strong"><strong>GND</strong></span> is connected to the accelerometer ground pin labeled <span class="strong"><strong>GND</strong></span>.</li></ul></div><p>Now, it is<a id="id348" class="indexterm"/> time make all the necessary wirings. Don't forget to shutdown the Yocto Linux, wait for all the onboard LEDs to turn off, and unplug the power supply from the Intel Galileo Gen 2 board before adding or removing any wire from the board's pins. As you did with the analog accelerometer, make sure you use large wires to allow you to move the accelerometer breakout board in different directions without accidentally unplugging cables.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Measuring three axis acceleration with a digital accelerometer"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec67"/>Measuring three axis acceleration with a digital accelerometer</h1></div></div></div><p>The<a id="id349" class="indexterm"/> <code class="literal">upm</code> library<a id="id350" class="indexterm"/> includes support for the three axis digital accelerometer breakout board ADXL345 in the <code class="literal">pyupm_adxl345</code> module. The <code class="literal">Adxl345</code> class declared in this module represents a three axis digital accelerometer based on the ADXL345 sensor, connected to our board. The class makes it easy to initialize the sensor, update and retrieve the acceleration values for the three axis through the I<sup>2</sup>C bus. The class works with the <code class="literal">mraa.I<sup>2</sup>C</code> class under the hoods to talk with the sensor, that is, to write data to and read data from the ADXL345 sensor that acts as a slave device connected to the I<sup>2</sup>C bus.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip55"/>Tip</h3><p>Unluckily, each module in the <code class="literal">upm</code> library doesn't follow the same naming conventions we should expect for Python code. For example, in our previous example, that class name was <code class="literal">ADXL335</code>, with capital letters, while in this example the class name is <code class="literal">Adxl345</code>.</p></div></div><p>We will create a new version of the <code class="literal">Accelerometer</code> class to represent the accelerometer and make it easier for us to retrieve the acceleration values without worrying about specific methods <a id="id351" class="indexterm"/>and arrays when working with an instance of the <code class="literal">Adxl345</code> class. We will use the <code class="literal">Adxl345</code> class to interact with the accelerometer. The following lines show the code for<a id="id352" class="indexterm"/> the new <code class="literal">Accelerometer</code> class that works with the <code class="literal">upm</code> library, specifically with the <code class="literal">pyupm_adxl345</code> module. The code file for the sample is <code class="literal">iot_python_chapter_07_02.py</code>.</p><div class="informalexample"><pre class="programlisting">import pyupm_adxl345 as upmAdxl345
import time


class Accelerometer:
    def __init__(self, bus):
        self.accelerometer = upmAdxl345.Adxl345(bus)
        self.x_acceleration = 0.0
        self.y_acceleration = 0.0
        self.z_acceleration = 0.0

    def measure_acceleration(self):
        # Update the acceleration values for the three axis
        self.accelerometer.update()
        # Retrieve the acceleration values for the three axis
        acceleration_array = \
            self.accelerometer.getAcceleration()
        self.x_acceleration = acceleration_array[0]
        self.y_acceleration = acceleration_array[1]
        self.z_acceleration = acceleration_array[2]</pre></div><p>We have to specify the I<sup>2</sup>C bus number to which the digital accelerometer is wired when we create an instance of the <code class="literal">Accelerometer</code> class in the <code class="literal">bus</code> required argument. The constructor, that is, the <code class="literal">__init__</code> method, creates a new <code class="literal">upmAdxl345.Adxl345</code> instance with the received <code class="literal">bus</code> argument and saves its reference in the <code class="literal">accelerometer</code> attribute.</p><p>The <code class="literal">upmAdxl345.Adxl345</code> instance requires working with an array of floating point pointers to retrieve the acceleration values for the three axis. We want to work with easy to understand attributes, and therefore, the constructor creates and initializes three attributes with <code class="literal">0.0</code>: <code class="literal">x_acceleration</code>, <code class="literal">y_acceleration</code>, and <code class="literal">z_acceleration</code>. After the constructor is executed, we have an initialized digital accelerometer ready to retrieve acceleration values for the three axis: <span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span> and <span class="emphasis"><em>z</em></span>.</p><p>The class defines a <code class="literal">measure_acceleration</code> method that updates the acceleration values for the three axes in the sensor, retrieves these acceleration values from the sensor, and finally saves them in the following three attributes: <code class="literal">x_acceleration</code>, <code class="literal">y_acceleration</code> and <code class="literal">z_acceleration</code>. The acceleration values are expressed in g-force (<code class="literal">g</code>).</p><p>First, the <a id="id353" class="indexterm"/>code within the <code class="literal">measure_acceleration</code> method calls the <code class="literal">update</code> method for <code class="literal">self.accelerometer</code> to request the sensor to update the read values. Then, the code calls the <code class="literal">getAcceleration</code> method for <code class="literal">self.accelerometer</code> to retrieve the acceleration values <a id="id354" class="indexterm"/>for the three axis and saves the returned array in the <code class="literal">acceleration_array</code> local variable. The first element in the array has the acceleration value for x, the second for y and the third for z. Thus, the code updates the following three attributes with the values in the <code class="literal">acceleration_array</code> array: <code class="literal">x_acceleration</code>, <code class="literal">y_acceleration</code>, and <code class="literal">z_acceleration</code>. This way, we can easily access each acceleration value by accessing the appropriate attribute instead of working with elements of an array that might lead to confusion.</p><p>Now, we will write a loop that will run a calibration, retrieve and display the acceleration values for the three axis expressed in g-force (<code class="literal">g</code>) every 500 milliseconds, that is, twice per second. The code file for the sample is <code class="literal">iot_python_chapter_07_02.py</code>.</p><div class="informalexample"><pre class="programlisting">if __name__ == "__main__":
    accelerometer = Accelerometer(0)
    while True:
        accelerometer.measure_acceleration()
        print("Acceleration for x: {:5.2f}g".
              format(accelerometer.x_acceleration))
        print("Acceleration for y: {:5.2f}g".
              format(accelerometer.y_acceleration))
        print("Acceleration for z: {:5.2f}g".
              format(accelerometer.z_acceleration))
        # Sleep 0.5 seconds (500 milliseconds)
        time.sleep(0.5)</pre></div><p>The first line creates an instance of the previously coded <code class="literal">Accelerometer</code> class with <code class="literal">0</code> as the values of the <code class="literal">bus</code> argument. The <code class="literal">mraa.I2c</code> class identifies the I<sup>2</sup>C bus to which we wired the accelerometer with number <code class="literal">0</code>. This way, the instance will establish a communication with the digital accelerometer through the I<sup>2</sup>C bus. The Intel Galileo Gen 2 board is the master in the bus and the digital accelerometer, as any other device connected to this bus, acts as a slave.</p><p>Then, the code runs a loop forever that calls <code class="literal">measure_acceleration</code> method to update the acceleration values and then prints them, expressed in g-force (g).</p><p>The following line will start the example:</p><div class="informalexample"><pre class="programlisting">python iot_python_chapter_07_02.py</pre></div><p>After <a id="id355" class="indexterm"/>you run the example, perform<a id="id356" class="indexterm"/> the same actions done with the previous example. As a result of these actions, you will see the different acceleration values measured for the three axis. The following lines show some sample output lines generated when we make small movements with the breakout board:</p><div class="informalexample"><pre class="programlisting">Acceleration for x: 0.000g
Acceleration for y: 0.056g
Acceleration for z: 0.000g
Acceleration for x: 0.000g
Acceleration for y: 0.088g
Acceleration for z: 0.000g
Acceleration for x: 0.000g
Acceleration for y: 0.872g
Acceleration for z: 0.056g</pre></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Using the I2C bus to control a digital accelerometer with the mraa library"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec68"/>Using the I<sup>2</sup>C bus to control a digital accelerometer with the mraa library</h1></div></div></div><p>Sometimes, the <a id="id357" class="indexterm"/>features included in the <code class="literal">upm</code> library for a specific sensor do not include all of its possible usages and <a id="id358" class="indexterm"/>configurations. An example of this situation is the <code class="literal">upmAdxl345.Adxl345</code> class that we used in our previous example. This class doesn't allow us to configure the desired scale for the accelerometer while the sensor supports the following four selectable measurement ranges: ±2g, ±4g, ±8g and ±16g. If we want to use specific features that aren't included in the <code class="literal">upm</code> module, we can use the appropriate <code class="literal">mraa</code> class to interact with the sensor, in this case, we can use <code class="literal">mraa.I2c</code> to control the digital accelerometer through the I<sup>2</sup>C bus.</p><p>We will use the C++ source code for the upm module as a baseline to write our own Python code that controls the accelerometer through the I<sup>2</sup>C bus using the <code class="literal">mraa.I2c</code> class. The C++ source code<a id="id359" class="indexterm"/> file is <code class="literal">adxl1345.cxx</code> and it can be found in the following GitHub URL: <a class="ulink" href="http://github.com/intel-iot-devkit/upm/blob/master/src/adxl345/adxl345.cxx">http://github.com/intel-iot-devkit/upm/blob/master/src/adxl345/adxl345.cxx</a>. As we use the C++ source code as a baseline, we will use the same naming convention (capital letters) for the constants declared with <code class="literal">#define</code>, but we will convert them into class attributes.</p><p>The following <a id="id360" class="indexterm"/>lines show the code for the new <code class="literal">Adxl1345</code> class that works with an instance of the <code class="literal">mraa.I2c</code> class to communicate with the digital accelerometer. The code file for the <a id="id361" class="indexterm"/>sample is <code class="literal">iot_python_chapter_07_03.py</code>.</p><div class="informalexample"><pre class="programlisting">class Adxl345:
    # Read buffer length
    READ_BUFFER_LENGTH = 6
    # I2C address for the ADXL345 accelerometer
    ADXL345_I2C_ADDR = 0x53
    ADXL345_ID = 0x00
    # Control registers
    ADXL345_OFSX = 0x1E
    ADXL345_OFSY = 0x1F
    ADXL345_OFSZ = 0x20
    ADXL345_TAP_THRESH = 0x1D
    ADXL345_TAP_DUR = 0x21
    ADXL345_TAP_LATENCY = 0x22
    ADXL345_ACT_THRESH = 0x24
    ADXL345_INACT_THRESH = 0x25
    ADXL345_INACT_TIME = 0x26
    ADXL345_INACT_ACT_CTL = 0x27
    ADXL345_FALL_THRESH = 0x28
    ADXL345_FALL_TIME = 0x29
    ADXL345_TAP_AXES = 0x2A
    ADXL345_ACT_TAP_STATUS = 0x2B
    # Interrupt registers
    ADXL345_INT_ENABLE = 0x2E
    ADXL345_INT_MAP = 0x2F
    ADXL345_INT_SOURCE = 0x30
    # Data registers (read only)
    ADXL345_XOUT_L = 0x32
    ADXL345_XOUT_H = 0x33
    ADXL345_YOUT_L = 0x34
    ADXL345_YOUT_H = 0x35
    ADXL345_ZOUT_L = 0x36
    ADXL345_ZOUT_H = 0x37
    DATA_REG_SIZE = 6
    # Data and power management
    ADXL345_BW_RATE = 0x2C
    ADXL345_POWER_CTL = 0x2D
    ADXL345_DATA_FORMAT = 0x31
    ADXL345_FIFO_CTL = 0x38
    ADXL345_FIFO_STATUS = 0x39
    # Useful values
    ADXL345_POWER_ON = 0x08
    ADXL345_AUTO_SLP = 0x30
    ADXL345_STANDBY = 0x00
    # Scales and resolution
    ADXL345_FULL_RES = 0x08
    ADXL345_10BIT = 0x00
    ADXL345_2G = 0x00
    ADXL345_4G = 0x01
    ADXL345_8G = 0x02
    ADXL345_16G = 0x03

    def __init__(self, bus):
        # Init bus and reset chip
        self.i2c = mraa.I2c(bus)
        # Set the slave to talk to
        if self.i2c.address(self.__class__.ADXL345_I2C_ADDR) != mraa.SUCCESS:
            raise Exception("i2c.address() failed")
        message = bytearray(
            [self.__class__.ADXL345_POWER_CTL,
             self.__class__.ADXL345_POWER_ON])
        if self.i2c.write(message) != mraa.SUCCESS:
            raise Exception("i2c.write() control register failed")
        if self.i2c.address(self.__class__.ADXL345_I2C_ADDR) != mraa.SUCCESS:
            raise Exception("i2c.address() failed")
        message = bytearray(
            [self.__class__.ADXL345_DATA_FORMAT,
             self.__class__.ADXL345_16G | self.__class__.ADXL345_FULL_RES])
        if self.i2c.write(message) != mraa.SUCCESS:
            raise Exception("i2c.write() mode register failed")
        # 2.5V sensitivity is 256 LSB/g = 0.00390625 g/bit
        # 3.3V x and y sensitivity is 265 LSB/g = 0.003773584 g/bit, z is the same
        self.x_offset = 0.003773584
        self.y_offset = 0.003773584
        self.z_offset = 0.00390625
        self.x_acceleration = 0.0
        self.y_acceleration = 0.0
        self.z_acceleration = 0.0
        self.update()

    def update(self):
        # Set the slave to talk to
        self.i2c.address(self.__class__.ADXL345_I2C_ADDR)
        self.i2c.writeByte(self.__class__.ADXL345_XOUT_L)
        self.i2c.address(self.__class__.ADXL345_I2C_ADDR)
        xyz_raw_acceleration = self.i2c.read(self.__class__.DATA_REG_SIZE)
        x_raw_acceleration = (xyz_raw_acceleration[1] &lt;&lt; 8) | xyz_raw_acceleration[0]
        y_raw_acceleration = (xyz_raw_acceleration[3] &lt;&lt; 8) | xyz_raw_acceleration[2]
        z_raw_acceleration = (xyz_raw_acceleration[5] &lt;&lt; 8) | xyz_raw_acceleration[4]
        self.x_acceleration = x_raw_acceleration * self.x_offset
        self.y_acceleration = y_raw_acceleration * self.y_offset
        self.z_acceleration = z_raw_acceleration * self.z_offset</pre></div><p>First, the <a id="id362" class="indexterm"/>class declares many constants that make it easier for us to understand the code that interacts with the <a id="id363" class="indexterm"/>accelerometer through the I<sup>2</sup>C bus. For example, the <code class="literal">ADXL345_I2C_ADDR</code> constant specifies the address for the ADXL345 accelerometer in the I<sup>2</sup>C bus, which is 53 in hexadecimal (<code class="literal">0x53</code>). If we just see a <code class="literal">0x53</code> within the code, we don't understand that it is an I<sup>2</sup>C bus address for the sensor. We imported all the constants defined in the C++ version so that we have all the necessary values in case we want to add additional features not included in the initial version. The datasheet provided by the manufacturer provides the necessary details to know the addresses for each register and the way in which the commands work in the I<sup>2</sup>C bus.</p><p>We have to specify the I<sup>2</sup>C bus number to which the digital accelerometer is wired when we create an instance of the <code class="literal">Adxl345</code> class in the <code class="literal">bus</code> required argument. The constructor, that is, the <code class="literal">__init__</code> method, creates a new <code class="literal">mraa.I2c</code> instance with the received <code class="literal">bus</code> argument and saves its reference in the <code class="literal">i2c</code> attribute.</p><div class="informalexample"><pre class="programlisting">self.i2c = mraa.I2c(bus)</pre></div><p>Before <a id="id364" class="indexterm"/>performing any read or write operation in the I<sup>2</sup>C bus, it is a good practice to call the <code class="literal">address</code> method for the <code class="literal">mraa.I2c</code> instance to indicate the slave device to which we want to talk to. In this case, the address for the slave device is specified in the <code class="literal">ADXL345_I2C_ADDR</code> constant.</p><div class="informalexample"><pre class="programlisting">if self.i2c.address(self.__class__.ADXL345_I2C_ADDR) != mraa.SUCCESS:
    raise Exception("i2c.address() failed")</pre></div><p>Then, the<a id="id365" class="indexterm"/> code builds a message by creating a <code class="literal">bytearray</code> with the two hexadecimal values that we want to write to the slave: <code class="literal">ADXL345_POWER_CTL</code> and <code class="literal">ADXL345_POWER_ON</code>. We can read the message as <code class="literal">write turn on to the power control register</code>. The call to the <code class="literal">write</code> method for the <code class="literal">mraa.I2c</code> instance with this message will turn on the accelerometer.</p><div class="informalexample"><pre class="programlisting">message = bytearray(
    [self.__class__.ADXL345_POWER_CTL,
     self.__class__.ADXL345_POWER_ON])
if self.i2c.write(message) != mraa.SUCCESS:
    raise Exception("i2c.write() control register failed")</pre></div><p>We declared the following constants related to resolutions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">ADXL345_FULL_RES</code>: Work with full resolution, where resolution increases with the g range up to 13-bit resolution</li><li class="listitem" style="list-style-type: disc"><code class="literal">ADXL345_10BIT</code>: Work with a fixed 10-bit resolution</li></ul></div><p>We declared the following constants related to scales:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">ADXL345_2G</code>: Sets the g range to ±2g</li><li class="listitem" style="list-style-type: disc"><code class="literal">ADXL345_4G</code>: Sets the g range to ±4g</li><li class="listitem" style="list-style-type: disc"><code class="literal">ADXL345_8G</code>: Sets the g range to ±8g</li><li class="listitem" style="list-style-type: disc"><code class="literal">ADXL345_16G</code>: Sets the g range to ±16g</li></ul></div><p>The code makes another call to the <code class="literal">address</code> method for the <code class="literal">mraa.I2c</code> instance before it makes another write to configure the desired resolution and scale for the sensor. The code builds another message by creating a <code class="literal">bytearray</code> with the two hexadecimal values that we want to write to the slave: <code class="literal">ADXL345_DATA_FORMAT</code> and the result of applying a bitwise or operator (<code class="literal">|</code>) for <code class="literal">ADXL345_16G</code> and <code class="literal">ADXL345_FULL_RES</code>. We can read the message as <code class="literal">write ±16g + full resolution to the data format register</code>. It is necessary to<a id="id366" class="indexterm"/> combine the desired resolution and the range in a single byte value, and therefore, we have to use the bitwise or operator (<code class="literal">|</code>).</p><div class="informalexample"><pre class="programlisting">if self.i2c.address(self.__class__.ADXL345_I2C_ADDR) != mraa.SUCCESS:
    raise Exception("i2c.address() failed")
message = bytearray(
    [self.__class__.ADXL345_DATA_FORMAT,
     self.__class__.ADXL345_16G | self.__class__.ADXL345_FULL_RES])
if self.i2c.write(message) != mraa.SUCCESS:
    raise Exception("i2c.write() mode register failed")</pre></div><p>The <a id="id367" class="indexterm"/>call to the write method for the <code class="literal">mraa.I2c</code> instance with this message will configure the accelerometer to work with a ±16g range for g and with the full resolution. As we have access to this call, we can make changes to the code to change the desired resolution or the scale for our acceleration measures. For example, the following lines that compose the message will change the configuration to make the accelerometer work with a g range of ±4g:</p><div class="informalexample"><pre class="programlisting">message = bytearray(
    [self.__class__.ADXL345_DATA_FORMAT,
     self.__class__.ADXL345_4G | self.__class__.ADXL345_FULL_RES])</pre></div><p>Then, the code declares offset attributes for x, y, and z that is necessary to convert the raw acceleration values retrieved from the accelerometer into the appropriate values expressed in g. We want to work with easy to understand attributes instead, and therefore, the constructor creates and initializes three attributes with <code class="literal">0.0</code>: <code class="literal">x_acceleration</code>, <code class="literal">y_acceleration</code>, and <code class="literal">z_acceleration</code>. Finally, the constructor calls the <code class="literal">update</code> method to retrieve the first values from the accelerometer.</p><p>The <code class="literal">update</code> method makes a call to the <code class="literal">address</code> method for the <code class="literal">mraa.I2c</code> instance and then calls its <code class="literal">writeByte</code> method with <code class="literal">ADXL345_XOUT_L</code> as its argument, that is, the first data register that we want to read.</p><div class="informalexample"><pre class="programlisting">self.i2c.address(self.__class__.ADXL345_I2C_ADDR)
self.i2c.writeByte(self.__class__.ADXL345_XOUT_L)</pre></div><p>The accelerometer values are stored in six data registers. There are two bytes per axis: the low byte (eight least significant bits) and the high byte (eight most significant bits), and therefore, we can read the six bytes with a single I<sup>2</sup>C read operation, starting with the address of<a id="id368" class="indexterm"/> the first byte for the x axis. Then, we have to compose each pair of bytes into a single value. The call to the <code class="literal">read</code> method for the <code class="literal">mraa.I2c</code> instance passes the <code class="literal">DATA_REG_SIZE</code> constant as an argument to indicate that we want to read six bytes and the code saves the resulting <code class="literal">bytearray</code> in the <code class="literal">xyz_raw_acceleration</code> local variable.</p><div class="informalexample"><pre class="programlisting">self.i2c.address(self.__class__.ADXL345_I2C_ADDR)
xyz_raw_acceleration = self.i2c.read(self.__class__.DATA_REG_SIZE)</pre></div><p>Then, the code combines the low bytes and the high bytes to compose a single value for each raw acceleration pair of bytes retrieved from the accelerometer and saves them in three local variables: <code class="literal">x_raw_acceleration</code>, <code class="literal">y_raw_acceleration</code>, and <code class="literal">z_raw_acceleration</code>. The code uses the binary left shift (<code class="literal">&lt;&lt;</code>) bitwise operator to move the high byte (the eight most significant bits) to the left by 8 places and make the new bits on the right-hand side zeros. Then, it applies a binary or (<code class="literal">|</code>) to build the entire word (two bytes). The <code class="literal">x_raw_acceleration</code> value is the result of joining the high byte and the low byte to <a id="id369" class="indexterm"/>compose a word of two bytes. </p><p>The first element in the <code class="literal">xyz_raw_acceleration</code> array (<code class="literal">xyz_raw_acceleration[0]</code>) includes the low byte for the x raw acceleration and the second element in the <code class="literal">xyz_raw_acceleration</code> array (<code class="literal">xyz_raw_acceleration[1]</code>) includes the high byte for the x raw acceleration. Thus, it is necessary to add 8 binary zeros to the high byte (<code class="literal">xyz_raw_acceleration[1]</code>) and replace those eight zeros with the low byte (<code class="literal">xyz_raw_acceleration[0]</code>). The same has to be done for the y and z raw acceleration bytes.</p><div class="informalexample"><pre class="programlisting">x_raw_acceleration = (xyz_raw_acceleration[1] &lt;&lt; 8) | xyz_raw_acceleration[0]
y_raw_acceleration = (xyz_raw_acceleration[3] &lt;&lt; 8) | xyz_raw_acceleration[2]
z_raw_acceleration = (xyz_raw_acceleration[5] &lt;&lt; 8) | xyz_raw_acceleration[4]</pre></div><p>Finally, it is necessary to multiply each value by the offsets defined in the constructor to obtain the appropriate values for x, y, and z expressed in g and save them in the three attributes: <code class="literal">x_acceleration</code>, <code class="literal">y_acceleration</code>, and <code class="literal">z_acceleration</code>.</p><div class="informalexample"><pre class="programlisting">self.x_acceleration = x_raw_acceleration * self.x_offset
self.y_acceleration = y_raw_acceleration * self.y_offset
self.z_acceleration = z_raw_acceleration * self.z_offset</pre></div><p>Now, we have a class that represents the ADXL345 accelerometer entirely written in Python and we can make any necessary changes to make different configurations for the accelerometer.</p><p>We just <a id="id370" class="indexterm"/>need to create a new version of the <code class="literal">Accelerometer</code> class to use the recently created <code class="literal">Adxl345</code> class instead of the <code class="literal">pyupm_adxl345.Adxl345</code> class. The following lines show the code for the new <code class="literal">Accelerometer</code> class. The code file for the sample is <code class="literal">iot_python_chapter_07_03.py</code>.</p><div class="informalexample"><pre class="programlisting">class Accelerometer:
    def __init__(self, bus):
        self.accelerometer = Adxl345(bus)
        self.x_acceleration = 0.0
        self.y_acceleration = 0.0
        self.z_acceleration = 0.0

    def measure_acceleration(self):
        # Update the acceleration values for the three axis
        self.accelerometer.update()
        self.x_acceleration = self.accelerometer.x_acceleration
        self.y_acceleration = self.accelerometer.y_acceleration
        self.z_acceleration = self.accelerometer.z_acceleration</pre></div><p>Now, we <a id="id371" class="indexterm"/>can use the same code that we have in the previous example for the <code class="literal">__main__</code> method and perform the same operations to check the values retrieved from the accelerometer.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip56"/>Tip</h3><p>Writing code that interacts with the I<sup>2</sup>C bus and a specific sensor requires a big effort because we have to read the detailed specifications from the manufacturer's datasheet. Sometimes, we won't be able to use all the features included in a sensor if we don't write our own code. In other cases, the features included in the <code class="literal">upm</code> library will be enough for our projects.</p></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Wiring an analog temperature sensor"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec69"/>Wiring an analog temperature sensor</h1></div></div></div><p>In <a class="link" href="ch06.html" title="Chapter 6. Working with Analog Inputs and Local Storage">Chapter 6</a>, <span class="emphasis"><em>Working with Analog Inputs and Local Storage</em></span>, we used a photoresistor included in a<a id="id372" class="indexterm"/> voltage divider and we connected it to an analog input pin. We can use a similar configuration and replace the photoresistor with a thermistor to measure ambient temperature. A thermistor changes its resistance value with temperature, and therefore, we can convert resistance changes into voltage value changes.</p><p>We can also <a id="id373" class="indexterm"/>work with an analog sensor breakout board that includes a thermistor in the necessary configuration to provide us with voltage levels to an analog pin that represent temperature values. In this case, we will work with an analog temperature sensor supported in the <code class="literal">upm</code> library to measure ambient temperature.</p><p>We will use the the analog pin labeled <span class="strong"><strong>A0</strong></span> to connect the voltage output of an analog accelerometer breakout board. After we finish the necessary wirings, we will write Python code to measure and display the ambient temperature in both degrees Celsius (ºC) and degrees Fahrenheit (ºF). This way, we will read the result of converting an analog value to its digital representation and we will map it to the temperature value in the appropriate measurement unit.</p><p>We need a Seeedstudio Grove temperature sensor to work with this example. The following URL provides detailed information about this module: <a class="ulink" href="http://www.seeedstudio.com/depot/Grove-Temperature-Sensor-p-774.html">http://www.seeedstudio.com/depot/Grove-Temperature-Sensor-p-774.html</a>. The following diagram shows the sensor breakout board, the necessary wirings, and the wirings from the Intel Galileo Gen 2 board to the breadboard. The Fritzing file for the sample is <code class="literal">iot_fritzing_chapter_07_04.fzz</code> and the following picture is the breadboard view. Don't forget that you can also decide to use the Grove base shield to plug this sensor to the Intel Galileo Gen 2 board. </p><div class="mediaobject"><img src="images/B05042_07_05.jpg" alt="Wiring an analog temperature sensor"/></div><p>The following <a id="id374" class="indexterm"/>picture shows the schematic with the electronic components represented as symbols:</p><div class="mediaobject"><img src="images/B05042_07_06.jpg" alt="Wiring an analog temperature sensor"/></div><p>As seen in the <a id="id375" class="indexterm"/>previous schematic, we have the following connections:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The analog input pin labeled <span class="strong"><strong>A0</strong></span> is connected to the temperature output pin labeled <span class="strong"><strong>SIG</strong></span> (<span class="strong"><strong>0</strong></span> in the breakout board's symbol)</li><li class="listitem" style="list-style-type: disc">The power pin labeled <span class="strong"><strong>3V3</strong></span> is connected to the temperature sensor power pin labeled <span class="strong"><strong>VCC</strong></span></li><li class="listitem" style="list-style-type: disc">The ground pin labeled <span class="strong"><strong>GND</strong></span> is connected to the temperature sensor ground pin labeled <span class="strong"><strong>GND</strong></span></li></ul></div><p>Now, it is time make all the necessary wirings. Don't forget to shutdown the Yocto Linux, wait for<a id="id376" class="indexterm"/> all the onboard LEDs to turn off, and unplug the power supply from the Intel Galileo Gen 2 board before adding or removing any wire from the board's pins.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Measuring ambient temperature with an analog sensor"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec70"/>Measuring ambient temperature with an analog sensor</h1></div></div></div><p>The<a id="id377" class="indexterm"/> <code class="literal">upm</code> library includes support for the Grove analog temperature sensor breakout board in the <code class="literal">pyupm_grove</code> module. The <code class="literal">GroveTemp</code> class declared in this module represents the analog temperature sensor connected to our board. The class makes it easy to retrieve the raw values read from the analog input into values expressed in degrees Celsius (ºC).</p><p>We will create a new <code class="literal">TemperatureSensor</code> class to represent the temperature sensor and make it easier for us to retrieve the ambient temperature values without worrying about unit conversions that are necessary when working with an instance of the <code class="literal">GroveTemp</code> class. We will use the <code class="literal">GroveTemp</code> class to interact with the analog temperature sensor. The following lines show the code for the new <code class="literal">TemperatureSensor</code> class that works with the <code class="literal">upm</code> library, specifically with the <code class="literal">pyupm_grove</code> module. The code file for the sample is <code class="literal">iot_python_chapter_07_04.py</code>.</p><div class="informalexample"><pre class="programlisting">import pyupm_grove as upmGrove
import time


class TemperatureSensor:
    def __init__(self, analog_pin):
        self.temperature_sensor = upmGrove.GroveTemp(analog_pin)
        self.temperature_celsius = 0.0
        self.temperature_fahrenheit = 0.0

    def measure_temperature(self):
        # Retrieve the temperature expressed in Celsius degrees
        temperature_celsius = self.temperature_sensor.value()
        self.temperature_celsius = temperature_celsius
        self.temperature_fahrenheit = \
            (temperature_celsius * 9.0 / 5.0) + 32.0</pre></div><p>We have to specify the analog pin to which the sensor is connected when we create an instance of the <code class="literal">TemperatureSensor</code> class in the <code class="literal">analog_pin</code> required arguments. The constructor, that is, the <code class="literal">__init__</code> method, creates a new <code class="literal">upmGrove.GroveTemp</code> instance with the received <code class="literal">analog_pin</code> argument and saves its reference in the <code class="literal">temperature_sensor</code> attribute. Finally, the constructor instance creates and initializes two attributes with <code class="literal">0.0</code>: <code class="literal">temperature_celsius</code>, and <code class="literal">temperature_fahrenheit</code>.</p><p>The <a id="id378" class="indexterm"/>class defines the <code class="literal">measure_temperature</code> method that retrieves the current ambient temperature measured in degrees Celsius (ºC) by calling the value method for <code class="literal">self.temperature_sensor</code> and saves the value in the <code class="literal">temperature_celsius</code> local variable. The next line assigns the value to the <code class="literal">temperature_celsius</code> attribute. Finally, the code assigns the result of converting the the temperature measured in degrees Celsius (ºC) to the equivalent value in degrees Fahrenheit (ºF). The formula is easy to read because it is just necessary to multiply the temperature measured in degrees Celsius (ºC) by 9, divide the result by 5 and sum 32. This way the <code class="literal">TemperatureSensor</code> class updates two attributes with the ambient temperature measured by the sensor in degrees Celsius (ºC) and degrees Fahrenheit (ºF).</p><p>Now, we will write a loop that will retrieve and display the ambient temperature in degrees Celsius (ºC) and degrees Fahrenheit (ºF), every 10 seconds. The code file for the sample is <code class="literal">iot_python_chapter_07_04.py</code>.</p><div class="informalexample"><pre class="programlisting">if __name__ == "__main__":
    # The temperature sensor is connected to analog pin A0
    temperature_sensor = TemperatureSensor(0)

    while True:
        temperature_sensor.measure_temperature()
        print("Ambient temperature in degrees Celsius: {0}".
              format(temperature_sensor.temperature_celsius))
        print("Ambient temperature in degrees Fahrenheit: {0}".
              format(temperature_sensor.temperature_fahrenheit))
        # Sleep 10 seconds (10000 milliseconds)
        time.sleep(10)</pre></div><p>The first line creates an instance of the previously coded <code class="literal">TemperatureSensor</code> class with <code class="literal">0</code> as the values of the <code class="literal">analog_pin</code> argument. This way, the instance will read the analog values from the pin labeled <span class="strong"><strong>A0</strong></span>. Then, the code runs a loop forever that calls the <code class="literal">measure_temperature</code> method to update the ambient temperature values and then prints them, expressed in degrees Celsius (ºC) and degrees Fahrenheit (ºF).</p><p>The following line will start the example:</p><div class="informalexample"><pre class="programlisting">python iot_python_chapter_07_04.py</pre></div><p>After you run the example, turn on an air conditioner or a heating system to generate a change in<a id="id379" class="indexterm"/> the ambient temperature and you will see how the measured temperature changes after a few minutes. The following lines show some a sample output:</p><div class="informalexample"><pre class="programlisting">Ambient temperature in degrees Celsius: 13
Ambient temperature in degrees Fahrenheit: 55.4
Ambient temperature in degrees Celsius: 14
Ambient temperature in degrees Fahrenheit: 57.2
Ambient temperature in degrees Celsius: 15
Ambient temperature in degrees Fahrenheit: 59
Ambient temperature in degrees Celsius: 16
Ambient temperature in degrees Fahrenheit: 60.8</pre></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Wiring a digital temperature and humidity sensor to the I2C bus"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec71"/>Wiring a digital temperature and humidity sensor to the I<sup>2</sup>C bus</h1></div></div></div><p>Now, we <a id="id380" class="indexterm"/>will use a multifunctional digital sensor that will provide us with temperature and relative humidity information. We will use a breakout board that uses the I<sup>2</sup>C bus to allow the Intel Galileo Gen 2 board to communicate with the sensor. The sensor is useful when we don't need to measure temperature and humidity in extreme conditions. We cannot use this sensor at the top of Mount Etna, just in case we work in a research project related to volcanoes.</p><p>We will use the two pins labeled <span class="strong"><strong>SDA</strong></span> and <span class="strong"><strong>SCL</strong></span> to connect the data and clock lines of the I<sup>2</sup>C bus to the corresponding pins in the digital temperature and humidity breakout board. After we finish the necessary wirings, we will write a Python code to measure, display the ambient temperature, and the relative humidity. This way, we will read the result of sending commands to the sensor through the I<sup>2</sup>C bus, reading the responses, and decoding them into the ambient temperature and the relative humidity expressed in the appropriate units.</p><p>We need a SeeedStudio Grove temperature &amp; humidity sensor (high-accuracy &amp; mini) breakout to work with this example. The following URL provides detailed information about this breakout board: <a class="ulink" href="http://www.seeedstudio.com/depot/Grove-TemperatureHumidity-Sensor-HighAccuracy-Mini-p-1921.html">http://www.seeedstudio.com/depot/Grove-TemperatureHumidity-Sensor-HighAccuracy-Mini-p-1921.html</a>. The breakout board incorporates the TH02 digital humidity and temperature sensor and provides support for both the I<sup>2</sup>C bus.</p><p>The following diagram shows the digital temperature, humidity breakout, the necessary wirings, and the wirings from the Intel Galileo Gen 2 board to the breadboard. The Fritzing file for the sample is <code class="literal">iot_fritzing_chapter_07_05.fzz</code> and the following picture is the<a id="id381" class="indexterm"/> breadboard view:</p><div class="mediaobject"><img src="images/B05042_07_07.jpg" alt="Wiring a digital temperature and humidity sensor to the I2C bus"/></div><p>The following picture shows the schematic with the electronic components represented as symbols:</p><div class="mediaobject"><img src="images/B05042_07_08.jpg" alt="Wiring a digital temperature and humidity sensor to the I2C bus"/></div><p>As seen in<a id="id382" class="indexterm"/> the previous schematic, we have the following connections:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="strong"><strong>SDA</strong></span> pin is connected to the breakout board pin labeled <span class="strong"><strong>SDA</strong></span>. This way, we connect the digital temperature and humidity sensor to the serial data line for the I<sup>2</sup>C bus.</li><li class="listitem" style="list-style-type: disc">The <span class="strong"><strong>SCL</strong></span> pin is connected to the breakout board pin labeled <span class="strong"><strong>SCL</strong></span>. This way, we connect the digital temperature and humidity sensor to the serial clock line for the I<sup>2</sup>C bus.</li><li class="listitem" style="list-style-type: disc">The power pin labeled <span class="strong"><strong>3V3</strong></span> is connected to the breakout board power pin labeled <span class="strong"><strong>VCC</strong></span>.</li><li class="listitem" style="list-style-type: disc">The ground pin labeled <span class="strong"><strong>GND</strong></span> is connected to the breakout board ground pin labeled <span class="strong"><strong>GND</strong></span>.</li></ul></div><p>Now, it is<a id="id383" class="indexterm"/> time make all the necessary wirings. Don't forget to shutdown the Yocto Linux, wait for all the onboard LEDs to turn off, and unplug the power supply from the Intel Galileo Gen 2 board before adding or removing any wire from the board's pins.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Measuring temperature and humidity with a digital sensor"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec72"/>Measuring temperature and humidity with a digital sensor</h1></div></div></div><p>The <a id="id384" class="indexterm"/>
<code class="literal">upm</code> library includes support for the digital temperature and humidity breakout board that uses the TH02 sensor in the <code class="literal">pyupm_th02</code> module. The <code class="literal">TH02</code> class declared in this module represents a digital temperature and humidity sensor that uses the TH02 sensor, connected to our board. The class makes it easy to initialize the sensor and retrieve the temperature and humidity values through the I<sup>2</sup>C bus. The class works with the <code class="literal">mraa.I2c</code> class under the hoods to talk with the sensor, that is, to write data to and read data from the TH02 sensor that acts as a slave device connected to the I<sup>2</sup>C bus.</p><p>We will create a new <code class="literal">TemperatureAndHumiditySensor</code> class to represent the temperature and humidity sensor and make it easier for us to retrieve the temperature and humidity values in the appropriate units working with an instance of the <code class="literal">TH02</code> class. We will use the <code class="literal">TH02</code> class to interact with the sensor. The following lines show the code for the new <code class="literal">TemperatureSensor</code> class that works with the <code class="literal">upm</code> library, specifically with the <code class="literal">pyupm_th02</code> module. The code file for the sample is <code class="literal">iot_python_chapter_07_05.py</code>.</p><div class="informalexample"><pre class="programlisting">import pyupm_th02 as upmTh02
import time


class TemperatureAndHumiditySensor:
    def __init__(self, bus):
        self.th02_sensor = upmTh02.TH02(bus)
        self.temperature_celsius = 0.0
        self.temperature_fahrenheit = 0.0
        self.humidity = 0.0

    def measure_temperature_and_humidity(self):
        # Retrieve the temperature expressed in Celsius degrees
        temperature_celsius = self.th02_sensor.getTemperature()
        self.temperature_celsius = temperature_celsius
        self.temperature_fahrenheit = \
            (temperature_celsius * 9.0 / 5.0) + 32.0
        # Retrieve the humidity
        self.humidity = self.th02_sensor.getHumidity()</pre></div><p>We <a id="id385" class="indexterm"/>have to specify the I<sup>2</sup>C bus number to which the digital temperature and humidity sensor is wired when we create an instance of the <code class="literal">TemperatureAndHumiditySensor</code> class in the <code class="literal">bus</code> required argument. The constructor, that is, the <code class="literal">__init__</code> method, creates a new <code class="literal">upmTh02.TH02</code> instance with the received <code class="literal">bus</code> argument and saves its reference in the <code class="literal">th02_sensor</code> attribute.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip57"/>Tip</h3><p>The datasheet for the TH02 sensor specifies a formula to convert the raw read temperature to degrees Celsius (ºC), and therefore, by reading the datasheet we might think the <code class="literal">upmTh02.TH02</code> instance will provide us a value in degrees Fahrenheit (ºF). However, this is not what happens. The <code class="literal">upmTh02.TH02</code> instance performs the conversion from degrees Fahrenheit (ºF) to degrees Celsius (ºC) and provides us a value in the latter unit of measure. Thus, if we want to display the value in degrees Fahrenheit (ºF), we must perform the conversion from degrees Celsius (ºC) to degrees Fahrenheit (ºF). Unluckily, the only way of realizing about this situation is by looking at the C++ source code for the <code class="literal">upm</code> module because there is no documentation about the unit of measure that the code uses to return the temperature value.</p></div></div><p>We want to work with easy to understand attributes, and therefore, the constructor creates and initializes three attributes with <code class="literal">0.0</code>: <code class="literal">temperature_celsius</code>, <code class="literal">temperature_fahrenheit</code>, and <code class="literal">humidity</code>. After the constructor is executed, we have an initialized digital temperature and humidity sensor ready to retrieve values.</p><p>The class defines a <code class="literal">measure_temperature_and_humidity</code> method that updates the ambient temperature and humidity values in the sensor, retrieves these values, and finally saves them in the following three attributes: <code class="literal">temperature_celsius</code>, <code class="literal">temperature_fahrenheit</code>, and <code class="literal">humidity</code>.</p><p>First, the code within the <code class="literal">measure_temperature_and_humidity</code> method calls the <code class="literal">getTemperature</code> method for <code class="literal">self.th02_sensor</code> to request the sensor to retrieve the temperature value. The method returns the read value converted to degrees Celsius (ºC) and the code saves it in the <code class="literal">temperature_celsius</code> local variable. The code saves the value in the attribute with the same name and saves the value converted to degrees Fahrenheit (ºF) in the <code class="literal">temperature_fahrenheit</code> attribute. Finally, the code calls the <code class="literal">getHumidity</code> method for <code class="literal">self.th02_sensor</code> to request the sensor to retrieve the humidity value and saves it in the <code class="literal">humidity</code> attribute.</p><p>Now, we<a id="id386" class="indexterm"/> will write a loop that will retrieve and display the temperature values expressed in degrees Celsius (ºC) and degrees Fahrenheit, and the humidity value, every 10 seconds. The code file for the sample is <code class="literal">iot_python_chapter_07_05.py</code>.</p><div class="informalexample"><pre class="programlisting">if __name__ == "__main__":
    temperature_and_humidity_sensor = \
        TemperatureAndHumiditySensor(0)

    while True:
        temperature_and_humidity_sensor.\
            measure_temperature_and_humidity()
        print("Ambient temperature in degrees Celsius: {0}".
              format(temperature_and_humidity_sensor.temperature_celsius))
        print("Ambient temperature in degrees Fahrenheit: {0}".
              format(temperature_and_humidity_sensor.temperature_fahrenheit))
        print("Ambient humidity: {0}%".
              format(temperature_and_humidity_sensor.humidity))
        # Sleep 10 seconds (10000 milliseconds)
        time.sleep(10)</pre></div><p>The first line creates an instance of the previously coded <code class="literal">TemperatureAndHumiditySensor</code> class with <code class="literal">0</code> as the value of the <code class="literal">bus</code> argument. This way, the instance will establish a communication with the digital accelerometer through the I<sup>2</sup>C bus. As happened in our previous example with a sensor connected to the I<sup>2</sup>C bus, the Intel Galileo Gen 2 board is the master in the bus and the digital temperature and humidity sensor, acts as a slave.</p><p>Then, the code runs a loop forever that calls the <code class="literal">measure_temperature_and_humidity</code> method to update the temperature values expressed in two units and the humidity.</p><p>The following line will start the example:</p><div class="informalexample"><pre class="programlisting">python iot_python_chapter_07_05.py</pre></div><p>After <a id="id387" class="indexterm"/>you run the example, turn on an air conditioner or a heating system, to generate a change in the ambient temperature and humidity.</p><div class="informalexample"><pre class="programlisting">Ambient temperature in degrees Celsius: 24
Ambient temperature in degrees Fahrenheit: 73.4
Ambient humidity: 48%</pre></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Test your knowledge"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec73"/>Test your knowledge</h1></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Which of the following sensors allows us to measure the magnitude and direction of proper acceleration?<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">A temperature sensor.</li><li class="listitem">An accelerometer.</li><li class="listitem">A light sensor.</li></ol></div></li><li class="listitem">Which of the following acronym that defines a connection type for a module with a sensor is analog:<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">AIO.</li><li class="listitem">I2C.</li><li class="listitem">UART.</li></ol></div></li><li class="listitem">How many wires do we need to connect a device to the I<sup>2</sup>C bus:<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">1<code class="literal">.</code></li><li class="listitem">2<code class="literal">.</code></li><li class="listitem">3<code class="literal">.</code></li></ol></div></li><li class="listitem">How many wires do we need to connect a device to the SPI bus:<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">1<code class="literal">.</code></li><li class="listitem">2<code class="literal">.</code></li><li class="listitem">3<code class="literal">.</code></li></ol></div></li><li class="listitem">Which of the following is not a connection of the I<sup>2</sup>C bus:<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">MISO.</li><li class="listitem">SDA.</li><li class="listitem">SCL.</li></ol></div></li></ol></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec74"/>Summary</h1></div></div></div><p>In this chapter, we learned about sensors and their connection types. We understood that it is necessary to consider many important things when choosing sensors and that they make it easy for us to measure different variables from the real world. We learned the importance of considering the units of measure because sensors always provide values measured in a specific unit that we must consider.</p><p>We wrote code that took advantage of the modules and classes included in the <code class="literal">upm</code> library that made it easier for us to start working with analog and digital sensors. In addition, we wrote code that interacted with a digital accelerometer through the I<sup>2</sup>C bus because we wanted to be able to take advantage of additional features provided by the sensor but not included in the <code class="literal">upm</code> library module.</p><p>We measured the magnitude and direction of proper acceleration or g-force, ambient temperature and humidity. As in the previous chapters, we continued taking advantage of Python's object-oriented features and we created classes to encapsulate sensors and the necessary configurations with the <code class="literal">upm</code> and <code class="literal">mraa</code> libraries. Our code is easy to read and understand and we can easily hide the low-level details.</p><p>Now that we are able to retrieve data from the real world with sensors, we will make our IoT device perform actions with different actuators and shields, which is the topic of the next chapter.</p></div></div>
</body></html>