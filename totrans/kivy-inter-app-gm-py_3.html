<html><head></head><body>
  <div id="sbo-rt-content"><div class="chapter" title="Chapter 3. Widget Events – Binding Actions"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Widget Events – Binding Actions</h1></div></div></div><p>In this <a id="id230" class="indexterm"/>chapter, you will learn how to integrate actions into the <span class="strong"><strong>Graphical User Interface</strong></span> (<span class="strong"><strong>GUI</strong></span>) components; some of the actions will be associated with the canvas and others with the <code class="literal">Widget</code> management. We will learn how to handle events dynamically in order to make the application respond to the user interactions. In this chapter, you will acquire the following skills:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Reference different parts of the GUI through IDs and properties</li><li class="listitem" style="list-style-type: disc">Override, bind, unbind, and create Kivy events</li><li class="listitem" style="list-style-type: disc">Add widgets to other widgets dynamically</li><li class="listitem" style="list-style-type: disc">Add vertex and context instructions to the canvas dynamically</li><li class="listitem" style="list-style-type: disc">Translate relative and absolute coordinates between a widget, its parent, and its window</li><li class="listitem" style="list-style-type: disc">Use properties to keep the GUI updated with the changes</li></ul></div><p>This is an exciting chapter because our application will start interacting with the user applying the concepts acquired in the previous two chapters. All the basic functionality of our <span class="emphasis"><em>Comic Creator</em></span> project will be ready by the end. This includes shapes that can be dragged, sizeable circles, and lines, clearing the widget space, removing the last added figure, grouping several widgets to drag them together, and keeping the <span class="emphasis"><em>status bar</em></span> updated about the last actions of the user.</p><div class="section" title="Attributes, ID, and root"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec22"/>Attributes, ID, and root</h1></div></div></div><p>In <a id="id231" class="indexterm"/>
<a class="link" href="ch01.html" title="Chapter 1. GUI Basics – Building an Interface">Chapter 1</a>, <span class="emphasis"><em>GUI Basics – Building an Interface</em></span>, we distinguished <a id="id232" class="indexterm"/>between <a id="id233" class="indexterm"/>four main components for our <span class="emphasis"><em>Comic Creator</em></span>: <span class="emphasis"><em>tool box</em></span>, <span class="emphasis"><em>drawing space</em></span>, <span class="emphasis"><em>general options</em></span>, and <span class="emphasis"><em>status bar</em></span>. In this chapter, we will make these components interact with each other and, therefore, we need to add some attributes to the classes of the project we created in the previous chapters. These attributes will reference different parts of the interface so that they can communicate. For example, the <code class="literal">ToolBox</code> class needs to<a id="id234" class="indexterm"/> have a reference to the <code class="literal">DrawingSpace</code> instance, so<a id="id235" class="indexterm"/> the <code class="literal">ToolButton</code> instances can draw <a id="id236" class="indexterm"/>their respective figures inside it. The following diagram shows all the relationships that are created in the <code class="literal">comiccreator.kv</code> file:</p><div class="mediaobject"><img src="images/B04244_03_01.jpg" alt="Attributes, ID, and root"/><div class="caption"><p>Internal References of the <span class="emphasis"><em>Comic Creator</em></span>
</p></div></div><p>We also learned in <a class="link" href="ch01.html" title="Chapter 1. GUI Basics – Building an Interface">Chapter 1</a>, <span class="emphasis"><em>GUI Basics – Building an Interface,</em></span> that <span class="strong"><strong>ID</strong></span> lets us reference other widgets in the Kivy language.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note20"/>Note</h3><p>The IDs are only meant to be used within the Kivy language. Therefore, we need to create attributes in order to reference the elements inside the Python code.</p></div></div><p>Following is the <code class="literal">comiccreator.kv</code> file of the <span class="emphasis"><em>Comic Creator</em></span> project with some modifications to create the necessary IDs and attributes:</p><div class="informalexample"><pre class="programlisting">1. File Name: comiccreator.kv 
2. &lt;ComicCreator&gt;:
3.    AnchorLayout:
4.        anchor_x: 'left'
5.        anchor_y: 'top'
6.        ToolBox:
7.            id: _tool_box
8.            drawing_space: _drawing_space
9.            comic_creator: root
10.            size_hint: None,None
11.            width: 100
12.    AnchorLayout:
13.        anchor_x: 'right'
14.        anchor_y: 'top'
15.        DrawingSpace:
16.            id: _drawing_space
17.            status_bar: _status_bar
18.            general_options: _general_options
19.            tool_box: _tool_box
20.            size_hint: None,None
21.            width: root.width - _tool_box.width
22.            height: root.height - _general_options.height - _status_bar.height
23.    AnchorLayout:
24.        anchor_x: 'center'
25.        anchor_y: 'bottom'
26.        BoxLayout:
27.             orientation: 'vertical'
28.             GeneralOptions:
29.                 id: _general_options
30.                 drawing_space: _drawing_space
31.                 comic_creator: root
32.                 size_hint: 1,None
33.                 height: 48
34.             StatusBar:
35.                 id: _status_bar
36.                 size_hint: 1,None
37.                 height: 24</pre></div><p>The IDs <a id="id237" class="indexterm"/>in lines 7, 16, 29, and 35 have been added to the comiccreator.kv. Following the previous<a id="id238" class="indexterm"/> diagram (Internal References of the <span class="emphasis"><em>Comic Creator</em></span>), the IDs are used to<a id="id239" class="indexterm"/> create the attributes in lines 8, 17, 18, 19, and 30.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip11"/>Tip</h3><p>The names of the attributes and IDs don't have to be different. In the previous code, we just added '_' to the IDs to distinguish them from the attributes. That is to say, the <code class="literal">_status_bar</code> ID, is only accessible within the <code class="literal">.kv</code> files, and the <code class="literal">status_bar</code> attribute, is intended to be used inside the Python code. Both could have had the same name without causing any conflict.</p></div></div><p>As an example, line 8 created the attribute <code class="literal">drawing_space</code>, which references the <code class="literal">DrawingSpace</code> instance. This means that the <code class="literal">ToolBox</code> (line 6) instance can now access the <code class="literal">DrawingSpace</code> instance in order to draw figures on it.</p><p>One component that we often want to have access to is the base widget (<code class="literal">ComicCreator</code>) of the rule hierarchy. Lines 9 and 31 complete the referencing using <span class="strong"><strong><code class="literal">root</code></strong></span> to have access to it<a id="id240" class="indexterm"/> through the <code class="literal">comic_creator</code> attribute.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note21"/>Note</h3><p>The <a id="id241" class="indexterm"/>reserved <span class="strong"><strong><code class="literal">root</code></strong></span> keyword is an internal Kivy language variable that always refers to the base widget in the rule hierarchy. The other<a id="id242" class="indexterm"/> two important keywords are <span class="strong"><strong><code class="literal">self</code></strong></span> and <span class="strong"><strong><code class="literal">app</code></strong></span>. The <a id="id243" class="indexterm"/>keyword <span class="strong"><strong><code class="literal">self</code></strong></span> refers to the current widget, and <span class="strong"><strong><code class="literal">app</code></strong></span> refers to the instance of the application.</p></div></div><p>These<a id="id244" class="indexterm"/> are <a id="id245" class="indexterm"/>all the changes that are needed in the <span class="emphasis"><em>Comic Creator</em></span> project to <a id="id246" class="indexterm"/>create the attributes. We can run the project as usual with Python <code class="literal">comicreator.py</code> and we will obtain the same result as <a class="link" href="ch02.html" title="Chapter 2. Graphics – the Canvas">Chapter 2</a>, <span class="emphasis"><em>Graphics – the Canvas</em></span>.</p><p>We created the links between the interface components with attributes. In the following sections, we will frequently use the created attributes to access different parts of the interface.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Basic widget events – dragging the stickman"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec23"/>Basic widget events – dragging the stickman</h1></div></div></div><p>Basic <code class="literal">Widget</code> events <a id="id247" class="indexterm"/>correspond to touches on the screen. However, the <a id="id248" class="indexterm"/>concept of touch in Kivy is broader than might be intuitively assumed. It includes mouse events, finger touches, and magic pen touches. For the sake of simplicity, we will often assume in this chapter that we are using a mouse but it doesn't really change if we were to use a touch screen (and the finger or magic pen instead). The following are the three basic <code class="literal">Widget</code> events:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong><code class="literal">on_touch_down</code></strong></span>: When<a id="id249" class="indexterm"/> a new touch starts, for example, the action of clicking a button of the mouse or touching the screen.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong><code class="literal">on_touch_move</code></strong></span>: When<a id="id250" class="indexterm"/> the touch is moved, for example, dragging the mouse or sliding the finger over the screen.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong><code class="literal">on_touch_up</code></strong></span>: When<a id="id251" class="indexterm"/> the touch ends, for example, releasing the mouse button or lifting a finger from the screen.</li></ul></div><p>Notice that <span class="strong"><strong><code class="literal">on_touch_down</code></strong></span> takes<a id="id252" class="indexterm"/> place each time before <a id="id253" class="indexterm"/>
<span class="strong"><strong><code class="literal">on_touch_move</code></strong></span>, and <span class="strong"><strong><code class="literal">on_touch_up</code></strong></span> happens; the bullet<a id="id254" class="indexterm"/> list order reflects the necessary execution order. Finally, <span class="strong"><strong><code class="literal">on_touch_move</code></strong></span> cannot happen at all if there is no moving action. These events allow us to add drag capability to our <code class="literal">Stickman</code> so that we can place it wherever we want after adding it. We modify the header of <code class="literal">comicwidgets.kv</code> as follows:</p><div class="informalexample"><pre class="programlisting">38. # File name: comicwidgets.kv
39. #:import comicwidgets comicwidgets
40. &lt;DraggableWidget&gt;:
41.    size_hint: None, None
42.
43. &lt;StickMan&gt;:
44.    size: 48,48
45.    ... </pre></div><p>The code <a id="id255" class="indexterm"/>now<a id="id256" class="indexterm"/> includes a rule for a new <code class="literal">Widget</code> called <code class="literal">DraggableWidget</code>. Line 41 deactivates <code class="literal">size_hint</code> so that we can use fixed sizes (for example, line 44). The <code class="literal">size_hint: None, None</code> instruction has been removed from the <code class="literal">StickMan</code> because it will inherit from <code class="literal">DraggableWidget</code> in <a id="id257" class="indexterm"/>the Python code. The <span class="strong"><strong><code class="literal">import</code></strong></span> <span class="strong"><strong>directive</strong></span> on line 39 is responsible for importing the respective <code class="literal">comicwidgets.py</code> file:</p><div class="informalexample"><pre class="programlisting">46. # File name: comicwidgets.py
47. from kivy.uix.relativelayout import RelativeLayout
48. from kivy.graphics import Line
49.
50. class DraggableWidget(RelativeLayout):
51.    def __init__(self,  **kwargs):
52.        self.selected = None
53.        super(DraggableWidget, self).__init__(**kwargs)</pre></div><p>The <code class="literal">comicwidgets.py</code> file contains the new <code class="literal">DraggableWidget</code> class. This class inherits from <code class="literal">RelativeLayout</code> (line 50). The <code class="literal">selected</code> attribute in line 52 will indicate whether the <code class="literal">DraggableWidget</code> instance is selected or not. Notice that <code class="literal">selected</code> is not part of Kivy; it is an attribute that we just created as part of the <code class="literal">DraggableWidget</code> class.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip12"/>Tip</h3><p>The <code class="literal">__init__</code> constructor in Python is the right place to define class object attributes by simply using the <code class="literal">self</code> reference without declaring them at the class level; this often causes confusion to programmers coming from other object-oriented languages, such as C++ or Java.</p></div></div><p>In the <code class="literal">comicwidgets.py</code> file, we also have to override the three methods associated with the touch events (<code class="literal">on_touch_down</code>, <code class="literal">on_touch_move</code>, and <code class="literal">on_touch_up</code>). Each of these methods receives <code class="literal">MotionEvent</code> as a parameter (<code class="literal">touch</code>), which contains a lot of useful information related to the event, for instance, the coordinates of the touch, type of touch, the number of taps (or clicks), duration, the input device, and many more that can be used for advanced tasks (<a class="ulink" href="http://kivy.org/docs/api-kivy.input.motionevent.html#kivy.input.motionevent.MotionEvent">http://kivy.org/docs/api-kivy.input.motionevent.html#kivy.input.motionevent.MotionEvent</a>).</p><p>Let's start with <span class="strong"><strong><code class="literal">on_touch_down</code></strong></span>:</p><div class="informalexample"><pre class="programlisting">54.    def on_touch_down(self, touch):
55.        if self.collide_point(touch.x, touch.y):
56.            self.select()
57.            return True
58.        return super(DraggableWidget, self).on_touch_down(touch)</pre></div><p>In line 55, we<a id="id258" class="indexterm"/> used the most common strategy in Kivy to detect if the<a id="id259" class="indexterm"/> touch is on top of a widget: the <span class="strong"><strong><code class="literal">collide_point</code></strong></span> method. It allows <a id="id260" class="indexterm"/>us to detect whether the event actually happens inside a specific <code class="literal">DraggableWidget</code> by checking the coordinates of the touch.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note22"/>Note</h3><p>Every active <code class="literal">Widget</code> receives all the touch events (<code class="literal">MotionEvent</code>) that happen inside the app (coordinate space), and we can use the <code class="literal">collide_point</code> method to detect whether the event occurs in any particular <code class="literal">Widget</code>.</p></div></div><p>This means it is up to the programmer to implement the logic that will discriminate between the possibility of a particular <code class="literal">Widget</code> doing something (in this case, to call on the method <code class="literal">select</code> in line 56) with the event, or whether it will just let it pass by calling the base class method (line 58) and hence, the default behavior.</p><p>The most common way of handling an event is by using <span class="strong"><strong><code class="literal">collide_point</code></strong></span>, but other criteria can be used. Kivy gives us absolute freedom in this. Line 55 provides the simplest case of checking whether the event occurred inside the <code class="literal">Widget</code>. If the coordinate of the event was actually inside the <code class="literal">Widget</code>, we call on the <code class="literal">select()</code> method, which will set the figure as being selected (details explained later in this chapter).</p><p>It is important to understand the returning value of an event (line 57) and also what calling the method of the base class means (line 58). The Kivy GUI has a hierarchical structure, so <a id="id261" class="indexterm"/>each <code class="literal">Widget</code> instance always has a corresponding <span class="strong"><strong><code class="literal">parent</code></strong></span> <code class="literal">Widget</code> (except if the <code class="literal">Widget</code> instance is the root of the hierarchy).</p><p>The returning value of the touch event tells the <span class="strong"><strong><code class="literal">parent</code></strong></span> whether we took care of the event or not by returning <code class="literal">True</code> or <code class="literal">False</code>, respectively. Therefore, we need to be careful because we are in full control of the widgets that receive the event. Finally, we can also use the returning value of <code class="literal">super</code> (base class reference) to find out whether one of the children has taken care of the event already.</p><p>In general, the structure of the <code class="literal">on_touch_down</code> method overriding lines 54 to 58, is the most common way to take care of a basic event:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Make sure that the event happens inside <code class="literal">Widget</code> (line 55).</li><li class="listitem">Do what has to be done (line 56).</li><li class="listitem">Return <code class="literal">True</code> indicating that the event was processed (line 57).</li><li class="listitem">If the event falls outside the <code class="literal">Widget</code>, then we propagate the event to the children and return the result (line 58).</li></ol></div><p>Even though<a id="id262" class="indexterm"/> this is the most common way, and probably recommended for<a id="id263" class="indexterm"/> beginners, we can deviate from this in order to achieve different goals; we will soon expand this with other examples. First, let's review the <code class="literal">select</code> method:</p><div class="informalexample"><pre class="programlisting">59.     def select(self):
60.        if not self.selected:
61.            self.ix = self.center_x
62.            self.iy = self.center_y
63.            with self.canvas:
64.                self.selected = Line(rectangle=(0,0,self.width,self.height), dash_offset=2)</pre></div><p>First, we need to ensure that nothing has been selected before (line 60) using the <code class="literal">select</code> attribute we created earlier (line 52). If this is the case, we save the center coordinates of <code class="literal">DraggableWidget</code> (lines 61 and 62), and we dynamically draw a rectangle on its border (line 63 and 64), as illustrated in the following screenshot:</p><div class="mediaobject"><img src="images/B04244_03_02.jpg" alt="Basic widget events – dragging the stickman"/></div><p>Line 63 is a convenience based on the <code class="literal">with</code> Python statement. It is equivalent to the call in the <span class="strong"><strong><code class="literal">add</code></strong></span> method<a id="id264" class="indexterm"/> with <code class="literal">self.canvas.add(Rectangle(…))</code>, with the advantage that it allows us to add many instructions at the same time. For example, we could use it to add three instructions:</p><div class="informalexample"><pre class="programlisting">with self.canvas:
   Color(rgb=(1,0,0))
   Line(points=(0,0,5,5))
   Rotate()
   ...</pre></div><p>In <a class="link" href="ch02.html" title="Chapter 2. Graphics – the Canvas">Chapter 2</a>, <span class="emphasis"><em>Graphics – the Canvas</em></span>, we used Kivy language to add shapes to the <code class="literal">canvas</code>. Now, we used Python code directly and not the Kivy language syntax anymore, although the Python <code class="literal">with</code> statement slightly resembles it and it is frequently used in the Kivy API. Notice that we kept the <code class="literal">Line</code> instance in the <code class="literal">selected</code> attribute in line 64 because we will need it in order to remove the rectangle once the widget is not selected anymore. Also, the <code class="literal">DraggableWidget</code> instance will be aware of when it is selected, either whether it contains a reference or is <code class="literal">None</code>.</p><p>That <a id="id265" class="indexterm"/>condition <a id="id266" class="indexterm"/>is used in the <code class="literal">on_touch_move</code> method:</p><div class="informalexample"><pre class="programlisting">65.    def on_touch_move(self, touch):
66.        (x,y) = self.parent.to_parent(touch.x, touch.y)
67.        if self.selected and self.parent.collide_point(x - self.width/2, y - self.height/2):
68.            self.translate(touch.x-self.ix,touch.y-self.iy)
69.            return True
70.        return super(DraggableWidget, self).on_touch_move(touch)</pre></div><p>In this event, we control the dragging of <code class="literal">DraggableWidget</code>. In line 67, we make sure that <code class="literal">DraggableWidget</code> is selected. In the same line, we use <code class="literal">collide_point</code> again but this time, we<a id="id267" class="indexterm"/> use <span class="strong"><strong><code class="literal">parent</code></strong></span> (<span class="emphasis"><em>drawing space</em></span>) instead of <code class="literal">self</code>. This is the reason why the previous line (line 66) transformed the widget coordinates to values that are relative to the corresponding <code class="literal">parent</code> with the <span class="strong"><strong><code class="literal">to_parent</code></strong></span> method. In other words, we <a id="id268" class="indexterm"/>have to check the <code class="literal">parent</code> (<span class="emphasis"><em>drawing space</em></span>) because the <code class="literal">Stickman</code> can be dragged inside the whole of the <span class="emphasis"><em>drawing space</em></span>, and not just inside <code class="literal">DraggableWidget</code> itself. The next section will explain in detail how to localize coordinates to different parts of the screen.</p><p>Another detail of line 67 is that we check the left corner of the future position of <code class="literal">DraggableWidget</code> by subtracting half its width and height from the current touch (<code class="literal">touch.x - self.width/2, touch.y - self.height/2</code>). This is in order to make sure that we don't drag the shape outside the <span class="emphasis"><em>drawing space</em></span> because we will drag it from the center.</p><p>If the conditions are <code class="literal">True</code>, we call the <code class="literal">translate</code> method:</p><div class="informalexample"><pre class="programlisting">71.     def translate(self, x, y):
72.         self.center_x = self.ix = self.ix + x
73.         self.center_y = self.iy = self.iy + y</pre></div><p>The method moves the <code class="literal">DraggableWidget</code> (<code class="literal">x</code>, <code class="literal">y</code>) pixels by assigning new values to the <code class="literal">center_x</code> and <code class="literal">center_y</code> properties (lines 72 and 73). It also updates the <code class="literal">ix</code> and <code class="literal">iy</code> properties that we created in the <code class="literal">select</code> method before lines 61 and 62.</p><p>The last two lines (lines 69 and 70) of the <code class="literal">on_touch_move</code> method follow the same approach of the <code class="literal">on_touch_down</code> method (line 57 and 58), and also the <code class="literal">on_touch_up</code> method (lines 77 and 78):</p><div class="informalexample"><pre class="programlisting">74.     def on_touch_up(self, touch):
75.        if self.selected:
76.            self.unselect()
77.            return True
78.        return super(DraggableWidget, self).on_touch_up(touch)</pre></div><p>The <code class="literal">on_touch_up</code> event undoes the <code class="literal">on_touch_down</code> status. First, it checks whether it is selected <a id="id269" class="indexterm"/>using our <code class="literal">selected</code> attribute. If it is, then it calls the <code class="literal">unselected()</code> method:</p><div class="informalexample"><pre class="programlisting">79.    def unselect(self):
80.        if self.selected:
81.            self.canvas.remove(self.selected)
82.            self.selected = None</pre></div><p>This <a id="id270" class="indexterm"/>method will dynamically call the <span class="strong"><strong><code class="literal">remove</code></strong></span> method to remove the <code class="literal">Line</code> vertex <a id="id271" class="indexterm"/>instruction from the <code class="literal">canvas</code> (line 81), and set our attribute <code class="literal">selected</code> to <code class="literal">None</code> (line 82) to indicate that the widget is not being dragged anymore. Notice the different ways in which we add the <code class="literal">Line</code> vertex instruction (line 63 and 64) and remove it (line 81).</p><p>There are two more lines of code in <code class="literal">comicwidgets.py</code>:</p><div class="informalexample"><pre class="programlisting">83. class StickMan(DraggableWidget):
84.    pass</pre></div><p>These lines define our <code class="literal">StickMan</code>, which now inherits from <code class="literal">DraggableWidget</code> (line 83) instead of from <code class="literal">RelativeLayout</code>.</p><p>A final change is necessary in <code class="literal">drawingspace.kv</code>, which now looks as follows:</p><div class="informalexample"><pre class="programlisting">85. # File name: drawingspace.kv
86. &lt;DrawingSpace@RelativeLayout&gt;:
87.    Canvas.before:
88.        Line: 
89.            rectangle: 0, 0, self.width - 4,self.height - 4
90.    StickMan:</pre></div><p>We added a border to <code class="literal">canvas.before</code> of the <span class="emphasis"><em>drawing space</em></span> (lines 87 and 88), which will serve us a reference to visualize where the canvas starts or ends. We also kept a <code class="literal">StickMan</code> instance in the <span class="emphasis"><em>drawing space</em></span>. You can run the application (<code class="literal">python comiccreator.py</code>) and drag the <code class="literal">StickMan</code> over the <span class="emphasis"><em>drawing space</em></span>.</p><div class="mediaobject"><img src="images/B04244_03_03.jpg" alt="Basic widget events – dragging the stickman"/></div><p>In this <a id="id272" class="indexterm"/>section, you learned the three basic touch events of any <code class="literal">Widget</code>. They <a id="id273" class="indexterm"/>are strongly dependent on the coordinates, and therefore it will be necessary to learn how to properly manipulate the coordinates. We introduce this technique in the <code class="literal">on_touch_move</code> method, but it will be the main topic in the next section, which explores the possible ways that Kivy offers to localize coordinates.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Localizing coordinates – adding stickmen"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec24"/>Localizing coordinates – adding stickmen</h1></div></div></div><p>In the<a id="id274" class="indexterm"/> last section, we used the <span class="strong"><strong><code class="literal">to_parent()</code></strong></span> method (line 66) to <a id="id275" class="indexterm"/>translate<a id="id276" class="indexterm"/> the coordinates relative to the <code class="literal">DrawingSpace</code>, to its parent. Remember that we were inside <code class="literal">DraggableWidget</code> and the coordinates we received were relative to <code class="literal">parent</code> (<code class="literal">DrawingSpace</code>).</p><p>These coordinates are convenient for <code class="literal">DraggableWidget</code> because we positioned it in the parent's coordinates. The method allows us to use the coordinates in the parent's <code class="literal">collide_point</code>. This is no longer convenient for when we want to check the coordinates on the parent's <code class="literal">parent</code> space or when we need to draw something directly on the canvas of a <code class="literal">Widget</code>.</p><p>Before studying more examples, let's review the theory. You learned that <code class="literal">RelativeLayout</code> is very useful because it is simpler to think inside a constraint space to localize our objects. The problems start when we need to translate coordinates to another <code class="literal">Widget</code> area. Let's consider the following screenshot of a Kivy program:</p><div class="mediaobject"><img src="images/B04244_03_04.jpg" alt="Localizing coordinates – adding stickmen"/></div><p>The code<a id="id277" class="indexterm"/> to generate this example is not shown here since it is very<a id="id278" class="indexterm"/> straightforward. If you want to test it, you can find the code under the folder <code class="literal">04 - Embedding RelativeLayouts/</code> and run it with <code class="literal">python main.py --size=150x75</code>. It consists of three <code class="literal">RelativeLayouts</code> embedded into each other. The <span class="strong"><strong>Blue</strong></span> (darker gray) is parent of the <span class="strong"><strong>Green</strong></span> (light gray) and the <span class="strong"><strong>Green</strong></span> is parent of <span class="strong"><strong>Red</strong></span> (middle gray). The <span class="strong"><strong>a</strong></span> (in the top-right corner) is a <code class="literal">Label</code> instance located at the position <code class="literal">(5, 5)</code> inside <span class="strong"><strong>Red</strong></span> (middle gray) <code class="literal">RelativeLayout</code>. The <span class="strong"><strong>Blue</strong></span> layout (dark gray) is the size of the window (150 x 75). The rest of the elements are indicators (no part of the code) to help you understand the example.</p><p>The preceding screenshot includes some measurements that help explain the four methods of localizing coordinates that the <code class="literal">Widget</code> class provides:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong><code class="literal">to_parent()</code></strong></span>: This<a id="id279" class="indexterm"/> method transforms relative coordinates inside <code class="literal">RelativeLayout</code> to the parent of <code class="literal">RelativeLayout</code>. For example, <code class="literal">red.to_parent(a.x, a.y)</code> returns the coordinates of <code class="literal">a</code> relative to the green (light gray) layout, which are <code class="literal">(50+5, 25+5) = (55, 30)</code>.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong><code class="literal">to_local()</code></strong></span>: This <a id="id280" class="indexterm"/>method transforms the coordinates of <code class="literal">parent</code> of <code class="literal">RelativeLayout</code> to <code class="literal">RelativeLayout</code>. For example, <code class="literal">red.to_local(55,30)</code> returns <code class="literal">(5,5)</code>, the coordinates of the <code class="literal">a</code> label relative to the red layout (middle gray).</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong><code class="literal">to_window()</code></strong></span>: This method transforms the coordinates of the current <code class="literal">Widget</code> to<a id="id281" class="indexterm"/> absolute coordinates with respect to the window. For example, <code class="literal">a.to_window(a.x, a.y)</code> returns the absolute coordinates of <span class="strong"><strong>a</strong></span> which are<code class="literal">(100 + 5, 50 + 5) = (105, 55)</code>.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong><code class="literal">to_widget()</code></strong></span>: This <a id="id282" class="indexterm"/>method transforms the absolute coordinates to coordinates within the parent of the current widget. For example, <code class="literal">a.to_widget(105,55)</code> returns <code class="literal">(5,5)</code>, again the coordinates of <code class="literal">a</code> relative to the <code class="literal">red</code> (middle gray) layout.</li></ul></div><p>The last two methods don't use the <code class="literal">red</code> layout to transform the coordinates because in this case, Kivy assumes that the coordinates are always relative to the parent. There is also a <code class="literal">Boolean</code> parameter (called <span class="strong"><strong><code class="literal">relative</code></strong></span>), which controls whether the coordinates are relative inside the <code class="literal">Widget</code>.</p><p>Let's study a real example in the <span class="emphasis"><em>Comic Creator</em></span> project. We will add events to the <span class="emphasis"><em>tool box</em></span> buttons, so that we can add figures to the <span class="emphasis"><em>drawing space</em></span>. In this process, we will encounter a scenario in which we have to use one of the before-mentioned methods to localize our coordinates correctly to the <code class="literal">Widget</code>.</p><p>This <a id="id283" class="indexterm"/>code <a id="id284" class="indexterm"/>corresponds to the header of the <code class="literal">toolbox.py</code> file:</p><div class="informalexample"><pre class="programlisting">91. # File name: toolbox.py
92. import kivy
93.
94. import math
95. from kivy.uix.togglebutton import ToggleButton
96. from kivy.graphics import Line
97. from comicwidgets import StickMan, DraggableWidget
98.
99. class ToolButton(ToggleButton):
100.    def on_touch_down(self, touch):
101.         ds = self.parent.drawing_space
102.         if self.state == 'down' and ds.collide_point(touch.x, touch.y):
103.             (x,y) = ds.to_widget(touch.x, touch.y)
104.             self.draw(ds, x, y)
105.             return True
106.      return super(ToolButton, self).on_touch_down(touch)
107.  
108.  def draw(self, ds, x, y):
109.      pass</pre></div><p>The structure in lines 99 to 106 is already familiar. Line 102 makes sure that <code class="literal">ToolButton</code> is in the <code class="literal">'down'</code> state and that the event happened in the <code class="literal">DrawingSpace</code> instance (referenced by <code class="literal">ds</code>). Remember that the parent of <code class="literal">ToolButton</code> is <code class="literal">ToolBox</code> and that we added an attribute that references the <code class="literal">DrawingSpace</code> instance in <code class="literal">comiccreator.kv</code> at the beginning of the chapter.</p><p>The <code class="literal">draw</code> method is called in line 104. It will draw the respective shapes according to the derived classes (<code class="literal">ToolStickMan</code>, <code class="literal">ToolCircle</code>, and <code class="literal">ToolLine</code>). We need to be sure that we send the right coordinates to the <code class="literal">draw</code> method. Therefore, before calling it, we need to translate the absolute coordinates (received in <code class="literal">on_touch_down</code> of <code class="literal">ToolButton</code>) to relative coordinates (appropriated for the <span class="emphasis"><em>drawing space</em></span>) with the <code class="literal">to_widget</code> event (line 103).</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip13"/>Tip</h3><p>We know that the coordinates we received (<code class="literal">touch.x</code> and <code class="literal">touch.y</code>) are absolute because <code class="literal">ToolStickman</code> is not <code class="literal">RelativeLayout</code>, whereas the <code class="literal">DrawingSpace</code> (<code class="literal">ds</code>) is.</p></div></div><p>Let's <a id="id285" class="indexterm"/>continue<a id="id286" class="indexterm"/> studying the <code class="literal">toolbox.py</code> file and see how <code class="literal">ToolStickMan</code> actually adds <code class="literal">StickMan</code>:</p><div class="informalexample"><pre class="programlisting">110. class ToolStickman(ToolButton):
111.     def draw(self, ds, x, y):
112.         sm = StickMan(width=48, height=48)
113.         sm.center = (x,y)
114.         ds.add_widget(sm)</pre></div><p>We create an instance of <code class="literal">Stickman</code> (line 112), use the translated coordinates (line 103) to center the <code class="literal">Stickman</code>, and finally (line 119), add it to the <code class="literal">DrawingSpace</code> instance with the <span class="strong"><strong><code class="literal">add_widget</code></strong></span> method (line 114). We just need to update a few lines in <code class="literal">toolbox.kv</code> in order<a id="id287" class="indexterm"/> to run the project with new changes:</p><div class="informalexample"><pre class="programlisting">115. # File name: toolbox.kv
116. #:import toolbox toolbox
117. 
118. &lt;ToolButton&gt;:
119.    …
120. &lt;ToolBox@GridLayout&gt;:
121.     …
122.     ToolStickman:</pre></div><p>First, we need to import <code class="literal">toolbox.py</code> (line 116), then we remove <code class="literal">@ToggleButton</code> from <code class="literal">ToolButton</code> (line 118) because we added it in <code class="literal">toolbox.py</code>, and finally we replace the last <code class="literal">ToolButton</code> for our new <code class="literal">ToolStickman</code> widget (line 122). At this point, we are able to add <span class="emphasis"><em>stickmen</em></span> to the <span class="emphasis"><em>drawing space</em></span> and also drag them over it.</p><div class="mediaobject"><img src="images/B04244_03_05.jpg" alt="Localizing coordinates – adding stickmen"/></div><p>We have covered the basics now, so let's learn how to bind and unbind events dynamically.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Binding and unbinding events – sizing limbs and heads"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec25"/>Binding and unbinding events – sizing limbs and heads</h1></div></div></div><p>In<a id="id288" class="indexterm"/> the <a id="id289" class="indexterm"/>previous two sections, we override basic events to perform actions we want. In this section, you will learn how to bind and unbind events dynamically. It was quite an easy job to add our <code class="literal">Stickman</code> because it is a <code class="literal">Widget</code> already, but what about the graphics, the circle, and the rectangle? We could create some widgets for them, just as we did with the <code class="literal">Stickman</code>, but let's attempt something braver before that. Instead of just clicking on the <span class="emphasis"><em>drawing space</em></span>, let's drag the mouse on its border to decide the size of the circle or line:</p><div class="mediaobject"><img src="images/B04244_03_06.jpg" alt="Binding and unbinding events – sizing limbs and heads"/><div class="caption"><p>Using mouse to set the size</p></div></div><p>Once we finish the dragging (and we are satisfied with the size), let's dynamically create <code class="literal">DraggableWidget</code> that will contain the shape, so we can also drag them over the <code class="literal">DrawingSpace</code> instance. The following class diagram will help us understand the whole inheritance structure of the <code class="literal">toolbox.py</code> file:</p><div class="mediaobject"><img src="images/B04244_03_07.jpg" alt="Binding and unbinding events – sizing limbs and heads"/></div><p>The <a id="id290" class="indexterm"/>diagram<a id="id291" class="indexterm"/> includes <code class="literal">ToolButton</code> and <code class="literal">ToolsStickman</code>, which were explained in the last section, but it also includes three new classes called <code class="literal">ToolFigure</code>, <code class="literal">ToolLine</code>, and <code class="literal">ToolCircle</code>.</p><p>The <code class="literal">ToolFigure</code> class has six methods. Let's start with a quick overview of these methods and then highlight the important and new parts:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem"><code class="literal">draw</code>: This<a id="id292" class="indexterm"/> method overrides <code class="literal">draw</code> of <code class="literal">ToolButton</code> (lines 108 and 109). The position where we touch down indicates the starting point of our figure, either the center for a circle or one of the ends of a line.<div class="informalexample"><pre class="programlisting">123. class ToolFigure(ToolButton):
124.     def draw(self, ds, x, y):
125.         (self.ix, self.iy) = (x,y)
126.         with ds.canvas:
127.             self.figure=self.create_figure(x,y,x+1,y+1)
128.         ds.bind(on_touch_move=self.update_figure)
129.         ds.bind(on_touch_up=self.end_figure)</pre></div></li><li class="listitem"><code class="literal">update_figure</code>: This method updates the end-point of the figure when we drag. Either<a id="id293" class="indexterm"/> the end of a line or the radius (distance from the starting point to the end point) of the circle.<div class="informalexample"><pre class="programlisting">130.     def update_figure(self, ds, touch):
131.         if ds.collide_point(touch.x, touch.y):
132.             (x,y) = ds.to_widget(touch.x, touch.y)
133.             ds.canvas.remove(self.figure)
134.             with ds.canvas:
135.                 self.figure = self.create_figure(self.ix, self.iy,x,y)</pre></div></li><li class="listitem"><code class="literal">end_figure</code>: This method<a id="id294" class="indexterm"/> indicates the final end point of the <a id="id295" class="indexterm"/>figure with the same logic as in <code class="literal">update_figure</code>. Also, we <a id="id296" class="indexterm"/>put the final figure inside <code class="literal">DraggableWidget</code> (see <code class="literal">widgetize</code>).<div class="informalexample"><pre class="programlisting">136.     def end_figure(self, ds, touch):
137.         ds.unbind(on_touch_move=self.update_figure)
138.         ds.unbind(on_touch_up=self.end_figure)
139.         ds.canvas.remove(self.figure)
140.         (fx,fy) = ds.to_widget(touch.x, touch.y)
141.         self.widgetize(ds,self.ix,self.iy,fx,fy)</pre></div></li><li class="listitem"><code class="literal">widgetize</code>: This method creates <code class="literal">DraggableWidget</code> and places the figure in it. It uses four <a id="id297" class="indexterm"/>coordinates that have to be localized correctly with the localization methods:<div class="informalexample"><pre class="programlisting">142.     def widgetize(self,ds,ix,iy,fx,fy):
143.         widget = self.create_widget(ix,iy,fx,fy)
144.         (ix,iy) = widget.to_local(ix,iy,relative=True)
145.         (fx,fy) = widget.to_local(fx,fy,relative=True)
146.         widget.canvas.add( self.create_figure(ix,iy,fx,fy))
147.         ds.add_widget(widget)</pre></div></li><li class="listitem"><code class="literal">create_figure</code>: This method will be<a id="id298" class="indexterm"/> overridden by <code class="literal">ToolLine</code> (lines 153 and 154) and <code class="literal">ToolCircle</code> (lines 162 to 163). It creates the respective figure, given four coordinates:<div class="informalexample"><pre class="programlisting">148.     def create_figure(self,ix,iy,fx,fy):
149.         pass</pre></div></li><li class="listitem"><code class="literal">create_widget</code>: This method is also overridden <a id="id299" class="indexterm"/>by <code class="literal">ToolLine</code> (lines 156 to 159) and <code class="literal">ToolCircle</code> (lines 165 to 169). It creates a respectively positioned and sized <code class="literal">DraggableWidget</code> given four coordinates.<div class="informalexample"><pre class="programlisting">150.     def create_widget(self,ix,iy,fx,fy):
151.         pass </pre></div></li></ol></div><p>Most of the statements from the preceding methods have already been covered. The new topic of this <a id="id300" class="indexterm"/>code is the dynamic <span class="strong"><strong><code class="literal">bind</code></strong></span>/<span class="strong"><strong><code class="literal">unbind</code></strong></span> of events. The main problem we needed to solve is that we didn't want the <code class="literal">on_touch_move</code> and <code class="literal">on_touch_up</code> events active all the time. We needed to activate them (<span class="strong"><strong><code class="literal">bind</code></strong></span>) from the moment the user starts drawing (<code class="literal">on_touch_down</code> of <code class="literal">ToolButton</code> that calls on the method <code class="literal">draw</code>) until the user decides the size and does a touch up. Therefore, we bound <code class="literal">update_figure</code> and <code class="literal">end_figure</code>, respectively, to the <code class="literal">on_touch_move</code> and <code class="literal">on_touch_up</code> events of <code class="literal">DrawingSpace</code> when the method <code class="literal">draw</code> is called on (lines 128 and 129). Also, we unbound them when the user ends the figure on method <code class="literal">end_figure</code> (lines 137 and 138). Notice that we can unbind the <a id="id301" class="indexterm"/>same method that is being executed (<code class="literal">end_figure</code>) from <a id="id302" class="indexterm"/>the <code class="literal">on_touch_up</code> event. We want to avoid calling the methods <code class="literal">update_figure</code> and <code class="literal">end_figure</code> unnecessarily. With this approach, they are going to be called only when the figure is drawn for the first time.</p><p>There are a few other interesting things in this code that deserve some attention. In line 125, we created two class attributes (<code class="literal">self.ix</code> and <code class="literal">self.iy</code>) to keep the coordinates of the initial touch. We use those coordinates each time we update the figure (line 135) and when we put the figure into a <code class="literal">Widget</code> (line 141).</p><p>We also use some of the localizing methods that we covered in the previous section. In lines 132 and 140, we used <code class="literal">to_widget</code> to translate the coordinates to the <code class="literal">DrawingSpace</code> instance. The lines 144 and 145 use <code class="literal">to_local</code> to translate the coordinates to <code class="literal">DraggableWidget</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note23"/>Note</h3><p>
<code class="literal">DraggableWidget</code> is instructed to translate the coordinates to its inner relative <a id="id303" class="indexterm"/>space with the parameter <span class="strong"><strong><code class="literal">relative</code></strong></span><code class="literal">=True</code> because <code class="literal">DraggableWidget</code> is relative and we are trying to draw inside it (not inside the parent: the <span class="emphasis"><em>drawing space</em></span>).</p></div></div><p>There is some basic math involved in the calculation of the position and sizes of the figures and widgets. We have intentionally moved it to the deeper classes of the inheritance: <code class="literal">ToolLine</code> and <code class="literal">ToolCircle</code>. The following is their code, the last part of <code class="literal">toolbox.py</code>:</p><div class="informalexample"><pre class="programlisting">152. class ToolLine(ToolFigure):
153.     def create_figure(self,ix,iy,fx,fy):
154.         return Line(points=[ix, iy, fx, fy])
155. 
156.     def create_widget(self,ix,iy,fx,fy):
157.         pos = (min(ix, fx), min(iy, fy)) 
158.         size = (abs(fx-ix), abs(fy-iy))
159.         return DraggableWidget(pos = pos, size = size)
160. 
161. class ToolCircle(ToolFigure):
162.     def create_figure(self,ix,iy,fx,fy):
163.         return Line(circle=[ix,iy,math.hypot(ix-fx,iy-fy)])
164. 
165.     def create_widget(self,ix,iy,fx,fy):
166.         r = math.hypot(ix-fx, iy-fy)
167.         pos = (ix-r, iy-r)
168.         size = (2*r, 2*r)
169.         return DraggableWidget(pos = pos, size = size)</pre></div><p>The<a id="id304" class="indexterm"/> math<a id="id305" class="indexterm"/> involves concepts of geometry that escape the scope of this book. It is important to understand that the methods of this code section adapts the calculations to create either lines or circles. Finally, we apply some changes to the <code class="literal">ToolBox</code> class in <code class="literal">toolbox.kv</code>:</p><div class="informalexample"><pre class="programlisting">170. # File name: toolbox.kv
171. ...
172. 
173. &lt;ToolBox@GridLayout&gt;:
174.     cols: 2
175.    padding: 2
176.    tool_circle: _tool_circle
177.    tool_line: _tool_line
178.    tool_stickman: _tool_stickman
179.    ToolCircle:
180.        id:  _tool_circle
181.        canvas:
182.            Line:
183.                circle: 24,24,14
184.    ToolLine:
185.        id: _tool_line
186.        canvas:
187.            Line:
188.                points: 10,10,38,38
189.    ToolStickman:
190.        id: _tool_stickman
191.        StickMan:
192.            pos_hint: {'center_x':.5,'center_y':.5}</pre></div><p>The new classes <code class="literal">ToolCircle</code> (line 179), <code class="literal">ToolLine</code> (line 184), and <code class="literal">ToolStickMan</code> (line 189) have replaced the previous <code class="literal">ToolButton</code> instances. Now, we can also add and scale lines and circles to the <span class="emphasis"><em>drawing space</em></span>:</p><div class="mediaobject"><img src="images/B04244_03_08.jpg" alt="Binding and unbinding events – sizing limbs and heads"/></div><p>We also <a id="id306" class="indexterm"/>created <a id="id307" class="indexterm"/>some attributes (lines 176, 177, and 178) that will be useful in <a class="link" href="ch04.html" title="Chapter 4. Improving the User Experience">Chapter 4</a>, <span class="emphasis"><em>Improving the User Experience</em></span>, when we use gestures to create figures.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Binding events in the Kivy language"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec26"/>Binding events in the Kivy language</h1></div></div></div><p>So far, we <a id="id308" class="indexterm"/>have been handling events in two ways: overridding<a id="id309" class="indexterm"/> an event method (for example, <code class="literal">on_touch_event</code>) and binding a personalize method to a related event method (for example, <code class="literal">ds.bind(on_touch_move=self.update_figure)</code>). In this section, we will discuss a different way, that is, binding events in the Kivy language. Potentially, we could have done this since the beginning of this chapter when we started working with <code class="literal">DraggableWidget</code> but there is a difference. If we use the Kivy language, we can easily add the event to a specific instance and not to all the instances of the same class. In this sense, it resembles dinamically binding an instance to its callback with the <code class="literal">bind</code> method.</p><p>We are going to concentrate on new events specific to <code class="literal">Button</code> and <code class="literal">ToggleButton</code>. The following is the code for <code class="literal">generaloption.kv</code>:</p><div class="informalexample"><pre class="programlisting">193. # File name: generaloptions.kv
194. #:import generaloptions generaloptions
195. &lt;GeneralOptions&gt;:
196.    orientation: 'horizontal'
197.    padding: 2
198.    Button:
199.        text: 'Clear'
200.        on_press: root.clear(*args)
201.    Button:
202.        text: 'Remove'
203.        on_release: root.remove(*args)
204.    ToggleButton:
205.        text: 'Group'
206.        on_state: root.group(*args)
207.    Button:
208.        text: 'Color'
209.        on_press: root.color(*args)
210.    ToggleButton:
211.        text: 'Gestures'
212.        on_state: root.gestures(*args)</pre></div><p>The <code class="literal">Button</code> class has<a id="id310" class="indexterm"/> two extra events: <span class="strong"><strong><code class="literal">on_press</code></strong></span> and <span class="strong"><strong><code class="literal">on_release</code></strong></span>. The<a id="id311" class="indexterm"/> former is similar to <code class="literal">on_touch_down</code> and<a id="id312" class="indexterm"/> the latter is similar to <code class="literal">on_touch_up</code>. However, in<a id="id313" class="indexterm"/> this case, we don't need to worry about calling the <code class="literal">collide_point</code> method. We used <code class="literal">on_press</code> for the <span class="strong"><strong>Clear</strong></span> <code class="literal">Button</code> (line 200) and the <span class="strong"><strong>Color</strong></span> <code class="literal">Button</code> (line 209) and <code class="literal">on_release</code> for the <span class="strong"><strong>Remove</strong></span> <code class="literal">Button</code> (line 203) to illustrate both methods, but for this <a id="id314" class="indexterm"/>particular case, it does not really matter which one we pick. The <span class="strong"><strong><code class="literal">on_state</code></strong></span> event is already a part of the <code class="literal">Button</code> class, although more commonly used in the ToggleButton instances. This event is triggered every time the state of <code class="literal">ToogleButton</code> changes from <code class="literal">'normal'</code> to <code class="literal">'down'</code> and vice versa. The <span class="strong"><strong><code class="literal">on_state</code></strong></span> event is used in lines 206 and 212. All the events are bound to methods in the root, which are defined in the <code class="literal">generaloptions.py</code> file:</p><div class="informalexample"><pre class="programlisting">213. # File name: generaloptions.py
214. from kivy.uix.boxlayout import BoxLayout
215. from kivy.properties import NumericProperty, ListProperty
216.
217. class GeneralOptions(BoxLayout):
218.    group_mode = False
219.    translation = ListProperty(None)
220.
221.    def clear(self, instance):
222.        self.drawing_space.clear_widgets()
223.
224.    def remove(self, instance):
225.        ds = self.drawing_space
226.        if len(ds.children) &gt; 0:
227.            ds.remove_widget(ds.children[0])
228.
229.    def group(self, instance, value):
230.        if value == 'down':
231.            self.group_mode = True
232.        else:
233.            self.group_mode = False
234.            self.unselect_all()
235.
236.    def color(self, instance):
237.        pass
238.
239.    def gestures(self, instance, value):
240.        pass
241.
242.    def unselect_all(self):
243.         for child in self.drawing_space.children:
244.             child.unselect()
245.
246.    def on_translation(self,instance,value):
247.        for child in self.drawing_space.children:
248.            if child.selected:
249.                child.translate(*self.translation)</pre></div><p>The <a id="id315" class="indexterm"/>
<code class="literal">GeneralOptions</code> method illustrates a few other<a id="id316" class="indexterm"/> methods of the <code class="literal">Widget</code> class. The <code class="literal">clear</code> method removes all the widgets from the <code class="literal">DrawingSpace</code> instance through the <span class="strong"><strong><code class="literal">clear_widgets</code></strong></span> method (line 222). The <a id="id317" class="indexterm"/>following screenshot show the result of clicking on it:</p><div class="mediaobject"><img src="images/B04244_03_09.jpg" alt="Binding events in the Kivy language"/></div><p>The <span class="strong"><strong><code class="literal">remove_widget</code></strong></span> method<a id="id318" class="indexterm"/> removes the last added <code class="literal">Widget</code> instance accessing the <span class="strong"><strong><code class="literal">children</code></strong></span> list (line 227). The <code class="literal">group</code> method modifies the <code class="literal">group_mode</code> attribute of line 218 according to the <code class="literal">'down'</code> or <code class="literal">'normal'</code> <code class="literal">ToggleButton</code> state. The <code class="literal">color</code> and <code class="literal">gestures</code> methods will be completed in <a class="link" href="ch04.html" title="Chapter 4. Improving the User Experience">Chapter 4</a>, <span class="emphasis"><em>Improving the User Experience</em></span>.</p><p>The <span class="emphasis"><em>group mode</em></span> will allow the user to select several <code class="literal">DraggableWidget</code> instances in order to drag them at the same time. We activated or deactivated the <span class="emphasis"><em>group mode</em></span> according to the state of the <code class="literal">ToggleButton</code>. In the next section, we will actually allow multiple selections and dragging in the <code class="literal">DraggableWidget</code> class. For now, we will just get the controls ready with the <code class="literal">unselect_all</code> and <code class="literal">on_translation</code> methods.</p><p>When<a id="id319" class="indexterm"/> the <span class="emphasis"><em>group mode</em></span> is deactivated, we make sure that<a id="id320" class="indexterm"/> all the selected widgets are unselected, by calling the <code class="literal">unselect_all</code> method (line 242). The <code class="literal">unselect_all</code> method traverses the list of children calling the internal method <code class="literal">unselect</code> of each <code class="literal">DraggableWidget</code> (line 79).</p><p>Lastly, the <code class="literal">on_translation</code> method also traverses the children list calling the internal <code class="literal">translate</code> method (line 71) of each <code class="literal">DraggableWidget</code>. The question is; what calls the <code class="literal">on_translation</code> method? One of the most useful features of Kivy provides the answer to this question; this will be explained in the next section.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Creating your own events – the magical properties"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec27"/>Creating your own events – the magical properties</h1></div></div></div><p>This <a id="id321" class="indexterm"/>section covers the use of the Kivy properties. A Kivy property triggers an event every time we modify it. There are different types of properties, from<a id="id322" class="indexterm"/> the simple <span class="strong"><strong><code class="literal">NumericProperty</code></strong></span> or <span class="strong"><strong><code class="literal">StringProperty</code></strong></span> to<a id="id323" class="indexterm"/> much <a id="id324" class="indexterm"/>more complex<a id="id325" class="indexterm"/> versions such as <span class="strong"><strong><code class="literal">ListProperty</code></strong></span>, <span class="strong"><strong><code class="literal">DictProperty</code></strong></span>, or <span class="strong"><strong><code class="literal">ObjectProperty</code></strong></span>. For <a id="id326" class="indexterm"/>example, if we define a <span class="strong"><strong><code class="literal">StringProperty</code></strong></span> called <code class="literal">text</code>, then an <code class="literal">on_text</code> event is going to be triggered each time the text is modified.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note24"/>Note</h3><p>Once we define a Kivy property, Kivy internally creates an event associated with that property. The property event is referenced adding the prefix <code class="literal">on_</code> to the name of the property. For example, the <code class="literal">on_translation</code> method (line 246) is associated with <code class="literal">ListProperty</code> in line 219 called <code class="literal">translation</code>.</p></div></div><p>All the properties work in the same way. For example, the <code class="literal">state</code> property that we used in the <code class="literal">ToogleButton</code> class is actually a property that creates the <code class="literal">on_state</code> event. We already used this event in line 206. We define the property and Kivy creates the event for us.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note25"/>Note</h3><p>In the context <a id="id327" class="indexterm"/>of this book, a <span class="strong"><strong>property</strong></span> will always refer to a Kivy property and it should not be confused with a Python property, which is a different concept not covered in this book. An <span class="strong"><strong>attribute</strong></span> is used to describe variables (references, objects, and instances) that belong to the class. As a general<a id="id328" class="indexterm"/> rule, a Kivy property is always an attribute but an attribute is not necessarily a Kivy property.</p></div></div><p>In this section, we implement <span class="emphasis"><em>group mode</em></span>, which offers the possibility of selecting and dragging several figures (<code class="literal">DraggableWidgets</code> instances) at the same time by pressing the <span class="strong"><strong>Group</strong></span> button (line 204). In order to do this, we can take advantage of the relation between the <code class="literal">translation</code> property and the <code class="literal">on_translation</code> method. Basically, every time we <a id="id329" class="indexterm"/>modify the <code class="literal">translation</code> property, the <code class="literal">on_translation</code> event is triggered. Say that we drag three figures at the same time (with the <span class="emphasis"><em>group mode</em></span>) as shown in the following screenshot:</p><div class="mediaobject"><img src="images/B04244_03_10.jpg" alt="Creating your own events – the magical properties"/></div><p>The three figures are selected but the events are handled by the circle, since it is the one that has the pointer on top. The circle needs to tell the line and the stickman to translate. Instead of calling the <code class="literal">on_translation</code> method, it only needs to modify the <code class="literal">translation</code> property, and the <code class="literal">on_translation</code> event is triggered. Let's include these changes in <code class="literal">comicwidgets.py</code>. We need four modifications.</p><p>First, we need to add the <code class="literal">touched</code> attribute (line 252) to indicate which of the selected figures receives the event (for example, the circle in the previous screenshot). We do this in the constructor:</p><div class="informalexample"><pre class="programlisting">250. def __init__(self,  **kwargs):
251.    self.selected = None
252.    self.touched = False
253.    super(DraggableWidget, self).__init__(**kwargs)</pre></div><p>Second, we need to set the <code class="literal">touched</code> attribute to <code class="literal">True</code> (line 256) when one of the <code class="literal">DraggableWidget</code> instances receives the event. We do this in the <code class="literal">on_touch_down</code> method:</p><div class="informalexample"><pre class="programlisting">254. def on_touch_down(self, touch):
255.    if self.collide_point(touch.x, touch.y):
256.        self.touched = True
257.        self.select()
258.        return True
259.    return super(DraggableWidget, self).on_touch_down(touch)</pre></div><p>Third, we<a id="id330" class="indexterm"/> need to check that <code class="literal">DraggableWidget</code> is the one that is currently being touched (received the <code class="literal">on_touch_down</code> event previously). We add this to the condition in line 262. The most important change is in line 264. Instead of calling the <code class="literal">translate</code> method directly, we modify the <code class="literal">translation</code> property of <span class="emphasis"><em>general options</em></span> (<code class="literal">self.parent.general_options</code>) setting the number of pixels the widget has been translated to the property. This will trigger the <code class="literal">on_translation</code> method of <code class="literal">GeneralOptions</code>, which at the same time calls the <code class="literal">translate</code> method for each selected <code class="literal">DraggableWidget</code>. This is the resulting code for <code class="literal">on_touch_move</code>:</p><div class="informalexample"><pre class="programlisting">260. def on_touch_move(self, touch):
261.    (x,y) = self.parent.to_parent(touch.x, touch.y)
262.    if self.selected and self.touched and self.parent.collide_point(x - self.width/2, y -self.height/2):
263.        go = self.parent.general_options
264.        go.translation=(touch.x-self.ix,touch.y-self.iy)
265.        return True
266.    return super(DraggableWidget, self).on_touch_move(touch)</pre></div><p>Fourth, we need to set the <code class="literal">touched</code> attribute to <code class="literal">False</code> (line 268) on the <code class="literal">on_touch_up</code> event, and also avoid calling the <code class="literal">unselect</code> method when we use <code class="literal">group_mode</code> (line 270). Here is the code for the <code class="literal">on_touch_up</code> method:</p><div class="informalexample"><pre class="programlisting">267. def on_touch_up(self, touch):
268.    self.touched = False
269.    if self.selected:
270.        if not self.parent.general_options.group_mode:
271.            self.unselect()
272.    return super(DraggableWidget, self).on_touch_up(touch) </pre></div><p>This example could be considered artificial, since we theoretically could have called the <code class="literal">on_translation</code> method from the start. However, properties are crucial in order to keep consistency of the internal state of a variable and the screen display. The example from the next section will improve your understanding of this.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Kivy and its properties"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec28"/>Kivy and its properties</h1></div></div></div><p>Even though<a id="id331" class="indexterm"/> we <a id="id332" class="indexterm"/>have only touched upon explanations of properties in the previous section, the truth is that we have been using them since the beginning of this chapter. Kivy's internals are full of properties. They are almost everywhere. For example, when we implemented <code class="literal">DraggableWidget</code>, we simply modified the <code class="literal">center_x</code> property (line 72 and 73), and the whole <code class="literal">Widget</code> was then kept updated because there is a chain of properties involved in the use of <code class="literal">center_x</code>.</p><p>The last example in this chapter illustrates how powerful Kivy properties are. Here is the code for <code class="literal">statusbar.py</code>:</p><div class="informalexample"><pre class="programlisting">273. # File name: statusbar.py
274. from kivy.uix.boxlayout import BoxLayout
275. from kivy.properties import NumericProperty, ObjectProperty
276.
277. class StatusBar(BoxLayout):
278.    counter = NumericProperty(0)
279.    previous_counter = 0
280.
281.    def on_counter(self, instance, value):
282.        if value == 0:
283.            self.msg_label.text="Drawing space cleared"
284.        elif value - 1 == self.__class__.previous_counter:
285.            self.msg_label.text = "Widget added" 286.        elif value + 1 == StatusBar.previous_counter:
287.            self.msg_label.text = "Widget removed"
288.        self.__class__.previous_counter = value</pre></div><p>The way Kivy properties work can be perceived as confusing by some advanced Python or Java programmers. The confusion happens when a programmer assumes that <code class="literal">counter</code> (line 278) is a static attribute of the <code class="literal">StatusBar</code> class because <code class="literal">counter</code> is defined in an equivalent way to the Python static attributes (for example, <code class="literal">previous_counter</code> in line 279). The assumption is incorrect.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note26"/>Note</h3><p>Kivy properties are declared as static attribute classes (since they belong to the class), but they are always internally transformed to attribute instances. They actually belong to the object as we would have declared them in the constructor.</p></div></div><p>We need to distinguish between a static attribute of a class and an attribute of a class instance. In Python, <code class="literal">previous_counter</code> (line 279) is a static attribute of the <code class="literal">StatusBar</code> class. This means that it is shared among all the <code class="literal">StatusBar</code> instances, and it can be accessed in any of the ways shown in lines 284 and 286 (however, line 284 is recommended because it is independent of the class name). In contrast, the <code class="literal">selected</code> variable (line 251) is an attribute of a <code class="literal">DraggableWidget</code> instance. This means that there is a <code class="literal">selected</code> variable per <code class="literal">StatusBar</code> object. It is not shared among them. They are created until the constructor (<code class="literal">__init__</code>) is called. The only way to access it is through <code class="literal">obj.selected</code> (line 251). The <code class="literal">counter</code> property (line 278) behaves more similarly to the <code class="literal">selected</code> attribute than to the <code class="literal">previous_counter</code> static attribute, in the sense that there is one <code class="literal">counter</code> property and one <code class="literal">selected</code> attribute in each instance.</p><p>Now that this has been clarified, we <a id="id333" class="indexterm"/>can move <a id="id334" class="indexterm"/>on to study the example. The <code class="literal">counter</code> is defined as <code class="literal">NumericProperty</code> in line 278. It corresponds to the <code class="literal">on_counter</code> method (line 281) and modifies <code class="literal">Label</code> (<code class="literal">msg_text</code>) defined in the <code class="literal">statusbar.kv</code> file:</p><div class="informalexample"><pre class="programlisting">289. # File name: statusbar.kv
290. #:import statusbar statusbar
291. &lt;StatusBar&gt;:
292.    msg_text: _msg_label
293.    orientation: 'horizontal'
294.    Label:
295.         text: 'Total Figures: ' + str(root.counter)
296.     Label:
297.         id: _msg_label
298.         text: "Kivy started"</pre></div><p>Note that we use <code class="literal">id</code> (line 297) again in order to define <code class="literal">msg_text</code> (line 292). Also, we use <code class="literal">counter</code> defined in line 278 to update the <span class="strong"><strong>Total Figures</strong></span> message in line 295. The specific part (<code class="literal">str(root.counter)</code>) of <code class="literal">text</code> is updated automatically when <code class="literal">counter</code> is modified.</p><p>So, we just need to modify the <code class="literal">counter</code> property, and the interface is updated automatically. Let's update the counter in <code class="literal">drawingspace.py</code>:</p><div class="informalexample"><pre class="programlisting">299. # File name: drawingspace.py
300. from kivy.uix.relativelayout import RelativeLayout
301. 
302. class DrawingSpace(RelativeLayout):
303.     def on_children(self, instance, value):
304.         self.status_bar.counter = len(self.children)</pre></div><p>We updated <code class="literal">counter</code> with the length of <code class="literal">children</code> of the <code class="literal">DrawingSpace</code> in the method <code class="literal">on_children</code>. Then, <code class="literal">on_children</code> is called every time we add (line 114 or 147) or remove (line 222 or 227) widgets from the <code class="literal">children</code> list of the <code class="literal">DrawingSpace</code> because <code class="literal">children</code> is also a Kivy property.</p><p>Don't forget to import this file into <code class="literal">drawingspace.py</code> in the <code class="literal">drawingspace.kv</code> file, in which we also removed the border of the <span class="emphasis"><em>drawing space</em></span>:</p><div class="informalexample"><pre class="programlisting">305. # File name: drawingspace.kv
306. #:import drawingspace drawingspace
307. &lt;DrawingSpace@RelativeLayout&gt;:</pre></div><p>The following diagram shows a chain of elements (properties, methods, and widgets) that are associated with the <code class="literal">children</code> property:</p><div class="mediaobject"><img src="images/B04244_03_11.jpg" alt="Kivy and its properties"/></div><p>It is<a id="id335" class="indexterm"/> important <a id="id336" class="indexterm"/>to compare again the way we gain access to the <code class="literal">counter</code> property and the <code class="literal">msg_label</code> attribute. We defined the <code class="literal">counter</code> property in the <code class="literal">StatusBar</code> (line 278) and used it in <code class="literal">Label</code> through the <code class="literal">root</code> (line 295). In the <code class="literal">msg_label</code> case, we started defining <code class="literal">id</code> (line 297) and then the attribute of the Kivy language (line 292). Then, we were able used msg_label in the Python code (lines 283, 285 and 287)</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note27"/>Note</h3><p>Remember that an attribute is not necessarily a Kivy property. An attribute is an element of the class, whereas a Kivy property also associates the attribute with an event.</p></div></div><p>You can find the<a id="id337" class="indexterm"/> complete list of available properties in the Kivy API (<a class="ulink" href="http://kivy.org/docs/api-kivy.properties.html">http://kivy.org/docs/api-kivy.properties.html</a>). There are two specific properties<a id="id338" class="indexterm"/> that<a id="id339" class="indexterm"/> should at least be mentioned: <span class="strong"><strong><code class="literal">BoundedNumericProperty</code></strong></span> and <span class="strong"><strong><code class="literal">AliasProperty</code></strong></span>. The <span class="strong"><strong><code class="literal">BoundedNumericProperty</code></strong></span> property allows the setting of the maximum and minimum values. If the value is beyond the range, an <code class="literal">Exception</code> is thrown. The <span class="strong"><strong><code class="literal">AliasProperty</code></strong></span> property<a id="id340" class="indexterm"/> offers a way in which we can extend the properties; it allows us to create our own properties in case the necessary property does not exist.</p><p>One last thing that deserves attention is that attributes of the vertex instructions are used as properties when we create them with the Kivy language. For example, if we change the <a id="id341" class="indexterm"/>position <a id="id342" class="indexterm"/>of the line inside <code class="literal">ToolLine</code>, it will be updated automatically. However, this just applies inside the Kivy language, not when we add the vertex instructions dynamically, as we did in <code class="literal">toolbox.py</code>. In our case, we had to remove and create a new vertex instruction every time we needed to update the figures (lines 133 to 135). However, we could have created our own properties to handle the updates. An example will be offered in <a class="link" href="ch06.html" title="Chapter 6. Kivy Player – a TED Video Streamer">Chapter 6</a>, <span class="emphasis"><em>Kivy Player – a TED Video Streamer</em></span>, when we add subtitles to the videos.</p><p>Let's run the code one last time to see the final result with the status bar counting figures and indicating our last action:</p><div class="mediaobject"><img src="images/B04244_03_12.jpg" alt="Kivy and its properties"/></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec29"/>Summary</h1></div></div></div><p>We covered most of the topics related to event handling in this chapter. You learned how to override different kind of events, dynamic binding and unbinding, assigning events in the Kivy language, and creating our own. You also learned about Kivy properties, how to manage the localization of coordinates to different widgets, and many methods related to adding, removing, and updating objects of <code class="literal">Kivy</code> <code class="literal">Widget</code> and <code class="literal">canvas</code>. Here are the events, methods, properties, and attributes that were covered:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The events we covered are <code class="literal">on_touch_up</code>, <code class="literal">on_touch_move</code> and <code class="literal">on_touch_down</code> (of <code class="literal">Widget</code>); <code class="literal">on_press</code> and <code class="literal">on_release</code> (of <code class="literal">Button</code>); and <code class="literal">on_state</code> (of <code class="literal">ToggleButton</code>)</li><li class="listitem" style="list-style-type: disc">The attributes we covered are x and y of <code class="literal">MotionEvent</code> (<code class="literal">touch</code>); <code class="literal">center_x</code>, <code class="literal">center_y</code>, <code class="literal">canvas</code>, <code class="literal">parent</code>, and <code class="literal">children</code> of <code class="literal">Widget</code>, and <code class="literal">state</code> of <code class="literal">ToggleButton</code>.</li><li class="listitem" style="list-style-type: disc">The following methods of <code class="literal">Widget</code>:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">bind</code> and <code class="literal">unbind</code> to attach events dynamically</li><li class="listitem" style="list-style-type: disc"><code class="literal">collide_points</code>, <code class="literal">to_parent</code>, <code class="literal">to_local</code>, <code class="literal">to_window</code>, and <code class="literal">to_widget</code> to work with coordinates</li><li class="listitem" style="list-style-type: disc"><code class="literal">add_widget</code>, <code class="literal">remove_widget</code>, and <code class="literal">clear_widgets</code> to dynamically modify the children widgets</li><li class="listitem" style="list-style-type: disc">The methods <code class="literal">add</code> and <code class="literal">remove</code> of canvas to dynamically add and remove vertex and context instructions</li></ul></div></li><li class="listitem" style="list-style-type: disc">Kivy properties: <code class="literal">NumericProperty</code> and <code class="literal">ListProperty</code></li></ul></div><p>There are two other important types of events related to the clock and keyboard. This chapter was focused on widget and property events but we will see how to use other events in <a class="link" href="ch05.html" title="Chapter 5. Invaders Revenge – an Interactive Multi-touch Game">Chapter 5</a>, <span class="emphasis"><em>Invaders Revenge – an Interactive Multi-touch Game</em></span>. The next chapter is going to introduce a list of interesting topics on Kivy in order to improve the user experience with our <span class="emphasis"><em>Comic Creator</em></span>.</p></div></div>
</body></html>