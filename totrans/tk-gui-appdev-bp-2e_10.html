<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Miscellaneous Tips</h1>
                </header>
            
            <article>
                
<p class="mce-root">We have reached the final chapter of this book. Let's end our discussion on Tkinter by looking at some concepts that, though very common in many <strong>graphical user interface</strong> (<strong>GUI</strong>) programs, did not appear in the previous chapters.</p>
<p class="mce-root">We will cover the following in this chapter:</p>
<ul>
<li class="mce-root">Tracing Tkinter variables and attaching callbacks that are triggered when the value of a variable changes</li>
<li class="mce-root">Understanding the default keyboard widget traversal rules to provide a consistent user experience</li>
<li class="mce-root">Validating user inputs using built-in Tkinter mechanisms</li>
<li class="mce-root">Formatting a widget's content as the user interacts with the widget</li>
<li class="mce-root">Understanding how Tkinter handles fonts and the best practices involved in using custom fonts in Tkinter</li>
<li class="mce-root">Redirecting the command-line output to Tkinter</li>
<li class="mce-root">Taking a look at the source code of Tkinter to understand class hierarchy</li>
<li class="mce-root">Highlighting some current best practices involved in program design and implementation</li>
<li class="mce-root">Getting an insight into code cleanup and program optimization</li>
<li class="mce-root">Distributing Tkinter applications as standalone programs to end users</li>
<li>Understanding the limitations of Tkinter</li>
<li>Exploring alternatives to Tkinter and understanding when it is better to use them instead of Tkinter and the tradeoffs involved</li>
<li>Backporting Tkinter programs are written in Python 3.x versions to older Python 2.x versions</li>
</ul>
<p>Let's begin!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Tracing Tkinter variables</h1>
                </header>
            
            <article>
                
<p>When you specify a Tkinter variable, such as <kbd>textvariable</kbd>, for a widget (<kbd>textvariable = myvar</kbd>), the widget automatically gets updated whenever the value of the variable changes. However, there might be times when, in addition to updating the widget, you need to do some extra processing at the time of reading or writing (or modifying) the variable.</p>
<p>Tkinter provides a method to attach a callback method that will be triggered every time the value of a variable is accessed. Thus, the callback acts as a variable observer. </p>
<p>The callback creation method is named <kbd>trace_variable(self, mode, callback)</kbd> or simply <kbd>trace(self, mode, callback)</kbd>.</p>
<p>The mode argument can take a value of <kbd>r</kbd>, <kbd>w</kbd>, or <kbd>u</kbd>, which stand for <em>read</em>, <em>write</em>, or <em>undefined</em>. Depending upon the mode specifications, the callback method is triggered when the variable is read or written.</p>
<p>By default, the callback method gets three arguments. The arguments, in order of their position, are as follows:</p>
<ul>
<li>The name of the Tkinter variable</li>
<li>The index of the variable in case the Tkinter variable is an array, otherwise, it's an empty string</li>
<li>The access modes (<kbd>r</kbd>, <kbd>w</kbd>, or <kbd>u</kbd>)</li>
</ul>
<p>Note that the triggered callback function may also modify the value of the variable. However, this modification does not trigger additional callbacks. </p>
<p>Let's look at an example of variable tracing in Tkinter. Take a look at how a change in a traced Tkinter variable triggers a callback (see code <kbd>10.01_trace_variable.py</kbd>):</p>
<pre>from tkinter import Tk, Label, Entry, StringVar<br/>root = Tk()<br/>my_variable = StringVar()  <br/><br/>def trace_when_my_variable_written(var, indx, mode):<br/>   print ("Traced variable {}".format(my_variable.get()))<br/><br/>my_variable.trace_variable("w", trace_when_my_variable_written)<br/><br/>Label(root, textvariable = my_variable).pack(padx=5, pady=5)<br/>Entry(root, textvariable = my_variable).pack(padx=5, pady=5)<br/><br/>root.mainloop()</pre>
<p>The following line of code attaches a callback to <kbd>trace</kbd> the variable:</p>
<pre>my_variable.trace_variable("w", trace_when_my_variable_written)</pre>
<p>Now, every time you write in the entry widget, it modifies the value of <kbd>my_variable</kbd>. Because we have set a <kbd>trace</kbd> on <kbd>my_variable</kbd>, it triggers the callback method that, in our example, simply prints the new value into the console, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/b57b5fec-2dd6-4a17-a180-4754bf9b2bc5.png"/></div>
<p>The <kbd>trace</kbd> on a variable is active until it is explicitly deleted. You can delete a <kbd>trace</kbd> using the following command:</p>
<pre>trace_vdelete(self, mode, callback_to_be_deleted)</pre>
<p>The <kbd>trace</kbd> method returns the ID and name of the callback method. This can be used to get the name of the callback method that needs to be deleted.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Widget traversal</h1>
                </header>
            
            <article>
                
<p>If a GUI has more than one widget, a given widget can come under focus when you explicitly click on the widget. Alternatively, the focus can be shifted to other widgets in the order that the widgets were created in the program by pressing the <em>Tab</em> key on the keyboard.</p>
<p>Therefore, it is vital to create widgets in the order that we want the user to traverse through them. Otherwise, the user will have a tough time navigating between the widgets using the keyboard.</p>
<p class="mce-root">Different widgets are designed to behave differently to different keyboard strokes. Therefore, let's spend some time trying to understand the rules of traversing through widgets using the keyboard.</p>
<p class="mce-root">Have a look at the <kbd>10.02_widget_traversal.py</kbd> file to understand the keyboard traversal behavior for different widgets. The code displays a window like the one shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/0b8bc194-c422-40b9-afb6-d83a68737de3.png"/></div>
<p>The code will not be given here as it is very simple (see the <kbd>10.02_widget_traversal.py</kbd> code). It simply adds an entry widget, a few buttons, a few radio buttons, a text widget, a label widget, and a scale widget.</p>
<p>The code demonstrates the default keyboard traversal behaviors for these widgets in Tkinter.</p>
<p>The following are a few important points that you should note:</p>
<ul>
<li class="mce-root">The <em>Tab</em> key can be used to traverse forward, and <em>Shift</em> + <em>Tab</em> can be used to traverse backward.</li>
<li class="mce-root">A user can traverse through the widgets in the order that they were created. A parent widget is visited first (unless it is excluded using <kbd>takefocus = 0</kbd>), followed by all of its children widgets.</li>
<li class="mce-root">You can use <kbd>widget.focus_force()</kbd> to force the input focus on a widget. </li>
<li class="mce-root">You cannot traverse a text widget by using the <em>Tab</em> key because the text widget can contain tab characters as its content. Instead, the text widget can be traversed by using <em>Ctrl</em> + <em>Tab</em>.</li>
<li class="mce-root">Buttons on the widget can be pressed using the spacebar. Similarly, check buttons and radio buttons can also be traversed using the <span>spacebar.</span></li>
<li class="mce-root">You can go up and down the items in a Listbox widget by using the up and down arrows.</li>
<li class="mce-root">The Scale widget responds to the left and right arrow keys and the up and down arrow keys. Similarly, the Scrollbar widget responds to the left/right or up/down arrow keys, depending on their orientation.</li>
<li class="mce-root">By default, most of the widgets (except Frame, Label, and Menus) get an outline when they have the focus set on them. This outline is normally displayed as a thin black border around the widget. You can even set the Frame and Label widgets to show this outline by setting the <kbd>highlightthickness</kbd> option to a nonzero integer value for these widgets.</li>
<li class="mce-root">We can change the color of the outline by using <kbd>highlightcolor= 'red'</kbd> in the code.</li>
<li class="mce-root">Frame, Label, and Menu are not included in the tab's navigation path. However, they can be included in the navigation path by using the <kbd>takefocus = 1</kbd> option. You can explicitly exclude a widget from the tab's navigation path by using the <kbd>takefocus = 0</kbd> option.</li>
</ul>
<p> </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Validating user input</h1>
                </header>
            
            <article>
                
<p>Let's discuss input data validation in Tkinter.</p>
<p>Most of the applications that we have developed in our book are point-and-click-based (the drum machine, the chess game, and the drawing application), where a validation of user input is not required. However, data validation is a must in programs such as the phone book application, where a user enters some data and we store it in a database.</p>
<p>Ignoring user input validation can be dangerous in such applications because input data can be misused for SQL injection. In general, an application in which a user can enter textual data is a good candidate for the validation of user input. In fact, not trusting user inputs is almost considered a maxim.</p>
<p>Wrong user inputs may be intentional or accidental. In either case, if you fail to validate or sanitize data, unexpected errors may occur in your program. In a worst-case scenario, user input can be used to inject harmful code that may be capable of crashing a program or wiping out an entire database.</p>
<p>Widgets, such as Listbox, Combobox, and Radiobuttons, allow limited input options and hence, they normally cannot be misused to input wrong data. On the other hand, widgets such as the Entry widget, the Spinbox widget, and the Text widget allow a large possibility of user inputs, and hence, they need to be validated for correctness.</p>
<p>To enable validation on a widget, you need to specify an additional option of the <kbd>validate = 'validationmode'</kbd> form to the widget.</p>
<p>For example, if you want to enable validation on an Entry widget, you begin by specifying the validate option, as follows:</p>
<p><kbd>Entry( root, validate="all", validatecommand=vcmd)</kbd></p>
<p>Validation can occur in one of the following validation modes:</p>
<table>
<tbody>
<tr>
<td><strong>Validation Mode</strong></td>
<td><strong>Explanation</strong></td>
</tr>
<tr>
<td>
<p><kbd>none</kbd></p>
</td>
<td>
<p>This is the default mode. No validation occurs if <kbd>validate</kbd> is set to <kbd>none</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>focus</kbd></p>
</td>
<td>
<p>When validate is set to focus, the <kbd>validate</kbd> command is called twice—once when the widget receives focus, and once when the focus is lost.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>focusin</kbd></p>
</td>
<td>
<p>The <kbd>validate</kbd> command is called when the widget receives focus.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>focusout</kbd></p>
</td>
<td>
<p>The <kbd>validate</kbd> command is called when the widget loses focus.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>key</kbd></p>
</td>
<td>
<p>The <kbd>validate</kbd> command is called when the entry is edited.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>all</kbd></p>
</td>
<td>
<p>The <kbd>validate</kbd> command is called in all the aforementioned cases.</p>
</td>
</tr>
</tbody>
</table>
<p>The <kbd>10.03_validation_mode_demo.py</kbd> code file demonstrates all of these validation modes by attaching them to a single <kbd>validation</kbd> method. In the code, note the different ways in which different Entry widgets respond to different events. Some Entry widgets call the <kbd>validation</kbd> method on the focus events, others call the <kbd>validation</kbd> method at the time of entering keystrokes into a widget, and still others use a combination of the focus and key events.</p>
<p>Although we did set the validation mode to trigger the <kbd>validate</kbd> method, we need some data to validate against the rules. This is passed to the <kbd>validate</kbd> method using percent substitution. For instance, we passed the mode as an argument to the<br/>
<kbd>validate</kbd> method by performing a percent substitution on the <kbd>validate</kbd> command, as demonstrated in the following command:</p>
<pre>vcmd = (self.root.register(self.validate_data), '%V')</pre>
<p>This was followed by passing the value of <kbd>v</kbd> as an argument to the <kbd>validate</kbd> method:</p>
<pre>def validate_data(self, v)</pre>
<p>In addition to <kbd>%V</kbd>, Tkinter recognizes the following percent substitutions:</p>
<table>
<tbody>
<tr>
<td><strong>Percent substitutions</strong></td>
<td><strong>Explanation</strong></td>
</tr>
<tr>
<td>
<p><kbd>%d</kbd></p>
</td>
<td>
<p>The type of action that is performed on a widget (<kbd>1</kbd> for insert, <kbd>0</kbd> for delete, and <kbd>-1</kbd> for a focus, forced, or <kbd>textvariable</kbd> validation).</p>
</td>
</tr>
<tr>
<td>
<p><kbd>%i</kbd></p>
</td>
<td>
<p>The index of the char string that is inserted or deleted, if any. Otherwise, it will be <kbd>-1</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>%P</kbd></p>
</td>
<td>
<p>The value of the entry in case the edit is allowed. If you are configuring the Entry widget to have a new <kbd>textvariable</kbd>, this will be the value of that <kbd>textvariable</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>%s</kbd></p>
</td>
<td>
<p>The current value of the entry prior to editing.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>%S</kbd></p>
</td>
<td>
<p>The text string being inserted or deleted if any. Otherwise, <kbd>{}</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>%v</kbd></p>
</td>
<td>
<p>The type of validation that has been currently set.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>%V</kbd></p>
</td>
<td>
<p class="mce-root">The type of validation that triggers the callback method (<kbd>key</kbd>, <kbd>focusin</kbd>, <kbd>focusout</kbd>, and forced).</p>
</td>
</tr>
<tr>
<td>
<p><kbd>%W</kbd></p>
</td>
<td>
<p class="mce-root"><span>The name of the Entry widget.</span></p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>These substitution values provide us with the necessary data to validate the input.</p>
<p>Let's pass all of these values and just print them through a dummy <kbd>validate</kbd> method just to see what kind of data that we can expect to get on carrying out the validations (see the <kbd>10.04_percent_substitutions_demo.py</kbd> code):</p>
<pre>class PercentSubstitutionsDemo():<br/>  <br/>  def __init__(self):<br/>    self.root = tk.Tk()<br/>    tk.Label(text='Type Something Below').pack()<br/>    vcmd = (self.root.register(self.validate), <strong>'%d', '%i', '%P', '%s',<br/>                                                '%S', '%v', '%V', '%W'</strong>)<br/>    tk.Entry(self.root, validate="all", validatecommand=vcmd).pack()<br/>    self.root.mainloop()<br/><br/>  def validate(self, <strong>d, i, P, s, S, v, V, W</strong>):<br/>    print("Following Data is received for running our validation checks:")<br/>    print("d:{}".format(d))<br/>    print("i:{}".format(i))<br/>    print("P:{}".format(P))<br/>    print("s:{}".format(s))<br/>    print("S:{}".format(S))<br/>    print("v:{}".format(v))<br/>    print("V:{}".format(V))<br/>    print("W:{}".format(W))<br/>    # returning true for now <br/>    # in actual validation you return true if data is valid <br/>    # else return false<br/>    return True</pre>
<p>Note the line where we register a <kbd>validate</kbd> method by passing all the possible percent substitutions to the callback.</p>
<p>Take particular note of the data returned by <kbd>%P</kbd> and <kbd>%s</kbd> because they pertain to the actual data entered by the user in the Entry widget. In most cases, you will be checking either of these two data sources against the validation rules.</p>
<p>Now that we have a background of rules for data validation, let's have a look at two practical examples that demonstrate input validation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Key validation mode demo</h1>
                </header>
            
            <article>
                
<p>Let's assume that we have a form that asks for a username. We want users to input only alphabetical or space characters in the name. Thus, a number of special characters should not be allowed, as shown in the following screenshot of the widget:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/fa7793c5-9426-4a2f-9ffe-4c604b640392.png"/></div>
<p>This is clearly a case for the <kbd>key</kbd> validation mode because we want to check whether an entry is valid after every keypress. The percent substitution that we need to check is <kbd>%S</kbd> because it yields the text string being inserted or deleted in<br/>
the Entry widget. Therefore, the code that validates the Entry widget is as follows (see the <kbd>10.05_key_validation.py</kbd> code):</p>
<pre>import tkinter as tk<br/><br/>class KeyValidationDemo():<br/>  def __init__(self):<br/>    root = tk.Tk()<br/>    tk.Label(root, text='Enter your name / only alpabets &amp; space <br/>      allowed').pack()<br/>    vcmd = (root.register(self.validate_data), '%S')<br/>    invcmd = (root.register(self.invalid_name), '%S')<br/>    tk.Entry(root, validate="key",validatecommand=vcmd, <br/>               invalidcommand=invcmd).pack(pady=5, padx=5)<br/>    self.error_message = tk.Label(root, text='', fg='red')<br/>    self.error_message.pack()<br/>    root.mainloop()<br/><br/>  def validate_data(self, S):<br/>    self.error_message.config(text='')<br/>    return (S.isalpha() or S == ' ')<br/><br/>  def invalid_name(self, S):<br/>    self.error_message.config(text='Invalid character %s \n <br/>                     name can only have alphabets and spaces' % S)<br/>    app = KeyValidationDemo()</pre>
<p>The description of the preceding code is as follows:</p>
<ul>
<li>We first register two options, namely <kbd>validatecommand ( vcmd )</kbd> and <kbd>invalidcommand ( invcmd )</kbd>.</li>
<li>In the example, <kbd>validatecommand</kbd> is registered to call the <kbd>validate_data</kbd> method, and the <kbd>invalidcommand</kbd> option is registered to call another method named <kbd>invalid_name</kbd>.</li>
<li>The <kbd>validatecommand</kbd> option specifies a method that needs to be evaluated, which will validate the input. The validation method must return a Boolean value, where <kbd>True</kbd> signifies that the data entered is valid, and a <kbd>False</kbd> return value signifies that the data is invalid.</li>
<li>In case the validate method returns <kbd>False</kbd> (invalid data), no data is added to the Entry widget and the script registered for <kbd>invalidcommand</kbd> is evaluated. In our case, a False validation will call the <kbd>invalid_name </kbd> method. The <kbd>invalidcommand</kbd> method is generally responsible for displaying error messages or setting back the focus to the Entry widget.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Focus-out validation mode demo</h1>
                </header>
            
            <article>
                
<p>The previous example demonstrated validation in the <kbd>key</kbd> mode. This means that the validation method was called after every keypress to check whether an entry was valid.</p>
<p>However, there are situations where you might want to check the entire string entered into the widget rather than checking individual keystroke entries.</p>
<p>For example, when an Entry widget accepts a valid email address, we would ideally like to check the validity after the user has entered the entire email address and not after every keystroke entry. This will qualify for a validation in the <kbd>focusout</kbd> mode.</p>
<p>Check out <kbd>10.06_focus_out_validation.py</kbd> for a demonstration of email validation in the <kbd>focusout</kbd> mode, which gives us the following GUI:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/7f2093f9-0445-426e-9b5d-a8d863daa7e5.png"/></div>
<p>The code for the aforementioned demo is as follows:</p>
<pre>import tkinter as tk<br/>import re<br/><br/>class FocusOutValidationDemo():<br/>  def __init__(self):<br/>    self.master = tk.Tk()<br/>    self.error_message = tk.Label(text='', fg='red') <br/>    self.error_message.pack()<br/>    tk.Label(text='Enter Email Address').pack()<br/>    vcmd = (self.master.register(self.validate_email), <strong>'%P'</strong>)<br/>    invcmd = (self.master.register(self.invalid_email), <strong>'%P'</strong>)<br/>    self.email_entry = tk.Entry(self.master, validate="focusout", <br/>              <strong>validatecommand=vcmd, invalidcommand=invcmd)</strong><br/>    self.email_entry.pack()<br/>    tk.Button(self.master, text="Login").pack()<br/>    tk.mainloop()<br/><br/>  def validate_email(self, P):<br/>    self.error_message.config(text='')<br/>    x = re.match(r"[^@]+@[^@]+\.[^@]+", P)<br/>    return (x != None)<br/><br/>  def invalid_email(self, P):<br/>    self.error_message.config(text='Invalid Email Address')<br/>    self.email_entry.focus_set()<br/><br/>app = FocusOutValidationDemo()</pre>
<p>This code has a lot of similarities to the previous validation example. However, note the following differences:</p>
<ul>
<li>The validate mode is set to <kbd>focusout</kbd> in contrast to the <kbd>key</kbd> mode in the previous example. This means that the validation will be done only when the Entry widget loses focus. The validation occurs when you hit the <em>Tab</em> key. Thus, the input box does not lose its focus in case the input is invalid.</li>
<li>This program uses data provided by the <kbd>%P</kbd> <span>percentage substitution, while the previous example used</span> <kbd>%S</kbd><span>. This is understandable because</span> <kbd>%P</kbd> <span>provides the value entered in the Entry widget, but</span> <kbd>%S</kbd> <span>provides the value of the last </span>keystroke.</li>
<li>This program uses regular expressions to check whether the entered value corresponds to a valid email format. Validation usually relies on regular expressions. A whole lot of explanation is required to cover this topic, but that is beyond the scope of this book. For more information on regular expression modules, visit <a href="http://docs.python.org/3.6/library/re.html">http://docs.python.org/3.6/library/re.html</a><span><span>.</span></span></li>
</ul>
<p>This concludes our discussion on input validation in Tkinter. Hopefully, you should now be able to implement input validation to suit your custom needs.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Formatting widget data</h1>
                </header>
            
            <article>
                
<p>Input data such as date, time, phone number, credit card number, website URL, and IP number, have an associated display format. For instance, the date can be better represented in a <kbd>MM/DD/YYYY</kbd> format.</p>
<p>Fortunately, it is easy to format data in the required format as the user enters it in the widget, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/68a447d2-d557-46b9-b123-df47959e326c.png"/></div>
<p>The <kbd>10.07_formatting_entry_widget_to_display_date.py</kbd> code automatically formats user input to insert forward slashes at the required places to display the date entered by a user in the <kbd>MM/DD/YYYY</kbd> format:</p>
<pre>from tkinter import Tk, Entry, Label, StringVar, INSERT<br/><br/>class FormatEntryWidgetDemo:<br/>  <br/>  def __init__(self, root):<br/>    Label(root, text='Date(MM/DD/YYYY)').pack()<br/>    self.entered_date = StringVar()<br/>    self.date_entry = Entry(textvariable=self.entered_date)<br/>    self.date_entry.pack(padx=5, pady=5)  <br/>    self.date_entry.focus_set()<br/>    self.slash_positions = [2, 5]<br/>    root.bind('&lt;Key&gt;', self.format_date_entry_widget)<br/><br/>  def format_date_entry_widget(self, event):<br/>    entry_list = [c for c in self.entered_date.get() if c !='/']<br/>    for pos in self.slash_positions:<br/>      if len(entry_list) &gt; pos:<br/>        entry_list.insert(pos, '/')<br/>    self.entered_date.set(''.join(entry_list))<br/>    # Controlling cursor<br/>    cursor_position = self.date_entry.index(INSERT) # current cursor <br/>      position<br/>    for pos in self.slash_positions:<br/>      if cursor_position == (pos + 1): # if cursor position is on slash<br/>        cursor_position += 1<br/>    if event.keysym not in ['BackSpace', 'Right', 'Left','Up', 'Down']:<br/>      self.date_entry.icursor(cursor_position)<br/><br/>root = Tk()<br/>FormatEntryWidgetDemo(root)<br/>root.mainloop()</pre>
<p>The description of the preceding code is as follows:</p>
<ul>
<li>The Entry widget is bound to the keypress event, where every new keypress calls the related <kbd>format_date_entry_widget</kbd> callback method.</li>
<li>First, the <kbd>format_date_entry_widget</kbd> method breaks down the entered text into an equivalent list named <kbd>entry_list</kbd> and ignores the slash/symbol that may have been entered by a user.</li>
<li>It then iterates through the <kbd>self.slash_positions</kbd> list and inserts the slash symbol at all the required positions in <kbd>entry_list</kbd>. The net result of this is a list that has slashes inserted at all the right places.</li>
<li>The next line converts this list into an equivalent string using <kbd>join()</kbd> and then sets the value of the Entry widget to this string. This ensures that the Entry widget text is formatted into the aforementioned date format.</li>
<li>The remaining pieces of code simply control the cursor to ensure that the cursor advances by one position whenever it encounters the slash symbol. It also ensures that keypresses, such as <em>Backspace</em>, right, left, up, and down are handled properly.</li>
</ul>
<p>Note that this method does not validate the date value, and users may add an invalid date. The method defined here will simply format it by adding a forward slash at the third and sixth positions. Adding date validation to this example is left as an exercise for you to complete.</p>
<p>This concludes our brief discussion on formatting data within widgets. Hopefully, you should now be able to create formatted widgets for a wide variety of input data that can be better displayed in a given format.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">More on fonts</h1>
                </header>
            
            <article>
                
<p>Many Tkinter widgets let you specify custom font specifications either at the time of widget creation or later by using the <kbd>configure()</kbd> option. For most cases, default fonts provide a standard look and feel. However, if you want to change font specifications, Tkinter lets you do so. There is one caveat, though.</p>
<p>When you specify your own font, you need to make sure that it looks good on all the platforms where your program is intended to be deployed because a font might look good on a particular platform, but it may look awful on another platform. Unless you know what you are doing, it is always advisable to stick to Tkinter's default fonts.</p>
<p>Most platforms have their own set of standard fonts that are used by the platform's native widgets. So, rather than trying to reinvent the wheel on what looks good on a given platform or what would be available for a given platform, Tkinter assigns these standard platform-specific fonts to its widget, thus providing a native look and feel on every platform.</p>
<p>Tkinter assigns nine fonts to nine different names; you can use these fonts in your programs. The font names are as follows:</p>
<ul>
<li><kbd>TkDefaultFont</kbd></li>
<li><kbd>TkTextFont</kbd></li>
<li><kbd>TkFixedFont</kbd></li>
<li><kbd>TkMenuFont</kbd></li>
<li><kbd>TkHeadingFont</kbd></li>
<li> <kbd>TkCaptionFont</kbd></li>
<li><kbd>TkSmallCaptionFont</kbd></li>
<li><kbd>TkIconFont</kbd></li>
<li><kbd>TkTooltipFont</kbd></li>
</ul>
<p>Accordingly, you can use them in your programs in the following way:</p>
<pre>Label(text="Sale Up to 50% Off !", font="TkHeadingFont 20")<br/>Label(text="**Conditions Apply", font="TkSmallCaptionFont 8") </pre>
<p>Using these kinds of fonts markups, you can rest assured that your font will look native across all platforms.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Finer control over font</h1>
                </header>
            
            <article>
                
<p>In addition to the aforementioned method of handling fonts, Tkinter provides a separate <kbd>Font</kbd> class implementation. The source code for this class is located in the same folder as the source code for Tkinter.</p>
<p>On my Linux machine, the source code is located in <kbd>/usr/local/lib/python3.6/tkinter/font.py</kbd>. O<span>n Windows (with a default Python 3.6 install) the location is <kbd>C:\Program Files (x86)\Python36-32\Lib\tkinter\font.py</kbd></span>.</p>
<p>To use this module, you need to import fonts into your namespace, as follows (see the <kbd>10.08_font_demo.py</kbd> code):</p>
<pre>from tkinter import Tk, Label, Pack<br/>from tkinter import font<br/>root = Tk()<br/>label = Label(root, text="Humpty Dumpty was pushed")<br/>label.pack()<br/>current_font = font.Font(font=label['font'])<br/>print ('Actual :', str(current_font.actual()))<br/>print ('Family : ', current_font.cget("family"))<br/>print ('Weight : ', current_font.cget("weight"))<br/>print ('Text width of Dumpty : {}'.format(current_font.measure("Dumpty")))<br/>print ('Metrics:', str(current_font.metrics()))<br/>current_font.config(size=14)<br/>label.config(font=current_font)<br/>print ('New Actual :', str(current_font.actual()))<br/>root.mainloop()</pre>
<p>The console output of this program on my terminal is as follows:</p>
<pre><strong>Actual: {'slant': 'roman', 'underline': 0, 'family': 'DejaVu Sans', 'weight': 'normal', 'size': -12, 'overstrike': 0}</strong><br/><strong>Family: DejaVu Sans</strong><br/><strong>Weight: normal</strong><br/><strong>Text width of Dumpty: 49</strong><br/><strong>Metrics: {'fixed': 0, 'descent': 3, 'ascent': 12, 'linespace':15}</strong><br/><strong>New actual: {'slant': 'roman', 'underline': 0, 'family': 'DejaVu Sans', 'weight': 'normal', 'size': 14, 'overstrike': 0}</strong></pre>
<p>As you can see, the <kbd>font</kbd> module provides much better fine-grained control over various aspects of fonts that are otherwise inaccessible.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building a font selector</h1>
                </header>
            
            <article>
                
<p class="mce-root">Now that we have seen the basic features that are available in Tkinter's <kbd>font</kbd> module, let's implement a font selector like the one shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/cedda725-82e3-4356-8031-95999711f122.png"/></div>
<p>The key to building the font selector shown in the preceding screenshot is to fetch a list of all the fonts installed on a system. A call to the <kbd>families()</kbd> method from the <kbd>font</kbd> module fetches a tuple of all the fonts available on a system. Accordingly, when you run the following code, a tuple of all the fonts available on the system gets printed (see the <kbd>10.09_all_fonts_on_a_system.py</kbd> code):</p>
<pre>from tkinter import Tk, font<br/>root = Tk()<br/>all_fonts = font.families()<br/>print(all_fonts) # this prints the tuple containing all fonts on a system.</pre>
<p>Note that since <kbd>font</kbd> is a submodule of Tkinter, it needs an instance of <kbd>Tk()</kbd>, which loads the Tcl interpreter, before it can fetch the tuple.</p>
<p>Now that we have a tuple of all the fonts available on a system, we just need to create the GUI shown in the preceding screenshot and attach relevant callbacks to all the widgets.</p>
<p>We will not discuss the code that creates the GUI shown in the preceding screenshot. Check out <kbd>10.10_font_selector.py</kbd> for the complete code. However, note that the code attaches the following callback to all the widgets:</p>
<pre>def on_value_change(self, event=None):<br/>  self.current_font.config(family=self.family.get(), size=self.size.get(),    <br/>           weight=self.weight.get(), slant=self.slant.get(),  <br/>           underline=self.underline.get(),  <br/>           overstrike=self.overstrike.get())<br/>  self.text.tag_config('fontspecs', font=self.current_font)</pre>
<p>Here, <kbd>fontspecs</kbd> is a custom tag that we attached to the sample text in the text widget, as follows:</p>
<pre>self.text.insert(INSERT, '{}\n{}'.format(self.sample_text,  <br/>                          self.sample_text.upper()), 'fontspecs')</pre>
<p>This concludes our brief discussion on playing with fonts in Tkinter. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Redirecting the command-line output to Tkinter</h1>
                </header>
            
            <article>
                
<p>You may occasionally need to redirect the output of a command line to a GUI such as Tkinter. The ability to pass outputs from the command line to Tkinter opens a large pool of possibilities for using the inherent powers of the shell on Unix and Linux operating systems and the Windows shell on a Windows machine.</p>
<p>We will demonstrate this by using the <kbd>subprocess</kbd> Python module, which lets us spawn new processes, connect to the input, output, and error pipes of this new process, and obtain the return codes from the programs.</p>
<p>A detailed discussion on the <kbd>subprocess</kbd> module can be found at <a href="https://docs.python.org/3/library/subprocess.html">https://docs.python.org/3/library/subprocess.html</a>.</p>
<p>We will use the <kbd>Popen</kbd> class from the <kbd>subprocess</kbd> module to create a new process.</p>
<p>The <kbd>Popen</kbd> class provides a cross-platform way to create new processes, and it has the following long signature to handle most of the common and esoteric use cases:</p>
<pre>subprocess.Popen(args, bufsize=-1, executable=None, stdin=None, stdout=None, stderr=None, preexec_fn=None, close_fds=True, shell=False, cwd=None, env=None, universal_newlines=False, startupinfo=None, creationflags=0, restore_signals=True, start_new_session=False, pass_fds=())</pre>
<p>Here's a simple program that shows how we can redirect the output of the <kbd>ls</kbd> Bash shell command to Tkinter's text widget. As a reminder, the <kbd>ls</kbd> command in the Bash scripting language returns a list of all files and directories (see the <kbd>10.11_reading_from_command_line.py</kbd> code):</p>
<pre>from tkinter import Tk, Text, END<br/>from subprocess import Popen, PIPE<br/>root = Tk()<br/>text = Text(root)<br/>text.pack()<br/><br/>#replace "ls" with "dir" in the next line on windows platform<br/>with Popen(["ls"], stdout=PIPE, bufsize=1, universal_newlines=True) as p:<br/>   for line in p.stdout:<br/>      text.insert(END, line)<br/><br/>root.mainloop()</pre>
<p>Windows users should note that you will have to replace <kbd>ls</kbd> with <kbd>dir</kbd> in the highlighted part of the preceding code to get an equivalent result.</p>
<p>Furthermore, note that you can pass extra arguments to <kbd>Popen</kbd> by using the following format:</p>
<pre>Popen(['your command', arg0, arg1, ...])</pre>
<p>Even better, you can pass the name of the script file that needs to be executed in the new process. The code used to run a script file is as follows: </p>
<pre>Popen('path/toexecutable/script',stdout=sub.PIPE,stderr=sub.PIPE)</pre>
<p>However, the script file that needs to be executed must include a proper shebang declaration to let the program choose a proper executing environment for your script. For instance, if you intend to run a Python script, your script must begin with the shebang of the <kbd>#!/usr/bin/env python3</kbd> form. Similarly, you need to include <kbd>#!/bin/sh</kbd> to run a Bourne-compatible shell script. A shebang isn't necessary on Windows. It is also not required for binary executables.</p>
<p>Running the preceding program produces a window, and a listing of all the files from the current directory are added to the text widget, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img height="166" src="assets/05fe7cb1-51dd-4408-9e44-c07536d40593.png" width="459"/></div>
<p>While the preceding program is simple, this technique can have a lot of practical uses. For instance, you may recall that we built a chat server in the previous chapter. Every time a new client connected to the server, it printed the client details to the terminal. We could have easily redirected that output into a new Tkinter app. This would enable us to create a dashboard for the server; from there, we could have monitored all the incoming connections to the server.</p>
<p>This opens the door for us to reuse any command-line script written in any other programming language, such as Perl or Bash, and directly integrate it with a Tkinter program.</p>
<p>This concludes the brief section on the redirection of command-line outputs into Tkinter programs.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The class hierarchy of Tkinter</h1>
                </header>
            
            <article>
                
<p>As programmers, we hardly need to understand the class hierarchy of Tkinter. After all, we have been able to code all the applications so far without bothering with the overall class hierarchy. However, knowing the class hierarchy enables us to <kbd>trace</kbd> the origin of a method within the source code or source documentation of a method.</p>
<p>In order to understand the class hierarchy of Tkinter, let's take a look at the source code of Tkinter. On the Windows installation, the source code of Tkinter is located at <kbd>path\of\Python\Installation\Lib\tkinter\</kbd>. On my Linux machine, the<br/>
source code is located at <kbd>/usr/lib/python3.6/tkinter/</kbd> .</p>
<p>If you open the <kbd>__init__.py</kbd> file from this folder in a code editor and look at its list of class definitions in Tkinter, you will see the following structure:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/a4c1654f-080d-44b9-93cf-14ed4a8c5b10.png"/></div>
<p>So, what can you see here? We have class definitions for each core Tkinter widget.</p>
<p>In addition to this, we have class definitions for different geometry managers and variable types defined within Tkinter. These class definitions are what you would normally expect to be there.</p>
<p>However, in addition to these, you will see some more class names, such as <kbd>BaseWidget, Misc</kbd>, <kbd>Tk</kbd>, <kbd>Toplevel</kbd>, <kbd>Widget</kbd>, and <kbd>Wm</kbd>. All of these classes are circled in the preceding screenshot. So, what services do these classes provide, and where do they fit in the larger scheme of things?</p>
<p>Let's use the <kbd>inspect</kbd> module to look at the class hierarchy of Tkinter. We will first inspect the class hierarchy of the Frame widget as a representation of class hierarchies for all the other widgets. We will also look at the class hierarchy of<br/>
the <kbd>Tk</kbd> and <kbd>Toplevel</kbd> classes to estimate their role in the overall class hierarchy of Tkinter (<kbd>10.12_tkinter_class_hierarchy.py</kbd>):</p>
<pre>import tkinter<br/>import inspect<br/><br/>print ('Class Hierarchy for Frame Widget')<br/><br/>for i, classname in enumerate(inspect.getmro(tkinter.Frame)):<br/>  print( '\t{}: {}'.format(i, classname))<br/><br/>print ('Class Hierarchy for Toplevel')<br/>for i, classname in enumerate(inspect.getmro(tkinter.Toplevel)):<br/>  print ('\t{}:{}'.format(i, classname))<br/><br/>print ('Class Hierarchy for Tk')<br/>for i, classname in enumerate(inspect.getmro(tkinter.Tk)):<br/>  print ('\t{}: {}'.format(i, classname))</pre>
<p>The output of the preceding program is as follows:</p>
<pre class="mce-root"><strong>Class Hierarchy for Frame Widget</strong><br/><strong>      0: &lt;class 'tkinter.Frame'&gt;</strong><br/><strong>      1: &lt;class 'tkinter.Widget'&gt;</strong><br/><strong>      2: &lt;class 'tkinter.BaseWidget'&gt;</strong><br/><strong>      3: &lt;class 'tkinter.Misc'&gt;</strong><br/><strong>      4: &lt;class 'tkinter.Pack'&gt;</strong><br/><strong>      5: &lt;class 'tkinter.Place'&gt;</strong><br/><strong>      6: &lt;class 'tkinter.Grid'&gt;</strong><br/><strong>      7: &lt;class 'object'&gt;</strong><br/><strong>Class Hierarchy for Toplevel</strong><br/><strong>      0:&lt;class 'tkinter.Toplevel'&gt;</strong><br/><strong>      1:&lt;class 'tkinter.BaseWidget'&gt;</strong><br/><strong>      2:&lt;class 'tkinter.Misc'&gt;</strong><br/><strong>      3:&lt;class 'tkinter.Wm'&gt;</strong><br/><strong>      4:&lt;class 'object'&gt;</strong><br/><strong>Class Hierarchy for Tk</strong><br/><strong>      0: &lt;class 'tkinter.Tk'&gt;</strong><br/><strong>      1: &lt;class 'tkinter.Misc'&gt;</strong><br/><strong>      2: &lt;class 'tkinter.Wm'&gt;</strong><br/><strong>      3: &lt;class 'object'&gt;</strong></pre>
<p>The description of the preceding code is as follows:</p>
<ul>
<li>The <kbd>getmro</kbd>(<kbd>classname</kbd>) function from the <kbd>inspect</kbd> module returns a tuple consisting of all the ancestors of <kbd>classname</kbd> in the order specified by the <strong>method resolution order</strong> (<strong>MRO</strong>). MRO refers to the order in which base<br/>
classes are searched when looking for a given method.</li>
<li>By inspecting the MRO and the source code, you will come to know that the <kbd>Frame</kbd> class inherits from the <kbd>Widget</kbd> class, which in turn inherits from the <kbd>BaseWidget</kbd> class. </li>
<li>The <kbd>Widget</kbd> class is an empty class with the following class definition: <kbd>class Widget(BaseWidget, Pack, Place, Grid)</kbd>.</li>
<li>As you can see, this is how methods defined in the geometry manager (the pack, place, and grid mix-ins) are made available to all the widgets.</li>
<li>The <kbd>BaseWidget</kbd> class has the following class definition: <kbd>class BaseWidget(Misc)</kbd>. This class exposes the destroy method that can be used by programmers. </li>
<li>All the utility methods defined in the <kbd>Misc</kbd> class are made available to the widgets at this hierarchy level.</li>
<li class="mce-root"><span>The</span> <kbd>Misc</kbd> <span>class is a generic mix-in that provides a lot of functionality that we have used in our applications. Some of the methods that we have used in our programs, as defined within the <kbd>Misc</kbd> class, are</span> <kbd>after()</kbd><span>,</span> <kbd>bbox()</kbd><span>,</span> <kbd>bind_all()</kbd><span>, </span><kbd>bind_tag()</kbd><span>,</span> <kbd>focus_set()</kbd><span>,</span> <kbd>mainloop()</kbd><span>,</span> <kbd>update()</kbd><span>,</span> <kbd>update_idletask()</kbd><span>, and </span><kbd>winfo_children()</kbd><span>. For a complete list of functionalities provided by the</span> <kbd>Misc</kbd> <span>class, run the following commands in the Python interactive shell:</span></li>
</ul>
<pre><strong>&gt;&gt;&gt; import tkinter</strong><br/><strong>&gt;&gt;&gt; help(tkinter.Misc)</strong></pre>
<p>Now, let's take a look at the <kbd>Tk</kbd> and <kbd>Toplevel</kbd> classes:</p>
<ul>
<li>The <kbd>Tk</kbd> class returns a new <kbd>Toplevel</kbd> widget on the screen. The <kbd>__init__</kbd> method of the <kbd>Tk</kbd> class is responsible for the creation of a new Tcl interpreter by calling a method named <kbd>loadtk()</kbd>. The class defines a method named <kbd>report_callback_exception()</kbd>, which is responsible for the reporting of errors and exceptions on <kbd>sys.stderr</kbd>.</li>
<li>The <kbd>__init__</kbd> method of the <kbd>Toplevel</kbd> class of Tkinter is responsible for the creation of the main window of an application. The constructor of the class takes various optional arguments such as <kbd>bg</kbd>, <kbd>background</kbd>, <kbd>bd</kbd>, <kbd>borderwidth</kbd>, <kbd>class</kbd>, <kbd>height</kbd>, <kbd>highlightbackground</kbd>, <kbd>highlightcolor</kbd>, <kbd>highlightthickness</kbd>, <kbd>menu</kbd>, and <kbd>relief</kbd>.</li>
<li>To obtain a list of all the methods provided by the <kbd>Toplevel</kbd> and <kbd>Tk</kbd> classes, run the following command in the Python interactive shell:  <kbd>help(tkinter.Toplevel); help(tkinter.Tk)</kbd>.</li>
<li>In addition to inheriting from the <kbd>Misc</kbd> mixin class, the <kbd>Toplevel</kbd> and <kbd>Tk</kbd> classes also inherit methods from the <kbd>Wm</kbd> mixin class.</li>
<li>The <kbd>Wm</kbd> (short for the Window manager) <kbd>mixin</kbd> class provides many methods to let us communicate with the window manager. Some commonly used methods from this class include <kbd>wm_iconify, wm_deiconify</kbd>, <kbd>wm_overrideredirect</kbd>, <kbd>title</kbd>, <kbd>wm_withdraw</kbd>, <kbd>wm_transient</kbd>, and <kbd>wm_resizable</kbd>. For a complete list of functions provided by the <kbd>Wm</kbd> class, run the following command in the Python interactive shell: <kbd>help(tkinter.Wm)</kbd>.</li>
</ul>
<p>After translating the class hierarchy, as obtained from the previous program and by inspecting the source code, we get a hierarchy structure of Tkinter, as shown in the following diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/13641faf-5200-45c6-914e-dd14ae9821b1.png"/></div>
<p>In addition to the normal inheritance relation, which is shown in the preceding diagram with the help of unbroken lines, Tkinter provides a list of mixins (or helper classes).</p>
<p>A <kbd>mixin</kbd> is a class that is designed not to be used directly, but to be combined with other classes using multiple inheritances.</p>
<p>Tkinter mixins can be broadly classified into the following two categories:</p>
<ul>
<li>Geometry mixins: These include the <kbd>Grid</kbd>, <kbd>Pack</kbd>, and <kbd>Place</kbd> classes</li>
<li>Implementation mixins: These include the following classes:<br/>
<ul>
<li>The <kbd>Misc</kbd> class, which is used by the root window and <kbd>widget</kbd> classes,  provides several Tk and window-related services</li>
<li>The <kbd>Wm</kbd> class, which is used by the root window and the Toplevel widget, provides several window manager services</li>
</ul>
</li>
</ul>
<p>This concludes our brief under-the-hood tour of Tkinter. Hopefully, this should give you some insight into the inner workings of Tkinter. If you ever have a doubt about the documentation of any given method, you can take a peek directly into the actual implementation of the method.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Tips for program design</h1>
                </header>
            
            <article>
                
<p>Let's take a look at a few generic tips for program design.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The model-first policy versus the code-first policy</h1>
                </header>
            
            <article>
                
<p>A well-designed model is half the work done. That said, the model is sometimes not very evident when you start writing the program. In such cases, you can break the rules and try out the code-first philosophy. The idea is to build your program incrementally from the ground up, refactor your code, and model, as your <span>vision for the program becomes clearer</span>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Separating the model from the view</h1>
                </header>
            
            <article>
                
<p>The need to separate the model or data structure from the view is the key to building scalable applications. While it is possible to intermix the two components, you will soon find your program getting messy and difficult to maintain.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Selecting the right data structure</h1>
                </header>
            
            <article>
                
<p>Selecting the right data structure can have a profound impact on the performance of a program. If your program requires you to spend considerable time on lookups, use a dictionary, if feasible. When all that you need is to traverse over a collection, prefer lists over dictionaries because dictionaries take up more space. When your data is immutable, prefer tuples over lists because tuples can be traversed faster than lists.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Naming variables and methods</h1>
                </header>
            
            <article>
                
<p>Use meaningful and self-documenting names for your variables and methods. The name should leave no scope for confusion about the intent of the variable or the method. Use plural names for collections and singular names otherwise. Methods that return Boolean values should be appended with words such as <em>is</em> or <em>has</em>. Stick to the style guidelines, but you should also know when to break them.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Single Responsibility Principle</h1>
                </header>
            
            <article>
                
<p>The Single Responsibility Principle suggests that a function/class/method should do only one thing and that it should do it all and do it well. This means that we should not try to handle multiple things from within a function.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Loose coupling</h1>
                </header>
            
            <article>
                
<p>Whenever possible, reduce coupling or dependence in your program. The following is a famous quote on this subject:</p>
<div class="packt_quote CDPAlignLeft CDPAlign">All problems in computer science can be solved by another level of indirection.<br/>
                                                                                                      – David Wheeler</div>
<p>Let's suppose that your program has a play button. An immediate impulse may be to link it to the <kbd>play</kbd> method of your program. However, you can further break it up into two methods. You could probably link the play button to a method named <kbd>on_play_button_clicked</kbd>, which in turn calls the actual <kbd>play</kbd> method. The advantage of this is that you may want to handle additional things when the play button is clicked, such as displaying the current track information somewhere in your program.</p>
<p>Thus, you can now use the <kbd>on_play_button_clicked</kbd> method to decouple the click event from the actual play method and then handle calls to multiple methods. </p>
<p>However, you must resist the temptation of adding too many levels of indirection, as your program may quickly start getting messy and it may get out of control.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Handling errors and exceptions</h1>
                </header>
            
            <article>
                
<p>Python follows the <strong>EAFP</strong> (short for <strong>easier to ask for forgiveness than permission</strong>) style of coding as opposed to the <strong>LBYL</strong> (<strong>look before you leap</strong>) style that is followed by most programming languages.</p>
<p>Therefore, handling exceptions in a way that is similar to the following one is normally cleaner in Python than checking conditions using the if-then block.</p>
<p>So when coding in Python, rather than using the following style in coding:</p>
<pre>if some_thing_wrong:<br/>  do_something_else()<br/>else:<br/>  do_something_normal()</pre>
<p>Consider using this instead:</p>
<pre>try:<br/>  do_some_thing_normal()<br/>except some_thing_wrong:<br/>  do_some_thing_else()</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Handling cross-platform differences </h1>
                </header>
            
            <article>
                
<p>Even though Tkinter is a cross-platform module, you might come across occasions when code written for one operating system might not work as expected on other operating systems.  We already saw one such example in the case of getting command-line results in the previous Redirecting the command-line output to Tkinter<em>.</em> In such cases, you can overcome these cross-platform discrepancies by first identifying the operating system on which the program is being run and then using a conditional statement to run different lines of code for different operating systems.</p>
<p>Here's a brief snippet that demonstrates this concept:</p>
<pre> from platform import uname<br/> operating_system = uname()[0]<br/> if ( operating_system == "Linux" ):<br/>   canvas.bind('&lt;Button-4&gt;', wheelUp) # X11<br/>   canvas.bind('&lt;Button-5&gt;', wheelDown)<br/> elif ( operating_system == "Darwin" ):<br/>   canvas.bind('&lt;MouseWheel&gt;', wheel) # MacOS<br/> else: <br/>   canvas.bind_all('&lt;MouseWheel&gt;', wheel) # windows</pre>
<p>The particular problem here is that the mouse wheel event is denoted by the <kbd>&lt;MouseWheel&gt;</kbd> event name on Windows and macOS, but as <kbd>&lt;Button-4&gt;</kbd> and <kbd>&lt;Button-5&gt;</kbd> on Linux distributions.  The preceding code uses the platform module of Python to identify the operating system and follows a different line of code for different operating systems.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Tips for program optimization</h1>
                </header>
            
            <article>
                
<p>Next, let's take a look at some generic tips to optimize your programs.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using filter and map</h1>
                </header>
            
            <article>
                
<p>Python provides two built-in functions, named <kbd>filter</kbd> and <kbd>map</kbd>, to manipulate collections directly rather than having to iterate over each item in the collection. The <kbd>filter</kbd>, <kbd>map</kbd>, and <kbd>reduce</kbd> functions are faster than loops because a lot of the work is done by the underlying code written in C.</p>
<p>The <kbd>filter(function, list)</kbd> function returns a list (iterators in Python 3.x) that contains all the items for which the function returns a true value. The following command is an example:</p>
<pre>print filter(lambda num: num&gt;6, range(1,10))# prints [7, 8,9]</pre>
<p>This is faster than running a conditional if-then check against the list.</p>
<p>The <kbd>map(function_name, list)</kbd> function applies <kbd>function_name</kbd> to each item in the list and returns the values in a new list (returns iterators instead of lists in Python 3.x). The following command is an example:</p>
<pre>print map(lambda num: num+5, range(1,5)) #prints [6, 7, 8,9]</pre>
<p>This is faster than running the list through a loop and adding <kbd>5</kbd> to each element.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Optimizing variables</h1>
                </header>
            
            <article>
                
<p>The way you select variables in your program can considerably affect the speed of the execution of your program. For instance, if you do not need to change the content or attributes of a widget after its instantiation, do not create a class-wide instance of the widget.</p>
<p>For example, if a Label widget needs to remain static, use <kbd>Label(root, text='Name').pack(side=LEFT)</kbd> instead of using the following snippet:</p>
<pre>self.mylabel = Label(root, text='Name')<br/>self.mylabel.pack(side=LEFT)</pre>
<p>Similarly, do not create local variables if you are not going to use them more than once. For example, use <kbd>mylabel.config (text= event.keysym)</kbd> instead of first creating a local variable named key and then using it only once:</p>
<pre>key = event.keysym<br/>mylabel.config (text=key)</pre>
<p>If the local variable needs to be used more than once, it may make sense to create a local variable.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Profiling your program</h1>
                </header>
            
            <article>
                
<p>Profiling involves generating detailed statistics to show how often and for how long various routines of a program execute. This helps you isolate the offending parts of a program, and those parts probably need redesigning.</p>
<p>Python provides a built-in module named <kbd>cProfile</kbd>, which enables the generation of detailed statistics pertaining to a program. The module gives details such as the total program running time, the time taken to run each function, and the number of times each function is called. These statistics make it easy to determine the parts of the code that need optimization.</p>
<p>In particular, <kbd>cProfile</kbd> provides the following data for a function or script:</p>
<ul>
<li><kbd>ncalls</kbd>: This indicates the number of times a function is called </li>
<li><kbd>tottime</kbd>: This indicates the time spent on a function, which excludes the time spent on calling other functions</li>
<li> <kbd>percall</kbd>: This is <kbd>tottime</kbd> divided by <kbd>ncalls</kbd></li>
<li><kbd>cumtime</kbd>: This indicates the time spent on a function, including calls to other functions</li>
<li><kbd>percall</kbd>: This is <kbd>cumtime</kbd> divided by <kbd>tottime </kbd></li>
</ul>
<p>To profile a function named <kbd>spam()</kbd>, use the following code:</p>
<pre>import cProfile<br/>cProfile.run('spam()','spam.profile')</pre>
<p>You can then view the results of profiling by using another module called <kbd>pstats</kbd>, as follows:</p>
<pre>import pstats<br/>stats = pstats.Stats('spam.profile')<br/>stats.strip_dirs().sort_stats('time').print_stats()</pre>
<p>More importantly, you can profile an entire script. Let's assume that you want to profile a script named <kbd>myscript.py</kbd>. You can simply navigate to the directory of the script using a command-line tool and then type and run the following command:</p>
<pre><strong>python -m cProfile myscript.py</strong></pre>
<p>Here's a partial output from running the preceding command on the <kbd>8.08_vornoi_diagram</kbd> code from <a href="7f88607b-582a-4f9e-a922-7cd9333d320e.xhtml" target="_blank">Chapter 8</a>, <em>Fun With Canvas</em>:</p>
<pre>57607465 function calls (57607420 primitive calls) in 110.040 seconds<br/>Ordered by: standard name<br/>ncalls tottime percall cumtime percall filename:lineno(function)<br/> 1 50.100 50.100 95.452 95.452 8.09_vornoi_diagram.py:15(create_voronoi_diagram)<br/> 1 0.000 0.000 110.040 110.040 8.09_vornoi_diagram.py:5(&lt;module&gt;)<br/> 400125 2.423 0.000 14.616 0.000 __init__.py:2313(_create)<br/> 400125 0.661 0.000 15.277 0.000 __init__.py:2342(create_rectangle)<br/> 400128 1.849 0.000 2.743 0.000 __init__.py:95(_cnfmerge)<br/> 625 0.001 0.000 0.003 0.000 random.py:170(randrange)<br/> 625 0.002 0.000 0.002 0.000 random.py:220(_randbelow)<br/> 50400000 30.072 0.000 30.072 0.000 {built-in method math.hypot}<br/> 1 14.202 14.202 14.358 14.358 {method 'mainloop' of '_tkinter.tkapp' objects}</pre>
<p>I <span>specifically</span> chose to profile this program because it takes a long time to execute. In this case, it took ~110 seconds to run and most of the time was spent running the <kbd>create_vornoi_diagram</kbd> function (~95 seconds). So now this function is a perfect candidate for optimization.</p>
<p>In addition to the <kbd>cProfile</kbd> module, there are other modules, such as <kbd>PyCallGraph</kbd> and <kbd>objgraph</kbd>, and they provide visual graphs for the profile data.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Other optimization tips</h1>
                </header>
            
            <article>
                
<p>Optimization is a vast topic, and there is a lot that you can do. If you are interested in knowing more about code optimization, you can start with the official Python optimization tips that are available at <a href="http://wiki.python.org/moin/PythonSpeed/PerformanceTips">http://wiki.python.org/moin/PythonSpeed/PerformanceTips</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Distributing a Tkinter application</h1>
                </header>
            
            <article>
                
<p>So, you have your new application ready and want to share it with the rest of the world. How do you do that?</p>
<p>You, of course, need Python installed for your programs to run. Windows does not have Python preinstalled. Most modern Linux distributions and macOS have Python preinstalled, but you don't need just any version of Python. You need a version of Python that is compatible with the version on which the program was originally written.</p>
<p>Furthermore, if your program uses third-party modules, you need the appropriate module installed for the required Python version. This surely is too much diversity to handle.</p>
<p>Fortunately, we have tools, such as Freeze tools, that allow us to distribute Python programs as standalone applications.</p>
<p>Given the diversity of platforms that need to be handled, there are a large number of Freeze tool options from which you can choose. Therefore, a detailed discussion on any one of these tools is beyond the scope of this book.</p>
<p>We will list some of the most evolved freezing tools in the following sections. If you find a tool that fits into your distribution requirements, you can look at its documentation for more information.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">py2exe</h1>
                </header>
            
            <article>
                
<p>If you only need to distribute your Python application on Windows, py2exe is perhaps the most hardened tool. It converts Python programs into executable Windows programs that can run without requiring a Python installation.<br/>
More information, a download link, and tutorials on this are available at <a href="http://www.py2exe.org/">http://www.py2exe.org/</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">py2app</h1>
                </header>
            
            <article>
                
<p>The py2app performs the same tasks in macOS that py2exe does for Windows. If you just need to distribute your Python application on macOS, py2app is a time-tested tool. More information is available at <a href="https://pythonhosted.org/py2app/">https://pythonhosted.org/py2app/</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">PyInstaller</h1>
                </header>
            
            <article>
                
<p>PyInstaller has gained popularity as a freezing tool in the last few years because it supports a wide variety of platforms, such as Windows, Linux, macOS X, Solaris, and AIX.</p>
<p>In addition, executables created using PyInstaller claim to take up less space than other freezing tools because it uses transparent compression. Another important feature of PyInstaller is its out-of-the-box compatibility with a large number of third-party packages. The full list of features, downloads, and documentation can be viewed by visiting <a href="http://www.pyinstaller.org/">http://www.pyinstaller.org/</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Other freezing tools</h1>
                </header>
            
            <article>
                
<p>The following are a few other freezing tools:</p>
<ul>
<li><strong>Freeze</strong>: This tool is shipped with the standard Python distribution. Freeze can only be used to compile executables on Unix systems.  However, the program is overly simplistic, as it fails to handle even the common third-party libraries. More information on this is available at <a href="http://wiki.python.org/moin/Freeze">http://wiki.python.org/moin/Freeze</a>.</li>
<li><strong>cx_Freeze</strong>: This tool is similar to py2exe and py2app, but it claims to be portable across all platforms on which Python works. More information on this is available at <a href="http://cx-freeze.sourceforge.net/index.html">http://cx-freeze.sourceforge.net/index.html</a>.</li>
</ul>
<p>If you're distributing a small program, a <span>freezing</span> tool might be just what you need. </p>
<p>However, if you have a large program, say, with lots of external third-party library dependencies, or dependencies that are not supported by any existing freezing tool, your application might be the right candidate for bundling the<br/>
Python interpreter with your application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The limitations of Tkinter</h1>
                </header>
            
            <article>
                
<p>We have already explored the power of Tkinter. Perhaps the greatest power of Tkinter lies in its ease of use and lightweight footprint. Tkinter exposes a very powerful API, especially with the Text widget and the Canvas widget.<br/>
However, <span>its ease of use and the fact that it is lightweight</span> also result in some limitations.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">A limited number of core widgets</h1>
                </header>
            
            <article>
                
<p>Tkinter provides only a small number of basic widgets and lacks a collection of modern widgets. It needs Ttk, Pmw, TIX, and other extensions to provide some really useful widgets. Even with these extensions, Tkinter fails to match the range of widgets provided by other GUI tools, such as the advanced wxPython widget set and PyQt.</p>
<p>For instance, wxPython's HtmlWindow widget lets users display HTML content with ease. There have been attempts to provide similar extensions in Tkinter, but they are far from satisfactory. Similarly, there are other widgets from the Advanced User Interface Library and mixins in wxPython, such as floating/docking frames and perspective loading and saving; Tkinter users can only hope that these widgets will be included in future releases.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Non-Python objects</h1>
                </header>
            
            <article>
                
<p>Tkinter widgets are not first-class Python objects. Thus, we have to use workarounds such as <kbd>Intvar</kbd>, <kbd>StringVar</kbd>, and <kbd>BooleanVar</kbd> to handle variables in Tkinter. This adds a small layer of complexity, as error messages returned by the Tcl interpreter are not very Python-friendly, which makes it harder to debug.</p>
<p> </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">No support for printing</h1>
                </header>
            
            <article>
                
<p>Tkinter is rightly criticized for not providing any support for printing features.</p>
<p>The Canvas widget allows for limited printing support in the PostScript format. The PostScript format is too limited in what it can be used for. Compare this to wxPython, which provides a complete printing solution in the form of a printing framework.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">No support for newer image formats</h1>
                </header>
            
            <article>
                
<p>Tkinter does not natively support image formats such as JPEG and PNG. The <kbd>PhotoImage</kbd> class of Tkinter can read images only in the GIF and PGM/PPM formats. Although there are workarounds, such as using the <kbd>ImageTk</kbd> and <kbd>Image</kbd> submodules from the <kbd>PIL</kbd> module, it would have been better if Tkinter natively supported popular image formats.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Inactive development community</h1>
                </header>
            
            <article>
                
<p>Tkinter is often criticized for having a relatively inactive development community. This is true to a large extent. The documentation for Tkinter has remained a work in progress for many years now.</p>
<p>A large number of Tkinter extensions have appeared over the years, but most of them have not been under active development for a long time. </p>
<p>Tkinter supporters refute this with the argument that Tkinter is a stable and mature technology that does not need frequent revisions, unlike some other GUI modules that are still being developed.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Alternatives to Tkinter</h1>
                </header>
            
            <article>
                
<p>If a program can be written in Tkinter, this is probably the best way to go in terms of simplicity and maintainability. However, in case the aforementioned limitations get in your way, you can explore some other alternatives to Tkinter.</p>
<p>In addition to Tkinter, there are several other popular Python GUI toolkits. The most popular ones include wxPython, PyQt, PySide, and PyGTK. Here's a brief discussion of these toolkits.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">wxPython</h1>
                </header>
            
            <article>
                
<p>wxPython is a Python interface for <kbd>wxWidgets</kbd>, a popular open source GUI library. The code written in wxPython is portable across most major platforms, such as Windows, Linux, and macOS.</p>
<p>The wxPython interface is generally considered to be better than Tkinter at building complex GUIs, primarily because it has a large base of natively supported widgets. However, Tkinter supporters do contest this claim.</p>
<p>The <kbd>wxWidgets</kbd> interface was originally written in the C++ programming language. Hence, wxPython inherits a large portion of the complexity that is typical of C++ programs. wxPython provides a very large base of classes, and it often takes more code to produce the same interface than it would take in Tkinter. However, in exchange for this complexity, wxPython provides a larger base of built-in widgets than Tkinter offers. </p>
<p>Owing to its inherent complexity, wxPython has seen the emergence of several GUI builder toolkits, such as <strong>wxGlade, wxFormBuilder,</strong> and <strong>wxDesigner.</strong> The wxPython installation comes with demo programs that can help you quickly get started with the toolkit. To download the toolkit, or for more information on wxPython, visit <a href="http://wxpython.org/">http://wxpython.org/</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">PyQt</h1>
                </header>
            
            <article>
                
<p>PyQt is a Python interface for a cross-platform GUI toolkit named Qt, a project currently developed and maintained by a British firm named Riverbank Computing.</p>
<p>PyQt, with several hundred classes and thousands of functions, is perhaps the most fully featured GUI library currently available for GUI programming in Python. However, this feature load brings in a lot of complexity and a steep learning curve.</p>
<p>Qt, and hence pyQt, has a very rich set of supported widgets. In addition to this, it includes built-in support for network programming, SQL databases, threads, multimedia frameworks, regular expressions, XML, SVG, and much more. The designer feature of Qtletsus generates GUI code from a <strong>WYSIWYG</strong> (<strong>what you see is what you get</strong>) interface.</p>
<p>PyQt is available under a variety of licenses, including GNU, <strong>General Public License</strong> (<strong>GPL</strong>), and a commercial license. However, its greatest disadvantage is that unlike Qt, it is unavailable under the <strong>Lesser General Public License</strong> (<strong>LGPL</strong>).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">PySide</h1>
                </header>
            
            <article>
                
<p>If you are looking for an LGPL Version of Qt bindings for Python, you may want to explore PySide. PySide was originally released under the LGPL in August 2009 by Nokia, the former owners of the Qt Toolkit. It is now owned by Digia. More information on PySide can be obtained by visiting <a href="http://qt-project.org/wiki/PySide">http://qt-project.org/wiki/PySide</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">PyGTK</h1>
                </header>
            
            <article>
                
<p>PyGTK is a collection of Python bindings for the GTK + GUI library. PyGTK applications are cross-platform and can run on Windows, Linux, macOS, and others. PyGTK is free and is licensed under the LGPL. Therefore, you can use, modify, and distribute it with very few restrictions. </p>
<p>More information about PyGTK can be obtained by visiting <a href="http://www.pygtk.org/">http://www.pygtk.org/</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Other options</h1>
                </header>
            
            <article>
                
<p>Besides these popular toolkits, there are a range of toolkits available for GUI programming in Python.</p>
<p>Java programmers who are comfortable with Java GUI libraries, such as Swing and AWT, can seamlessly access these libraries by using <strong>Jython.</strong> Similarly, C# programmers can use <strong>IronPython</strong> to access GUI construction features from the <strong>.NET</strong> framework.</p>
<p>For a comprehensive list of other GUI tools that are available to a Python developer, visit <a href="http://wiki.python.org/moin/GuiProgramming">http://wiki.python.org/moin/GuiProgramming</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Tkinter in Python 2.x</h1>
                </header>
            
            <article>
                
<p>In 2008, Guido van Rossum, the author of Python, forked the language into two branches—2.x and 3.x. This was done to clean up the language and make it more consistent.</p>
<p>Python 3.x broke backward compatibility with Python 2.x. For example, the print statement in Python 2.x was replaced by the <kbd>print()</kbd> function that would now take arguments as parameters.</p>
<p>We coded all the Tkinter programs in Python Version 3.x. However, in case you need to maintain or write new Tkinter programs in Python 2.x, the transition should not be very difficult.</p>
<p>The core functionality of Tkinter remains the same between 2.x and 3.x. The only significant change to Tkinter when moving from Python 2.x to Python 3.x involves changing the way the Tkinter modules are imported.</p>
<p>Tkinter has been renamed as <kbd>tkinter</kbd> in Python 3.x (capitalization has been removed).</p>
<p>Note that in 3.x, the <kbd>lib-tk</kbd> directory was renamed to <kbd>tkinter</kbd>. Inside this directory, the <kbd>Tkinter.py</kbd> file was renamed to <kbd>__init__.py</kbd>, thus making <kbd>tkinter</kbd> an importable module.</p>
<p>Accordingly, the biggest difference lies in the way you import the <kbd>tkinter</kbd> module into your current namespace:</p>
<pre>import Tkinter  <span># for Python 2</span><br/>import tkinter  # for Python 3</pre>
<p class="mce-root"/>
<p>Furthermore, note the following changes.</p>
<p>Note how the Python 3 version is cleaner, more elegant, and more systematic in its naming conventions regarding the use of lowercase names for its modules:</p>
<table>
<tbody>
<tr>
<td><strong>Python 3</strong></td>
<td><strong>Python 2</strong></td>
</tr>
<tr>
<td>
<p class="mce-root"><kbd>import tkinter.ttk </kbd>     OR</p>
<p><kbd>from tkinter import ttk</kbd></p>
</td>
<td><kbd>import ttk</kbd></td>
</tr>
<tr>
<td><kbd>import tkinter.messagebox</kbd></td>
<td><kbd>import tkMessageBox</kbd></td>
</tr>
<tr>
<td><kbd>import tkinter.colorchooser</kbd></td>
<td><kbd>import tkColorChooser</kbd></td>
</tr>
<tr>
<td><kbd>import tkinter.filedialog</kbd></td>
<td><kbd>import tkFileDialog</kbd></td>
</tr>
<tr>
<td><kbd>import tkinter.simpledialog</kbd></td>
<td><kbd>import tkSimpleDialog</kbd></td>
</tr>
<tr>
<td><kbd>import tkinter.commondialog</kbd></td>
<td><kbd>import tkCommonDialog</kbd></td>
</tr>
<tr>
<td><kbd>import tkinter.font</kbd></td>
<td><kbd>import tkFont</kbd></td>
</tr>
<tr>
<td><kbd>import tkinter.scrolledtext</kbd></td>
<td><kbd>import ScrolledText</kbd></td>
</tr>
<tr>
<td><kbd>import tkinter.tix</kbd></td>
<td><kbd>import Tix</kbd></td>
</tr>
</tbody>
</table>
<p> </p>
<p>The following version will work for both cases:</p>
<pre>try:<br/>  import tkinter as tk<br/>except ImportError:<br/>  import Tkinter as tk<br/><br/>try:<br/>  import tkinter.messagebox<br/>except:<br/>  import tkMessageBox</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>To conclude the book, let's summarize some of the key steps involved in designing an application. Depending on what you want to design, choose a suitable data structure to represent your needs logically. If required, combine primitive data structures to form complex structures such as, say, a list or a tuple of dictionaries. Create classes for objects that constitute your application. Add attributes that need to be manipulated and methods to manipulate these attributes. Manipulate attributes by using a different API provided by a rich set of Python-standard and external libraries.</p>
<p>We tried to build several applications in this book. Then, we had a look at an explanation for the code. However, when you try to explain a software development process in a sequential text, you sometimes mislead your readers by implying that<br/>
the development of software programs is a linear process. This is hardly true.</p>
<p>Actual programming doesn't usually work this way. In fact, small- to medium-sized programs are normally written in an incremental trial-and-error process, where assumptions get changed and structures are modified throughout the course of application development.</p>
<p>Here is how you would develop a small- to a medium-sized application:</p>
<ol>
<li>Start with a simple script.</li>
<li>Set a small achievable goal, implement it, and then think of adding the next feature to your program in an incremental fashion.</li>
<li>You may or may not introduce a class structure initially. If you are clear about the problem domain, you may introduce the class structure from the very beginning.</li>
<li>If you are not initially sure about the class structure, start with simple procedural code. As your program starts to grow, you will probably start getting a lot of global variables. It is here that you will start getting an idea of the structural dimensions of your program. It is now time to refactor and restructure your program to introduce a class structure.</li>
<li>Harden your program against unanticipated runtime failures and edge cases to make it ready for production use.</li>
</ol>
<p>That concludes the book. <span>If you have any suggestions or feedback, please leave us a comment. </span>If you found this book helpful, please rate it online and help us spread the word. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">QA section</h1>
                </header>
            
            <article>
                
<p><span class="fontstyle0">Here are a few questions to reflect upon:</span></p>
<ul>
<li>How can we handle cross-platform differences in Tkinter?</li>
<li>What are the advantages and limitations of using Tkinter?</li>
<li>What are some of the common alternatives to Tkinter?</li>
<li>What the various modes of validation in Tkinter?</li>
<li>What is program profiling? How do we profile a program in Python?</li>
</ul>
<p> </p>


            </article>

            
        </section>
    </body></html>