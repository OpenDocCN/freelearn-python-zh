- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Managing State with React Hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[*Chapter 2*](B18554_02.xhtml#_idTextAnchor038), *Getting Started with React*,
    was a great way to kick off React frontend development. By now, you should be
    familiar with project directory structures and a few other concepts in React.
    In this chapter, we will take your understanding of React’s core concepts further.'
  prefs: []
  type: TYPE_NORMAL
- en: Why does this matter? Simple. You can’t be the shining light you intend to be
    with React development without getting a grounding in the React core features
    and how we use them. This chapter focuses on managing state with React **Hooks**.
  prefs: []
  type: TYPE_NORMAL
- en: State in React is the medium through which we add interactivity to the user
    interface. Before React v16.8, developing class components was the only way you
    could add state and state transitions to your components.
  prefs: []
  type: TYPE_NORMAL
- en: Functional components were stateless; they were only able to display **JavaScript
    XML** (**JSX**) elements, that is, presentational components only. But with the
    Hooks API, you can add state and state transitions to your functional components.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will come to understand various React hooks and how we
    use them to add statefulness to functional components. The building blocks of
    any React application are components, and making them stateful is what enhances
    the user experience of web applications.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to build stateful function components
    with hooks such as `useState`, `useEffect`, `useContext`, `useMemo`, and `useReducer`,
    and even be able to develop your own custom Hooks.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is a Hook in React?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why use Hooks in React?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `useState` to develop stateful components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `useEffect` to create useful side effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `useContext` to manage React applications’ global state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `useRef` to directly access DOM elements and persist state values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `useReducer` for state management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `useMemo` to improve performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `useCallback` to avoid re-rendering functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using custom Hooks for code reusability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The complete code for this chapter is available on GitHub at: [https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter03](https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter03).'
  prefs: []
  type: TYPE_NORMAL
- en: Due to page count constraints, the code blocks have been snipped. Please refer
    to GitHub for the full source code.
  prefs: []
  type: TYPE_NORMAL
- en: What is a Hook in React?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **hook** is a special function provided by React that lets you use React core
    features—state and component lifecycle methods—within a function component. While
    state is an in-built object in React that adds interactivity and dynamic mechanism
    to components, the lifecycle tracks the phases components go through, from their
    initialization to their eventual demise (when a user navigates away or exits from
    an application UI).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three major cyclic phases React components go through, as explained
    in [*Chapter 2*](B18554_02.xhtml#_idTextAnchor038), *Getting Started with React*:
    mounting, updating, and unmounting. Each of these phases has what we call lifecycle
    methods that can be used during the rendering of React components.'
  prefs: []
  type: TYPE_NORMAL
- en: We observed the presence of certain methods, such as `componentWillMount()`,
    `componentDidMount()`, `componentWillUpdate()`, and `componentDidUpdate()`, during
    the class component’s lifecycle. React hooks are used to make function components
    stateful without using class components’ lifecycle methods.
  prefs: []
  type: TYPE_NORMAL
- en: If you were working with stateful components before React version 16.8, you
    had no choice but to use class components as the only way to incorporate statefulness
    into your components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at a component that changes a first name to a full name when a button
    is clicked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us understand the preceding code in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '`import React from ''react''`: This line brings React library core features
    into the scope.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`class App extends React.Component`: This declares our `class App`, which extends
    the React component base class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following snippet defines a constructor that accepts `props` as an argument:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is a normal JavaScript class construct. Any class that extends the base
    class must have a `super()` method defined. The `this.state={name:"Andrew",}`
    part sets the initial state to `Andrew`. This is the state we want to update later
    in the code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following snippet ensures that the function’s `this` context will refer
    to the correct instance of the component when called:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `updateNameState` function is bound to the component instance using `.bind(this)`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following snippet demonstrates the state updater method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It is invoked in our button to set state from `name:"Andrew"` to `name: "``Andrew
    Peter"`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`render()`: This is a compulsory method for every class component in React.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<p>{this.state.name}</p>`: This sets our initial state, which is `Andrew`,
    and returns it for our viewing as JSX.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'According to the following snippet, when the button is clicked, the `updateNameState()`
    class method is invoked and set to an updated state, which is `Andrew Peter`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this chapter, we will refactor the preceding code snippet to a function
    component using a Hook. But before we delve into this, let’s look at two rules
    guiding how we write Hooks in React function components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rule 1**: *Hooks must only be invoked at the* *top level.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can’t call Hooks from inside conditions, loops, or nested functions. Rather,
    you are to always invoke Hooks at the top level of your React function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Rule 2**: *Hooks must only be invoked from a React* *component function.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can’t invoke Hooks from regular JavaScript functions, and neither can you
    invoke Hooks from the class component in React. You can only invoke Hooks from
    functional components. You can also invoke Hooks from custom Hooks.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Why use Hooks in React?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the history of React, Hooks represented a significant shift in how we approach
    stateful components and manage side effects. Prior to Hooks, writing or refactoring
    class components was the primary method to enable components to exhibit interactivity
    and handle other side effects. Components serve as the building blocks of React
    applications’ UIs, and creating interactive interfaces necessitated the use of
    class components.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, for beginners, the class syntax and structure can be challenging to
    understand. Sophie Alpert, former manager of the React team at Facebook, in her
    keynote (*React Today and Tomorrow*) at the *2018 React* *Conference*, said:'
  prefs: []
  type: TYPE_NORMAL
- en: “I claim classes are hard for humans…but it’s not just humans, I claim the classes
    are also hard for machines”
  prefs: []
  type: TYPE_NORMAL
- en: – Sophie Alpert (https://bit.ly/37MQjBD)
  prefs: []
  type: TYPE_NORMAL
- en: The use of `this` and `bind` in class components adds to the list of confusion.
    While JavaScript offers both the world of **Object-Oriented Programming** (**OOP**)
    and that of functional programming, with React class components, you can’t code
    without understanding the OOP paradigm.
  prefs: []
  type: TYPE_NORMAL
- en: This critically underscores the challenges that newcomers to the React world
    face. This was at least the case until React Hooks came into the picture. With
    Hooks, you simply write regular JavaScript functions that are easier to code,
    and you just have to hook into React Hooks for statefulness.
  prefs: []
  type: TYPE_NORMAL
- en: Another reason you might opt for React Hooks is the reusability of stateful
    logic across multiple components. Hooks allow you to separate stateful logic from
    component rendering logic, making it easier to reuse the logic in different components.
  prefs: []
  type: TYPE_NORMAL
- en: This separation ensures better modularity and reusability, as you can share
    your custom Hooks containing stateful logic across different React applications
    and with the broader React community. On the other hand, with class-based components,
    stateful logic and UI are often intertwined, which can make it harder to extract
    and reuse the logic efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: In sum, React Hooks have triggered a new way of thinking about React component
    design. The possibility of gradual adoption in an existing code base (if you are
    still running on legacy React source code), makes it easy for diehard class component
    React developers to continue to write their stateful class components along with
    systematic migration of their code base to a functional-oriented approach.
  prefs: []
  type: TYPE_NORMAL
- en: The future of React is pointed toward functional component architecture. I can’t
    imagine anyone reasonably pursuing class components anymore at this stage. By
    learning about and writing function components, developers can harness the advantages
    of React more effectively.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will start the process of developing a stateful React
    component using Hooks. We will start with the `useState` Hook, the most popular
    React Hook, which brings state to function components.
  prefs: []
  type: TYPE_NORMAL
- en: Using useState to develop stateful components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `useState` Hook allows you to manage state in React applications. Function
    components rely on the `useState` Hook to add state variables to them. State is
    an object in React that can hold data information for use in React components.
    When you make a change to existing data, that change is stored as a state.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how it works: you pass an initial state property to `useState()`, which
    then returns a variable with the current state value and a function to update
    this value. The following is the syntax of the `useState` Hook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s see a simplistic use case of how `useState` works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet shows how you can develop a component that has increment,
    decrement, and reset states. When the `IncrementByTen` button is clicked, the
    counter increases the number by `10` and when the `DecrementByTen` button is clicked,
    the decrement state is activated and the number decreases by `10`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reset to the initial state does what it’s meant to do – it resets the value
    to its initial value. The following completes the code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s understand the preceding code in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Importing `useState`: To use the `useState` Hook function, we first need to
    import it into our component from the `Import React, { useState } from ''react''`
    React object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Initializing `useState`: We initialize our state by calling `useState` in our
    component as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`useState<number>` accepts an initial state of zero (`useState(0)`) and returns
    two values: `count` and `setCount`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`count`: The current state'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setCount`: State updater function (this function is responsible for the new
    state of the initial state)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`useState(0)`: `useState <number>` with the initial value of `0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In `useState`, you can only declare a state property at a time. However, the
    data can be of any type: primitives, arrays, and even objects.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`onClick` event functions are added to help emit event operations for our buttons.
    When the buttons are clicked, different event functions are invoked based on the
    expected actions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`handleIncrementByTen()`, `handleDecrementByTen()`, and `resetCountHandler()`
    functions are used to change the state values, as shown in the following snippet:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`useState<number>` can contain primitive and object data that can be accessed
    across React components. At this point, it is recommended you fire up your VS
    code or your preferred IDE and experiment with `useState` in developing a stateful
    component.'
  prefs: []
  type: TYPE_NORMAL
- en: Passing state as props
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: State is not limited to being used solely within the component where it is defined.
    You can pass state as props to child components, allowing them to display or use
    the parent state data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code shows a React function component with state using the `useState`
    Hook. It consists of two components, `ParentComponent` and `ChildComponent`, and
    demonstrates how to pass state data from the parent component to the child component.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you use `ParentComponent` in your application, it will render with an
    initial `count: number` of `0`. `count: number`, and `ChildComponent`) will also
    display the same value as it receives it via the `count` prop. When you click
    the `count` state will increase by `10`, and both counts will reflect the same
    updated value.'
  prefs: []
  type: TYPE_NORMAL
- en: Conditional rendering with state
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Conditional rendering with state** in React allows you to show or hide specific
    parts of the user interface based on the values of state variables. By using conditionals,
    you can control what content or components are displayed depending on the current
    state of your application.'
  prefs: []
  type: TYPE_NORMAL
- en: This technique can be useful for creating dynamic and interactive user interfaces.
    Imagine having a **Login** button that turns into a **Logout** button once the
    user is logged in. That’s a classic example of conditional rendering! When you
    click the button, React will automatically update the UI to reflect the new state,
    making it super responsive. Oh, and that’s not all!
  prefs: []
  type: TYPE_NORMAL
- en: You can even use this magic to toggle the visibility of different elements,
    such as showing or hiding a cool modal or drop-down menu based on user actions.
    For instance, let’s say you have the `isLoggedIn` state variable, and you want
    to display different content based on whether the user is logged in or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code demonstrates how you can implement this with the `useState`
    Hook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code demonstrates a React component called `Dashboard`. It’s all
    about handling user authentication and showing personalized messages to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `Dashboard` component, we have the `isLoggedIn` state variable, which
    is managed using the `useState` Hook. This variable keeps track of whether the
    user is currently logged in or not. When the component first renders, the initial
    state of `isLoggedIn` is set to false, indicating that the user is not logged
    in.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s dive into the magic of conditional rendering! When you look at the
    JSX inside the `return` statement, you’ll see some interesting stuff happening.
    We use the `{}` curly braces to wrap our conditionals.
  prefs: []
  type: TYPE_NORMAL
- en: If `isLoggedIn` is `true`, we display a `onClick` event that triggers the respective
    `handleLogin` or `handleLogout` function. The fun doesn’t end there!
  prefs: []
  type: TYPE_NORMAL
- en: We also use more conditional rendering with `isLoggedIn` to display a personalized
    message for the user. When `isLoggedIn` is `true`, we show a warm greeting such
    as `handleLogin` function gets called, and guess what?
  prefs: []
  type: TYPE_NORMAL
- en: It sets `isLoggedIn` to `true`, indicating that the user is now logged in! Likewise,
    when the user clicks the `handleLogout` function is triggered, and it sets `isLoggedIn`
    back to `false`, meaning the user is now logged out.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will examine another Hook in React, `useEffect`. It
    is widely used to manipulate the DOM and fetch data from external sources.
  prefs: []
  type: TYPE_NORMAL
- en: Using useEffect to create side effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `useEffect` Hook allows you to fetch data from external sources, update
    the DOM tree, and set up a data subscription. These operations are called side
    effects. In the class component, you have what we call lifecycle methods that
    can execute operations based on the phase of the component-rendering process.
    `useEffect` accepts two arguments: a function and an optional dependency.'
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that `useEffect` does the work of the old `componentDidMount`,
    `componentDidUpdate`, and `componentWillUnmount` in one place. Using the `useEffect`
    Hook shortens the amount of code you have to write in a function component to
    achieve the same side effects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the syntax for the `useEffects` Hook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s dive into an example of using the `useEffect` Hook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we are fetching data from an external API source using
    `useEffect`. For this example, we have used fake API data from `https://dummyjson.com/users`.
    By the time we get to the backend development section of this book ([*Chapter
    9*](B18554_09.xhtml#_idTextAnchor186), *API Development and Documentation*), we
    will be developing custom API endpoints. Next, we will use the `useEffect()` Hook
    to call the `fetchSpeakers` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Refer to GitHub for the full code and have a look at the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: '`import React, { useEffect, useState } from ''react'';`: This line allows us
    to use `useEffect` and `useState` APIs from the React library.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`const [data, setData] = useState([]);`: In this line, we have declared a state
    object set with an empty array as the initial data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`useEffect(()=>{...}, [])`: This part of the code represents a signature set
    that fetches data from the specified external source. The second argument in the
    `useEffect` function, the dependency `[]`, is set to an empty array. The empty
    array ensures `useEffect()` renders just once, the first time, on mounting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To have it render depending on state changes, you would have to pass the state
    through the dependency array. With this, you are able to prevent the constant
    unnecessary re-rendering of the component unless the dependency state changes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`fetchSpeakers():Promise<Speaker[]>` inside the `useEffect` Hook is a call
    to the `fetchSpeakers` function. This function is an asynchronous function that
    fetches data from a mocked remote API and sets the data in the component’s state
    using the `setData` function. The empty dependency array `[]` passed as the second
    argument to `useEffect` indicates that the effect should only run once when the
    component is mounted and never again after that.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since there are no dependencies listed, the effect won’t be triggered by changes
    in any props or state variables. This is why it behaves like the `componentDidMount`
    lifecycle method, as it runs only once when the component is first rendered.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`const API_URL = "https://dummyjson.com/users";`: The `API_URL` variable is
    set to hold the endpoint information about the external source.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `try… catch` code block is set to execute the code and console error if
    there is an error fetching data from the endpoint:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`map()` is set on the data to loop through the object array data and display
    the newly created array from the function invocation on every array element `item:
    Speaker`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let’s update the `useEffect` Hook function of the preceding code and add a state
    to its dependency and a `Cleanup` function. Adding a `Cleanup` function inside
    the `useEffect` hook serves a crucial purpose in React applications.
  prefs: []
  type: TYPE_NORMAL
- en: The `cleanup` function is executed when the component unmounts or when the dependencies
    listed in the `useEffect` hook change. Its main use is to perform cleanup tasks,
    freeing up resources, and preventing potential memory leaks or unexpected behavior
    in the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, update the preceding `useEffect()` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code uses the `useEffect` Hook to fetch data from an API (`fetchSpeakers`)
    and update the data state with the fetched result. It employs an `isMounted` flag
    to prevent setting the state after the component has unmounted, effectively avoiding
    potential issues. The data fetching effect runs whenever the `data` state changes,
    and the `Cleanup` function sets the `isMounted` flag to false when the component
    unmounts.
  prefs: []
  type: TYPE_NORMAL
- en: In sum, we have seen how `useEffect` could be used for side effect operation
    in a function component by fetching data from an external source. Next, we will
    look at how we can use the `useContext` Hook to better manage the global state
    in React applications.
  prefs: []
  type: TYPE_NORMAL
- en: Using useContext to manage global state in React applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `useContext` Hook is used to share application state data across the component
    tree without having to pass props down explicitly at every component level. To
    put it simply, `useContext` is a way to manage React applications’ global state.
    Remember, we used the `useState` Hook to manage local state in the *Using useState
    to develop stateful* *components* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, as React project requirements expand in scope, it will be ineffective
    to use the `useState` Hook alone in passing state data in deeply nested components.
    The following is the syntax for the `useContext` Hook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Briefly, we will discuss *props drilling* to understand the challenges it poses.
    Afterward, we’ll delve into the implementation of the context API, which addresses
    these issues.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding props drilling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s examine how you might pass data as props down a component hierarchy without
    the use of `useContext`. The following code snippet shows how we pass data to
    inner deeply nested components without the use of `useContext`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code displays the name of a speaker in a function comprising nested
    components. The full source code is on GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us understand the code in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '`const [speakerName]= useState`: This line is used to set the default state
    for `speakerName`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<App />` is a parent component that passes state using `{speakerName}` as
    props for the state needed in `<``GrandChildComponent />`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The parent has to pass through the `<ImmediateChildComponent />` component to
    reach `<GrandChildComponent />` nested lower in the hierarchy. This becomes even
    more cumbersome when you have five or more intermediary components before we get
    to the actual component that needs the state information.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This is the problem `useContext` tries to solve. The following code shows the
    intermediate component and the final `GrandChildComponent: React.FC<Props>` where
    the states are required:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let’s now look at how `useContext` can be used to solve the preceding problem
    by maintaining a global state where different components can communicate without
    causing prop drilling issues in React.
  prefs: []
  type: TYPE_NORMAL
- en: Using useContext to solve the props drilling problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With `useContext`, you will understand how you can pass state data across components
    without manually doing so with props. The following code shows how `useContext`
    is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us understand the preceding code in detail. Refer to GitHub for the full
    source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`import React, {useState, useContext,createContext } from ''react'';`: This
    line allows us to make use of `useState`, `useContext`, and `createContext` from
    the React library.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`const context = createContext(null);`: This line creates `Context<ContextType>`
    and allows us to use `Provider:` `React.FC<ProviderProps|null>` with `null` as
    the initial value. Note that the `null` default value could also be any value
    provided to us by the `createContext` function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The context provider envelopes the child component and makes the state values
    available, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`const {speakerName} = useContext(context);`: In this line, we use the `useContext`
    Hook to have access to `context` in `<``GrandChildComponent />`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In sum, the `useContext` Hook enables us to use `context` in function components
    no matter how nested the component hierarchy may be. This is always required in
    complex React applications where the state data may be needed across global application
    states. With `useContext`, we are able to share the information state that was
    passed as props without the direct interference of the intermediate components.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will delve into the `useRef` Hook and explore how it can be effectively
    utilized in a React component.
  prefs: []
  type: TYPE_NORMAL
- en: Using useRef to directly access DOM elements and persist state values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `useRef` Hook allows you to access DOM elements directly in React and is
    used to persist state values across re-renders. React, as a powerful library for
    UI, has a lot of novel concepts (virtual DOM design patterns, event handling,
    attribute manipulation) we can use to access and manipulate DOM elements without
    the use of traditional DOM methods.
  prefs: []
  type: TYPE_NORMAL
- en: This declarative approach to DOM is one of the reasons React is so popular.
    However, with `useRef`, we can directly access DOM elements and freely manipulate
    them without consequence. The team at React felt that with `useRef`, developers’
    present and future cravings for direct DOM access might be met despite the React
    abstraction on top of the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two core uses of `useRef`:'
  prefs: []
  type: TYPE_NORMAL
- en: Accessing DOM elements directly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Persisting state values that do not trigger the re-rendering of React components
    when updated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are interested in how many times a component re-renders upon update,
    we can use either `useState` or `useRef`. But it will be a bad idea to use `useState`.
    Using this might leave users stuck in an infinite loop of re-rendering since `useState`
    re-renders on every update of its values.
  prefs: []
  type: TYPE_NORMAL
- en: However, the `useRef` Hook shines in this scenario as it can store state values
    across components re-rendering without triggering the re-render mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s dive into a use case for `useRef` in the form of autofocusing an input
    field on a rendered component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us understand the preceding code in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '`const inputRef = useRef(null);`: This line creates a reference for the `useRef`
    function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<input ref={inputRef} type="text" />`: In this line, `ref` is added to the
    `input` element to make use of the `useRef()` Hook'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `onClick` event is added to the button, which makes use of `inputRef <button
    onClick={clickButton}>click` to focus on `input</button>`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`useState` and `useRef` are very similar in the sense that they hold state
    values. However, `useState` re-renders each time its values change, while `useRef`
    does not trigger a re-render.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move on to the next Hook, `useReducer`. It is another hook to manage complex
    states in React applications.
  prefs: []
  type: TYPE_NORMAL
- en: Using useReducer for state management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `useReducer` hook is a state management hook in a React application. It
    is quite a bit more robust than the `useState` hook we discussed earlier in this
    chapter as it separates the state management logic in the function component from
    the component-rendering logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `useState` hook encapsulates the state management function with component
    rendering logic, which may become complex to handle in a large React project with
    the need for complex state management. The following is the syntax for `useReducer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `useReducer` hook accepts two arguments – the reducer, which is a function,
    and the initial application state. The Hook then returns two array values – the
    current state and the `Dispatch` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Basically, we need to understand these core concepts in `useReducer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`State`: This refers to mutable data that can be changed over time. `State`
    doesn’t have to be an object; it could also be an array or number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Dispatch`: This is a function that allows us to modify the state. `Dispatch`
    is used to trigger the action that changes the state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Reducer`: This is a function that handles the business logic of how the state
    could be modified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IntialState`: This refers to the initial state of the applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Action`: This is an object with a set of properties. Type is a required property.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Payload`: This refers to the data of interest in a chunk of network data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With these core concepts explained, we also need to understand one more thing:
    the main purpose of `useReducer` is to manage complex multiple states in such
    a way that the logic for state management is separated from the component view
    functionality. We will elaborate more on this with a practical example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s dive in to see the use case for `useReducer`:'
  prefs: []
  type: TYPE_NORMAL
- en: The following snippet will show how you can use `useReducer` to manage different
    state properties. We will be working with an event schedule component. In the
    following code snippet, we are fetching the data from fake JSON API data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `src` directory, create `src/db.json` and paste in this data object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'To install the JSON server for mocking backend services, in the terminal, enter
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Start the server on port `8000` with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the JSON server is started, the following will appear in your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following snippet to `App.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The full source code can be found on GitHub. Let’s examine the code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The initial state properties of the component are first specified:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then, we define the `Reducer` function as `const reducer = (state, action) =>
    {}`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `Reducer` function takes two arguments: `state` and `action`. Then the
    action through the `type` property defines the logic of the state. In this case,
    the switch runs through a series of conditional action-based operations and returns
    a specific action type.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The action-type properties specified in the `reducer` function, for instance,
    `getEventSchedule`, `getEventScheduleSuccess`, and `getEventScheduleFailure`,
    allow us to modify the state of the component based on the state of the action
    type.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`getEventSchedule<EventSchedule[]>` accepts all the properties of `initalState`,
    and the `isLoading` property is set to `true` because we are fetching this state
    data:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`getEventScheduleSuccess` will be invoked when the `data` property is modified
    through the returned data in `action.payload: EventSchedule[]`, and the `isLoading`
    property is set back to `false`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And if there is no returned data, `getEventScheduleFailure` `:Action` is invoked
    and an error is displayed:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `App()` component handles the view part of the component state where `useReducer()`
    is defined and executed:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `useReducer()` accepts two arguments—`reducer` and `initialState`—and returns
    two array variables: `state` and `dispatch`. The `state` variable holds the state
    object and `dispatch` is a function that allows the reducer to update the state
    based on the invoked type of action in the `reducer` function.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`useEffect()` is invoked to fetch the schedule data from the endpoint specified:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `useEffect()` body, `dispatch()` is triggered based on the type
    of action. The object type is specified: `dispatch({` `type:"getEventSchedule"
    });`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`axios()` is invoked to fetch the endpoint data with `axios.get("http://localhost:8000/schedules/")`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When the type of action is `getEventScheduleSuccess`, we expect returned data,
    thus the payload property – `dispatch({ type: "getEventScheduleSuccess", payload:`
    `response.data })`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet handles the error that may occur from this promise-based
    request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `App()` component `return` construct, we render schedules to the screen
    with the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We check whether `initialState :State` is in the loading state and display
    `<div>Loading…</div>`. If the error state is `true`, we display the error. If
    there is no data to fetch, we display the appropriate message. We also check the
    data state and ensure we have data to display. Now, start the server if it’s not
    running, with `npm start`:'
  prefs: []
  type: TYPE_NORMAL
- en: The following screenshot shows an example implementation of `useReducer`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Screenshot showing the effect of the useReducer Hook](img/Figure_3.1_B18554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – Screenshot showing the effect of the useReducer Hook
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how we can use the `useReducer` Hook to manage advanced multiple
    states in React. In the next section, we will examine what `useMemo` is and how
    we can use it to improve performance in React applications.
  prefs: []
  type: TYPE_NORMAL
- en: Using useMemo to improve performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `useMemo` Hook is part of the core APIs in React geared toward improving
    the performance of React applications. It uses a technique known in software development
    as **memoization**.
  prefs: []
  type: TYPE_NORMAL
- en: This is an optimization technique used to enhance the performance of software
    by keeping in memory the results of resource-intensive computation function calls
    and sending back the cached output when the same inputs are used subsequently.
    So, why is `useMemo` important in React application development? `useMemo` solves
    two performance problems for a React developer.
  prefs: []
  type: TYPE_NORMAL
- en: Prevents unnecessary component re-rendering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It memoizes the return value of a function for computations that consume a lot
    of resources by sending back a cached function result upon subsequent requests
    without a state update.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dive into a use case for `useMemo` to better understand how it can be
    used in React. This snippet shows how a component re-renders on every character
    search. With a large application that has over 20,000 users, this could result
    in performance issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we’ll see what the code looks like without `useMemo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the `list` component re-rendering on every character
    search:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – A console showing components re-rendering](img/Figure_3.2_B18554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – A console showing components re-rendering
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go through the implementation of the `useMemo` Hook and gain insights
    into how developers can significantly enhance performance and optimize resource
    usage in React applications, ensuring that expensive computations are only executed
    when necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: '`speakers` is declared to hold the array of object data:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`text` and `searchTerm` are declared with their setter methods as state variables:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`onChange` handler: This event handler updates the initial state to the current
    state:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`filteredSpeakers` function is used to filter an array of speakers based on
    `searchTerm` using a case-insensitive search. With this filtering, you are able
    to optimize the performance of filtering by memoizing the filtered results:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`useMemo`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see in the preceding snippet, the dependency property for the `speaker`
    component hasn’t changed. There is no need for re-rendering, but the console shows
    us that there is re-rendering.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s see what the code looks like with `useMemo`. Update the `filteredSpeakers`
    function in the preceding code with the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The preceding snippet shows the use of `useMemo` on the `filteredSpeakers` function.
    This function only executes once the `searchTerm` state changes. The `filteredSpeakers`
    function is not expected to run when the `text` state changes, because that is
    obviously not a dependency in the dependency array for the `useMemo` Hook.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will explore `useCallback`. The `useCallback` Hook is similar to the
    `useMemo` Hook in making React applications performant. Both `useCallback` and
    `useMemo` optimize React applications. Let’s dive in to understand `useCallback`
    in avoiding the re-rendering of component functions.
  prefs: []
  type: TYPE_NORMAL
- en: Using useCallback to avoid re-rendering functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In React function components, there is an additional optimization Hook called
    `useCallback`. It shares functionality with `useMemo`, with a slight difference
    in output behavior in terms of what is returned. In `useCallback`, a memoized
    function is returned, while `useMemo` returns memoized returned values of the
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like `useMemo`, `useCallback` is invoked when one of its dependencies is updated
    inside the function component. This ensures that the functional components are
    not necessarily re-rendered constantly. There are key highlights for `useCallback`:'
  prefs: []
  type: TYPE_NORMAL
- en: A memoized callback function is returned in `useCallback`. This improves the
    performance of the React application based on memoization techniques.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The change in the dependencies of the `useCallback` Hook determines whether
    it will update or not.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Right now, let’s dive into a simple use case of `useCallback` for deeper understanding.
  prefs: []
  type: TYPE_NORMAL
- en: The following snippet displays a list of speakers to simulate the high computation
    requirements to consider the usage of `useCallback` for performance optimization.
    Also, it is important to note that this illustration is by no means sufficient
    enough as a use case to demonstrate real-life performance bottleneck scenarios,
    but it comes in handy to explain this scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Assuming we have a huge list of `speakers` components to handle displaying and
    searching for speakers, without the use of `useCallback`, we will discover for
    every character search in the input field, `App`, `List`, and `ListItem` will
    be re-rendered needlessly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete snippet can be found at [https://github.com/PacktPublishing/Full-Stack-Flask-and-React/blob/main/Chapter03/08](https://github.com/PacktPublishing/Full-Stack-Flask-and-React/blob/main/Chapter03/08)
    in the book’s GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet demonstrates `useCallback`. The code structure is
    essentially similar to `useMemo`, except that `useCallback` is wrapped around
    the function we intend to cache or memoize.
  prefs: []
  type: TYPE_NORMAL
- en: In the following figure, we see how the `App`, `List`, and `ListItem` components
    re-render with every character search in the search input box.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Screenshot showing the usage of useCallback](img/Figure_3.3_B18554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – Screenshot showing the usage of useCallback
  prefs: []
  type: TYPE_NORMAL
- en: '`handleRemoveSpeaker: React.FC<ButtonProps>` is optimized with `useCallback`
    to prevent the re-rendering of the `List` and `ListItem` components due to a change
    in the state of the search input. The re-rendering of components is expected if
    users of the application click on the **Add a Speaker** or **Remove** buttons.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one major problem the `useCallback` Hook solves in React: preventing
    unnecessary re-rendering of components due to a referential equality check.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will dissect the use of custom Hooks to separate the business logic
    of the component from the rendering function. This allows function reusability
    and a better organization of code in a React application.
  prefs: []
  type: TYPE_NORMAL
- en: Using custom Hooks for code reusability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have extensively discussed some of the in-built Hooks in React. Hooks have
    been part of the core React library since v16.8, which allows React components
    to exhibit statefulness without a class-based approach. Hooks such as `useState`,
    `useEffect`, `UseMemo`, `useRef`, `useContext`, and `useCallback` are specific
    functions to manage state, share stateful logic, and allow other interactions
    with React core APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s understand what a custom Hook is and the benefits we can get from
    using them.
  prefs: []
  type: TYPE_NORMAL
- en: '`use` and that usually invoke one or more in-built React Hooks. For instance,
    custom Hooks could be named anything as long as it starts with *use*, for instance,
    `useCustomHook`, `useFetchSpeakers`, or `useUpdateDatabase`. Conventionally, there
    must be `use` in front of your custom Hook name.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So why should you want to build your own custom Hooks? Let’s examine some of
    the reasons experienced React developers build custom Hooks:'
  prefs: []
  type: TYPE_NORMAL
- en: As a React developer, you are going to write a ton of functions to solve problems
    in your React projects. And if the best React practices are not followed, some
    of those functions are going to be repeated so often in many components of your
    project. With a custom Hook, you can reuse stateful logic across several components
    in your project.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom Hooks encourage the separation of concerns between state logic functions
    and view layers of components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy debugging.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s see an implementation example of custom Hooks:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside `App.js`, enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s break the preceding snippet down:'
  prefs: []
  type: TYPE_NORMAL
- en: '`import useFetchSpeakers from "./useFetchSpeakers"` brings the custom Hook
    into scope in this application. Like any other Hook, we use *use* as part of the
    naming convention.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `useFetchSpeakers` Hook returns the data variable state, based on `API_URL
    : string` passed as the endpoint. This endpoint as an argument is passed to the
    custom `useFetchSpeakers` Hook.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then iterate over the data objects with `map()` to display the returned `firstName:string`
    and `lastName:string`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Inside `useFetchSpeakers.js`, we define the custom Hook function with its locally
    managed state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, the following steps were involved:'
  prefs: []
  type: TYPE_NORMAL
- en: The `useFetchSpeakers` custom Hook signature is defined. It accepts `url` as
    an argument.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `useFetchSpeakers` Hook uses `useEffect()` to asynchronously fetch data
    from an endpoint – the `url` argument passed into the custom Hook.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A promise is returned with *jsonified* result data, which is made available
    to the `setData(data.users)` state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It has a dependency (`url`) that causes the component to re-render the component
    state upon any change in the data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With this, you can see how the custom Hook allows the logic part of the component
    to be separated from the rendering part, and how code reusability is encouraged
    and implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have been able to understand Hooks as a new mind shift in
    how we add statefulness to components in React. Prior to Hooks, only class components
    could offer us stateful functionalities. With React 16.8, we are now able to develop
    stateful functional components in React applications that are more elegant and
    concise.
  prefs: []
  type: TYPE_NORMAL
- en: The learning curve is easy as we can leverage our understanding of regular JavaScript
    functions and develop function components to power user interfaces for our web
    applications. With Hooks in React, user and developer experiences have been greatly
    improved.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will focus extensively on how we can leverage React
    APIs to fetch data from external sources into our web applications. Most of the
    applications we use today rely heavily on external data. Undoubtedly, React shines
    well in this domain.
  prefs: []
  type: TYPE_NORMAL
