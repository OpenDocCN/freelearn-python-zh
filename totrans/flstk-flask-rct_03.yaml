- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Managing State with React Hooks
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用React Hooks管理状态
- en: '[*Chapter 2*](B18554_02.xhtml#_idTextAnchor038), *Getting Started with React*,
    was a great way to kick off React frontend development. By now, you should be
    familiar with project directory structures and a few other concepts in React.
    In this chapter, we will take your understanding of React’s core concepts further.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第2章*](B18554_02.xhtml#_idTextAnchor038)，*React入门*，是启动React前端开发的好方法。到目前为止，你应该熟悉项目目录结构和React中的几个其他概念。在本章中，我们将进一步深化你对React核心概念的理解。'
- en: Why does this matter? Simple. You can’t be the shining light you intend to be
    with React development without getting a grounding in the React core features
    and how we use them. This chapter focuses on managing state with React **Hooks**.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这为什么重要？简单来说，如果你没有掌握React核心功能和它们的使用方法，就无法在React开发中成为你想要的光芒。本章重点介绍使用React **Hooks**
    管理状态。
- en: State in React is the medium through which we add interactivity to the user
    interface. Before React v16.8, developing class components was the only way you
    could add state and state transitions to your components.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: React中的状态是我们添加用户界面交互的媒介。在React v16.8之前，开发类组件是唯一能够为你的组件添加状态和状态转换的方法。
- en: Functional components were stateless; they were only able to display **JavaScript
    XML** (**JSX**) elements, that is, presentational components only. But with the
    Hooks API, you can add state and state transitions to your functional components.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 函数组件最初是无状态的；它们只能显示 **JavaScript XML** （**JSX**）元素，即仅作为展示组件。但通过Hooks API，你可以为你的函数组件添加状态和状态转换。
- en: In this chapter, you will come to understand various React hooks and how we
    use them to add statefulness to functional components. The building blocks of
    any React application are components, and making them stateful is what enhances
    the user experience of web applications.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解各种React Hooks以及我们如何使用它们为函数组件添加状态。任何React应用程序的构建块都是组件，而使它们具有状态性是提升Web应用程序用户体验的关键。
- en: By the end of this chapter, you will be able to build stateful function components
    with hooks such as `useState`, `useEffect`, `useContext`, `useMemo`, and `useReducer`,
    and even be able to develop your own custom Hooks.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够使用如 `useState`、`useEffect`、`useContext`、`useMemo` 和 `useReducer`
    等Hooks构建有状态的函数组件，甚至能够开发你自己的自定义Hooks。
- en: 'In this chapter, we will be covering the following topics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What is a Hook in React?
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React中的Hook是什么？
- en: Why use Hooks in React?
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么要在React中使用Hooks？
- en: Using `useState` to develop stateful components
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `useState` 开发有状态的组件
- en: Using `useEffect` to create useful side effects
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `useEffect` 创建有用的副作用
- en: Using `useContext` to manage React applications’ global state
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `useContext` 管理React应用程序的全局状态
- en: Using `useRef` to directly access DOM elements and persist state values
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `useRef` 直接访问DOM元素并持久化状态值
- en: Using `useReducer` for state management
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `useReducer` 进行状态管理
- en: Using `useMemo` to improve performance
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `useMemo` 提高性能
- en: Using `useCallback` to avoid re-rendering functions
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `useCallback` 避免函数重新渲染
- en: Using custom Hooks for code reusability
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自定义Hooks实现代码复用
- en: Technical requirements
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The complete code for this chapter is available on GitHub at: [https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter03](https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter03).'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完整代码可在GitHub上找到：[https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter03](https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter03).
- en: Due to page count constraints, the code blocks have been snipped. Please refer
    to GitHub for the full source code.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 由于页面数量限制，代码块已被截断。请参阅GitHub以获取完整源代码。
- en: What is a Hook in React?
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React中的Hook是什么？
- en: A **hook** is a special function provided by React that lets you use React core
    features—state and component lifecycle methods—within a function component. While
    state is an in-built object in React that adds interactivity and dynamic mechanism
    to components, the lifecycle tracks the phases components go through, from their
    initialization to their eventual demise (when a user navigates away or exits from
    an application UI).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**Hook** 是React提供的一个特殊函数，它允许你在函数组件中使用React核心功能——状态和组件生命周期方法。虽然状态是React中内置的对象，它为组件添加了交互性和动态机制，但生命周期跟踪组件经历的各个阶段，从它们的初始化到最终消亡（当用户离开或退出应用程序UI时）。'
- en: 'There are three major cyclic phases React components go through, as explained
    in [*Chapter 2*](B18554_02.xhtml#_idTextAnchor038), *Getting Started with React*:
    mounting, updating, and unmounting. Each of these phases has what we call lifecycle
    methods that can be used during the rendering of React components.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: React 组件经历三个主要的循环阶段，如在第 [*2章*](B18554_02.xhtml#_idTextAnchor038) *React 入门*
    中所述：挂载、更新和卸载。每个阶段都有我们所说的生命周期方法，可以在 React 组件的渲染过程中使用。
- en: We observed the presence of certain methods, such as `componentWillMount()`,
    `componentDidMount()`, `componentWillUpdate()`, and `componentDidUpdate()`, during
    the class component’s lifecycle. React hooks are used to make function components
    stateful without using class components’ lifecycle methods.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在类组件的生命周期中观察到某些方法的存在，例如 `componentWillMount()`、`componentDidMount()`、`componentWillUpdate()`
    和 `componentDidUpdate()`。React Hooks 用于使函数组件具有状态，而无需使用类组件的生命周期方法。
- en: If you were working with stateful components before React version 16.8, you
    had no choice but to use class components as the only way to incorporate statefulness
    into your components.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React 版本 16.8 之前，如果你在使用具有状态的组件，你除了使用类组件作为将状态性引入组件的唯一方式外别无选择。
- en: 'Let’s look at a component that changes a first name to a full name when a button
    is clicked:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个在按钮点击时将名字从首字母更改为全名的组件：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let us understand the preceding code in detail:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细理解前面的代码：
- en: '`import React from ''react''`: This line brings React library core features
    into the scope.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`import React from ''react''`：这一行将 React 库的核心功能引入作用域。'
- en: '`class App extends React.Component`: This declares our `class App`, which extends
    the React component base class.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`class App extends React.Component`：这声明了我们的 `class App`，它扩展了 React 组件的基本类。'
- en: 'The following snippet defines a constructor that accepts `props` as an argument:'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下代码片段定义了一个接受 `props` 作为参数的构造函数：
- en: '[PRE1]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is a normal JavaScript class construct. Any class that extends the base
    class must have a `super()` method defined. The `this.state={name:"Andrew",}`
    part sets the initial state to `Andrew`. This is the state we want to update later
    in the code.
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是一个普通的 JavaScript 类构造。任何扩展基本类的类都必须定义一个 `super()` 方法。`this.state={name:"Andrew",}`
    这部分将初始状态设置为 `Andrew`。这是我们想要在代码中稍后更新的状态。
- en: 'The following snippet ensures that the function’s `this` context will refer
    to the correct instance of the component when called:'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下代码片段确保当函数被调用时，函数的 `this` 上下文将指向组件的正确实例：
- en: '[PRE2]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `updateNameState` function is bound to the component instance using `.bind(this)`.
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`updateNameState` 函数使用 `.bind(this)` 绑定到组件实例上。'
- en: 'The following snippet demonstrates the state updater method:'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下代码片段演示了状态更新方法：
- en: '[PRE3]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'It is invoked in our button to set state from `name:"Andrew"` to `name: "``Andrew
    Peter"`.'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '它在按钮中被调用，将状态从 `name:"Andrew"` 更改为 `name: "Andrew Peter"`。'
- en: '`render()`: This is a compulsory method for every class component in React.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`render()`：这是 React 中每个类组件的强制方法。'
- en: '`<p>{this.state.name}</p>`: This sets our initial state, which is `Andrew`,
    and returns it for our viewing as JSX.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<p>{this.state.name}</p>`：这设置了我们的初始状态，即 `Andrew`，并以 JSX 的形式返回它供我们查看。'
- en: 'According to the following snippet, when the button is clicked, the `updateNameState()`
    class method is invoked and set to an updated state, which is `Andrew Peter`:'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据以下代码片段，当按钮被点击时，`updateNameState()` 类方法被调用，并设置为更新后的状态，即 `Andrew Peter`。
- en: '[PRE4]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In this chapter, we will refactor the preceding code snippet to a function
    component using a Hook. But before we delve into this, let’s look at two rules
    guiding how we write Hooks in React function components:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用 Hook 将前面的代码片段重构为函数组件。但在深入探讨之前，让我们看看指导我们在 React 函数组件中编写 Hooks 的两个规则：
- en: '**Rule 1**: *Hooks must only be invoked at the* *top level.*'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规则 1**：*Hooks 只能在* *顶层调用。*'
- en: You can’t call Hooks from inside conditions, loops, or nested functions. Rather,
    you are to always invoke Hooks at the top level of your React function.
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你不能在条件语句、循环或嵌套函数内部调用 Hooks。相反，你应该始终在 React 函数的顶层调用 Hooks。
- en: '**Rule 2**: *Hooks must only be invoked from a React* *component function.*'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规则 2**：*Hooks 只能从 React* *组件函数中调用。*'
- en: You can’t invoke Hooks from regular JavaScript functions, and neither can you
    invoke Hooks from the class component in React. You can only invoke Hooks from
    functional components. You can also invoke Hooks from custom Hooks.
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你不能在常规的 JavaScript 函数中调用 Hooks，同样，你也不能在 React 的类组件中调用 Hooks。你只能从函数组件中调用 Hooks。你也可以从自定义
    Hooks 中调用 Hooks。
- en: Why use Hooks in React?
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么要在 React 中使用 Hooks？
- en: In the history of React, Hooks represented a significant shift in how we approach
    stateful components and manage side effects. Prior to Hooks, writing or refactoring
    class components was the primary method to enable components to exhibit interactivity
    and handle other side effects. Components serve as the building blocks of React
    applications’ UIs, and creating interactive interfaces necessitated the use of
    class components.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React 的历史中，Hooks 代表了我们在处理状态组件和管理副作用方面的方法上的重大转变。在 Hooks 之前，编写或重构类组件是使组件能够表现出交互性和处理其他副作用的主要方法。组件是
    React 应用程序 UI 的构建块，创建交互式界面需要使用类组件。
- en: 'However, for beginners, the class syntax and structure can be challenging to
    understand. Sophie Alpert, former manager of the React team at Facebook, in her
    keynote (*React Today and Tomorrow*) at the *2018 React* *Conference*, said:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于初学者来说，类的语法和结构可能难以理解。Facebook React 团队前经理 Sophie Alpert 在 *2018 React* *大会*
    的主题演讲 (*React 今天和明天*) 中说：
- en: “I claim classes are hard for humans…but it’s not just humans, I claim the classes
    are also hard for machines”
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: “我声称类对人类来说很难……但不仅人类，我还声称类对机器来说也很困难”
- en: – Sophie Alpert (https://bit.ly/37MQjBD)
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: – Sophie Alpert (https://bit.ly/37MQjBD)
- en: The use of `this` and `bind` in class components adds to the list of confusion.
    While JavaScript offers both the world of **Object-Oriented Programming** (**OOP**)
    and that of functional programming, with React class components, you can’t code
    without understanding the OOP paradigm.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在类组件中使用 `this` 和 `bind` 增加了困惑的清单。虽然 JavaScript 提供了面向对象编程（**OOP**）和函数编程的世界，但在
    React 类组件中，如果不理解面向对象范式，就无法编写代码。
- en: This critically underscores the challenges that newcomers to the React world
    face. This was at least the case until React Hooks came into the picture. With
    Hooks, you simply write regular JavaScript functions that are easier to code,
    and you just have to hook into React Hooks for statefulness.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这严重强调了 React 新手面临的挑战。至少在 React Hooks 出现之前是这样的。有了 Hooks，你只需编写常规的 JavaScript 函数，这些函数更容易编写，并且你只需将
    React Hooks 钩入即可实现状态化。
- en: Another reason you might opt for React Hooks is the reusability of stateful
    logic across multiple components. Hooks allow you to separate stateful logic from
    component rendering logic, making it easier to reuse the logic in different components.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能选择 React Hooks 的另一个原因是跨多个组件重用状态逻辑。Hooks 允许你将状态逻辑与组件渲染逻辑分离，这使得在不同组件中重用逻辑变得更加容易。
- en: This separation ensures better modularity and reusability, as you can share
    your custom Hooks containing stateful logic across different React applications
    and with the broader React community. On the other hand, with class-based components,
    stateful logic and UI are often intertwined, which can make it harder to extract
    and reuse the logic efficiently.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这种分离确保了更好的模块化和可重用性，因为您可以将包含状态逻辑的自定义 Hooks 在不同的 React 应用程序以及更广泛的 React 社区中共享。另一方面，在基于类的组件中，状态逻辑和
    UI 往往交织在一起，这可能会使有效地提取和重用逻辑变得更加困难。
- en: In sum, React Hooks have triggered a new way of thinking about React component
    design. The possibility of gradual adoption in an existing code base (if you are
    still running on legacy React source code), makes it easy for diehard class component
    React developers to continue to write their stateful class components along with
    systematic migration of their code base to a functional-oriented approach.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，React Hooks 引发了一种关于 React 组件设计的新思考方式。在现有的代码库中逐步采用的可能性（如果你仍在运行遗留的 React
    源代码），使得坚定的类组件 React 开发者能够继续编写他们的状态类组件，同时系统地将其代码库迁移到面向功能的方案。
- en: The future of React is pointed toward functional component architecture. I can’t
    imagine anyone reasonably pursuing class components anymore at this stage. By
    learning about and writing function components, developers can harness the advantages
    of React more effectively.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: React 的未来指向了函数组件架构。我无法想象在这个阶段，任何合理的人还会追求类组件。通过了解和编写函数组件，开发者可以更有效地利用 React 的优势。
- en: In the next section, we will start the process of developing a stateful React
    component using Hooks. We will start with the `useState` Hook, the most popular
    React Hook, which brings state to function components.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将开始使用 Hooks 开发状态组件的过程。我们将从最受欢迎的 React Hook `useState` 开始，它将状态引入函数组件。
- en: Using useState to develop stateful components
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 useState 开发状态组件
- en: The `useState` Hook allows you to manage state in React applications. Function
    components rely on the `useState` Hook to add state variables to them. State is
    an object in React that can hold data information for use in React components.
    When you make a change to existing data, that change is stored as a state.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`useState` Hook允许你在React应用程序中管理状态。函数组件依赖于`useState` Hook来向它们添加状态变量。状态是React中的一个对象，可以存储用于React组件的数据信息。当你对现有数据进行更改时，该更改被存储为状态。'
- en: 'This is how it works: you pass an initial state property to `useState()`, which
    then returns a variable with the current state value and a function to update
    this value. The following is the syntax of the `useState` Hook:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是这样工作的：你将初始状态属性传递给`useState()`，然后它返回一个包含当前状态值的变量和一个用于更新此值的函数。以下是`useState`
    Hook的语法：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let’s see a simplistic use case of how `useState` works:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`useState`的一个简单用法示例：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding code snippet shows how you can develop a component that has increment,
    decrement, and reset states. When the `IncrementByTen` button is clicked, the
    counter increases the number by `10` and when the `DecrementByTen` button is clicked,
    the decrement state is activated and the number decreases by `10`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段展示了如何开发一个具有增加、减少和重置状态的组件。当点击`IncrementByTen`按钮时，计数器将数字增加`10`，而当点击`DecrementByTen`按钮时，减少状态被激活，数字减少`10`。
- en: 'The reset to the initial state does what it’s meant to do – it resets the value
    to its initial value. The following completes the code snippet:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 重置到初始状态做了它应该做的事情——将值重置为其初始值。以下完成了代码片段：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let’s understand the preceding code in more detail:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地了解前面的代码：
- en: 'Importing `useState`: To use the `useState` Hook function, we first need to
    import it into our component from the `Import React, { useState } from ''react''`
    React object.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入`useState`：要使用`useState` Hook函数，我们首先需要从`Import React, { useState } from 'react'`
    React对象中将其导入到我们的组件中。
- en: 'Initializing `useState`: We initialize our state by calling `useState` in our
    component as follows:'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化`useState`：我们通过在组件中调用`useState`来初始化我们的状态，如下所示：
- en: '[PRE8]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`useState<number>` accepts an initial state of zero (`useState(0)`) and returns
    two values: `count` and `setCount`:'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`useState<number>`接受一个初始状态为零（`useState(0)`）并返回两个值：`count`和`setCount`：'
- en: '`count`: The current state'
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`count`：当前状态'
- en: '`setCount`: State updater function (this function is responsible for the new
    state of the initial state)'
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setCount`：状态更新函数（此函数负责初始状态的新状态）'
- en: '`useState(0)`: `useState <number>` with the initial value of `0`'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useState(0)`：具有初始值`0`的`useState <number>`'
- en: 'In `useState`, you can only declare a state property at a time. However, the
    data can be of any type: primitives, arrays, and even objects.'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`useState`中，你一次只能声明一个状态属性。然而，数据可以是任何类型：原始数据类型、数组，甚至是对象。
- en: '`onClick` event functions are added to help emit event operations for our buttons.
    When the buttons are clicked, different event functions are invoked based on the
    expected actions.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onClick`事件函数被添加以帮助发出按钮的事件操作。当按钮被点击时，将根据预期的操作调用不同的事件函数。'
- en: '`handleIncrementByTen()`, `handleDecrementByTen()`, and `resetCountHandler()`
    functions are used to change the state values, as shown in the following snippet:'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`handleIncrementByTen()`、`handleDecrementByTen()`和`resetCountHandler()`函数用于更改状态值，如下面的代码片段所示：'
- en: '[PRE9]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`useState<number>` can contain primitive and object data that can be accessed
    across React components. At this point, it is recommended you fire up your VS
    code or your preferred IDE and experiment with `useState` in developing a stateful
    component.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`useState<number>`可以包含原始数据和对象数据，这些数据可以在React组件之间访问。在此阶段，建议你启动你的VS code或你喜欢的IDE，并在开发有状态的组件时实验`useState`。'
- en: Passing state as props
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将状态作为props传递
- en: State is not limited to being used solely within the component where it is defined.
    You can pass state as props to child components, allowing them to display or use
    the parent state data.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 状态不仅限于在定义它的组件内使用。你可以将状态作为props传递给子组件，允许它们显示或使用父组件的状态数据。
- en: 'Let’s consider the following example:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下示例：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The preceding code shows a React function component with state using the `useState`
    Hook. It consists of two components, `ParentComponent` and `ChildComponent`, and
    demonstrates how to pass state data from the parent component to the child component.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码展示了使用`useState` Hook的React函数组件。它由两个组件组成，`ParentComponent`和`ChildComponent`，并演示了如何从父组件传递状态数据到子组件。
- en: 'When you use `ParentComponent` in your application, it will render with an
    initial `count: number` of `0`. `count: number`, and `ChildComponent`) will also
    display the same value as it receives it via the `count` prop. When you click
    the `count` state will increase by `10`, and both counts will reflect the same
    updated value.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '当你在应用程序中使用 `ParentComponent` 时，它将以初始的 `count: number` 值 `0` 渲染。`count: number`，并且
    `ChildComponent`）也会显示它通过 `count` 属性接收到的相同值。当你点击按钮时，`count` 状态会增加 `10`，并且两个计数都会反映相同的更新值。'
- en: Conditional rendering with state
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 条件渲染与状态
- en: '**Conditional rendering with state** in React allows you to show or hide specific
    parts of the user interface based on the values of state variables. By using conditionals,
    you can control what content or components are displayed depending on the current
    state of your application.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用状态进行条件渲染** 在 React 中允许您根据状态变量的值显示或隐藏用户界面的特定部分。通过使用条件语句，您可以控制根据应用程序的当前状态显示哪些内容或组件。'
- en: This technique can be useful for creating dynamic and interactive user interfaces.
    Imagine having a **Login** button that turns into a **Logout** button once the
    user is logged in. That’s a classic example of conditional rendering! When you
    click the button, React will automatically update the UI to reflect the new state,
    making it super responsive. Oh, and that’s not all!
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术对于创建动态和交互式用户界面非常有用。想象一下，有一个 **登录** 按钮一旦用户登录就会变成 **注销** 按钮。这是一个经典的条件渲染例子！当你点击按钮时，React
    会自动更新 UI 以反映新的状态，使其非常响应。哦，还有更多！
- en: You can even use this magic to toggle the visibility of different elements,
    such as showing or hiding a cool modal or drop-down menu based on user actions.
    For instance, let’s say you have the `isLoggedIn` state variable, and you want
    to display different content based on whether the user is logged in or not.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以使用这种魔法来切换不同元素的可见性，例如根据用户操作显示或隐藏一个酷炫的模态框或下拉菜单。例如，假设你有 `isLoggedIn` 状态变量，并且你想根据用户是否登录显示不同的内容。
- en: 'The following code demonstrates how you can implement this with the `useState`
    Hook:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了如何使用 `useState` 钩子实现这一点：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding code demonstrates a React component called `Dashboard`. It’s all
    about handling user authentication and showing personalized messages to the user.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了一个名为 `Dashboard` 的 React 组件。它主要关于处理用户身份验证并向用户显示个性化消息。
- en: Inside the `Dashboard` component, we have the `isLoggedIn` state variable, which
    is managed using the `useState` Hook. This variable keeps track of whether the
    user is currently logged in or not. When the component first renders, the initial
    state of `isLoggedIn` is set to false, indicating that the user is not logged
    in.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Dashboard` 组件内部，我们有 `isLoggedIn` 状态变量，该变量使用 `useState` 钩子进行管理。该变量跟踪用户是否当前已登录。当组件首次渲染时，`isLoggedIn`
    的初始状态设置为 `false`，表示用户尚未登录。
- en: Now, let’s dive into the magic of conditional rendering! When you look at the
    JSX inside the `return` statement, you’ll see some interesting stuff happening.
    We use the `{}` curly braces to wrap our conditionals.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入探索条件渲染的魔法！当你查看 `return` 语句内部的 JSX 时，你会看到一些有趣的事情发生。我们使用 `{}` 括号来包裹我们的条件语句。
- en: If `isLoggedIn` is `true`, we display a `onClick` event that triggers the respective
    `handleLogin` or `handleLogout` function. The fun doesn’t end there!
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `isLoggedIn` 为 `true`，我们将显示一个触发相应 `handleLogin` 或 `handleLogout` 函数的 `onClick`
    事件。乐趣还没有结束！
- en: We also use more conditional rendering with `isLoggedIn` to display a personalized
    message for the user. When `isLoggedIn` is `true`, we show a warm greeting such
    as `handleLogin` function gets called, and guess what?
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用更多的 `isLoggedIn` 条件渲染来显示针对用户的个性化消息。当 `isLoggedIn` 为 `true` 时，我们显示一个温馨的问候，例如
    `handleLogin` 函数被调用，而且你知道吗？
- en: It sets `isLoggedIn` to `true`, indicating that the user is now logged in! Likewise,
    when the user clicks the `handleLogout` function is triggered, and it sets `isLoggedIn`
    back to `false`, meaning the user is now logged out.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 它将 `isLoggedIn` 设置为 `true`，表示用户现在已登录！同样，当用户点击 `handleLogout` 函数被触发时，它将 `isLoggedIn`
    返回到 `false`，意味着用户现在已注销。
- en: In the next section, we will examine another Hook in React, `useEffect`. It
    is widely used to manipulate the DOM and fetch data from external sources.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将检查 React 中的另一个钩子 `useEffect`。它广泛用于操作 DOM 和从外部源获取数据。
- en: Using useEffect to create side effects
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 useEffect 创建副作用
- en: 'The `useEffect` Hook allows you to fetch data from external sources, update
    the DOM tree, and set up a data subscription. These operations are called side
    effects. In the class component, you have what we call lifecycle methods that
    can execute operations based on the phase of the component-rendering process.
    `useEffect` accepts two arguments: a function and an optional dependency.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`useEffect` 钩子允许您从外部源获取数据，更新 DOM 树，并设置数据订阅。这些操作被称为副作用。在类组件中，您有我们所说的生命周期方法，可以根据组件渲染过程的阶段执行操作。`useEffect`
    接受两个参数：一个函数和一个可选的依赖项。'
- en: It is important to note that `useEffect` does the work of the old `componentDidMount`,
    `componentDidUpdate`, and `componentWillUnmount` in one place. Using the `useEffect`
    Hook shortens the amount of code you have to write in a function component to
    achieve the same side effects.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，`useEffect` 在一个地方完成了旧 `componentDidMount`、`componentDidUpdate` 和 `componentWillUnmount`
    的工作。使用 `useEffect` 钩子可以缩短函数组件中编写以实现相同副作用的代码量。
- en: 'The following is the syntax for the `useEffects` Hook:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对 `useEffects` 钩子的语法：
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let’s dive into an example of using the `useEffect` Hook:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入一个使用 `useEffect` 钩子的例子：
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding code, we are fetching data from an external API source using
    `useEffect`. For this example, we have used fake API data from `https://dummyjson.com/users`.
    By the time we get to the backend development section of this book ([*Chapter
    9*](B18554_09.xhtml#_idTextAnchor186), *API Development and Documentation*), we
    will be developing custom API endpoints. Next, we will use the `useEffect()` Hook
    to call the `fetchSpeakers` function.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们正在使用 `useEffect` 从外部 API 源获取数据。对于这个例子，我们使用了来自 `https://dummyjson.com/users`
    的模拟 API 数据。当我们到达这本书的“后端开发”部分（[第 9 章](B18554_09.xhtml#_idTextAnchor186)，*API 开发和文档*）时，我们将开发自定义
    API 端点。接下来，我们将使用 `useEffect()` 钩子调用 `fetchSpeakers` 函数。
- en: 'Refer to GitHub for the full code and have a look at the following points:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考 GitHub 以获取完整代码，并查看以下要点：
- en: '`import React, { useEffect, useState } from ''react'';`: This line allows us
    to use `useEffect` and `useState` APIs from the React library.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`import React, { useEffect, useState } from ''react'';`: 这行代码允许我们使用来自 React
    库的 `useEffect` 和 `useState` API。'
- en: '`const [data, setData] = useState([]);`: In this line, we have declared a state
    object set with an empty array as the initial data.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const [data, setData] = useState([]);`: 在这一行中，我们声明了一个以空数组作为初始数据的对象状态。'
- en: '`useEffect(()=>{...}, [])`: This part of the code represents a signature set
    that fetches data from the specified external source. The second argument in the
    `useEffect` function, the dependency `[]`, is set to an empty array. The empty
    array ensures `useEffect()` renders just once, the first time, on mounting.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useEffect(()=>{...}, [])`: 这部分代码代表一个签名集，用于从指定的外部源获取数据。`useEffect` 函数中的第二个参数，依赖项
    `[]`，被设置为空数组。空数组确保 `useEffect()` 只渲染一次，即在组件挂载时第一次渲染。'
- en: To have it render depending on state changes, you would have to pass the state
    through the dependency array. With this, you are able to prevent the constant
    unnecessary re-rendering of the component unless the dependency state changes.
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要使其根据状态变化进行渲染，您必须通过依赖数组传递状态。这样，您就可以防止组件在没有依赖状态变化的情况下不断进行不必要的重新渲染。
- en: '`fetchSpeakers():Promise<Speaker[]>` inside the `useEffect` Hook is a call
    to the `fetchSpeakers` function. This function is an asynchronous function that
    fetches data from a mocked remote API and sets the data in the component’s state
    using the `setData` function. The empty dependency array `[]` passed as the second
    argument to `useEffect` indicates that the effect should only run once when the
    component is mounted and never again after that.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fetchSpeakers():Promise<Speaker[]>` 在 `useEffect` 钩子内是对 `fetchSpeakers` 函数的调用。这个函数是一个异步函数，它从模拟的远程
    API 获取数据，并使用 `setData` 函数将数据设置在组件的状态中。作为 `useEffect` 的第二个参数传递的空依赖数组 `[]` 指示，该副作用仅在组件挂载时运行一次，之后不再运行。'
- en: Since there are no dependencies listed, the effect won’t be triggered by changes
    in any props or state variables. This is why it behaves like the `componentDidMount`
    lifecycle method, as it runs only once when the component is first rendered.
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于没有列出依赖项，副作用不会由任何属性或状态变量的变化触发。这就是为什么它表现得像 `componentDidMount` 生命周期方法一样，因为它只在组件首次渲染时运行一次。
- en: '`const API_URL = "https://dummyjson.com/users";`: The `API_URL` variable is
    set to hold the endpoint information about the external source.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const API_URL = "https://dummyjson.com/users";`: `API_URL` 变量被设置为保存外部源端点信息。'
- en: 'The `try… catch` code block is set to execute the code and console error if
    there is an error fetching data from the endpoint:'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`try… catch` 代码块被设置为执行代码，并在从端点获取数据出错时在控制台显示错误：'
- en: '[PRE14]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`map()` is set on the data to loop through the object array data and display
    the newly created array from the function invocation on every array element `item:
    Speaker`:'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map()` 被设置在数据上，用于遍历对象数组数据，并在每个数组元素 `item: Speaker` 上调用函数时显示新创建的数组：'
- en: '[PRE15]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Let’s update the `useEffect` Hook function of the preceding code and add a state
    to its dependency and a `Cleanup` function. Adding a `Cleanup` function inside
    the `useEffect` hook serves a crucial purpose in React applications.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新前面代码的 `useEffect` 钩子函数，并为其依赖项添加一个状态和一个 `Cleanup` 函数。在 React 应用程序中，在 `useEffect`
    钩子内添加一个 `Cleanup` 函数起着至关重要的作用。
- en: The `cleanup` function is executed when the component unmounts or when the dependencies
    listed in the `useEffect` hook change. Its main use is to perform cleanup tasks,
    freeing up resources, and preventing potential memory leaks or unexpected behavior
    in the application.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`cleanup` 函数在组件卸载时或在 `useEffect` 钩子中列出的依赖项更改时执行。其主要用途是执行清理任务，释放资源，并防止应用程序中的潜在内存泄漏或意外行为。'
- en: 'Now, update the preceding `useEffect()` as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，按照以下方式更新前面的 `useEffect()`：
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding code uses the `useEffect` Hook to fetch data from an API (`fetchSpeakers`)
    and update the data state with the fetched result. It employs an `isMounted` flag
    to prevent setting the state after the component has unmounted, effectively avoiding
    potential issues. The data fetching effect runs whenever the `data` state changes,
    and the `Cleanup` function sets the `isMounted` flag to false when the component
    unmounts.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码使用 `useEffect` 钩子从 API (`fetchSpeakers`) 获取数据，并使用获取的结果更新数据状态。它使用一个 `isMounted`
    标志来防止在组件卸载后设置状态，从而有效地避免潜在的问题。数据获取效果在 `data` 状态更改时运行，并且当组件卸载时，`Cleanup` 函数将 `isMounted`
    标志设置为 false。
- en: In sum, we have seen how `useEffect` could be used for side effect operation
    in a function component by fetching data from an external source. Next, we will
    look at how we can use the `useContext` Hook to better manage the global state
    in React applications.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，我们已经看到了如何通过从外部源获取数据来使用 `useEffect` 在函数组件中进行副作用操作。接下来，我们将探讨如何使用 `useContext`
    钩子更好地管理 React 应用程序中的全局状态。
- en: Using useContext to manage global state in React applications
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 React 应用程序中使用 useContext 管理全局状态
- en: The `useContext` Hook is used to share application state data across the component
    tree without having to pass props down explicitly at every component level. To
    put it simply, `useContext` is a way to manage React applications’ global state.
    Remember, we used the `useState` Hook to manage local state in the *Using useState
    to develop stateful* *components* section.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`useContext` 钩子用于在组件树中共享应用程序状态数据，而无需在每一层组件级别上显式传递 props。简单来说，`useContext` 是管理
    React 应用程序全局状态的一种方式。记住，我们在 *使用 useState 开发有状态组件* 部分使用了 `useState` 钩子来管理局部状态。'
- en: 'However, as React project requirements expand in scope, it will be ineffective
    to use the `useState` Hook alone in passing state data in deeply nested components.
    The following is the syntax for the `useContext` Hook:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，随着 React 项目要求的范围扩大，仅使用 `useState` 钩子来在深层嵌套组件中传递状态数据将变得无效。以下为 `useContext`
    钩子的语法：
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Briefly, we will discuss *props drilling* to understand the challenges it poses.
    Afterward, we’ll delve into the implementation of the context API, which addresses
    these issues.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 简要来说，我们将讨论 *属性钻取* 以了解它带来的挑战。之后，我们将深入探讨上下文 API 的实现，该 API 解决了这些问题。
- en: Understanding props drilling
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解属性钻取
- en: 'Let’s examine how you might pass data as props down a component hierarchy without
    the use of `useContext`. The following code snippet shows how we pass data to
    inner deeply nested components without the use of `useContext`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考察一下在不使用 `useContext` 的情况下，你如何将数据作为 props 传递到组件层次结构中。以下代码片段展示了在不使用 `useContext`
    的情况下如何将数据传递到深层嵌套的内部组件：
- en: '[PRE18]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The preceding code displays the name of a speaker in a function comprising nested
    components. The full source code is on GitHub.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码在一个包含嵌套组件的函数中显示了演讲者的名字。完整的源代码在 GitHub 上。
- en: 'Let us understand the code in more detail:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地理解这段代码：
- en: '`const [speakerName]= useState`: This line is used to set the default state
    for `speakerName`.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const [speakerName]= useState`：这一行用于设置 `speakerName` 的默认状态。'
- en: '`<App />` is a parent component that passes state using `{speakerName}` as
    props for the state needed in `<``GrandChildComponent />`:'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<App />` 是一个父组件，它使用 `{speakerName}` 作为 props 传递状态，该状态用于 `<GrandChildComponent
    />`：'
- en: '[PRE19]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The parent has to pass through the `<ImmediateChildComponent />` component to
    reach `<GrandChildComponent />` nested lower in the hierarchy. This becomes even
    more cumbersome when you have five or more intermediary components before we get
    to the actual component that needs the state information.
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 父组件必须通过 `<ImmediateChildComponent />` 组件来达到嵌套在层级中更低的 `<GrandChildComponent />`。当你有五个或更多中间组件时，这变得更加繁琐，直到我们到达需要状态信息的实际组件。
- en: 'This is the problem `useContext` tries to solve. The following code shows the
    intermediate component and the final `GrandChildComponent: React.FC<Props>` where
    the states are required:'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '这正是 `useContext` 尝试解决的问题。以下代码显示了中间组件和最终的 `GrandChildComponent: React.FC<Props>`，其中需要状态：'
- en: '[PRE20]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Let’s now look at how `useContext` can be used to solve the preceding problem
    by maintaining a global state where different components can communicate without
    causing prop drilling issues in React.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一下 `useContext` 如何通过维护一个全局状态来解决前面的问题，这样不同的组件可以通信而不会在 React 中引起 prop 钻孔问题。
- en: Using useContext to solve the props drilling problem
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `useContext` 解决 prop 钻孔问题
- en: 'With `useContext`, you will understand how you can pass state data across components
    without manually doing so with props. The following code shows how `useContext`
    is used:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `useContext`，你会了解如何在不手动使用 props 的情况下跨组件传递状态数据。以下代码显示了 `useContext` 的使用方法：
- en: '[PRE21]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let us understand the preceding code in detail. Refer to GitHub for the full
    source code:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细理解前面的代码。请参考 GitHub 以获取完整的源代码：
- en: '`import React, {useState, useContext,createContext } from ''react'';`: This
    line allows us to make use of `useState`, `useContext`, and `createContext` from
    the React library.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`import React, {useState, useContext, createContext } from ''react'';`：这行代码允许我们使用
    React 库中的 `useState`、`useContext` 和 `createContext`。'
- en: '`const context = createContext(null);`: This line creates `Context<ContextType>`
    and allows us to use `Provider:` `React.FC<ProviderProps|null>` with `null` as
    the initial value. Note that the `null` default value could also be any value
    provided to us by the `createContext` function.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const context = createContext(null);`：这行代码创建 `Context<ContextType>` 并允许我们使用
    `Provider:` `React.FC<ProviderProps|null>`，其中 `null` 作为初始值。请注意，`null` 默认值也可以是
    `createContext` 函数提供的任何值。'
- en: 'The context provider envelopes the child component and makes the state values
    available, as follows:'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Context 提供者包围了子组件，并使状态值可用，如下所示：
- en: '[PRE22]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`const {speakerName} = useContext(context);`: In this line, we use the `useContext`
    Hook to have access to `context` in `<``GrandChildComponent />`:'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const {speakerName} = useContext(context);`：在这行代码中，我们使用 `useContext` 钩子来访问
    `<GrandChildComponent />` 中的 `context`：'
- en: '[PRE23]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In sum, the `useContext` Hook enables us to use `context` in function components
    no matter how nested the component hierarchy may be. This is always required in
    complex React applications where the state data may be needed across global application
    states. With `useContext`, we are able to share the information state that was
    passed as props without the direct interference of the intermediate components.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，`useContext` 钩子使我们能够在函数组件中使用 `context`，无论组件层级有多深。这在复杂的 React 应用程序中总是必要的，在这些应用程序中，可能需要在全局应用程序状态中跨状态使用状态数据。使用
    `useContext`，我们能够共享作为 props 传递的信息状态，而无需中间组件的直接干扰。
- en: Next, we will delve into the `useRef` Hook and explore how it can be effectively
    utilized in a React component.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将深入探讨 `useRef` 钩子，并探讨如何在 React 组件中有效地利用它。
- en: Using useRef to directly access DOM elements and persist state values
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `useRef` 直接访问 DOM 元素并持久化状态值
- en: The `useRef` Hook allows you to access DOM elements directly in React and is
    used to persist state values across re-renders. React, as a powerful library for
    UI, has a lot of novel concepts (virtual DOM design patterns, event handling,
    attribute manipulation) we can use to access and manipulate DOM elements without
    the use of traditional DOM methods.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`useRef` 钩子允许你在 React 中直接访问 DOM 元素，并用于在重新渲染之间持久化状态值。React 作为强大的 UI 库，有很多新颖的概念（虚拟
    DOM 设计模式、事件处理、属性操作），我们可以使用这些概念来访问和操作 DOM 元素，而无需使用传统的 DOM 方法。'
- en: This declarative approach to DOM is one of the reasons React is so popular.
    However, with `useRef`, we can directly access DOM elements and freely manipulate
    them without consequence. The team at React felt that with `useRef`, developers’
    present and future cravings for direct DOM access might be met despite the React
    abstraction on top of the DOM.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two core uses of `useRef`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Accessing DOM elements directly
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Persisting state values that do not trigger the re-rendering of React components
    when updated
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are interested in how many times a component re-renders upon update,
    we can use either `useState` or `useRef`. But it will be a bad idea to use `useState`.
    Using this might leave users stuck in an infinite loop of re-rendering since `useState`
    re-renders on every update of its values.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: However, the `useRef` Hook shines in this scenario as it can store state values
    across components re-rendering without triggering the re-render mechanism.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s dive into a use case for `useRef` in the form of autofocusing an input
    field on a rendered component:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let us understand the preceding code in detail:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '`const inputRef = useRef(null);`: This line creates a reference for the `useRef`
    function'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<input ref={inputRef} type="text" />`: In this line, `ref` is added to the
    `input` element to make use of the `useRef()` Hook'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `onClick` event is added to the button, which makes use of `inputRef <button
    onClick={clickButton}>click` to focus on `input</button>`
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`useState` and `useRef` are very similar in the sense that they hold state
    values. However, `useState` re-renders each time its values change, while `useRef`
    does not trigger a re-render.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move on to the next Hook, `useReducer`. It is another hook to manage complex
    states in React applications.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Using useReducer for state management
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `useReducer` hook is a state management hook in a React application. It
    is quite a bit more robust than the `useState` hook we discussed earlier in this
    chapter as it separates the state management logic in the function component from
    the component-rendering logic.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'The `useState` hook encapsulates the state management function with component
    rendering logic, which may become complex to handle in a large React project with
    the need for complex state management. The following is the syntax for `useReducer`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `useReducer` hook accepts two arguments – the reducer, which is a function,
    and the initial application state. The Hook then returns two array values – the
    current state and the `Dispatch` function.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'Basically, we need to understand these core concepts in `useReducer`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '`State`: This refers to mutable data that can be changed over time. `State`
    doesn’t have to be an object; it could also be an array or number.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Dispatch`: This is a function that allows us to modify the state. `Dispatch`
    is used to trigger the action that changes the state.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Reducer`: This is a function that handles the business logic of how the state
    could be modified.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IntialState`: This refers to the initial state of the applications.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Action`: This is an object with a set of properties. Type is a required property.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Payload`: This refers to the data of interest in a chunk of network data.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With these core concepts explained, we also need to understand one more thing:
    the main purpose of `useReducer` is to manage complex multiple states in such
    a way that the logic for state management is separated from the component view
    functionality. We will elaborate more on this with a practical example.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s dive in to see the use case for `useReducer`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: The following snippet will show how you can use `useReducer` to manage different
    state properties. We will be working with an event schedule component. In the
    following code snippet, we are fetching the data from fake JSON API data.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `src` directory, create `src/db.json` and paste in this data object:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To install the JSON server for mocking backend services, in the terminal, enter
    the following command:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Start the server on port `8000` with the following command:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Once the JSON server is started, the following will appear in your terminal:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Add the following snippet to `App.js`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The full source code can be found on GitHub. Let’s examine the code snippet:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'The initial state properties of the component are first specified:'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Then, we define the `Reducer` function as `const reducer = (state, action) =>
    {}`.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `Reducer` function takes two arguments: `state` and `action`. Then the
    action through the `type` property defines the logic of the state. In this case,
    the switch runs through a series of conditional action-based operations and returns
    a specific action type.'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The action-type properties specified in the `reducer` function, for instance,
    `getEventSchedule`, `getEventScheduleSuccess`, and `getEventScheduleFailure`,
    allow us to modify the state of the component based on the state of the action
    type.
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`getEventSchedule<EventSchedule[]>` accepts all the properties of `initalState`,
    and the `isLoading` property is set to `true` because we are fetching this state
    data:'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`getEventScheduleSuccess` will be invoked when the `data` property is modified
    through the returned data in `action.payload: EventSchedule[]`, and the `isLoading`
    property is set back to `false`:'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'And if there is no returned data, `getEventScheduleFailure` `:Action` is invoked
    and an error is displayed:'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `App()` component handles the view part of the component state where `useReducer()`
    is defined and executed:'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `useReducer()` accepts two arguments—`reducer` and `initialState`—and returns
    two array variables: `state` and `dispatch`. The `state` variable holds the state
    object and `dispatch` is a function that allows the reducer to update the state
    based on the invoked type of action in the `reducer` function.'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`useEffect()` is invoked to fetch the schedule data from the endpoint specified:'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Inside the `useEffect()` body, `dispatch()` is triggered based on the type
    of action. The object type is specified: `dispatch({` `type:"getEventSchedule"
    });`.'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`axios()` is invoked to fetch the endpoint data with `axios.get("http://localhost:8000/schedules/")`.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When the type of action is `getEventScheduleSuccess`, we expect returned data,
    thus the payload property – `dispatch({ type: "getEventScheduleSuccess", payload:`
    `response.data })`.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet handles the error that may occur from this promise-based
    request:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the `App()` component `return` construct, we render schedules to the screen
    with the following snippet:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We check whether `initialState :State` is in the loading state and display
    `<div>Loading…</div>`. If the error state is `true`, we display the error. If
    there is no data to fetch, we display the appropriate message. We also check the
    data state and ensure we have data to display. Now, start the server if it’s not
    running, with `npm start`:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: The following screenshot shows an example implementation of `useReducer`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Screenshot showing the effect of the useReducer Hook](img/Figure_3.1_B18554.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – Screenshot showing the effect of the useReducer Hook
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how we can use the `useReducer` Hook to manage advanced multiple
    states in React. In the next section, we will examine what `useMemo` is and how
    we can use it to improve performance in React applications.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Using useMemo to improve performance
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `useMemo` Hook is part of the core APIs in React geared toward improving
    the performance of React applications. It uses a technique known in software development
    as **memoization**.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: This is an optimization technique used to enhance the performance of software
    by keeping in memory the results of resource-intensive computation function calls
    and sending back the cached output when the same inputs are used subsequently.
    So, why is `useMemo` important in React application development? `useMemo` solves
    two performance problems for a React developer.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Prevents unnecessary component re-rendering
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It memoizes the return value of a function for computations that consume a lot
    of resources by sending back a cached function result upon subsequent requests
    without a state update.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dive into a use case for `useMemo` to better understand how it can be
    used in React. This snippet shows how a component re-renders on every character
    search. With a large application that has over 20,000 users, this could result
    in performance issues.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we’ll see what the code looks like without `useMemo`:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The following screenshot shows the `list` component re-rendering on every character
    search:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – A console showing components re-rendering](img/Figure_3.2_B18554.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – A console showing components re-rendering
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go through the implementation of the `useMemo` Hook and gain insights
    into how developers can significantly enhance performance and optimize resource
    usage in React applications, ensuring that expensive computations are only executed
    when necessary:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '`speakers` is declared to hold the array of object data:'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '`text` and `searchTerm` are declared with their setter methods as state variables:'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '`onChange` handler: This event handler updates the initial state to the current
    state:'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '`filteredSpeakers` function is used to filter an array of speakers based on
    `searchTerm` using a case-insensitive search. With this filtering, you are able
    to optimize the performance of filtering by memoizing the filtered results:'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '`useMemo`:'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: As you can see in the preceding snippet, the dependency property for the `speaker`
    component hasn’t changed. There is no need for re-rendering, but the console shows
    us that there is re-rendering.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s see what the code looks like with `useMemo`. Update the `filteredSpeakers`
    function in the preceding code with the following snippet:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The preceding snippet shows the use of `useMemo` on the `filteredSpeakers` function.
    This function only executes once the `searchTerm` state changes. The `filteredSpeakers`
    function is not expected to run when the `text` state changes, because that is
    obviously not a dependency in the dependency array for the `useMemo` Hook.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will explore `useCallback`. The `useCallback` Hook is similar to the
    `useMemo` Hook in making React applications performant. Both `useCallback` and
    `useMemo` optimize React applications. Let’s dive in to understand `useCallback`
    in avoiding the re-rendering of component functions.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Using useCallback to avoid re-rendering functions
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In React function components, there is an additional optimization Hook called
    `useCallback`. It shares functionality with `useMemo`, with a slight difference
    in output behavior in terms of what is returned. In `useCallback`, a memoized
    function is returned, while `useMemo` returns memoized returned values of the
    function.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'Like `useMemo`, `useCallback` is invoked when one of its dependencies is updated
    inside the function component. This ensures that the functional components are
    not necessarily re-rendered constantly. There are key highlights for `useCallback`:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: A memoized callback function is returned in `useCallback`. This improves the
    performance of the React application based on memoization techniques.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The change in the dependencies of the `useCallback` Hook determines whether
    it will update or not.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Right now, let’s dive into a simple use case of `useCallback` for deeper understanding.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: The following snippet displays a list of speakers to simulate the high computation
    requirements to consider the usage of `useCallback` for performance optimization.
    Also, it is important to note that this illustration is by no means sufficient
    enough as a use case to demonstrate real-life performance bottleneck scenarios,
    but it comes in handy to explain this scenario.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Assuming we have a huge list of `speakers` components to handle displaying and
    searching for speakers, without the use of `useCallback`, we will discover for
    every character search in the input field, `App`, `List`, and `ListItem` will
    be re-rendered needlessly.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete snippet can be found at [https://github.com/PacktPublishing/Full-Stack-Flask-and-React/blob/main/Chapter03/08](https://github.com/PacktPublishing/Full-Stack-Flask-and-React/blob/main/Chapter03/08)
    in the book’s GitHub repository:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The preceding code snippet demonstrates `useCallback`. The code structure is
    essentially similar to `useMemo`, except that `useCallback` is wrapped around
    the function we intend to cache or memoize.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: In the following figure, we see how the `App`, `List`, and `ListItem` components
    re-render with every character search in the search input box.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Screenshot showing the usage of useCallback](img/Figure_3.3_B18554.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – Screenshot showing the usage of useCallback
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '`handleRemoveSpeaker: React.FC<ButtonProps>` is optimized with `useCallback`
    to prevent the re-rendering of the `List` and `ListItem` components due to a change
    in the state of the search input. The re-rendering of components is expected if
    users of the application click on the **Add a Speaker** or **Remove** buttons.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one major problem the `useCallback` Hook solves in React: preventing
    unnecessary re-rendering of components due to a referential equality check.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will dissect the use of custom Hooks to separate the business logic
    of the component from the rendering function. This allows function reusability
    and a better organization of code in a React application.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Using custom Hooks for code reusability
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have extensively discussed some of the in-built Hooks in React. Hooks have
    been part of the core React library since v16.8, which allows React components
    to exhibit statefulness without a class-based approach. Hooks such as `useState`,
    `useEffect`, `UseMemo`, `useRef`, `useContext`, and `useCallback` are specific
    functions to manage state, share stateful logic, and allow other interactions
    with React core APIs.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s understand what a custom Hook is and the benefits we can get from
    using them.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '`use` and that usually invoke one or more in-built React Hooks. For instance,
    custom Hooks could be named anything as long as it starts with *use*, for instance,
    `useCustomHook`, `useFetchSpeakers`, or `useUpdateDatabase`. Conventionally, there
    must be `use` in front of your custom Hook name.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: 'So why should you want to build your own custom Hooks? Let’s examine some of
    the reasons experienced React developers build custom Hooks:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: As a React developer, you are going to write a ton of functions to solve problems
    in your React projects. And if the best React practices are not followed, some
    of those functions are going to be repeated so often in many components of your
    project. With a custom Hook, you can reuse stateful logic across several components
    in your project.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom Hooks encourage the separation of concerns between state logic functions
    and view layers of components.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy debugging.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s see an implementation example of custom Hooks:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside `App.js`, enter the following:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, let’s break the preceding snippet down:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '`import useFetchSpeakers from "./useFetchSpeakers"` brings the custom Hook
    into scope in this application. Like any other Hook, we use *use* as part of the
    naming convention.'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `useFetchSpeakers` Hook returns the data variable state, based on `API_URL
    : string` passed as the endpoint. This endpoint as an argument is passed to the
    custom `useFetchSpeakers` Hook.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then iterate over the data objects with `map()` to display the returned `firstName:string`
    and `lastName:string`.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Inside `useFetchSpeakers.js`, we define the custom Hook function with its locally
    managed state:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In the preceding snippet, the following steps were involved:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: The `useFetchSpeakers` custom Hook signature is defined. It accepts `url` as
    an argument.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `useFetchSpeakers` Hook uses `useEffect()` to asynchronously fetch data
    from an endpoint – the `url` argument passed into the custom Hook.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A promise is returned with *jsonified* result data, which is made available
    to the `setData(data.users)` state.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It has a dependency (`url`) that causes the component to re-render the component
    state upon any change in the data.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With this, you can see how the custom Hook allows the logic part of the component
    to be separated from the rendering part, and how code reusability is encouraged
    and implemented.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have been able to understand Hooks as a new mind shift in
    how we add statefulness to components in React. Prior to Hooks, only class components
    could offer us stateful functionalities. With React 16.8, we are now able to develop
    stateful functional components in React applications that are more elegant and
    concise.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: The learning curve is easy as we can leverage our understanding of regular JavaScript
    functions and develop function components to power user interfaces for our web
    applications. With Hooks in React, user and developer experiences have been greatly
    improved.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will focus extensively on how we can leverage React
    APIs to fetch data from external sources into our web applications. Most of the
    applications we use today rely heavily on external data. Undoubtedly, React shines
    well in this domain.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
