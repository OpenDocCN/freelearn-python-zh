- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Backend Views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In all previous chapters, you have seen the server and database side of Odoo.
    In this chapter, you will see the UI side of Odoo. You will learn how to create
    different types of views. Aside from the views, this chapter also covers other
    components, such as action buttons, menus, and widgets, which will help you make
    your application more user-friendly. After completing this chapter, you will be
    able to design the UI of an Odoo backend. Note that this chapter does not cover
    the website part of Odoo; we have a separate chapter (*14*) for that.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a menu item and window actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having an action open a specific view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding content and widgets to a form view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding buttons to forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing parameters to forms and actions – Context
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining filters on record lists – Domain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining list views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining search views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a search filter side panel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing existing views – View inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining document-style forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic form elements using attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining embedded views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying attachments on the side of the form view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining kanban views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Showing kanban cards in columns according to their state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining calendar views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining graph view and pivot view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining the cohort view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining the gantt view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining the activity view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining the map view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter, we will assume that you have a database with the base
    add-on installed and an empty Odoo add-on module where you can add XML code from
    the recipes to a data file referenced in the add-on’s manifest. Refer to [*Chapter
    3*](B20997_03.xhtml#_idTextAnchor083), *Creating Odoo Add-On Modules*, for more
    information on how to activate changes in your add-on.
  prefs: []
  type: TYPE_NORMAL
- en: The technical requirements for this chapter include an online Odoo platform.
  prefs: []
  type: TYPE_NORMAL
- en: All of the code used in this chapter can be downloaded from the GitHub repository
    at [https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter09](https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter09).
  prefs: []
  type: TYPE_NORMAL
- en: Adding a menu item and window actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most obvious way to make a new feature available to users is by adding a
    menu item. When you click on a **Menu** item, something happens. This recipe walks
    you through how to define that something.
  prefs: []
  type: TYPE_NORMAL
- en: We will create a top-level menu and its sub-menu, which will open a list of
    all hostel rooms.
  prefs: []
  type: TYPE_NORMAL
- en: This can also be done using the **web user interface** through the **Settings**
    menu, but we prefer to use XML data files since this is what we’ll have to use
    when creating our add-on modules.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will need a module with a dependency on the `base` module,
    as the `my_hostel` module adds new models to the `hostel.room`. So, if you are
    using an existing module, please add the `base` dependency in the manifest. Alternatively,
    you can grab the initial module from [https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter09/00_initial_module](https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter09/00_initial_module).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In an XML data file of our add-on module, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define an action to be executed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the top-level menu, which will be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Refer to our action in the menu:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If we now upgrade the module, we will see a top-level menu with the label **Hostel
    Room** that opens a sub-menu called **All Hostel Room**. Clicking on that menu
    item will open a list of all hostel rooms.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first XML element, `record model="ir.actions.act_window"`, declares a window
    action to display a list view with all the hostel rooms. We used the most important
    attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name`: To be used as the title for the views opened by the action.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`res_model`: This is the model to be used. We are using `hostel.room`, where
    Odoo stores all `hostel room`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`view_mode`: This lists the view types to make available. It is a comma-separated
    values file of the views type. The default value is `tree, form`, which makes
    a list and form view available. If you just want to show the calendar and form
    views, then the value of `view_mode` should be `calendar, form`. Other possible
    view choices are `kanban`, `graph`, `pivot`, `calendar`, and `cohort`. You will
    learn more about these views in forthcoming recipes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`domain`: This is optional and allows you to set a filter on the records to
    be made available in the views. We will see all of these views in more detail
    in the *Defining filters on record lists – Domain* recipe of this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`context`: This can set values made available to the opened views, affecting
    their behavior. In our example, on new records, we want the room rank’s default
    value to be `1`. This will be covered in more depth in the *Passing parameters
    to forms and actions – Context* recipe of this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`limit`: This sets the default amount of records that can be seen on list views.
    In our example, we have given a limit of `20`, but if you don’t give a `limit`
    value, Odoo will use the default value of `80`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we create the menu item hierarchy from the top-level menu to the clickable
    end menu item. The most important attributes of the `menuitem` element are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name`: This is used as the text that the menu items display. If your menu
    item links to an action, you can leave this out because the action’s name will
    be used in that case.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`parent` (`parent_id` if using the `record` element): This is the XML ID that
    references the parent menu item. Items with no parents are top-level menus.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`action`: This is the XML ID that references the action to be called.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sequence`: This is used to order the sibling menu items.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`groups` (`groups_id` with the `record` tag): This is an optional list of user
    groups that can access the menu item. If empty, it will be available to all users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`web_icon`: This option only works on the top-level menu. It will display an
    icon of your application in the Enterprise edition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Window actions automatically determine the view to be used by looking up views
    for the target model with the intended type (`form`, `tree`, and so on) and picking
    the one with the lowest sequence number. `ir.actions.act_window` and `menuitem`
    are convenient shortcut XML tags that hide what you’re actually doing. If you
    don’t want to use the shortcut XML tags, then you can create a record of the `ir.actions.act_window`
    and `ir.ui.menu` models via the `<record>` tag. For example, if you want to load
    `act_window` with `<record>`, you can do so as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the same way, you can create a `menuitem` instance through `<record>`.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that names used with the `menuitem` shortcut may not map to the field
    names that are used when using a `record` element; `parent` should be `parent_id`
    and `groups` should be `groups_id`.
  prefs: []
  type: TYPE_NORMAL
- en: To build the menu, the web client reads all the records from `ir.ui.menu` and
    infers their hierarchy from the `parent_id` field. The menus are also filtered
    based on user permissions to models and groups assigned to menus and actions.
    When a user clicks on a menu item, its `action` is executed.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Window actions also support a `target` attribute to specify how the view is
    to be presented. The possible choices are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**current**: This is the default and opens the view in the web client’s main
    content area.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**new**: This opens the view in a popup.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`current,` but it opens a form in edit mode and disables the **Action** menu.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fullscreen**: The action will cover the whole browser window, so this will
    overlay the menus, too. Sometimes, this is called **tablet mode**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**main**: This is like **current**, but it also clears out the breadcrumbs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are also some additional attributes available for window actions that
    are not supported by the `ir.actions.act_window` shortcut tag. To use them, we
    must use the `record` element with the following fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`res_id`: If opening a form, you can use it to open a specific record by setting
    its ID here. This can be useful for multi-step wizards or in cases when you have
    to view or edit a specific record frequently.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`search_view_id`: This specifies a specific search view to use for tree and
    graph views.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep in mind that the menu in the top left (or the apps icon in the Enterprise
    version) and the menu in the bar at the top are both made up of menu items. The
    only difference is that the items in the menu in the top left don’t have any parent
    menus, while the ones on the top bar have the respective menu items from the top
    bar as a parent. In the left bar, the hierarchical structure is more obvious.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, bear in mind that for design reasons, the first-level menus will
    open the dropdown menu if your second-level menu has child menus. In any case,
    Odoo will open the first menu item’s action based on the sequence of child menu
    items.
  prefs: []
  type: TYPE_NORMAL
- en: 'Refer to the following to learn more about menus and views:'
  prefs: []
  type: TYPE_NORMAL
- en: The `ir.actions.act_window` action type is the most common action type, but
    a menu can refer to any type of action. Technically, it is the same if you link
    to a client action, a server action, or any other model defined in the `ir.actions.*`
    namespace. It just differs in what the backend makes of the action.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you need just a tiny bit more flexibility in the concrete action to be called,
    look into server actions that return a window action. If you need complete flexibility,
    take a look at the client actions (`ir.actions.client`), which allow you to have
    a completely custom user interface. However, only do this as a last resort as
    you lose a lot of Odoo’s convenient helpers when using them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For a detailed explanation of filters in all of the views, have a look at the
    *Defining filters on record lists – Domain* recipe in this chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having an action open a specific view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Window actions automatically determine the view to be used if none is given,
    but sometimes, we want an action to open a specific view.
  prefs: []
  type: TYPE_NORMAL
- en: We will create a basic form view for the `hostel.room` model, and then we will
    create a new window action specifically to open that form view.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Define the `hostel room` minimal tree and form view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the action from the *Adding a menu item and window action* recipe to
    use a new form view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, if you open your menu and click on a **partner** in the list, you should
    see the very minimal form and tree that we just defined.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This time, we used the generic XML code for any type of record, that is, the
    `record` element with the required `id` and `model` attributes. The `id` attribute
    on the `record` element is an arbitrary string that must be unique for your add-on.
    The `model` attribute refers to the name of the model you want to create. Given
    that we want to create a view, we need to create a record of the `ir.ui.view`
    model. Within this element, you set fields as defined in the model you chose through
    the `model` attribute. For `ir.ui.view`, the crucial fields are `model` and `arch`.
    The `model` field contains the model for which you want to define a view, while
    the `arch` field contains the definition of the view itself. We’ll come to its
    contents in a short while.
  prefs: []
  type: TYPE_NORMAL
- en: The `name` field, while not strictly necessary, is helpful when debugging problems
    with views. So, set it to a string that tells you what this view is intended to
    do. This field’s content is not shown to the user, so you can fill in any technical
    hints that you deem sensible. If you set nothing here, you’ll get a default name
    that contains the model name and view type.
  prefs: []
  type: TYPE_NORMAL
- en: ir.actions.act_window.view
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The second record we defined works in tandem with `act_window`, which we defined
    earlier in the *Adding a menu item and window action* recipe. We already know
    that by setting the `view_id` field there, we can select which view is used for
    the first view mode. However, given that we set the `view_mode` field to the `tree,
    form` view, `view_id` would have to pick a tree view, but we want to set the form
    view, which comes second here.
  prefs: []
  type: TYPE_NORMAL
- en: If you find yourself in a situation like this, use the `ir.actions.act_window.view`
    model, which gives you fine-grained control over which views to load for which
    view type. The first two fields defined here are examples of the generic way to
    refer to other objects; you keep the element’s body empty but add an attribute
    called `ref`, which contains the XML ID of the object you want to reference. So,
    what happens here is we refer to our action from the previous recipe in the `act_window_id`
    field and refer to the view we just created in the `view_id` field. Then, though
    not strictly necessary, we add a sequence number to position this view assignment
    relative to the other view assignments for the same action. This is only relevant
    if you assign views for different view modes by creating multiple `ir.actions.act_window.view`
    records.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Once you define the `ir.actions.act_window.view` records, they take precedence
    over what you filled in the action’s `view_mode` field. So, with the preceding
    records, you won’t see a list at all, but only a form. You should add another
    `ir.actions.act_window.view` record that points to a list view for the `hostel.room`
    model.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we saw in the *Adding a menu item and window action* recipe, we can replace
    `act_window` with `<record>`. If you want to use a custom view, you can follow
    the given syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This example is just an alternative to `act_window`. In the code base of Odoo,
    you will find both types of action.
  prefs: []
  type: TYPE_NORMAL
- en: Adding content and widgets to a form view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The preceding recipe showed how to pick a specific view for an action. Now,
    we’ll demonstrate how to make the form view more useful. In this recipe, we will
    use the **form view** that we defined earlier in the *Having an action open a
    specific view* recipe. In the form view, we will add the widgets and content.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Define the basic structure of the form view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To add a head bar, which is usually used for action buttons and stage pipelines,
    add this inside the form:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add fields to the form, using `group` tags to organize them visually:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, the form should display a top bar with a button and two vertically aligned
    fields, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – Screenshot of the form view](img/B20997_09_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – Screenshot of the form view
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll look at the `arch` field of the `ir.ui.view` model first. First, note
    that views are defined in XML, so you need to pass the `type="xml"` attribute
    for the `arch` field; otherwise, the parser will be confused. It is also mandatory
    that your view definition contains well-formed XML; otherwise, you’ll get an error
    such as “Element odoo has extra content” when you upgrade/install the module.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll now walk through the tags that we used previously and summarize the others
    that are available.
  prefs: []
  type: TYPE_NORMAL
- en: form
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you define a form view, it is mandatory that the first element within the
    `arch` field is a `form` element. This is used internally to derive the record’s
    `type` field.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the following elements, you can use arbitrary HTML within the
    form tag. The algorithm has it that every element unknown to Odoo is considered
    plain HTML and is simply passed through to the browser. Be careful with that,
    as the HTML you fill in can interact with the HTML code the Odoo elements generate,
    which might distort the rendering.
  prefs: []
  type: TYPE_NORMAL
- en: header
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This element is a container for elements that should be shown in a form’s header,
    which is rendered as a white bar. Usually, as in this example, you place action
    buttons here. Alternatively, if your model has a `state` field, you could opt
    for a **status bar**.
  prefs: []
  type: TYPE_NORMAL
- en: button
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `button` element is used to allow the user to trigger an action. Refer to
    the *Adding buttons to forms* recipe for details.
  prefs: []
  type: TYPE_NORMAL
- en: <group>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `<group>` element is Odoo’s main element and is used for organizing content.
    Fields placed within a `<group>` element are rendered with their title, and all
    fields within the same group are aligned so that there’s also a visual indicator
    that they belong together. You can also nest `<group>` elements; this causes Odoo
    to render the contained fields in adjacent columns.
  prefs: []
  type: TYPE_NORMAL
- en: In general, you should use the `<group>` mechanism to display all of your fields
    in the form view and only revert to the other elements, such as `<notebook>`,
    `<label>`, `<newline>`, and more, when necessary.
  prefs: []
  type: TYPE_NORMAL
- en: If you assign the `string` attribute to a group, its content will be rendered
    as a heading for the group.
  prefs: []
  type: TYPE_NORMAL
- en: You should develop the habit of assigning a name to every logical group of fields,
    too. This name is not visible to the user but is very helpful when we override
    views in the following recipes. Keep the name unique within the form definition
    to avoid confusion about which group you refer to. Don’t use the `string` attribute
    for this because the value of the string will eventually change because of translations.
  prefs: []
  type: TYPE_NORMAL
- en: field
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to actually show and manipulate data, your form view should contain
    some `field` elements. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: These have one mandatory attribute, called `name`, which refers to the field’s
    name in the model. Earlier, we offered the user the ability to edit the partner’s
    categories. If we only want to disable the editing feature on a field, we can
    set the `readonly` attribute to `1` or `True`. This attribute may actually contain
    a small subset of Python code, so `readonly="2>1"` will make the field read-only
    too. This also applies to the `invisible` attribute, for which you used to obtain
    a value that is read from the database but is not shown to the user. Later, we’ll
    take a look at which situations this can be used in.
  prefs: []
  type: TYPE_NORMAL
- en: You must have noticed the `widget` attribute in the `categories` field. This
    defines how the data in the field are supposed to be presented to the user. Every
    type of field has a standard widget, so you don’t have to explicitly choose a
    widget. However, several types provide multiple ways of representation, so you
    might opt for something other than the default. As a complete list of available
    widgets would exceed the scope of this recipe, consult **Odoo’s source code**
    to try them out. Take a look at [*Chapter 14*](B20997_14.xhtml#_idTextAnchor734),
    *CMS Website Development*, for details on how to make your own.
  prefs: []
  type: TYPE_NORMAL
- en: <notebook> and <page>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If your model has too many fields, then you can use the `<notebook>` and `<page>`
    tags to create tabs. Each `<page>` in the `<notebook>` tag will create a new tab,
    and the content inside the page will be the tab content. The following example
    will create two tabs with three fields in each tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `string` attribute in the `<page>` tag will be the name of the tab. You
    can only use `<page>` tags in the `<notebook>` tag, but in the `<page>` tag, you
    can use any other elements.
  prefs: []
  type: TYPE_NORMAL
- en: General attributes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'On most elements (this includes `group`, `field`, and `button`), you can set
    the `attributes` and `groups` attributes. Here is a small example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: While `attributes` are discussed in the *Dynamic form elements using attributes*
    recipe, the `groups` attribute gives you the possibility to show some elements
    only to members of certain groups. Simply put, the group’s full XML ID (separated
    by commas for multiple groups) is the attribute, and the element will be hidden
    for everyone who is not a member of at least one of the groups mentioned.
  prefs: []
  type: TYPE_NORMAL
- en: Other tags
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are situations in which you might want to deviate from the strict layout
    groups prescribed. For example, if you want the `name` field of a record to be
    rendered as a heading, the field’s label will interfere with the appearance. In
    this case, don’t put your field into a `group` element but, instead, put it into
    a plain HTML `h1` element. Then, before the `h1` element, put a `label` element
    with the `for` attribute set to your `field name`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This will be rendered with the field’s content as a big heading, but the field’s
    name will be written in a smaller type above the big heading. This is basically
    what the standard partner form does.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need a line break within a group, use the `newline` element. It’s always
    empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Another useful element is `footer`. When you open a form as a popup, this is
    a good place to put the action buttons. It will be rendered as a separate bar
    too, analogous to the `header` element.
  prefs: []
  type: TYPE_NORMAL
- en: 'The form view also has special widgets, such as `web_ribbon`. You can use it
    with the `<widget>` tag as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You can use `attributes` to hide and show the ribbon based on a condition. Don’t
    worry if you are not aware of `attributes`. It will be covered in the *Dynamic
    form elements using attributes* recipe of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Don’t address `string` attribute (or any other translated attribute, for that
    matter), as your view overrides will break for other languages because views are
    translated before inheritance is applied.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since form views are basically HTML with some extensions, Odoo also makes extensive
    use of CSS classes. Two very useful ones are `oe_read_only` and `oe_edit_only`.
    Elements with these classes will be visible only in **read-only mode** or **edit
    mode**, respectively. For example, to have the label visible only in edit mode,
    use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Another very useful class is `oe_inline`, which you can use on fields to make
    them render as an inline element to avoid causing unwanted line breaks. Use this
    class when you embed a field into text or other markup tags.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, the `form` element can have the `create`, `edit`, and `delete`
    attributes. If you set one of these to `false`, the corresponding action ’on’t
    be available for this form. Without this being explicitly set, the availability
    of the action is inferred from the u’er’s permissions. Note that this is purely
    for straightening up the UI; ’on’t use this for security.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The widgets and views already offer a lot of functionality, but sooner or later,
    you will have requirements that cannot be fulfilled with the existing widgets
    and views. Refer to the following recipes to create your own views and widgets:'
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the *Adding buttons to forms* recipe in this chapter for more details
    about using the `button` element to trigger an action.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To define your own widgets, refer to the *Creating custom widgets* recipe of
    [*Chapter 15*](B20997_15.xhtml#_idTextAnchor861), *Web* *Client Development*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refer to the *Creating a new view* recipe of [*Chapter 15*](B20997_15.xhtml#_idTextAnchor861),
    *Web Client Development*, to create your own view.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding buttons to forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`header` element.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add a button that refers to an action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The button’s `type` attribute determines the semantics of the other fields,
    so we’ll first take a look at the possible values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`action`: This makes the button call an action, as defined in the `ir.actions.*`
    namespace. The `name` attribute needs to contain the action’s database ID, which
    you can conveniently have Odoo look up with a Python-format string that contains
    the XML ID of the action in question.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`object`: This calls a method from the current model. The `name` attribute
    contains the function’s name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`string`: The `string` attribute is used to assign the text the user sees.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `btn-primary` CSS classes to render highlighted button and `btn-default`
    to render a normal button. This is commonly used for cancel buttons in wizards
    or to offer secondary actions in a visually unobtrusive way. Setting the `oe_link`
    class causes the button to look like a link. You can also use other bootstrap
    button classes to get different button colors.
  prefs: []
  type: TYPE_NORMAL
- en: A call with a button of the **object** type can return a dictionary that describes
    an action, which will then be executed on the client side. This way, you can implement
    multiscreen wizards or just open another record.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Note that clicking on a button always causes the client to issue a `write` or
    `create` call before running the method.
  prefs: []
  type: TYPE_NORMAL
- en: You can also add content within the `button` tag by replacing the `string` attribute.
    This is commonly used in button boxes, as described in the *Document style* *forms*
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Passing parameters to forms and actions – context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Internally, every method in Odoo has access to a dictionary called **context**,
    which is propagated from every action to the methods involved in delivering that
    action. The UI also has access to it, and it can be modified in various ways by
    setting values in the context. In this recipe, we’ll explore some of the applications
    of this mechanism by toying with the language, default values, and implicit filters.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While not strictly necessary, this recipe will be more fun if you install the
    French language if you haven’t got this already. Consult [*Chapter 11*](B20997_11.xhtml#_idTextAnchor595),
    *Internationalization*, for how to do this. If you have a French database, change
    `fr_FR` to some other language, e.g., `en_US` will do for English. Additionally,
    click on the **Active** button (changing to **Archive** when you hover over it)
    for one of the hostel rooms in order to archive it and verify that this partner
    doesn’t show up in the list anymore.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new action, very similar to the one from the *Adding a menu item and
    window* *action* recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add a menu that calls this action. This is left as an exercise for the reader.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you open this menu, the views will show up in French, and if you create
    a new partner, they will have French as their pre-selected language. A less obvious
    difference is that you will also see **deactivated (archived)** **partner records**.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The context dictionary is populated from several sources. First, some values
    from the current user’s record (`lang` and `tz` for the user’s language and the
    user’s time zone, respectively) are read. Then, we have some add-ons that add
    keys for their own purposes. Furthermore, the UI adds keys about which model and
    which record we’re busy using at the moment (`active_id`, `active_ids`, `active_model`).
    Moreover, as seen in the *Having an action open a specific view* recipe, we can
    add our own keys in actions. These are merged together and passed to the underlying
    server functions and the client-side UI.
  prefs: []
  type: TYPE_NORMAL
- en: So, by setting the `lang` context key, we force the display language to be **French**.
    You will note that this doesn’t change the whole UI language; this is because
    only the list view that we open lies within the scope of this context. The rest
    of the UI was loaded already with another context that contained the user’s original
    language. However, if you open a record in this list view, it will be presented
    in French, too, and if you open a linked record on the form or press a button
    that executes an action, the language will be propagated, too.
  prefs: []
  type: TYPE_NORMAL
- en: 'By setting `default_lang`, we set a default value for every record created
    within the scope of this context. The general pattern is `default_$fieldname:
    my_default_value`, which enables you to set default values for newly created partners
    in this case. Given that our menu is about hostel rooms, we have added `default_room_rating:
    1` as the value for the `Hostel Average Rating` field by default. However, this
    is a model-wide default for `hostel.room`, so this wouldn’t have changed anything.
    For scalar fields, the syntax for this is the same as what you would write in
    Python code: `string` fields go in quotes, `number` fields stay as they are, and
    `Boolean` fields are either `True` or `False`. For relational fields, the syntax
    is slightly more complicated; refer to [*Chapter 6*](B20997_06.xhtml#_idTextAnchor319),
    *Managing Module Data*, to learn how to write them.'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Note that the default values set in the context override the default values
    set in the model definition, so you can have different default values in different
    situations.
  prefs: []
  type: TYPE_NORMAL
- en: The last key is `active_test`, which has very special semantics. For every model
    that has a field called `active`, Odoo automatically filters out records where
    this field is `False`. This is why the partner from where you unchecked this field
    disappeared from the list. By setting this key, we can suppress this behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: This is useful for the UI in its own right but even more useful in your Python
    code when you need to ensure that an operation is applied to all the records,
    not just the active ones.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When defining a context, you have access to some variables, with the most important
    one being `uid`, which evaluates the current user’s ID. You’ll need this to set
    default filters (refer to the next recipe, *Defining filters on record lists –
    Domain*). Furthermore, you have access to the `context_today` function and the
    `current_date` variable, where the first is a `date` object that represents the
    current date, as seen from the user’s time zone, and the latter is the current
    date, as seen in UTC, formatted as `YYYY-MM-DD`. To set a default value for a
    `date` field to the current date, use `current_date`, and for default filters,
    use `context_today()`.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, you can do some date calculations with a subset of Python’s `datetime`,
    `time`, and `relativedelta` classes.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Most of the domains are evaluated on the client side. The server-side domain
    evaluation is restricted for security reasons. When client-side evaluation was
    introduced, the best option in order to not break the whole system was to implement
    a part of Python in JavaScript. There is a small JavaScript Python interpreter
    built into Odoo that works well for simple expressions, and that is usually enough.
  prefs: []
  type: TYPE_NORMAL
- en: Beware of the use of the `context` variable in the `<record id="action_name"
    model="ir.actions.act_window.view">` shortcut. These are evaluated at installation
    time, which is nearly never what you want. If you need variables in your context,
    use the `<record />` syntax.
  prefs: []
  type: TYPE_NORMAL
- en: We can also add different contexts for the buttons. It works the same way as
    how we added context keys to our action. This causes the function or action that
    the button calls to be run in the context given.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most form element attributes that are evaluated as Python also have access
    to the context dictionary. The `invisible` and `readonly` attributes are examples
    of these. So, in cases where you want an element to show up in a form sometimes
    but not at other times, set the `invisible` attribute to `context.get(''my_key'')`.
    For actions that lead to a case in which the field is supposed to be invisible,
    set the context key to `my_key: True`. This strategy enables you to adapt your
    form without having to rewrite it for different occasions.'
  prefs: []
  type: TYPE_NORMAL
- en: You can also set a context for relational fields, which influences how the field
    is loaded. By setting the `form_view_ref` or `tree_view_ref` keys to the full
    XML ID of a view, you can select a specific view for this field. This is necessary
    when you have multiple views of the same type for the same object. Without this
    key, you get the view with the lowest sequence number, which might not always
    be desirable.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The context is also used to set a default search filter. You can learn more
    about the default search filter in the *Defining search views* recipe of this
    chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more details on setting default recipes, refer to the next recipe, *Defining
    filters on record lists –* *Domain*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To learn how to install the French language, consult [*Chapter* *11*](B20997_11.xhtml#_idTextAnchor595),
    *Internationalization*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can refer to [*Chapter 6*](B20997_06.xhtml#_idTextAnchor319), *Managing
    Module Data* to learn how to write the syntax for relational fields.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining filters on record lists – domain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve already seen an example of a domain in the first recipe of this chapter,
    which was `[('state', '=', 'draft')]`. Often, you need to display a subset of
    all available records from an action or allow only a subset of possible records
    to be the target of a `many2one` relation. The way to describe these filters in
    Odoo is by using domains. This recipe illustrates how to use a domain to display
    a selection of partners.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To display a subset of partners from your action, you need to perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an action for when “state” is set to “draft:”
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add menus that call these actions. This is left as an exercise for the reader.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The simplest form of a domain is a list of three tuples that contain a field
    name (of the model in question) as `string` in the first element, an operator
    as `string` in the second element, and the value that the field is to be checked
    against as the third element. This is what we did before, and this is interpreted
    as, “*All those conditions have to apply to the records we’re interested in*.”
    This is actually a shortcut because the domains know the two prefix operators—`&`
    and `|`—where `&` is the default. So, in normalized form, the first domain will
    be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'While these can be a bit hard to read for bigger expressions, the advantage
    of prefix operators is that their scope is rigidly defined, which saves you from
    having to worry about operator precedence and brackets. It’s always two expressions:
    the first `&` applies to `''&'',(''state'', ''='', ''draft'')`, with `(''room_rating'',
    ''&gt;'', ''0.0'')` as the first operand and `(''room_rating'', ''&gt;'', ''0.0'')`
    as the second. Then, we have the first operand and `(''room_rating'', ''&gt;'',
    ''0.0'')` as the second.'
  prefs: []
  type: TYPE_NORMAL
- en: In the second step, we have to write out the full form because we need the `|`
    operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, say we have a complex domain such as this: `[''|'',` `(''user_id'',`
    `''='', uid), ''&'', (''lang'', ''!='', ''fr_FR''), ''|'', (''phone'', ''='',
    False), (''email'', ''='', False)]`. See the following figure to learn about how
    this domain is evaluated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – The evaluation of a domain](img/B20997_09_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – The evaluation of a domain
  prefs: []
  type: TYPE_NORMAL
- en: There is also a `!` operator for negation, but given logical equivalences and
    negated comparison operators such as `!=` and `not in`, it is not really necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Note that this is a unary prefix operator, so it only applies to the following
    expression in the domain and not to everything that follows.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the right operand doesn’t need to be a fixed value when you write
    a domain for a window action or other client-side domains. You can use the same
    minimal Python as is used in the *Passing parameters to forms and actions – Context*
    recipe, so you can write filters such as **changed last week** or **my partners**.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The preceding domains work only for the fields of the model itself, while we
    often need to filter based on the properties of linked records. To do this, you
    can use the notation that’s also used in `@api.depends` definitions or related
    fields: create a dotted path from the current model to the model you want to filter
    for. To search partners that have a salesperson who is a member of a group starting
    with the letter `G`, you would use the `[(''user_id.groups_id.name'', ''=like'',
    ''G%'')]` domain. The path can be long, so you only have to be sure that there
    are relation fields between the current model and the model you want to filter
    for.'
  prefs: []
  type: TYPE_NORMAL
- en: Operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following table lists the available operators and their semantics:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 9.1 – Operators and their semantics](img/Table_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Table 9.1 – Operators and their semantics
  prefs: []
  type: TYPE_NORMAL
- en: Note that some of the operators work only with certain fields and values. For
    example, the domain `[('category_id', 'in', 1)]` is invalid and will generate
    an error, while the domain `[('category_id', 'in', [1])]` is valid.
  prefs: []
  type: TYPE_NORMAL
- en: Pitfalls of searching using domains
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This all works fine for traditional fields, but a notorious problem is searching
    for the value of a non-stored function field. People often omit the search function.
    This is simple enough to fix by providing the search function in your own code,
    as described in [*Chapter 4*](B20997_04.xhtml#_idTextAnchor118), *Application
    Models*.
  prefs: []
  type: TYPE_NORMAL
- en: Another issue that might baffle developers is Odoo’s behavior when searching
    through `one2many` or `many2many` fields with a negative operator. Imagine that
    you have a partner with the `A` tag, and you search for `[('category_id.name',
    '!=', 'B')]`. Your partner shows up in the result, and this is what you expected,
    but if you add the `B` tag to this partner, it still shows up in your results
    because, for the search algorithm, it is enough that there is one linked record
    (`A` in this case) that does not fulfill the criterion. Now, if you remove the
    `A` tag so that `B` is the only tag, the partner will be filtered out. If you
    also remove the `B` tag so that the partner has no tags, it is still filtered
    out because the conditions of the linked records presuppose the existence of this
    record. In other situations, though, this is the behavior you want, so it is not
    really an option to change the standard behavior. If you need a different behavior
    here, provide a search function that interprets the negation the way you need.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: People often forget that they are writing XML files when it comes to domains.
    You need to escape the less-than operator. Searching for records that have been
    created before the current day will have to be written as `[('create_date', '&lt;',
    current_date)]` in XML.
  prefs: []
  type: TYPE_NORMAL
- en: Domains are used widely in Odoo. You will find them everywhere in Odoo; they
    are used for searching, filtering, security rules, search views, user actions,
    and more.
  prefs: []
  type: TYPE_NORMAL
- en: If you ever need to manipulate a domain that you didn’t create programmatically,
    use the utility functions provided in `odoo.osv.expression`. The `is_leaf`, `normalize_domain`,
    `AND`, and `OR` functions will allow you to combine domains exactly the way that
    Odoo does. Don’t do this yourself because there are many corner cases that you
    have to take into account, and it is likely that you’ll overlook one.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the standard application of domains, see the *Defining search* *views* recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining list views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After having spent quite some time on the form view, we’ll now take a quick
    look at how to define list views. Internally, these are called tree views in some
    places and list views in others, but given that there is another construction
    within the Odoo view framework called **tree**, we’ll stick to **list** here.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Define your list view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Register a tree view in the action that we created in the *Adding a menu item
    and window action* recipe of this chapter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add menus that call these actions. This is left as an exercise for the reader.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Install**/**Upgrade** the module. After that, you will see our tree view
    for the hostel room, and if you check it, it will show different row styles based
    on our conditions.'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You already know most of what happens here. We define a view, using the `tree`
    type this time, and attach it to our action with an `ir.actions.act_window.view`
    element. So, the only thing left to discuss is the `tree` element and its semantics.
    With a list, you don’t have many design choices, so the only valid children of
    this element are the `field` and `button` elements. You can also use some widgets
    in the list view; in our example, we have used the `many2one_avatar_user` widget.
    The tree view has the support of a special widget called `handle`. This is specific
    to list views. It is meant for integer fields and renders a drag handle that the
    user can use to drag a row to a different position in the list, thereby updating
    the field’s value. This is useful for sequence or priority fields.
  prefs: []
  type: TYPE_NORMAL
- en: By using the `optional` attribute, you can show fields optionally. Adding the
    `optional` attribute to a field will allow the user to hide and show the column
    at any time from the UI. In our example, we have used it for the `country` and
    `state` fields.
  prefs: []
  type: TYPE_NORMAL
- en: What is new here are the `decoration` attributes in the `tree` element. This
    contains rules as to which font and/or color is chosen for the row, given in the
    form of `decoration-$name="Python code"`. We made these invisible because we only
    need the data and don’t want to bother our users with the two extra columns. The
    possible classes are `decoration-bf` (bold) and `decoration-it` (italic), and
    the semantic bootstrap classes are `decoration-danger`, `decoration-info`, `decoration-muted`,
    `decoration-primary`, `decoration-success`, and `decoration-warning`.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For numeric fields, you can add a `sum` attribute that causes this column to
    be summed up with the text you set in the attribute as a tooltip. Less common
    are the `avg`, `min`, and `max` attributes, which display the average, minimum,
    and maximum, respectively. Note that these four only work on the records that
    are currently visible, so you might want to adjust the action’s `limit` (covered
    earlier in the *Adding a menu item and window action* recipe) in order for the
    user to see all the records immediately.
  prefs: []
  type: TYPE_NORMAL
- en: A very interesting attribute for the `tree` element is `editable`. If you set
    this to top or bottom, the list behaves entirely differently. Without it, clicking
    on a row opens a form view for the row. With it, clicking on a row makes it editable
    inline, with the visible fields rendered as form fields. This is particularly
    useful in embedded list views, which are discussed later in the *Defining embedded
    views* recipe of this chapter. The choice of top or bottom relates to whether
    new lines will be added to the top or bottom of the list.
  prefs: []
  type: TYPE_NORMAL
- en: By default, records are ordered according to the `_order` property of the displayed
    model. The user can change the ordering by clicking on a column header, but you
    can also set a different initial order by setting the `default_order` property
    in the `tree` element. The syntax is the same as in `_order`.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Ordering is often a source of frustration for new developers. As Odoo lets PostgreSQL
    do the work here, you can only order according to the fields that PostgreSQL knows
    about and only the fields that live in the same database table. So, if you want
    to order according to a function or a related field, ensure that you set `store=True`.
    If you need to order according to a field inherited from another model, declare
    a stored related field.
  prefs: []
  type: TYPE_NORMAL
- en: The `create`, `edit`, and `delete` attributes of the `tree` element work the
    same as for the `form` element we described earlier in the *Adding content and
    widgets to a form view* recipe of this chapter. They also determine the available
    controls if the `editable` attribute is set.
  prefs: []
  type: TYPE_NORMAL
- en: Defining search views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When opening your list view, you’ll notice the search field in the upper right.
    If you type something there, you will receive suggestions about what to search
    for, and there is also a set of predefined filters to choose from. This recipe
    will walk you through how to define these suggestions and options.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Define your search view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Tell your action to use it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When you type something into the search bar now, you’ll be offered the ability
    to search for this term in the `name`, `room no`, and `state` fields. If your
    term happens to be a substring of a bank account number in your system, you’ll
    even be offered the option to search exactly for this bank account.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the case of `name`, we simply listed the field as the one to be offered to
    the user to search for. We left the semantics as the default, which is a substring
    search for character fields.
  prefs: []
  type: TYPE_NORMAL
- en: For categories, we do something more interesting. By default, your search term
    is applied to a `many2many` field trigger called `name_search`, which would be
    a substring search in the category names in this case. However, depending on your
    category structure, it can be very convenient to search for partners who have
    the category you’re interested in or a child of it. Think of a main category,
    **newsletter subscribers**, with the subcategories **weekly newsletter**, **monthly
    newsletter**, and a couple of other newsletter types. Searching for **newsletter
    subscribers** with the preceding search view definition will give you everyone
    who is subscribed to any of those newsletters in one go, which is a lot more convenient
    than searching for every single type and combining the results.
  prefs: []
  type: TYPE_NORMAL
- en: The `filter_domain` attribute can contain an arbitrary domain, so you’re not
    restricted to searching for the same field you named in the `name` attribute nor
    to using only one term. The `self` variable is what the user filled in and is
    also the only variable that you can use here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a more elaborate example from the default search view for hostel room:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This means that the user doesn’t have to think about what to search for. All
    they need to do is type in some letters, press *Enter*, and, with a bit of luck,
    one of the fields mentioned contains the string we’re looking for.
  prefs: []
  type: TYPE_NORMAL
- en: For the `child_ids` field, we used another trick. The type of field not only
    decides the default way of searching for the user’s input but also defines the
    way in which Odoo presents the suggestions. Additionally, given that `many2one`
    fields are the only ones that offer auto-completion, we force Odoo to do that,
    even though `child_ids` is a `one2many` field, by setting the `widget` attribute.
    Without this, we will have to search in this field without suggestions for completion.
    The same applies to `many2many` fields.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Note that every field with a `many2one` widget set will trigger a search on
    its model for every one of the user’s keystrokes; don’t use too many of them.
  prefs: []
  type: TYPE_NORMAL
- en: You should also put the most-used fields on the top because the first field
    is what is searched for if the user just types something and presses *Enter*.
    The search bar can also be used with the keyboard; select a suggestion by pressing
    the down arrow and open the completion suggestion of `many2one` by pressing the
    right arrow. If you educate your users on this and pay attention to the sensible
    ordering of fields in the search view, this will be much more efficient than typing
    something first, grabbing the mouse, and selecting an option.
  prefs: []
  type: TYPE_NORMAL
- en: The `filter` element creates a button that adds the content of the filter’s
    `domain` attribute to the search domain. You should add a logical internal `name`
    and a `string` attribute to describe the filter to your users.
  prefs: []
  type: TYPE_NORMAL
- en: The `<group>` tag is used to provide a grouping option under the `country_id`
    field.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can group filters using the `group` tag, which causes them to be rendered
    slightly closer together than the other filters, but this has semantic implications,
    too. If you put multiple filters in the same group and activate more than one
    of them, their domains will be combined with the `|` operator, while the filters
    and fields not in the same group are combined with the `&` operator. Sometimes,
    you might want disjunction for your filters, which is where they filter for mutually
    exclusive sets, in which case, selecting both of them will always lead to an empty
    result set. Within the same group, you can achieve the same effect with the `separator`
    element.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Note that if the user fills in multiple queries for the same field, they will
    be combined with `|`, too, so you don’t need to worry about that.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from the `field` attribute, the `filter` element can have a `context`
    attribute, whose content will be merged with the current context and eventually
    other context attributes in the search view. This is essential for views that
    support grouping (refer to the *Defining kanban view* and *Defining graph view*
    recipes) because the resulting context determines the field(s) to be grouped using
    the `group_by` key. We’ll look into the details of grouping in the appropriate
    recipes, but the context has other uses, too. For example, you can write a function
    field that returns different values depending on the context, and then you can
    change the values by activating a filter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The search view itself also responds to context keys. In a very similar way
    to default values when creating records, you can pass default values for a search
    view through the context. If we had set a context of `{''search_default_room_rating'':
    1}` in our previous action, the `room_rating` filter would have been pre-selected
    in the search view. This works only if the filter has a name, though, which is
    why you should always set it. To set defaults for fields in the search view, use
    `search_default_$fieldname`.'
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, the `field` and `filter` elements can have a `groups` property
    with the same semantics as in the form views in order to make the element only
    visible to certain groups.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For further details about manipulating the context, see the *Passing parameters
    to forms and actions –* *Context* recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users who speak languages with heavy use of diacritical marks will probably
    want to have Odoo search for `e`, `è`, `é`, and `ê` when filling in the `e` character.
    This is a configuration of the **PostgreSQL server** called **unaccent**, which
    Odoo has special support for, but this is outside the scope of this book. Refer
    to [https://www.postgresql.org/docs/10/unaccent.html](https://www.postgresql.org/docs/10/unaccent.html)
    for more information about unaccent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a search filter side panel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Odoo provides one more way to display search filters, which is a **search filter
    side panel**. This panel shows a list of filters on the side of the view. A search
    panel is very useful when search filters are used frequently by the end user.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The search panel is part of the search view. So, for this recipe, we will continue
    using the `my_module` add-on from the previous recipe. We will add our search
    panel to the previously designed search view.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add `<searchpanel>` in the search view, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Update the module to apply the modification. After the update, you will see
    the search panel on the left side of the view.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To add the search panel, you will need to use the `<searchpanel>` tag in the
    search view. To add your filter, you will need to add a field in the search panel.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, first, we added a `state` field. You also need to add an `icon`
    attribute to the field. This icon will be displayed before the title of the filter.
    Once you add the field to the search panel, it will display the title with an
    icon, and, below that, a list of all the users. Upon clicking on a user, the records
    in the list view will be filtered, and you will only see the contacts of the selected
    user. In this filter, only one item can be active, meaning once you click on another
    user’s filter, the previous user’s filter will be removed. If you want to activate
    multi-user filters, you can use the `select="multi"` attribute. If you use that
    attribute, you will find the checkbox for each filter option, and you will be
    able to activate multiple filters at a time. We have used the `select="multi"`
    attribute on the `state` filter. This will allow us to select and filter by multiple
    categories at once.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Be careful when you are using the side panel filter on `many2one` or `many2many`.
    If the relation model has too many records, only the **top 200 records** will
    be displayed to avoid performance issues.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you want to display search panel items in groups, you can use the `groupby`
    attribute on a field. For example, if you want to group a category based on its
    parent hierarchy, you can add the `groupby` attribute with the `parent_id` field,
    as can be seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This will show the category filters grouped according to the parent category
    of the record.
  prefs: []
  type: TYPE_NORMAL
- en: Changing existing views – view inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have ignored the existing views and declared completely new ones.
    While this is didactically sensible, you’ll rarely be in situations where you’ll
    want to define a new view for an existing model. Instead, you’ll want to slightly
    modify the existing views, be it to simply have them show a field that you added
    to the model in your add-on or to customize them according to your needs or your
    customers’ needs.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we’ll change the default partner form to show the record’s last
    modification date and make the `mobile` field searchable by modifying the search
    view. Then, we’ll change the position of one column in the partners’ list view.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Inject the field into the default form view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the field to the default search view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the field to the default list view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After updating your module, you should see the **Last updated on** field beneath
    the website field on the partner form. When you type something into the search
    box, it should suggest that you search for the partners on the mobile field, and
    in the partner’s list view, you will see that the order of the phone number and
    email has changed.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1*, we added a basic structure for form inheritance. The crucial field
    here is, as you’ve probably guessed, `inherit_id`. You need to pass the XML ID
    of the view you want to modify (inherit from) to it. The `arch` field contains
    instructions on how to modify the existing XML nodes within the view you’re inheriting
    from. You should actually think of the whole process as simple XML processing
    because all the semantic parts only come a lot later.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most canonical instruction within the `arch` field of an inherited view
    is the `field` element, which has the required attributes: `name` and `position`.
    As you can only have every field appear once in a form, the name already uniquely
    identifies a field. With the `position` attribute, we can place whatever we put
    within the field element, either `before`, `inside`, or `after` regarding the
    field we named. The default is `inside`, but for readability, you should always
    name the position you require. Remember that we’re not talking semantics here;
    this is about the position in the XML tree relative to the field we have named.
    How this will be rendered afterward is a completely different matter.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 2* demonstrates a different approach. The `xpath` element selects the
    first element that matches the XPath expression named in the `expr` attribute.
    Here, the `position` attribute tells the processor where to put the contents of
    the `xpath` element.'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: If you want to create an XPath expression based on a CSS class, Odoo provides
    a special function called `hasclass`. For example, if you want to select a `<div>`
    element with the `test_class` CSS class, then the expression will be `expr="//div[hasclass('test_class')]"`.
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 3* shows how you can change the position of an element. This option was
    introduced in `phone` field so that it came after the `email` field using the
    `position=move` option.'
  prefs: []
  type: TYPE_NORMAL
- en: XPath might look somewhat scary, but it is a very efficient means of selecting
    the node you need to work on. Take the time to look through some simple expressions;
    it’s worth it. You’ll likely stumble upon the term **context node**, to which
    some expressions are relative. In Odoo’s view inheritance system, this is always
    the root element of the view you’re inheriting from.
  prefs: []
  type: TYPE_NORMAL
- en: For all the other elements found in the `arch` field of an inheriting view,
    the processor looks for the first element with the same node name and matching
    attributes (with the attribute position excluded, as this is part of the instruction).
    Use this only in cases where it is very unlikely that this combination is not
    unique, such as a group element combined with a `name` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have as many instruction elements within the `arch` field
    as you need. We only used one per inherited view because there’s nothing else
    we want to change currently.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `position` attribute has two other possible values: `replace` and `attributes`.
    Using `replace` causes the selected element to be replaced with the content of
    the instruction element. Consequently, if you don’t have any content, the selected
    element can simply be removed. The preceding list or form view would cause the
    `state` field to be removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Removing fields can cause other inheriting views to break and several other
    undesirable side effects, so avoid that if possible. If you really need to remove
    fields, do so in a view that comes late in the order of evaluation (refer to the
    next section, *Order of evaluation in view inheritance*, for more information).
  prefs: []
  type: TYPE_NORMAL
- en: '`attributes` has very different semantics from the preceding examples. The
    processor expects the element to contain the `attribute` elements with a `name`
    attribute. These elements will then be used to set attributes for the selected
    element. If you want to heed the earlier warning, you should set the `invisible`
    attribute to `1` for the `state` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'An `attribute` node can have `add` and `remove` attributes, which, in turn,
    should contain the value to be removed from or added to the space-separated list.
    This is very useful for the `class` attribute, where you’d add a class (instead
    of overwriting the whole attribute) by using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This code adds the `oe_inline` class to the `description` field. If the field
    already has a class attribute present, Odoo will join the value with the value
    of the `separator` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Order of evaluation in view inheritance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we currently have only one parent view and one inheriting view, we don’t
    run into any problems with conflicting view overrides. When you have installed
    a couple of modules, you’ll find a lot of overrides for the partner form. This
    is fine as long as they change different things in a view, but there are occasions
    where it is important to understand how overriding works in order to avoid conflicts.
  prefs: []
  type: TYPE_NORMAL
- en: The direct descendants of a view are evaluated in ascending order of their `priority`
    field, so views with a lower priority are applied first. Every step of inheritance
    is applied to the result of the first, so if a view with priority `3` changes
    a field and another one with priority `5` removes it, this is fine. This does
    not work, however, if the priorities are reversed.
  prefs: []
  type: TYPE_NORMAL
- en: You can also inherit an inheriting view itself from a view. In this case, the
    second-level inheriting view is applied to the result of the view it inherits
    from. So, if you have four views, `A`, `B`, `C`, and `D`, where `A` is a standalone
    form, `B` and `C` inherit from `A`, and `D` inherits from `B`, the order of evaluation
    is `A`, `B`, `D`, and `C`. Use this to enforce an order without having to rely
    on priorities; this is safer in general. If an inheriting view adds a field and
    you need to apply changes to this field, inherit from the inheriting view and
    not from the standalone one.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: This kind of inheritance always works on the complete XML tree from the original
    view, with modifications from the previous inheriting views applied.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following points provide information on some advanced tricks that are used
    to tweak the behavior of view inheritance:'
  prefs: []
  type: TYPE_NORMAL
- en: For inheriting views, a very useful and not very well-known field is `groups_id`.
    This field causes inheritance to take place only if the user requesting the parent
    view is a member of one of the groups mentioned there. This can save you a lot
    of work when adapting the user interface for different levels of access because,
    with inheritance, you can have more complex operations than just showing or not
    showing the elements based on group membership, as is possible with the `groups`
    attribute for form elements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can, for example, remove elements if the user is a member of a group (which
    is the inverse of what the `groups` attribute does). You can also carry out some
    elaborate tricks, such as adding attributes based on group membership. Think about
    simple things, such as making a field read-only for certain groups, or more interesting
    concepts, such as using different widgets for different groups.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What was described in this recipe relates to the `mode` field of the original
    view being set to primary, while the inheriting views have the mode extension,
    which is the default. We will investigate the case in which the mode of an inheriting
    view is set to `primary` later, where the rules are slightly different.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining document-style forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we’ll review some design guidelines in order to present a uniform
    user experience.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Start your form with a `header` element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'stat button, which will be used to show total Hostel Room and will redirect
    to hostel room:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add some prominent field(s):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add your content; you can use a notebook if there are a lot of fields:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: </sheet>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <div class="oe_chatter">
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <field name="message_follower_ids" widget="mail_followers"/>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <field name="message_ids" widget="mail_thread"/>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <field name="activity_ids" widget="mail_activity"/>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: </div>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let’s have a look at how this recipe works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The header should contain buttons that execute actions on the object that the
    user currently sees. Use the `btn-primary` class to make buttons visually stand
    out (in purple at the time of writing), which is a good way to guide the user
    regarding which is the most logical action to execute at the moment. Try to have
    all the highlighted buttons to the left of the non-highlighted buttons and hide
    the buttons that are not relevant in the current state (if applicable). If the
    model has a state, show it in the header using the `statusbar` widget. This will
    be rendered as right-aligned in the header.
  prefs: []
  type: TYPE_NORMAL
- en: The `sheet` element is rendered as a stylized sheet, and the most important
    fields should be the first thing the user sees when looking at it. Use the `oe_title`
    classes to have them rendered in a prominent place (floating left with slightly
    adjusted font sizes at the time of writing).
  prefs: []
  type: TYPE_NORMAL
- en: If there are other records of interest concerning the record the user currently
    sees (such as the partner’s invoices on a partner form), put them in an element
    with the `oe_right` and `oe_button_box` classes; this aligns the buttons in it
    to the right. On the buttons themselves, use the `oe_stat_button` class to enforce
    a uniform rendering of the buttons. It’s also customary to assign an icon class
    from the `icon` attribute. You can learn more about Font Awesome at [https://fontawesome.com/v4.7.0/icons/](https://fontawesome.com/v4.7.0/icons/).
  prefs: []
  type: TYPE_NORMAL
- en: You can use the `oe_chatter` class and `mail.thread` mixin. We will see this
    in detail in [*Chapter 23*](B20997_23.xhtml#_idTextAnchor1210), *Managing Emails*
    *in Odoo*.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Even if you do not like this layout, stick to the element and class names described
    here and adjust what you need with CSS and possibly JavaScript. This will make
    the user interface more compatible with existing add-ons and allow you to integrate
    better with core add-ons.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To find out more about Font Awesome, go to [https://fontawesome.com/v4.7.0/icons/](https://fontawesome.com/v4.7.0/icons/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more details on the `mail.thread` mixin, refer to [*Chapter 23*](B20997_23.xhtml#_idTextAnchor1210),
    *Managing Emails* *in Odoo*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic form elements using attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have only looked into changing forms depending on the user’s groups
    (the `groups` attribute for elements and the `groups_id` field for inherited views)
    and nothing more. This recipe will show you how to modify the form view based
    on the value of the fields in it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Define an attribute called `attributes` on a form element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Ensure that all the fields you refer to are available in your form:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will make the `child_ids` field invisible if the `parent_id` is not `hostel
    room category`, and it will be required if it’s a hostel room category.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`invisible`, `required`, and `readonly` keys (all of which are optional). The
    values are domains that may refer to the fields that exist on the form (and really
    only those, so there are no dotted paths), and the whole dictionary is evaluated
    according to the rules for client-side Python, as described earlier in the *Passing
    parameters to forms and actions – Context* recipe of this chapter. So, for example,
    you can access the context in the right-hand operand.'
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While this mechanism is quite straightforward for scalar fields, it’s less obvious
    how to handle the `one2many` and `many2many` fields. In fact, in standard Odoo,
    you can’t do much with those fields within `[[6, False, []]]` as your right-hand
    operand.
  prefs: []
  type: TYPE_NORMAL
- en: Defining embedded views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you show a `one2many` or a `many2many` field on a form, you don’t have
    much control over how it is rendered if you haven’t used one of the specialized
    widgets. Additionally, in the case of the `many2one` fields, it is sometimes desirable
    to be able to influence the way the linked record is opened. In this recipe, we’ll
    look at how to define private views for those fields.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Define your field as usual, but don’t close the tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Write the view definition(s) into the tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Close the tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When Odoo loads a form view, it first checks whether the `relational` type fields
    have embedded views in the field, as outlined previously. Those embedded views
    can have the exact same elements as the views we defined before. Only if Odoo
    doesn’t find an embedded view of some type does it use the model’s default view
    of this type.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While embedded views might seem like a great feature, they complicate view inheritance
    a lot. For example, as soon as embedded views are involved, the field names are
    not guaranteed to be unique, and you’ll usually have to use some elaborate XPaths
    to select elements within an embedded view.
  prefs: []
  type: TYPE_NORMAL
- en: So, in general, you should better define standalone views and use the `form_view_ref`
    and `tree_view_ref` keys, as described earlier in the *Having an action open a
    specific view* recipe of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying attachments on the side of the form view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In some applications, such as invoicing, you need to fill in data based on a
    document. To ease the data-filling process, a new feature was added to Odoo version
    12 to display the document on the side of the form view.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we will learn how to display the form view and the document
    side by side:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3 – Cascading attachments and the form view](img/B20997_09_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – Cascading attachments and the form view
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: This feature is only meant for large displays (`>1534px`), so if you have a
    small viewport, this feature will be hidden. Internally, this feature uses some
    responsive utilities, so this feature only works in the **Enterprise** edition.
    However, you can still use this code in your module. Odoo will automatically handle
    this, so if the module is installed in the Enterprise edition, it will show the
    document, while in the Community edition, it will hide everything without any
    side effects.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will enable this feature to modify a form view for the `hostel.room.category`
    model, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Update the module to apply the changes. You need to upload a PDF or image via
    the record chatter. When you upload it, Odoo will display the attachment on the
    side.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This feature only works if your model has inherited the `mail.thread` model.
    To show the document on the side of any form view, you will need to add an empty
    `<div>` with the `o_attachment_preview` class before the chatter elements. That’s
    it; the documents attached in the chatter will be displayed on the side of the
    form view.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the `pdf` and `image` documents will be displayed in ascending
    order by date. You can change this behavior by providing extra options, which
    include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`type`: You need to pass the list of document types you want to allow. Only
    two values are possible: `pdf` and `image`. For example, if you want to display
    only `pdf`-type images, you can pass `{''``type'': [''pdf'']}`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`order`: The possible values are `asc` and `desc`. These allow you to show
    documents in ascending order or descending order of the document creation date.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In most cases, you want to display documents on the side of the initial state
    of any record. If you want to hide the attachment preview based on domain, you
    can use `attributes` on the `<div>` tag to hide the preview.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following example: it will hide the PDF preview if the value
    of the `state` field is not `draft`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This is how you can hide attachments when they are not needed. Usually, this
    feature is used to fill data from PDFs and is only activated in draft mode.
  prefs: []
  type: TYPE_NORMAL
- en: Defining kanban views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have presented you with a list of records that can be opened to show
    a form. While those lists are efficient when presenting a lot of information,
    they tend to be slightly boring, given the lack of design possibilities. In this
    recipe, we’ll take a look at **kanban views**, which allow us to present lists
    of records in a more appealing way.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Define a view of the `kanban` type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'List the fields you’ll use in your view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement a design:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Close all the tags:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add this view to one of your actions. This is left as an exercise for the reader.
    You will find a full working example in the GitHub example files: [https://github.com/PacktPublishing/Odoo-13-Development-Cookbook-Fourth-Edition/tree/master/Chapter09/15_kanban_view/my_module](https://github.com/PacktPublishing/Odoo-13-Development-Cookbook-Fourth-Edition/tree/master/Chapter09/15_kanban_view/my_module).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to give a list of fields to load in *step 2* in order to be able to
    access them later. The content of the `templates` element must be a single `t`
    element with the `t-name` attribute set to `kanban-box`.
  prefs: []
  type: TYPE_NORMAL
- en: What you write inside this element will be repeated for each record, with special
    semantics for `t` elements and `t-*` attributes. For details about this, refer
    to the *Using client-side QWeb templates* recipe from [*Chapter 15*](B20997_15.xhtml#_idTextAnchor861),
    *Web Client Development* because, technically speaking, kanban views are just
    an application of QWeb templates.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few modifications that are particular to kanban views. You have
    access to the `read_only_mode`, `record`, and `widget` variables during evaluation.
    Fields can be accessed using `record.fieldname`, which is an object with the `value`
    and `raw_value` properties, where `value` is the field’s value that has been formatted
    in a way that is presentable to the user, and `raw_value` is the field’s value,
    as it comes from the database.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: '`many2many` fields make an exception here. You’ll only get an ID list through
    the `record` variable. For a user-readable representation, you must use the `field`
    element.'
  prefs: []
  type: TYPE_NORMAL
- en: Note the `type` attribute of the link at the top of the template. This attribute
    makes Odoo generate a link that opens the record in view mode (`type` attribute
    can also be `object` or `action`, which will render the links that call a function
    from the model or an action. In both cases, you need to supplement the attributes
    for buttons in form views, as outlined in the *Adding buttons to forms* recipe
    of this chapter. Instead of the `a` element, you can also use the `button` element;
    the `type` attribute has the same semantics here.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a few more helper functions worth mentioning. If you need to generate
    a pseudo-random color for an element, use the `kanban_color(some_variable)` function,
    which will return a CSS class that sets the `background` and `color` properties.
    This is usually used in the `t-att-class` elements.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to display an image stored in a binary field, use `kanban_image(modelname,
    fieldname, record.id.raw_value)`, which returns a data URI if you included the
    field in your fields list; the field is set, is a placeholder if the field is
    not set, or is a URL that makes Odoo stream the field’s contents if you didn’t
    include the field in your fields list. Do not include the field in the fields
    list if you need to display a lot of records simultaneously or if you expect very
    big images. Usually, you’d use this in a `t-att-src` attribute of an `img` element.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Doing design in kanban views can be a bit trying. What often works better is
    generating HTML using a function field of the HTML type and generating this HTML
    from a Qweb view. In this way, you’re still doing QWeb but doing so on the server
    side, which is a lot more convenient when you need to work on a lot of data.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To know more about template elements, refer to the *Using client-side QWeb templates*
    recipe from [*Chapter 15*](B20997_15.xhtml#_idTextAnchor861), *Web* *Client Development*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Showing kanban cards in columns according to their state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe shows you how to set up a kanban view where the user can drag and
    drop a record from one column to the other, thereby pushing the record in question
    into another state.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From now on, we’ll make use of the hostel module here, as this defines models
    that lend themselves better to date- and state-based views than those defined
    in the base module. So, before proceeding, add `base` to the dependencies list
    of your add-on.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Define a kanban view for the hostel room category:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add a menu and an action using this view. This is left as an exercise for the
    reader.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kanban views support grouping, which allows you to display records that have
    a group field in common in the same column. This is commonly used for a `parent
    hotel room category` or `parent_id` field because it allows the user to change
    this field’s value for a record by simply dragging it into another column. Set
    the `default_group_by` attribute on the `kanban` element to the name of the field
    you want to group by in order to make use of this functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'To control the behavior of kanban grouping, there are a few options available
    in Odoo:'
  prefs: []
  type: TYPE_NORMAL
- en: '`group_create`: This option is used to hide or show the `true`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`group_delete`: This option enables or disables the `true`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`group_edit`: This option enables or disables the `true`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`archivable`: This option enables or disables the option to archive and restore
    the records from the kanban group context menu. This only works if the `active`
    Boolean field is present in your model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`quick_create`: With this option, you can create records directly from the
    kanban view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`quick_create_view`: By default, the `quick_create` option displays only the
    name field in kanban. However, with the `quick_create_view` option, you can give
    the reference to the minimal form view so as to display it in kanban.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`on_create`: If you don’t want to use `quick_create` when creating a new record
    and you don’t want to redirect the user to the form view either, you can give
    the reference of the wizard so that it will open the wizard when clicking the
    **Create** button.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If not defined in the dedicated attribute, any search filter can add grouping
    by setting a context key named `group_by` to the field name(s) to group by.
  prefs: []
  type: TYPE_NORMAL
- en: Defining calendar views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe walks you through how to display and edit information about dates
    and duration in your records in a visual way.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to add a `calendar` view for the `hostel.room.category`
    model:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a `calendar` view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add menus and actions using this view. This is left as an exercise for the reader.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `calendar` view needs to pass the field names in the `date_start` and `date_stop`
    attributes to indicate which fields to look at when building the visual representation.
    Only use fields with the `Datetime` or `Date` type; other types of fields will
    not work and will instead generate an error. While `date_start` is required, you
    can leave out `date_stop` and set the `date_delay` attribute instead, which is
    expected to be a `Float` field that represents the duration in hours.
  prefs: []
  type: TYPE_NORMAL
- en: The `calendar` view allows you to give records that have the same value in a
    field the same (arbitrarily assigned) color. To use this functionality, set the
    `color` attribute to the name of the field you need. In our example, we can see
    at a glance which hostel room category belongs to the same hostel room category
    because we assigned `parent_id` as the field to determine the color groups.
  prefs: []
  type: TYPE_NORMAL
- en: The fields you name in the `calendar` element’s body are shown within the block
    that represents the time interval covered, separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `calendar` view has some other helpful attributes. If you want to open calendar
    entries in a popup instead of the standard form view, set `event_open_popup` to
    `1`. By default, you create a new entry by just filling in some text, which internally
    calls the model’s `name_create` function to actually create the record. If you
    want to disable this behavior, set `quick_add` to `0`.
  prefs: []
  type: TYPE_NORMAL
- en: If your model covers a whole day, set `all_day` to a field’s name that is `true`
    if the record covers the whole day and `false` otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: Defining graph view and pivot view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we’ll take a look at Odoo’s business intelligence views. These
    are read-only views that are meant to present data.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’re still making use of the `hostel` module here. You can configure a graph
    and pivot views to get different statistics. For our example, we will focus on
    the assigned user. We will generate a graph and pivot view to see the users of
    the hostel room category. By the way, the end user can generate statistics of
    their choice by modifying the view options.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Define a graph view using bars:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a pivot view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add menus and actions using this view. This is left as an exercise for the reader.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If everything went well, you should see graphs that show how many parent hostel
    room categories are assigned to which hostel room categories and the state of
    those hostel room categories.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The graph view is declared with a root element, `graph`. The `type` attribute
    on a `graph` element determines the initial mode of a graph view. The possible
    values are `bar`, `line`, and `chart`, but `bar` is the default. The graph view
    is highly interactive, so the user can switch between the different modes and
    also add and remove fields. If you use `type="bar",`, you can also use `stacked="1"`
    to show a stacked bar chart during grouping.
  prefs: []
  type: TYPE_NORMAL
- en: The `field` elements tell Odoo what to display on which axis. For all graph
    modes, you need at least one field with the `row` type and one with the `measure`
    type to see anything useful. Fields of the `row` type determine the grouping,
    while those of the `measure` type stand for the value(s) to be shown. Line graphs
    only support one field of each type, while charts and bars handle two group fields
    with one measure nicely.
  prefs: []
  type: TYPE_NORMAL
- en: Pivot views have their own root element, `pivot`. The pivot view supports an
    arbitrary amount of group and measure fields. Nothing will break if you switch
    to a mode that doesn’t support the number of groups and measures you defined;
    some fields will just be ignored, and the result might not be as interesting as
    it could be.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For all graph types, `Datetime` fields are tricky to group because you’ll rarely
    encounter the same field value here. So, if you have a `Datetime` field of the
    `row` type, also specify the `interval` attribute with one of the following values:
    `day`, `week`, `month`, `quarter`, or `year`. This will cause the grouping to
    take place in the given interval.'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Grouping, like sorting, relies heavily on PostgreSQL. So, the rule applies here
    also that a field must live in the database and in the current table in order
    to be usable.
  prefs: []
  type: TYPE_NORMAL
- en: It is a common practice to define database views that collect all the data you
    need and define a model on top of this view in order to have all the necessary
    fields available.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the complexity of your view and the grouping, building the graph
    can be quite an expensive exercise. Consider setting the `auto_search` attribute
    to `False` in these cases so that the user can first adjust all the parameters
    and only then trigger a search.
  prefs: []
  type: TYPE_NORMAL
- en: The pivot table also supports grouping in columns. Use the `col` type for the
    fields you want to have there.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the cohort view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the cohort analysis of records, the new cohort view was added in Odoo version
    12\. The cohort view is used to find out the life cycle of a record over a particular
    time span. With the cohort view, you can see the churn and retention rate of any
    object for a particular time.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `cohort` view is part of the `web_cohort` in the manifest file of your module.
    For our example, we will create a view to see the cohort analysis for hostel room
    category.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to add the `cohort` view for the `hostel.room.category`
    model:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a `cohort` view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add menus and actions using this view. This is left as an exercise for the reader.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To create a cohort view, you need to provide `date_start` and `date_stop`. These
    will be used in the view to determine the time span of any record. For example,
    if you are managing a subscription of a service, the start date of the subscription
    will be `date_start` and the date when the subscription is going to expire will
    be `date_stop`.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the `cohort` view will be displayed in the `retention` mode at
    intervals of a month. You can use the given options to obtain different behaviors
    in the `cohort` view:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mode`: You can use cohort with two modes: `retention (default)` or `churn`.
    The `retention` mode starts at 100% and decreases with time, while the `churn`
    mode starts at 0% and increases with time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`timeline`: This option accepts two values: `forward (default)` or `backward`.
    In most cases, you need to use the forward timeline. However, if `date_start`
    is in the future, you will need to use the backward timeline. An example of when
    we would use the backward timeline would be for the registration of an event attendee
    where the event date is in the future, and the registration date is in the past.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`interval`: By default, the cohort is grouped by month, but you can change
    this in the interval options. Other than months, the cohort also supports day,
    week, and year intervals.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`measure`: Just like graph and pivot, measure is used to display the aggregated
    value of a given field. If no option is given, the cohort will display the count
    of records.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining the gantt view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Odoo version 13 added a new `gantt` view with new options. The `gantt` view
    is useful for seeing overall progress and scheduling business processes. In this
    recipe, we will create a new `gantt` view and look at its options.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `gantt` view is part of the Odoo Enterprise edition, so you can’t use it
    with the Community edition. If you are using the Enterprise edition, you need
    to add the `web_gantt` dependency in the manifest file of your module.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we will continue using the `my_hostel` module from the previous
    recipe. We will create a new `gantt` view for the hostel room category.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Define a `gantt` view for the hostel room category model as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add menus and actions using this view. This is left as an exercise for the reader.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install and update the module to apply the changes; after the update, you will
    see the `gantt` view on the hostel room category.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the `gantt` view, you can display an overall schedule on one screen. In
    our example, we have created a `gantt` view for the hostel room category grouped
    by parent. Typically, you need two attributes to create a `gantt` view, `start_date`,
    and `stop_date`, but there are some other attributes that extend the functionality
    of the `gantt` view. Let’s see all the options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`start_date`: Defines the starting time of the `gantt` item. It must be a date
    or date-time field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default_group_by`: Use this attribute if you want to group the `gantt` items
    based on field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`color`: This attribute is used to decide the color of a `gantt` item.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`progress`: This attribute is used to indicate the progress of a `gantt` item.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`decoration-*`: Decoration attributes are used to decide the color of a gantt
    item based on conditions. It can be used like this: `decoration-danger="state
    == ''lost''"`. Its other values are `decoration-success`, `decoration-info`, `decoration-warning`,
    and `decoration-secondary`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scales`: Use the `scales` attribute if you want to enable the `gantt` view
    only for a few scales. For example, if you only want day and week scales, you
    can use `scales="day,week"`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By default, `gantt` view items are resizable and draggable, but if you want
    to disable that, you can use the `edit="0"` attribute.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you hover over a `gantt` view item, you will see the name and date for
    the item. If you want to customize that popup, you can define a `gantt` view definition
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Note that you will need to add the fields that you want to use in the template
    via the `<``field>` tag.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the activity view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Activities are an important part of Odoo apps. They are used to schedule to-do
    actions for different business objects. The `activity` view helps you to see the
    statuses and schedules of all activities on the model.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our example, we will continue using the `my_hostel` module from the previous
    recipe. We will create a new `activity` view for the hostel room category.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Define a `activity` view for the `hostel room category` model as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add menus and actions using this view. This is left as an exercise for the reader.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `activity` view is simplistic; most of the things are managed automatically.
    You just have the option to customize the first column. To display your data in
    the first column, you need to create a QWeb template with the name `activity-box`,
    and that’s it; Odoo will manage the rest.
  prefs: []
  type: TYPE_NORMAL
- en: The `activity` view will display your template in the first column, and other
    columns will show the scheduled activities grouped by activity type.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the map view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Odoo version 13 adds a new view called a `map` view. As its name suggests, it
    is used to show a map with a marker. They are very useful for on-site services.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our example, we will continue using the `my_hostel` module from the previous
    recipe. We will create the new `map` view for the hostel room category. The `map`
    view is part of the `web_map` dependency in the manifest file of your module.
  prefs: []
  type: TYPE_NORMAL
- en: Odoo uses the API from [https://www.mapbox.com/](https://www.mapbox.com/) to
    display maps in the view. In order to see the map in Odoo, you will need to generate
    the access token from the **mapbox**. Make sure you have generated an access token
    and set it in the Odoo configuration.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Define a `map` view for the hostel room category model as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add menus and actions using this view. This is left as an exercise for the reader.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating a map view is pretty simple; you just need a `many2one` field that
    refers to the `hostel.room.category` model. The `hostel.room.category` model has
    `address` fields, which are used by the map view to display the marker for the
    address. You will need to use the `res_partner` attribute to map the address for
    the `map` view. In our case, we have used the `parent_id` field as the hostel
    room category parent record set in the `parent_id` field.
  prefs: []
  type: TYPE_NORMAL
