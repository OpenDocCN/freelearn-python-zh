<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Gesture-Controlled Robotic Vehicle</h1>
                </header>
            
            <article>
                
<p class="mce-root">In the previous few chapters, you have learned a lot about sensors—what they do and how they work. The number of sensors on this planet is simply out of bonds. It's ever increasing, and while you are reading this book, there could be some new sensor being launched by some country across the world. This might make you wonder, do you have to learn about all of these sensors coming out on the market every single day? </p>
<p class="mce-root">Thankfully, as you have learned, these sensors are more or less similar and work on a limited set of protocols. This makes working with new sensors easy. You might think that we have covered most of our basic sensors. However, that wouldn't be true—as we are yet to learn one of the most important sensors when it comes to the balancing of robots. These are accelerometers and gyroscope. These two sensors are not only present in all of these robots that have anything to do with balancing, but they have also found their way into our mobile devices. So, now let's learn about the basics of these sensors. </p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Accelerometers and gyroscope</h1>
                </header>
            
            <article>
                
<p>Let's first start with accelerometers. As the name suggests, these are meant to measure acceleration in any body. Hence, whenever there is any acceleration in any body, then the accelerometers have the work to sense that acceleration and give the corresponding reading. </p>
<p><span>A gyroscope is a device that uses Earth's gravity to help determine orientation of the robot. </span><span>An accelerometer is a device designed to measure non-gravitational acceleration.</span> <span>Whenever there is any acceleration, the crystals in the accelerometer excite and provide a voltage corresponding to it.</span></p>
<p>The main difference between these devices is simple: the gyroscope can sense rotation, whereas the <span>accelerometer </span>cannot. In a way, the accelerometer can gauge the orientation of a stationary item with relation to Earth's surface. When accelerating in a particular direction, the accelerometer is unable to distinguish between that and the acceleration provided through Earth's gravitational pull. The gyroscope measures the rate of rotation around a particular axis. In comparison, the accelerometer measures linear acceleration.</p>
<p>Here in this chapter, we will be using a sensor called MPU 6050, which is one of the most common sensors that has both the accelerometers and gyroscope built into one single package. </p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/ca5ef65f-b25b-4056-a746-1ed045b8f809.jpg" style="width:25.75em;height:24.50em;"/></div>
<p>Preceding is a photograph of it. As you can see, it has <strong>SCL</strong> and <strong>SDA</strong> lines. Hence, you can be sure that this sensor works on I2C protocol. This is cool because we have already had a good experience working with I2C type sensors. </p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Interfacing the inertial measurement unit</h1>
                </header>
            
            <article>
                
<p><span>MPU 6050 is a three-axis accelerometer and three-axis gyroscope. It works on I2C, but the interesting thing about this sensor is that it has a different address for different </span>sensors. What did you just say? Different address for different sensors. Isn't it one single sensor?</p>
<p>Well, yes it is, but if you see the internal construction of the sensor, then you would find that for every different axis, the data is being stored in different registers from where we can acquire the data at our disposal. Hence, if you require just the reading of x axis of accelerometer, then you can do so efficiently rather than getting a whole long string of different values. Now connecting this sensor is super easy. All you have to do is to power it up using Raspberry Pi and simply connect the I2C pins over, as shown in the following diagram: </p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/1568df83-88d0-4155-af55-7066bd7a6eb2.png" style="width:26.92em;height:41.58em;"/></div>
<p>Once the wiring is done, go ahead and upload the following code. Once you do so, run and see what you get:</p>
<pre>import smbus<br/>from time import sleep<br/>PWR_MGMT_1 = 0x6B<br/>SMPLRT_DIV = 0x19<br/>CONFIG = 0x1A<br/>GYRO_CONFIG = 0x1B<br/>INT_ENABLE = 0x38<br/>ACCEL_XOUT_H = 0x3B<br/>ACCEL_YOUT_H = 0x3D<br/>ACCEL_ZOUT_H = 0x3F<br/>GYRO_XOUT_H = 0x43<br/>GYRO_YOUT_H = 0x45<br/>GYRO_ZOUT_H = 0x47<br/>def MPU_Init():<br/>  bus.write_byte_data(Device_Address, SMPLRT_DIV, 7)<br/>  bus.write_byte_data(Device_Address, PWR_MGMT_1, 1)<br/>  bus.write_byte_data(Device_Address, CONFIG, 0)<br/>  bus.write_byte_data(Device_Address, GYRO_CONFIG, 24)<br/>  bus.write_byte_data(Device_Address, INT_ENABLE, 1)<br/><br/>def read_raw_data(addr):<br/>  high = bus.read_byte_data(Device_Address, addr)<br/>  low = bus.read_byte_data(Device_Address, addr+1)<br/>  value = ((high &lt;&lt; 8) | low)<br/>   if(value &gt; 32768):<br/>   value = value - 65536<br/>   return value<br/>  bus = smbus.SMBus(1)<br/>  Device_Address = 0x68<br/><br/>MPU_Init()<br/>print (" Reading Data of Gyroscope and Accelerometer")<br/>while True:<br/>   Ax = read_raw_data(ACCEL_XOUT_H)<br/>   Ay = read_raw_data(ACCEL_YOUT_H)<br/>   Az = read_raw_data(ACCEL_ZOUT_H)<br/>   Gx = read_raw_data(GYRO_XOUT_H)<br/>   Gy = read_raw_data(GYRO_YOUT_H)<br/>   Gz = read_raw_data(GYRO_ZOUT_H)<br/>  print(“Ax=”+str(Ax)+”Ay=”+str(Ay)+"Az="+str(Az)+“Gx=”+str(Gx)+”Gy=”+str(Gy)+"Gz="+str(Gz))</pre>
<p>Now it's time to see what we have done:</p>
<pre>def MPU_Init():<br/><br/>            bus.write_byte_data(Device_Address, SMPLRT_DIV, 7)<br/>            <br/><br/>            bus.write_byte_data(Device_Address, PWR_MGMT_1, 1)<br/>            <br/><br/>            bus.write_byte_data(Device_Address, CONFIG, 0)<br/>            <br/><br/>            bus.write_byte_data(Device_Address, GYRO_CONFIG, 24)<br/>            <br/><br/>            bus.write_byte_data(Device_Address, INT_ENABLE, 1)</pre>
<p>In this lines, we are defining a function called <kbd>MPU_Init()</kbd>. This will be used to initialize the <strong>inertial measurement unit</strong> (<strong>IMU</strong>) sensor. In this function, we are using a method called <kbd>write_byte_data()</kbd> from the library <kbd>bus</kbd>. What it does is that it writes the data to a specific register declared in the argument. The data written using this function would be of a byte in size. Now we are declaring <kbd>Device_Address</kbd>. That is, the data written would be on the connected device's address. The second argument <kbd>SMPLRT_DIV</kbd> will tell the address of the register in hexadecimal. Hence, the value of <kbd>SMPLRT_DIV</kbd> would be used as the address. The last argument is the data that needs to be written, which in our case is <kbd>7</kbd>. Similarly, the following would be the values passed to the device:</p>
<ul>
<li><kbd>PWR_MGMT_1</kbd>: <kbd>1</kbd></li>
<li><kbd>CONFIG</kbd>: <kbd>0</kbd></li>
<li><kbd>GYRO_CONFIG</kbd>: <kbd>24</kbd></li>
<li><kbd>INT_ENABLE</kbd>: <kbd>1</kbd></li>
</ul>
<p>These values would be required to set up the sensor. What these values are doing is not of an importance to us at this point. However, if you wish to know, then you can use the data sheet of the IMU MPU 6050 and get what all these registers are doing in detail: </p>
<pre>def read_raw_data(addr):<br/><br/>        high = bus.read_byte_data(Device_Address, addr)<br/>        low = bus.read_byte_data(Device_Address, addr+1)</pre>
<p>Here, we are defining a function called <kbd>read_raw_data(addr)</kbd> reading the address from the device and then register where we are reading the address from is <kbd>addr</kbd> for the <kbd>high</kbd> variable and <kbd>addr+1</kbd> for the <kbd>low</kbd> variable.</p>
<pre>        value = ((high &lt;&lt; 8) | low)</pre>
<p>Once the data has been acquired then it is being processed by the following statement <kbd>value = ((high &lt;&lt; 8) | low)</kbd> what this does is that shifts the value of the high variable hence if the data of the variable high in binary is <kbd>10111011</kbd>, <kbd>(high &lt;&lt;8)</kbd> would transform this value to <span><span><kbd>1011101100000000</kbd>. </span></span>Once that is done the and operator would add the eight digit value to the newly calculated value of high. Making the output a 16 bit integer. Now you must be thinking why did we do this?</p>
<p>The value which is being given by the MPU 6050 for any reading is 16 bit. However the registers of MPU 6050 are 8 bit in size. Now what MPU 6050 does is that it stores the value of any sensor in the registers based on the position of the bits. That is the most significant 8 bits would be stored in the first address and the rest of the least significant 8 bits would be stored in the next address that is <kbd>addr+1</kbd>:</p>
<pre><br/>        if(value &gt; 32768):<br/>                value = value - 65535<br/>        return value</pre>
<p>As we understood in the last line, the output data from the sensor would be in a 16 bit format. When the sensor would be in the normal position this reading would be lying somewhere in the middle. If the value is more than the middle reading we would subtract the value by <kbd>65535</kbd>, hence providing us a negative value for every value which is over the middle reading. This would give us a sense of direction without doing much brain work. If the values are positive the tilt is in one direction and if negative then in other direction. </p>
<pre>            acc_x = read_raw_data(ACCEL_XOUT_H)<br/>            acc_y = read_raw_data(ACCEL_YOUT_H)<br/>            acc_z = read_raw_data(ACCEL_ZOUT_H)<br/>            <br/><br/>            gyro_x = read_raw_data(GYRO_XOUT_H)<br/>            gyro_y = read_raw_data(GYRO_YOUT_H)<br/>            gyro_z = read_raw_data(GYRO_ZOUT_H)</pre>
<p>Now that we have defined the function called <kbd>read_raw_data()</kbd> we can start reading the data from different sensors. These sensors would be saving the data onto different addresses. These lists of addresses we have mentioned earlier. Hence by passing that data to the function we can get to know the reading of every single sensor. All these readings are being calculated and the data is stored in a variable. </p>
<pre>print(“Ax=”+str(Ax)+”Ay=”+str(Ay)+"Az="+str(Az)+“Gx=”+str(Gx)+”Gy=”+str(Gy)+"Gz="+str(Gz))</pre>
<p>In this line we are simply printing the values of each of the variables corresponding to each of the sensors. </p>
<p>Now once you run this code you will see the values of each of the sensors coming out and this will change as you change the orientation or acceleration. Explore the reading and how they are changing in respect to movement. I'm sure it would give you a plentiful idea about the sensor. So go ahead and enjoy! </p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Gesture-controlled car </h1>
                </header>
            
            <article>
                
<p>We have seen how we can extract the data from IMU. Now its time to put that data to work. In this chapter we will be controlling our robotic vehicle just with the tilt of our hand. So in essence it will be a gesture-controlled robotic vehicle. Now to do so, lets go ahead and connect the Raspberry Pi as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/d83d3c7d-116d-459d-854e-7405ea002e87.png"/></div>
<p><span>Make sure you attach a sufficiently long wire for the sensor, do not exceed 1 meter at any point and use it as a remote control for your vehicle.</span> Once connected upload the following code:</p>
<pre>import smbus<br/>from time import sleep<br/>import RPi.GPIO as GPIO<br/>int1 = 12<br/>int2 = 16<br/>int3 = 18<br/>int4 = 15<br/>GPIO.setup(int1, GPIO.OUT)<br/>GPIO.setup(int2, GPIO.OUT)<br/>GPIO.setup(int3, GPIO.OUT)<br/>GPIO.setup(int4, GPIO.OUT)<br/>PWM1 = GPIO.PWM(12, 100)<br/>PWM2 = GPIO.PWM(16, 100)<br/>PWM3 = GPIO.PWM(18, 100)<br/>PWM4 = GPIO.PWM(15, 100)<br/>PWM1.start(0)<br/>PWM2.start(0)<br/>PWM3.start(0)<br/>PWM4.start(0)<br/>PWR_MGMT_1 = 0x6B<br/>SMPLRT_DIV = 0x19<br/>CONFIG = 0x1A<br/>GYRO_CONFIG = 0x1B<br/>INT_ENABLE = 0x38<br/>ACCEL_XOUT_H = 0x3B<br/>ACCEL_YOUT_H = 0x3D<br/>ACCEL_ZOUT_H = 0x3F<br/>GYRO_XOUT_H = 0x43<br/>GYRO_YOUT_H = 0x45<br/>GYRO_ZOUT_H = 0x47<br/><br/>def MPU_Init():<br/>  bus.write_byte_data(Device_Address, SMPLRT_DIV, 7)<br/>  bus.write_byte_data(Device_Address, PWR_MGMT_1, 1)<br/>  bus.write_byte_data(Device_Address, CONFIG, 0)<br/>  bus.write_byte_data(Device_Address, GYRO_CONFIG, 24)<br/>  bus.write_byte_data(Device_Address, INT_ENABLE, 1)<br/><br/>def read_raw_data(addr):<br/>  high = bus.read_byte_data(Device_Address, addr)<br/>   low = bus.read_byte_data(Device_Address, addr+1)<br/>   value = ((high &lt;&lt; 8) | low)<br/>   if(value &gt; 32768):<br/>     value = value - 65536<br/>     return value<br/>  bus = smbus.SMBus(1)<br/>  Device_Address = 0x68<br/><br/>MPU_Init()<br/>while True:<br/>   acc_x = read_raw_data(ACCEL_XOUT_H)<br/>   acc_y = read_raw_data(ACCEL_YOUT_H)<br/>   acc_z = read_raw_data(ACCEL_ZOUT_H)<br/>   gyro_x = read_raw_data(GYRO_XOUT_H)<br/>   gyro_y = read_raw_data(GYRO_YOUT_H)<br/>   gyro_z = read_raw_data(GYRO_ZOUT_H)<br/>   Ax = (gyro_x/327)<br/>   Ay = (gyro_y/327)<br/>   for Ax &gt; 20:<br/>     PWM1.changeDutyCycle(Ax)<br/>     PWM3.changeDutyCycle(Ax)<br/>   for Ax &lt; -20:<br/>     PWM2.changeDutyCycle(Ax)<br/>     PWM4.changeDutyCycle(Ax)<br/><br/>   for Ay &gt; 20:<br/>     PWM1.changeDutyCycle(Ax)<br/>     PWM4.changeDutyCycle(Ax)<br/>   for Ay &lt; -20:<br/>     PWM2.changeDutyCycle(Ax)<br/>     PWM3.changeDutyCycle(Ax)<br/><br/><br/></pre>
<p>As you would have seen the code is almost the same till the time we reach the <kbd>while True</kbd> loop. Thereafter we have done a small trick. So let's see what it is. </p>
<pre> Ax = (gyro_x/327)<br/> Ay = (gyro_y/327)</pre>
<p>When the accelerometer is in the middle or in the flat lying position the value would be close to <kbd>32768</kbd>, which would be the central reading. Hence to find out what percentage we have tilted front or back we are using this line. To do that we are dividing it by <kbd>327</kbd>. What it does is, it gives a reading in between <kbd>0</kbd> - <kbd>100</kbd>. For example, if raw reading is <kbd>gryo_x</kbd> = <kbd>21000</kbd>, <kbd>gyro_x/327</kbd> = <kbd>64.22</kbd>. Now <kbd>64.22</kbd> would be reading of tilt in the percentage value.  This is important step for us as, this reading will help us determine the <kbd>DutyCycle</kbd> that we have to provide to the motors drivers. </p>
<pre> for Ax &lt; -20:<br/>         PWM2.changeDutyCycle(Ax)<br/>         PWM4.changeDutyCycle(Ax)</pre>
<p>This step is very simple, what we have done is simply taken a threshold for the readings beyond which the PWM would be provided to the motors. The <kbd>DutyCycle</kbd> for the PWM being provided to the motors would be directly proportional to the angle of tilt. </p>
<pre>for Ay &lt; -20:<br/>         PWM2.changeDutyCycle(Ax)<br/>         PWM3.changeDutyCycle(Ax)</pre>
<p><span>Just like we did before, in case the tilt is in another direction, then the motor drivers pins corresponding to the rear direction would be made high making it go backwards. The speed as before would be proportional to the tilt. </span></p>
<pre> for Ay &gt; 20:<br/>         PWM1.changeDutyCycle(Ax)<br/>         PWM4.changeDutyCycle(Ax)</pre>
<p><span>In this line, we are making the robotic vehicle turn in one direction. As before, due to the percentage value of tilt the <kbd>DutyCycle</kbd> will change and hence change the rate of turn. As you can see the robot's wheels will turn opposite to each other, hence the turn will be made while being on its axis. <br/></span></p>
<div class="packt_tip">Sometimes while using various libraries, the raw outputs can vary. To make sure your code works fine, firstly see the raw readings which you are getting. Once you get the readings write on a piece of paper what are the flat-line reading and maximum and minimum readings. These readings can change based on the made of the sensors as well. (There are a lot of counterfeits that does not give the same readings.) Once you see the entire span of the reading then you can make the desirable adjustment to the algorithms and make it work. </div>
<p><span>Go ahead, see how you can control it just by your hand gestures. </span></p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Making it more advanced</h1>
                </header>
            
            <article>
                
<p>In the previous chapter we have seen that we are making the car turn in any of the directions just based on our hand movements, however there is a problem with the previous code. Firstly the car is moving in one direction at a time, that is it's going either forward or backward or turning left or right. </p>
<p>It was not able to make a banking turn based on the hand gestures itself. To make it capable of doing so, we need to make the code even smarter. The overall connections to the robot would be exactly the same. But the code would be slightly different, so let's see what it is: </p>
<pre>import smbus<br/>from time import sleep<br/>import RPi.GPIO as GPIO<br/>int1 = 12<br/>int2 = 16<br/>int3 = 18<br/>int4 = 15<br/>GPIO.setup(int1, GPIO.OUT)<br/>GPIO.setup(int2, GPIO.OUT)<br/>GPIO.setup(int3, GPIO.OUT)<br/>GPIO.setup(int4, GPIO.OUT)<br/>PWM1 = GPIO.PWM(12, 100)<br/>PWM2 = GPIO.PWM(16, 100)<br/>PWM3 = GPIO.PWM(18, 100)<br/>PWM4 = GPIO.PWM(15, 100)<br/>PWM1.start(0)<br/>PWM2.start(0)<br/>PWM3.start(0)<br/>PWM4.start(0)<br/>PWR_MGMT_1 = 0x6B<br/>SMPLRT_DIV = 0x19<br/>CONFIG = 0x1A<br/>GYRO_CONFIG = 0x1B<br/>INT_ENABLE = 0x38<br/>ACCEL_XOUT_H = 0x3B<br/>ACCEL_YOUT_H = 0x3D<br/>ACCEL_ZOUT_H = 0x3F<br/>GYRO_XOUT_H = 0x43<br/>GYRO_YOUT_H = 0x45<br/>GYRO_ZOUT_H = 0x47<br/><br/>def MPU_Init():<br/>   bus.write_byte_data(Device_Address, SMPLRT_DIV, 7)<br/>   bus.write_byte_data(Device_Address, PWR_MGMT_1, 1)<br/>   bus.write_byte_data(Device_Address, CONFIG, 0)<br/>   bus.write_byte_data(Device_Address, GYRO_CONFIG, 24)<br/>   bus.write_byte_data(Device_Address, INT_ENABLE, 1)<br/>def read_raw_data(addr):<br/>   high = bus.read_byte_data(Device_Address, addr)<br/>   low = bus.read_byte_data(Device_Address, addr+1)<br/>   value = ((high &lt;&lt; 8) | low)<br/>   if(value &gt; 32768):<br/>     value = value - 65536<br/>     return value<br/>  bus = smbus.SMBus(1)<br/>  Device_Address = 0x68<br/>MPU_Init()<br/>while True:<br/>   acc_x = read_raw_data(ACCEL_XOUT_H)<br/>   acc_y = read_raw_data(ACCEL_YOUT_H)<br/>   acc_z = read_raw_data(ACCEL_ZOUT_H)<br/>   gyro_x = read_raw_data(GYRO_XOUT_H)<br/>   gyro_y = read_raw_data(GYRO_YOUT_H)<br/>   gyro_z = read_raw_data(GYRO_ZOUT_H)<br/>   Ax = (gyro_x/160)- 16384<br/>  Ay = (gyro_y/160)-16384<br/>   if Ax &gt; 20:<br/>     if Ay &gt; 20:<br/>       dc1 = Ax - Ay<br/>       PWM1.changeDutyCycle(dc1)<br/>       dc3 = Ax + Ay<br/>       PWM3.changeDutyCycle(dc3)<br/>   elif Ay &lt;- 20:<br/>     dc2 = Ax + Ay<br/>     PWM1.changeDutyCycle(dc)<br/>     dc4 = Ax - Ay<br/>     PWM3.changeDutyCycle(dc4)<br/>   else:<br/>     dc1=Ax<br/>     PWM1.changeDutyCycle(dc)<br/>     dc3=Ax<br/>     PWM3.changeDutyCycle(dc)<br/>    if Ax &lt; -20:<br/>       if Ay &gt; 20:<br/>         dc1 = Ax - Ay<br/>         dc3 = Ax + Ay<br/>         PWM1.changeDutyCycle(dc1)<br/>         PWM3.changeDutyCycle(dc3)<br/>       if Ay &lt;- 20:<br/>         dc2 = Ax + Ay<br/>         dc4 = Ax - Ay<br/>         PWM2.changeDutyCycle(dc2)<br/>         PWM4.changeDutyCycle(dc4)<br/>       else:<br/>         dc2=Ax<br/>         dc4=Ax<br/>         PWM2.changeDutyCycle(dc2)<br/>         PWM4.changeDutyCycle(dc4)</pre>
<p>Now let's see all the changes we have done to the code. The entire sensing mechanism is the same, however, data processing has a major overhaul. So let's see what it is:</p>
<pre> If Ax &gt; 20:<br/>     if Ay &gt; 20:<br/>         dc1 = Ax - Ay<br/>         PWM1.changeDutyCycle(dc1)<br/>         dc3 = Ax + Ay<br/>         PWM3.changeDutyCycle(dc3)</pre>
<p>Now here we are comparing the value of <kbd>Ax</kbd>. If the value of <kbd>Ax &gt; 20</kbd> then the code below it would run. We have done this because, the accelerometer is extremely sensitive and can sense slightest vibration. Due to this there can be erroneous output. So to filter it we have a threshold value of <kbd>20</kbd>. That is till the time the accelerometer is 20% tilted, this code will not come into effect. Similarly we are doing this for the y axis as well. Once that is done that percentage value is given to the line <kbd>dc1 = Ax - Ay</kbd>. What this is doing is taking the tilt in x axis which is the forward axis and subtracting it with movement of <em>Y</em>. In the second line we are doing the same thing with the other side of the motors however rather than subtracting the value of <em>Y</em> we are adding it. Hence what it would do is to create a difference of speed in between the speed of motors on the opposite ends. This speed difference would be directly proposal to the angular tilt of the <em>Y</em> axis. Hence more the tilt, the more would be the change in the speed and more would be the angle of the turn. </p>
<pre>elif Ay &lt;- 20:<br/><br/>    dc2 = Ax + Ay<br/>    PWM1.changeDutyCycle(dc)<br/>    dc4 = Ax - Ay<br/>    PWM3.changeDutyCycle(dc4)</pre>
<p>In the next line what we have done is that we have made a condition for the tilt on the other side of the accelerometer by sensing <kbd>Ay &lt; -20</kbd>. If the value is smaller than <kbd>-20</kbd> then the following algorithm would come into play. </p>
<p>Here the lines are exactly the same. However the mathematical operators have been inverted. Hence  for the first motor, instead of subtracting the value of <em>Y</em> now we are adding it. On the other hand for the second motor rather than adding the value we are subtracting it. </p>
<pre> Else:<br/><br/>     dc1=Ax<br/>     PWM1.changeDutyCycle(dc)<br/>     dc3=Ax<br/>     PWM3.changeDutyCycle(dc)</pre>
<p>Finally, if the value of <kbd>Ax</kbd> is greater than <kbd>20</kbd> but the value of <kbd>Ay</kbd> is between <kbd>-20</kbd> and <kbd>+20</kbd> then we will assume that the car has to go straight. Hence the value of the <kbd>Ax</kbd> is directly getting passed on to both the motors, making it go entirely straight. </p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we have understood on how accelerometer and gyros functions. We have taken the raw data of the gyro and accelerometer and utilized it to make a gesture-controlled robot. Finally, onto the next and final chapter of the book, where we will continue our journey with the most exciting chapter you were looking forward to.</p>
<p> </p>


            </article>

            
        </section>
    </div></body></html>