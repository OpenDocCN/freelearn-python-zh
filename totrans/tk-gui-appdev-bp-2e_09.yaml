- en: Multiple Fun Projects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多种趣味项目
- en: By now, we have explored most of the important features of Tkinter. Let's use
    this chapter to explore aspects of programming that, though not core to Tkinter,
    are often encountered while writing GUI applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经探索了 Tkinter 的大部分重要特性。让我们利用本章来探讨在编写 GUI 应用程序时虽然不是 Tkinter 的核心，但经常遇到的一些编程方面。
- en: 'In this chapter, we will develop several small applications from different
    domains. The applications we will build here include:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从不同领域开发几个小型应用程序。我们将构建的应用程序包括：
- en: A snake game application
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蛇形游戏应用
- en: A weather reporter application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 天气预报应用
- en: A port scanner application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端口扫描应用程序
- en: A chat application
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聊天应用程序
- en: A phone book application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电话簿应用程序
- en: An ultrasound distance scanner application
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超声波测距扫描仪应用
- en: 'Some of the key objectives of the chapter are:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的一些关键目标包括：
- en: To learn to use `Queue` module to avoid race conditions and other synchronization
    issues involved in writing multithreaded programs
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习使用 `Queue` 模块以避免在编写多线程程序时出现的竞态条件和其它同步问题
- en: To understand the basics of data mining over the network
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解网络数据挖掘的基本原理
- en: To understand socket programming and to learn the basics of server-client architecture
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了理解套接字编程以及学习服务器-客户端架构的基础
- en: To learn database programming
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习数据库编程
- en: To learn to use `asyncio` with Tkinter
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用 `asyncio` 与 Tkinter
- en: To learn how to interface and interact with external hardware components using
    serial communication
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用串行通信接口和交互外部硬件组件
- en: Technical requirements
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Most of the projects in this chapter rely on the standard libraries and do not
    require anything extra. The exception is the ultrasonic range finder project,
    which requires an Arduino board and an ultrasonic range finder sensor.  The hardware
    is relatively cheap (under 10 dollars). You may also decide not to buy the hardware
    and still read the project to understand how serial communication takes place
    between two pieces of equipment.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的大多数项目都依赖于标准库，不需要额外的东西。例外的是超声波测距仪项目，该项目需要一个Arduino板和一个超声波测距仪传感器。硬件相对便宜（低于10美元）。你也可以选择不购买硬件，仍然可以阅读该项目，了解两台设备之间如何进行串行通信。
- en: In addition, you will also need to download and install the Arduino **integrated
    development environment** (**IDE**), the details of which will be discussed in
    the project itself.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您还需要下载并安装Arduino **集成开发环境**（**IDE**），其具体细节将在项目本身中进行讨论。
- en: Building a Snake game
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个贪吃蛇游戏
- en: Let's now build a simple Snake game. As usual, we will be making use of the
    `Canvas` widget to provide the platform for our Snake program. We will use `canvas.create_line`
    to draw our snake and `canvas.create_rectangle` to draw the snake food.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在构建一个简单的贪吃蛇游戏。像往常一样，我们将使用`Canvas`小部件为我们的蛇程序提供平台。我们将使用`canvas.create_line`来绘制蛇，以及`canvas.create_rectangle`来绘制蛇的食物。
- en: The primary objective of this project is to learn how to use `Queue` module
    as a **synchronization technique** in a multithreaded application.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目的首要目标是学习如何在多线程应用程序中把`Queue`模块用作**同步技术**。
- en: Writing a multithreaded application poses the challenge of synchronization between different
    threads. When multiple threads try to access shared data simultaneously, the data
    is likely to get corrupted or modified in ways that were not intended in the program.
    This is called a **race condition**.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 编写多线程应用程序会面临不同线程之间同步的挑战。当多个线程试图同时访问共享数据时，数据很可能会被损坏或以程序中未预期的方式修改。这被称为**竞态条件**。
- en: Understanding a race condition
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解竞态条件
- en: 'The `9.01_race_condition.py` code demonstrates a race condition. The program
    is as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`9.01_race_condition.py` 代码演示了竞态条件。程序如下：'
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding code consists of two methods named `increment` and `decrement`
    that both operate on a single shared variable named `shared_var`. These two methods
    are called from separate threads.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码包含两个名为 `increment` 和 `decrement` 的方法，这两个方法都操作一个名为 `shared_var` 的单个共享变量。这两个方法是从不同的线程中调用的。
- en: One would expect that an equal number of increments and decrements on a shared variable
    would produce no change in its value at the end. However, when you run this program,
    say 100 times as before, it produces a different value for the shared variable
    in each consecutive run. This is a classic example for how a race condition can
    make the output of a program nondeterministic.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 人们会预期在共享变量上进行相同数量的增加和减少操作，其值在结束时不会发生变化。然而，当你运行这个程序，比如像之前那样运行100次，每次连续运行都会得到共享变量的不同值。这是一个经典的例子，说明了竞争条件如何使程序输出变得非确定性。
- en: Race conditions occur because we cannot predict the thread execution order at
    all. The operating system does it very randomly and so the execution order of
    threads varies each time the program is run.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 竞态条件发生是因为我们根本无法预测线程的执行顺序。操作系统执行得非常随机，因此每次程序运行时线程的执行顺序都会有所不同。
- en: Using synchronization primitives
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用同步原语
- en: To handle this complexity, the `threading` module provides some synchronization primitives,
    such as locks, joins, semaphores, events, and condition variables.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理这种复杂性，`threading`模块提供了一些同步原语，例如锁、join操作、信号量、事件和条件变量。
- en: '`9.02_lock_demo.py` slightly modifies the preceding code by introducing a `lock`
    using this line:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`9.02_lock_demo.py` 通过引入此行使用 `lock` 对前面的代码进行了轻微修改：'
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, every time `shared_variable` is to be modified, it is done after acquiring
    a `lock`. The `lock` is released when the variable has been modified, as shown
    in the following code:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，每次要修改`shared_variable`时，都是在获取一个`lock`之后进行的。当变量被修改后，`lock`会被释放，如下面的代码所示：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This enables us to avoid a race condition. Since this code operates with a `lock`,
    it produces no change in the shared variable after an equal number of increments and
    decrements.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够避免竞态条件。由于此代码使用`锁`进行操作，在等量的增加和减少之后，它不会在共享变量中产生任何变化。
- en: It seemed easy to use the `lock` mechanism to avoid a race condition. However,
    as the complexity of a program grows, there are many places where a variable may
    be modified. Tracking large code bases for places where a variable may be changed is
    often a difficult task.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`锁`机制来避免竞态条件似乎很简单。然而，随着程序复杂性的增加，可能会有许多地方会修改变量。追踪大型代码库中可能被修改的变量位置通常是一项困难的任务。
- en: Using queues
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用队列
- en: In most cases, it is safer and simpler to use **queues**. Simply put, a queue
    is a compound memory structure that is thread-safe. Queues effectively channel
    access to a resource to multiple threads in a sequential order, and are a recommended
    design pattern that uses threads for most of the scenarios that require concurrency.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，使用**队列**更安全、更简单。简单来说，队列是一种线程安全的复合内存结构。队列有效地按顺序将资源的访问权限分配给多个线程，并且是推荐的设计模式，适用于大多数需要并发的场景。
- en: The `Queue` module provides a way to implement different kinds of queuing, such as
    FIFO (default implementation), LIFO queues, and priority queues, and this module comes
    with a built-in implementation of all the locking semantics required for running multithreaded
    programs.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`Queue`模块提供了一种实现不同类型队列的方法，例如FIFO（默认实现）、LIFO队列和优先队列，并且该模块自带了运行多线程程序所需的所有锁定语义的内置实现。'
- en: 'Here''s a quick roundup of the basic usage of the `Queue` module:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`Queue`模块基本用法的快速总结：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s see a simple demonstration of using a queue to implement a multithreaded application
    (see `9.03_threading_with_queue.py`):'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用队列实现多线程应用程序的一个简单示例（见`9.03_threading_with_queue.py`）：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The description of the code is as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的描述如下：
- en: We first create a `Consumer` class, which inherits from the `threading` module of
    Python. The `__init__` method takes in a queue as its argument.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们首先创建一个`Consumer`类，它继承自Python的`threading`模块。`__init__`方法接受一个队列作为其参数。
- en: We then override the `run` method of the `threading` module to get each item
    from the queue using `queue.get()`, which is then passed on to the `task_handler`
    method, which actually executes the task specified in the current queue item.
    In our example, it does nothing useful except print the name of the task.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们随后覆盖了`threading`模块的`run`方法，通过使用`queue.get()`从队列中获取每个项目，然后将其传递给`task_handler`方法，该方法实际上执行当前队列项中指定的任务。在我们的示例中，它除了打印任务的名称外，没有做任何有用的事情。
- en: After the work is done on a particular thread by our `task_handler` method, it
    sends a signal to the queue telling it that the task has been completed using the
    `queue.task_done()` method.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的`task_handler`方法完成特定线程的工作后，它通过使用`queue.task_done()`方法向队列发送一个信号，告知任务已完成。
- en: Outside our `Consumer` class, we create an empty queue in our `producer()` module
    function. This queue is populated with a list of tasks using `queue.put(task)`.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的`Consumer`类外部，我们在`producer()`模块函数中创建了一个空队列。这个队列通过使用`queue.put(task)`方法被填充了一个任务列表。
- en: We then create six different threads and pass this populated queue as its argument.
    Now that the tasks are handled by the queue, all threads automatically ensure
    that the tasks are completed in the sequence in which they are encountered by
    the threads, without causing any deadlocks or two different threads trying to
    work on the same queued task.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们随后创建了六个不同的线程，并将这个已填充的队列作为其参数传递。现在，由于任务由队列处理，所有线程都会自动确保任务按照线程遇到它们的顺序完成，而不会造成任何死锁或两个不同的线程试图处理同一个队列任务的情况。
- en: At the time of creating each thread, we also create a pool of daemon threads using
    `my_thread.daemon = True`. Doing this passes control to our main program once
    all threads have completed execution. If you comment out the line, the program
    would still run, but would fail to exit after all threads have completed executing
    the tasks in the queue. Without the daemon threads, you'd have to keep track of
    all the threads and tell them to exit before your program could completely quit.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创建每个线程时，我们也会使用 `my_thread.daemon = True` 创建一个守护线程池。这样做一旦所有线程完成执行，就会将控制权传递给我们的主程序。如果你注释掉这一行，程序仍然会运行，但在所有线程完成执行队列中的任务后，程序将无法退出。如果没有守护线程，你将不得不跟踪所有线程，并在你的程序完全退出之前告诉它们退出。
- en: Finally, the `queue.join()` method ensures that the program flow waits there until
    all queued tasks are actually done and the queue is empty.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，`queue.join()` 方法确保程序流程在此等待，直到所有排队任务实际上完成并且队列变为空。
- en: Building the Snake game
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建贪吃蛇游戏
- en: With that background information about using a queue to handle multithreaded applications,
    let's build our Snake game.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了使用队列处理多线程应用程序的背景信息之后，让我们构建我们的贪吃蛇游戏。
- en: 'Upon completion, the game will look as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏完成后，其外观将如下所示：
- en: '![](img/dbe3da18-357d-4e24-93fb-0ecdd3be9304.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dbe3da18-357d-4e24-93fb-0ecdd3be9304.png)'
- en: The View class
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图类
- en: 'Let''s start coding our game by first creating a basic `View` class. This class
    will be responsible for creating the GUI, checking for *game over* logic, and
    most importantly acting as the consumer, taking items from the queue and processing them
    to update the view (see `9.04_game_of_snake.py`):'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先通过创建一个基本的`View`类来开始编写我们的游戏代码。这个类将负责创建GUI，检查*游戏结束*逻辑，并且最重要的是充当消费者，从队列中取出项目并处理它们以更新视图（参见`9.04_game_of_snake.py`）：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding code should be mostly familiar to you by now as we have written similar
    code in the past. Note, however, that rather than passing the root instance as
    an argument to its `__init__` method, our `View` class now inherits from the `Tk` class.
    The line `Tk.__init__(self)` ensures that the root window is available to all methods
    of this class. This way we can avoid writing a root attribute on every line by
    referencing root simply as `self`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，前面的代码应该对你来说已经很熟悉了，因为我们以前写过类似的代码。然而，请注意，我们现在的`View`类不是将根实例作为参数传递给其`__init__`方法，而是从`Tk`类继承。这行代码`Tk.__init__(self)`确保根窗口对所有这个类的所有方法都是可用的。这样我们就可以通过简单地引用`self`来避免在每一行都写上根属性。
- en: This class will also have code to process items put in the queue. We will code
    the rest of this class after we have coded the classes that put items in the queue.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 本节课还将包含处理队列中放入的项目代码。在编写了将项目放入队列的类之后，我们将继续编写本节课的其余代码。
- en: The Food class
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 食品类别
- en: 'Next, we will create the `Food` class (see `9.04_game_of_snake.py`):'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建`Food`类（参见`9.04_game_of_snake.py`）：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The description of the code is as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的描述如下：
- en: Because we want to process all data centrally from within a queue, we pass the
    queue as an argument to the `__init__` method of the `Food` class.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为我们希望从队列内部集中处理所有数据，所以我们把队列作为参数传递给`Food`类的`__init__`方法。
- en: The `__init__` method calls another method called `generate_food`, which is responsible
    for generating the snake food at random positions on the canvas.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__init__` 方法调用了另一个名为 `generate_food` 的方法，该方法负责在画布上随机位置生成蛇的食物。'
- en: The `generate_food` method generates a random (`x`, `y`) position on the canvas.
    However, because the place where the coordinates coincide is just a small point
    on the canvas, it would be barely visible. We, therefore, generate an expanded
    coordinate (`rectangle_position` ) ranging from five values less than the (`x`,
    `y`) coordinate up to five values higher than the same coordinate. Using this
    range, we can create a small rectangle on the canvas that would be easily visible
    and would represent our food.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`generate_food` 方法在画布上生成一个随机的 (`x`, `y`) 位置。然而，因为坐标重合的地方只是画布上的一个很小的点，几乎看不见。因此，我们生成一个扩展的坐标（`rectangle_position`），范围从比
    (`x`, `y`) 坐标小五个值的范围到比相同坐标高五个值的范围。使用这个范围，我们可以在画布上创建一个容易看见的小矩形，它将代表我们的食物。'
- en: However, we do not create the rectangle here. Instead, we pass the coordinates
    for the food (rectangle) into our queue using `queue.put`.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然而，我们在这里并没有创建矩形。相反，我们使用 `queue.put` 将食物（矩形）的坐标传递到我们的队列中。
- en: The Snake class
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 蛇类
- en: 'Let''s now create the `Snake` class. We have already passed a task to generate
    our food to the central queue. However, no additional thread was involved in the
    task. We could also generate our `Snake` class without using threads. However,
    because we are talking about ways to implement multithreaded applications, let''s
    implement our `Snake` class to work from a separate thread (see `9.04_game_of_snake.py`):'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来创建`Snake`类。我们已经在中央队列中分配了一个任务来生成我们的食物。然而，这个任务并没有涉及到额外的线程。我们也可以在不使用线程的情况下生成我们的`Snake`类。但是，因为我们正在讨论实现多线程应用程序的方法，所以让我们将我们的`Snake`类实现为从单独的线程中工作（参见`9.04_game_of_snake.py`）：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The description of the code is as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的描述如下：
- en: We create a class named `Snake` to run from a separate thread. This class takes the
    `queue` as its input arguments.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建一个名为 `Snake` 的类，使其在一个独立的线程中运行。这个类以 `queue` 作为其输入参数。
- en: We initialize the points earned by the player from zero and set the initial location
    of the snake using the attribute `self.snake_points`. Note that initially, the
    snake is `40` pixels long.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将玩家获得的成绩初始化为零，并使用属性`self.snake_points`设置蛇的初始位置。注意，最初，蛇的长度为`40`像素。
- en: Finally, we start the thread and create an infinite loop to call the `move()` method
    at small intervals. During every run of the loop, the method populates the `queue`
    with a dictionary having the key as move and the value equal to the updated position
    of the snake, through the `self.snake_points` attribute.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们启动线程并创建一个无限循环，以小间隔调用`move()`方法。在每次循环运行期间，该方法通过`self.snake_points`属性，将一个字典填充到`queue`中，其中键为移动，值为蛇的更新位置。
- en: First, the `move` method obtains the latest coordinates for the snake depending
    on the keyboard event. It uses a separate method called `calculate_new_coordinates`
    to get the latest coordinates.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，`move`方法根据键盘事件获取蛇的最新坐标。它使用一个名为`calculate_new_coordinates`的独立方法来获取最新的坐标。
- en: It then checks whether the location of the new coordinates coincides with the
    location of the food. If they match, it increases the score of the player by one
    and calls the `Food` class' `generate_food` method to generate a new food at a new
    location.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后它会检查新坐标的位置是否与食物的位置相匹配。如果它们匹配，它会将玩家的得分增加一分，并调用`Food`类的`generate_food`方法在新的位置生成新的食物。
- en: If the current point does not coincide with the food coordinates, it deletes
    the first item from the snake coordinates using `self.snake_points.pop(0)`.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果当前点与食物坐标不重合，它将使用 `self.snake_points.pop(0)` 删除蛇坐标中的第一个项目。
- en: Then, it calls another method named `check_game_over` to check whether the snake collides
    with the wall or itself. If the snake does collide, it appends a new dictionary
    item in the queue with the value `'game_over':True`.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，它调用另一个名为 `check_game_over` 的方法来检查蛇是否撞到墙壁或自身。如果蛇发生碰撞，它将在队列中添加一个新的字典项，其值为 `'game_over':True`。
- en: 'Finally, if the game is not over, it appends the new position of the snake
    to the list `self.snake_points`. This is automatically added to the queue, because
    we have defined `self.queue.put({''move'': self.snake_points } )` in the `Snake`
    class''s `run()` method to update every `0.1` seconds as long as the game is not
    over.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '最后，如果游戏尚未结束，它会将蛇的新位置添加到列表 `self.snake_points` 中。这会自动加入到队列中，因为我们已经在 `Snake`
    类的 `run()` 方法中定义了 `self.queue.put({''move'': self.snake_points })`，以便在游戏未结束的情况下每
    `0.1` 秒更新一次。'
- en: Queue handler
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 队列处理器
- en: Now that the queue is getting populated with various actionables, let's create
    the `queue_handler` method to process the items in the queue and update the `View` accordingly.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在队列中已经填充了各种可执行项，让我们创建`queue_handler`方法来处理队列中的项目并相应地更新`View`。
- en: 'We define the `queue_handler()` method in our `View` class as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`View`类中定义了`queue_handler()`方法如下：
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The description for the code is as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的描述如下：
- en: The `queue_handler` method gets into an infinite loop looking for tasks in the
    queue using `task = self.queue.get_nowait()`. If the queue becomes empty, the
    loop is restarted using `canvas.after`.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`queue_handler` 方法会陷入一个无限循环，使用 `task = self.queue.get_nowait()` 在队列中查找任务。如果队列变为空，循环会通过
    `canvas.after` 重新启动。'
- en: When we use `queue_get_nowait()`, the call does not block the calling thread
    until an item is available. It removes and returns an item from the queue, if
    available. If the queue is empty, it raises `Queue.Empty`.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们使用 `queue_get_nowait()` 时，调用不会阻塞调用线程直到有项目可用。如果可用，它会从队列中移除并返回一个项目。如果队列是空的，它会引发
    `Queue.Empty`。
- en: Once a task is fetched from the queue, the method checks its key.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦从队列中获取了一个任务，该方法会检查其键。
- en: If the key is `game_over`, it calls another method named `game_over()` which
    we define next.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果键是`game_over`，它将调用另一个名为`game_over()`的方法，我们将在下面定义它。
- en: If the key of the task is `move`, it uses `canvas.coords` to move the line to
    its new position.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果任务的键是`move`，它使用`canvas.coords`将线条移动到其新位置。
- en: If the key is `points_earned`, it updates the score on the canvas.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果键是`points_earned`，它将更新画布上的分数。
- en: 'When the execution of a task completes, it signals the thread with the `task_done()` method. Finally,
    we create the main loop as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个任务执行完成后，它通过`task_done()`方法向线程发出信号。最后，我们创建主循环如下：
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Our game is now functional. Go and try controlling the snake while keeping its stomach
    filled.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏现在已可运行。去尝试控制蛇，同时保持它的肚子饱饱的。
- en: Creating a Weather Reporter application
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个天气播报应用程序
- en: Let's now build a simple Weather Reporter application. The weather data for
    any given location will be fetched from the network, suitably formatted, and presented to
    the user.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在构建一个简单的天气报告应用。任何给定位置的天气数据将从网络中获取，进行适当的格式化，并展示给用户。
- en: 'We will use a higher level module named `urllib` to fetch weather data from
    the web. The `urllib` module is part of Python''s standard library and it provides
    an easy to use API for working with URLs. It has four submodules:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个名为 `urllib` 的高级模块从网络中获取天气数据。`urllib` 模块是 Python 的标准库的一部分，它提供了一个易于使用的
    API，用于处理 URL。它包含四个子模块：
- en: '`urllib.request`: For opening and reading URLs'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`urllib.request`: 用于打开和读取URL'
- en: '`urllib.error`: For handling exceptions raised by `urllib.request`'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`urllib.error`: 用于处理由 `urllib.request` 引起的异常'
- en: '`urllib.parse`: For parsing URLs'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`urllib.parse`: 用于解析URL'
- en: '`urllib.robotparser`: For parsing `robots.txt` files'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`urllib.robotparser`: 用于解析 `robots.txt` 文件'
- en: 'With `urllib.request`, fetching the contents of a web page turns into three
    lines of code   (see `9.05_urllib_demo.py`):'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '使用 `urllib.request`，获取网页内容只需三行代码   (参见 `9.05_urllib_demo.py`):'
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This prints the entire HTML source code or whatever is the response from the
    web page [http://www.packtpub.com](http://www.packtpub.com). This is, in essence,
    the core of mining the web for information.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印整个HTML源代码或网页[http://www.packtpub.com](http://www.packtpub.com)的响应。本质上，这是从网络中挖掘信息的核心。
- en: 'Now that we know how to get data from a URL, let''s apply it to building our
    Weather Reporter application. This application should take the location as an
    input from the user and fetch relevant weather-related data, as shown in the following
    screenshot:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何从URL获取数据，让我们将其应用到构建我们的天气报告应用中。这个应用应该从用户那里获取位置输入，并获取相关的天气数据，如下面的截图所示：
- en: '![](img/62812610-8b31-43db-915d-8da3ee60cbf7.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/62812610-8b31-43db-915d-8da3ee60cbf7.png)'
- en: 'We create a class, `WeatherReporter`, and call it from outside the class within
    the `mainloop` (see the code of `9.06_weather_reporter.py`):'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为 `WeatherReporter` 的类，并在类外部的 `mainloop` 中调用它（参见 `9.06_weather_reporter.py`
    的代码）：
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We do not discuss the code for creating this GUI here, as we have done similar
    coding many times in all the the previous chapters. The weather data is displayed
    on a canvas (see `9.06_weather_reporter.py`):'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里不讨论创建此GUI的代码，因为我们已经在所有前面的章节中多次进行过类似的编码。天气数据在画布上显示（见`9.06_weather_reporter.py`）：
- en: When you specify a location and click on the **Go** button, it calls a command
    callback named `on_show_weather_button_clicked`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当你指定一个位置并点击**前往**按钮时，它会调用一个名为`on_show_weather_button_clicked`的命令回调。
- en: We then fetch the weather data from a website.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后从网站获取天气数据。
- en: There are two ways to fetch data from a website. The first method involves getting an
    HTML response from a website, and then parsing the received HTML response for
    data that is relevant to us. This type of data extraction is called **site scraping**.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 从网站获取数据有两种方法。第一种方法涉及从网站获取HTML响应，然后解析收到的HTML响应以获取与我们相关的数据。这种数据提取方式被称为**网站抓取**。
- en: '**Scrapy** and **Beautiful Soup** are two popular site-scraping frameworks
    for extracting data from websites. You can find the official documentation of
    the two libraries at [http://scrapy.org/](http://scrapy.org/) and [http://www.crummy.com/software/BeautifulSoup/](http://www.crummy.com/software/BeautifulSoup/).'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**Scrapy** 和 **Beautiful Soup** 是两个流行的网站抓取框架，用于从网站中提取数据。您可以在[http://scrapy.org/](http://scrapy.org/)
    和 [http://www.crummy.com/software/BeautifulSoup/](http://www.crummy.com/software/BeautifulSoup/)
    找到这两个库的官方文档。'
- en: Site scraping is a rather crude method that is employed only when a given website does
    not provide a structured way to retrieve data. On the other hand, some websites are
    willing to share data through a set of APIs, provided you query it for data using the
    specified URL structure. This is clearly more elegant than site scraping, because data
    is interchanged in a reliable and *mutually agreed* format.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 网站抓取是一种相当粗糙的方法，只有在给定网站不提供结构化数据检索方式时才会使用。另一方面，一些网站愿意通过一组API共享数据，前提是你使用指定的URL结构查询数据。这显然比网站抓取更优雅，因为数据是以可靠和*相互同意*的格式进行交换的。
- en: For our Weather Reporter application, we want to query some weather channels for
    a given location, and in turn retrieve and display the data on our canvas.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的天气报道应用，我们希望针对特定位置查询一些天气频道，然后检索并显示数据到我们的画布上。
- en: 'Fortunately, there are several weather APIs that we can use. In our example,
    we will use the weather data provided by the following website:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有几个天气API我们可以使用。在我们的示例中，我们将使用以下网站提供的天气数据：
- en: '[http://openweathermap.org/](http://openweathermap.org/)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://openweathermap.org/](http://openweathermap.org/)'
- en: 'In order to use the API, you need to sign up for a free API key here:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用API，您需要在此处注册一个免费的API密钥：
- en: '[http://home.openweathermap.org/users/sign_up](http://home.openweathermap.org/users/sign_up)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '[注册](http://home.openweathermap.org/users/sign_up)'
- en: The `OpenWeatherMap` service provides free weather data and forecast APIs. This
    site collates weather data from more than 40,000 weather stations across the globe,
    and the data can be assessed by city name and geographic coordinates, or their
    internal city ID.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`OpenWeatherMap` 服务提供免费的天气数据和预报 API。该网站收集来自全球超过 40,000 个气象站的天气数据，数据可以通过城市名称和地理坐标，或者它们的内部城市
    ID 进行评估。'
- en: 'The website provides weather data in two data formats:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 该网站提供两种数据格式的天气数据：
- en: '**JSON** (**JavaScript Object Notation**)'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JSON** （**JavaScript 对象表示法**）'
- en: '**XML** (**Extensible Markup Language**)'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**XML** （**可扩展标记语言**）'
- en: XML and JSON are two popular interchangeable data serialization formats widely used
    for interchanging data between different applications, which may be running on different
    platforms and using different programming languages, thus providing the benefit
    of interoperability.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: XML和JSON是两种流行的可互换数据序列化格式，广泛用于在不同应用程序之间交换数据，这些应用程序可能运行在不同的平台和不同的编程语言上，从而提供了互操作性的好处。
- en: JSON is simpler than XML, because its grammar is simpler and it maps more directly onto
    the data structures used in modern programming languages. JSON is better suited
    for exchanging data, but XML is good for exchanging documents.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 比 XML 更简单，因为它的语法更简单，并且更直接地映射到现代编程语言中使用的数据结构。JSON 更适合交换数据，但 XML 适合交换文档。
- en: 'The API documentation tells us of a query such as:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: API 文档告诉我们查询的例子如下：
- en: '[PRE12]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The preceding code returns weather data for London in JSON format as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码返回伦敦的天气数据，格式如下：
- en: '[PRE13]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The syntax of JSON is simple. Any piece of JSON data is a name/value pair and
    each piece of data is separated from the others by commas. JSON uses curly braces
    `{}` to hold objects and square brackets `[ ]` to hold arrays. Accordingly, we
    define a method to get the weather data in JSON format in our application (see
    `9.06_weather_reporter.py`):'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 的语法简单。任何 JSON 数据都是一个名称/值对，并且每条数据都由逗号与其它数据分隔。JSON 使用花括号 `{}` 来包含对象，使用方括号
    `[ ]` 来包含数组。因此，我们在应用程序中定义了一个方法来获取以 JSON 格式的天气数据（见 `9.06_weather_reporter.py`）：
- en: '[PRE14]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The description for the code is as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的描述如下：
- en: This method uses `urllib` to retrieve responses from the website. It returns the
    response in JSON format.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此方法使用 `urllib` 从网站检索响应。它以 JSON 格式返回响应。
- en: Now, we'll start processing the JSON data. The weather data returned using the
    API is encoded in JSON format. We need to convert this data into the Python data
    type. Python provides a built-in `json` module that simplifies the process of
    encoding/decoding JSON data. We therefore import the `json` module into our current
    namespace.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，我们将开始处理 JSON 数据。使用 API 返回的天气数据是以 JSON 格式编码的。我们需要将这些数据转换为 Python 数据类型。Python
    提供了一个内置的 `json` 模块，它简化了编码/解码 JSON 数据的过程。因此，我们将 `json` 模块导入到我们的当前命名空间中。
- en: 'Then, we''ll use this module to convert the retrieved JSON data into the Python
    dictionary format (see `9.06_weather_reporter.py`):'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将使用这个模块将检索到的 JSON 数据转换为 Python 字典格式（参见 `9.06_weather_reporter.py`）：
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now that we have a dictionary of all weather-related information provided by
    the API, we simply display the retrieved weather data using `canvas.create_text`
    and `canvas.create_image`. The code for displaying the weather data is self-explanatory
    (see `9.06_weather_reporter.py`).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了API提供的所有与天气相关的信息字典，我们只需使用`canvas.create_text`和`canvas.create_image`来显示检索到的天气数据。显示天气数据的代码是自我解释的（见`9.06_weather_reporter.py`）。
- en: Our Weather Reporter application is now functional.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的天气报道应用现在已启用。
- en: When you access a server from your Python program, it is very important to send
    requests after small time gaps.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当您从Python程序访问服务器时，在发送请求后留出小的时间间隔非常重要。
- en: A typical Python program is capable of running several million instructions
    per second. However, the server that sends you the data at the other end is not
    equipped to work at that speed. If you knowingly or unknowingly send a large number
    of requests to a server within a short time span, you may prevent it from servicing
    its routine requests from normal web users. This constitutes what is called a **denial
    of service** (**DOS**) attack on the server. You may be banned or, in a worst
    case scenario, be sued for disrupting a server, if your program does not make
    a limited number of well-behaved requests.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的 Python 程序每秒可以执行数百万条指令。然而，向你发送数据的另一端的服务器并没有配备以那种速度工作的能力。如果你在短时间内有意或无意地向服务器发送大量请求，你可能会阻止它为正常网络用户处理常规请求。这构成了对服务器所谓的**拒绝服务**（**DOS**）攻击。如果你的程序没有发送有限数量的良好行为请求，你可能会被禁止访问，或者在最坏的情况下，因为破坏服务器而被告上法庭。
- en: To summarize the code for the Weather Reporter, we use the `urllib` module to query
    the weather API provided by our data provider. The data is fetched in JSON format.
    The JSON data is then decoded into a Python-readable format (dictionary).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 总结天气报告的代码，我们使用`urllib`模块来查询数据提供者提供的天气API。数据以JSON格式获取。然后，将JSON数据解码成Python可读的格式（字典）。
- en: The converted data is then displayed on the canvas using the `create_text` and `create_image`
    methods.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 转换后的数据随后使用 `create_text` 和 `create_image` 方法在画布上显示。
- en: A simple socket demo
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个简单的套接字示例
- en: The goal of this project is to introduce you to the basics of network programming and
    how to use it in your GUI application.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目的目标是向您介绍网络编程的基础知识以及如何在您的图形用户界面应用程序中使用它。
- en: Python has great support for network programming. At the lowest level, Python provides
    a `socket` module that lets you connect and interact with the network using a
    simple-to-use, object-oriented interface.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Python 对网络编程有着强大的支持。在最低级别上，Python 提供了一个 `socket` 模块，它允许你使用简单易用、面向对象的接口连接和与网络进行交互。
- en: For those new to socket programming, **sockets** are the fundamental concept
    behind any kind of network communication done by your computer. For instance,
    when you type `www.packtpub.com` in your browser, the operating system on your
    computer opens a socket and connects to the remote server to fetch the web page
    for you. The same happens with any application that needs to connect to the network.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些刚开始学习套接字编程的人来说，**套接字**是计算机进行任何网络通信的基本概念。例如，当你在你浏览器中输入`www.packtpub.com`时，你的计算机操作系统会打开一个套接字并连接到远程服务器以为你获取网页。任何需要连接到网络的应用程序都会发生同样的事情。
- en: 'More specifically, sockets refer to a communications endpoint that is characterized by
    a five-element tuple that contains the following information:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，套接字指的是一个通信端点，它由一个包含以下信息的五个元素元组来表征：
- en: '[PRE16]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This tuple must be unique for communication on a channel between a local machine
    and a remote machine.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这个元组必须对于在本地机器和远程机器之间通信的通道是唯一的。
- en: Sockets may be connection-oriented or connectionless. Connection-oriented sockets
    allow for the flow of data to and fro as required. Connectionless sockets (or
    datagram sockets) allow only one message at a time to be transmitted, without
    an open connection.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字可以是面向连接的或无连接的。面向连接的套接字允许根据需要双向传输数据。无连接套接字（或数据报套接字）一次只能传输一条消息，而不需要建立开放连接。
- en: Sockets can be classified into different types or families. The two most common socket
    families are `AF_INET` (for internet connections) and `AF_UNIX` for interprocess communications
    on a Unix machine. We will use `AF_INET` in our chat program.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字可以分为不同的类型或家族。最常用的两种套接字家族是`AF_INET`（用于互联网连接）和`AF_UNIX`（用于Unix机器上的进程间通信）。在我们的聊天程序中，我们将使用`AF_INET`。
- en: This is the lowest level at which a programmer can access the network. Underneath the
    socket layer lie raw UDP and TCP connections, which are handled by your computer's
    operating system with no direct access points for programmers.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最底层程序员可以访问网络的级别。在套接字层之下，是原始的UDP和TCP连接，这些连接由计算机的操作系统处理，程序员没有直接的访问点。
- en: 'Let''s take a brief look at some of the APIs available in the `socket` module:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要地看看`socket`模块中可用的一些API：
- en: '| **API**  | **Description** |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| **API**  | **描述** |'
- en: '| `socket.socket` `(addressfamily=AF_INET,`'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '| `socket.socket` `(addressfamily=AF_INET,`'
- en: '`type=SOCK_STREAM, proto=0,`'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`type=SOCK_STREAM, proto=0,`'
- en: '`fileno=None)` | Creates a socket. The `addressfamily` represents the format
    for providing the address, normally the IP address; type is usually `SOCK_STREAM`
    for TCP or `SOCK_DGRAM` for the UDP connection protocol. The protocol number is
    usually zero and may be omitted. Returns a socket object. |'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`fileno=None)` | 创建一个套接字。`addressfamily` 表示提供地址的格式，通常是 IP 地址；类型通常是 `SOCK_STREAM`
    用于 TCP 或 `SOCK_DGRAM` 用于 UDP 连接协议。协议号通常是零，也可以省略。返回一个套接字对象。 |'
- en: '| `socket.bind(address)` | Associates a local address with a socket. The socket
    must not already be bound. (The format of the address depends on the address family defined
    when creating the socket.) |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `socket.bind(address)` | 将本地地址与套接字关联。套接字必须尚未绑定。（地址的格式取决于创建套接字时定义的地址族。） |'
- en: '| `socket.listen(backlog)` | Announces a willingness to accept connections. The
    backlog argument specifies the maximum number of queued connections and should
    be at least zero; the maximum value is system-dependent. |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `socket.listen(backlog)` | 声明接受连接的意愿。backlog参数指定了队列中最大连接数，其值至少为零；最大值依赖于系统。
    |'
- en: '| `socket.accept()` | Passively establishes an incoming connection. Before
    accepting, the socket must be bound to an address and listening for connections.
    Returns a (`conn`, `address`) pair, where `conn` is a new socket object usable
    to send and receive data on the connection, and `address` is the address bound
    to the socket on the other end of the connection. |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `socket.accept()` | 被动建立传入连接。在接受之前，套接字必须绑定到一个地址并监听连接。返回一个 (`conn`, `address`)
    对，其中 `conn` 是一个可用于在连接上发送和接收数据的新的套接字对象，而 `address` 是连接另一端绑定到套接字上的地址。 |'
- en: '| `socket.connect()` | Actively attempts to establish a connection to a remote
    socket at the address. |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `socket.connect()` | 主动尝试在指定地址上与远程套接字建立连接。 |'
- en: '| `socket.send(bytes)/socket.` `sendall(bytes)` | Sends some data over the
    connection. Unlike `send()`, `sendall()`, this continues to send data from bytes
    until either all data has been sent or an error occurs. Returns `None` on success.
    |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `socket.send(bytes)/socket.sendall(bytes)` | 通过连接发送一些数据。与 `send()` 不同，`sendall()`
    会继续从字节中发送数据，直到所有数据都已发送或发生错误。成功时返回 `None`。 |'
- en: '| `socket.recv(bufsize)` | Receives some data over the connection. Returns
    a bytes object representing the data received. The maximum amount of data to be received
    at once is specified by `bufsize`. |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `socket.recv(bufsize)` | 通过连接接收一些数据。返回一个表示接收到的数据的字节对象。一次要接收的数据的最大量由`bufsize`指定。
    |'
- en: '| `socket.close()` | Releases the connection. The underlying system resource
    (for example, a file descriptor) is also closed. |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `socket.close()` | 释放连接。底层系统资源（例如，文件描述符）也被关闭。 |'
- en: 'If you look at the `9.07_socket_demo.py` Python file in the code bundle of
    this project, you''ll find that it sends a very obscure-looking `GET` request
    to fetch the contents from the URL in the following line of code:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看本项目代码包中的 `9.07_socket_demo.py` Python 文件，你会发现它发送了一个看起来非常晦涩的 `GET` 请求，以从以下代码行中的
    URL 获取内容：
- en: '[PRE17]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The data received from the server is also sent in packets, and it is our task
    to collect all the data and assemble it at our end.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 从服务器接收到的数据也是以数据包的形式发送的，我们的任务是收集所有数据并在我们这一端将其组装起来。
- en: Building a port scanner
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个端口扫描器
- en: Now that we know the basics of socket programming, let's build a port scanner.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了套接字编程的基础，让我们来构建一个端口扫描器。
- en: Ports are to computers what entrances are to houses. A computer has 65,535 ports through
    which it can communicate with the outside world. Most of the ports are closed
    by default. However, typically computers need to keep certain ports open for other
    computers on the network to connect and communicate.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 端口对计算机而言就像入口对房屋一样。一台计算机有65,535个端口，通过这些端口它可以与外界进行通信。大多数端口默认是关闭的。然而，通常情况下，计算机需要保持某些端口开启，以便网络上的其他计算机能够连接并进行通信。
- en: A port scanner then is software that scans all the ports of a computer to find
    out which ports of the computer are open and listening for incoming communications.
    Port scanning is used by network administrators to strengthen their security regimes,
    but it is also used by hackers to look for entry points to break into a computer.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 端口扫描器是一种软件，它扫描计算机的所有端口，以找出哪些端口是开放的并且正在监听传入的通信。端口扫描被网络管理员用来加强他们的安全制度，但它也被黑客用来寻找入侵计算机的入口点。
- en: Before you get into scanning random website servers with this tool, it is important
    to know that port scanning without proper authorization is illegal in a few jurisdictions.
    Many ISPs ban port scanning. Furthermore, many websites have explicit policies
    banning any attempts at port scanning.  There have been cases of convictions for
    unauthorized scans.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在您使用此工具扫描随机网站服务器之前，重要的是要知道，在一些司法管辖区，未经适当授权的端口扫描是非法的。许多互联网服务提供商(ISP)禁止端口扫描。此外，许多网站都有明确政策禁止任何端口扫描尝试。已有未经授权扫描被定罪的案例。
- en: You may even want to consult a lawyer if you are scanning third-party websites
    with this tool. Even if a website is silent about port scanning, it's always better
    to get authorization from a website before you scan its ports. Repeated scan
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用此工具扫描第三方网站，甚至可能需要咨询律师。即使网站对端口扫描保持沉默，但在扫描其端口之前获得网站的授权总是更好的。重复扫描
- en: attempts on a single target may also cause your IP address to be blocked by
    the administrators.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 对单个目标的尝试也可能导致您的IP地址被管理员阻止。
- en: We recommend that you use this tool to analyze security vulnerabilities only
    on computers that you are authorized to scan, or on websites that have a liberal
    policy allowing for limited and non-disruptive scans.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议您仅在使用您有权扫描的计算机或具有宽松政策允许有限且非破坏性扫描的网站上使用此工具来分析安全漏洞。
- en: 'With that disclaimer out of the way, let''s get into building the port scanner.
    On completion, our port scanner will look as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在消除这些免责声明之后，让我们开始构建端口扫描器。在完成之后，我们的端口扫描器将如下所示：
- en: '![](img/d37ea535-58e6-4fca-a31f-622ccf4a9f2b.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d37ea535-58e6-4fca-a31f-622ccf4a9f2b.png)'
- en: We do not discuss the code that creates the preceding GUI, as this should be
    easy for you. See `9.08_port_scanner.py` for the complete code. We instead discuss the
    code related to port scanning.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不讨论创建前面GUI的代码，因为这应该对你来说很简单。请参阅`9.08_port_scanner.py`以获取完整的代码。我们反而讨论与端口扫描相关的代码。
- en: There are several techniques used for port scanning. TCP SYN scanning is the
    most commonly used technique. It exploits the three-way handshake protocol employed
    by TCP, which involves sending and receiving SYN, SYN-ACK, and ACK messages. Here,
    SYN stands for synchronize and ACK stands for acknowledge. Visit [https://en.wikipedia.org/wiki/Transmission_Control_Protocol](https://en.wikipedia.org/wiki/Transmission_Control_Protocol)
    for more details on this three-way handshake protocol.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 端口扫描使用了多种技术。TCP SYN 扫描是最常用的技术。它利用了 TCP 使用的三次握手协议，这涉及到发送和接收 SYN、SYN-ACK 和 ACK
    消息。在这里，SYN 代表同步，ACK 代表确认。访问 [https://en.wikipedia.org/wiki/Transmission_Control_Protocol](https://en.wikipedia.org/wiki/Transmission_Control_Protocol)
    了解关于此三次握手协议的更多详情。
- en: A TCP SYN scan involves sending a SYN packet as if you will make a real connection and
    then waiting for the response. A SYN/ACK response from the target means that the
    port is open. A RST (reset) response suggests that the port is closed. If no response
    is received, the port is considered to be filtered.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: TCP SYN扫描涉及发送一个SYN数据包，仿佛你将要建立一个真实连接，然后等待响应。来自目标的主机SYN/ACK响应意味着端口是开放的。RST（重置）响应表明端口是关闭的。如果没有收到任何响应，则认为端口被过滤。
- en: Another common technique, and the one we will use for port scanning, is called
    the TCP connect scanner. This involves requesting a connection to the target operating system
    using the connect system call. This is exactly how web browsers and other high-level
    clients make a connection.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种常见的技巧，也是我们将用于端口扫描的技巧，被称为TCP连接扫描器。这涉及到使用connect系统调用向目标操作系统请求建立连接。这正是网络浏览器和其他高级客户端建立连接的方式。
- en: The connect command establishes an actual connection to the target, as opposed to
    the half-open scan that TCP SYN scan does. Since a complete connection is established,
    a connect scan is slower and requires more transmission than an SYN scan to find
    out whether a port is open. Furthermore, the target machine is more likely to
    log the connection and it is therefore not as stealthy as an SYN scan.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: connect 命令与目标建立实际连接，这与 TCP SYN 扫描的半开扫描相反。由于建立了完整的连接，connect 扫描比 SYN 扫描慢，并且需要更多的传输来找出端口是否开放。此外，目标机器更有可能记录连接，因此它不如
    SYN 扫描隐蔽。
- en: 'Accordingly, the code that checks whether a port is open is defined as follows
    (see `9.08_port_scanner.py`):'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，检查端口是否开放的代码定义如下（见`9.08_port_scanner.py`）：
- en: '[PRE18]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note that the preceding code simply uses `socket.connect` to make a connection to
    probe the port
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，前面的代码只是简单地使用 `socket.connect` 来建立连接以探测端口
- en: 'We call the preceding method from another method, `start_scan`, which simply loops
    over each of the ports in the range provided by the user:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将之前的方法称为另一种方法，即`start_scan`，它简单地遍历用户提供的范围内的每个端口：
- en: '[PRE19]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, we do not want a call to this method to block our Tkinter main loop.
    Therefore, we call the preceding method in a new thread as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们不希望调用此方法阻塞我们的 Tkinter 主循环。因此，我们如下在一个新线程中调用前面的方法：
- en: '[PRE20]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The preceding method gets the values entered by the user and passes them as arguments
    to the `start_scan` method in a new thread.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 上述方法获取用户输入的值，并将它们作为参数传递给新线程中的`start_scan`方法。
- en: The rest of the code simply creates and updates the GUI with the result and
    should be self-explanatory. This concludes the port scanner project.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的其余部分仅用于创建和更新带有结果的图形用户界面，应该很容易理解。这标志着端口扫描项目的结束。
- en: Building a chat application
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个聊天应用
- en: Next, let's build a multi-client chat room. The goal of this program is to explore
    socket programming in further detail. This section also implements and discusses
    the client-server architecture that is so common in all network programs.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们构建一个多客户端聊天室。这个程序的目标是更深入地探索套接字编程。本节还实现了并讨论了在所有网络程序中都非常常见的客户端-服务器架构。
- en: Our chat program will consist of a chat server, which listens for and receives
    all incoming messages on a given port.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的聊天程序将包括一个聊天服务器，该服务器会在指定的端口上监听并接收所有传入的消息。
- en: 'It also maintains a list of chat clients that connect to the server. It then
    broadcasts any incoming messages to all connected clients:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 它还维护一个连接到服务器的聊天客户端列表。然后，它将任何接收到的消息广播给所有已连接的客户端：
- en: '![](img/0cabf5fd-2e22-4eaf-8eea-11cdfd7aada8.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0cabf5fd-2e22-4eaf-8eea-11cdfd7aada8.png)'
- en: Let's start with the code for the chat server.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从聊天服务器的代码开始。
- en: A server runs on a remote host and has a socket bound to a specific port number.
    The server just waits, listening to the socket for a client to make a connection
    request.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器运行在远程主机上，并绑定到一个特定的端口号。服务器只是等待，监听套接字以等待客户端发起连接请求。
- en: 'Here''s the code for a chat server (see `9.09_chat_server.py`):'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这是聊天服务器的代码（见`9.09_chat_server.py`）：
- en: '[PRE21]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The description of the preceding code is as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 前述代码的描述如下：
- en: We create a TCP socket with an address family of IPv4 using the line `self.server_socket
    = socket(AF_INET, SOCK_STREAM)`. The IPv4 socket uses a 32-bit number to represent
    the address size. It is the most popular addressing scheme and accounts for most
    current internet traffic. IPv6 is a newer numbering system with a 128-bit address
    size, thereby providing a much larger pool of addresses. IPv6 has seen some adoption
    but it has not yet become the mainstream standard.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用行`self.server_socket = socket(AF_INET, SOCK_STREAM)`创建一个IPv4地址族的TCP套接字。IPv4套接字使用32位数字来表示地址大小。它是最受欢迎的寻址方案，占用了大部分当前的互联网流量。IPv6是一个较新的编号系统，具有128位的地址大小，从而提供了更大的地址池。IPv6已经得到一些采用，但尚未成为主流标准。
- en: The `SOCK_STREAM` parameter means that we will be using a TCP connection for
    the communication. Another less popular option is to use `SOCK_DGRAM`, which refers
    to the UDP mode of transmission.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SOCK_STREAM`参数表示我们将使用TCP连接进行通信。另一个不太受欢迎的选项是使用`SOCK_DGRAM`，它指的是UDP传输模式。'
- en: TCP is a more reliable protocol for communication than UDP as it offers a guarantee
    against packet loss. It also takes care of the proper ordering of bytes at the
    receiving end. If we use a UDP protocol, we will have to take care of handling
    packet loss, duplication, and the ordering of packets at the receiving end.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TCP比UDP更可靠，因为它提供了防止数据包丢失的保证。它还负责在接收端正确排序字节。如果我们使用UDP协议，我们就必须处理数据包丢失、重复以及接收端数据包的排序问题。
- en: We used `socket.bind(('127.0.01', 10319))` in the preceding code to bind the
    socket. We could have alternatively used `socket.bind` `((socket.gethostname(
    ), 10319)` so that the socket would have been visible to the outside world. Alternatively,
    we could have specified an empty string such as `socket.bind((' ', 10319))` to
    make the socket reachable by any address the machine could have.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在上一段代码中使用了 `socket.bind(('127.0.01', 10319))` 来绑定套接字。我们也可以选择使用 `socket.bind`
    `((socket.gethostname( ), 10319)`，这样套接字就会对外界可见。或者，我们也可以指定一个空字符串，例如 `socket.bind(('
    ', 10319))`，使得套接字可以通过机器上的任何地址访问。
- en: The `socket.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1)` line of code allows other
    sockets to `bind()` to this local port, unless there is an active socket already
    bound to the port. This lets us get around the `Address already in use` error
    message when a server is restarted after a crash.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1)` 这行代码允许其他套接字绑定到这个本地端口，除非端口上已经有一个活跃的套接字绑定。这使我们能够在服务器崩溃后重启时绕过“地址已在使用”的错误信息。'
- en: The line `self.server_socket.accept()` returns a value of the form `(socket,
    (ip, port))` as soon as a remote client connects to the server. Each client is
    then uniquely identified by the following data: `(socket, (ip, port))`.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行 `self.server_socket.accept()` 在远程客户端连接到服务器后立即返回一个形式为 `(socket, (ip, port))`
    的值。然后，每个客户端通过以下数据唯一标识：`(socket, (ip, port))`。
- en: The line `Thread(target=self.receive_messages, args=(so,))` receives each new
    message on a new thread.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这行代码 `Thread(target=self.receive_messages, args=(so,))` 在一个新的线程上接收每条新消息。
- en: Finally, the line `socket.sendall(self.last_received_message.encode('utf-8'))`
    sends the message to individual clients.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，这一行代码 `socket.sendall(self.last_received_message.encode('utf-8'))` 将消息发送给单个客户端。
- en: The `receive_messages` method receives messages using the `socket.recv` method.
    The `socket.recv` method receives messages in buffers. It is your responsibility
    to call the method again and again until the entire message has been dealt with.
    When the `socket.recv` method returns `0` bytes, it means that the sender has
    closed the connection. We then break out of the infinite loop and get the complete
    message from the buffer.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`receive_messages` 方法使用 `socket.recv` 方法接收消息。`socket.recv` 方法在缓冲区中接收消息。你有责任反复调用该方法，直到整个消息被处理完毕。当
    `socket.recv` 方法返回 `0` 字节时，意味着发送者已经关闭了连接。然后我们跳出无限循环，并从缓冲区中获取完整的消息。'
- en: Also note that message transmission over the network occurs in bytes.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，网络上的消息传输是以字节为单位的。
- en: Any message that we send must be converted to byte form using `outgoing_message.encode('utf-8')`.
    Similarly, any message that we receive from the network must be converted from
    bytes to a string or any other format.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发送的任何消息都必须使用`outgoing_message.encode('utf-8')`转换为字节形式。同样，我们从网络接收到的任何消息都必须从字节转换为字符串或任何其他格式。
- en: To convert bytes to a string, we use `incoming_bytes.decode('utf-8')`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 将字节转换为字符串，我们使用 `incoming_bytes.decode('utf-8')`。
- en: Our chat server is now ready. Next, let's build the chat client.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的服务器现在已经准备好了。接下来，让我们构建聊天客户端。
- en: Our chat client should connect to the remote server and send a message to the
    server. It should also be listening for any incoming messages from the central
    chat server. We do not reproduce the entire code for our chat client. Specifically,
    we omit the code that produces the GUI for our chat client as we have coded similar
    widgets in the past.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的聊天客户端应该连接到远程服务器并向服务器发送消息。它还应该监听来自中央聊天服务器的任何传入消息。我们没有为我们的聊天客户端复制整个代码。具体来说，我们省略了生成我们聊天客户端GUI的代码，因为我们之前已经编写过类似的控件。
- en: 'The partial code in our chat client that sends and receives messages to and
    from the chat server is as follows (see `9.10_chat_client.py`):'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们聊天客户端中发送和接收聊天服务器消息的部分代码如下（见 `9.10_chat_client.py`）：
- en: '[PRE22]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This code is very similar to the code of our chat server. Here''s a short description
    of the code:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与我们聊天服务器的代码非常相似。以下是代码的简要描述：
- en: We first create a socket using `socket(AF_INET, SOCK_STREAM)`
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们首先使用 `socket(AF_INET, SOCK_STREAM)` 创建一个套接字
- en: We then connect the socket to the remote IP and the remote port of our chat server
    using `socket.connect()`
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们随后使用 `socket.connect()` 将套接字连接到我们的聊天服务器的远程 IP 地址和端口。
- en: We receive messages from the server using `socket.recv()`
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 `socket.recv()` 从服务器接收消息
- en: We send messages to the server using `socket.send()`
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 `socket.send()` 向服务器发送消息
- en: Note that when a client attempts to connect to the server using the `socket.connect` method,
    the operating system will assign a unique but random port to identify the client
    when a message is returned by the server.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当客户端尝试使用 `socket.connect` 方法连接到服务器时，操作系统将为客户端分配一个唯一但随机的端口号，以便在服务器返回消息时识别该客户端。
- en: The port numbers from `0` to `1023` are referred to as the well-known ports, reserved
    ports, or system ports. They are used by the operating system to provide widely
    used network services. For example, port `21` is reserved for FTP services, port
    `80` is reserved for HTTP services, port `22` is reserved for SSH and SFTP, and
    port `443` is reserved for a secure HTTP service (HTTPS) over TLS/SSL.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 端口号从 `0` 到 `1023` 被称为知名端口、保留端口或系统端口。它们被操作系统用于提供广泛使用的网络服务。例如，端口 `21` 保留用于 FTP
    服务，端口 `80` 保留用于 HTTP 服务，端口 `22` 保留用于 SSH 和 SFTP，端口 `443` 保留用于基于 TLS/SSL 的安全 HTTP
    服务（HTTPS）。
- en: The random port that the operating system assigns to our client is selected
    from a pool of ports that are above the system-reserved ports. The list of all
    reserved ports can be found at
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统分配给我们的客户端的随机端口是从高于系统保留端口的端口池中选择的。所有保留端口的列表可以在以下链接找到：
- en: '[https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers](https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers).'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '[TCP和UDP端口号列表](https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers).'
- en: The full code of the chat client can be found in `9.10_chat_client.py`. The
    chat is now functional, but note that we have not coded the logic for removing
    users from the `clients_list` in `ChatServer.` This means that even if you close
    a chat window, the chat server will still try to send a chat message to the closed
    client as we have not removed the client from the server. We will not implement
    it here, but should you wish to implement this, you can easily override the window's `close`
    method and send a message to `ChatServer` to delete the client from the client
    list.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的聊天客户端代码可以在`9.10_chat_client.py`中找到。聊天功能现在已启用，但请注意，我们尚未在`ChatServer`中编写从`clients_list`中移除用户的逻辑。这意味着即使你关闭了聊天窗口，聊天服务器仍然会尝试向已关闭的客户端发送聊天消息，因为我们尚未从服务器中移除该客户端。我们在此处不会实现它，但如果你希望实现这一功能，你可以轻松地覆盖窗口的`close`方法并向`ChatServer`发送一条消息以从客户端列表中删除该客户端。
- en: That concludes the chat application project.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 那就结束了聊天应用项目。
- en: Creating a phone book application
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个电话簿应用程序
- en: Let's now build a simple phone book application that allows the user to store
    names and phone numbers.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在构建一个简单的电话簿应用程序，允许用户存储姓名和电话号码。
- en: The main learning objective for this project relates to being able to use a
    relational database with Tkinter to store and manipulate records. We have already
    seen some basic examples of object persistence with serialization. Relational
    databases extend this persistence using rules of relational algebra to store data
    in tables.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目的学习目标主要涉及能够使用 Tkinter 与关系型数据库一起存储和操作记录。我们已看到一些使用序列化的基本对象持久化示例。关系型数据库通过关系代数的规则扩展这种持久化，将数据存储在表中。
- en: Python provides database interfaces for a wide range of database engines. Some of
    the commonly used database engines include MySQL, SQLite, PostgreSQL, Oracle,
    Ingres, SAP DB, Informix, Sybase, Firebird, IBM DB2, Microsoft SQL Server, and
    Microsoft Access.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: Python为多种数据库引擎提供了数据库接口。其中一些常用的数据库引擎包括MySQL、SQLite、PostgreSQL、Oracle、Ingres、SAP
    DB、Informix、Sybase、Firebird、IBM DB2、Microsoft SQL Server和Microsoft Access。
- en: We will use SQLite to store data for our phone book application.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 SQLite 来存储我们的电话簿应用程序的数据。
- en: SQLite is a serverless, zero-configuration, self-contained SQL database engine suitable
    for developing embedded applications. The source code for SQLite is in the public
    domain, which makes it freely available for use in all sorts of commercial and
    non-commercial projects.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 是一个无需服务器、无需配置、自包含的 SQL 数据库引擎，适用于开发嵌入式应用程序。SQLite 的源代码属于公共领域，这使得它在各种商业和非商业项目中都可以免费使用。
- en: Unlike many other SQL databases, SQLite does not require running a separate
    server process. Instead, SQLite stores all the data directly onto flat files that
    get stored on a computer disk. These files are easily portable across different
    platforms, making it a very popular choice for smaller and simpler database implementation
    requirements.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多其他SQL数据库不同，SQLite不需要运行一个单独的服务器进程。相反，SQLite将所有数据直接存储到存储在计算机磁盘上的平面文件中。这些文件在不同平台之间易于移植，使其成为满足较小和较简单数据库实施需求的一个非常受欢迎的选择。
- en: Python comes with a built-in standard library for SQLite3 support. However,
    we need to download the SQLite3 command-line tool that lets us create, modify,
    and access the database using a command line. The command-line shell for Windows,
    Linux, and macOS can be downloaded from [http://sqlite.org/download.html](http://sqlite.org/download.html).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: Python自带对SQLite3的支持标准库。然而，我们需要下载SQLite3命令行工具，这样我们才能使用命令行创建、修改和访问数据库。Windows、Linux和macOS的命令行shell可以从[http://sqlite.org/download.html](http://sqlite.org/download.html)下载。
- en: Following the instructions on the website, install the SQLite command shell
    into any location of your choice.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 按照网站上的说明，将 SQLite 命令行工具安装到您选择的任何位置。
- en: 'Let''s now implement our phone book application. The application will look as
    follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在来实现我们的电话簿应用程序。应用程序将如下所示：
- en: '![](img/fd1eb5ff-d1ad-4084-b7c9-c7bf7891be10.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fd1eb5ff-d1ad-4084-b7c9-c7bf7891be10.png)'
- en: The application will demonstrate some of the common operations involved in database
    programming. The user should be able to create new records, read existing records,
    update existing records, and delete records from the database using this application.
    Together, these activities constitute what are known as **CRUD** (**Create, Read,
    Update, and Delete**) operations on a database.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序将演示数据库编程中涉及的一些常见操作。用户应能够使用此应用程序创建新记录、读取现有记录、更新现有记录以及从数据库中删除记录。这些活动共同构成了所谓的数据库上的**CRUD**（创建、读取、更新和删除）操作。
- en: 'In order to create the database, we open the command-line tool of our operating system.
    Within the command line, we first navigate to the directory where we need to create
    the new database file. In order to create the database, we simply use this command:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建数据库，我们打开操作系统的命令行工具。在命令行中，我们首先导航到需要创建新数据库文件的目录。为了创建数据库，我们只需使用以下命令：
- en: '[PRE23]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This creates a database file named `phonebook.db` in the folder from which
    we execute the command. It also displays a message similar to the following:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在我们执行命令的文件夹中创建一个名为 `phonebook.db` 的数据库文件。同时，它还会显示类似于以下的消息：
- en: '[PRE24]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We have now created a database named `phonebook.db`. However, the database
    file is currently empty. It does not contain any tables or any data. So, we get
    no results if we run this command:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了一个名为 `phonebook.db` 的数据库。然而，数据库文件目前是空的。它不包含任何表或任何数据。因此，如果我们运行此命令，将不会得到任何结果：
- en: '[PRE25]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'For now, let''s exit the command-line tool by typing this:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，让我们通过输入以下命令来退出命令行工具：
- en: '[PRE26]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We want to store contacts in our database, and that is why we will create the
    `contacts` table. Our database table should store a person's name and phone number.
    In addition, it is good practice to keep a unique identification number for each
    person or each entry in the table. This is because multiple people might have
    the same name or same contact number.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望在数据库中存储联系人信息，因此我们将创建`contacts`表。我们的数据库表应存储一个人的姓名和电话号码。此外，为每个人或表中的每条记录保留一个唯一的识别号码是良好的实践。这是因为可能有多个人的姓名或联系号码相同。
- en: 'To create a table within our `phonebook.db` database, we again open the command-line
    tool and navigate to the directory where we had created the database. We again get
    into the SQLite3 terminal by typing this:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`phonebook.db`数据库中创建一个表格时，我们再次打开命令行工具并导航到创建数据库的目录。我们再次通过输入以下命令进入SQLite3终端：
- en: '[PRE27]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This time, a new database is not created. Rather, the command now opens the existing
    `phonebook.db` database because it is already present on the disk.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，没有创建新的数据库。相反，现在该命令打开现有的`phonebook.db`数据库，因为它已经存在于磁盘上。
- en: 'Next, we create a table named contacts, and add three columns to the table from
    the command line:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个名为 contacts 的表，并从命令行向表中添加三个列：
- en: '[PRE28]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You can verify the contacts table was created by typing the following command:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过输入以下命令来验证联系人表是否已创建：
- en: '[PRE29]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This prints the name of all the tables present in the currently open database.
    You will get the following output:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印出当前打开的数据库中所有表的名字。你将得到以下输出：
- en: '[PRE30]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Let's first create a basic GUI that will let us add, view, delete, and modify
    the records. We create a class named `phoneBook` and create all GUI widgets within
    it.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建一个基本的GUI，它将允许我们添加、查看、删除和修改记录。我们创建一个名为`phoneBook`的类，并在其中创建所有GUI小部件。
- en: 'We do not discuss the entire code that creates the GUI as we have coded similar structures
    in the past. However, we use a new ttk widget named `Treeview`. The code for creating
    `Treeview` is as follows (`9.11_phonebook.py`):'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不讨论创建GUI的整个代码，因为我们过去已经编写过类似的结构。然而，我们使用了一个名为`Treeview`的新 ttk小部件。创建`Treeview`的代码如下（`9.11_phonebook.py`）：
- en: '[PRE31]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To add items to `Treeview`, we use the following code:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 要向`Treeview`添加项目，我们使用以下代码：
- en: '[PRE32]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To get all items in `Treeview`, we use the code:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取`Treeview`中的所有项目，我们使用以下代码：
- en: '[PRE33]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To delete items from `Treeview`, we use the code:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 要从`Treeview`中删除项目，我们使用以下代码：
- en: '[PRE34]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Next, let''s prepare the code to query our database:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们准备查询数据库的代码：
- en: '[PRE35]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The code description is as follows:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 代码描述如下：
- en: The method establishes a connection to the `phonebook.db` database we created
    earlier.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该方法建立了与我们之前创建的`phonebook.db`数据库的连接。
- en: The next line, `cursor = conn.cursor()`, creates a cursor object. The cursor is
    a control structure that is required as per SQL standards, and it enables us to
    traverse the records in a database.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一行，`cursor = conn.cursor()` 创建了一个游标对象。游标是一个按照 SQL 标准要求的控制结构，它使我们能够遍历数据库中的记录。
- en: The next line, `cursor.execute(query)`, executes the query against the database.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一行，`cursor.execute(query)`，将对数据库执行查询操作。
- en: The line `conn.commit()` actually commits/saves these changes to the database.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这行代码 `conn.commit()` 实际上是将这些更改提交/保存到数据库中。
- en: We can now use the preceding method to execute CRUD queries on the database.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用前面的方法在数据库上执行 CRUD 查询。
- en: Creating a new record
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个新的记录
- en: A new record needs to be created every time a user enters a new name and a phone number
    in the entry widgets provided, and then clicks on the Add Record button.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 每当用户在提供的输入小部件中输入新的姓名和电话号码，然后点击添加记录按钮时，都需要创建一个新的记录。
- en: 'The database query for adding a new record is as follows:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 添加新记录的数据库查询如下：
- en: '[PRE36]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Reading from the database
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从数据库中读取
- en: 'The database query for reading all records from the database is as follows:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 从数据库中读取所有记录的数据库查询如下：
- en: '[PRE37]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The preceding variable, `phone_book_entries`, contains a list of all the records
    from the database.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个变量`phone_book_entries`包含数据库中所有记录的列表。
- en: Updating records
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新记录
- en: 'To update the phone number of an existing contact, we use the following code:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新现有联系人的电话号码，我们使用以下代码：
- en: '[PRE38]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Deleting records
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除记录
- en: 'To delete the phone number of an existing contact, we use the following code:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除现有联系人的电话号码，我们使用以下代码：
- en: '[PRE39]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The rest of the code is the supporting GUI. See `9.11_phonebook.py` for the
    complete code. We have now completed coding a basic phone book application.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的代码是支持性图形用户界面。请参阅`9.11_phonebook.py`以获取完整的代码。我们现在已经完成了基本电话簿应用的编码。
- en: We have seen how to create a database, add tables to the database, and query
    the database to add, modify, delete, and view items in the database. Our phone
    book application has demonstrated how to execute basic CRUD operations on a database.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了如何创建数据库，向数据库中添加表，以及如何查询数据库来添加、修改、删除和查看数据库中的项目。我们的电话簿应用程序展示了如何在数据库上执行基本的
    CRUD 操作。
- en: Furthermore, due to the similarity of basic database operations, you can now consider
    working with other database systems, such as MySQL, PostgreSQL, Oracle, Ingres,
    SAP DB, Informix, Sybase, Firebird, IBM DB2, Microsoft SQL Server, and Microsoft
    Access.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于基本数据库操作相似，你现在可以考虑使用其他数据库系统，例如 MySQL、PostgreSQL、Oracle、Ingres、SAP DB、Informix、Sybase、Firebird、IBM
    DB2、Microsoft SQL Server 和 Microsoft Access。
- en: Using asyncio with Tkinter
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 asyncio 与 Tkinter 结合
- en: Starting with Python 3.4, a new module named `asyncio` was introduced as a Python
    standard module.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Python 3.4 版本开始，引入了一个名为 `asyncio` 的新模块，作为 Python 的标准模块。
- en: 'The term **Asyncio** is made by adding two words: async + I/O.  Async is about
    concurrency, which means doing more than one thing at a time. I/O, on the other
    hand, refers to handling I/O bound tasks. A **bound task** means the thing that
    keeps your program busy.  If, for instance, you are doing computation-intensive
    math processing, the processor is taking most of the time—and it is, therefore,
    a **CPU bound task**. On the contrary, if you are waiting for a result from the
    network, result from the database, or an input from the user, the task is **I/O
    bound**.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 术语 **Asyncio** 是由两个单词组合而成：async + I/O。Async 指的是并发，意味着一次做多件事。另一方面，I/O 指的是处理 I/O
    绑定任务。一个 **绑定任务** 指的是让程序忙碌的事情。例如，如果你在进行计算密集型的数学处理，处理器会花费大部分时间——因此，这是一个 **CPU 绑定任务**。相反，如果你正在等待来自网络的响应、数据库的结果或用户的输入，那么这个任务就是
    **I/O 绑定**。
- en: So in a nutshell, the `asyncio` module provides concurrency, particularly for
    I/O bound tasks. Concurrency ensures that you do not have to wait for I/O bound
    results.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，`asyncio`模块提供了并发性，尤其是针对I/O密集型任务。并发性确保你不必等待I/O密集型任务的结果。
- en: Let's say you have to fetch content from multiple URLs, then process the fetched
    content to extract the title and display it in a Tkinter window. Now you obviously cannot fetch
    the content in the same thread that runs the Tkinter main loop, as that would
    make the root window unresponsive while the content is fetched.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你需要从多个URL获取内容，然后处理获取到的内容以提取标题并在Tkinter窗口中显示。显然，你不能在运行Tkinter主循环的同一线程中获取内容，因为这会使根窗口在获取内容时变得无响应。
- en: So one of the options is to spawn a new thread for each URL. While this can
    be an option, it is not a very scalable one as spawning thousands or more threads
    at a time can lead to a lot of code complexity. We already saw a demo of a race
    condition in the beginning of the current chapter (`9.01_race_condition.py`),
    where running multiple threads can make it difficult to control the shared state. Furthermore,
    as context switching is an expensive and time-consuming affair, the program can
    become laggy after spawning just a few threads.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 所以一个选择是为每个URL创建一个新的线程。虽然这可以是一个选择，但它并不是一个非常可扩展的选择，因为一次创建成千上万个线程会导致代码复杂性大大增加。 我们在当前章节的开头已经看到了一个竞态条件的演示（`9.01_race_condition.py`），其中运行多个线程会使控制共享状态变得困难。 此外，由于上下文切换是一项昂贵且耗时的操作，程序在仅创建几个线程后可能会变得缓慢。
- en: Here's where `asyncio` comes to our rescue. In contrast to multithreading, which
    relies on threading, `asyncio` uses a concept of event loops.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 正是这里，`asyncio` 出现来拯救我们。与依赖于线程的多线程相比，`asyncio` 使用了事件循环的概念。
- en: 'To demonstrate, here is a Tkinter program that on the click of a button simulates
    fetching 10 URLs:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示，这里是一个Tkinter程序，点击按钮后模拟获取10个URL：
- en: '[PRE40]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Here''s a brief description of the code (`9.12_async_demo.py`):'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是对代码（`9.12_async_demo.py`）的简要描述：
- en: The first step in using the `asyncio` module is to construct an event loop using
    the code `event_loop = asyncio.get_event_loop()`. Internally, this `event_loop`
    will schedule all tasks assigned to it using coroutines and futures to do the
    I/O bound tasks in an asynchronous manner.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `asyncio` 模块的第一步是使用代码 `event_loop = asyncio.get_event_loop()` 构建一个事件循环。内部，这个
    `event_loop` 将使用协程和未来来安排分配给它的所有任务，以异步方式执行 I/O 绑定任务。
- en: We pass this `event_loop` as an argument to the Tkinter root window, so that
    it can use this event loop for scheduling async tasks.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将这个`event_loop`作为参数传递给Tkinter根窗口，以便它可以使用这个事件循环来调度异步任务。
- en: The method that is in charge of doing the I/O bound task is then defined by
    appending the keyword `async` in front of the method definition. Essentially,
    any method that is to be executed from the event loop must be appended with the
    keyword `async`.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负责执行I/O密集型任务的该方法通过在方法定义前添加关键字`async`来定义。本质上，任何需要从事件循环中执行的方法都必须添加关键字`async`。
- en: The method simulates a time-taking I/O blocking task using `await asyncio.sleep(sec)`. In
    a real case, you will perhaps use this to fetch the contents of a URL or perform
    a similar I/O blocking task.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该方法使用 `await asyncio.sleep(sec)` 模拟耗时 I/O 阻塞任务。在实际情况下，你可能使用它来获取 URL 的内容或执行类似的
    I/O 阻塞任务。
- en: We start executing the async tasks in a new thread. This single thread executes
    the list of tasks using the `event_loop.run_until_complete(simulate_fetch_all_urls())` command. Note
    that this is different from creating one thread each for each of the tasks. In
    this case, we are only creating a single thread to isolate it from the Tkinter
    main loop.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在一个新的线程中开始执行异步任务。这个单独的线程使用`event_loop.run_until_complete(simulate_fetch_all_urls())`命令来执行任务列表。请注意，这与为每个任务创建一个线程是不同的。在这种情况下，我们只创建一个线程来将其从Tkinter主循环中隔离出来。
- en: The line `all_tasks = [simulate_fetch_one_url(url) for url in range(10)]` combines
    all the async tasks into a list. This list of all I/O bound tasks is then passed
    on to `completed, pending = await asyncio.wait(all_tasks)`, which waits for all
    tasks to be completed in a non-blocking manner. Once all the tasks are completed,
    the results are populated in the `completed `variable.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这行代码 `all_tasks = [simulate_fetch_one_url(url) for url in range(10)]` 将所有异步任务合并为一个列表。然后，这个包含所有I/O密集型任务的列表被传递给
    `completed, pending = await asyncio.wait(all_tasks)`，它以非阻塞方式等待所有任务完成。一旦所有任务完成，结果将被填充到
    `completed` 变量中。
- en: We get the results of individual tasks using `results = [task.result() for task
    in completed]`.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过`results = [task.result() for task in completed]`获取单个任务的成果。
- en: We finally print out all the results to the console.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们最终将所有结果打印到控制台。
- en: The benefit of using `asyncio` is that we do not have to spawn one thread for
    each task and as a result, the code does not have to context switch for each individual
    task.  Thus, using `asyncio` we can scale up to fetch thousands of URLs without
    slowing down our program and without worrying about managing results from each
    thread individually.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `asyncio` 的好处是，我们不需要为每个任务创建一个线程，因此代码也不必为每个单独的任务进行上下文切换。因此，使用 `asyncio` 我们可以扩展到检索数千个
    URL，而不会减慢我们的程序，也不必担心单独管理每个线程的结果。
- en: This concludes our brief discussion on using the `asyncio` module with Tkinter.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们关于使用`asyncio`模块与Tkinter结合的简要讨论。
- en: Interfacing with hardware/serial communication
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与硬件/串行通信接口
- en: The **internet of things** (**IoT**) is now becoming a reality. We are seeing
    a glimpse of IoT in smart medical devices, driverless cars, smart factories, and
    smart homes. A large number of such IoT applications are built around the idea
    of capturing data with sensors and actuators.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 物联网（**IoT**）现在正成为现实。我们在智能医疗设备、自动驾驶汽车、智能工厂和智能家居中看到了物联网的一瞥。大量此类物联网应用都是围绕使用传感器和执行器捕获数据这一理念构建的。
- en: The rise of IoT can largely be attributed to the rise in popularity of microcontrollers,
    which make it very easy to test and build product prototypes for such embedded
    systems.  A microcontroller is a self-contained device with a built-in processor
    and a programmable memory. Most typical microcontrollers provide general purpose
    input/output pins which can be used either to receive data from sensors or to
    send data based on some program that is uploaded to the microcontoller.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 物联网（IoT）的兴起很大程度上归功于微控制器的普及，这使得测试和构建此类嵌入式系统的产品原型变得非常容易。微控制器是一种集成的设备，内置处理器和可编程内存。大多数典型的微控制器提供通用输入/输出引脚，这些引脚既可以用来接收来自传感器的数据，也可以根据上传到微控制器的某些程序发送数据。
- en: In this project, we will use one of the most popular microcontrollers—the Arduino
    Uno—to demonstrate how to build an application that can read data from an external
    device. We will build an Ultrasonic Range Finder. If you find this project interesting,
    you can buy the hardware and build it as well—the total cost of this project is
    less than five dollars. However, if you do not intend to implement it, you can
    merely read through this section. Our primary objective here is to show how to
    get data from external hardware into Tkinter using what is known as serial communication.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将使用最受欢迎的微控制器之一——Arduino Uno——来演示如何构建一个可以从外部设备读取数据的程序。我们将构建一个超声波测距仪。如果你对这个项目感兴趣，你可以购买硬件并自己搭建——这个项目的总成本不到五美元。然而，如果你不打算实施它，你只需阅读这一节即可。我们在这里的主要目标是展示如何使用所谓的串行通信将外部硬件的数据导入Tkinter。
- en: Hardware
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 硬件
- en: To begin with, we need an Arduino Uno board (or any other Arduino board). We
    also need an ultrasonic range finder sensor. A quick web search shows hundreds
    of rangefinder sensors for less than a quarter of a dollar. We use a sensor named
    HC-SR04-Ultrasonic Range Finder, but just about any other sensor would do. The
    sensor we have chosen provides a range-finding capability for distances in a 2
    cm - 300 cm range, with an accuracy of up to 3 mm.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一块Arduino Uno板（或任何其他Arduino板）。我们还需要一个超声波测距传感器。快速的网络搜索显示，价格低于四分之一的美元就有数百种测距传感器。我们使用的是名为HC-SR04-Ultrasonic
    Range Finder的传感器，但几乎任何其他传感器都可以。我们选择的传感器提供了2厘米至300厘米距离范围内的测距能力，精度高达3毫米。
- en: These sensors use sonar to determine the distance to an object, just as dolphins
    and bats do. Here's how the sensor calculates the distance. The module has two
    units. The transmitter transmits ultrasound, while a receiver reads any ultrasound
    that reflects back. Since the speed of ultrasound is fixed and known, by calculating
    the time between transmission and reflection, we can calculate the distance of
    the object that reflected the ultrasound.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 这些传感器使用声纳来确定物体距离，就像海豚和蝙蝠一样。以下是传感器计算距离的方法。该模块有两个单元。发射器发射超声波，而接收器读取任何反射回来的超声波。由于超声波的速度是固定且已知的，通过计算发射和反射之间的时间，我们可以计算出反射超声波的物体距离。
- en: 'Here''s how the hardware is set up:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是硬件的设置方式：
- en: '![](img/e78fab2f-360c-4a2c-99cd-12054b1aa674.png)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e78fab2f-360c-4a2c-99cd-12054b1aa674.png)'
- en: To the left is the Arduino Uno board. The ultrasound sensor is towards the right.
    As you can see the sensor has four pins marked VCC, Trig, Echo, and GND. The specifications
    of the sensor states that it needs 5 volts to run. Accordingly, we connect the
    VCC pin to a pin that reads 5V on the Arduino pin. Similarly, the ground pin (GND)
    from the sensor is connected to a GND pin on the Arduino board. Now the sensor
    is powered up. We connect the Trig pin to pin number 8 and the Echo pin to pin
    number 7 on the Arduino board. Every time we provide a high pulse on Pin 8, the
    sensor will trigger an ultrasound and then the Echo pin will return the time it
    took for the ultrasound to reflect back, which we will read into the Arduino on
    Pin 7.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧是Arduino Uno板。超声波传感器位于右侧。如您所见，传感器有四个标记为VCC、Trig、Echo和GND的引脚。传感器的规格说明显示它需要5伏电压才能运行。因此，我们将VCC引脚连接到Arduino引脚上读取5V的引脚。同样，传感器的地线引脚（GND）连接到Arduino板上的GND引脚。现在传感器已通电。我们将Trig引脚连接到Arduino板上的8号引脚，将Echo引脚连接到7号引脚。每次我们在8号引脚上提供一个高脉冲时，传感器将触发超声波，然后Echo引脚将返回超声波反射所需的时间，我们将这个时间读取到Arduino的7号引脚上。
- en: Writing the Arduino sketch
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写Arduino草图
- en: 'In the Arduino world, programs that you upload to the microcontroller are called
    sketches. You can write these sketches in a free **integrated development environment**
    (**IDE**) which can be downloaded from here:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在Arduino的世界里，您上传到微控制器的程序被称为草图。您可以使用以下链接下载的免费**集成开发环境**（**IDE**）来编写这些草图：
- en: '[https://www.arduino.cc/en/Main/Software](https://www.arduino.cc/en/Main/Software)'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '[Arduino 软件下载](https://www.arduino.cc/en/Main/Software)'
- en: 'Once you finalize a program, you upload it to your Arduino board using the
    upload button on the IDE and voila: your board starts doing what you asked it
    to do.'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你完成了程序，你可以通过IDE上的上传按钮将其上传到你的Arduino板，然后就是：你的板子开始执行你所要求它做的事情。
- en: 'Every Arduino sketch will have two methods where you get to define the logic
    of your program:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Arduino草图都将包含两个方法，你可以在这里定义程序的逻辑：
- en: '`setup()`: For one-time initialization'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setup()`: 用于一次性初始化'
- en: '`loop()`: For things that the board keeps doing forever until it runs out of
    power'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loop()`: 对于板子持续不断执行直到耗尽电力的操作'
- en: 'Here''s the code that we upload to the Arduino (see `9.13.arduino_sketch.ino`):'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们上传到Arduino的代码（见`9.13.arduino_sketch.ino`）：
- en: '[PRE41]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The code description is as follows:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 代码描述如下：
- en: The first two lines indicates that we will use pin numbers `7` and `8` on the
    Arduino board and we assign them the variable names `triggerPin` and `echoBackPin`.
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前两行表示我们将在Arduino板上使用引脚编号`7`和`8`，并将它们分配给变量名`triggerPin`和`echoBackPin`。
- en: The `setup` function initializes the serial port and fixes its baud rate at
    9600\. Baud rate is defined as the number of signal changes that occur in a second.
    We will use the same rate when reading data in Tkinter with Python.
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setup` 函数初始化串行端口并将其波特率设置为 9600。波特率定义为每秒发生的信号变化次数。在用 Python 的 Tkinter 读取数据时，我们将使用相同的波特率。'
- en: The code `pinMode(triggerPin, OUTPUT)` means that we will now use Pin `8` to
    send an output pulse to the sensor.
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码 `pinMode(triggerPin, OUTPUT)` 表示我们现在将使用引脚 `8` 向传感器发送输出脉冲。
- en: Similarly, the code `pinMode(echoBackPin, INPUT);` declares that we will use
    Pin `7` to receive input from the sensor.
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样地，代码 `pinMode(echoBackPin, INPUT);` 声明我们将使用引脚 `7` 来接收传感器的输入。
- en: Within the loop, we start by setting pin `triggerPin` to low pulse.  We then
    trigger the sensor to emit ultrasound by triggering a high voltage pulse of `2`
    microseconds. This triggers the sensor to emit an ultrasound for 5 microseconds.
    We then mark the pin `LOW` to stop triggering the ultrasound pulse.
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在循环内部，我们首先将引脚 `triggerPin` 设置为低脉冲。然后通过触发一个持续 `2` 微秒的高电压脉冲来触发传感器发射超声波。这会使传感器发射超声波持续
    `5` 微秒。随后我们将引脚标记为 `LOW` 以停止触发超声波脉冲。
- en: We then time the signal received on `echoBackPin` using `duration = pulseIn(ioPin,
    HIGH)`. This gives us the time (in microseconds) it took for the ultrasound to
    reflect back.
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们随后使用`duration = pulseIn(ioPin, HIGH)`来计时在`echoBackPin`上接收到的信号。这给出了超声波反射回来的时间（以微秒为单位）。
- en: Given that the speed of sound is 340 m/s or 29 microseconds per centimeter,
    we find the distance using the formula `distance = speed * time`. But since this
    is the time it took for a reflected sound to travel out and back, the actual distance
    is half this value. Perhaps the math should be done by Python instead? Doing division
    here using a `long` method will result in a whole number and so will not be precise.
    Note that we could have also offloaded this calculation from Arduino to our Python
    code, as most Arduino processors do not directly support floats in hardware, and
    doing so in software on such a limited processor could bog it down.
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于声速为340 m/s或每厘米29微秒，我们使用公式 `distance = speed * time` 来计算距离。但是，由于这是反射声波往返所需的时间，实际距离是这个值的一半。也许应该用Python来做这个数学计算？在这里使用`long`方法进行除法将得到一个整数，因此不会很精确。注意，我们也可以将这个计算从Arduino转移到我们的Python代码中，因为大多数Arduino处理器不支持硬件上的浮点数，在这样的有限处理器上通过软件进行计算可能会使其变得缓慢。
- en: The line `delay(100)` ensures that the previous code runs every `100` milliseconds,
    sending pulses of ultrasound and measuring the distance to whatever the sensor
    is pointed at.
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行`delay(100)`确保前一行代码每`100`毫秒运行一次，发送超声波脉冲并测量传感器指向的物体的距离。
- en: The moment this code is uploaded to the Arduino board, it starts sending `5`-microsecond
    pulses of ultrasound after a delay of 100 milliseconds. It also sends a message
    to the serial port of your computer in every one of these loops.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 当这段代码上传到Arduino板后，它会在延迟100毫秒后开始发送`5`微秒的超声波脉冲。同时，它还会在每一个这样的循环中向你的电脑的串行端口发送一条消息。
- en: Now it's time to read this using Python and then display it in a Tkinter widget.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候用Python来读取它，然后在Tkinter小部件中显示它了。
- en: Reading serial data
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取串行数据
- en: 'We will use the `pyserial`module to read data from the serial port. However,
    this is not a standard Python module and needs to be installed. We can install
    it using the following pip command:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`pyserial`模块从串行端口读取数据。然而，这并不是一个标准的Python模块，需要安装。我们可以使用以下pip命令来安装它：
- en: '[PRE42]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Once we are able to get data from the Arduino board, we can further process
    it or plot it in the way we want. However, the goal here is to simply display
    whatever data is sent by the Arduino board over the serial port, as shown in the
    following Tkinter window (`9.14_read_from_serial_port.py`):'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们能够从Arduino板上获取数据，我们就可以进一步处理它或以我们想要的方式绘制它。然而，这里的目的是简单地显示Arduino板通过串行端口发送的任何数据，如下面的Tkinter窗口所示（`9.14_read_from_serial_port.py`）：
- en: '![](img/d692b435-0152-414c-bf42-6d97a22351f0.png)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d692b435-0152-414c-bf42-6d97a22351f0.png)'
- en: In order to read the serial port, we first need to identify the port on which
    this message is being sent. There are two ways you can do this.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 为了读取串行端口，我们首先需要确定这条消息是通过哪个端口发送的。你可以通过两种方式来完成这个操作。
- en: 'Firstly, you can find the name of the port from your Arduino IDE under the
    Tools menu, as shown here:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您可以从Arduino IDE的“工具”菜单中找到端口的名称，如下所示：
- en: '![](img/ec5b64a4-9b65-44a5-8356-e135fda0a058.png)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ec5b64a4-9b65-44a5-8356-e135fda0a058.png)'
- en: 'Alternatively, you can run the following command from the command line:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以从命令行运行以下命令：
- en: '[PRE43]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This will print a list of all active serial ports. Once you have the port name
    at hand, data reading is done using the following code:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印出所有活动串行端口的列表。一旦你手头有了端口名称，数据读取将使用以下代码完成：
- en: '[PRE44]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The description of the code is as follows:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的描述如下：
- en: We first get an instance of the `Serial` class by calling `ser = serial.Serial()`.
    We then specify the port name and the baud rate. This is the same baud rate that
    we used earlier in our Arduino code.
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们首先通过调用`ser = serial.Serial()`来获取`Serial`类的一个实例。然后我们指定端口号和波特率。这与我们在之前的Arduino代码中使用的波特率相同。
- en: We then open the serial port by calling `ser.open()` and read the data using
    `ser.readline()`.
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过调用 `ser.open()` 打开串行端口，并使用 `ser.readline()` 读取数据。
- en: The rest of the code is Tkinter-specific and creates the GUI and displays the
    results in a `Label` widget.
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 剩余的代码是Tkinter特定的，用于创建GUI并在`Label`小部件中显示结果。
- en: This concludes the section and the chapter.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分和这一章到此结束。
- en: In the next chapter, we will conclude the book with discussions on miscellaneous
    issues that you may encounter when writing GUI programs.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过讨论你在编写GUI程序时可能遇到的各种问题来结束本书。
- en: Summary
  id: totrans-361
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Let's summarize the concepts we discussed in this chapter.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下本章讨论的概念。
- en: We learned about the perils of spawning threads and the resulting race condition.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了创建线程的潜在危险以及由此产生的竞态条件。
- en: We learned how to use the queue data structure to program a multithreaded application,
    without having to worry about synchronization between multiple threads trying
    to access the same memory, and without using complicated synchronization primitives.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何使用队列数据结构来编写多线程应用程序，无需担心多个试图访问相同内存的线程之间的同步问题，也不需要使用复杂的同步原语。
- en: The Weather Reporter application introduced us to the basics of network programming
    and how to tap into the internet to get data. We discussed two popular structures
    used for data exchange, namely XML and JSON.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 天气预报应用向我们介绍了网络编程的基础以及如何接入互联网获取数据。我们讨论了两种用于数据交换的流行结构，即XML和JSON。
- en: The port scanner and the chat program discussed the basics of socket programming for
    interprocess and remote communication. We used the TCP/IP protocol to send and
    receive messages in our chat program. We also saw a basic example of client-server
    architecture.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 端口扫描器和聊天程序讨论了进程间和远程通信的套接字编程基础。在我们的聊天程序中，我们使用了TCP/IP协议来发送和接收消息。我们还看到了客户端-服务器架构的基本示例。
- en: We saw how all forms of communication over a network occur in bytes and how
    we can convert data to bytes and back from bytes to data in the required format.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了网络中所有形式的通信都是通过字节来实现的，以及我们如何将数据转换为字节，再将字节转换回所需格式的数据。
- en: The phone book application showed us how to work with databases. We saw how to
    perform basic CRUD operations on a database.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 电话簿应用程序向我们展示了如何与数据库打交道。我们看到了如何在数据库上执行基本的CRUD操作。
- en: Next, we saw how to use the `asyncio` module to fetch I/O bound tasks in a non-blocking
    and scalable manner, without having to worry about managing the states of a large
    number of threads at once.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们了解了如何使用 `asyncio` 模块以非阻塞和可扩展的方式获取 I/O 绑定任务，无需担心一次性管理大量线程的状态。
- en: Finally, we saw how to interface with external hardware to collect data from
    sensors using serial communication.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们学习了如何通过串行通信与外部硬件接口，以收集传感器的数据。
- en: QA section
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QA部分
- en: 'Here are a few questions to reflect upon:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些问题供您思考：
- en: What is a race condition? How can you avoid a race condition?
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是竞态条件？如何避免竞态条件？
- en: What are the benefits of using the queue data structure?
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用队列数据结构的优点有哪些？
- en: What are the most popular open source databases available in the market?
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 市面上最受欢迎的开源数据库有哪些？
- en: What are the most common modes of interprocess communication?
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最常见的进程间通信模式有哪些？
- en: When would you use the `asyncio` module?
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你会在什么情况下使用 `asyncio` 模块？
- en: What are some of the advantages and disadvantages of using serial communication?
    What are some of its alternatives?
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用串行通信有哪些优缺点？有哪些替代方案？
- en: What are the JSON and XML file formats used for? What are their advantages and
    disadvantages when compared to using a database?
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON和XML文件格式用于什么？与使用数据库相比，它们有什么优点和缺点？
- en: Further reading
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: We used Python code to perform basic CRUD operations on our database.  It would
    be worthwhile to note that as applications get larger and more complex, the programmer
    should consider making use of an **ORM** (**object-relational mapping**) library
    instead of direct CRUD operations. Read more about ORM and its benefits at [http://blogs.learnnowonline.com/2012/08/28/4-benefits-of-object-relational-mapping-orm/.](http://blogs.learnnowonline.com/2012/08/28/4-benefits-of-object-relational-mapping-orm/)
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Python代码在我们的数据库上执行基本的CRUD操作。值得注意的是，随着应用程序变得更大和更复杂，程序员应该考虑使用**ORM（对象关系映射）**库来代替直接的CRUD操作。更多关于ORM及其优势的信息，请参阅[http://blogs.learnnowonline.com/2012/08/28/4-benefits-of-object-relational-mapping-orm/](http://blogs.learnnowonline.com/2012/08/28/4-benefits-of-object-relational-mapping-orm/)。
- en: We used a thread lock as a synchronization primitive in `9.02_lock_demo.py`.
    There are several other synchronization primitives that could have been used instead.
    Learn about other synchronization primitives at [https://www.usenix.org/legacy/publications/library/proceedings/bsdcon02/full_papers/baldwin/baldwin_html/node5.html.](https://www.usenix.org/legacy/publications/library/proceedings/bsdcon02/full_papers/baldwin/baldwin_html/node5.html)
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`9.02_lock_demo.py`中使用了线程锁作为同步原语。还有其他几种同步原语可以被用来替代。了解更多其他同步原语的信息，请访问[https://www.usenix.org/legacy/publications/library/proceedings/bsdcon02/full_papers/baldwin/baldwin_html/node5.html.](https://www.usenix.org/legacy/publications/library/proceedings/bsdcon02/full_papers/baldwin/baldwin_html/node5.html)
- en: '**Python Enhancement Proposals** (**PEPs**) are official design documents or
    technical specifications in the Python community that describe a new feature that
    has been introduced in Python. For instance, PEP 3156 is the specification dealing
    with and explaining the rationale behind the introduction of the `asyncio` module.
    You can read this PEP document here:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.python.org/dev/peps/pep-3156/](https://www.python.org/dev/peps/pep-3156/)'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '[Python PEP 3156](https://www.python.org/dev/peps/pep-3156/)'
- en: The event loop in `asyncio` internally uses coroutines and futures to implement
    asynchronous behavior. Learning how to use coroutines and futures can be a valuable
    tool for writing more efficient and scalable programs.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '`asyncio`中的事件循环内部使用协程和未来来实现异步行为。学习如何使用协程和未来可以成为编写更高效和可扩展程序的有价值工具。'
- en: Sockets are commonly used for interprocess communication. However, there are
    many other methods for interprocess communication. A brief read of [http://nptel.ac.in/courses/106108101/pdf/Lecture_Notes/Mod%207_LN.pdf ](http://nptel.ac.in/courses/106108101/pdf/Lecture_Notes/Mod%207_LN.pdf)is
    well worth the effort.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字通常用于进程间通信。然而，还有许多其他进程间通信的方法。简要阅读[http://nptel.ac.in/courses/106108101/pdf/Lecture_Notes/Mod%207_LN.pdf](http://nptel.ac.in/courses/106108101/pdf/Lecture_Notes/Mod%207_LN.pdf)是值得努力的。
