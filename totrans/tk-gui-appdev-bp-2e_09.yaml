- en: Multiple Fun Projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now, we have explored most of the important features of Tkinter. Let's use
    this chapter to explore aspects of programming that, though not core to Tkinter,
    are often encountered while writing GUI applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will develop several small applications from different
    domains. The applications we will build here include:'
  prefs: []
  type: TYPE_NORMAL
- en: A snake game application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A weather reporter application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A port scanner application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A chat application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A phone book application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An ultrasound distance scanner application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some of the key objectives of the chapter are:'
  prefs: []
  type: TYPE_NORMAL
- en: To learn to use `Queue` module to avoid race conditions and other synchronization
    issues involved in writing multithreaded programs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To understand the basics of data mining over the network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To understand socket programming and to learn the basics of server-client architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To learn database programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To learn to use `asyncio` with Tkinter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To learn how to interface and interact with external hardware components using
    serial communication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the projects in this chapter rely on the standard libraries and do not
    require anything extra. The exception is the ultrasonic range finder project,
    which requires an Arduino board and an ultrasonic range finder sensor.  The hardware
    is relatively cheap (under 10 dollars). You may also decide not to buy the hardware
    and still read the project to understand how serial communication takes place
    between two pieces of equipment.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, you will also need to download and install the Arduino **integrated
    development environment** (**IDE**), the details of which will be discussed in
    the project itself.
  prefs: []
  type: TYPE_NORMAL
- en: Building a Snake game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's now build a simple Snake game. As usual, we will be making use of the
    `Canvas` widget to provide the platform for our Snake program. We will use `canvas.create_line`
    to draw our snake and `canvas.create_rectangle` to draw the snake food.
  prefs: []
  type: TYPE_NORMAL
- en: The primary objective of this project is to learn how to use `Queue` module
    as a **synchronization technique** in a multithreaded application.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a multithreaded application poses the challenge of synchronization between different
    threads. When multiple threads try to access shared data simultaneously, the data
    is likely to get corrupted or modified in ways that were not intended in the program.
    This is called a **race condition**.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding a race condition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `9.01_race_condition.py` code demonstrates a race condition. The program
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code consists of two methods named `increment` and `decrement`
    that both operate on a single shared variable named `shared_var`. These two methods
    are called from separate threads.
  prefs: []
  type: TYPE_NORMAL
- en: One would expect that an equal number of increments and decrements on a shared variable
    would produce no change in its value at the end. However, when you run this program,
    say 100 times as before, it produces a different value for the shared variable
    in each consecutive run. This is a classic example for how a race condition can
    make the output of a program nondeterministic.
  prefs: []
  type: TYPE_NORMAL
- en: Race conditions occur because we cannot predict the thread execution order at
    all. The operating system does it very randomly and so the execution order of
    threads varies each time the program is run.
  prefs: []
  type: TYPE_NORMAL
- en: Using synchronization primitives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To handle this complexity, the `threading` module provides some synchronization primitives,
    such as locks, joins, semaphores, events, and condition variables.
  prefs: []
  type: TYPE_NORMAL
- en: '`9.02_lock_demo.py` slightly modifies the preceding code by introducing a `lock`
    using this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, every time `shared_variable` is to be modified, it is done after acquiring
    a `lock`. The `lock` is released when the variable has been modified, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This enables us to avoid a race condition. Since this code operates with a `lock`,
    it produces no change in the shared variable after an equal number of increments and
    decrements.
  prefs: []
  type: TYPE_NORMAL
- en: It seemed easy to use the `lock` mechanism to avoid a race condition. However,
    as the complexity of a program grows, there are many places where a variable may
    be modified. Tracking large code bases for places where a variable may be changed is
    often a difficult task.
  prefs: []
  type: TYPE_NORMAL
- en: Using queues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In most cases, it is safer and simpler to use **queues**. Simply put, a queue
    is a compound memory structure that is thread-safe. Queues effectively channel
    access to a resource to multiple threads in a sequential order, and are a recommended
    design pattern that uses threads for most of the scenarios that require concurrency.
  prefs: []
  type: TYPE_NORMAL
- en: The `Queue` module provides a way to implement different kinds of queuing, such as
    FIFO (default implementation), LIFO queues, and priority queues, and this module comes
    with a built-in implementation of all the locking semantics required for running multithreaded
    programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a quick roundup of the basic usage of the `Queue` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see a simple demonstration of using a queue to implement a multithreaded application
    (see `9.03_threading_with_queue.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The description of the code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We first create a `Consumer` class, which inherits from the `threading` module of
    Python. The `__init__` method takes in a queue as its argument.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then override the `run` method of the `threading` module to get each item
    from the queue using `queue.get()`, which is then passed on to the `task_handler`
    method, which actually executes the task specified in the current queue item.
    In our example, it does nothing useful except print the name of the task.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After the work is done on a particular thread by our `task_handler` method, it
    sends a signal to the queue telling it that the task has been completed using the
    `queue.task_done()` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Outside our `Consumer` class, we create an empty queue in our `producer()` module
    function. This queue is populated with a list of tasks using `queue.put(task)`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then create six different threads and pass this populated queue as its argument.
    Now that the tasks are handled by the queue, all threads automatically ensure
    that the tasks are completed in the sequence in which they are encountered by
    the threads, without causing any deadlocks or two different threads trying to
    work on the same queued task.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the time of creating each thread, we also create a pool of daemon threads using
    `my_thread.daemon = True`. Doing this passes control to our main program once
    all threads have completed execution. If you comment out the line, the program
    would still run, but would fail to exit after all threads have completed executing
    the tasks in the queue. Without the daemon threads, you'd have to keep track of
    all the threads and tell them to exit before your program could completely quit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the `queue.join()` method ensures that the program flow waits there until
    all queued tasks are actually done and the queue is empty.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the Snake game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With that background information about using a queue to handle multithreaded applications,
    let's build our Snake game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon completion, the game will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dbe3da18-357d-4e24-93fb-0ecdd3be9304.png)'
  prefs: []
  type: TYPE_IMG
- en: The View class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start coding our game by first creating a basic `View` class. This class
    will be responsible for creating the GUI, checking for *game over* logic, and
    most importantly acting as the consumer, taking items from the queue and processing them
    to update the view (see `9.04_game_of_snake.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code should be mostly familiar to you by now as we have written similar
    code in the past. Note, however, that rather than passing the root instance as
    an argument to its `__init__` method, our `View` class now inherits from the `Tk` class.
    The line `Tk.__init__(self)` ensures that the root window is available to all methods
    of this class. This way we can avoid writing a root attribute on every line by
    referencing root simply as `self`.
  prefs: []
  type: TYPE_NORMAL
- en: This class will also have code to process items put in the queue. We will code
    the rest of this class after we have coded the classes that put items in the queue.
  prefs: []
  type: TYPE_NORMAL
- en: The Food class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, we will create the `Food` class (see `9.04_game_of_snake.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The description of the code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Because we want to process all data centrally from within a queue, we pass the
    queue as an argument to the `__init__` method of the `Food` class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `__init__` method calls another method called `generate_food`, which is responsible
    for generating the snake food at random positions on the canvas.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `generate_food` method generates a random (`x`, `y`) position on the canvas.
    However, because the place where the coordinates coincide is just a small point
    on the canvas, it would be barely visible. We, therefore, generate an expanded
    coordinate (`rectangle_position` ) ranging from five values less than the (`x`,
    `y`) coordinate up to five values higher than the same coordinate. Using this
    range, we can create a small rectangle on the canvas that would be easily visible
    and would represent our food.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, we do not create the rectangle here. Instead, we pass the coordinates
    for the food (rectangle) into our queue using `queue.put`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Snake class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now create the `Snake` class. We have already passed a task to generate
    our food to the central queue. However, no additional thread was involved in the
    task. We could also generate our `Snake` class without using threads. However,
    because we are talking about ways to implement multithreaded applications, let''s
    implement our `Snake` class to work from a separate thread (see `9.04_game_of_snake.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The description of the code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We create a class named `Snake` to run from a separate thread. This class takes the
    `queue` as its input arguments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We initialize the points earned by the player from zero and set the initial location
    of the snake using the attribute `self.snake_points`. Note that initially, the
    snake is `40` pixels long.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we start the thread and create an infinite loop to call the `move()` method
    at small intervals. During every run of the loop, the method populates the `queue`
    with a dictionary having the key as move and the value equal to the updated position
    of the snake, through the `self.snake_points` attribute.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, the `move` method obtains the latest coordinates for the snake depending
    on the keyboard event. It uses a separate method called `calculate_new_coordinates`
    to get the latest coordinates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It then checks whether the location of the new coordinates coincides with the
    location of the food. If they match, it increases the score of the player by one
    and calls the `Food` class' `generate_food` method to generate a new food at a new
    location.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the current point does not coincide with the food coordinates, it deletes
    the first item from the snake coordinates using `self.snake_points.pop(0)`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, it calls another method named `check_game_over` to check whether the snake collides
    with the wall or itself. If the snake does collide, it appends a new dictionary
    item in the queue with the value `'game_over':True`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, if the game is not over, it appends the new position of the snake
    to the list `self.snake_points`. This is automatically added to the queue, because
    we have defined `self.queue.put({''move'': self.snake_points } )` in the `Snake`
    class''s `run()` method to update every `0.1` seconds as long as the game is not
    over.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Queue handler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that the queue is getting populated with various actionables, let's create
    the `queue_handler` method to process the items in the queue and update the `View` accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'We define the `queue_handler()` method in our `View` class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The description for the code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `queue_handler` method gets into an infinite loop looking for tasks in the
    queue using `task = self.queue.get_nowait()`. If the queue becomes empty, the
    loop is restarted using `canvas.after`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we use `queue_get_nowait()`, the call does not block the calling thread
    until an item is available. It removes and returns an item from the queue, if
    available. If the queue is empty, it raises `Queue.Empty`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once a task is fetched from the queue, the method checks its key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the key is `game_over`, it calls another method named `game_over()` which
    we define next.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the key of the task is `move`, it uses `canvas.coords` to move the line to
    its new position.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the key is `points_earned`, it updates the score on the canvas.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When the execution of a task completes, it signals the thread with the `task_done()` method. Finally,
    we create the main loop as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Our game is now functional. Go and try controlling the snake while keeping its stomach
    filled.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Weather Reporter application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's now build a simple Weather Reporter application. The weather data for
    any given location will be fetched from the network, suitably formatted, and presented to
    the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use a higher level module named `urllib` to fetch weather data from
    the web. The `urllib` module is part of Python''s standard library and it provides
    an easy to use API for working with URLs. It has four submodules:'
  prefs: []
  type: TYPE_NORMAL
- en: '`urllib.request`: For opening and reading URLs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`urllib.error`: For handling exceptions raised by `urllib.request`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`urllib.parse`: For parsing URLs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`urllib.robotparser`: For parsing `robots.txt` files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With `urllib.request`, fetching the contents of a web page turns into three
    lines of code   (see `9.05_urllib_demo.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This prints the entire HTML source code or whatever is the response from the
    web page [http://www.packtpub.com](http://www.packtpub.com). This is, in essence,
    the core of mining the web for information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know how to get data from a URL, let''s apply it to building our
    Weather Reporter application. This application should take the location as an
    input from the user and fetch relevant weather-related data, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/62812610-8b31-43db-915d-8da3ee60cbf7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We create a class, `WeatherReporter`, and call it from outside the class within
    the `mainloop` (see the code of `9.06_weather_reporter.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We do not discuss the code for creating this GUI here, as we have done similar
    coding many times in all the the previous chapters. The weather data is displayed
    on a canvas (see `9.06_weather_reporter.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: When you specify a location and click on the **Go** button, it calls a command
    callback named `on_show_weather_button_clicked`.
  prefs: []
  type: TYPE_NORMAL
- en: We then fetch the weather data from a website.
  prefs: []
  type: TYPE_NORMAL
- en: There are two ways to fetch data from a website. The first method involves getting an
    HTML response from a website, and then parsing the received HTML response for
    data that is relevant to us. This type of data extraction is called **site scraping**.
  prefs: []
  type: TYPE_NORMAL
- en: '**Scrapy** and **Beautiful Soup** are two popular site-scraping frameworks
    for extracting data from websites. You can find the official documentation of
    the two libraries at [http://scrapy.org/](http://scrapy.org/) and [http://www.crummy.com/software/BeautifulSoup/](http://www.crummy.com/software/BeautifulSoup/).'
  prefs: []
  type: TYPE_NORMAL
- en: Site scraping is a rather crude method that is employed only when a given website does
    not provide a structured way to retrieve data. On the other hand, some websites are
    willing to share data through a set of APIs, provided you query it for data using the
    specified URL structure. This is clearly more elegant than site scraping, because data
    is interchanged in a reliable and *mutually agreed* format.
  prefs: []
  type: TYPE_NORMAL
- en: For our Weather Reporter application, we want to query some weather channels for
    a given location, and in turn retrieve and display the data on our canvas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, there are several weather APIs that we can use. In our example,
    we will use the weather data provided by the following website:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://openweathermap.org/](http://openweathermap.org/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to use the API, you need to sign up for a free API key here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://home.openweathermap.org/users/sign_up](http://home.openweathermap.org/users/sign_up)'
  prefs: []
  type: TYPE_NORMAL
- en: The `OpenWeatherMap` service provides free weather data and forecast APIs. This
    site collates weather data from more than 40,000 weather stations across the globe,
    and the data can be assessed by city name and geographic coordinates, or their
    internal city ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'The website provides weather data in two data formats:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JSON** (**JavaScript Object Notation**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**XML** (**Extensible Markup Language**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XML and JSON are two popular interchangeable data serialization formats widely used
    for interchanging data between different applications, which may be running on different
    platforms and using different programming languages, thus providing the benefit
    of interoperability.
  prefs: []
  type: TYPE_NORMAL
- en: JSON is simpler than XML, because its grammar is simpler and it maps more directly onto
    the data structures used in modern programming languages. JSON is better suited
    for exchanging data, but XML is good for exchanging documents.
  prefs: []
  type: TYPE_NORMAL
- en: 'The API documentation tells us of a query such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code returns weather data for London in JSON format as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The syntax of JSON is simple. Any piece of JSON data is a name/value pair and
    each piece of data is separated from the others by commas. JSON uses curly braces
    `{}` to hold objects and square brackets `[ ]` to hold arrays. Accordingly, we
    define a method to get the weather data in JSON format in our application (see
    `9.06_weather_reporter.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The description for the code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: This method uses `urllib` to retrieve responses from the website. It returns the
    response in JSON format.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, we'll start processing the JSON data. The weather data returned using the
    API is encoded in JSON format. We need to convert this data into the Python data
    type. Python provides a built-in `json` module that simplifies the process of
    encoding/decoding JSON data. We therefore import the `json` module into our current
    namespace.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, we''ll use this module to convert the retrieved JSON data into the Python
    dictionary format (see `9.06_weather_reporter.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have a dictionary of all weather-related information provided by
    the API, we simply display the retrieved weather data using `canvas.create_text`
    and `canvas.create_image`. The code for displaying the weather data is self-explanatory
    (see `9.06_weather_reporter.py`).
  prefs: []
  type: TYPE_NORMAL
- en: Our Weather Reporter application is now functional.
  prefs: []
  type: TYPE_NORMAL
- en: When you access a server from your Python program, it is very important to send
    requests after small time gaps.
  prefs: []
  type: TYPE_NORMAL
- en: A typical Python program is capable of running several million instructions
    per second. However, the server that sends you the data at the other end is not
    equipped to work at that speed. If you knowingly or unknowingly send a large number
    of requests to a server within a short time span, you may prevent it from servicing
    its routine requests from normal web users. This constitutes what is called a **denial
    of service** (**DOS**) attack on the server. You may be banned or, in a worst
    case scenario, be sued for disrupting a server, if your program does not make
    a limited number of well-behaved requests.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize the code for the Weather Reporter, we use the `urllib` module to query
    the weather API provided by our data provider. The data is fetched in JSON format.
    The JSON data is then decoded into a Python-readable format (dictionary).
  prefs: []
  type: TYPE_NORMAL
- en: The converted data is then displayed on the canvas using the `create_text` and `create_image`
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: A simple socket demo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The goal of this project is to introduce you to the basics of network programming and
    how to use it in your GUI application.
  prefs: []
  type: TYPE_NORMAL
- en: Python has great support for network programming. At the lowest level, Python provides
    a `socket` module that lets you connect and interact with the network using a
    simple-to-use, object-oriented interface.
  prefs: []
  type: TYPE_NORMAL
- en: For those new to socket programming, **sockets** are the fundamental concept
    behind any kind of network communication done by your computer. For instance,
    when you type `www.packtpub.com` in your browser, the operating system on your
    computer opens a socket and connects to the remote server to fetch the web page
    for you. The same happens with any application that needs to connect to the network.
  prefs: []
  type: TYPE_NORMAL
- en: 'More specifically, sockets refer to a communications endpoint that is characterized by
    a five-element tuple that contains the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This tuple must be unique for communication on a channel between a local machine
    and a remote machine.
  prefs: []
  type: TYPE_NORMAL
- en: Sockets may be connection-oriented or connectionless. Connection-oriented sockets
    allow for the flow of data to and fro as required. Connectionless sockets (or
    datagram sockets) allow only one message at a time to be transmitted, without
    an open connection.
  prefs: []
  type: TYPE_NORMAL
- en: Sockets can be classified into different types or families. The two most common socket
    families are `AF_INET` (for internet connections) and `AF_UNIX` for interprocess communications
    on a Unix machine. We will use `AF_INET` in our chat program.
  prefs: []
  type: TYPE_NORMAL
- en: This is the lowest level at which a programmer can access the network. Underneath the
    socket layer lie raw UDP and TCP connections, which are handled by your computer's
    operating system with no direct access points for programmers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a brief look at some of the APIs available in the `socket` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **API**  | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `socket.socket` `(addressfamily=AF_INET,`'
  prefs: []
  type: TYPE_NORMAL
- en: '`type=SOCK_STREAM, proto=0,`'
  prefs: []
  type: TYPE_NORMAL
- en: '`fileno=None)` | Creates a socket. The `addressfamily` represents the format
    for providing the address, normally the IP address; type is usually `SOCK_STREAM`
    for TCP or `SOCK_DGRAM` for the UDP connection protocol. The protocol number is
    usually zero and may be omitted. Returns a socket object. |'
  prefs: []
  type: TYPE_NORMAL
- en: '| `socket.bind(address)` | Associates a local address with a socket. The socket
    must not already be bound. (The format of the address depends on the address family defined
    when creating the socket.) |'
  prefs: []
  type: TYPE_TB
- en: '| `socket.listen(backlog)` | Announces a willingness to accept connections. The
    backlog argument specifies the maximum number of queued connections and should
    be at least zero; the maximum value is system-dependent. |'
  prefs: []
  type: TYPE_TB
- en: '| `socket.accept()` | Passively establishes an incoming connection. Before
    accepting, the socket must be bound to an address and listening for connections.
    Returns a (`conn`, `address`) pair, where `conn` is a new socket object usable
    to send and receive data on the connection, and `address` is the address bound
    to the socket on the other end of the connection. |'
  prefs: []
  type: TYPE_TB
- en: '| `socket.connect()` | Actively attempts to establish a connection to a remote
    socket at the address. |'
  prefs: []
  type: TYPE_TB
- en: '| `socket.send(bytes)/socket.` `sendall(bytes)` | Sends some data over the
    connection. Unlike `send()`, `sendall()`, this continues to send data from bytes
    until either all data has been sent or an error occurs. Returns `None` on success.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `socket.recv(bufsize)` | Receives some data over the connection. Returns
    a bytes object representing the data received. The maximum amount of data to be received
    at once is specified by `bufsize`. |'
  prefs: []
  type: TYPE_TB
- en: '| `socket.close()` | Releases the connection. The underlying system resource
    (for example, a file descriptor) is also closed. |'
  prefs: []
  type: TYPE_TB
- en: 'If you look at the `9.07_socket_demo.py` Python file in the code bundle of
    this project, you''ll find that it sends a very obscure-looking `GET` request
    to fetch the contents from the URL in the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The data received from the server is also sent in packets, and it is our task
    to collect all the data and assemble it at our end.
  prefs: []
  type: TYPE_NORMAL
- en: Building a port scanner
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know the basics of socket programming, let's build a port scanner.
  prefs: []
  type: TYPE_NORMAL
- en: Ports are to computers what entrances are to houses. A computer has 65,535 ports through
    which it can communicate with the outside world. Most of the ports are closed
    by default. However, typically computers need to keep certain ports open for other
    computers on the network to connect and communicate.
  prefs: []
  type: TYPE_NORMAL
- en: A port scanner then is software that scans all the ports of a computer to find
    out which ports of the computer are open and listening for incoming communications.
    Port scanning is used by network administrators to strengthen their security regimes,
    but it is also used by hackers to look for entry points to break into a computer.
  prefs: []
  type: TYPE_NORMAL
- en: Before you get into scanning random website servers with this tool, it is important
    to know that port scanning without proper authorization is illegal in a few jurisdictions.
    Many ISPs ban port scanning. Furthermore, many websites have explicit policies
    banning any attempts at port scanning.  There have been cases of convictions for
    unauthorized scans.
  prefs: []
  type: TYPE_NORMAL
- en: You may even want to consult a lawyer if you are scanning third-party websites
    with this tool. Even if a website is silent about port scanning, it's always better
    to get authorization from a website before you scan its ports. Repeated scan
  prefs: []
  type: TYPE_NORMAL
- en: attempts on a single target may also cause your IP address to be blocked by
    the administrators.
  prefs: []
  type: TYPE_NORMAL
- en: We recommend that you use this tool to analyze security vulnerabilities only
    on computers that you are authorized to scan, or on websites that have a liberal
    policy allowing for limited and non-disruptive scans.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that disclaimer out of the way, let''s get into building the port scanner.
    On completion, our port scanner will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d37ea535-58e6-4fca-a31f-622ccf4a9f2b.png)'
  prefs: []
  type: TYPE_IMG
- en: We do not discuss the code that creates the preceding GUI, as this should be
    easy for you. See `9.08_port_scanner.py` for the complete code. We instead discuss the
    code related to port scanning.
  prefs: []
  type: TYPE_NORMAL
- en: There are several techniques used for port scanning. TCP SYN scanning is the
    most commonly used technique. It exploits the three-way handshake protocol employed
    by TCP, which involves sending and receiving SYN, SYN-ACK, and ACK messages. Here,
    SYN stands for synchronize and ACK stands for acknowledge. Visit [https://en.wikipedia.org/wiki/Transmission_Control_Protocol](https://en.wikipedia.org/wiki/Transmission_Control_Protocol)
    for more details on this three-way handshake protocol.
  prefs: []
  type: TYPE_NORMAL
- en: A TCP SYN scan involves sending a SYN packet as if you will make a real connection and
    then waiting for the response. A SYN/ACK response from the target means that the
    port is open. A RST (reset) response suggests that the port is closed. If no response
    is received, the port is considered to be filtered.
  prefs: []
  type: TYPE_NORMAL
- en: Another common technique, and the one we will use for port scanning, is called
    the TCP connect scanner. This involves requesting a connection to the target operating system
    using the connect system call. This is exactly how web browsers and other high-level
    clients make a connection.
  prefs: []
  type: TYPE_NORMAL
- en: The connect command establishes an actual connection to the target, as opposed to
    the half-open scan that TCP SYN scan does. Since a complete connection is established,
    a connect scan is slower and requires more transmission than an SYN scan to find
    out whether a port is open. Furthermore, the target machine is more likely to
    log the connection and it is therefore not as stealthy as an SYN scan.
  prefs: []
  type: TYPE_NORMAL
- en: 'Accordingly, the code that checks whether a port is open is defined as follows
    (see `9.08_port_scanner.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note that the preceding code simply uses `socket.connect` to make a connection to
    probe the port
  prefs: []
  type: TYPE_NORMAL
- en: 'We call the preceding method from another method, `start_scan`, which simply loops
    over each of the ports in the range provided by the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we do not want a call to this method to block our Tkinter main loop.
    Therefore, we call the preceding method in a new thread as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The preceding method gets the values entered by the user and passes them as arguments
    to the `start_scan` method in a new thread.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the code simply creates and updates the GUI with the result and
    should be self-explanatory. This concludes the port scanner project.
  prefs: []
  type: TYPE_NORMAL
- en: Building a chat application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, let's build a multi-client chat room. The goal of this program is to explore
    socket programming in further detail. This section also implements and discusses
    the client-server architecture that is so common in all network programs.
  prefs: []
  type: TYPE_NORMAL
- en: Our chat program will consist of a chat server, which listens for and receives
    all incoming messages on a given port.
  prefs: []
  type: TYPE_NORMAL
- en: 'It also maintains a list of chat clients that connect to the server. It then
    broadcasts any incoming messages to all connected clients:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0cabf5fd-2e22-4eaf-8eea-11cdfd7aada8.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's start with the code for the chat server.
  prefs: []
  type: TYPE_NORMAL
- en: A server runs on a remote host and has a socket bound to a specific port number.
    The server just waits, listening to the socket for a client to make a connection
    request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the code for a chat server (see `9.09_chat_server.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The description of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We create a TCP socket with an address family of IPv4 using the line `self.server_socket
    = socket(AF_INET, SOCK_STREAM)`. The IPv4 socket uses a 32-bit number to represent
    the address size. It is the most popular addressing scheme and accounts for most
    current internet traffic. IPv6 is a newer numbering system with a 128-bit address
    size, thereby providing a much larger pool of addresses. IPv6 has seen some adoption
    but it has not yet become the mainstream standard.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `SOCK_STREAM` parameter means that we will be using a TCP connection for
    the communication. Another less popular option is to use `SOCK_DGRAM`, which refers
    to the UDP mode of transmission.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TCP is a more reliable protocol for communication than UDP as it offers a guarantee
    against packet loss. It also takes care of the proper ordering of bytes at the
    receiving end. If we use a UDP protocol, we will have to take care of handling
    packet loss, duplication, and the ordering of packets at the receiving end.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We used `socket.bind(('127.0.01', 10319))` in the preceding code to bind the
    socket. We could have alternatively used `socket.bind` `((socket.gethostname(
    ), 10319)` so that the socket would have been visible to the outside world. Alternatively,
    we could have specified an empty string such as `socket.bind((' ', 10319))` to
    make the socket reachable by any address the machine could have.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `socket.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1)` line of code allows other
    sockets to `bind()` to this local port, unless there is an active socket already
    bound to the port. This lets us get around the `Address already in use` error
    message when a server is restarted after a crash.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The line `self.server_socket.accept()` returns a value of the form `(socket,
    (ip, port))` as soon as a remote client connects to the server. Each client is
    then uniquely identified by the following data: `(socket, (ip, port))`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The line `Thread(target=self.receive_messages, args=(so,))` receives each new
    message on a new thread.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the line `socket.sendall(self.last_received_message.encode('utf-8'))`
    sends the message to individual clients.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `receive_messages` method receives messages using the `socket.recv` method.
    The `socket.recv` method receives messages in buffers. It is your responsibility
    to call the method again and again until the entire message has been dealt with.
    When the `socket.recv` method returns `0` bytes, it means that the sender has
    closed the connection. We then break out of the infinite loop and get the complete
    message from the buffer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also note that message transmission over the network occurs in bytes.
  prefs: []
  type: TYPE_NORMAL
- en: Any message that we send must be converted to byte form using `outgoing_message.encode('utf-8')`.
    Similarly, any message that we receive from the network must be converted from
    bytes to a string or any other format.
  prefs: []
  type: TYPE_NORMAL
- en: To convert bytes to a string, we use `incoming_bytes.decode('utf-8')`.
  prefs: []
  type: TYPE_NORMAL
- en: Our chat server is now ready. Next, let's build the chat client.
  prefs: []
  type: TYPE_NORMAL
- en: Our chat client should connect to the remote server and send a message to the
    server. It should also be listening for any incoming messages from the central
    chat server. We do not reproduce the entire code for our chat client. Specifically,
    we omit the code that produces the GUI for our chat client as we have coded similar
    widgets in the past.
  prefs: []
  type: TYPE_NORMAL
- en: 'The partial code in our chat client that sends and receives messages to and
    from the chat server is as follows (see `9.10_chat_client.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is very similar to the code of our chat server. Here''s a short description
    of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: We first create a socket using `socket(AF_INET, SOCK_STREAM)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then connect the socket to the remote IP and the remote port of our chat server
    using `socket.connect()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We receive messages from the server using `socket.recv()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We send messages to the server using `socket.send()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that when a client attempts to connect to the server using the `socket.connect` method,
    the operating system will assign a unique but random port to identify the client
    when a message is returned by the server.
  prefs: []
  type: TYPE_NORMAL
- en: The port numbers from `0` to `1023` are referred to as the well-known ports, reserved
    ports, or system ports. They are used by the operating system to provide widely
    used network services. For example, port `21` is reserved for FTP services, port
    `80` is reserved for HTTP services, port `22` is reserved for SSH and SFTP, and
    port `443` is reserved for a secure HTTP service (HTTPS) over TLS/SSL.
  prefs: []
  type: TYPE_NORMAL
- en: The random port that the operating system assigns to our client is selected
    from a pool of ports that are above the system-reserved ports. The list of all
    reserved ports can be found at
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers](https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers).'
  prefs: []
  type: TYPE_NORMAL
- en: The full code of the chat client can be found in `9.10_chat_client.py`. The
    chat is now functional, but note that we have not coded the logic for removing
    users from the `clients_list` in `ChatServer.` This means that even if you close
    a chat window, the chat server will still try to send a chat message to the closed
    client as we have not removed the client from the server. We will not implement
    it here, but should you wish to implement this, you can easily override the window's `close`
    method and send a message to `ChatServer` to delete the client from the client
    list.
  prefs: []
  type: TYPE_NORMAL
- en: That concludes the chat application project.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a phone book application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's now build a simple phone book application that allows the user to store
    names and phone numbers.
  prefs: []
  type: TYPE_NORMAL
- en: The main learning objective for this project relates to being able to use a
    relational database with Tkinter to store and manipulate records. We have already
    seen some basic examples of object persistence with serialization. Relational
    databases extend this persistence using rules of relational algebra to store data
    in tables.
  prefs: []
  type: TYPE_NORMAL
- en: Python provides database interfaces for a wide range of database engines. Some of
    the commonly used database engines include MySQL, SQLite, PostgreSQL, Oracle,
    Ingres, SAP DB, Informix, Sybase, Firebird, IBM DB2, Microsoft SQL Server, and
    Microsoft Access.
  prefs: []
  type: TYPE_NORMAL
- en: We will use SQLite to store data for our phone book application.
  prefs: []
  type: TYPE_NORMAL
- en: SQLite is a serverless, zero-configuration, self-contained SQL database engine suitable
    for developing embedded applications. The source code for SQLite is in the public
    domain, which makes it freely available for use in all sorts of commercial and
    non-commercial projects.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike many other SQL databases, SQLite does not require running a separate
    server process. Instead, SQLite stores all the data directly onto flat files that
    get stored on a computer disk. These files are easily portable across different
    platforms, making it a very popular choice for smaller and simpler database implementation
    requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Python comes with a built-in standard library for SQLite3 support. However,
    we need to download the SQLite3 command-line tool that lets us create, modify,
    and access the database using a command line. The command-line shell for Windows,
    Linux, and macOS can be downloaded from [http://sqlite.org/download.html](http://sqlite.org/download.html).
  prefs: []
  type: TYPE_NORMAL
- en: Following the instructions on the website, install the SQLite command shell
    into any location of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now implement our phone book application. The application will look as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fd1eb5ff-d1ad-4084-b7c9-c7bf7891be10.png)'
  prefs: []
  type: TYPE_IMG
- en: The application will demonstrate some of the common operations involved in database
    programming. The user should be able to create new records, read existing records,
    update existing records, and delete records from the database using this application.
    Together, these activities constitute what are known as **CRUD** (**Create, Read,
    Update, and Delete**) operations on a database.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to create the database, we open the command-line tool of our operating system.
    Within the command line, we first navigate to the directory where we need to create
    the new database file. In order to create the database, we simply use this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a database file named `phonebook.db` in the folder from which
    we execute the command. It also displays a message similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We have now created a database named `phonebook.db`. However, the database
    file is currently empty. It does not contain any tables or any data. So, we get
    no results if we run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'For now, let''s exit the command-line tool by typing this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We want to store contacts in our database, and that is why we will create the
    `contacts` table. Our database table should store a person's name and phone number.
    In addition, it is good practice to keep a unique identification number for each
    person or each entry in the table. This is because multiple people might have
    the same name or same contact number.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a table within our `phonebook.db` database, we again open the command-line
    tool and navigate to the directory where we had created the database. We again get
    into the SQLite3 terminal by typing this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This time, a new database is not created. Rather, the command now opens the existing
    `phonebook.db` database because it is already present on the disk.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we create a table named contacts, and add three columns to the table from
    the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'You can verify the contacts table was created by typing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This prints the name of all the tables present in the currently open database.
    You will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Let's first create a basic GUI that will let us add, view, delete, and modify
    the records. We create a class named `phoneBook` and create all GUI widgets within
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We do not discuss the entire code that creates the GUI as we have coded similar structures
    in the past. However, we use a new ttk widget named `Treeview`. The code for creating
    `Treeview` is as follows (`9.11_phonebook.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'To add items to `Treeview`, we use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'To get all items in `Treeview`, we use the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'To delete items from `Treeview`, we use the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s prepare the code to query our database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The code description is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The method establishes a connection to the `phonebook.db` database we created
    earlier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next line, `cursor = conn.cursor()`, creates a cursor object. The cursor is
    a control structure that is required as per SQL standards, and it enables us to
    traverse the records in a database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next line, `cursor.execute(query)`, executes the query against the database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The line `conn.commit()` actually commits/saves these changes to the database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can now use the preceding method to execute CRUD queries on the database.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new record
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A new record needs to be created every time a user enters a new name and a phone number
    in the entry widgets provided, and then clicks on the Add Record button.
  prefs: []
  type: TYPE_NORMAL
- en: 'The database query for adding a new record is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Reading from the database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The database query for reading all records from the database is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The preceding variable, `phone_book_entries`, contains a list of all the records
    from the database.
  prefs: []
  type: TYPE_NORMAL
- en: Updating records
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To update the phone number of an existing contact, we use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Deleting records
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To delete the phone number of an existing contact, we use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The rest of the code is the supporting GUI. See `9.11_phonebook.py` for the
    complete code. We have now completed coding a basic phone book application.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how to create a database, add tables to the database, and query
    the database to add, modify, delete, and view items in the database. Our phone
    book application has demonstrated how to execute basic CRUD operations on a database.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, due to the similarity of basic database operations, you can now consider
    working with other database systems, such as MySQL, PostgreSQL, Oracle, Ingres,
    SAP DB, Informix, Sybase, Firebird, IBM DB2, Microsoft SQL Server, and Microsoft
    Access.
  prefs: []
  type: TYPE_NORMAL
- en: Using asyncio with Tkinter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Starting with Python 3.4, a new module named `asyncio` was introduced as a Python
    standard module.
  prefs: []
  type: TYPE_NORMAL
- en: 'The term **Asyncio** is made by adding two words: async + I/O.  Async is about
    concurrency, which means doing more than one thing at a time. I/O, on the other
    hand, refers to handling I/O bound tasks. A **bound task** means the thing that
    keeps your program busy.  If, for instance, you are doing computation-intensive
    math processing, the processor is taking most of the time—and it is, therefore,
    a **CPU bound task**. On the contrary, if you are waiting for a result from the
    network, result from the database, or an input from the user, the task is **I/O
    bound**.'
  prefs: []
  type: TYPE_NORMAL
- en: So in a nutshell, the `asyncio` module provides concurrency, particularly for
    I/O bound tasks. Concurrency ensures that you do not have to wait for I/O bound
    results.
  prefs: []
  type: TYPE_NORMAL
- en: Let's say you have to fetch content from multiple URLs, then process the fetched
    content to extract the title and display it in a Tkinter window. Now you obviously cannot fetch
    the content in the same thread that runs the Tkinter main loop, as that would
    make the root window unresponsive while the content is fetched.
  prefs: []
  type: TYPE_NORMAL
- en: So one of the options is to spawn a new thread for each URL. While this can
    be an option, it is not a very scalable one as spawning thousands or more threads
    at a time can lead to a lot of code complexity. We already saw a demo of a race
    condition in the beginning of the current chapter (`9.01_race_condition.py`),
    where running multiple threads can make it difficult to control the shared state. Furthermore,
    as context switching is an expensive and time-consuming affair, the program can
    become laggy after spawning just a few threads.
  prefs: []
  type: TYPE_NORMAL
- en: Here's where `asyncio` comes to our rescue. In contrast to multithreading, which
    relies on threading, `asyncio` uses a concept of event loops.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate, here is a Tkinter program that on the click of a button simulates
    fetching 10 URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s a brief description of the code (`9.12_async_demo.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: The first step in using the `asyncio` module is to construct an event loop using
    the code `event_loop = asyncio.get_event_loop()`. Internally, this `event_loop`
    will schedule all tasks assigned to it using coroutines and futures to do the
    I/O bound tasks in an asynchronous manner.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We pass this `event_loop` as an argument to the Tkinter root window, so that
    it can use this event loop for scheduling async tasks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The method that is in charge of doing the I/O bound task is then defined by
    appending the keyword `async` in front of the method definition. Essentially,
    any method that is to be executed from the event loop must be appended with the
    keyword `async`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The method simulates a time-taking I/O blocking task using `await asyncio.sleep(sec)`. In
    a real case, you will perhaps use this to fetch the contents of a URL or perform
    a similar I/O blocking task.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We start executing the async tasks in a new thread. This single thread executes
    the list of tasks using the `event_loop.run_until_complete(simulate_fetch_all_urls())` command. Note
    that this is different from creating one thread each for each of the tasks. In
    this case, we are only creating a single thread to isolate it from the Tkinter
    main loop.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The line `all_tasks = [simulate_fetch_one_url(url) for url in range(10)]` combines
    all the async tasks into a list. This list of all I/O bound tasks is then passed
    on to `completed, pending = await asyncio.wait(all_tasks)`, which waits for all
    tasks to be completed in a non-blocking manner. Once all the tasks are completed,
    the results are populated in the `completed `variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We get the results of individual tasks using `results = [task.result() for task
    in completed]`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We finally print out all the results to the console.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The benefit of using `asyncio` is that we do not have to spawn one thread for
    each task and as a result, the code does not have to context switch for each individual
    task.  Thus, using `asyncio` we can scale up to fetch thousands of URLs without
    slowing down our program and without worrying about managing results from each
    thread individually.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our brief discussion on using the `asyncio` module with Tkinter.
  prefs: []
  type: TYPE_NORMAL
- en: Interfacing with hardware/serial communication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **internet of things** (**IoT**) is now becoming a reality. We are seeing
    a glimpse of IoT in smart medical devices, driverless cars, smart factories, and
    smart homes. A large number of such IoT applications are built around the idea
    of capturing data with sensors and actuators.
  prefs: []
  type: TYPE_NORMAL
- en: The rise of IoT can largely be attributed to the rise in popularity of microcontrollers,
    which make it very easy to test and build product prototypes for such embedded
    systems.  A microcontroller is a self-contained device with a built-in processor
    and a programmable memory. Most typical microcontrollers provide general purpose
    input/output pins which can be used either to receive data from sensors or to
    send data based on some program that is uploaded to the microcontoller.
  prefs: []
  type: TYPE_NORMAL
- en: In this project, we will use one of the most popular microcontrollers—the Arduino
    Uno—to demonstrate how to build an application that can read data from an external
    device. We will build an Ultrasonic Range Finder. If you find this project interesting,
    you can buy the hardware and build it as well—the total cost of this project is
    less than five dollars. However, if you do not intend to implement it, you can
    merely read through this section. Our primary objective here is to show how to
    get data from external hardware into Tkinter using what is known as serial communication.
  prefs: []
  type: TYPE_NORMAL
- en: Hardware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To begin with, we need an Arduino Uno board (or any other Arduino board). We
    also need an ultrasonic range finder sensor. A quick web search shows hundreds
    of rangefinder sensors for less than a quarter of a dollar. We use a sensor named
    HC-SR04-Ultrasonic Range Finder, but just about any other sensor would do. The
    sensor we have chosen provides a range-finding capability for distances in a 2
    cm - 300 cm range, with an accuracy of up to 3 mm.
  prefs: []
  type: TYPE_NORMAL
- en: These sensors use sonar to determine the distance to an object, just as dolphins
    and bats do. Here's how the sensor calculates the distance. The module has two
    units. The transmitter transmits ultrasound, while a receiver reads any ultrasound
    that reflects back. Since the speed of ultrasound is fixed and known, by calculating
    the time between transmission and reflection, we can calculate the distance of
    the object that reflected the ultrasound.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how the hardware is set up:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e78fab2f-360c-4a2c-99cd-12054b1aa674.png)'
  prefs: []
  type: TYPE_IMG
- en: To the left is the Arduino Uno board. The ultrasound sensor is towards the right.
    As you can see the sensor has four pins marked VCC, Trig, Echo, and GND. The specifications
    of the sensor states that it needs 5 volts to run. Accordingly, we connect the
    VCC pin to a pin that reads 5V on the Arduino pin. Similarly, the ground pin (GND)
    from the sensor is connected to a GND pin on the Arduino board. Now the sensor
    is powered up. We connect the Trig pin to pin number 8 and the Echo pin to pin
    number 7 on the Arduino board. Every time we provide a high pulse on Pin 8, the
    sensor will trigger an ultrasound and then the Echo pin will return the time it
    took for the ultrasound to reflect back, which we will read into the Arduino on
    Pin 7.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the Arduino sketch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the Arduino world, programs that you upload to the microcontroller are called
    sketches. You can write these sketches in a free **integrated development environment**
    (**IDE**) which can be downloaded from here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.arduino.cc/en/Main/Software](https://www.arduino.cc/en/Main/Software)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you finalize a program, you upload it to your Arduino board using the
    upload button on the IDE and voila: your board starts doing what you asked it
    to do.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Every Arduino sketch will have two methods where you get to define the logic
    of your program:'
  prefs: []
  type: TYPE_NORMAL
- en: '`setup()`: For one-time initialization'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`loop()`: For things that the board keeps doing forever until it runs out of
    power'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s the code that we upload to the Arduino (see `9.13.arduino_sketch.ino`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The code description is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The first two lines indicates that we will use pin numbers `7` and `8` on the
    Arduino board and we assign them the variable names `triggerPin` and `echoBackPin`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `setup` function initializes the serial port and fixes its baud rate at
    9600\. Baud rate is defined as the number of signal changes that occur in a second.
    We will use the same rate when reading data in Tkinter with Python.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code `pinMode(triggerPin, OUTPUT)` means that we will now use Pin `8` to
    send an output pulse to the sensor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similarly, the code `pinMode(echoBackPin, INPUT);` declares that we will use
    Pin `7` to receive input from the sensor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Within the loop, we start by setting pin `triggerPin` to low pulse.  We then
    trigger the sensor to emit ultrasound by triggering a high voltage pulse of `2`
    microseconds. This triggers the sensor to emit an ultrasound for 5 microseconds.
    We then mark the pin `LOW` to stop triggering the ultrasound pulse.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then time the signal received on `echoBackPin` using `duration = pulseIn(ioPin,
    HIGH)`. This gives us the time (in microseconds) it took for the ultrasound to
    reflect back.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given that the speed of sound is 340 m/s or 29 microseconds per centimeter,
    we find the distance using the formula `distance = speed * time`. But since this
    is the time it took for a reflected sound to travel out and back, the actual distance
    is half this value. Perhaps the math should be done by Python instead? Doing division
    here using a `long` method will result in a whole number and so will not be precise.
    Note that we could have also offloaded this calculation from Arduino to our Python
    code, as most Arduino processors do not directly support floats in hardware, and
    doing so in software on such a limited processor could bog it down.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The line `delay(100)` ensures that the previous code runs every `100` milliseconds,
    sending pulses of ultrasound and measuring the distance to whatever the sensor
    is pointed at.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The moment this code is uploaded to the Arduino board, it starts sending `5`-microsecond
    pulses of ultrasound after a delay of 100 milliseconds. It also sends a message
    to the serial port of your computer in every one of these loops.
  prefs: []
  type: TYPE_NORMAL
- en: Now it's time to read this using Python and then display it in a Tkinter widget.
  prefs: []
  type: TYPE_NORMAL
- en: Reading serial data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use the `pyserial`module to read data from the serial port. However,
    this is not a standard Python module and needs to be installed. We can install
    it using the following pip command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we are able to get data from the Arduino board, we can further process
    it or plot it in the way we want. However, the goal here is to simply display
    whatever data is sent by the Arduino board over the serial port, as shown in the
    following Tkinter window (`9.14_read_from_serial_port.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d692b435-0152-414c-bf42-6d97a22351f0.png)'
  prefs: []
  type: TYPE_IMG
- en: In order to read the serial port, we first need to identify the port on which
    this message is being sent. There are two ways you can do this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, you can find the name of the port from your Arduino IDE under the
    Tools menu, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ec5b64a4-9b65-44a5-8356-e135fda0a058.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Alternatively, you can run the following command from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This will print a list of all active serial ports. Once you have the port name
    at hand, data reading is done using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The description of the code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We first get an instance of the `Serial` class by calling `ser = serial.Serial()`.
    We then specify the port name and the baud rate. This is the same baud rate that
    we used earlier in our Arduino code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then open the serial port by calling `ser.open()` and read the data using
    `ser.readline()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The rest of the code is Tkinter-specific and creates the GUI and displays the
    results in a `Label` widget.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This concludes the section and the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will conclude the book with discussions on miscellaneous
    issues that you may encounter when writing GUI programs.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's summarize the concepts we discussed in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We learned about the perils of spawning threads and the resulting race condition.
  prefs: []
  type: TYPE_NORMAL
- en: We learned how to use the queue data structure to program a multithreaded application,
    without having to worry about synchronization between multiple threads trying
    to access the same memory, and without using complicated synchronization primitives.
  prefs: []
  type: TYPE_NORMAL
- en: The Weather Reporter application introduced us to the basics of network programming
    and how to tap into the internet to get data. We discussed two popular structures
    used for data exchange, namely XML and JSON.
  prefs: []
  type: TYPE_NORMAL
- en: The port scanner and the chat program discussed the basics of socket programming for
    interprocess and remote communication. We used the TCP/IP protocol to send and
    receive messages in our chat program. We also saw a basic example of client-server
    architecture.
  prefs: []
  type: TYPE_NORMAL
- en: We saw how all forms of communication over a network occur in bytes and how
    we can convert data to bytes and back from bytes to data in the required format.
  prefs: []
  type: TYPE_NORMAL
- en: The phone book application showed us how to work with databases. We saw how to
    perform basic CRUD operations on a database.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we saw how to use the `asyncio` module to fetch I/O bound tasks in a non-blocking
    and scalable manner, without having to worry about managing the states of a large
    number of threads at once.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we saw how to interface with external hardware to collect data from
    sensors using serial communication.
  prefs: []
  type: TYPE_NORMAL
- en: QA section
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few questions to reflect upon:'
  prefs: []
  type: TYPE_NORMAL
- en: What is a race condition? How can you avoid a race condition?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the benefits of using the queue data structure?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the most popular open source databases available in the market?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the most common modes of interprocess communication?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When would you use the `asyncio` module?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are some of the advantages and disadvantages of using serial communication?
    What are some of its alternatives?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the JSON and XML file formats used for? What are their advantages and
    disadvantages when compared to using a database?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We used Python code to perform basic CRUD operations on our database.  It would
    be worthwhile to note that as applications get larger and more complex, the programmer
    should consider making use of an **ORM** (**object-relational mapping**) library
    instead of direct CRUD operations. Read more about ORM and its benefits at [http://blogs.learnnowonline.com/2012/08/28/4-benefits-of-object-relational-mapping-orm/.](http://blogs.learnnowonline.com/2012/08/28/4-benefits-of-object-relational-mapping-orm/)
  prefs: []
  type: TYPE_NORMAL
- en: We used a thread lock as a synchronization primitive in `9.02_lock_demo.py`.
    There are several other synchronization primitives that could have been used instead.
    Learn about other synchronization primitives at [https://www.usenix.org/legacy/publications/library/proceedings/bsdcon02/full_papers/baldwin/baldwin_html/node5.html.](https://www.usenix.org/legacy/publications/library/proceedings/bsdcon02/full_papers/baldwin/baldwin_html/node5.html)
  prefs: []
  type: TYPE_NORMAL
- en: '**Python Enhancement Proposals** (**PEPs**) are official design documents or
    technical specifications in the Python community that describe a new feature that
    has been introduced in Python. For instance, PEP 3156 is the specification dealing
    with and explaining the rationale behind the introduction of the `asyncio` module.
    You can read this PEP document here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.python.org/dev/peps/pep-3156/](https://www.python.org/dev/peps/pep-3156/)'
  prefs: []
  type: TYPE_NORMAL
- en: The event loop in `asyncio` internally uses coroutines and futures to implement
    asynchronous behavior. Learning how to use coroutines and futures can be a valuable
    tool for writing more efficient and scalable programs.
  prefs: []
  type: TYPE_NORMAL
- en: Sockets are commonly used for interprocess communication. However, there are
    many other methods for interprocess communication. A brief read of [http://nptel.ac.in/courses/106108101/pdf/Lecture_Notes/Mod%207_LN.pdf ](http://nptel.ac.in/courses/106108101/pdf/Lecture_Notes/Mod%207_LN.pdf)is
    well worth the effort.
  prefs: []
  type: TYPE_NORMAL
