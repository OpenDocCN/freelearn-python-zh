<html><head></head><body>
<div class="book" title="Chapter&#xA0;7.&#xA0;Sets: No Duplicates"><div class="book" id="173722-77f2b5b248f04368a6f723b0e9357ef3"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07" class="calibre1"/>Chapter 7. Sets: No Duplicates</h1></div></div></div><p class="calibre7">Within the confines of computer science, <span class="strong"><strong class="calibre16">sets</strong></span> are typically used as a simple collection of objects that contain no duplicates. In the broader realm of mathematics in general, however, a set is an abstract data structure that can be described as a collection of distinct objects or values stored in no particular order. For the purpose of this discussion, we will choose to view a set as the computer implementation of a mathematically finite set.</p><p class="calibre7">When working with problems to which the mathematical concepts of set theory can be applied, set data structures provide a powerful group of tools for combining and examining relationships between collections of similar objects. However, even outside set theory and mathematics, the set data structure provides functionality that can be useful in everyday applications. For example, since a set naturally eliminates duplicates, any application that requires maintaining or editing a collection of unique elements would benefit from storing objects in a set data structure. Similarly, if you need to eliminate duplicates from an existing collection, most implementations of the set data structure will allow you to create a new set from a collection of arrays; and in doing so, you will filter out duplicates automatically. Overall, sets are a relatively simple data structure, which provide tremendous functionality and power in analyzing collections of data.</p><p class="calibre7">In this chapter, we will cover the following:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Definition of the set data structure</li><li class="listitem">Set theory</li><li class="listitem">Initializing sets</li><li class="listitem">Common set operations</li><li class="listitem">Revisiting the users logged in to a service problem</li><li class="listitem">Case study - music playlists</li><li class="listitem">Hash table-based sets</li><li class="listitem">Tree-based sets</li><li class="listitem">Array-based sets</li></ul></div></div>

<div class="book" title="Chapter&#xA0;7.&#xA0;Sets: No Duplicates">
<div class="book" title="Set theory"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch07lvl1sec33" class="calibre1"/>Set theory</h1></div></div></div><p class="calibre7">The concept of a set is relatively simple, but in practice a concrete implementation can be somewhat difficult to understand due to its mathematical origins. Therefore, in order to fully appreciate the set data structure, it becomes necessary to examine some of the characteristics and functions of <span class="strong"><strong class="calibre16">set theory</strong></span> upon which the set data structure is built. Set theory is a branch of mathematics that studies collections, or <span class="strong"><em class="calibre20">sets</em></span>, of objects. Although set theory is a major area of research in mathematics with many interrelated sub-fields, we really only need to examine five functions for combining and relating sets to one another to understand the set data structure:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre16">Union</strong></span>: A union is one of the fundamental methods of combining and relating sets to one another. A union of a series of <span class="strong"><em class="calibre20">n</em></span> sets is the set of only those distinct elements contained in those sets. This means that, if you combine sets <span class="strong"><em class="calibre20">A</em></span> and <span class="strong"><em class="calibre20">B</em></span>, the resulting set will only contain unique elements from set <span class="strong"><em class="calibre20">A</em></span> and <span class="strong"><em class="calibre20">B</em></span>. If an element exists in both <span class="strong"><em class="calibre20">A</em></span> and <span class="strong"><em class="calibre20">B</em></span>, it will only appear once in our result set. We use the notation <span class="strong"><em class="calibre20">A</em></span> ∪ <span class="strong"><em class="calibre20">B</em></span> to denote the <span class="strong"><em class="calibre20">union</em></span> of sets <span class="strong"><em class="calibre20">A</em></span> and <span class="strong"><em class="calibre20">B</em></span>. The following Venn diagram represents the union of two sets:</li></ul></div><p class="calibre7">
</p><div class="mediaobject"><img src="../images/00008.jpeg" alt="Set theory" class="calibre17"/></div><p class="calibre18"> </p><p class="calibre7">
</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre16">Intersection</strong></span>: An intersection is the second fundamental method of combining and relating sets to one another. An intersection of a collection of <span class="strong"><em class="calibre20">n</em></span> sets is the set of elements that exist in each of the sets being evaluated. So if we examine sets <span class="strong"><em class="calibre20">A</em></span> and <span class="strong"><em class="calibre20">B</em></span> for an intersection, our resulting set will only include those elements that exist in both <span class="strong"><em class="calibre20">A</em></span> and <span class="strong"><em class="calibre20">B</em></span>. Any elements that are unique to <span class="strong"><em class="calibre20">A</em></span> or <span class="strong"><em class="calibre20">B</em></span> will be discarded. We use the notation <span class="strong"><em class="calibre20">A</em></span> ∩ <span class="strong"><em class="calibre20">B</em></span> to denote the <span class="strong"><em class="calibre20">intersection</em></span> of set <span class="strong"><em class="calibre20">A</em></span> with set <span class="strong"><em class="calibre20">B</em></span>. The following Venn diagram represents the intersection of two sets:</li></ul></div><p class="calibre7">
</p><div class="mediaobject"><img src="../images/00009.jpeg" alt="Set theory" class="calibre17"/></div><p class="calibre18"> </p><p class="calibre7">
</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre16">Difference</strong></span>: The difference operation is the opposite of the intersection operation. The difference of a collection of <span class="strong"><em class="calibre20">n</em></span> sets is the set of elements that are unique to each set being evaluated. If we examine sets <span class="strong"><em class="calibre20">A</em></span> and <span class="strong"><em class="calibre20">B</em></span> for a difference, our resulting set will only include those elements that exist in either <span class="strong"><em class="calibre20">A</em></span> or <span class="strong"><em class="calibre20">B</em></span>. Any elements that are part of the intersection of <span class="strong"><em class="calibre20">A</em></span> and <span class="strong"><em class="calibre20">B</em></span> will be discarded. We use the notation <span class="strong"><em class="calibre20">A</em></span> Δ <span class="strong"><em class="calibre20">B</em></span> to denote the <span class="strong"><em class="calibre20">difference</em></span> between sets <span class="strong"><em class="calibre20">A</em></span> and <span class="strong"><em class="calibre20">B</em></span>. The following Venn diagram represents the difference of two sets:</li></ul></div><p class="calibre7">
</p><div class="mediaobject"><img src="../images/00010.jpeg" alt="Set theory" class="calibre17"/></div><p class="calibre18"> </p><p class="calibre7">
</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre16">Compliment</strong></span>: The compliment, or the <span class="strong"><strong class="calibre16">relative compliment</strong></span>, of <span class="strong"><em class="calibre20">A</em></span> in <span class="strong"><em class="calibre20">B</em></span> is the set of elements that are found in <span class="strong"><em class="calibre20">B</em></span> but not found in <span class="strong"><em class="calibre20">A</em></span>. If we examine sets <span class="strong"><em class="calibre20">A</em></span> and <span class="strong"><em class="calibre20">B</em></span> for a compliment, only those elements that are unique to <span class="strong"><em class="calibre20">B</em></span> will be included in our result set. Any elements that are unique to <span class="strong"><em class="calibre20">A</em></span> or are part of the intersection of <span class="strong"><em class="calibre20">A</em></span> and <span class="strong"><em class="calibre20">B</em></span> will be discarded. We use the notation <span class="strong"><em class="calibre20">B\</em></span><span class="strong"><em class="calibre20">A </em></span>to denote the relative compliment of set <span class="strong"><em class="calibre20">A</em></span> with respect to set <span class="strong"><em class="calibre20">B</em></span>. The following Venn diagram represents the compliment of two sets:</li></ul></div><p class="calibre7">
</p><div class="mediaobject"><img src="../images/00011.jpeg" alt="Set theory" class="calibre17"/></div><p class="calibre18"> </p><p class="calibre7">
</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre16">Subset</strong></span>: The subset is the final fundamental method of combining and relating sets to one another. The subset operation determines if set <span class="strong"><em class="calibre20">A</em></span> is a subset of set <span class="strong"><em class="calibre20">B</em></span>, or rather if set <span class="strong"><em class="calibre20">B</em></span> is a <span class="strong"><strong class="calibre16">superset</strong></span> of set <span class="strong"><em class="calibre20">A</em></span>. This relationship of one set being a subset of another is called an <span class="strong"><strong class="calibre16">inclusion</strong></span>, or a <span class="strong"><strong class="calibre16">containment</strong></span> when considering one set is a superset of another set. In the next figure, we can say that <span class="strong"><em class="calibre20">A</em></span> is the subset of <span class="strong"><em class="calibre20">B</em></span> or <span class="strong"><em class="calibre20">B</em></span> is the superset of <span class="strong"><em class="calibre20">A</em></span>. We use the notation <span class="strong"><em class="calibre20">A</em></span> ⊂ <span class="strong"><em class="calibre20">B</em></span> to denote that set <span class="strong"><em class="calibre20">A</em></span> is an inclusion of set <span class="strong"><em class="calibre20">B</em></span>, or <span class="strong"><em class="calibre20">B ⊃ </em></span> <span class="strong"><em class="calibre20">A</em></span> to denote that set <span class="strong"><em class="calibre20">B</em></span> is the containment of set <span class="strong"><em class="calibre20">A</em></span>.</li></ul></div><p class="calibre7">
</p><div class="mediaobject"><img src="../images/00012.jpeg" alt="Set theory" class="calibre17"/></div><p class="calibre18"> </p><p class="calibre7">
</p></div></div>

<div class="book" title="Initializing sets" id="181NK1-77f2b5b248f04368a6f723b0e9357ef3"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec34" class="calibre1"/>Initializing sets</h1></div></div></div><p class="calibre7">Sets are not terribly commonplace in development, but each of the languages we are examining supports data structures with some form of concrete implementations. Here are some examples of initializing a set, adding a few values to the collection including one duplicate, and printing the set's count to the console after each step.</p><p class="calibre7"><span class="strong"><strong class="calibre16">C#</strong></span></p><p class="calibre7">C# provides a concrete implementation of the set data structure through the <code class="literal">HashSet&lt;T&gt;</code> class. Since this class is generic, the caller may define the type used for elements. For example, the following example initializes a new set where the elements will be <code class="literal">string</code> types:</p><pre class="programlisting">    HashSet&lt;string, int&gt; mySet = new HashSet&lt;string&gt;(); 
    mySet.Add("green");  
    Console.WriteLine("{0}", mySet.Count); 
    mySet.Add("yellow");  
    Console.WriteLine("{0}", mySet.Count); 
    mySet.Add("red");  
    Console.WriteLine("{0}", mySet.Count); 
    mySet.Add("red");  
    Console.WriteLine("{0}", mySet.Count); 
    mySet.Add("blue");  
    Console.WriteLine("{0}", mySet.Count); 
    
    /* Output:  
    1 
    2 
    3 
    3 since "red" already exists in the collection 
    4 
    */ 
</pre><p class="calibre7"><span class="strong"><strong class="calibre16">Java</strong></span></p><p class="calibre7">Java provides a <code class="literal">HashSet&lt;E&gt;</code> class as well as other classes that implement the <code class="literal">Set&lt;E&gt;</code> interface. In this chapter, we'll look at an example of the <code class="literal">HashSet&lt;E&gt;</code> class only:</p><pre class="programlisting">    HashSet&lt;String&gt; mySet = new HashSet&lt; &gt;(); 
    mySet.add("green");  
    System.out.println(mySet.size()); 
    mySet.add("yellow");  
    System.out.println(mySet.size()); 
    mySet.add("red");  
    System.out.println(mySet.size()); 
    mySet.add("red");  
    System.out.println(mySet.size()); 
    mySet.add("blue");  
    System.out.println(mySet.size()); 

    /* Output:  
    1 
    2 
    3 
    3 since "red" already exists in the collection 
    4 
    */ 
</pre><p class="calibre7"><span class="strong"><strong class="calibre16">Objective-C</strong></span></p><p class="calibre7">Objective-C provides immutable as well as mutable set classes, <code class="literal">NSSet</code> and <code class="literal">NSMutableSet</code>. In this chapter, we will only be examining the mutable version in detail:</p><pre class="programlisting">    NSMutableSet *mySet = [NSMutableSet set]; 
    [mySet addObject:@"green"]; 
    NSLog(@"%li", (long)[mySet count]);  
    [mySet addObject:@"yellow"]; 
    NSLog(@"%li", (long)[mySet count]); 
    [mySet addObject:@"red"]; 
    NSLog(@"%li", (long)[mySet count]); 
    [mySet addObject:@"red"]; 
    NSLog(@"%li", (long)[mySet count]); 
    [mySet addObject:@"blue"]; 
    NSLog(@"%li", (long)[mySet count]);  

    /* Output:  
    1 
    2 
    3 
    3 since "red" already exists in the collection 
    4 
    */ 
</pre><p class="calibre7"><span class="strong"><strong class="calibre16">Swift</strong></span></p><p class="calibre7">Sets in Swift are created using the <code class="literal">Set</code> class. Swift sets are mutable when initialized as <span class="strong"><strong class="calibre16">variables</strong></span> using <code class="literal">var</code>, but they can also be created as immutable by initializing them as <span class="strong"><strong class="calibre16">constants</strong></span> using <code class="literal">let</code>. In this chapter, we will only be examining the mutable version in detail:</p><pre class="programlisting">    let mySet: Set&lt;String&gt; = Set&lt;String&gt;() 
    mySet.insert(@"green")  
    print(mySet.count)  
    mySet.insert(@"yellow")  
    print(mySet.count) 
    mySet.insert(@"red")  
    print(mySet.count) 
    mySet.insert(@"red")  
    print(mySet.count) 
    mySet.insert(@"blue")  
    print(mySet.count)  

    /* Output:  
    1 
    2 
    3 
    3 since "red" already exists in the collection 
    4 
    */ 
</pre></div>

<div class="book" title="Initializing sets" id="181NK1-77f2b5b248f04368a6f723b0e9357ef3">
<div class="book" title="Set operations"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_1"><a id="ch07lvl2sec36" class="calibre1"/>Set operations</h2></div></div></div><p class="calibre7">Not all concrete implementations of the set data structures expose the same operational methods. However, the more common operations should be available or can be made available as needed by the developer. As you examine these operations, note how the language is similar to the language of set theory operations discussed earlier. You will find that most of the set data structure functionality will closely mirror that of set theory in general:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre16">add</strong></span>: The add operation, sometimes referred to as an insert, introduces a new object into the collection if that object does not already exist in the collection. This functionality, which prevents duplicate objects from being added to the collection, is one of the core advantages of using a set over many other data structures. Most implementations of the set data structure will return a Boolean value denoting whether or not the element could be added to the collection. Add operations have an <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">n</em></span>) cost.</li><li class="listitem"><span class="strong"><strong class="calibre16">remove</strong></span>: The remove, or delete, operation allows the caller to remove a value or object from the collection if it exists. Most implementations of the set data structure return a Boolean value denoting whether or not the remove operation was successful. Remove operations have an <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">n</em></span>) cost.</li><li class="listitem"><span class="strong"><strong class="calibre16">capacity</strong></span>: The capacity operation returns the maximum number of values the set can hold. This is not an operation that developers will naturally see in the four languages we are discussing as each of the mutable sets found in these languages can dynamically resize on demand. However, some implementations do permit the set to be limited in size as part of its definition. Capacity has an <span class="strong"><strong class="calibre16">O</strong></span>(1) operational cost.</li><li class="listitem"><span class="strong"><strong class="calibre16">union</strong></span>: The union operation returns a new set containing the unique elements of two or more sets. Therefore, this operation has a worst-case cost of <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">n</em></span>+<span class="strong"><em class="calibre20">m</em></span>), where <span class="strong"><em class="calibre20">n</em></span> is the size of the first set and <span class="strong"><em class="calibre20">m</em></span> is the size of the second set.</li><li class="listitem"><span class="strong"><strong class="calibre16">intersection</strong></span>: The intersection operation returns only those elements that are shared between two or more sets. This means that, if you supply the method with two sets, you will only get back those elements that already exist in both sets. Intersection carries an <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">n</em></span>*<span class="strong"><em class="calibre20">m</em></span>), where <span class="strong"><em class="calibre20">n</em></span> is the size of the first set and <span class="strong"><em class="calibre20">m</em></span> is the size of the second set. Interestingly, if you attempt to perform an intersection on a series of three or more sets, the cost becomes <span class="strong"><em class="calibre20">(n-1) </em></span>* <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">L</em></span>), where <span class="strong"><em class="calibre20">n</em></span> is the number of <span class="strong"><em class="calibre20">sets</em></span> involved in the operation and <span class="strong"><em class="calibre20">L</em></span> is the size of the largest set in the series. Obviously, this cost is quite high and using this operation on multiple sets simultaneously could get out of hand very quickly.</li><li class="listitem"><span class="strong"><strong class="calibre16">difference</strong></span>: The difference operation is the opposite of the intersection operation, returning only those elements that are unique to each set. This operation has an operational cost of <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">m</em></span>), where <span class="strong"><em class="calibre20">m</em></span> is the length of the shorter of the two sets being evaluated.</li><li class="listitem"><span class="strong"><strong class="calibre16">subset</strong></span>: The subset operation returns a Boolean value determining whether set <span class="strong"><em class="calibre20">A</em></span> is a subset of set <span class="strong"><em class="calibre20">B</em></span>. For set <span class="strong"><em class="calibre20">A</em></span> to be considered a subset of set <span class="strong"><em class="calibre20">B</em></span>, every element within set <span class="strong"><em class="calibre20">A</em></span> must also be included in set <span class="strong"><em class="calibre20">B</em></span>. If only a portion of the elements of set <span class="strong"><em class="calibre20">A</em></span> are contained in set <span class="strong"><em class="calibre20">B</em></span>, then sets <span class="strong"><em class="calibre20">A</em></span> and <span class="strong"><em class="calibre20">B</em></span> share an intersection, but <span class="strong"><em class="calibre20">A</em></span> is not a subset of <span class="strong"><em class="calibre20">B</em></span>. This operation has an operational cost of <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">m</em></span>), where <span class="strong"><em class="calibre20">m</em></span> is the length of set <span class="strong"><em class="calibre20">A</em></span>.</li><li class="listitem"><span class="strong"><strong class="calibre16">count</strong></span>: The count, or size, operation represents the <span class="strong"><em class="calibre20">cardinality</em></span> of a particular set, which is really just the set theory way of saying the number of elements in the set. Count is typically a simple property on the collection and, therefore, has an <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">1</em></span>) cost.</li><li class="listitem"><span class="strong"><strong class="calibre16">isEmpty</strong></span>: The isEmpty operation returns a Boolean value representing whether the set contains any elements at all. Some implementations provide a corresponding <code class="literal">isFull</code> operation, but only for those instances where the set capacity can be limited to a specific value. Both <code class="literal">isEmpty</code> and <code class="literal">isFull</code> have an <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">1</em></span>) cost.</li></ul></div></div></div>

<div class="book" title="Example: revisiting users logged in to a service" id="190861-77f2b5b248f04368a6f723b0e9357ef3"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec35" class="calibre1"/>Example: revisiting users logged in to a service</h1></div></div></div><p class="calibre7">Let's revisit the users logged into a service problem from <a class="calibre1" title="Chapter 2.  Arrays: Foundational Collections" href="part0019_split_000.html#I3QM2-77f2b5b248f04368a6f723b0e9357ef3">Chapter 2</a>, <span class="strong"><em class="calibre20">Arrays: Foundational Collection</em></span>, one more time and examine how the code will be changed if we had chosen a set as the underlying data structure rather than an array or list.</p><p class="calibre7"><span class="strong"><strong class="calibre16">C#</strong></span></p><p class="calibre7">In this example, we have replaced the <code class="literal">List&lt;User&gt;</code> object with a <code class="literal">HashSet&lt;User&gt;</code> object. The majority of our code is unchanged, but you should note the exclusion of the <code class="literal">CanAddUser(User)</code> method. Originally, this method validated the<span class="strong"><em class="calibre20"> authenticated user</em></span> action by ensuring that the collection had room for another object and then ensuring that the object to be added was not already included in the collection. A set data structure eliminates the need for the second step as it intrinsically prevents duplicate objects from being added. Since the only validation our class now requires is a capacity check, we can handle that inline with the <code class="literal">UserAuthenticated(User)</code> functionality. As an added bonus, we can now easily report whether or not the user was successfully added, as <code class="literal">HashSet&lt;T&gt;.Add(T)</code> returns <code class="literal">true</code> for success, and <code class="literal">false</code> when the object already exists in the set:</p><pre class="programlisting">    public class LoggedInUserSet 
    { 
        HashSet&lt;User&gt; _users; 
 
        public LoggedInUserSet() 
        { 
            _users = new HashSet&lt;User&gt;(); 
        } 
 
        public bool UserAuthenticated(User user) 
        { 
            if (_users.Count &lt; 30) 
            { 
                return _users.Add(user); 
            } 
            return false; 
        } 
 
        public void UserLoggedOut(User user) 
        { 
            _users.Remove(user); 
        } 
    } 
</pre><p class="calibre7"><span class="strong"><strong class="calibre16">Java</strong></span></p><p class="calibre7">Changes in our Java example almost mirror those of our C# example. Again, we have replaced the <code class="literal">List&lt;User&gt;</code> object with a <code class="literal">HashSet&lt;User&gt;</code> object. The majority of our code is unchanged, except for the exclusion of the <code class="literal">canAddUser(User)</code> method. In Java, the <code class="literal">HashSet&lt;E&gt;</code> class implements the <code class="literal">Set&lt;E&gt;</code> interface and is based on a set data structure, which eliminates the need for checking whether an object exists in the collection before adding it. Since the only validation our class now requires is a capacity check, we can handle that inline with the <code class="literal">userAuthenticated(User)</code> functionality. Again, we can now easily report whether or not the user was successfully added, as <code class="literal">HashSet&lt;E&gt;.add(E)</code> returns <code class="literal">true</code> for success, and <code class="literal">false</code> when the object already exists in the set:</p><pre class="programlisting">    HashSet&lt;User&gt; _users; 
 
    public LoggedInUserSet() 
    { 
        _users = new HashSet&lt;User&gt;(); 
    } 
 
    public boolean userAuthenticated(User user) 
    { 
        if (_users.size() &lt; 30) 
        { 
            return _users.add(user); 
        } 
        return false; 
    } 
 
    public void userLoggedOut(User user) 
    { 
        _users.remove(user); 
    } 
</pre><p class="calibre7"><span class="strong"><strong class="calibre16">Objective-C</strong></span></p><p class="calibre7">Changes to our Objective-C example yield some interesting results. Although we are exchanging the <code class="literal">NSMutableArray</code> collection for an <code class="literal">NSMutableSet</code> collection, the majority of our code remains the same, including the fact that we are not going to return a <code class="literal">BOOL</code> representing the success or failure of our <code class="literal">addObject:</code> operation. This is because <code class="literal">addObject:</code> does not return a value; if we were to include it in <code class="literal">userAuthenticated:</code>, we would have to resort to calling the <code class="literal">containsObject:</code> method prior to calling <code class="literal">addObject:</code> on our set collection. Since the entire point of this exercise is to use a set to eliminate the need to check for duplicates before adding new objects, to re-introduce this functionality would defeat the purpose and potentially put us in a more costly position than if we simply stuck with an array or list.</p><p class="calibre7">This is not to say that there are no valid applications that could benefit from a set as well as a report on the success or failure of an <code class="literal">addObject:</code> operation; this is just not one of those cases:</p><pre class="programlisting">    @interface EDSLoggedInUserSet() 
    { 
        NSMutableSet *_users; 
    } 
    @end 
 
    @implementation EDSLoggedInUserSet 
    -(instancetype)init 
    { 
        if (self = [super init]) 
        { 
            _users = [NSMutableSet set]; 
        } 
        return self; 
    } 
 
    -(void)userAuthenticated:(EDSUser *)user 
    { 
        if ([_users count] &lt; 30) 
        { 
            [_users addObject:user]; 
        } 
    } 
 
    -(void)userLoggedOut:(EDSUser *)user 
    { 
        [_users removeObject:user]; 
    } 
</pre><p class="calibre7"><span class="strong"><strong class="calibre16">Swift</strong></span></p><p class="calibre7">The outcome of our Swift example is almost exactly like that of our Objective-C example. Again, we are replacing our array with a set, but sets in Swift function much like they do in Objective-C. Therefore, our final code is more abbreviated but does not immediately provide the same functionality as our C# and Java implementations:</p><pre class="programlisting">    var _users: Set&lt;User&gt; = Set&lt;User&gt;() 
 
    public func userAuthenticated(user: User) 
    { 
        if (_users.count &lt; 30) 
        { 
            _users.insert(user) 
        } 
    } 
 
    public func userLoggedOut(user: User) 
    { 
        if let index = _users.indexOf(user) 
        { 
            _users.removeAtIndex(index) 
        } 
    } 
</pre></div>

<div class="book" title="Example: revisiting users logged in to a service" id="190861-77f2b5b248f04368a6f723b0e9357ef3">
<div class="book" title="We would need a contract"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_1"><a id="ch07lvl2sec37" class="calibre1"/>We would need a contract</h2></div></div></div><p class="calibre7">If you look carefully at each of the three solutions to the logged in user business problem, you will probably notice they all share common public methods. In our array implementation, list implementation, and set implementation, we have two public methods named <code class="literal">UserAuthenticated()</code> and <code class="literal">UserLoggedOut()</code>, or some variation of these names depending on the language. This would not be an issue if we were to just choose one implementation that best suits our needs and move on. However, what if there were justifiable reasons to keep each one of these classes in our solution to efficiently work within specific environmental conditions?</p><p class="calibre7">In actuality, it is very common to see multiple classes that share the same public-facing methods but have uniquely implemented functionality under the hood. If we were to simply create three (or more) separate implementations that are completely independent of one another, our application would have a resulting <span class="strong"><em class="calibre20">code smell</em></span>. That's because, whenever we want to use a specific implementation, we will need to call for it by name, which requires some advance knowledge of which classes and implementations are available. Plus, although our code might work just fine, it will be fragile, inextensible, and more difficult to maintain in the long term.</p><p class="calibre7">A better solution would involve defining a contract that each class implements. In C# or Java, we would define an interface, while in Objective-C and Swift, we would define a protocol. The difference between these two patterns is mostly semantics, as they will both provide our caller with the names of the methods, what the methods expect, and what the methods will return. What is important is that by doing this, we greatly simplify and harden our implementation of both the functionality and the calling class structures.
</p></div></div>
<div class="book" title="Case-study: music playlists"><div class="book" id="19UOO2-77f2b5b248f04368a6f723b0e9357ef3"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec36" class="calibre1"/>Case-study: music playlists</h1></div></div></div><p class="calibre7"><span class="strong"><strong class="calibre16">Business problem</strong></span>: A music streaming service wants to provide their users with a better streaming experience. Currently, user playlists are a simple collection of songs dumped into a bucket that provides no means of filtering or ordering the collection. The content management team has heard the complaints of their users and has tasked the engineering team with building a better playlist. </p><p class="calibre7">This new playlist tool will have several key requirements. The more basic requirements include the ability to add and remove songs from the list, the ability to differentiate between an empty list and a list with elements, as well the ability to report on the total count of elements in the list. For those customers who are not interested in paying for the premium service, the lists will be limited to a 100 songs so our playlist tool must also have the ability to set a capacity and easily identify when the capacity has been met.</p><p class="calibre7">Additionally, many premium users are known to have thousands of songs in their playlist, as well as multiple themed playlists for everything from riding their bike to doing the laundry. For these users the playlist tool must include some advanced analysis and editing features. First, there must be a way to easily consolidate playlists and, since we don't want to have songs that exist in both playlists to appear twice, this consolidation must prevent duplicates. Next, the playlist should be able to easily identify songs that are duplicated between two lists as well as identify songs that are unique to specific lists. Finally, some users will want to know more information about their collection of playlists, such as whether one playlist exists as part of another playlist. Based on these requirements, the developer decides that a set will be the most efficient way to represent the playlists, so the core class's functionality will be based on that data structure.</p><p class="calibre7"><span class="strong"><strong class="calibre16">C#</strong></span></p><p class="calibre7">C# provides the generic collection <code class="literal">HashSet&lt;T&gt;</code>. This class provides all of the basic operations we would expect to see in a concrete set implementation with the added benefit of generic type casting:</p><pre class="programlisting">    HashSet&lt;Song&gt; _songs; 
    public Int16 capacity { get; private set; } 
    public bool premiumUser { get; private set; } 
    public bool isEmpty  
    { 
        get 
        { 
            return _songs.Count == 0; 
        } 
    } 
 
    public bool isFull 
    { 
        get 
        { 
            if (this.premiumUser) 
            { 
                return false; 
            } 
            else 
            { 
                return _songs.Count == this.capacity; 
            } 
        } 
    } 
 
    public PlaylistSet(bool premiumUser, Int16 capacity) 
    { 
        _songs = new HashSet&lt;Song&gt;(); 
        this.premiumUser = premiumUser; 
        this.capacity = capacity;  
    } 
</pre><p class="calibre7">Using the <code class="literal">HashSet&lt;T&gt;</code> interface, we create one private field for our class called <code class="literal">_songs</code>. Our constructor instantiates this field, giving us the underlying data structure to build our <code class="literal">PlaylistSet</code> class on. We also create four public fields: <code class="literal">capacity</code>, <code class="literal">premiumUser</code>, <code class="literal">isEmpty</code>, and <code class="literal">isFull</code>. The <code class="literal">capacity</code> field stores the maximum numbers of songs non-premium users can store in their playlist, while <code class="literal">premiumUser</code> denotes whether this list belongs to a premium account or not. The <code class="literal">isEmpty</code> and <code class="literal">isFull</code> fields allow our class to easily implement the two operations of the same name. The <code class="literal">isEmpty</code> field simply returns whether or not the count of the set is <code class="literal">0</code>. The <code class="literal">isFull</code> field first checks whether this list belongs to a premium account. If <code class="literal">true</code>, the collection is never full as we allow premium users to store unlimited songs in their playlists. If this list does not belong to a premium account, our getter ensures that the current count of <code class="literal">_songs</code> has not exceeded the capacity and returns that comparison:</p><pre class="programlisting">    public bool AddSong(Song song) 
    { 
        if (!this.isFull) 
        { 
            return _songs.Add(song); 
        } 
        return false; 
    } 
</pre><p class="calibre7">The <code class="literal">AddSong(Song song)</code> method provides the <span class="strong"><em class="calibre20">add</em></span> functionality to our class. This method first confirms that the collection is not full. If this is so, the method returns <code class="literal">false</code> as we cannot add any more songs to the list. Otherwise, the method returns the result of <code class="literal">HashSet&lt;T&gt;.Add(T)</code> which returns <code class="literal">true</code> if <code class="literal">song</code> is added, meaning the song was not already in the list.</p><pre class="programlisting">    public bool RemoveSong(Song song) 
    { 
        return _songs.Remove(song); 
    } 
</pre><p class="calibre7">The <code class="literal">RemoveSong(Song song)</code> method provides <span class="strong"><em class="calibre20">remove</em></span> functionality to our class. This method simply returns the result of <code class="literal">HashSet&lt;T&gt;.Remove(T)</code>, which will return <code class="literal">true</code> if the song exists in the list; otherwise, it will return <code class="literal">false</code>:</p><pre class="programlisting">    public void MergeWithPlaylist(HashSet&lt;Song&gt; playlist) 
    { 
        _songs.UnionWith(playlist); 
    } 
</pre><p class="calibre7">The <code class="literal">MergeWithPlaylist(HashSet&lt;Song&gt; playlist)</code> method provides the <span class="strong"><em class="calibre20">union</em></span> functionality for our class. Luckily, <code class="literal">HashSet&lt;T&gt;</code> exposes the union functionality with the <code class="literal">Union(HashSet&lt;T&gt;)</code> method, so our method simply calls it. In this case, <code class="literal">Union()</code> will merge the <code class="literal">playlist</code> parameter with our existing <code class="literal">_songs</code> list:</p><pre class="programlisting">    public HashSet&lt;Song&gt; FindSharedSongsInPlaylist(HashSet&lt;Song&gt; playlist) 
    { 
        HashSet&lt;Song&gt; songsCopy = new HashSet&lt;Song&gt;(_songs); 
        songsCopy.IntersectWith(playlist); 
        return songsCopy; 
    } 
</pre><p class="calibre7">Next, the <code class="literal">FindSharedSongsInPlaylist(HashSet&lt;Song&gt; playlist)</code> method provides the <span class="strong"><em class="calibre20">intersection</em></span> functionality to our class. Again, <code class="literal">HashSet&lt;T&gt;</code> conveniently provides the <code class="literal">IntersectWith(HashSet&lt;T&gt;)</code> method, which our method takes advantage of. Note that this method does not modify our list in-place, but rather returns the actual intersection of our list and the <code class="literal">playlist</code> parameter. We do this because it would not be very useful to simply eliminate songs that are unique to one list or the other. This method will instead be used for informational purposes by other functions within the overall application.</p><p class="calibre7">Since we are not modifying the existing list but only returning information about the intersection, our method first makes a copy of the <code class="literal">_songs</code> set using the overloaded <code class="literal">HashSet&lt;T&gt;</code> object. Then, our method modifies the copied list and returns the result of the intersection operation:</p><pre class="programlisting">    public HashSet&lt;Song&gt; FindUniqueSongs(HashSet&lt;Song&gt; playlist) 
    { 
        HashSet&lt;Song&gt; songsCopy = new HashSet&lt;Song&gt;(_songs); 
        songsCopy.ExceptWith(playlist); 
        return songsCopy; 
    } 
</pre><p class="calibre7">The <code class="literal">FindUniqueSongs(HashSet&lt;Song&gt; playlist)</code> method provides the <span class="strong"><em class="calibre20">difference</em></span> functionality to our class and works under a methodology that is very similar to the previous method. Again, this method does not modify our existing set in place but returns the results of the <code class="literal">ExceptWith()</code> operation on the copied set and the <code class="literal">playlist</code> parameter:</p><pre class="programlisting">    public bool IsSubset(HashSet&lt;Song&gt; playlist) 
    { 
        return _songs.IsSubsetOf(playlist); 
    } 
 
    public bool IsSuperset(HashSet&lt;Song&gt; playlist) 
    { 
        return _songs.IsSupersetOf(playlist); 
    } 
</pre><p class="calibre7">The <code class="literal">IsSubset(HashSet&lt;Song&gt; playlist)</code> and <code class="literal">IsSuperset(HashSet&lt;Song&gt; playlist)</code> methods provide the functionalities implied by their names. These methods utilize the <code class="literal">HashSet&lt;T&gt;.IsSubSetOf(HashSet&lt;T&gt;)</code> and <code class="literal">HashSet&lt;T&gt;.IsSuperSetOf(HashSet&lt;T&gt;)</code> methods, respectively and return a Boolean value representing the result of those comparisons:</p><pre class="programlisting">    public int TotalSongs() 
    { 
        return _songs.Count; 
    } 
</pre><p class="calibre7">Finally, the <code class="literal">TotalSongs()</code> method returns the number of elements found in the <code class="literal">_songs</code> set, providing <span class="strong"><em class="calibre20">count</em></span> functionality to our collection.</p><p class="calibre7"><span class="strong"><strong class="calibre16">Java</strong></span></p><p class="calibre7">Java provides the generic collection <code class="literal">HashSet&lt;E&gt;</code> that implements the <code class="literal">Set&lt;E&gt;</code> interface. This class provides all of the basic operations we would expect to see in a concrete set implementation with the added benefit of generic type casting:</p><pre class="programlisting"> 
    private HashSet&lt;Song&gt; _songs; 
    public int capacity; 
    public boolean premiumUser; 
    public boolean isEmpty() 
    { 
        return _songs.size() == 0; 
    } 
 
    public boolean isFull() 
    { 
        if (this.premiumUser) 
        { 
            return false; 
        } 
        else { 
            return _songs.size() == this.capacity; 
        } 
    } 
 
    public PlaylistSet(boolean premiumUser, int capacity) 
    { 
        _songs = new HashSet&lt;&gt;(); 
        this.premiumUser = premiumUser; 
        this.capacity = capacity; 
    } 
</pre><p class="calibre7">Using <code class="literal">HashSet&lt;E&gt;</code>, we create one private field for our class called <code class="literal">_songs</code>. Our constructor instantiates this field, giving us the underlying data structure to build our <code class="literal">PlaylistSet</code> class on. We also create two public fields and two public accessors: <code class="literal">capacity</code>, <code class="literal">premiumUser</code>, <code class="literal">isEmpty()</code>, and <code class="literal">isFull()</code>. The <code class="literal">capacity</code> field stores the maximum numbers of songs non-premium users can store in their playlist, while <code class="literal">premiumUser</code> denotes whether this list belongs to a premium account or not. The <code class="literal">isEmpty()</code> and <code class="literal">isFull()</code> accessors allow our class to easily implement the two operations of the same name. These two accessors function exactly as their C# field counterparts. The <code class="literal">isEmpty()</code> method simply returns whether or not the count of the set is <code class="literal">0</code>. The <code class="literal">isFull()</code> method first checks whether this list belongs to a premium account.</p><p class="calibre7">If <code class="literal">true</code>, the collection is never full as we allow premium users to store unlimited songs in their playlists. If this list does not belong to a premium account, our getter ensures that the current count of <code class="literal">_songs</code> has not exceeded <code class="literal">capacity</code> and returns that comparison:</p><pre class="programlisting">    public boolean addSong(Song song) 
    { 
        if (!this.isFull()) 
        { 
            return _songs.add(song); 
        } 
        return false; 
    } 
</pre><p class="calibre7">The <code class="literal">addSong(Song song)</code> method provides <span class="strong"><em class="calibre20">add</em></span> functionality to our class. This method first confirms that the collection is not full. If so, the method returns <code class="literal">false</code> as we cannot add any more songs to the list. Otherwise, the method returns the result of <code class="literal">HashSet&lt;E&gt;.add(E)</code>, which will return <code class="literal">true</code> if the song is added, and that too only if the song is not already in this playlist:</p><pre class="programlisting">    public boolean removeSong(Song song) 
    { 
        return _songs.remove(song); 
    } 
</pre><p class="calibre7">The <code class="literal">removeSong(Song song)</code> method provides the <span class="strong"><em class="calibre20">remove</em></span> functionality to our class. This method simply returns the result of <code class="literal">HashSet&lt;E&gt;.remove(E)</code>, which will return <code class="literal">true</code> if the song exists in the set; otherwise, it will return <code class="literal">false</code>.</p><pre class="programlisting">    public void mergeWithPlaylist(HashSet&lt;Song&gt; playlist) 
    { 
        _songs.addAll(playlist); 
    } 
</pre><p class="calibre7">The <code class="literal">mergeWithPlaylist(HashSet&lt;Song&gt; playlist)</code> method provides <span class="strong"><em class="calibre20">union</em></span> functionality for our class, and this is where our class begins to truly diverge from our previous C# example. <code class="literal">HashSet&lt;E&gt;</code> exposes the <span class="strong"><em class="calibre20">union</em></span> functionality we're looking for, but only by calling the <code class="literal">HashSet&lt;E&gt;.addAll(HashSet&lt;E&gt;)</code> method. This method accepts a set of <code class="literal">Song</code> objects as a parameter and attempts to add each one to our <code class="literal">_songs</code> collection. If the <code class="literal">Song</code> element being added already exists in the <code class="literal">_songs</code> set, that element will be discarded, leaving us with only unique <code class="literal">Song</code> objects from both lists or a union of the two sets:</p><pre class="programlisting">    public HashSet&lt;Song&gt; findSharedSongsInPlaylist(HashSet&lt;Song&gt; playlist) 
    { 
        HashSet&lt;Song&gt; songsCopy = new HashSet&lt;&gt;(_songs); 
        songsCopy.retainAll(playlist); 
        return songsCopy; 
    } 
</pre><p class="calibre7">Next, the <code class="literal">findSharedSongsInplaylist(HashSet&lt;Song&gt; playlist)</code> method provides the <span class="strong"><em class="calibre20">intersection</em></span> functionality to our class. Again, <code class="literal">HashSet&lt;E&gt;</code> exposes intersection functionality, but not directly. Our method uses the <code class="literal">HashSet&lt;E&gt;.retainAll(HashSet&lt;E&gt;)</code> method, which retains all of the elements in the <code class="literal">_songs</code> set, that also exist in the <code class="literal">playlist</code> parameter, or intersection of the two collections. As in our C# example, we are not modifying the <code class="literal">_songs</code> set in place but rather returning the intersection between a copy of <code class="literal">_songs</code> and the <code class="literal">playlist</code> parameter:</p><pre class="programlisting">    public HashSet&lt;Song&gt; findUniqueSongs(HashSet&lt;Song&gt; playlist) 
    { 
        HashSet&lt;Song&gt; songsCopy = new HashSet&lt;&gt;(_songs); 
        songsCopy.removeAll(playlist); 
        return songsCopy; 
    } 
</pre><p class="calibre7">The <code class="literal">findUniqueSongs(HashSet&lt;Song&gt; playlist)</code> method provides the <span class="strong"><em class="calibre20">difference</em></span> functionality to our class. Once again, <code class="literal">HashSet&lt;E&gt;</code> exposes the difference functionality, but through the <code class="literal">removeAll(HashSet&lt;E&gt;)</code> method. The <code class="literal">removeAll()</code> method removes all of the <code class="literal">_songs</code> elements that are also contained in the playlist parameter or the difference between the two collections. Again, this method does not modify our existing set in place but returns the results of the <code class="literal">removeAll() </code>method, or difference operation, on the <code class="literal">_songs</code> copy and the <code class="literal">playlist</code> parameter:</p><pre class="programlisting">    public boolean isSubset(HashSet&lt;Song&gt; playlist) 
    { 
        return _songs.containsAll(playlist); 
    } 
 
    public boolean isSuperset(HashSet&lt;Song&gt; playlist) 
    { 
        return playlist.containsAll(_songs); 
    } 
</pre><p class="calibre7">The <code class="literal">isSubset(HashSet&lt;Song&gt; playlist)</code> and <code class="literal">isSuperset(HashSet&lt;Song&gt; playlist)</code> methods provide the functionality of the same names. These methods both utilize the <code class="literal">HashSet&lt;E&gt;.containsAll(HashSet&lt;E&gt;)</code> method and return a Boolean value representing the result of those comparisons. Our methods simply swap the source set and the parameter to obtain the desired comparison since <code class="literal">HashSet&lt;E&gt;</code> does not provide a specific comparator for each function:</p><pre class="programlisting">    public int totalSongs() 
    { 
        return _songs.size(); 
    } 
</pre><p class="calibre7">Finally, the <code class="literal">totalSongs()</code> method returns the number of elements found in the <code class="literal">_songs</code> set using the collection's <code class="literal">size()</code> method, providing the <span class="strong"><em class="calibre20">count</em></span> functionality to our collection.</p><p class="calibre7"><span class="strong"><strong class="calibre16">Objective-C</strong></span></p><p class="calibre7">Objective-C provides the <code class="literal">NSSet</code> and <code class="literal">NSMutableSet</code> class clusters as the concrete implementations of the set data structure. These class clusters provide most of the functionality we would expect to see in a set data structure, and the explicit functions that are missing are very simple to implement, which makes the Objective-C implementation fairly straightforward:</p><pre class="programlisting">    @interface EDSPlaylistSet() 
    { 
        NSMutableSet&lt;EDSSong*&gt;* _songs; 
        NSInteger _capacity; 
        BOOL _premiumUser; 
        BOOL _isEmpty; 
        BOOL _isFull; 
    } 
    @end 
 
    @implementation EDSPlaylistSet 
 
    -(instancetype)playlistSetWithPremiumUser:(BOOL)isPremiumUser andCapacity:(NSInteger)capacity 
    { 
        if (self == [super init]) 
        { 
            _songs = [NSMutableSet set]; 
            _premiumUser = isPremiumUser; 
            _capacity = capacity; 
        } 
        return self;  
    } 

    -(BOOL)isEmpty 
    { 
        return [_songs count] == 0; 
    } 
 
    -(BOOL)isFull 
    { 
        if (_premiumUser) 
        { 
            return NO; 
        } 
        else 
        { 
            return [_songs count] == _capacity; 
        } 
    } 
</pre><p class="calibre7">Using <code class="literal">NSMutableSet</code>, we create one private ivar for our class called <code class="literal">_songs</code>. Our initializer instantiates this field, giving us the underlying data structure to build our <code class="literal">EDSPlaylistSet</code> class on. We also create four public properties: <code class="literal">capacity</code>, <code class="literal">premiumUser</code>, <code class="literal">isEmpty</code>, and <code class="literal">isFull</code> in our header file, backed by private ivars of the same name. The <code class="literal">capacity</code> property stores the maximum numbers of songs non-premium users can store in their playlist, while <code class="literal">premiumUser</code> denotes if this list belongs to a premium account or not. The <code class="literal">isEmpty</code> and <code class="literal">isFull</code> properties allow our class to easily implement the two operations of the same name. The <code class="literal">isEmpty</code> property simply returns whether or not the count of the set is <code class="literal">0</code>, while the <code class="literal">isFull</code> property first checks whether this list belongs to a premium account. If <code class="literal">true</code>, the collection is never full as we allow premium users to store unlimited songs in their playlists. If this list does not belong to a premium account, our method ensures that the current count of <code class="literal">_songs</code> has not exceeded the capacity and returns that comparison:</p><pre class="programlisting">    -(BOOL)addSong:(EDSSong*)song 
    { 
        if (!_isFull &amp;&amp; ![_songs containsObject:song]) 
        { 
            [_songs addObject:song]; 
            return YES; 
        } 
        return NO; 
    } 
</pre><p class="calibre7">The <code class="literal">addSong:</code> method provides <span class="strong"><em class="calibre20">add</em></span> functionality to our class. This method first confirms that the collection is not full and then confirms that the object is actually contained in the <code class="literal">_songs</code> collection. If the collection does not pass both tests, the method returns <code class="literal">NO</code>, as we cannot add any more songs to the list or the song already exists in the collection. Otherwise, the method calls <code class="literal">addObject:</code> and returns <code class="literal">YES</code>:</p><pre class="programlisting">    -(BOOL)removeSong:(EDSSong*)song 
    { 
        if ([_songs containsObject:song]) 
        { 
            [_songs removeObject:song]; 
            return YES; 
        } 
        else 
        { 
            return NO; 
        } 
    } 
</pre><p class="calibre7">The <code class="literal">removeSong:</code> method provides <span class="strong"><em class="calibre20">remove</em></span> functionality to our class. This method confirms that the song exists in the collection, then removes the song using <code class="literal">removeObject:</code>, and finally returns <code class="literal">YES</code>. If the song does not exist in the collection, the method returns <code class="literal">NO</code>:</p><pre class="programlisting">    -(void)mergeWithPlaylist:(NSMutableSet&lt;EDSSong*&gt;*)playlist 
    { 
        [_songs unionSet:playlist]; 
    } 
</pre><p class="calibre7">The <code class="literal">mergeWithPlaylist:</code> method provides <span class="strong"><em class="calibre20">union</em></span> functionality for our class. Luckily, <code class="literal">NSSet</code> exposes the union functionality with the <code class="literal">unionSet:</code> method, so our method simply calls it. In this case, <code class="literal">unionSet:</code> will merge the <code class="literal">playlist</code> parameter with our existing <code class="literal">_songs</code> list:</p><pre class="programlisting">    -(NSMutableSet&lt;EDSSong*&gt;*)findSharedSongsInPlaylist: (NSMutableSet&lt;EDSSong*&gt;*)playlist 
    { 
        NSMutableSet *songsCopy = [NSMutableSet setWithSet:_songs]; 
        [songsCopy intersectSet:playlist]; 
        return songsCopy; 
    } 
</pre><p class="calibre7">Next, the <code class="literal">findSharedSongsInplaylist:</code> method provides <span class="strong"><em class="calibre20">intersection</em></span> functionality to our class. Again, <code class="literal">NSSet</code> exposes the intersection functionality through the <code class="literal">intersectSet:</code> method. As in our C# example, we are not modifying the <code class="literal">_songs</code> set in place but rather returning the intersection between a copy of <code class="literal">_songs</code> and the <code class="literal">playlist</code> parameter:</p><pre class="programlisting">    -(NSMutableSet&lt;EDSSong*&gt;*)findUniqueSongs:(NSMutableSet&lt;EDSSong*&gt;*)playlist 
    { 
        NSMutableSet *songsCopy = [NSMutableSet setWithSet:_songs]; 
        [songsCopy minusSet:playlist]; 
        return songsCopy; 
    } 
</pre><p class="calibre7">The <code class="literal">findUniqueSongs:</code> method provides the <span class="strong"><em class="calibre20">difference</em></span> functionality to our class. Once again, <code class="literal">NSSet</code> exposes the difference functionality through the <code class="literal">minusSet:</code> method. And again, this method does not modify our existing set in place but returns the results of the <code class="literal">minusSet:</code>, or difference, operation on the <code class="literal">_songs</code> copy and the <code class="literal">playlist</code> parameter:</p><pre class="programlisting">    -(BOOL)isSubset:(NSMutableSet&lt;EDSSong*&gt;*)playlist 
    { 
        return [_songs isSubsetOfSet:playlist];  
    } 
 
    -(BOOL)isSuperset:(NSMutableSet&lt;EDSSong*&gt;*)playlist 
    { 
        return; 
    } 
</pre><p class="calibre7">The <code class="literal">isSubset:</code> and <code class="literal">isSuperset:</code> methods provide the functionalities by their names. These methods utilize the <code class="literal">isSubsetOfSet:</code> method on <code class="literal">NSSet</code> in much the same way that our Java example utilizes the <code class="literal">containsAll(HashSet&lt;E&gt;)</code> method of the <code class="literal">Set&lt;E&gt;</code> interface:</p><pre class="programlisting">    -(NSInteger)totalSongs 
    { 
        return [_songs count]; 
    } 
</pre><p class="calibre7">Finally, the <code class="literal">totalSongs</code> method returns the number of elements found in the <code class="literal">_songs</code> set, providing <span class="strong"><em class="calibre20">count</em></span> functionality to our collection.</p><p class="calibre7"><span class="strong"><strong class="calibre16">Swift</strong></span></p><p class="calibre7">Swift provides the <code class="literal">Set</code> class as a concrete implementation of the set data structure. This class provides all of the functionality we would expect to see in a set data structure, even more so than its Objective-C counterpart, which makes the Swift implementation very clean:</p><pre class="programlisting">    var _songs: Set&lt;Song&gt; = Set&lt;Song&gt;() 
    
    public private(set) var _capacity: Int 
    public private(set) var _premiumUser: Bool 
    public private(set) var _isEmpty: Bool 
    public private(set) var _isFull: Bool 
 
    public init (capacity: Int, premiumUser: Bool) 
    { 
        _capacity = capacity 
        _premiumUser = premiumUser 
        _isEmpty = true 
        _isFull = false 
    } 
    
    public func premiumUser() -&gt; Bool 
    { 
        return _premiumUser 
    } 
 
    public func isEmpty() -&gt; Bool 
    { 
        return _songs.count == 0 
    } 
 
    public func isFull() -&gt; Bool 
    { 
        if (_premiumUser) 
        { 
            return false 
        } 
        else 
        { 
            return _songs.count == _capacity 
        } 
    } 
</pre><p class="calibre7">Using <code class="literal">Set</code>, we create one private ivar for our class called <code class="literal">_songs</code> and initialize it inline with its declaration, giving us the underlying data structure to build our <code class="literal">PlaylistSet</code> class on. We also create four public fields, <code class="literal">_capacity</code>, <code class="literal">_premiumUser</code>, <code class="literal">_isEmpty</code>, and <code class="literal">_isFull</code>, as well as public accessors for the last three. The <code class="literal">capacity</code> field stores the maximum number of songs non-premium users can store in their playlist while <code class="literal">premiumUser</code> denotes whether this list belongs to a premium account or not. The <code class="literal">isEmpty</code> and <code class="literal">isFull</code> fields allow our class to easily implement the two operations of the same name. The <code class="literal">isEmpty()</code> field simply returns whether or not the count of the set is <code class="literal">0</code>. The <code class="literal">isFull()</code> field first checks if this list belongs to a premium account. If <code class="literal">true</code>, the collection is never full as we allow premium users to store unlimited songs in their playlists. If this list does not belong to a premium account, our getter ensures that the current count of <code class="literal">_songs</code> has not exceeded <code class="literal">capacity</code> and returns that comparison:</p><pre class="programlisting">    public func addSong(song: Song) -&gt; Bool 
    { 
        if (!_isFull &amp;&amp; !_songs.contains(song)) 
        { 
            _songs.insert(song) 
            return true 
        } 
        return false 
    } 
</pre><p class="calibre7">The <code class="literal">addSong(song: Song)</code> method provides <span class="strong"><em class="calibre20">add</em></span> functionality to our class. This method first confirms that the collection is not full and then confirms that the object is actually contained in the <code class="literal">_songs</code> collection. If the collection does not pass both tests, the method returns <code class="literal">false</code>, as we cannot add any more songs to the list or the song already exists in the collection. Otherwise, the method calls <code class="literal">insert()</code> and returns <code class="literal">true</code>:</p><pre class="programlisting">    public func removeSong(song: Song) -&gt; Bool 
    { 
        if (_songs.contains(song)) 
        { 
            _songs.remove(song) 
            return true 
        } 
        else 
        { 
            return false 
        } 
    } 
</pre><p class="calibre7">The <code class="literal">removeSong(song: Song)</code> method provides <span class="strong"><em class="calibre20">remove</em></span> functionality to our class. This method confirms that the song exists in the collection, then removes the song using <code class="literal">remove()</code>, and finally returns <code class="literal">true</code>. If the song does not exist in the collection, the method returns <code class="literal">false</code>:</p><pre class="programlisting">    public func mergeWithPlaylist(playlist: Set&lt;Song&gt;) 
    { 
        _songs.unionInPlace(playlist) 
    } 
</pre><p class="calibre7">The <code class="literal">mergeWithPlaylist(playlist: Set&lt;Song&gt;)</code> method provides the <span class="strong"><em class="calibre20">union</em></span> functionality for our class. Luckily, <code class="literal">Set</code> exposes the union functionality with the <code class="literal">unionInPlace()</code> method, so our method simply calls it. In this case, <code class="literal">unionInPlace()</code> will merge the <code class="literal">playlist</code> parameter with our existing <code class="literal">_songs</code> list:</p><pre class="programlisting">    public func findSharedSongsInPlaylist(playlist: Set&lt;Song&gt;) -&gt; Set&lt;Song&gt; 
    { 
        return _songs.intersect(playlist) 
    } 
</pre><p class="calibre7">Next, the <code class="literal">findSharedSongsInplaylist(playlist: Set&lt;Song&gt;)</code> method provides <span class="strong"><em class="calibre20">intersection</em></span> functionality to our class. The <code class="literal">Set</code> class exposes the intersection functionality using the <code class="literal">intersect()</code> method. The <code class="literal">intersect()</code> method does not modify <code class="literal">_songs</code>, but only returns the results of the intersection between <code class="literal">_songs</code> and the <code class="literal">playlist</code> parameter, so we simply return the results of this method call:</p><pre class="programlisting">    public func findUniqueSongs(playlist: Set&lt;Song&gt;) -&gt; Set&lt;Song&gt; 
    { 
        return _songs.subtract(playlist) 
    } 
</pre><p class="calibre7">The <code class="literal">findUniqueSongs(playlist: Set&lt;Song&gt;)</code> method provides <span class="strong"><em class="calibre20">difference</em></span> functionality to our class. Once again, <code class="literal">Set</code> exposes the difference functionality using the <code class="literal">subtract()</code> method. The <code class="literal">subtract()</code> method does not modify <code class="literal">_songs</code>, but only returns the results of the difference between <code class="literal">_songs</code> and the <code class="literal">playlist</code> parameter, so we simply return the results of this method call:</p><pre class="programlisting">    public func isSubset(playlist: Set&lt;Song&gt;) -&gt; Bool 
    { 
        return _songs.isSubsetOf(playlist) 
    } 
 
    public func isSuperset(playlist: Set&lt;Song&gt;) -&gt; Bool 
    { 
        return _songs.isSupersetOf(playlist) 
    } 
</pre><p class="calibre7">The <code class="literal">isSubset(playlist: Set&lt;Song&gt;)</code> and <code class="literal">isSuperset(playlist: Set&lt;Song&gt;)</code> methods provide the functionalities by their names. These methods utilize the <code class="literal">isSubSetOf()</code> and <code class="literal">isSuperSetOf()</code> methods, respectively, and return a Boolean value representing the result of those comparisons:</p><pre class="programlisting">    public func totalSongs() -&gt; Int 
    { 
        return _songs.count; 
    } 
</pre><p class="calibre7">Finally, the <code class="literal">totalSongs()</code> method returns the number of elements found in the <code class="literal">_songs</code> set, providing <span class="strong"><em class="calibre20">count</em></span> functionality to our collection.
</p></div>

<div class="book" title="Advanced topics" id="1AT9A1-77f2b5b248f04368a6f723b0e9357ef3"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec37" class="calibre1"/>Advanced topics</h1></div></div></div><p class="calibre7">Now that we have examined how sets are used in common applications, we should take some time to examine how they are implemented under the hood. The majority of sets come in three varieties: hash table-based sets, tree-based sets, and array-based sets.</p></div>

<div class="book" title="Advanced topics" id="1AT9A1-77f2b5b248f04368a6f723b0e9357ef3">
<div class="book" title="Hash table-based sets"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_1"><a id="ch07lvl2sec38" class="calibre1"/>Hash table-based sets</h2></div></div></div><p class="calibre7">Hash table-based sets are typically used for unordered collections of data. As such, the majority of sets you will encounter for non-specialized applications will be hash table-based. Hash table-based sets share similar operational costs with dictionaries. For example, search, insert, and delete operations all have an operational cost of <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">n</em></span>).</p></div></div>

<div class="book" title="Advanced topics" id="1AT9A1-77f2b5b248f04368a6f723b0e9357ef3">
<div class="book" title="Tree-based sets"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_2"><a id="ch07lvl2sec39" class="calibre1"/>Tree-based sets</h2></div></div></div><p class="calibre7">Tree-based sets are typically based on binary search trees, but they sometimes can be based on other structures. Due to their design, the binary search tree allows for very efficient search functions on average, as each node that is examined can allow for branches of the tree to be discarded from the remaining search pattern. Although the worst case scenario for searching a binary search tree has an <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">n</em></span>) operational cost, in practice this is rarely required.</p></div></div>

<div class="book" title="Advanced topics" id="1AT9A1-77f2b5b248f04368a6f723b0e9357ef3">
<div class="book" title="Array-based sets"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_3"><a id="ch07lvl2sec40" class="calibre1"/>Array-based sets</h2></div></div></div><p class="calibre7">Arrays can be used to implement subsets of sets, making union, intersection, and difference operations much more efficient in properly organized array-based sets.
</p></div></div>
<div class="book" title="Summary" id="1BRPS1-77f2b5b248f04368a6f723b0e9357ef3"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec38" class="calibre1"/>Summary</h1></div></div></div><p class="calibre7">In this chapter, you learned the basic definition of the set data structure. In order to fully appreciate the functionality of the structure, we briefly examined the most basic principles of set theory upon which the set data structure is based. Following this, we looked at the most common operations of sets and how they relate to the set theory functions. We then looked at how to implement a set in each of the four languages we're studying in this text. Next, we revisited the users logged into a service problem one more time to see if we could improve upon its implementation at all using a set data structure as opposed to an array or list. Following this, we examined a case study where sets would be beneficial. Finally, we looked at the varying implementations of sets, including hash table-based sets, tree-based sets, and array-based sets.</p></div></body></html>