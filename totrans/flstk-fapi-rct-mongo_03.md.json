["```py\npip install pydantic==2.7.1 pydantic_settings==2.2.1\n```", "```py\n>>>{}+3\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: unsupported operand type(s) for +: 'dict' and 'int'\n```", "```py\nmypy==1.10.0\npydantic==2.7.4\n```", "```py\npip install -r requirements.txt\n```", "```py\n    def print_name_x_times(name: str, times: int) -> None:\n        for _ in range(times):\n            print(name)\n    ```", "```py\n    mypy chapter3_01.py\n    ```", "```py\n    types_testing.py:8: error: Argument 1 to \"print_name_x_times\" has incompatible type \"int\"; expected \"str\"  [arg-type]\n    types_testing.py:8: error: Argument 2 to \"print_name_x_times\" has incompatible type \"str\"; expected \"int\"  [arg-type]\n    Found 2 errors in 1 file (checked 1 source file)\n    ```", "```py\n    text: str = \"John\"\n    ```", "```py\n    def count_users(users: list[str]) -> int:\n        return len(users)\n    ```", "```py\n    from typing import Union\n    x: Union(str, int)\n    ```", "```py\n    x: str | int\n    ```", "```py\nfrom typing import List\ndef square_numbers(numbers: List[int]) -> List[int]:\n    return [number ** 2 for number in numbers]\n# Example usage\ninput_numbers = [1, 2, 3, 4, 5]\nsquared_numbers = square_numbers(input_numbers)\nprint(squared_numbers)  # Output: [1, 4, 9, 16, 25]\n```", "```py\nfrom typing import Literal\naccount_type: Literal[\"personal\", \"business\"]\naccount_type = \"name\"\n```", "```py\nfrom datetime import datetime\ndef format_datetime(dt: datetime) -> str:\n     return dt.strftime(\"%Y-%m-%d %H:%M:%S\")\nnow = datetime.now()\nprint(format_datetime(now))\n```", "```py\ndef get_users(id: int) -> list[dict]:\n    return [\n        {\"id\": 1, \"name\": \"Alice\"},\n        {\"id\": 2, \"name\": \"Bob\"},\n        {\"id\": 3, \"name\": \"Charlie\"},\n    ]\n```", "```py\nfrom datetime import datetime\nfrom pydantic import BaseModel\nclass User(BaseModel):\n    id: int\n    username: str\n    email: str\n    dob: datetime\n```", "```py\nPu = User(id=1, username=\"freethrow\", email=\"email@gmail.com\", dob=datetime(1975, 5, 13))\n```", "```py\nfrom pydantic import BaseModel, ValidationError\ntry:\n    u = User(\n        id=\"one\",\n        username=\"freethrow\",\n        email=\"email@gmail.com\",\n        dob=datetime(1975, 5, 13),\n    )\n    print(u)\nexcept ValidationError as e:\n    print(e)\n```", "```py\n1 validation error for User\nid\n  Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='one', input_type=str]\n```", "```py\nclass User(BaseModel):\n    id: int = 2\n    username: str\n    email: str\n    dob: datetime\n    fav_colors: list[str] | None = [\"red\", \"blue\"]\n```", "```py\nid=2 username='marko' email='email@gmail.com' dob=datetime.datetime(1975, 5, 13, 0, 0) fav_colors=None\n```", "```py\nclass User(BaseModel):\n    id: int\n    username: str\n    email: str\n    password: str\nuser = User.model_validate(\n    {\n        \"id\": 1,\n        \"username\": \"freethrow\",\n        \"email\": \"email@gmail.com\",\n        \"password\": \"somesecret\",\n    }\n)\nprint(user)\n```", "```py\n    from pydantic import BaseModel\n    from typing import Literal\n    class UserModel(BaseModel):\n        id: int\n        username: str\n        email: str\n        account: Literal[\"personal\", \"business\"] | None = None\n        nickname: str | None = None\n    ```", "```py\n    print(UserModel.model_fields)\n    ```", "```py\n    {'id': FieldInfo(annotation=int, required=True), 'username': FieldInfo(annotation=str, required=True), 'email': FieldInfo(annotation=str, required=True), 'account': FieldInfo(annotation=Union[Literal['personal', 'business'], NoneType], required=False, default=None), 'nickname': FieldInfo(annotation=Union[str, NoneType], required=False, default=None)}\n    ```", "```py\npip install pydantic[email]\n```", "```py\nfrom typing import Literal\nfrom pydantic import BaseModel, Field\nclass UserModelFields(BaseModel):\n    id: int = Field(…)\n    username: str = Field(…)\n    email: str = Field(…)\n    account: Literal[\"personal\", \"business\"] | None = Field(default=None)\n    nickname: str | None = Field(default=None)\n```", "```py\nexternal_api_data = {\n    \"user_id\": 234,\n    \"name\": \"Marko\",\n    \"email\": \"email@gmail.com\",\n    \"account_type\": \"personal\",\n    \"nick\": \"freethrow\",\n}\n```", "```py\nclass UserModelFields(BaseModel):\n    id: int = Field(alias=\"user_id\")\n    username: str = Field(alias=\"name\")\n    email: str = Field()\n    account: Literal[\"personal\", \"business\"] | None = Field(\n        default=None, alias=\"account_type\"\n    )\n    nickname: str | None = Field(default=None, alias=\"nick\")\n```", "```py\nuser = UserModelFields.model_validate(external_api_data)\n```", "```py\nfrom datetime import datetime\nfrom uuid import uuid4\nfrom pydantic import BaseModel, Field\nclass ChessTournament(BaseModel):\n    id: int = Field(strict=True)\n    dt: datetime = Field(default_factory=datetime.now)\n    name: str = Field(min_length=10, max_length=30)\n    num_players: int = Field(ge=4, le=16, multiple_of=2)\n    code: str = Field(default_factory=uuid4)\n```", "```py\nemail_validator==2.1.1\n```", "```py\npip install -r requirements.txt\nclass UserModel(BaseModel):\n    id: int = Field()\n    username: str = Field(min_length=5, max_length=20)\n    email: EmailStr = Field()\n    password: str = Field(min_length=5, max_length=20, pattern=\"^[a-zA-Z0-9]+$\")\n```", "```py\n    u = UserModel(\n        id=1,\n        username=\"freethrow\",\n        email=\"email@gmail.com\",\n        password=\"password123\",\n    )\n    print(u.model_dump())\n    ```", "```py\n    {'id': 1, 'username': 'freethrow', 'email': 'email@gmail.com', 'password': 'password123'}\n    ```", "```py\n    print(u.model_dump_json(exclude=set(\"password\"))\n    ```", "```py\n    {\"id\":1,\"username\":\"freethrow\",\"email\":\"email@gmail.com\"}\n    ```", "```py\nfrom pydantic import BaseModel, Field, ConfigDict, EmailStr\nclass UserModel(BaseModel):\n    id: int = Field()\n    username: str = Field(min_length=5, max_length=20, alias=\"name\")\n    email: EmailStr = Field()\n    password: str = Field(min_length=5, max_length=20, pattern=\"^[a-zA-Z0-9]+$\")\n    model_config = ConfigDict(extra=\"forbid\", populate_by_name=True)\n```", "```py\n    from datetime import datetime\n    from pydantic import BaseModel, field_serializer\n    class Account(BaseModel):\n        balance: float\n        updated: datetime\n        @field_serializer(\"balance\", when_used=\"always\")\n        def serialize_balance(self, value: float) -> float:\n            return round(value, 2)\n        @field_serializer(\"updated\", when_used=\"json\")\n        def serialize_updated(self, value: datetime) -> str:\n           return value.isoformat()\n    ```", "```py\n    account_data = {\n        \"balance\": 123.45545,\n        \"updated\": datetime.now(),\n    }\n    account = Account.model_validate(account_data)\n    print(\"Python dictionary:\", account.model_dump())\n    print(\"JSON:\", account.model_dump_json())\n    ```", "```py\n    Python dictionary: {'balance': 123.46, 'updated': datetime.datetime(2024, 5, 2, 21, 34, 11, 917378)}\n    JSON: {\"balance\":123.46,\"updated\":\"2024-05-02T21:34:11.917378\"}\n    ```", "```py\nfrom pydantic import BaseModel,  field_validator\nclass Article(BaseModel):\n    id: int\n    title: str\n    content: str\n    published: bool\n    @field_validator(\"title\")\n    @classmethod\n    def check_title(cls, v: str) -> str:\n        if \"FARM stack\" not in v:\n            raise ValueError('Title must contain \"FARM stack\"')\n        return v.title()\n```", "```py\n    from pydantic import BaseModel, EmailStr, ValidationError, model_validator\n    from typing import Any, Self\n    class UserModelV(BaseModel):\n        id: int\n        username: str\n        email: EmailStr\n        password1: str\n        password2: str\n    ```", "```py\n    @model_validator(mode='after')\n    def check_passwords_match(self) -> Self:\n        pw1 = self.password1\n        pw2 = self.password2\n        if pw1 is not None and pw2 is not None and pw1 != pw2:\n            raise ValueError('passwords do not match')\n        return self\n    @model_validator(mode='before')\n    @classmethod\n    def check_private_data(cls, data: Any) -> Any:\n        if isinstance(data, dict):\n            assert (\n                'private_data' not in data\n            ), 'Private data should not be included'\n        return data\n    ```", "```py\n    usr_data = {\n        \"id\": 1,\n        \"username\": \"freethrow\",\n        \"email\": \"email@gmail.com\",\n        \"password1\": \"password123\",\n        \"password2\": \"password456\",\n        \"private_data\": \"some private data\",\n    }\n    try:\n        user = UserModelV.model_validate(usr_data)\n        print(user)\n    except ValidationError as e:\n        print(e)\n    ```", "```py\n    Value error, passwords do not match [type=value_error, input_value={'id': 1, 'username': 'fr...ssword2': 'password456'}, input_type=dict]\n    ```", "```py\n    car_data = {\n        \"brand\": \"Ford\",\n        \"models\": [\n            {\"model\": \"Mustang\", \"year\": 1964},\n            {\"model\": \"Focus\", \"year\": 1975},\n            {\"model\": \"Explorer\", \"year\": 1999},\n        ],\n        \"country\": \"USA\",\n    }\n    ```", "```py\n    class CarModel(BaseModel):\n        model: str\n        year: int\n    ```", "```py\n    class CarBrand(BaseModel):\n        brand: str\n        models: List[CarModel]\n        country: str\n    ```", "```py\n    pip install pydantic-settings\n    ```", "```py\n    API_URL=https://api.com/v2\n    SECRET_KEY=s3cretstr1n6\n    ```", "```py\n    from pydantic import Field\n    from pydantic_settings import BaseSettings\n    class Settings(BaseSettings):\n        api_url: str = Field(default=\"\")\n        secret_key: str = Field(default=\"\")\n        class Config:\n            env_file = \".env\"\n    print(Settings().model_dump())\n    ```", "```py\n    {'api_url': 'https://api.com/v2', 'secret_key': 's3cretstr1n6'}\n    ```", "```py\n    os.environ[\"API_URL\"] = 'http://localhost:8000'\n    ```"]