<html><head></head><body>
		<div><div></div>
		</div>
		<div><h1 id="_idParaDest-283"><a id="_idTextAnchor298"/>10. Advanced Django Admin and Customizations</h1>
		</div>
		<div><p class="callout-heading">Overview</p>
			<p class="callout">This chapter introduces you to advanced customizations to the <strong class="bold">Django Admin</strong> site so that you can tailor the appearance of the Django Admin dashboard to make it blend with the rest of your web project. You will see how new features and capabilities can be added to your web project's Django admin interface to make it substantially more powerful and useful for your project's goals. These customizations are driven by the addition of custom templates that help modify the look and feel of existing pages. These custom templates also add new views that can help extend the default functionalities of the Admin dashboard. Completing this chapter will equip you with skills that not only let you customize the interface, but also the functionality of your project's Django-based admin page.</p>
			<h1 id="_idParaDest-284"><a id="_idTextAnchor299"/>Introduction</h1>
			<p>Let's say we want to customize the front page of a large organization's admin site. We want to show the health of the different systems in the organization and see any high-priority alerts that are active. If this were an internal website built on top of Django, we would need to customize it. Adding these kinds of functionalities will require the developers in the IT team to customize the default admin panel and create their own custom <code>AdminSite</code> module, which will render a different index page in comparison to what is provided by the default admin site. Fortunately, Django makes these kinds of customizations easy. </p>
			<p>In this chapter, we will look at how we can leverage Django's framework and its extensibility to customize Django's default admin interface (as shown in <em class="italic">Figure 10.1</em>). We'll not just learn how to make the interface more personal; we will also learn how we can control the different aspects of the admin site to make Django load a custom admin site instead of the one that ships with the default framework. Such customization can come in handy when we want to introduce features into the admin site that are not present by default.</p>
			<div><div><img src="img/B15509_10_01.jpg" alt="Figure 10.1: Default Django administration panel interface&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.1: Default Django administration panel interface</p>
			<p>This chapter builds upon the skills we practiced in <em class="italic">Chapter 4</em>, <em class="italic">Introduction to Django Admin</em>. Just to recap, we learned how to use the Django admin site to take control of the administration and authorization for our Bookr app. We also learned how to register models to read and edit their contents and also to customize Django's admin interface using the <code>admin.site</code> properties. Now, let's expand our knowledge further by taking a look at how we can start customizing the admin site by utilizing Django's <code>AdminSite</code> module to add powerful new functionalities to the admin portal of our web application.</p>
			<h1 id="_idParaDest-285"><a id="_idTextAnchor300"/>Customizing the Admin Site</h1>
			<p>Django as a web framework provides a lot of customization options for building web applications. We will be using this same freedom provided by Django when we are working on building the admin application for our project.</p>
			<p>In <em class="italic">Chapter 4</em>, <em class="italic">Introduction to Django Admin</em>, we looked at how we can use the <code>admin.site</code> properties to customize the elements of our Django's admin interface. But what if we require more control over how our admin site behaves? For example, let's say we wanted to use a custom template for the login page (or the logout page) to show to users whenever they visited the Bookr admin panel. In this case, the <code>admin.site</code> properties provided might not be enough, and we will need to build customizations that can extend the default admin site's behavior. Luckily, this can be easily achieved by extending the <code>AdminSite</code> class from Django's admin model. But before we jump into building our admin site, let's first understand how Django discovers admin files and how we can use this admin file discovery mechanism to build a new app inside Django that will act as our admin site app.</p>
			<h2 id="_idParaDest-286"><a id="_idTextAnchor301"/>Discovering Admin Files in Django</h2>
			<p>When we build applications in our Django project, we use the <code>admin.py</code> file frequently to register our models or create <code>ModelAdmin</code> classes that customize our interactions with the models inside the admin interface. These <code>admin.py</code> files store and provide this information to our project's admin interface. The discovery of these files is affected automatically by Django once we add <code>django.contrib.admin</code> to our <code>INSTALLED_APPS</code> section inside our <code>settings.py</code> file:</p>
			<div><div><img src="img/B15509_10_02.jpg" alt="Figure 10.2: Bookr application structure&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.2: Bookr application structure</p>
			<p>As we can see in the preceding figure, we have an <code>admin.py</code> file under the <code>reviews</code> application directory that is used by Django to customize the admin site for Bookr.</p>
			<p>When the admin application gets added, it tries to find the <code>admin</code> module inside every app of the Django project we are working on and, if a module is found, it loads the contents from that module.</p>
			<h2 id="_idParaDest-287"><a id="_idTextAnchor302"/>Django's AdminSite Class</h2>
			<p>Before we start customizing Django's admin site, we must understand how the default admin site is generated and handled by Django.</p>
			<p>To provide us with the default admin site, Django packages a module known as the <code>admin</code> module, which holds a class known as <code>AdminSite</code>. This class implements a lot of useful functionalities and intelligent defaults that the Django community thinks will be important for implementing a useful administration panel for most Django websites. The default <code>AdminSite</code> class provides a lot of inbuilt properties that not only control the look and feel of how the default admin site is rendered in the web browser, but also control the way we can interact with it and how a particular interaction will result in an action. Some of these defaults include the site template properties, such as text to be shown in the site header, text to show in the title bar of the web browser, integration with Django's <code>auth</code> module for authenticating to the admin site, and a host of other properties.</p>
			<p>As we progress on our path to building a custom admin site for our Django web project, it is more than desirable to retain a lot of the useful functionalities that are already built into Django's <code>AdminSite</code> class. This is where the concepts of Python object-oriented programming come to our rescue.</p>
			<p>As we start to create our custom admin site, we will try to leverage the existing useful set of functionalities that are provided by Django's default <code>AdminSite</code> class. For this, instead of building everything from scratch, we will work on creating a new child class that inherits from Django's <code>AdminSite</code> class to leverage the existing set of functionalities and useful integration that Django already provides us with. This kind of approach allows us to focus on adding a new and useful set of functionalities to our custom admin site, rather than spending time on implementing the basic set of functionalities from scratch. For example, the following code snippet shows how we can create a child class of Django's <code>AdminSite</code> class:</p>
			<pre>class MyAdminSite(admin.AdminSite):
    …</pre>
			<p>To start working on our custom admin site for our web application, let's start by overriding some of the basic properties of Django's admin panel through the use of the custom <code>AdminSite</code> class we are going to work on.</p>
			<p>Some of the properties that can be overridden include <code>site_header</code>, <code>site_title</code>, and others.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">When creating a custom admin site, we will have to register once again any <code>Model</code> and <code>ModelAdmin</code> classes that we might have registered using the default <code>admin.site</code> variable earlier. This happens because a custom admin site doesn't inherit the instance details from the default admin site provided by Django and so unless we re-register our <code>Model</code> and <code>ModelAdmin</code> interfaces, our custom admin site will not show them. </p>
			<p>Now, with the knowledge of how Django discovers what to load into the admin interface and how we can start building our custom admin site, let's go ahead and try to create our custom admin app for Bookr, which extends the existing <code>admin</code> module provided by Django. In the exercise that follows, we are going to create a custom admin site interface for our Bookr application using Django's <code>AdminSite</code> class.</p>
			<h2 id="_idParaDest-288"><a id="_idTextAnchor303"/>Exercise 10.01: Creating a Custom Admin Site for Bookr</h2>
			<p>In this exercise, you will create a new application that extends the default Django admin site and allows you to customize the components of the interface. Consequently, you will customize the default title of Django's admin panel. Once that is done, you will override the default value of Django's <code>admin.site</code> property to point to your custom admin site:</p>
			<ol>
				<li>Before you can start working on your custom admin site, you first need to make sure that you are in the correct directory in your project from where you can run your Django application's management commands. For this, use the Terminal or Windows Command Prompt to navigate to the <code>bookr</code> directory and then create a new application named <code>bookr_admin</code>, which is going to act as the admin site for Bookr, by running the following commands:<pre>python3 manage.py startapp bookr_admin</pre><p>Once this command is executed successfully, you should have a new directory named <code>bookr_admin</code> inside your project. </p></li>
				<li>Now, with the default structure configured, the next step is to create a new class named <code>BookrAdmin</code>, which will extend the <code>AdminSite</code> class provided by Django to inherit the properties of the default admin site. To do this, open the <code>admin.py</code> file under the <code>bookr_admin</code> directory inside PyCharm. Once the file is open, you will see that the file already has the following code snippet present inside it: <pre>from django.contrib import admin</pre><p>Now, keeping this <code>import</code> statement as is, starting from the next line, create a new class named <code>BookrAdmin</code>, which inherits from the <code>AdminSite</code> class provided by the <code>admin</code> module you imported earlier:</p><pre>class BookrAdmin(admin.AdminSite):</pre><p>Inside this new <code>BookrAdmin</code> class, override the default value for the <code>site_header</code> variable, which is responsible for rendering the site header in Django's admin panel by setting the <code>site_header</code> property, as shown next:</p><pre>    site_header = "Bookr Administration"</pre><p>With this, the custom admin site class is now defined. To use this class, you will first create an instance of this class. This can be done as follows:</p><pre>admin_site = BookrAdmin(name='bookr_admin')</pre></li>
				<li>Save the file but don't close it yet; we'll revisit it in <em class="italic">step 6</em>. Next, let's edit the <code>urls.py</code> file in the <code>bookr</code> app. </li>
				<li>With the custom class now defined, the next step is to modify the <code>urlpatterns</code> list to map the <code>/admin</code> endpoint in our project to the new <code>AdminSite</code> class you created. To do this, open the <code>urls.py</code> file under the <code>Bookr</code> project directory inside PyCharm and change the mapping of the <code>/admin</code> endpoint to point to our custom site:<pre><code>admin_site</code> object from the admin module of the <code>bookr_admin</code> app. Then, we used the <code>urls</code> property of the object to map to the <code>admin</code> endpoint in our application as follows:</p><pre>path('admin/', admin_site.urls)</pre><p>In this case, the <code>urls</code> property of our <code>admin_site</code> object is being automatically populated by the <code>admin.AdminSite</code> base class provided by Django's <code>admin</code> module. Once complete, your <code>urls.py</code> file should look like this: <a href="http://packt.live/3qjx46J">http://packt.live/3qjx46J</a>.</p></li>
				<li>Now, with the configuration done, let's run our admin app in the browser. For this, run the following command from the root of your project directory where the <code>manage.py</code> file is located:<pre>python manage.py runserver localhost:8000</pre><p>Then, navigate to <code>http://localhost:8000/admin</code> (or <code>http://127.0.0.1:8000/admin</code>), which opens a page that resembles the following screenshot:</p><div><img src="img/B15509_10_03.jpg" alt="Figure 10.3: Home page view for the custom Bookr admin site&#13;&#10;"/></div><p class="figure-caption">Figure 10.3: Home page view for the custom Bookr admin site</p><p>In the preceding screenshot (<em class="italic">Figure 10.3</em>), you will see that Django displays the message, <code>You don't have permission to view or edit anything</code>. The issue of not having adequate permissions happens because, up till now, we have not registered any models with our custom <code>AdminSite</code> instance. The issue also applies to the <code>User and Groups</code> models that are shipped along with the Django <code>auth</code> module. So, let's make our custom admin site a bit more useful by registering the <code>User</code> model from Django's <code>auth</code> module.</p></li>
				<li>To register the <code>User</code> model from Django's <code>auth</code> module, open the <code>admin.py</code> file under the <code>bookr_admin</code> directory inside PyCharm, and add the following line at the top of the file:<pre>from django.contrib.auth.admin import User</pre><p>At the end of the file, use your <code>BookrAdmin</code> instance to register this model as follows:</p><pre>admin_site.register(User)</pre><p>By now, your <code>admin.py</code> file should look like this:</p><pre>from django.contrib import admin
from django.contrib.auth.admin import User
class BookrAdmin(admin.AdminSite):
    site_header = "Bookr Administration"
admin_site = BookrAdmin(name='bookr_admin')
admin_site.register(User)</pre><p>Once this is done, reload the web server and visit <code>http://localhost:8000/admin</code>. Now, you should be able to see the <code>User</code> model being displayed for editing inside the admin interface, as shown here:</p><div><img src="img/B15509_10_04.jpg" alt="Figure 10.4: Home page view showing our registered models &#13;&#10;on the Bookr Administration site&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 10.4: Home page view showing our registered models on the Bookr Administration site</p>
			<p>With this, we just created our admin site application, and we can also now validate the fact that the custom site has a different header—<code>Bookr Administration</code>.</p>
			<h2 id="_idParaDest-289"><a id="_idTextAnchor304"/>Overriding the Default admin.site</h2>
			<p>In the previous section, after we created our own <code>AdminSite</code> application, we saw that we had to register models manually. This happens because most of the apps that we have built prior to our custom admin site still use the <code>admin.site</code> property to register their models and, if we want to use our <code>AdminSite</code> instance, we will have to update all those applications to use our instance, which can become cumbersome if there are a lot of applications inside a project.</p>
			<p>Luckily, we can avoid this additional burden by overriding the default <code>admin.site</code> property. To do this, we first have to create a new <code>AdminConfig</code> class, which will override the default <code>admin.site</code> property for us, so that our application is marked as the default admin site and hence overrides the <code>admin.site</code> property inside our project. In the next exercise, we'll look at how we can map our custom admin site as a default admin site for an application.</p>
			<h2 id="_idParaDest-290"><a id="_idTextAnchor305"/>Exercise 10.02: Overriding the Default Admin Site</h2>
			<p>In this exercise, you will use the <code>AdminConfig</code> class to override the default admin site for your project such that you can keep on using the default <code>admin.site</code> variable to register models, override site properties, and more:</p>
			<ol>
				<li value="1">Open the <code>admin.py</code> file under the <code>bookr_admin</code> directory and remove the import for the <code>User</code> model and the <code>BookrAdmin</code> instance creation, which you wrote in <em class="italic">step 6</em> of <em class="italic">Exercise 10.01</em>, <em class="italic">Creating a Custom Admin Site for Bookr</em>. Once this is done, the file contents should resemble the following:<pre>from django.contrib import admin
class BookrAdmin(admin.AdminSite):
    site_header = "Bookr Administration"</pre></li>
				<li>You will then need to create an <code>AdminConfig</code> class for the custom admin site, such that Django recognizes the <code>BookrAdmin</code> class as an <code>AdminSite</code> and overrides the <code>admin.site</code> property. To do this, open up the <code>apps.py</code> file inside the <code>bookr_admin</code> directory and overwrite the contents of the file with the contents shown here:<pre>from django.contrib.admin.apps import AdminConfig
class BookrAdminConfig(AdminConfig):
    default_site = 'bookr_admin.admin.BookrAdmin'</pre><p>In this, we first imported the <code>AdminConfig</code> class from Django's <code>admin</code> module. This class is used to define the application that should be used as a default admin site, and also to override the default behavior of the Django admin site.</p><p>For our use case, we created a class with the name <code>BookrAdminConfig</code>, which acts as a child class of Django's <code>AdminConfig</code> class and overrides the <code>default_site</code> property to point to our <code>BookrAdmin</code> class, which is our custom admin site:</p><pre>default_site = 'bookr_admin.admin.BookrAdmin'</pre><p>Once this is done, we need to set our application as an admin application inside our <code>Bookr</code> project. To achieve this, open the <code>settings.py</code> file of the <code>Bookr</code> project and, under the <code>INSTALLED_APPS</code> section, replace <code>'reviews.apps.ReviewsAdminConfig'</code> with <code>'bookr_admin.apps.BookrAdminConfig'</code>. The <code>settings.py</code> file should look like this: <a href="http://packt.live/3siv1lf">http://packt.live/3siv1lf</a>. </p></li>
				<li>With the application mapped as the admin application, the final step involves modifying the URL mapping such that the <code>'admin/'</code> endpoint uses the <code>admin.site</code> property to find the correct URL. For this, open the <code>urls.py</code> file under the bookr project. Consider the following entry in the <code>urlpatterns</code> list:<pre>path('admin/', admin<code>admin_site.urls</code> is a module, while <code>admin.site</code> is a Django internal property. </p><p>Once the preceding steps are complete, let's reload our web server and check whether our admin site loads by visiting <code>http://localhost:8000/admin</code>. If the website that loads looks like the one shown here, we have our own custom admin app now being used for the admin interface:</p><div><img src="img/B15509_10_05.jpg" alt="Figure 10.5: Home page view of the custom Bookr Administration site&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 10.5: Home page view of the custom Bookr Administration site</p>
			<p>As you can see, once we override <code>admin.site</code> with our admin app, the models that were registered earlier using the <code>admin.site.register</code> property start to show up automatically.</p>
			<p>With this, we now have a custom base template, which we can now utilize to build the remainder of our Django admin customizations on. As we work through the chapter, we will discover some interesting customizations that allow us to make the admin dashboard an integrated part of our application.</p>
			<h2 id="_idParaDest-291"><a id="_idTextAnchor306"/>Customizing Admin Site Text Using AdminSite Attributes</h2>
			<p>Just as we can use the <code>admin.site</code> properties to customize the text for our Django application, we can also use the attributes exposed by the <code>AdminSite</code> class to customize these texts. In <em class="italic">Exercise 10.02</em>, <em class="italic">Overriding the Default Admin Site</em>, we took a look at updating the <code>site_header</code> property of the admin site. Similarly, there are many other properties we can modify. Some of the properties that can be overridden are described as follows:</p>
			<ul>
				<li><code>site_header</code>: Text to display at the top of every admin page (defaults to <code>Django Administration</code>).</li>
				<li><code>site_title</code>: Text to display in the title bar of the browser (defaults to <code>Django Admin Site</code>).</li>
				<li><code>site_url</code>: The link to use for the <code>View Site</code> option (defaults to <code>/</code>). This is overridden when the site is running on a custom path and the redirection should take the user to the subpath directly.</li>
				<li><code>index_title</code>: This is the text that should be shown on the index page of the admin application (defaults to <code>Site administration</code>).<p class="callout-heading">Note</p><p class="callout">For more information on all the <code>adminsite</code> attributes, refer to the official Django documentation at <a href="https://docs.djangoproject.com/en/3.1/ref/contrib/admin/#adminsite-attributes">https://docs.djangoproject.com/en/3.1/ref/contrib/admin/#adminsite-attributes</a>.</p></li>
			</ul>
			<p>If we want to override these attributes in our custom admin site, the process is very simple:</p>
			<pre>class MyAdminSite(admin.AdminSite):
    site_header = "My web application"
    site_title = "My Django Web application"
    index_title = "Administration Panel"</pre>
			<p>As we have seen in the examples so far, we have created a custom admin application for Bookr and then made it the default admin site for our project. An interesting question arises here. Since the properties that we have customized so far can also be customized by using the <code>admin.site</code> object directly, why should we create a custom admin application? Can't we just modify the <code>admin.site</code> properties?</p>
			<p>As it turns out, there could be multiple reasons why someone would opt for a custom admin site; for example, they might want to change the layout of the default admin site to make it align with the overall layout of their application. This is quite common when creating a web application for a business where the homogeneity of the content is very important. Here is a short list of requirements that may compel a developer to go ahead and build a custom admin site as opposed to simply modifying the properties of the <code>admin.site</code> variable:</p>
			<ul>
				<li>A need to override the index template for the admin interface</li>
				<li>A need to override the login or logout template</li>
				<li>A need to add a custom view to the admin interface</li>
			</ul>
			<h2 id="_idParaDest-292"><a id="_idTextAnchor307"/>Customizing Admin Site Templates</h2>
			<p>Just like some of the customizable common texts, such as <code>site_header</code> and <code>site_title</code>, that appear across the admin site, Django also allows us to customize the templates, which are used to render different pages inside the admin site by setting certain properties in the <code>AdminSite</code> class.</p>
			<p>These customizations can include the modification of templates that are used to render the index page, login page, model data page, and more. These customizations can be easily done by leveraging the templating system provided by Django. For example, the following code snippet shows how we can add a new template to the Django admin dashboard:</p>
			<pre>{% extends "admin/base_site.html" %}
{% block content %}
  &lt;!-- Template Content --&gt;
{% endblock %}</pre>
			<p>In this custom template, there are a couple of important aspects that we need to understand.</p>
			<p>When customizing the existing Django admin dashboard by modifying how certain pages inside the dashboard appear or by adding a new set of pages to the dashboard, we might not want to write every single piece of HTML again from scratch to maintain the basic look and feel of the Django admin dashboard.</p>
			<p>Usually, while customizing the admin dashboard, we want to retain the layout in which Django organizes the different elements displayed on the dashboard such that we can focus on modifying parts of the page that matter to us. This basic layout of the page, along with the common page elements, such as the page header and page footer, are defined inside the Django admin's base template, which also acts as a master template for all the pages inside the default Django admin website.</p>
			<p>To retain the way the common elements inside the Django admin pages are organized and rendered, we need to extend from this base template such that our custom template pages provide a user experience consistent with the other pages inside the Django admin dashboard. This can be done by using the template extension tags and extending the <code>base_site.html</code> template from the <code>admin</code> module provided by Django:</p>
			<pre>{% extends "admin/base_site.html" %}</pre>
			<p>Once this is done, the next part is to define our own content for the custom template. The <code>base_site.html</code> template provided by Django provides a block-based placeholder for developers to add their own content to the template. To add this content, a developer has to put the logic for their own custom elements for the page inside the <code>{% block content %}</code> tags. This essentially overrides any content defined by the <code>{% block content %}</code> tag inside the <code>base_site.html</code> template, following the concepts of template inheritance in Django.</p>
			<p>Now, let's look at how we can customize the template, which is used to render the logout page, once the user clicks the Logout button in the admin panel.</p>
			<h2 id="_idParaDest-293"><a id="_idTextAnchor308"/>Exercise 10.03: Customizing the Logout Template for the Bookr Admin Site</h2>
			<p>In this exercise, you are going to customize the template that is used to render the logout page once the user clicks the <code>Logout</code> button on the admin site. Such overrides can come in handy in banking websites. Once a user clicks <code>Logout</code>, the bank might want to show the user a page with detailed instructions on how to make sure that their banking session is securely closed. </p>
			<ol>
				<li value="1">Under the <code>templates</code> directory which you must have created in the earlier chapters, create another directory named <code>admin</code> which will be used for storing templates for your custom admin site. <p class="callout-heading">Note</p><p class="callout">Before proceeding, make sure that the templates directory is added to the <code>DIRS</code> list in your <code>settings.py</code> file (under the <code>bookr/ project</code>).</p></li>
				<li>Now, with the directory structure setup complete, and Django configured to load the templates, the next step involves writing your custom logout template that you want to render. For this, let's create a new file named <code>logout.html</code> under the <code>templates/admin</code> directory we created in <em class="italic">step 1</em> and add the following content to it:<pre>{% extends "admin/base_site.html" %}
{% block content %}
&lt;p&gt;You have been logged out from the Admin panel. &lt;/p&gt;
&lt;p&gt;&lt;a href="{% url 'admin:index' %}"&gt;Login Again&lt;/a&gt; or   &lt;a href="{{ site_url }}"&gt;Go to Home Page&lt;/a&gt;&lt;/p&gt;
{% endblock %}</pre><p>In the preceding code snippet, we are doing a couple of things. First, for our custom logout template, we are going to use the same master layout as provided by the <code>django.contrib.admin</code> module. So, consider the following:</p><pre>{% extends "admin/base_site.html" %}</pre><p>When we write this, Django tries to find and load the <code>admin/base_site.html</code> template inside the <code>templates</code> directory provided by the <code>django.contrib.admin</code> module.</p><p>Now, with our base template all set to be extended, the next thing we do is try to override the HTML of the content block by executing the following command:</p><pre>{% block content %}
…
{% endblock %}</pre><p>The values of <code>admin:index</code> and <code>site_url</code> are provided by the <code>AdminSite</code> class automatically, based on the settings we define.</p><p>Using the value for <code>admin:index</code> and <code>site_url</code>, we create our <code>Login Again</code> hyperlink, which, when clicked, will take the user back to the login form, and the <code>Go</code> <code>to</code> <code>Home</code> <code>Page</code> link, which will take the user back to the home page of the website. The file should look like this now: <a href="http://packt.live/3oIGQPo">http://packt.live/3oIGQPo</a>.</p></li>
				<li>Now, with the custom template defined, the next step is to make use of this custom template in our custom admin site. To do this, let's open the <code>admin.py</code> file under the <code>bookr_admin</code> directory and add the following field as the final value in the <code>BookrAdmin</code> class:<pre>logout_template = 'admin/logout.html'</pre><p>Save the file. It should look like this: <a href="http://packt.live/3oHHsVz">http://packt.live/3oHHsVz</a>. </p></li>
				<li>Once all the preceding steps are complete, let's start our development server by running the following command:<pre>python manage.py runserver localhost:8000</pre><p>Then, we navigate to <code>http://localhost:8000/admin</code>.</p><p>Once you are there, try to do a login and then click <code>Logout</code>. Once you are logged out, you will see the following page rendered:</p><div><img src="img/B15509_10_06.jpg" alt="Figure 10.6: Logout view rendered to users after clicking the Logout button&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 10.6: Logout view rendered to users after clicking the Logout button</p>
			<p>With this, we have successfully overridden our first template. Similarly, we can also override other templates inside Django's admin panel, such as the templates for the index view and the login form.</p>
			<h1 id="_idParaDest-294"><a id="_idTextAnchor309"/>Adding Views to the Admin Site</h1>
			<p>Just like general applications inside Django, which can have multiple views associated with them, Django allows developers to add custom views to the admin site as well. This allows the developer to increase the scope of what the admin site interface can do.</p>
			<p>The ability to add your own views to the admin site provides a lot of extensibility to the admin panel of the website, which can be leveraged for several additional use cases. For example, as we discussed at the start of the chapter, an IT team of a big organization can add a custom view to the admin site, which can then be used to both monitor the health of the different IT systems in the organization and to provide the IT team with the ability to quickly look at any urgent alerts that need to be addressed.</p>
			<p>Now, the next question we need to answer is: <em class="italic">How can we add a custom view to the admin site?</em></p>
			<p>As it turns out, adding a new view inside the admin template is quite easy and follows the same approach we used while creating views for our applications, though with some minor modifications. In the next section, we will look at how we can add a new view to our Django admin dashboard.</p>
			<h2 id="_idParaDest-295"><a id="_idTextAnchor310"/>Creating the View Function</h2>
			<p>The first step to adding a new view to the Django application is to create a view function that implements the logic to handle the view. In the previous chapters, we created the view functions inside a separate file known as <code>views.py</code>, which was used to hold all our method- and class-based views.</p>
			<p>When it comes to adding a new view to the Django admin dashboard, to create a new view, we need to define a new view function inside our custom <code>AdminSite</code> class. For example, to add a new view that renders a page showing the health of the different IT systems inside the organization, we can create a new view function named <code>system_health_dashboard()</code> inside our custom <code>AdminSite</code> class implementation, as shown in the following code snippet:</p>
			<pre>class SysAdminSite(admin.AdminSite):
    def system_health_dashboard(self, request):
        # View function logic</pre>
			<p>Inside the view function, we can perform any operations we want in order to generate a view and finally use that response to render a template. Inside this view function, there are some important pieces of logic we need to make sure are implemented correctly.</p>
			<p>The first one is to set the <code>current_app</code> property for the <code>request</code> field inside the view function. This is required in order to allow Django's URL resolver inside the templates to correctly resolve the view functions for an application. To set this value inside the custom view function we just created, we need to set the <code>current_app</code> property as shown in the following code snippet:</p>
			<pre>request.current_app = self.name</pre>
			<p>The <code>self.name</code> field is automatically populated by Django's <code>AdminSite</code> class and we don't need to initialize it explicitly. With this, our minimal custom view implementation will appear as shown in the following code snippet:</p>
			<pre>class SysAdminSite(admin.AdminSite):
    def system_health_dashboard(self, request):
        request.current_app = self.name
        # View function logic</pre>
			<h2 id="_idParaDest-296"><a id="_idTextAnchor311"/>Accessing Common Template Variables</h2>
			<p>When creating a custom view function, we might want access to the common template variables, such as <code>site_header</code> and <code>site_title</code>, in order to render them correctly in the template associated with our view function. As it turns out, this is quite easy to achieve with the use of the <code>each_context()</code> method provided by the <code>AdminSite</code> class.</p>
			<p>The <code>each_context()</code> method of the <code>AdminSite</code> class takes a single parameter, <code>request</code>, which is the current request context, and returns the template variables that are to be inserted in all the admin site templates.</p>
			<p>For example, if we wanted to access the template variables inside our custom view function, we could implement code similar to the following code snippet:</p>
			<pre>def system_health_dashboard(self, request):
    request.current_app = self.name
    context = self.each_context(request)
    # view function logic</pre>
			<p>The value returned by the <code>each_context()</code> method is a dictionary containing the name of the variable and the associated value.</p>
			<h2 id="_idParaDest-297"><a id="_idTextAnchor312"/>Mapping URLs for the Custom View</h2>
			<p>Once the view function is defined, the next step involves mapping this view function to a URL such that a user can access it or allow the other views to link to it. For the views defined inside <code>AdminSite</code>, this URL mapping to views is controlled by the <code>get_urls()</code> method implemented by the <code>AdminSite</code> class. The <code>get_urls()</code> method returns the <code>urlpatterns</code> list that maps to the <code>AdminSite</code> views.</p>
			<p>If we would like to add a URL mapping for our custom view, the preferred approach includes overriding the implementation of <code>get_urls()</code> in our custom <code>AdminSite</code> class and adding the URL mapping there. This approach is demonstrated in the following code snippet:</p>
			<pre>class SysAdminSite(admin.AdminSite):
    def get_urls(self):
        base_urls = super().get_urls(). # Get the existing set of URLs
        # Define our URL patterns for custom views
        urlpatterns = [path("health_dashboard/"),\
                           (self.system_health_dashboard)]
        # Return the updated mapping
        return base_urls + urlpatterns. </pre>
			<p>The <code>get_urls()</code> method is generally called automatically by Django and there is no need to perform any manual processing on it.</p>
			<p>Once this is done, the last step involves making sure that our custom admin view is only accessible through the admin site and non-admin users should not be able to access it. Let's take a look at how that can be achieved.</p>
			<h2 id="_idParaDest-298"><a id="_idTextAnchor313"/>Restricting Custom Views to the Admin Site</h2>
			<p>If you followed all the previous sections thoroughly, you would now have a custom <code>AdminSite</code> view ready for use. However, there is a small glitch. This view is also directly accessible to any user who is not on the admin site.</p>
			<p>To ensure that such a situation does not arise, we need to restrict this view to the admin site. This can be achieved quite simply by wrapping our URL path inside the <code>admin_view()</code> call, as shown in the following code snippet:</p>
			<pre>urlpatterns = [self.admin_view\
               (path("health_dashboard/"),\
               (self.system_health_dashboard))]</pre>
			<p>The <code>admin_view</code> function makes sure the path provided to it is restricted just to the admin dashboard and that no non-admin-privilege user can access it.</p>
			<p>Now, let's add a new custom view to our admin site.</p>
			<h2 id="_idParaDest-299"><a id="_idTextAnchor314"/>Exercise 10.04: Adding Custom Views to the Admin Site</h2>
			<p>In this exercise, you will add a custom view to the admin site, which will render a user profile and will show the user the options to modify their email or add a new profile picture. To build this custom view, follow the steps described:</p>
			<ol>
				<li value="1">Open the <code>admin.py</code> file under the <code>bookr_admin</code> directory and add the following imports. These will be required to build our custom view inside the admin site application:<pre>from django.template.response import TemplateResponse
from django.urls import path</pre></li>
				<li>Open the <code>admin.py</code> file under the <code>bookr_admin</code> directory and create a new method named <code>profile_view</code>, which takes in a <code>request</code> variable as its parameter, inside the <code>BookrAdmin</code> class:<pre>def profile_view(self, request):</pre><p>Next, inside the method, get the name of the current application and set that in the <code>request</code> context. For this, you can use the <code>name</code> property of the class, which is auto-populated by Django. To get this property and set it in your <code>request</code> context, you need to add the following line:</p><pre>request.current_app = self.name</pre><p>Once you have the application name populated to the request context, the next step is to fetch the template variables, which are required to render the contents, such as <code>site_title</code>, <code>site_header</code>, and more, in the admin templates. For this, leverage the <code>each_context()</code> method of the <code>AdminSite</code> class, which provides the dictionary of the admin site template variables from the class:</p><pre>context = self.each_context(request)</pre><p>Once you have the data in place, the last step is to return a <code>TemplateResponse</code> object, which will render the custom profile template when someone visits the URL endpoint mapped to your custom view:</p><pre>return TemplateResponse(request, "admin/admin_profile.html", \
                        context)</pre></li>
				<li>With the view function now created, the next step is to make <code>AdminSite</code> return the URLs mapping the view to a path inside <code>AdminSite</code>. To do this, you need to create a new method with the name <code>get_urls()</code>, which overrides the <code>AdminSite.get_urls()</code> method and returns the mapping of your new view. This can be done by first creating a new method named <code>get_urls()</code> inside the <code>BookrAdmin</code> class you have created for your custom admin site:<pre>def get_urls(self):</pre><p>Inside this method, the first thing you need to do is to get the list of the URLs that are already mapped to the admin endpoint. This is a required step, otherwise, your custom admin site will not be able to load any results associated with the model editing pages, logout page, and so on, in case this mapping is lost. To get this mapping, call the <code>get_urls()</code> method of the base class from which the <code>BookrAdmin</code> class is derived:</p><pre>urls = super().get_urls()</pre><p>Once the URLs from the base class are captured, the next step is to create a list of URLs that map our custom view to a URL endpoint in the admin site. For this, we create a new list named <code>url_patterns</code> and map our <code>profile_view</code> method to the <code>admin_profile</code> endpoint. To do this, we use the <code>path</code> utility function from Django, which allows us to map the view function with a string-based API endpoint path:</p><pre>url_patterns = [path("admin_profile", self.profile_view)]
return urls + url_patterns</pre><p>Save the <code>admin.py</code> file. It should look like this: <a href="http://packt.live/38Jlyvz">http://packt.live/38Jlyvz</a>. </p></li>
				<li>Now, with the <code>BookrAdmin</code> class configured for the new view, the next step is to create your template for the admin profile page. For this, create a new file named <code>admin_profile.html</code> under the <code>templates/admin</code> directory of your project root. Inside this file, first, add an <code>extend</code> tag to make sure that you are extending from the default <code>admin</code> template:<pre>{% extends "admin/index.html" %}</pre><p>This step ensures that all of your admin template style sheets and HTML are available for use inside your custom view template. For example, without having this <code>extend</code> tag, your custom view will not show any specific content already mapped to your admin site, such as <code>site_header</code>, <code>site_title</code>, or any links to log out or go to another page.</p><p>Once the extend tag is added, add a <code>block</code> tag and provide it with the value of content. This makes sure that the code you add between the pair of <code>{% block content %}…{% endblock %}</code> segments overrides whatever value is present in the <code>index.html</code> template that comes pre-packaged with the Django admin module:</p><pre>{% block content %}</pre><p>Inside the <code>block</code> tag, add the HTML required to render the profile view that was created in <em class="italic">step 2</em> of this exercise:</p><pre>&lt;p&gt;Welcome to your profile, {{ username }}&lt;/p&gt;
&lt;p&gt;You can do the following operations&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;&lt;a href="#"&gt;Change E-Mail Address&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="#"&gt;Add Profile Picture&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
{% endblock %}</pre><p>The file should look like this: <a href="http://packt.live/2MZhU8d">http://packt.live/2MZhU8d</a>.</p></li>
				<li>Now, with the preceding steps complete, reload your application server by running <code>python manage.py runserver localhost:8000</code> and then visiting <code>http://localhost:8000/admin/admin_profile</code>.<p>When the page opens, you can expect to see something like the following screenshot:</p><div><img src="img/B15509_10_07.jpg" alt="Figure 10.7: Profile page view in the administration site&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 10.7: Profile page view in the administration site</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The view created so far will render just fine irrespective of whether the user is logged into the admin application.</p>
			<p>To make sure that this view is only accessible to the logged-in admins, you need to make a small modification inside your <code>get_urls()</code> method, which you defined in <em class="italic">step 3</em> of this exercise.</p>
			<p>Inside the <code>get_urls()</code> method, modify the <code>url_patterns</code> list to look something like the one shown here:</p>
			<pre>url_patterns = [path("admin_profile", \
                self.admin_view(self.profile_view)),]</pre>
			<p>In the preceding code, you wrapped your <code>profile_view</code> method inside the <code>admin_view()</code> method.</p>
			<p>The <code>AdminSite.admin_view()</code> method causes the view to be restricted to those users who are logged in. If a user who is currently not logged into the admin site tries to visit the URL directly, they will get redirected to the login page, and only in the event of a successful login will they be allowed to see the contents of our custom page.</p>
			<p>During this exercise, we leveraged our existing understanding of writing views for Django applications and merged it with the context of the <code>AdminSite</code> class to build a custom view for our admin dashboard. With this knowledge, we can now move on and add useful functionalities to our Django admin to supercharge its usefulness. </p>
			<h2 id="_idParaDest-300"><a id="_idTextAnchor315"/>Passing Additional Keys to the Templates Using Template Variables</h2>
			<p>Inside the admin site, the variable values passed to the templates are passed through the use of template variables. These template variables are prepared and returned by the <code>AdminSite.each_context()</code> method.</p>
			<p>Now, if there is a value that you would like to pass to all the templates of your admin site, you can override the <code>AdminSite.each_context()</code> method and add the required fields to the <code>request</code> context. Let's look at an example to see how we can achieve this outcome.</p>
			<p>Consider the <code>username</code> field, which we passed to our <code>admin_profile</code> template earlier. If we want to pass it to every template inside our custom admin site, we first need to override the <code>each_context()</code> method inside our <code>BookrAdmin</code> class, as shown here:</p>
			<pre>def each_context(self, request):
        context = super().each_context(request)
        context['username'] = request.user.username
        return context</pre>
			<p>The <code>each_context()</code> method takes a single argument (we're not considering self here) of the <code>HTTPRequest</code> type, which it uses to evaluate certain other values.</p>
			<p>Now, inside our overridden <code>each_context()</code> method, we first make a call to the base class <code>each_context()</code> method so as to retrieve the <code>context</code> dictionary for the admin site:</p>
			<pre>context = super().each_context(request)</pre>
			<p>Once that is done, the next thing we do is to add our <code>username</code> field to the <code>context</code> and set its value to the value of the <code>request.user.username</code> field:</p>
			<pre>context['username'] = request.user.username</pre>
			<p>Once this is done, the last thing that remains is to return this modified context.</p>
			<p>Now, whenever a template is rendered by our custom admin site, the template will be passed with this additional username variable.</p>
			<h2 id="_idParaDest-301"><a id="_idTextAnchor316"/>Activity 10.01: Building a Custom Admin Dashboard with Built-In Search</h2>
			<p>In this activity, you will use the knowledge you gained about the different aspects of creating a custom admin site to build a custom admin dashboard for Bookr. Inside this dashboard, you will introduce the capability of allowing a user to search the books by using either the name of the book or by using the name of the book publisher and allowing the user to modify or delete these book records.</p>
			<p>The following steps will help you build a custom admin dashboard and add the ability to search a book record by using the name of the publisher:</p>
			<ol>
				<li value="1">Create a new application inside the Bookr project named <code>bookr_admin</code>, if not created already. This is going to store the logic for our custom admin site.</li>
				<li>Inside the <code>admin.py</code> file under the <code>bookr_admin</code> directory, create a new class, <code>BookrAdmin</code>, which inherits from the <code>AdminSite</code> class of Django's admin module.</li>
				<li>Inside the newly created <code>BookrAdmin</code> class in <em class="italic">step 2</em>, add any customizations for the site title or any other branding component of the admin dashboard.</li>
				<li>Inside the <code>apps.py</code> file under the <code>bookr_admin</code> directory, create a new <code>BookrAdminConfig</code> class, and inside this new <code>BookrAdminConfig</code> class, set the default site attribute to the fully qualified module name for our custom admin site class, <code>BookrAdmin</code>.</li>
				<li>Inside the <code>settings.py</code> file of your Django project, add the fully qualified path of the <code>BookrAdminConfig</code> class created in <em class="italic">step 4</em> as the first installed application.</li>
				<li>To register the <code>Books</code> model from the <code>reviews</code> application inside Bookr, open the <code>admin.py</code> file inside the reviews directory and make sure that the Books model is registered to the admin site by using <code>admin.site.register(ModelClass)</code>.</li>
				<li>To allow a search of the book according to the name of the publisher, inside the <code>admin.py</code> file of the <code>reviews</code> application, modify the <code>BookAdmin</code> class and add to it a property named <code>search_fields</code>, which contains <code>publisher_name</code> as a field.</li>
				<li>To get the publisher's name correctly for the <code>search_fields</code> property, introduce a new method named <code>get_publisher</code> inside the <code>BookAdmin</code> class, which will return the name field of the publisher from the <code>Book</code> model.</li>
				<li>Make sure that the <code>BookAdmin</code> class is registered as a Model admin class for the Book model inside our Django admin dashboard by using <code>admin.site.register(Book, BookModel)</code>.</li>
			</ol>
			<p>After completing this activity, once you start the application server and visit <code>http://localhost:8000/admin</code> and navigate to the Book model, you should be able to search for books by using the publisher's name and, in the event of a successful search, see a page that resembles the one shown in the following screenshot: </p>
			<div><div><img src="img/B15509_10_08.jpg" alt="Figure 10.8: Book editing page inside the Bookr administration dashboard&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.8: Book editing page inside the Bookr administration dashboard</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution to this activity can be found at <a href="http://packt.live/2Nh1NTJ">http://packt.live/2Nh1NTJ</a>.</p>
			<h1 id="_idParaDest-302"><a id="_idTextAnchor317"/>Summary</h1>
			<p>In this chapter, we looked at how Django allows the customization of its admin site. It does so by providing easy-to-use properties for some of the more general parts of the site, such as title fields, headings, and home links. Beyond this, we learned how to build a custom admin site by leveraging the concepts of object-oriented programming in Python and creating a child class of <code>AdminSite</code>.</p>
			<p>This functionality was further enhanced by implementing a custom template for the logout page. We also learned how we can supercharge our admin dashboard by adding a new set of views to allow enhanced usage of the dashboard.</p>
			<p>As we move on to the next chapter, we will build upon what we have learned so far by learning how to create our own custom tags and filters for templates. Furthermore, using class-based views, we will gain the ability to build our views in an object-oriented style.</p>
		</div>
		<div><div></div>
		</div>
	</body></html>