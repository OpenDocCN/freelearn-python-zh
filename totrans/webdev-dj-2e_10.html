<html><head></head><body>
		<div>
			<div id="_idContainer350" class="Content">
			</div>
		</div>
		<div id="_idContainer351" class="Content">
			<h1 id="_idParaDest-283"><a id="_idTextAnchor298"/>10. Advanced Django Admin and Customizations</h1>
		</div>
		<div id="_idContainer360" class="Content">
			<p class="callout-heading">Overview</p>
			<p class="callout">This chapter introduces you to advanced customizations to the <strong class="bold">Django Admin</strong> site so that you can tailor the appearance of the Django Admin dashboard to make it blend with the rest of your web project. You will see how new features and capabilities can be added to your web project's Django admin interface to make it substantially more powerful and useful for your project's goals. These customizations are driven by the addition of custom templates that help modify the look and feel of existing pages. These custom templates also add new views that can help extend the default functionalities of the Admin dashboard. Completing this chapter will equip you with skills that not only let you customize the interface, but also the functionality of your project's Django-based admin page.</p>
			<h1 id="_idParaDest-284"><a id="_idTextAnchor299"/>Introduction</h1>
			<p>Let's say we want to customize the front page of a large organization's admin site. We want to show the health of the different systems in the organization and see any high-priority alerts that are active. If this were an internal website built on top of Django, we would need to customize it. Adding these kinds of functionalities will require the developers in the IT team to customize the default admin panel and create their own custom <strong class="source-inline">AdminSite</strong> module, which will render a different index page in comparison to what is provided by the default admin site. Fortunately, Django makes these kinds of customizations easy. </p>
			<p>In this chapter, we will look at how we can leverage Django's framework and its extensibility to customize Django's default admin interface (as shown in <em class="italic">Figure 10.1</em>). We'll not just learn how to make the interface more personal; we will also learn how we can control the different aspects of the admin site to make Django load a custom admin site instead of the one that ships with the default framework. Such customization can come in handy when we want to introduce features into the admin site that are not present by default.</p>
			<div>
				<div id="_idContainer352" class="IMG---Figure">
					<img src="image/B15509_10_01.jpg" alt="Figure 10.1: Default Django administration panel interface&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.1: Default Django administration panel interface</p>
			<p>This chapter builds upon the skills we practiced in <em class="italic">Chapter 4</em>, <em class="italic">Introduction to Django Admin</em>. Just to recap, we learned how to use the Django admin site to take control of the administration and authorization for our Bookr app. We also learned how to register models to read and edit their contents and also to customize Django's admin interface using the <strong class="source-inline">admin.site</strong> properties. Now, let's expand our knowledge further by taking a look at how we can start customizing the admin site by utilizing Django's <strong class="source-inline">AdminSite</strong> module to add powerful new functionalities to the admin portal of our web application.</p>
			<h1 id="_idParaDest-285"><a id="_idTextAnchor300"/>Customizing the Admin Site</h1>
			<p>Django as a web framework provides a lot of customization options for building web applications. We will be using this same freedom provided by Django when we are working on building the admin application for our project.</p>
			<p>In <em class="italic">Chapter 4</em>, <em class="italic">Introduction to Django Admin</em>, we looked at how we can use the <strong class="source-inline">admin.site</strong> properties to customize the elements of our Django's admin interface. But what if we require more control over how our admin site behaves? For example, let's say we wanted to use a custom template for the login page (or the logout page) to show to users whenever they visited the Bookr admin panel. In this case, the <strong class="source-inline">admin.site</strong> properties provided might not be enough, and we will need to build customizations that can extend the default admin site's behavior. Luckily, this can be easily achieved by extending the <strong class="source-inline">AdminSite</strong> class from Django's admin model. But before we jump into building our admin site, let's first understand how Django discovers admin files and how we can use this admin file discovery mechanism to build a new app inside Django that will act as our admin site app.</p>
			<h2 id="_idParaDest-286"><a id="_idTextAnchor301"/>Discovering Admin Files in Django</h2>
			<p>When we build applications in our Django project, we use the <strong class="source-inline">admin.py</strong> file frequently to register our models or create <strong class="source-inline">ModelAdmin</strong> classes that customize our interactions with the models inside the admin interface. These <strong class="source-inline">admin.py</strong> files store and provide this information to our project's admin interface. The discovery of these files is affected automatically by Django once we add <strong class="source-inline">django.contrib.admin</strong> to our <strong class="source-inline">INSTALLED_APPS</strong> section inside our <strong class="source-inline">settings.py</strong> file:</p>
			<div>
				<div id="_idContainer353" class="IMG---Figure">
					<img src="image/B15509_10_02.jpg" alt="Figure 10.2: Bookr application structure&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.2: Bookr application structure</p>
			<p>As we can see in the preceding figure, we have an <strong class="source-inline">admin.py</strong> file under the <strong class="source-inline">reviews</strong> application directory that is used by Django to customize the admin site for Bookr.</p>
			<p>When the admin application gets added, it tries to find the <strong class="source-inline">admin</strong> module inside every app of the Django project we are working on and, if a module is found, it loads the contents from that module.</p>
			<h2 id="_idParaDest-287"><a id="_idTextAnchor302"/>Django's AdminSite Class</h2>
			<p>Before we start customizing Django's admin site, we must understand how the default admin site is generated and handled by Django.</p>
			<p>To provide us with the default admin site, Django packages a module known as the <strong class="source-inline">admin</strong> module, which holds a class known as <strong class="source-inline">AdminSite</strong>. This class implements a lot of useful functionalities and intelligent defaults that the Django community thinks will be important for implementing a useful administration panel for most Django websites. The default <strong class="source-inline">AdminSite</strong> class provides a lot of inbuilt properties that not only control the look and feel of how the default admin site is rendered in the web browser, but also control the way we can interact with it and how a particular interaction will result in an action. Some of these defaults include the site template properties, such as text to be shown in the site header, text to show in the title bar of the web browser, integration with Django's <strong class="source-inline">auth</strong> module for authenticating to the admin site, and a host of other properties.</p>
			<p>As we progress on our path to building a custom admin site for our Django web project, it is more than desirable to retain a lot of the useful functionalities that are already built into Django's <strong class="source-inline">AdminSite</strong> class. This is where the concepts of Python object-oriented programming come to our rescue.</p>
			<p>As we start to create our custom admin site, we will try to leverage the existing useful set of functionalities that are provided by Django's default <strong class="source-inline">AdminSite</strong> class. For this, instead of building everything from scratch, we will work on creating a new child class that inherits from Django's <strong class="source-inline">AdminSite</strong> class to leverage the existing set of functionalities and useful integration that Django already provides us with. This kind of approach allows us to focus on adding a new and useful set of functionalities to our custom admin site, rather than spending time on implementing the basic set of functionalities from scratch. For example, the following code snippet shows how we can create a child class of Django's <strong class="source-inline">AdminSite</strong> class:</p>
			<p class="source-code">class MyAdminSite(admin.AdminSite):</p>
			<p class="source-code">    …</p>
			<p>To start working on our custom admin site for our web application, let's start by overriding some of the basic properties of Django's admin panel through the use of the custom <strong class="source-inline">AdminSite</strong> class we are going to work on.</p>
			<p>Some of the properties that can be overridden include <strong class="source-inline">site_header</strong>, <strong class="source-inline">site_title</strong>, and others.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">When creating a custom admin site, we will have to register once again any <strong class="source-inline">Model</strong> and <strong class="source-inline">ModelAdmin</strong> classes that we might have registered using the default <strong class="source-inline">admin.site</strong> variable earlier. This happens because a custom admin site doesn't inherit the instance details from the default admin site provided by Django and so unless we re-register our <strong class="source-inline">Model</strong> and <strong class="source-inline">ModelAdmin</strong> interfaces, our custom admin site will not show them. </p>
			<p>Now, with the knowledge of how Django discovers what to load into the admin interface and how we can start building our custom admin site, let's go ahead and try to create our custom admin app for Bookr, which extends the existing <strong class="source-inline">admin</strong> module provided by Django. In the exercise that follows, we are going to create a custom admin site interface for our Bookr application using Django's <strong class="source-inline">AdminSite</strong> class.</p>
			<h2 id="_idParaDest-288"><a id="_idTextAnchor303"/>Exercise 10.01: Creating a Custom Admin Site for Bookr</h2>
			<p>In this exercise, you will create a new application that extends the default Django admin site and allows you to customize the components of the interface. Consequently, you will customize the default title of Django's admin panel. Once that is done, you will override the default value of Django's <strong class="source-inline">admin.site</strong> property to point to your custom admin site:</p>
			<ol>
				<li>Before you can start working on your custom admin site, you first need to make sure that you are in the correct directory in your project from where you can run your Django application's management commands. For this, use the Terminal or Windows Command Prompt to navigate to the <strong class="source-inline">bookr</strong> directory and then create a new application named <strong class="source-inline">bookr_admin</strong>, which is going to act as the admin site for Bookr, by running the following commands:<p class="source-code">python3 manage.py startapp bookr_admin</p><p>Once this command is executed successfully, you should have a new directory named <strong class="source-inline">bookr_admin</strong> inside your project. </p></li>
				<li>Now, with the default structure configured, the next step is to create a new class named <strong class="source-inline">BookrAdmin</strong>, which will extend the <strong class="source-inline">AdminSite</strong> class provided by Django to inherit the properties of the default admin site. To do this, open the <strong class="source-inline">admin.py</strong> file under the <strong class="source-inline">bookr_admin</strong> directory inside PyCharm. Once the file is open, you will see that the file already has the following code snippet present inside it: <p class="source-code">from django.contrib import admin</p><p>Now, keeping this <strong class="source-inline">import</strong> statement as is, starting from the next line, create a new class named <strong class="source-inline">BookrAdmin</strong>, which inherits from the <strong class="source-inline">AdminSite</strong> class provided by the <strong class="source-inline">admin</strong> module you imported earlier:</p><p class="source-code">class BookrAdmin(admin.AdminSite):</p><p>Inside this new <strong class="source-inline">BookrAdmin</strong> class, override the default value for the <strong class="source-inline">site_header</strong> variable, which is responsible for rendering the site header in Django's admin panel by setting the <strong class="source-inline">site_header</strong> property, as shown next:</p><p class="source-code">    site_header = "Bookr Administration"</p><p>With this, the custom admin site class is now defined. To use this class, you will first create an instance of this class. This can be done as follows:</p><p class="source-code">admin_site = BookrAdmin(name='bookr_admin')</p></li>
				<li>Save the file but don't close it yet; we'll revisit it in <em class="italic">step 6</em>. Next, let's edit the <strong class="source-inline">urls.py</strong> file in the <strong class="source-inline">bookr</strong> app. </li>
				<li>With the custom class now defined, the next step is to modify the <strong class="source-inline">urlpatterns</strong> list to map the <strong class="source-inline">/admin</strong> endpoint in our project to the new <strong class="source-inline">AdminSite</strong> class you created. To do this, open the <strong class="source-inline">urls.py</strong> file under the <strong class="source-inline">Bookr</strong> project directory inside PyCharm and change the mapping of the <strong class="source-inline">/admin</strong> endpoint to point to our custom site:<p class="source-code"><strong class="bold">from bookr_admin.admin import admin_site</strong></p><p class="source-code">urlpatterns = [….,\</p><p class="source-code"><strong class="bold">               path('admin/', admin_site.urls)</strong>]</p><p>We first imported the <strong class="source-inline">admin_site</strong> object from the admin module of the <strong class="source-inline">bookr_admin</strong> app. Then, we used the <strong class="source-inline">urls</strong> property of the object to map to the <strong class="source-inline">admin</strong> endpoint in our application as follows:</p><p class="source-code">path('admin/', admin_site.urls)</p><p>In this case, the <strong class="source-inline">urls</strong> property of our <strong class="source-inline">admin_site</strong> object is being automatically populated by the <strong class="source-inline">admin.AdminSite</strong> base class provided by Django's <strong class="source-inline">admin</strong> module. Once complete, your <strong class="source-inline">urls.py</strong> file should look like this: <a href="http://packt.live/3qjx46J">http://packt.live/3qjx46J</a>.</p></li>
				<li>Now, with the configuration done, let's run our admin app in the browser. For this, run the following command from the root of your project directory where the <strong class="source-inline">manage.py</strong> file is located:<p class="source-code">python manage.py runserver localhost:8000</p><p>Then, navigate to <strong class="source-inline">http://localhost:8000/admin</strong> (or <strong class="source-inline">http://127.0.0.1:8000/admin</strong>), which opens a page that resembles the following screenshot:</p><div id="_idContainer354" class="IMG---Figure"><img src="image/B15509_10_03.jpg" alt="Figure 10.3: Home page view for the custom Bookr admin site&#13;&#10;"/></div><p class="figure-caption">Figure 10.3: Home page view for the custom Bookr admin site</p><p>In the preceding screenshot (<em class="italic">Figure 10.3</em>), you will see that Django displays the message, <strong class="source-inline">You don't have permission to view or edit anything</strong>. The issue of not having adequate permissions happens because, up till now, we have not registered any models with our custom <strong class="source-inline">AdminSite</strong> instance. The issue also applies to the <strong class="source-inline">User and Groups</strong> models that are shipped along with the Django <strong class="source-inline">auth</strong> module. So, let's make our custom admin site a bit more useful by registering the <strong class="source-inline">User</strong> model from Django's <strong class="source-inline">auth</strong> module.</p></li>
				<li>To register the <strong class="source-inline">User</strong> model from Django's <strong class="source-inline">auth</strong> module, open the <strong class="source-inline">admin.py</strong> file under the <strong class="source-inline">bookr_admin</strong> directory inside PyCharm, and add the following line at the top of the file:<p class="source-code">from django.contrib.auth.admin import User</p><p>At the end of the file, use your <strong class="source-inline">BookrAdmin</strong> instance to register this model as follows:</p><p class="source-code">admin_site.register(User)</p><p>By now, your <strong class="source-inline">admin.py</strong> file should look like this:</p><p class="source-code">from django.contrib import admin</p><p class="source-code">from django.contrib.auth.admin import User</p><p class="source-code">class BookrAdmin(admin.AdminSite):</p><p class="source-code">    site_header = "Bookr Administration"</p><p class="source-code">admin_site = BookrAdmin(name='bookr_admin')</p><p class="source-code">admin_site.register(User)</p><p>Once this is done, reload the web server and visit <strong class="source-inline">http://localhost:8000/admin</strong>. Now, you should be able to see the <strong class="source-inline">User</strong> model being displayed for editing inside the admin interface, as shown here:</p><div id="_idContainer355" class="IMG---Figure"><img src="image/B15509_10_04.jpg" alt="Figure 10.4: Home page view showing our registered models &#13;&#10;on the Bookr Administration site&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 10.4: Home page view showing our registered models on the Bookr Administration site</p>
			<p>With this, we just created our admin site application, and we can also now validate the fact that the custom site has a different header—<strong class="source-inline">Bookr Administration</strong>.</p>
			<h2 id="_idParaDest-289"><a id="_idTextAnchor304"/>Overriding the Default admin.site</h2>
			<p>In the previous section, after we created our own <strong class="source-inline">AdminSite</strong> application, we saw that we had to register models manually. This happens because most of the apps that we have built prior to our custom admin site still use the <strong class="source-inline">admin.site</strong> property to register their models and, if we want to use our <strong class="source-inline">AdminSite</strong> instance, we will have to update all those applications to use our instance, which can become cumbersome if there are a lot of applications inside a project.</p>
			<p>Luckily, we can avoid this additional burden by overriding the default <strong class="source-inline">admin.site</strong> property. To do this, we first have to create a new <strong class="source-inline">AdminConfig</strong> class, which will override the default <strong class="source-inline">admin.site</strong> property for us, so that our application is marked as the default admin site and hence overrides the <strong class="source-inline">admin.site</strong> property inside our project. In the next exercise, we'll look at how we can map our custom admin site as a default admin site for an application.</p>
			<h2 id="_idParaDest-290"><a id="_idTextAnchor305"/>Exercise 10.02: Overriding the Default Admin Site</h2>
			<p>In this exercise, you will use the <strong class="source-inline">AdminConfig</strong> class to override the default admin site for your project such that you can keep on using the default <strong class="source-inline">admin.site</strong> variable to register models, override site properties, and more:</p>
			<ol>
				<li value="1">Open the <strong class="source-inline">admin.py</strong> file under the <strong class="source-inline">bookr_admin</strong> directory and remove the import for the <strong class="source-inline">User</strong> model and the <strong class="source-inline">BookrAdmin</strong> instance creation, which you wrote in <em class="italic">step 6</em> of <em class="italic">Exercise 10.01</em>, <em class="italic">Creating a Custom Admin Site for Bookr</em>. Once this is done, the file contents should resemble the following:<p class="source-code">from django.contrib import admin</p><p class="source-code">class BookrAdmin(admin.AdminSite):</p><p class="source-code">    site_header = "Bookr Administration"</p></li>
				<li>You will then need to create an <strong class="source-inline">AdminConfig</strong> class for the custom admin site, such that Django recognizes the <strong class="source-inline">BookrAdmin</strong> class as an <strong class="source-inline">AdminSite</strong> and overrides the <strong class="source-inline">admin.site</strong> property. To do this, open up the <strong class="source-inline">apps.py</strong> file inside the <strong class="source-inline">bookr_admin</strong> directory and overwrite the contents of the file with the contents shown here:<p class="source-code">from django.contrib.admin.apps import AdminConfig</p><p class="source-code">class BookrAdminConfig(AdminConfig):</p><p class="source-code">    default_site = 'bookr_admin.admin.BookrAdmin'</p><p>In this, we first imported the <strong class="source-inline">AdminConfig</strong> class from Django's <strong class="source-inline">admin</strong> module. This class is used to define the application that should be used as a default admin site, and also to override the default behavior of the Django admin site.</p><p>For our use case, we created a class with the name <strong class="source-inline">BookrAdminConfig</strong>, which acts as a child class of Django's <strong class="source-inline">AdminConfig</strong> class and overrides the <strong class="source-inline">default_site</strong> property to point to our <strong class="source-inline">BookrAdmin</strong> class, which is our custom admin site:</p><p class="source-code">default_site = 'bookr_admin.admin.BookrAdmin'</p><p>Once this is done, we need to set our application as an admin application inside our <strong class="source-inline">Bookr</strong> project. To achieve this, open the <strong class="source-inline">settings.py</strong> file of the <strong class="source-inline">Bookr</strong> project and, under the <strong class="source-inline">INSTALLED_APPS</strong> section, replace <strong class="source-inline">'reviews.apps.ReviewsAdminConfig'</strong> with <strong class="source-inline">'bookr_admin.apps.BookrAdminConfig'</strong>. The <strong class="source-inline">settings.py</strong> file should look like this: <a href="http://packt.live/3siv1lf">http://packt.live/3siv1lf</a>. </p></li>
				<li>With the application mapped as the admin application, the final step involves modifying the URL mapping such that the <strong class="source-inline">'admin/'</strong> endpoint uses the <strong class="source-inline">admin.site</strong> property to find the correct URL. For this, open the <strong class="source-inline">urls.py</strong> file under the bookr project. Consider the following entry in the <strong class="source-inline">urlpatterns</strong> list:<p class="source-code">path('admin/', admin<strong class="bold">_</strong>site.urls)</p><p>Replace it with the following entry:</p><p class="source-code">from django.contrib import admin</p><p class="source-code">urlpatterns = [....\</p><p class="source-code">               path('admin/', admin<strong class="bold">.</strong>site.urls)]</p><p>Remember that <strong class="source-inline">admin_site.urls</strong> is a module, while <strong class="source-inline">admin.site</strong> is a Django internal property. </p><p>Once the preceding steps are complete, let's reload our web server and check whether our admin site loads by visiting <strong class="source-inline">http://localhost:8000/admin</strong>. If the website that loads looks like the one shown here, we have our own custom admin app now being used for the admin interface:</p><div id="_idContainer356" class="IMG---Figure"><img src="image/B15509_10_05.jpg" alt="Figure 10.5: Home page view of the custom Bookr Administration site&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 10.5: Home page view of the custom Bookr Administration site</p>
			<p>As you can see, once we override <strong class="source-inline">admin.site</strong> with our admin app, the models that were registered earlier using the <strong class="source-inline">admin.site.register</strong> property start to show up automatically.</p>
			<p>With this, we now have a custom base template, which we can now utilize to build the remainder of our Django admin customizations on. As we work through the chapter, we will discover some interesting customizations that allow us to make the admin dashboard an integrated part of our application.</p>
			<h2 id="_idParaDest-291"><a id="_idTextAnchor306"/>Customizing Admin Site Text Using AdminSite Attributes</h2>
			<p>Just as we can use the <strong class="source-inline">admin.site</strong> properties to customize the text for our Django application, we can also use the attributes exposed by the <strong class="source-inline">AdminSite</strong> class to customize these texts. In <em class="italic">Exercise 10.02</em>, <em class="italic">Overriding the Default Admin Site</em>, we took a look at updating the <strong class="source-inline">site_header</strong> property of the admin site. Similarly, there are many other properties we can modify. Some of the properties that can be overridden are described as follows:</p>
			<ul>
				<li><strong class="source-inline">site_header</strong>: Text to display at the top of every admin page (defaults to <strong class="source-inline">Django Administration</strong>).</li>
				<li><strong class="source-inline">site_title</strong>: Text to display in the title bar of the browser (defaults to <strong class="source-inline">Django Admin Site</strong>).</li>
				<li><strong class="source-inline">site_url</strong>: The link to use for the <strong class="source-inline">View Site</strong> option (defaults to <strong class="source-inline">/</strong>). This is overridden when the site is running on a custom path and the redirection should take the user to the subpath directly.</li>
				<li><strong class="source-inline">index_title</strong>: This is the text that should be shown on the index page of the admin application (defaults to <strong class="source-inline">Site administration</strong>).<p class="callout-heading">Note</p><p class="callout">For more information on all the <strong class="source-inline">adminsite</strong> attributes, refer to the official Django documentation at <a href="https://docs.djangoproject.com/en/3.1/ref/contrib/admin/#adminsite-attributes">https://docs.djangoproject.com/en/3.1/ref/contrib/admin/#adminsite-attributes</a>.</p></li>
			</ul>
			<p>If we want to override these attributes in our custom admin site, the process is very simple:</p>
			<p class="source-code">class MyAdminSite(admin.AdminSite):</p>
			<p class="source-code">    site_header = "My web application"</p>
			<p class="source-code">    site_title = "My Django Web application"</p>
			<p class="source-code">    index_title = "Administration Panel"</p>
			<p>As we have seen in the examples so far, we have created a custom admin application for Bookr and then made it the default admin site for our project. An interesting question arises here. Since the properties that we have customized so far can also be customized by using the <strong class="source-inline">admin.site</strong> object directly, why should we create a custom admin application? Can't we just modify the <strong class="source-inline">admin.site</strong> properties?</p>
			<p>As it turns out, there could be multiple reasons why someone would opt for a custom admin site; for example, they might want to change the layout of the default admin site to make it align with the overall layout of their application. This is quite common when creating a web application for a business where the homogeneity of the content is very important. Here is a short list of requirements that may compel a developer to go ahead and build a custom admin site as opposed to simply modifying the properties of the <strong class="source-inline">admin.site</strong> variable:</p>
			<ul>
				<li>A need to override the index template for the admin interface</li>
				<li>A need to override the login or logout template</li>
				<li>A need to add a custom view to the admin interface</li>
			</ul>
			<h2 id="_idParaDest-292"><a id="_idTextAnchor307"/>Customizing Admin Site Templates</h2>
			<p>Just like some of the customizable common texts, such as <strong class="source-inline">site_header</strong> and <strong class="source-inline">site_title</strong>, that appear across the admin site, Django also allows us to customize the templates, which are used to render different pages inside the admin site by setting certain properties in the <strong class="source-inline">AdminSite</strong> class.</p>
			<p>These customizations can include the modification of templates that are used to render the index page, login page, model data page, and more. These customizations can be easily done by leveraging the templating system provided by Django. For example, the following code snippet shows how we can add a new template to the Django admin dashboard:</p>
			<p class="source-code">{% extends "admin/base_site.html" %}</p>
			<p class="source-code">{% block content %}</p>
			<p class="source-code">  &lt;!-- Template Content --&gt;</p>
			<p class="source-code">{% endblock %}</p>
			<p>In this custom template, there are a couple of important aspects that we need to understand.</p>
			<p>When customizing the existing Django admin dashboard by modifying how certain pages inside the dashboard appear or by adding a new set of pages to the dashboard, we might not want to write every single piece of HTML again from scratch to maintain the basic look and feel of the Django admin dashboard.</p>
			<p>Usually, while customizing the admin dashboard, we want to retain the layout in which Django organizes the different elements displayed on the dashboard such that we can focus on modifying parts of the page that matter to us. This basic layout of the page, along with the common page elements, such as the page header and page footer, are defined inside the Django admin's base template, which also acts as a master template for all the pages inside the default Django admin website.</p>
			<p>To retain the way the common elements inside the Django admin pages are organized and rendered, we need to extend from this base template such that our custom template pages provide a user experience consistent with the other pages inside the Django admin dashboard. This can be done by using the template extension tags and extending the <strong class="source-inline">base_site.html</strong> template from the <strong class="source-inline">admin</strong> module provided by Django:</p>
			<p class="source-code">{% extends "admin/base_site.html" %}</p>
			<p>Once this is done, the next part is to define our own content for the custom template. The <strong class="source-inline">base_site.html</strong> template provided by Django provides a block-based placeholder for developers to add their own content to the template. To add this content, a developer has to put the logic for their own custom elements for the page inside the <strong class="source-inline">{% block content %}</strong> tags. This essentially overrides any content defined by the <strong class="source-inline">{% block content %}</strong> tag inside the <strong class="source-inline">base_site.html</strong> template, following the concepts of template inheritance in Django.</p>
			<p>Now, let's look at how we can customize the template, which is used to render the logout page, once the user clicks the Logout button in the admin panel.</p>
			<h2 id="_idParaDest-293"><a id="_idTextAnchor308"/>Exercise 10.03: Customizing the Logout Template for the Bookr Admin Site</h2>
			<p>In this exercise, you are going to customize the template that is used to render the logout page once the user clicks the <strong class="source-inline">Logout</strong> button on the admin site. Such overrides can come in handy in banking websites. Once a user clicks <strong class="source-inline">Logout</strong>, the bank might want to show the user a page with detailed instructions on how to make sure that their banking session is securely closed. </p>
			<ol>
				<li value="1">Under the <strong class="source-inline">templates</strong> directory which you must have created in the earlier chapters, create another directory named <strong class="source-inline">admin</strong> which will be used for storing templates for your custom admin site. <p class="callout-heading">Note</p><p class="callout">Before proceeding, make sure that the templates directory is added to the <strong class="source-inline">DIRS</strong> list in your <strong class="source-inline">settings.py</strong> file (under the <strong class="source-inline">bookr/ project</strong>).</p></li>
				<li>Now, with the directory structure setup complete, and Django configured to load the templates, the next step involves writing your custom logout template that you want to render. For this, let's create a new file named <strong class="source-inline">logout.html</strong> under the <strong class="source-inline">templates/admin</strong> directory we created in <em class="italic">step 1</em> and add the following content to it:<p class="source-code">{% extends "admin/base_site.html" %}</p><p class="source-code">{% block content %}</p><p class="source-code">&lt;p&gt;You have been logged out from the Admin panel. &lt;/p&gt;</p><p class="source-code">&lt;p&gt;&lt;a href="{% url 'admin:index' %}"&gt;Login Again&lt;/a&gt; or   &lt;a href="{{ site_url }}"&gt;Go to Home Page&lt;/a&gt;&lt;/p&gt;</p><p class="source-code">{% endblock %}</p><p>In the preceding code snippet, we are doing a couple of things. First, for our custom logout template, we are going to use the same master layout as provided by the <strong class="source-inline">django.contrib.admin</strong> module. So, consider the following:</p><p class="source-code">{% extends "admin/base_site.html" %}</p><p>When we write this, Django tries to find and load the <strong class="source-inline">admin/base_site.html</strong> template inside the <strong class="source-inline">templates</strong> directory provided by the <strong class="source-inline">django.contrib.admin</strong> module.</p><p>Now, with our base template all set to be extended, the next thing we do is try to override the HTML of the content block by executing the following command:</p><p class="source-code">{% block content %}</p><p class="source-code">…</p><p class="source-code">{% endblock %}</p><p>The values of <strong class="source-inline">admin:index</strong> and <strong class="source-inline">site_url</strong> are provided by the <strong class="source-inline">AdminSite</strong> class automatically, based on the settings we define.</p><p>Using the value for <strong class="source-inline">admin:index</strong> and <strong class="source-inline">site_url</strong>, we create our <strong class="source-inline">Login Again</strong> hyperlink, which, when clicked, will take the user back to the login form, and the <strong class="source-inline">Go</strong> <strong class="source-inline">to</strong> <strong class="source-inline">Home</strong> <strong class="source-inline">Page</strong> link, which will take the user back to the home page of the website. The file should look like this now: <a href="http://packt.live/3oIGQPo">http://packt.live/3oIGQPo</a>.</p></li>
				<li>Now, with the custom template defined, the next step is to make use of this custom template in our custom admin site. To do this, let's open the <strong class="source-inline">admin.py</strong> file under the <strong class="source-inline">bookr_admin</strong> directory and add the following field as the final value in the <strong class="source-inline">BookrAdmin</strong> class:<p class="source-code">logout_template = 'admin/logout.html'</p><p>Save the file. It should look like this: <a href="http://packt.live/3oHHsVz">http://packt.live/3oHHsVz</a>. </p></li>
				<li>Once all the preceding steps are complete, let's start our development server by running the following command:<p class="source-code">python manage.py runserver localhost:8000</p><p>Then, we navigate to <strong class="source-inline">http://localhost:8000/admin</strong>.</p><p>Once you are there, try to do a login and then click <strong class="source-inline">Logout</strong>. Once you are logged out, you will see the following page rendered:</p><div id="_idContainer357" class="IMG---Figure"><img src="image/B15509_10_06.jpg" alt="Figure 10.6: Logout view rendered to users after clicking the Logout button&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 10.6: Logout view rendered to users after clicking the Logout button</p>
			<p>With this, we have successfully overridden our first template. Similarly, we can also override other templates inside Django's admin panel, such as the templates for the index view and the login form.</p>
			<h1 id="_idParaDest-294"><a id="_idTextAnchor309"/>Adding Views to the Admin Site</h1>
			<p>Just like general applications inside Django, which can have multiple views associated with them, Django allows developers to add custom views to the admin site as well. This allows the developer to increase the scope of what the admin site interface can do.</p>
			<p>The ability to add your own views to the admin site provides a lot of extensibility to the admin panel of the website, which can be leveraged for several additional use cases. For example, as we discussed at the start of the chapter, an IT team of a big organization can add a custom view to the admin site, which can then be used to both monitor the health of the different IT systems in the organization and to provide the IT team with the ability to quickly look at any urgent alerts that need to be addressed.</p>
			<p>Now, the next question we need to answer is: <em class="italic">How can we add a custom view to the admin site?</em></p>
			<p>As it turns out, adding a new view inside the admin template is quite easy and follows the same approach we used while creating views for our applications, though with some minor modifications. In the next section, we will look at how we can add a new view to our Django admin dashboard.</p>
			<h2 id="_idParaDest-295"><a id="_idTextAnchor310"/>Creating the View Function</h2>
			<p>The first step to adding a new view to the Django application is to create a view function that implements the logic to handle the view. In the previous chapters, we created the view functions inside a separate file known as <strong class="source-inline">views.py</strong>, which was used to hold all our method- and class-based views.</p>
			<p>When it comes to adding a new view to the Django admin dashboard, to create a new view, we need to define a new view function inside our custom <strong class="source-inline">AdminSite</strong> class. For example, to add a new view that renders a page showing the health of the different IT systems inside the organization, we can create a new view function named <strong class="source-inline">system_health_dashboard()</strong> inside our custom <strong class="source-inline">AdminSite</strong> class implementation, as shown in the following code snippet:</p>
			<p class="source-code">class SysAdminSite(admin.AdminSite):</p>
			<p class="source-code">    def system_health_dashboard(self, request):</p>
			<p class="source-code">        # View function logic</p>
			<p>Inside the view function, we can perform any operations we want in order to generate a view and finally use that response to render a template. Inside this view function, there are some important pieces of logic we need to make sure are implemented correctly.</p>
			<p>The first one is to set the <strong class="source-inline">current_app</strong> property for the <strong class="source-inline">request</strong> field inside the view function. This is required in order to allow Django's URL resolver inside the templates to correctly resolve the view functions for an application. To set this value inside the custom view function we just created, we need to set the <strong class="source-inline">current_app</strong> property as shown in the following code snippet:</p>
			<p class="source-code">request.current_app = self.name</p>
			<p>The <strong class="source-inline">self.name</strong> field is automatically populated by Django's <strong class="source-inline">AdminSite</strong> class and we don't need to initialize it explicitly. With this, our minimal custom view implementation will appear as shown in the following code snippet:</p>
			<p class="source-code">class SysAdminSite(admin.AdminSite):</p>
			<p class="source-code">    def system_health_dashboard(self, request):</p>
			<p class="source-code">        request.current_app = self.name</p>
			<p class="source-code">        # View function logic</p>
			<h2 id="_idParaDest-296"><a id="_idTextAnchor311"/>Accessing Common Template Variables</h2>
			<p>When creating a custom view function, we might want access to the common template variables, such as <strong class="source-inline">site_header</strong> and <strong class="source-inline">site_title</strong>, in order to render them correctly in the template associated with our view function. As it turns out, this is quite easy to achieve with the use of the <strong class="source-inline">each_context()</strong> method provided by the <strong class="source-inline">AdminSite</strong> class.</p>
			<p>The <strong class="source-inline">each_context()</strong> method of the <strong class="source-inline">AdminSite</strong> class takes a single parameter, <strong class="source-inline">request</strong>, which is the current request context, and returns the template variables that are to be inserted in all the admin site templates.</p>
			<p>For example, if we wanted to access the template variables inside our custom view function, we could implement code similar to the following code snippet:</p>
			<p class="source-code">def system_health_dashboard(self, request):</p>
			<p class="source-code">    request.current_app = self.name</p>
			<p class="source-code">    context = self.each_context(request)</p>
			<p class="source-code">    # view function logic</p>
			<p>The value returned by the <strong class="source-inline">each_context()</strong> method is a dictionary containing the name of the variable and the associated value.</p>
			<h2 id="_idParaDest-297"><a id="_idTextAnchor312"/>Mapping URLs for the Custom View</h2>
			<p>Once the view function is defined, the next step involves mapping this view function to a URL such that a user can access it or allow the other views to link to it. For the views defined inside <strong class="source-inline">AdminSite</strong>, this URL mapping to views is controlled by the <strong class="source-inline">get_urls()</strong> method implemented by the <strong class="source-inline">AdminSite</strong> class. The <strong class="source-inline">get_urls()</strong> method returns the <strong class="source-inline">urlpatterns</strong> list that maps to the <strong class="source-inline">AdminSite</strong> views.</p>
			<p>If we would like to add a URL mapping for our custom view, the preferred approach includes overriding the implementation of <strong class="source-inline">get_urls()</strong> in our custom <strong class="source-inline">AdminSite</strong> class and adding the URL mapping there. This approach is demonstrated in the following code snippet:</p>
			<p class="source-code">class SysAdminSite(admin.AdminSite):</p>
			<p class="source-code">    def get_urls(self):</p>
			<p class="source-code">        base_urls = super().get_urls(). # Get the existing set of URLs</p>
			<p class="source-code">        # Define our URL patterns for custom views</p>
			<p class="source-code">        urlpatterns = [path("health_dashboard/"),\</p>
			<p class="source-code">                           (self.system_health_dashboard)]</p>
			<p class="source-code">        # Return the updated mapping</p>
			<p class="source-code">        return base_urls + urlpatterns. </p>
			<p>The <strong class="source-inline">get_urls()</strong> method is generally called automatically by Django and there is no need to perform any manual processing on it.</p>
			<p>Once this is done, the last step involves making sure that our custom admin view is only accessible through the admin site and non-admin users should not be able to access it. Let's take a look at how that can be achieved.</p>
			<h2 id="_idParaDest-298"><a id="_idTextAnchor313"/>Restricting Custom Views to the Admin Site</h2>
			<p>If you followed all the previous sections thoroughly, you would now have a custom <strong class="source-inline">AdminSite</strong> view ready for use. However, there is a small glitch. This view is also directly accessible to any user who is not on the admin site.</p>
			<p>To ensure that such a situation does not arise, we need to restrict this view to the admin site. This can be achieved quite simply by wrapping our URL path inside the <strong class="source-inline">admin_view()</strong> call, as shown in the following code snippet:</p>
			<p class="source-code">urlpatterns = [self.admin_view\</p>
			<p class="source-code">               (path("health_dashboard/"),\</p>
			<p class="source-code">               (self.system_health_dashboard))]</p>
			<p>The <strong class="source-inline">admin_view</strong> function makes sure the path provided to it is restricted just to the admin dashboard and that no non-admin-privilege user can access it.</p>
			<p>Now, let's add a new custom view to our admin site.</p>
			<h2 id="_idParaDest-299"><a id="_idTextAnchor314"/>Exercise 10.04: Adding Custom Views to the Admin Site</h2>
			<p>In this exercise, you will add a custom view to the admin site, which will render a user profile and will show the user the options to modify their email or add a new profile picture. To build this custom view, follow the steps described:</p>
			<ol>
				<li value="1">Open the <strong class="source-inline">admin.py</strong> file under the <strong class="source-inline">bookr_admin</strong> directory and add the following imports. These will be required to build our custom view inside the admin site application:<p class="source-code">from django.template.response import TemplateResponse</p><p class="source-code">from django.urls import path</p></li>
				<li>Open the <strong class="source-inline">admin.py</strong> file under the <strong class="source-inline">bookr_admin</strong> directory and create a new method named <strong class="source-inline">profile_view</strong>, which takes in a <strong class="source-inline">request</strong> variable as its parameter, inside the <strong class="source-inline">BookrAdmin</strong> class:<p class="source-code">def profile_view(self, request):</p><p>Next, inside the method, get the name of the current application and set that in the <strong class="source-inline">request</strong> context. For this, you can use the <strong class="source-inline">name</strong> property of the class, which is auto-populated by Django. To get this property and set it in your <strong class="source-inline">request</strong> context, you need to add the following line:</p><p class="source-code">request.current_app = self.name</p><p>Once you have the application name populated to the request context, the next step is to fetch the template variables, which are required to render the contents, such as <strong class="source-inline">site_title</strong>, <strong class="source-inline">site_header</strong>, and more, in the admin templates. For this, leverage the <strong class="source-inline">each_context()</strong> method of the <strong class="source-inline">AdminSite</strong> class, which provides the dictionary of the admin site template variables from the class:</p><p class="source-code">context = self.each_context(request)</p><p>Once you have the data in place, the last step is to return a <strong class="source-inline">TemplateResponse</strong> object, which will render the custom profile template when someone visits the URL endpoint mapped to your custom view:</p><p class="source-code">return TemplateResponse(request, "admin/admin_profile.html", \</p><p class="source-code">                        context)</p></li>
				<li>With the view function now created, the next step is to make <strong class="source-inline">AdminSite</strong> return the URLs mapping the view to a path inside <strong class="source-inline">AdminSite</strong>. To do this, you need to create a new method with the name <strong class="source-inline">get_urls()</strong>, which overrides the <strong class="source-inline">AdminSite.get_urls()</strong> method and returns the mapping of your new view. This can be done by first creating a new method named <strong class="source-inline">get_urls()</strong> inside the <strong class="source-inline">BookrAdmin</strong> class you have created for your custom admin site:<p class="source-code">def get_urls(self):</p><p>Inside this method, the first thing you need to do is to get the list of the URLs that are already mapped to the admin endpoint. This is a required step, otherwise, your custom admin site will not be able to load any results associated with the model editing pages, logout page, and so on, in case this mapping is lost. To get this mapping, call the <strong class="source-inline">get_urls()</strong> method of the base class from which the <strong class="source-inline">BookrAdmin</strong> class is derived:</p><p class="source-code">urls = super().get_urls()</p><p>Once the URLs from the base class are captured, the next step is to create a list of URLs that map our custom view to a URL endpoint in the admin site. For this, we create a new list named <strong class="source-inline">url_patterns</strong> and map our <strong class="source-inline">profile_view</strong> method to the <strong class="source-inline">admin_profile</strong> endpoint. To do this, we use the <strong class="source-inline">path</strong> utility function from Django, which allows us to map the view function with a string-based API endpoint path:</p><p class="source-code">url_patterns = [path("admin_profile", self.profile_view)]</p><p class="source-code">return urls + url_patterns</p><p>Save the <strong class="source-inline">admin.py</strong> file. It should look like this: <a href="http://packt.live/38Jlyvz">http://packt.live/38Jlyvz</a>. </p></li>
				<li>Now, with the <strong class="source-inline">BookrAdmin</strong> class configured for the new view, the next step is to create your template for the admin profile page. For this, create a new file named <strong class="source-inline">admin_profile.html</strong> under the <strong class="source-inline">templates/admin</strong> directory of your project root. Inside this file, first, add an <strong class="source-inline">extend</strong> tag to make sure that you are extending from the default <strong class="source-inline">admin</strong> template:<p class="source-code">{% extends "admin/index.html" %}</p><p>This step ensures that all of your admin template style sheets and HTML are available for use inside your custom view template. For example, without having this <strong class="source-inline">extend</strong> tag, your custom view will not show any specific content already mapped to your admin site, such as <strong class="source-inline">site_header</strong>, <strong class="source-inline">site_title</strong>, or any links to log out or go to another page.</p><p>Once the extend tag is added, add a <strong class="source-inline">block</strong> tag and provide it with the value of content. This makes sure that the code you add between the pair of <strong class="source-inline">{% block content %}…{% endblock %}</strong> segments overrides whatever value is present in the <strong class="source-inline">index.html</strong> template that comes pre-packaged with the Django admin module:</p><p class="source-code">{% block content %}</p><p>Inside the <strong class="source-inline">block</strong> tag, add the HTML required to render the profile view that was created in <em class="italic">step 2</em> of this exercise:</p><p class="source-code">&lt;p&gt;Welcome to your profile, {{ username }}&lt;/p&gt;</p><p class="source-code">&lt;p&gt;You can do the following operations&lt;/p&gt;</p><p class="source-code">&lt;ul&gt;</p><p class="source-code">    &lt;li&gt;&lt;a href="#"&gt;Change E-Mail Address&lt;/a&gt;&lt;/li&gt;</p><p class="source-code">    &lt;li&gt;&lt;a href="#"&gt;Add Profile Picture&lt;/a&gt;&lt;/li&gt;</p><p class="source-code">&lt;/ul&gt;</p><p class="source-code">{% endblock %}</p><p>The file should look like this: <a href="http://packt.live/2MZhU8d">http://packt.live/2MZhU8d</a>.</p></li>
				<li>Now, with the preceding steps complete, reload your application server by running <strong class="source-inline">python manage.py runserver localhost:8000</strong> and then visiting <strong class="source-inline">http://localhost:8000/admin/admin_profile</strong>.<p>When the page opens, you can expect to see something like the following screenshot:</p><div id="_idContainer358" class="IMG---Figure"><img src="image/B15509_10_07.jpg" alt="Figure 10.7: Profile page view in the administration site&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 10.7: Profile page view in the administration site</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The view created so far will render just fine irrespective of whether the user is logged into the admin application.</p>
			<p>To make sure that this view is only accessible to the logged-in admins, you need to make a small modification inside your <strong class="source-inline">get_urls()</strong> method, which you defined in <em class="italic">step 3</em> of this exercise.</p>
			<p>Inside the <strong class="source-inline">get_urls()</strong> method, modify the <strong class="source-inline">url_patterns</strong> list to look something like the one shown here:</p>
			<p class="source-code">url_patterns = [path("admin_profile", \</p>
			<p class="source-code">                self.admin_view(self.profile_view)),]</p>
			<p>In the preceding code, you wrapped your <strong class="source-inline">profile_view</strong> method inside the <strong class="source-inline">admin_view()</strong> method.</p>
			<p>The <strong class="source-inline">AdminSite.admin_view()</strong> method causes the view to be restricted to those users who are logged in. If a user who is currently not logged into the admin site tries to visit the URL directly, they will get redirected to the login page, and only in the event of a successful login will they be allowed to see the contents of our custom page.</p>
			<p>During this exercise, we leveraged our existing understanding of writing views for Django applications and merged it with the context of the <strong class="source-inline">AdminSite</strong> class to build a custom view for our admin dashboard. With this knowledge, we can now move on and add useful functionalities to our Django admin to supercharge its usefulness. </p>
			<h2 id="_idParaDest-300"><a id="_idTextAnchor315"/>Passing Additional Keys to the Templates Using Template Variables</h2>
			<p>Inside the admin site, the variable values passed to the templates are passed through the use of template variables. These template variables are prepared and returned by the <strong class="source-inline">AdminSite.each_context()</strong> method.</p>
			<p>Now, if there is a value that you would like to pass to all the templates of your admin site, you can override the <strong class="source-inline">AdminSite.each_context()</strong> method and add the required fields to the <strong class="source-inline">request</strong> context. Let's look at an example to see how we can achieve this outcome.</p>
			<p>Consider the <strong class="source-inline">username</strong> field, which we passed to our <strong class="source-inline">admin_profile</strong> template earlier. If we want to pass it to every template inside our custom admin site, we first need to override the <strong class="source-inline">each_context()</strong> method inside our <strong class="source-inline">BookrAdmin</strong> class, as shown here:</p>
			<p class="source-code">def each_context(self, request):</p>
			<p class="source-code">        context = super().each_context(request)</p>
			<p class="source-code">        context['username'] = request.user.username</p>
			<p class="source-code">        return context</p>
			<p>The <strong class="source-inline">each_context()</strong> method takes a single argument (we're not considering self here) of the <strong class="source-inline">HTTPRequest</strong> type, which it uses to evaluate certain other values.</p>
			<p>Now, inside our overridden <strong class="source-inline">each_context()</strong> method, we first make a call to the base class <strong class="source-inline">each_context()</strong> method so as to retrieve the <strong class="source-inline">context</strong> dictionary for the admin site:</p>
			<p class="source-code">context = super().each_context(request)</p>
			<p>Once that is done, the next thing we do is to add our <strong class="source-inline">username</strong> field to the <strong class="source-inline">context</strong> and set its value to the value of the <strong class="source-inline">request.user.username</strong> field:</p>
			<p class="source-code">context['username'] = request.user.username</p>
			<p>Once this is done, the last thing that remains is to return this modified context.</p>
			<p>Now, whenever a template is rendered by our custom admin site, the template will be passed with this additional username variable.</p>
			<h2 id="_idParaDest-301"><a id="_idTextAnchor316"/>Activity 10.01: Building a Custom Admin Dashboard with Built-In Search</h2>
			<p>In this activity, you will use the knowledge you gained about the different aspects of creating a custom admin site to build a custom admin dashboard for Bookr. Inside this dashboard, you will introduce the capability of allowing a user to search the books by using either the name of the book or by using the name of the book publisher and allowing the user to modify or delete these book records.</p>
			<p>The following steps will help you build a custom admin dashboard and add the ability to search a book record by using the name of the publisher:</p>
			<ol>
				<li value="1">Create a new application inside the Bookr project named <strong class="source-inline">bookr_admin</strong>, if not created already. This is going to store the logic for our custom admin site.</li>
				<li>Inside the <strong class="source-inline">admin.py</strong> file under the <strong class="source-inline">bookr_admin</strong> directory, create a new class, <strong class="source-inline">BookrAdmin</strong>, which inherits from the <strong class="source-inline">AdminSite</strong> class of Django's admin module.</li>
				<li>Inside the newly created <strong class="source-inline">BookrAdmin</strong> class in <em class="italic">step 2</em>, add any customizations for the site title or any other branding component of the admin dashboard.</li>
				<li>Inside the <strong class="source-inline">apps.py</strong> file under the <strong class="source-inline">bookr_admin</strong> directory, create a new <strong class="source-inline">BookrAdminConfig</strong> class, and inside this new <strong class="source-inline">BookrAdminConfig</strong> class, set the default site attribute to the fully qualified module name for our custom admin site class, <strong class="source-inline">BookrAdmin</strong>.</li>
				<li>Inside the <strong class="source-inline">settings.py</strong> file of your Django project, add the fully qualified path of the <strong class="source-inline">BookrAdminConfig</strong> class created in <em class="italic">step 4</em> as the first installed application.</li>
				<li>To register the <strong class="source-inline">Books</strong> model from the <strong class="source-inline">reviews</strong> application inside Bookr, open the <strong class="source-inline">admin.py</strong> file inside the reviews directory and make sure that the Books model is registered to the admin site by using <strong class="source-inline">admin.site.register(ModelClass)</strong>.</li>
				<li>To allow a search of the book according to the name of the publisher, inside the <strong class="source-inline">admin.py</strong> file of the <strong class="source-inline">reviews</strong> application, modify the <strong class="source-inline">BookAdmin</strong> class and add to it a property named <strong class="source-inline">search_fields</strong>, which contains <strong class="source-inline">publisher_name</strong> as a field.</li>
				<li>To get the publisher's name correctly for the <strong class="source-inline">search_fields</strong> property, introduce a new method named <strong class="source-inline">get_publisher</strong> inside the <strong class="source-inline">BookAdmin</strong> class, which will return the name field of the publisher from the <strong class="source-inline">Book</strong> model.</li>
				<li>Make sure that the <strong class="source-inline">BookAdmin</strong> class is registered as a Model admin class for the Book model inside our Django admin dashboard by using <strong class="source-inline">admin.site.register(Book, BookModel)</strong>.</li>
			</ol>
			<p>After completing this activity, once you start the application server and visit <strong class="source-inline">http://localhost:8000/admin</strong> and navigate to the Book model, you should be able to search for books by using the publisher's name and, in the event of a successful search, see a page that resembles the one shown in the following screenshot: </p>
			<div>
				<div id="_idContainer359" class="IMG---Figure">
					<img src="image/B15509_10_08.jpg" alt="Figure 10.8: Book editing page inside the Bookr administration dashboard&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.8: Book editing page inside the Bookr administration dashboard</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution to this activity can be found at <a href="http://packt.live/2Nh1NTJ">http://packt.live/2Nh1NTJ</a>.</p>
			<h1 id="_idParaDest-302"><a id="_idTextAnchor317"/>Summary</h1>
			<p>In this chapter, we looked at how Django allows the customization of its admin site. It does so by providing easy-to-use properties for some of the more general parts of the site, such as title fields, headings, and home links. Beyond this, we learned how to build a custom admin site by leveraging the concepts of object-oriented programming in Python and creating a child class of <strong class="source-inline">AdminSite</strong>.</p>
			<p>This functionality was further enhanced by implementing a custom template for the logout page. We also learned how we can supercharge our admin dashboard by adding a new set of views to allow enhanced usage of the dashboard.</p>
			<p>As we move on to the next chapter, we will build upon what we have learned so far by learning how to create our own custom tags and filters for templates. Furthermore, using class-based views, we will gain the ability to build our views in an object-oriented style.</p>
		</div>
		<div>
			<div id="_idContainer361" class="Content">
			</div>
		</div>
	</body></html>