<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-48"><a id="_idTextAnchor049"/>3</h1>
<h1 id="_idParaDest-49"><a id="_idTextAnchor050"/>Creating Your Add-Ons</h1>
<p>Add-ons are extensions that expand the capabilities of Blender and can be enabled in the preferences. Some <a id="_idIndexMarker149"/>of them, such as Math Vis, encountered in <a href="B18375_02.xhtml#_idTextAnchor033"><em class="italic">Chapter 2</em></a>, are official features distributed as optional functionalities. Others are third-party expansions that can be installed by a user.</p>
<p>At their core, add-ons are Python modules that contain information used by Blender to install, enable, and remove them like in a plugin system.</p>
<p>In this chapter, you will learn how to write and install an add-on in Blender, and how to enable add-ons while they are still in the making. We will also implement a new command that groups objects into collections and make it part of the object context menu.</p>
<p>This chapter will cover the following topics:</p>
<ul>
<li>Scripting Blender extensions</li>
<li>Running and updating our add-on</li>
<li>Fixing errors and improving our code</li>
</ul>
<h1 id="_idParaDest-50"><a id="_idTextAnchor051"/>Technical requirements</h1>
<p>We will use Blender and <strong class="bold">Visual Studio Code</strong> (<strong class="bold">VS Code</strong>). The examples created in this chapter can be found at <a href="https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch3">https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch3</a>.</p>
<h1 id="_idParaDest-51"><a id="_idTextAnchor052"/>Installing our add-ons in Blender</h1>
<p>We can write a very <a id="_idIndexMarker150"/>simple add-on using VS Code. This add-on doesn’t really do anything; it just shows up in the extensions list.</p>
<p>First, we must create a folder for the code of this chapter. We can use the file manager or the navigation sidebar that comes with most IDEs. In this example, we will use VS Code, which we met in the <em class="italic">External editors</em> section of <a href="B18375_01.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>:</p>
<ol>
<li>Open your <strong class="bold">PythonScriptingBlender</strong> project in VS Code.</li>
<li>Create a new folder by clicking the <strong class="bold">New </strong><strong class="bold">Folder</strong> icon.</li>
</ol>
<div><div><img alt="Figure 3.1: Creating a folder in Visual Studio Code" height="203" src="img/Figure_3.01_B18375.jpg" width="639"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1: Creating a folder in Visual Studio Code</p>
<ol>
<li value="3">Name the new folder <code>ch3</code>.</li>
</ol>
<p>Now, we can <a id="_idIndexMarker151"/>create a Python file for our add-on:</p>
<ol>
<li>Make sure the <code>ch3</code> folder is selected in the <strong class="bold">VS Code</strong> explorer, and then create a new file by clicking the <strong class="bold">New </strong><strong class="bold">File</strong> icon.</li>
</ol>
<div><div><img alt="Figure 3.2: Creating a file in VS Code" height="216" src="img/Figure_3.02_B18375.jpg" width="638"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2: Creating a file in VS Code</p>
<ol>
<li value="2">Name the new file <code>the_simplest_add_on.py</code>.</li>
<li>Open the file via a double click.</li>
</ol>
<p>We are ready to <a id="_idIndexMarker152"/>write our add-on; let’s look at what is required.</p>
<h2 id="_idParaDest-52"><a id="_idTextAnchor053"/>Add-on requirements</h2>
<p>To be considered an <a id="_idIndexMarker153"/>add-on, our code must contain three things:</p>
<ul>
<li><strong class="bold">Script meta info</strong> – that is, information about the add-on</li>
<li>A <code>register()</code> function to enable the add-on</li>
<li>An <code>unregister()</code> function to disable the add-on</li>
</ul>
<h3>Script meta info</h3>
<p>The information displayed in the preferences tab comes from the <code>bl_info</code> variable, a dictionary <a id="_idIndexMarker154"/>located at the top of the <code>.py</code> file. The dictionary must contain the name of the author, a short description of the add-on, and the version of Blender for which it is written. Here is the info for our simple add-on:</p>
<pre class="source-code">
bl_info = {
    "name": "The Simplest Add-on",
    "author": "John Doe",
    "version": (1, 0),
    "blender": (3, 00, 0),
    "description": "A very simple add-on",
    "warning": "This is just for Learning",
    "category": "Learning",
}</pre>
<p class="callout-heading">Start with a blank!</p>
<p class="callout">It is better to leave a blank line at the start and the end of our code – <code>.py</code> files that do not start with a blank line might fail to register as add-ons and cause a <code>missing </code><code>bl_info</code> error.</p>
<h3>Registration</h3>
<p>The <code>register()</code> function is <a id="_idIndexMarker155"/>executed when an add-on is enabled. There is not much going on for now – only a <code>pass</code> statement, as our function doesn’t do anything:</p>
<pre class="source-code">
def register():
    # this function is called when the add-on is enabled
    pass</pre>
<p>The <code>unregister()</code> function is <a id="_idIndexMarker156"/>invoked when the add-on is disabled. Much like <code>register()</code>, it doesn’t do anything yet, but it is required as an add-on:</p>
<pre class="source-code">
def unregister():
    # this function is called when the add-on is disabled
    pass</pre>
<h2 id="_idParaDest-53"><a id="_idTextAnchor054"/>Installation</h2>
<p>Now, it’s time <a id="_idIndexMarker157"/>to install our add-on in Blender:</p>
<ol>
<li>Open the preferences window via <strong class="bold">Edit</strong> | <strong class="bold">Preferences</strong> from the top menu.</li>
<li>Select the <strong class="bold">Add-ons</strong> tab in the left column.</li>
<li>Click the <strong class="bold">Install</strong> button at the top right of the add-ons preferences.</li>
<li>In the file browser, navigate to <code>PythonScriptingBlender\ch3</code> and select <code>the_simplest_add_on.py</code>.</li>
<li>Click the <strong class="bold">Install Add-on</strong> button at the bottom</li>
</ol>
<p>Our add-on has been copied and installed in Blender; the filter entry on the top left is filled so that only the new add-on is displayed. We can click the add-on checkbox to enable it. Expanding the disclosure triangle displays more information from <code>bl_info</code>.</p>
<div><div><img alt="Figure 3.3: A very simple add-on as listed in Blender" height="498" src="img/Figure_3.3_B18375.jpg" width="1353"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3: A very simple add-on as listed in Blender</p>
<p>The <code>warning</code> entry <a id="_idIndexMarker158"/>from our dictionary is displayed with a triangle icon. That line is to warn the users of potentially unstable code.</p>
<p>Now that our add-on has served its purpose, it’s time to remove it.</p>
<h2 id="_idParaDest-54"><a id="_idTextAnchor055"/>Uninstall</h2>
<p>Clicking the big <strong class="bold">Remove</strong> button <a id="_idIndexMarker159"/>in the add-on preferences will display a confirmation dialog that asks whether it is fine to delete the add-on. This operation cannot be undone, but in this case, it is fine to go along and remove <strong class="bold">The </strong><strong class="bold">Simplest Add-on</strong>:</p>
<div><div><img alt="Figure 3.4: Add-on removal in Blender" height="677" src="img/Figure_3.4_B18375.jpg" width="1353"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.4: Add-on removal in Blender</p>
<p>The path displayed in the <strong class="bold">Remove</strong> dialog informs that the add-on was installed inside Blender user <a id="_idIndexMarker160"/>preferences. That’s not always the case, as we will see how to point the scripts path to our working directory in the next paragraph.</p>
<h2 id="_idParaDest-55"><a id="_idTextAnchor056"/>The scripts path</h2>
<p>Reinstalling an add-on <a id="_idIndexMarker161"/>at every change during development would end up <a id="_idIndexMarker162"/>being impractical. Programmers usually set up a <strong class="bold">system path</strong> for Python scripts and <a id="_idIndexMarker163"/>work on their add-ons from there.</p>
<p>System paths can be found in <strong class="bold">Blender Preferences</strong>, by choosing the <strong class="bold">File Paths</strong> tab in the left column.</p>
<div><div><img alt="Figure 3.5: The File Paths preferences window" height="917" src="img/Figure_3.5_B18375.jpg" width="1402"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.5: The File Paths preferences window</p>
<p>We can set this path <a id="_idIndexMarker164"/>to the directory that we will use for scripting, such <a id="_idIndexMarker165"/>as the <code>PythonScriptingBlender/ch3</code> folder that hosts the code of this chapter.</p>
<h3>The addons folder</h3>
<p>Now that blender <a id="_idIndexMarker166"/>will look in our scripting folder, we can create a directory for our add-ons. We can do that from VS Code:</p>
<ol>
<li>Select <code>PythonScriptingBlender/ch3</code> in VS Code.</li>
<li>Create a new folder by clicking the <strong class="bold">New </strong><strong class="bold">Folder</strong> icon.</li>
<li>Name the new folder <code>addons</code>.</li>
</ol>
<p>It is important that <code>addons</code> is the exact name of this folder; otherwise, Blender will not look for extensions. We need to restart Blender for the <strong class="bold">File Paths</strong> settings to take effect, but once we <a id="_idIndexMarker167"/>do, Blender will be able to load the add-ons on which we are working, with no installation needed.</p>
<p>Now, we can work on a new add-on that adds functionality to Blender. In the next section, we will write an add-on that groups the objects of a scene into collections.</p>
<h1 id="_idParaDest-56"><a id="_idTextAnchor057"/>Creating our first add-on – object collector</h1>
<p>We are going to <a id="_idIndexMarker168"/>write an add-on that groups the objects of a scene in <a id="_idIndexMarker169"/>collections that reflect their type – one collection for all the meshes, one for all the lights, one for the curves, and so on.</p>
<p>Since we have set up <code>PythonScriptingBlender/ch3</code> as the directory for our add-ons, we will proceed in VS Code:</p>
<ol>
<li>Select <code>PythonScriptingBlender/ch3/addons</code> in VS Code.</li>
<li>Create a new file by clicking the <strong class="bold">New </strong><strong class="bold">File</strong> icon.</li>
<li>Name the new file <code>object_collector.py</code>.</li>
<li>Open the file via a double click.</li>
</ol>
<p>This Python script’s name starts with <code>object</code>, since it affects object data. It is a <em class="italic">soft convention</em>, as this filename scheme is suggested but not enforced.</p>
<p>At this stage, the add-on is very similar to the previous one – we haven’t added any code yet. Note how, besides the obvious difference in names and descriptions, we haven’t put a <code>warning</code> entry – we intend to make a non-experimental add-on:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">object_collector.py</p>
<pre class="source-code">
bl_info = {
    "name": "Collector",
    "author": "John Doe",
    "version": (1, 0),
    "blender": (3, 00, 0),
    "description": "Create collections for object types",
    "category": "Object",
}
def register():
    # this function is called when the add-on is enabled
    pass
def unregister():
    # this function is called when the add-on is disabled
    pass</pre>
<p class="callout-heading">Remove carefully!</p>
<p class="callout">It is better to not remove add-ons loaded from the script path using the <strong class="bold">Remove</strong> button – we risk erasing our working (and perhaps only) copy!</p>
<p>Blender will show <a id="_idIndexMarker170"/>up this add-on in the preferences panel. In <a id="_idIndexMarker171"/>order to add functionalities, our add-on <a id="_idIndexMarker172"/>must contain an <strong class="bold">operator</strong>. Operators are the entities that carry on the execution of code; we will now learn how to write them.</p>
<h2 id="_idParaDest-57"><a id="_idTextAnchor058"/>Operators</h2>
<p>The <code>Operator</code> class allows <a id="_idIndexMarker173"/>calling functions from the graphic <a id="_idIndexMarker174"/>interface. They are, essentially, commands that can be run in Blender.</p>
<p>Therefore, we <a id="_idIndexMarker175"/>subclass the <code>bpy.types.Operator</code> class <a id="_idIndexMarker176"/>to make our code available to users.</p>
<h3>Operator requirements</h3>
<p>A class deriving <code>bpy.types.Operators</code> must <a id="_idIndexMarker177"/>implement these members:</p>
<ul>
<li>A static string named <code>bl_idname</code> that contains a unique name by which the operator goes internally</li>
<li>A static string named <code>bl_label</code> that contains the displayed name of the operator</li>
<li>A <code>poll()</code> class method that verifies that the conditions for executing the operator are met and return either <code>True</code> or <code>False</code></li>
<li>An <code>execute()</code> method that runs when the operator is executed, returning a set of possible running states</li>
<li>Optionally, a docstring that Blender will display as additional information</li>
</ul>
<p>We are going to fill in this information so that our add-on will contain an operator that can be executed.</p>
<h2 id="_idParaDest-58"><a id="_idTextAnchor059"/>Writing a basic operator</h2>
<p>Let’s start to create <a id="_idIndexMarker178"/>our operator class. Following the Blender guidelines, the name <a id="_idIndexMarker179"/>starts with <code>OBJECT_OT</code>. Soon after the (optional) docstring comes <code>bl_idname</code> and <code>bl_label</code>, the two attributes that Blender uses respectively as an identifier and description of the operator:</p>
<pre class="source-code">
class OBJECT_OT_collector_types(bpy.types.Operator):
    """Create collections based on objects types"""
    bl_idname = "object.pckt_type_collector"
    bl_label = "Create Type Collections"
    @classmethod
    def poll(cls, context):
        return False
    def execute(self, context):
        # our code goes here
        return {'FINISHED'}</pre>
<p>The <code>poll()</code> and <code>execute()</code> methods, at this stage, neither allow nor perform any action. We are going <a id="_idIndexMarker180"/>to implement them in the following pages, using what <a id="_idIndexMarker181"/>we have learned in <a href="B18375_02.xhtml#_idTextAnchor033"><em class="italic">Chapter 2</em></a>, when dealing with Blender data.</p>
<h3>Implementing the poll() method</h3>
<p><code>poll()</code> verifies <a id="_idIndexMarker182"/>that the conditions for running the operator are <a id="_idIndexMarker183"/>met. That restricts the possibility of error and makes the intended use of the operator more evident. This method is marked with a <code>@classmethod</code> decorator that allows us to validate the conditions before the operator is run.</p>
<p>Since our operator collects objects in the scene, we should not be able to use it if the scene is empty:</p>
<pre class="source-code">
    @classmethod
    def poll(cls, context):
        return len(context.scene.objects) &gt; 0</pre>
<h3>Implementing the execute() method</h3>
<p>After an operator is <a id="_idIndexMarker184"/>invoked, Blender runs <a id="_idIndexMarker185"/>its <code>execute()</code> method. This <code>execute()</code> function contains our operations. Breaking them down into single steps will help to code them in Python.</p>
<h4>Planning our execution</h4>
<p>We must know what <a id="_idIndexMarker186"/>to expect when we execute our operator. For instance, running it on the default scene, we would end up with three new collections – <strong class="bold">Mesh</strong> for the <strong class="bold">Cube</strong> object, <strong class="bold">Camera</strong> for the <strong class="bold">Camera</strong> object, and <strong class="bold">Light</strong> for the <strong class="bold">Light</strong> object.</p>
<div><div><img alt="Figure 3.6: The expected result after running Collector" height="240" src="img/Figure_3.6_B18375.jpg" width="481"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.6: The expected result after running Collector</p>
<p>There is more <a id="_idIndexMarker187"/>than one way to reach this result, but to accomplish it by hand, we will need to create the <strong class="bold">Mesh</strong>, <strong class="bold">Light</strong>, and <strong class="bold">Camera</strong> collections and bring each object under each one of them.</p>
<p>Now, we will translate these actions into Python.</p>
<h4>Writing the execution code</h4>
<p>We have seen in <a href="B18375_02.xhtml#_idTextAnchor033"><em class="italic">Chapter 2</em></a> how new <a id="_idIndexMarker188"/>collections can be created and linked to <code>scene.collection.children</code>:</p>
<pre class="source-code">
    def execute(self, context):
        mesh_cl = bpy.data.collections.new("Mesh")
        light_cl = bpy.data.collections.new("Light")
        cam_cl = bpy.data.collections.new("Camera")
        context.scene.collection.children.link(mesh_cl)
        context.scene.collection.children.link(light_cl)
        context.scene.collection.children.link(cam_cl)</pre>
<p>Then, we can process the objects using a <code>for</code> loop:</p>
<pre class="source-code">
        for ob in context.scene.objects:
            if ob.type == 'MESH':
                mesh_cl.objects.link(ob)
            elif ob.type == 'LIGHT':
                light_cl.objects.link(ob)
            elif ob.type == 'CAMERA':
                cam_cl.objects.link(ob)</pre>
<p>Finally, we always return an operation state when we exit the function:</p>
<pre class="source-code">
        return {'FINISHED'}</pre>
<p>This operator is still <a id="_idIndexMarker189"/>in progress and needs refining, but we can already use it. To do that, we must inform Blender of its existence using the <code>register_class()</code> function from <code>bpy.utils</code>.</p>
<h2 id="_idParaDest-59"><a id="_idTextAnchor060"/>Loading operators in our add-on</h2>
<p>Our add-on adds an <a id="_idIndexMarker190"/>operator to Blender when <a id="_idIndexMarker191"/>enabled and removes it when it is disabled. This is done via the <code>bpy.utils.register_class()</code> and <code>bpy.utils.unregister_class()</code> functions that we call, respectively, inside the add-on’s <code>register()</code> and <code>unregister()</code> functions:</p>
<pre class="source-code">
def register():
    bpy.utils.register_class(OBJECT_OT_collector_types)
def unregister():
    bpy.utils.unregister_class(OBJECT_OT_collector_types)</pre>
<p>Enabling the <strong class="bold">Collector</strong> add-on will add <strong class="bold">Create Type Collections</strong> to Blender and allow you to call it from the user interface.</p>
<h1 id="_idParaDest-60"><a id="_idTextAnchor061"/>Running our add-on</h1>
<p>Even if we have <a id="_idIndexMarker192"/>yet to add any graphic element, our add-on is ready for its first launch. We can use two tricks in order to run add-ons that are not yet listed, which is quite common in development.</p>
<h2 id="_idParaDest-61"><a id="_idTextAnchor062"/>Refreshing the add-on list</h2>
<p>Since we have <a id="_idIndexMarker193"/>added a new script folder and just changed its content, we need to either restart Blender or refresh the add-on information. To do that, we can click the <strong class="bold">Refresh</strong> button at the top right in the <strong class="bold">Add-ons</strong> preferences window.</p>
<div><div><img alt="Figure 3.7: The Collector add-on, loaded from the project folder" height="441" src="img/Figure_3.7_B18375.jpg" width="1322"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.7: The Collector add-on, loaded from the project folder</p>
<p>If we start typing the name of our add-on in the filter bar, the entries in the list will narrow down until <strong class="bold">Collector</strong> becomes <a id="_idIndexMarker194"/>easy to find and enable. Now, it’s time to execute our operator via the <strong class="bold">Blender </strong><strong class="bold">Source Bar</strong>.</p>
<h2 id="_idParaDest-62"><a id="_idTextAnchor063"/>Running from the Search Toolbar</h2>
<p>Operators that <a id="_idIndexMarker195"/>are not part of any graphic element are for internal usage – that is, callable by other operators but not by the user.</p>
<p>To make every operator searchable, make sure that <strong class="bold">Developers Extra</strong> is enabled in the <strong class="bold">Preferences</strong> | <strong class="bold">Interface</strong> tab, as we did in <a href="B18375_02.xhtml#_idTextAnchor033"><em class="italic">Chapter 2</em></a>. If this option is active, here is how we can call our operator:</p>
<ol>
<li>Press the <em class="italic">F3</em> button.</li>
<li>Start typing <code>create type</code>, and the operator will show up in the search box.</li>
</ol>
<div><div><img alt="Figure 3.8: The Create Type Collections operator, showing up in the search bar" height="288" src="img/Figure_3.8_B18375.jpg" width="993"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.8: The Create Type Collections operator, showing up in the search bar</p>
<ol>
<li value="3">Click on the <a id="_idIndexMarker196"/>operator to execute it.</li>
</ol>
<p>We can see in the outliner that our operator succeeded.</p>
<div><div><img alt="" height="508" src="img/Figure_3.9_B18375.jpg" width="524"/>
</div>
</div>
<p class="IMG---Figure">figure 3.9: Each object is grouped under its type collection</p>
<p>Our add-on is at an early stage; it has a few bugs and limitations that we are going to fix. For instance, the <strong class="bold">Mesh</strong>, <strong class="bold">Light</strong>, and <strong class="bold">Camera</strong> collections are created without checking whether they already exist, which will create duplicates. Also, we are only handling these three <a id="_idIndexMarker197"/>categories, skipping <strong class="bold">Curves</strong>, <strong class="bold">Armatures</strong>, and all the other object types entirely.</p>
<p>Nevertheless, if we are using version control for our folder, as seen in <a href="B18375_01.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, we can commit our new files. We are going to improve our add-on in the next section.</p>
<h1 id="_idParaDest-63"><a id="_idTextAnchor064"/>Improving our code</h1>
<p>Fixing bugs or starting with a row prototype that will be completed at a later stage is common practice in <a id="_idIndexMarker198"/>development. In this section, we will complete our add-on to its finished form, reload it in Blender, and deal with the versioning of the scripts path.</p>
<h2 id="_idParaDest-64"><a id="_idTextAnchor065"/>Saving our edits automatically</h2>
<p>The <strong class="bold">Auto Save</strong> option <a id="_idIndexMarker199"/>will make VS Code save every file change to disk automatically. To activate this option, follow these steps:</p>
<ol>
<li>Open the <strong class="bold">File</strong> menu in the <strong class="bold">Visual Studio Code</strong> menu bar.</li>
<li>Click on <strong class="bold">Auto Save</strong> to enable this entry.</li>
</ol>
<p>There are developers that prefer to save manually to have more control of their files. Which solution is better depends on personal tastes and workflows. Generally, if version control is used, the advantage of <strong class="bold">Auto Save</strong> outweighs the danger of unwanted changes.</p>
<p>In some cases, we want to turn off version control on specific files. For instance, there are files that Python generates when it executes code; we have no interest in tracking them. In the following paragraph, we are going to see how to ignore specific files.</p>
<h2 id="_idParaDest-65"><a id="_idTextAnchor066"/>Ignoring bytecode files (.pyc)</h2>
<p>If we execute code from <a id="_idIndexMarker200"/>our development <a id="_idIndexMarker201"/>folder, the <code>.pyc</code> file, along with our <code>.</code><code>py</code> files.</p>
<div><div><img alt="Figure 3.10: A temporary .pyc file can be seen alongside our scripts" height="461" src="img/Figure_3.10_B18375.jpg" width="920"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.10: A temporary .pyc file can be seen alongside our scripts</p>
<p>When a <code>.py</code> file is <a id="_idIndexMarker202"/>executed, Python translates it to <a id="_idIndexMarker203"/>an internal format and saves it as <code>.pyc</code>. We don’t need to concern ourselves with <code>.pyc</code> files, and usually, we don’t need to keep track of them.</p>
<h3>Creating a .gitignore file</h3>
<p>A text file named <code>.gitignore</code>, containing the names of files and directories that we don’t want to track, will <a id="_idIndexMarker204"/>have an immediate effect when placed in a version control-managed folder. We can create it manually or follow these steps inside VS Code:</p>
<ol>
<li>In the <code>.pyc</code> file listed under <strong class="bold">Changes</strong>.</li>
<li>From the context menu, select <strong class="bold">Add </strong><strong class="bold">to .gitignore</strong>.</li>
</ol>
<div><div><img alt="Figure 3.11: Adding to the git ignore list in VS Code" height="926" src="img/Figure_3.11_B18375.jpg" width="920"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.11: Adding to the git ignore list in VS Code</p>
<ol>
<li value="3">Once the<code>.gitignore</code> file is created, the <code>.pyc</code> file stops showing up in the changes.</li>
<li>If we open <a id="_idIndexMarker205"/>the <code>.gitignore</code> file, we will see that it contains the full path of the <code>.</code><code>pyc</code> file:</li>
</ol>
<pre class="source-code">
ch3/addons/__pycache__/object_collector.cpython-39.pyc</pre>
<ol>
<li value="5">We don’t need to ignore that specific file; we can blacklist all the directories called <code>__pycache__</code>. To do that, we take the following code:<pre class="source-code">
ch3/addons/__pycache__/object_collector.cpython-39.pyc</pre></li>
</ol>
<p>And change it to this, then save:</p>
<pre class="source-code">
__pycache__</pre>
<p>Source control applies to the <code>.gitignore</code> file itself; we have to stage and commit this file, along with the other changes made in this chapter.</p>
<div><div><img alt="Figure 3.12: Staging the current changes for this chapter" height="834" src="img/Figure_3.12_B18375.jpg" width="920"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.12: Staging the current changes for this chapter</p>
<p>Once we have <a id="_idIndexMarker206"/>committed our changes, we can go back to working on our script, fixing its flows, and expanding its capabilities. We will see how simplifying the logic of a script improves readability, behavior, and functionality at the same time.</p>
<h2 id="_idParaDest-66"><a id="_idTextAnchor067"/>Fixing the operator logic</h2>
<p>The most <a id="_idIndexMarker207"/>evident flow in our operator is that it tries to recreate <a id="_idIndexMarker208"/>existing collections. Running it twice in a row creates the <strong class="bold">Mesh.001</strong> and <strong class="bold">Light.001</strong> collections, and so on.</p>
<div><div><img alt="Figure 3.13: Unwanted collections are created" height="159" src="img/Figure_3.13_B18375.jpg" width="511"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.13: Unwanted collections are created</p>
<h3>Avoiding duplicate collections</h3>
<p>We should <a id="_idIndexMarker209"/>create the mesh collection only if it doesn<a id="_idTextAnchor068"/>’t exist already. Note the following:</p>
<pre class="source-code">
mesh_cl = bpy.data.collections.new("Mesh")</pre>
<p>Instead of that, we should create a new one, only if looking it up causes a <code>KeyError</code> error:</p>
<pre class="source-code">
try:
    mesh_cl = bpy.data.collections.new['Mesh']
except KeyError:
    mesh_cl = bpy.data.collections.new("Mesh")</pre>
<p>To be more generic, we can write a function that takes the collection name as an argument.</p>
<p>The function presented in the following code block starts with a very descriptive docstring that can help to give a better idea of what a function should do and how to implement it:</p>
<pre class="source-code">
def get_collection(name):
    '''Returns the collection named after the given
    argument. If it doesn't exist, a new collection
    is created and linked to the scene'''
    try:
        return bpy.data.collections[name]
    except KeyError:
        cl = bpy.data.collections.new(name)
        bpy.context.scene.collection.children.link(cl)
        return cl</pre>
<h3>Querying object types</h3>
<p>We could create <a id="_idIndexMarker210"/>unique collections using the preceding function – for instance, <code>get_collection("Mesh")</code> – but we don’t need to mention the object type explicitly; the <code>Object.type</code> parameter returns the type as a string:</p>
<pre class="source-code">
&gt;&gt;&gt; bpy.data.objects['Cube'].type
'MESH'</pre>
<p>Strings can also be formatted nicely via their <code>.</code><code>title()</code> method:</p>
<pre class="source-code">
&gt;&gt;&gt; bpy.data.objects['Cube'].type.title()
'Mesh'</pre>
<p>Here is our operator execution block after the rewrite:</p>
<pre class="source-code">
    @staticmethod
    def get_collection(name):
        '''Returns the collection named after the given
        argument. If it doesn't exist, a new collection
        is created and linked to the scene'''
        try:
            return bpy.data.collections[name]
        except KeyError:
            cl = bpy.data.collections.new(name)
            bpy.context.scene.collection.children.link(cl)
            return cl
    def execute(self, context):
        for ob in context.scene.objects:
            cl = self.get_collection(ob.type.title())
            cl.objects.link(ob)
    return {'FINISHED'}</pre>
<p>This version is more <a id="_idIndexMarker211"/>elegant and supports objects of any type. There is still a bug that we will fix shortly. Before we come to that, we need to reload the script to use this new version.</p>
<h2 id="_idParaDest-67"><a id="_idTextAnchor069"/>Reloading scripts</h2>
<p>Blender and Python <a id="_idIndexMarker212"/>store used scripts in memory; therefore, changes made to the code will not have an immediate effect. There is a Blender command that reloads the scripts, which we can look up in the search bar:</p>
<ol>
<li>Press the <em class="italic">F3</em> key to go to the search bar.</li>
<li>Start typing <code>reload scr</code> in the search field.</li>
<li>Click the operator, <strong class="bold">script.reload · </strong><strong class="bold">Reload Scripts</strong>.</li>
</ol>
<div><div><img alt="Figure 3.14: Invoking the Reload Scripts operator" height="158" src="img/Figure_3.14_B18375.jpg" width="984"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.14: Invoking the Reload Scripts operator</p>
<p>This command reloads all the scripts and spares us from having to restart Blender every time. Our add-ons now use the latest <code>.py</code> files on disk, and we can verify that our collections are created only once.</p>
<h2 id="_idParaDest-68"><a id="_idTextAnchor070"/>Avoiding re-assignment errors</h2>
<p>While <a id="_idIndexMarker213"/>executing <code>RuntimeError</code> error. We’ll see this error pop up if we run our operator a second time:</p>
<pre class="source-code">
    cl.objects.link(ob)
RuntimeError: Object 'Cube' already in collection 'Mesh'</pre>
<p>We need to enclose object linking in a <code>try</code>/<code>catch</code> statement to avoid that:</p>
<pre class="source-code">
            cl.objects.link(ob)</pre>
<p>This should be replaced with the following:</p>
<pre class="source-code">
            try:
                cl.objects.link(ob)
            except RuntimeError:
                continue</pre>
<p>This way, no <a id="_idIndexMarker214"/>action is taken for objects that were already collected and the operator moves on to the rest of the scene.</p>
<p class="callout-heading">Don’t try too hard!</p>
<p class="callout">We should always make sure that the actions contained inside a <code>try</code> block are minimal – these statements should not be used lightly. There is no obvious rule, but if we are trying more than two lines in a block, we should probably rethink our code so that it is less error-prone.</p>
<h2 id="_idParaDest-69"><a id="_idTextAnchor071"/>Our final operator</h2>
<p>We can add more objects to <a id="_idIndexMarker215"/>the scene by invoking the <strong class="bold">Add</strong> menu from the viewport or using the <em class="italic">Shift</em> + <em class="italic">A</em> shortcut. We can add objects of different types, such as <strong class="bold">Text</strong>, <strong class="bold">Speaker</strong>, <strong class="bold">Empty</strong> | <strong class="bold">Plain Axes</strong>, and even a few new meshes such as <strong class="bold">Cylinder</strong> and <strong class="bold">Sphere</strong>, and run <strong class="bold">Create Type Collections</strong> again. We can see that each object is assigned to a collection named after its type.</p>
<div><div><img alt="Figure 3.15: Every object type gets its own collection" height="480" src="img/Figure_3.15_B18375.jpg" width="472"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.15: Every object type gets its own collection</p>
<p>The nice thing is we didn’t have to account manually for all the object types – once a procedural <a id="_idIndexMarker216"/>workflow is in place, it will work with objects of all types, even those that will be added in future releases of Blender.</p>
<p>Our operator is complete; what is missing is an easy way to invoke it. We will finish the chapter by learning how to display an operator inside a menu of the interface.</p>
<h2 id="_idParaDest-70"><a id="_idTextAnchor072"/>Extending menus</h2>
<p>Menus present many advantages – they are everywhere in the application, they cover a specific aspect of <a id="_idIndexMarker217"/>the 3D workflow, and new items can be added easily. We are going to handle the addition and removal of new menu entries in our add-on – our operator will be displayed only when our add-on is enabled.</p>
<h3>Draw functions</h3>
<p>Blender menus accept new <a id="_idIndexMarker218"/>items in the form of functions. These functions describe how a menu should draw a new entry; they must accept the <code>self</code> and <code>context</code> arguments passed by their menu and have the following form:</p>
<pre class="source-code">
def draw_menu_item(self, context):
    row = self.layout.row()</pre>
<p>We will gain a better grasp of UI elements in <a href="B18375_05.xhtml#_idTextAnchor100"><em class="italic">Chapter 5</em></a>. For now, we <a id="_idIndexMarker219"/>will only add our operator to a menu row. This is how our function will look:</p>
<pre class="source-code">
def draw_collector_item(self, context):
    row = self.layout.row()
    row.operator(OBJECT_OT_collector_types.bl_idname)</pre>
<p>We can now append this function to a Blender menu and let it display our operator.</p>
<h3>Adding menu entries</h3>
<p>Blender menus <a id="_idIndexMarker220"/>are stored in the <code>bpy.types</code> namespace. By convention, the name of a menu type follows the following scheme:</p>
<pre class="source-code">
bpy.types.[AREA]_MT_[NAME]</pre>
<p>For instance, menus in the 3D view start with <code>bpy.types.VIEW3D_MT_</code>. Typing that in the Python console and pressing <em class="italic">Tab</em> will show the menus available in the viewport as a suggestion:</p>
<pre class="source-code">
&gt;&gt;&gt; bpy.types.VIEW3D_MT_
                        add(
                        angle_control(
                        armature_add(
                        …</pre>
<p>Since <code>bpy.types.VIEW3D_MT_object</code> menus:</p>
<pre class="source-code">
&gt;&gt;&gt; bpy.types.VIEW3D_MT_object
                              (
                              _animation(
                              _apply(
                              _asset(
                              …
                              _context_menu(</pre>
<p>The <code>bpy.types.VIEW3D_MT_object</code> is the <code>VIEW3D_MT_pose_context_menu</code>. We use this one in our example, but we could very well use any other menu.</p>
<p>The <code>append()</code> and <code>remove()</code> methods add and remove a draw function from a menu. That can <a id="_idIndexMarker221"/>be done in the <code>register()</code>/<code>unregister()</code> functions of our add-on, so it becomes the following:</p>
<pre class="source-code">
def register():
    bpy.utils.register_class(OBJECT_OT_collector_types)
    menu = bpy.types.VIEW3D_MT_object_context_menu
    menu.append(draw_collector_item)
def unregister():
    bpy.utils.unregister_class(OBJECT_OT_collector_types)
    menu = bpy.types.VIEW3D_MT_object_context_menu
    menu.remove(draw_collector_item)</pre>
<p>Reloading the scripts, and invoking the right-click menu while in <strong class="bold">Object Mode</strong> displays our option at the bottom. Now that there is a way to invoke our operator in the UI, we can consider our add-on complete and commit our changes.</p>
<div><div><img alt="Figure 3.16: Our operator added to the context menu" height="257" src="img/Figure_3.16_B18375.jpg" width="390"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.16: Our operator added to the context menu</p>
<h1 id="_idParaDest-71"><a id="_idTextAnchor073"/>Summary</h1>
<p>In this chapter, we have coded a complete add-on that expands Blender functionalities and integrates seamlessly into an application. We have also learned how to work on our code while it is being used and improve our tools through consecutive steps of refinement.</p>
<p>In <a href="B18375_04.xhtml#_idTextAnchor075"><em class="italic">Chapter 4</em></a><em class="italic">,</em> we will learn how to affect the position and rotation of Blender objects via Python, and we will add interactive properties to our operator.</p>
<h1 id="_idParaDest-72"><a id="_idTextAnchor074"/>Questions</h1>
<ol>
<li>What is the difference between a Python script and a Blender add-on?</li>
<li>Which advantages does an add-on provide over sparse code?</li>
<li>What do operators do?</li>
<li>How do we define the conditions under which an operator can be executed?</li>
<li>Can we work on an add-on while it is being used? How do we update it?</li>
<li>How do we ignore bytecode (<code>.pyc</code>) files in Git version control?</li>
<li>How do we avoid creating duplicates?</li>
</ol>
</div>
</div></body></html>