- en: '*Chapter 8*: Working with the Django REST Framework'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第8章*：使用Django REST框架'
- en: This chapter will focus on working with an **Application Programming Interface**
    (**API**). An API is actually a set of tools and communication protocols working
    to allow two different applications to communicate with each other effectively;
    it is what acts as the middleman between two systems. A **REST API** adopts the
    design principles set forth in a **Representational State Transfer** (**REST**)
    software architecture and is most commonly used with web-based applications. Every
    time we mention the word API in this chapter, we are really referring to a REST
    API as they are technically slightly different but usually interpreted as the
    same thing.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将专注于使用**应用程序编程接口**（**API**）。API实际上是一套工具和通信协议，旨在允许两个不同的应用程序有效地相互通信；它是作为两个系统之间的中间人。**REST
    API**采用**表示状态传输**（**REST**）软件架构中提出的设计原则，并且通常与基于Web的应用程序一起使用。在本章中，每次提到API这个词时，我们实际上是在指REST
    API，因为它们在技术上略有不同，但通常被视为同一事物。
- en: 'Django itself relies on third-party packages to work with an existing API or
    to create an API yourself. A common Python package that is available is called
    the `requests` package. The `requests` package is used to send and receive requests
    to and from an existing API found on the server side. More information about this
    package can be found here: [https://pypi.org/project/requests/](https://pypi.org/project/requests/).
    On the other hand, a JavaScript-based framework, such as React, AngularJS, or
    Vue.js, to name a few, will all perform these requests on the client side, within
    the user’s browser. There is no right or wrong way to communicate with an API,
    in terms of choosing tools that operate on the client versus the server side.
    Those decisions are made as a result of the technical requirements obtained for
    your project. We won’t actually be using the `requests` package or any of the
    client-side JavaScript-based frameworks; instead, we will focus on just the **Django
    REST framework**, which is used to build a model-based API for the models we previously
    created.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Django本身依赖于第三方包来与现有的API交互或自己创建API。一个常见的Python包叫做`requests`包。`requests`包用于向服务器端现有的API发送和接收请求。有关此包的更多信息，请参阅[https://pypi.org/project/requests/](https://pypi.org/project/requests/)。另一方面，基于JavaScript的框架，如React、AngularJS或Vue.js等，都会在用户的浏览器中客户端执行这些请求。在客户端与服务器端选择操作API的工具方面，没有正确或错误的方式。这些决定是根据为您的项目获得的技术要求做出的。我们实际上不会使用`requests`包或任何客户端JavaScript框架；相反，我们将专注于**Django
    REST框架**，它用于为我们之前创建的模型构建基于模型的API。
- en: The Django REST framework is licensed as open source, allowing developers to
    use it within their commercial or private applications. It is used to construct
    APIs based on the models of a Django project, where endpoints execute HTTP requests
    that perform `requests` package, but it won’t hurt either if you use this package
    in combination with the framework, which is sometimes done in projects. This chapter
    will focus entirely on using the Django REST framework to create an API for all
    of the vehicle models that we created in [*Chapter 3*](B17243_03_ePub.xhtml#_idTextAnchor077),
    *Models, Relations, and Inheritance*. We will be serializing those models and
    registering URL patterns, which are the API endpoints, to views and viewsets that
    we write. We will also be using routers to generate some of those URL patterns
    for us, based entirely on the data that exists in our database tables.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Django REST框架作为开源软件授权，允许开发者在他们的商业或私人应用程序中使用它。它用于根据Django项目的模型构建API，其中端点执行HTTP请求，执行`requests`包，但如果您将此包与框架结合使用，这在项目中有时也会这样做，这也不会有害。本章将完全专注于使用Django
    REST框架为我们创建的车辆模型创建API，这些模型在[*第3章*](B17243_03_ePub.xhtml#_idTextAnchor077)“模型、关系和继承”中创建。我们将序列化这些模型，并将URL模式（即API端点）注册到我们编写的视图和视图集中。我们还将使用路由器为我们生成一些这些URL模式，完全基于我们数据库表中的数据。
- en: 'In this chapter, we will cover the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Installing and configuring the Django REST framework
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装和配置Django REST框架
- en: Serializing related models of a project
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列化项目中的相关模型
- en: Using the browsable API, a tool provided by the Django REST framework
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Django REST框架提供的可浏览API工具
- en: Creating SPA-style pages
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建SPA风格的页面
- en: Creating custom API endpoints
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义API端点
- en: Performing API requests using token authentication measures
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用令牌认证措施执行API请求
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To work with the code in this chapter, the following tools will need to be
    installed on your local machine:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用本章中的代码，您需要在本地机器上安装以下工具：
- en: Python version 3.9 – used as the underlying programming language for the project
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python版本3.9 – 作为项目的底层编程语言
- en: Django version 4.0 – used as the backend framework of the project
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Django版本4.0 – 作为项目的后端框架
- en: pip package manager – used to manage third-party Python/Django packages
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: pip包管理器 – 用于管理第三方Python/Django包
- en: We will continue to work with the solution created in [*Chapter 2*](B17243_02_ePub.xhtml#_idTextAnchor037),
    *Project Configuration*. However, it is not necessary to use the Visual Studio
    IDE. The main project itself can be run using another IDE or run independently
    using a terminal or command-line window from within the project root folder, which
    is where the `manage.py` file resides. Whatever editor or IDE you are using, a
    virtual environment will also be needed to work with the Django project. Instructions
    for how to create a project and virtual environment can be found in [*Chapter
    2*](B17243_02_ePub.xhtml#_idTextAnchor037), *Project Configuration*. You will
    need a database to store the data contained in your project. PostgreSQL was chosen
    for the examples in the previous chapter; however, any database type that you
    choose for your project can be used to work with the examples in this chapter.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用[*第2章*](B17243_02_ePub.xhtml#_idTextAnchor037)，*项目配置*中创建的解决方案。然而，没有必要使用Visual
    Studio IDE。主要项目本身可以使用其他IDE运行，或者从项目根目录（其中包含`manage.py`文件）独立运行，使用终端或命令行窗口。无论您使用什么编辑器或IDE，都需要虚拟环境来与Django项目一起工作。有关如何创建项目和虚拟环境的说明可以在[*第2章*](B17243_02_ePub.xhtml#_idTextAnchor037)，*项目配置*中找到。您需要一个数据库来存储项目中的数据。在上一章的示例中选择了PostgreSQL；然而，您可以为项目选择任何数据库类型来使用本章中的示例。
- en: 'We will also be using data that is in the form of a Django fixture, provided
    in [*Chapter 3*](B17243_03_ePub.xhtml#_idTextAnchor077), *Models, Relations, and
    Inheritance*, in the subsection titled *Loading the chapter_3 data fixture*. Make
    sure the `chapter_3` fixture is loaded into your database. If this has already
    been done, then you may skip the next command. If you have already created the
    tables found in [*Chapter 3*](B17243_03_ePub.xhtml#_idTextAnchor077), *Models,
    Relations, and Inheritance*, and have not loaded that fixture yet, then run the
    following command, after activating your virtual environment:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用以Django fixture形式提供的数据，这些数据包含在[*第3章*](B17243_03_ePub.xhtml#_idTextAnchor077)，*模型、关系和继承*，的子标题*加载chapter_3数据fixture*中。请确保`chapter_3`
    fixture已加载到您的数据库中。如果已经完成，则可以跳过下一个命令。如果您已经创建了[*第3章*](B17243_03_ePub.xhtml#_idTextAnchor077)，*模型、关系和继承*中提到的表，并且尚未加载该fixture，那么在激活您的虚拟环境后，请运行以下命令：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'All of the code created in this chapter can be found in the GitHub repository
    for this book: [https://github.com/PacktPublishing/Becoming-an-Enterprise-Django-Developer](https://github.com/PacktPublishing/Becoming-an-Enterprise-Django-Developer).
    The bulk of the code depicted in this chapter can be found in the `/becoming_a_django_entdev/becoming_a_django_entdev/chapter_8/`
    directory.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中创建的所有代码都可以在本书的GitHub仓库中找到：[https://github.com/PacktPublishing/Becoming-an-Enterprise-Django-Developer](https://github.com/PacktPublishing/Becoming-an-Enterprise-Django-Developer)。本章中展示的大部分代码可以在`/becoming_a_django_entdev/becoming_a_django_entdev/chapter_8/`目录中找到。
- en: 'Check out the following video to see the *Code in Action*: [https://bit.ly/3Ojocdx](https://bit.ly/3Ojocdx).'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 观看以下视频以查看*代码的实际应用*：[https://bit.ly/3Ojocdx](https://bit.ly/3Ojocdx)。
- en: Preparing for this chapter
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为本章做准备
- en: Start by creating a new app in your project called `chapter_8` by following
    the steps discussed in [*Chapter 2*](B17243_02_ePub.xhtml#_idTextAnchor037), *Project
    Configuration*, in the subsection titled *Creating a Django app*. As discussed
    in that section, don’t forget to change the value of the `name =` variable for
    your app class found in the `/becoming_a_django_entdev/becoming_a_django_entdev/chapter_8/apps.py`
    file to now point to the path where you installed your app. Be sure to also include
    this app in the `INSTALLED_APPS` variable found in the `settings.py` file as well.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，按照在[*第2章*](B17243_02_ePub.xhtml#_idTextAnchor037)中讨论的步骤，在项目中创建一个名为`chapter_8`的新应用。正如该部分所讨论的，不要忘记将`/becoming_a_django_entdev/becoming_a_django_entdev/chapter_8/apps.py`文件中您的应用类中的`name
    =`变量的值更改为指向您安装应用的位置。务必还将此应用包含在`settings.py`文件中的`INSTALLED_APPS`变量中。
- en: 'In the main `urls.py` file of the site, add the following path, which points
    to the URL patterns of this chapter that we will be creating:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在站点的`urls.py`主文件中，添加以下路径，该路径指向我们将要创建的本章的URL模式：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Installing the Django REST framework
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Django REST框架
- en: 'To install the Django REST framework in any Django project and enable the bare-minimum
    settings needed to begin working with it, follow these steps:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要在任何Django项目中安装Django REST框架并启用开始使用它所需的最小设置，请按照以下步骤操作：
- en: 'Add the `djangorestframework`, `markdown`, and `django-filter` packages to
    your `requirements.txt` file and install them in your virtual environment using
    your IDE or command line. You can also run the following individual `pip` commands.
    Use the first of the following commands to activate your virtual environment:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`djangorestframework`、`markdown`和`django-filter`包添加到您的`requirements.txt`文件中，并使用您的IDE或命令行在虚拟环境中安装它们。您也可以运行以下单独的`pip`命令。使用以下命令中的第一个来激活您的虚拟环境：
- en: '[PRE11]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: There is no need to run the Django migration commands when installing these
    three packages as no additional tables will be created by them.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装这三个包时，无需运行Django迁移命令，因为它们不会创建任何额外的表。
- en: 'Next, in your `settings.py` file, add the following app to the `INSTALLED_APPS`
    list. Then, add the `REST_FRAMEWORK` dictionary, including the `DjangoModelPermissionsOrAnonReadOnly`
    permission class shown here:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在您的`settings.py`文件中，将以下应用添加到`INSTALLED_APPS`列表中。然后，添加包含在此处显示的`DjangoModelPermissionsOrAnonReadOnly`权限类的`REST_FRAMEWORK`字典：
- en: '[PRE12]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This permission class allows us to check for model-based CRUD rights and allows
    anonymous users to only view or read items. For a complete breakdown of the over
    half-dozen other permission classes, visit [https://www.django-rest-framework.org/api-guide/permissions/](https://www.django-rest-framework.org/api-guide/permissions/).
    We will only be working with one permission class throughout this chapter.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 此权限类允许我们检查基于模型的CRUD权限，并允许匿名用户仅查看或读取项目。有关其他六个以上权限类的完整说明，请访问[https://www.django-rest-framework.org/api-guide/permissions/](https://www.django-rest-framework.org/api-guide/permissions/)。在本章中，我们只将与一个权限类一起工作。
- en: 'You will need to register the URL patterns related to this framework’s authentication
    mechanisms. In your `/chapter_8/urls.py` file, add the following `include` pattern,
    along with a home page and Django admin site links for this chapter, as shown:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您需要注册与此框架的认证机制相关的URL模式。在您的`/chapter_8/urls.py`文件中，添加以下`include`模式，以及本章的主页和Django管理站点链接，如下所示：
- en: '[PRE13]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We also need to include the admin site URLs just like we did in [*Chapter 6*](B17243_06_ePub.xhtml#_idTextAnchor190),
    *Exploring the Django Admin Site*, for this chapter. If you have already placed
    this include statement in the main `urls.py` file of your project, then you do
    not need to include it again in the `chapter_8` app.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要像在[*第6章*](B17243_06_ePub.xhtml#_idTextAnchor190)中那样包含管理站点URL，即*探索Django管理站点*，对于本章也是如此。如果您已经在项目的`urls.py`主文件中放置了这个包含语句，那么您就不需要在`chapter_8`应用中再次包含它。
- en: Now, the Django REST framework is installed and ready to use in your project.
    Currently, we have no API URLs except for the authentication URLs that come with
    this framework. Currently, those authentication URLs don’t provide us with anything
    to do. You can navigate to the login page just to see whether it loads properly
    by visiting the URL `http://localhost:8000/api-auth/login/`. If you log in with
    your superuser account, there will currently be nothing to display and it will
    show you a **404 Page not found** message.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Django REST框架已安装并准备好在您的项目中使用。目前，我们除了这个框架附带的身份验证URL外没有API URL。目前，这些身份验证URL没有为我们提供任何操作。您可以通过访问URL
    `http://localhost:8000/api-auth/login/` 来导航到登录页面，以查看它是否正确加载。如果您使用超级用户账户登录，目前将没有任何内容显示，并且会显示一个**404页面未找到**的消息。
- en: Note
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The reason we enabled the Django admin site URL patterns for the `chapter_8`
    app is to be able to log into the Django admin site with a superuser account and
    authenticate a user when working with some of the exercises in this chapter. For
    those exercises, if you are not logged in, you will find a message in your results
    stating **Authentication credentials were not provided**. For other exercises
    toward the end of this chapter, you will not need to be logged into the Django
    admin site; authentication will be performed by using token-based authorization
    measures.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们启用`chapter_8`应用的Django管理站点URL模式的原因是能够使用超级用户账户登录Django管理站点并在处理本章的一些练习时验证用户。对于这些练习，如果您未登录，您将在结果中看到一个消息，指出**认证凭据未提供**。对于本章末尾的其他练习，您不需要登录Django管理站点；将通过基于令牌的授权措施进行认证。
- en: To begin using this framework and creating new API endpoints, we will start
    by creating a serializer class for each of the models created in [*Chapter 3*](B17243_03_ePub.xhtml#_idTextAnchor077),
    *Models, Relations, and Inheritance*.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用此框架并创建新的API端点，我们将从为[*第3章*](B17243_03_ePub.xhtml#_idTextAnchor077)中创建的每个模型创建序列化器类开始，*模型、关系和继承*。
- en: Serializing objects
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 序列化对象
- en: Creating an API starts with creating a serializer class and then creating a
    view, in particular a `ModelViewSet` view class. Serializing objects means converting
    a model object into JSON format to represent the data of that object. The last
    thing we need to do is create URL patterns that map to the view classes that we
    wrote; this will be done using URL routers. These URL patterns are considered
    your API endpoints.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 创建API的起点是创建一个序列化器类，然后创建一个视图，特别是`ModelViewSet`视图类。序列化对象意味着将模型对象转换为JSON格式以表示该对象的数据。我们需要做的最后一件事是创建URL模式，这些模式映射到我们编写的视图类；这将通过URL路由器来完成。这些URL模式被认为是您的API端点。
- en: 'One thing to note in this section is that we need to create serializers for
    all models that relate to other models when using related fields. This is why
    the following exercises will show examples for all four models of the `chapter_3`
    app. This has to be done in order to ensure that we do not get errors when using
    the Browsable API, which we will introduce later in this chapter, and when performing
    API requests. This means if you have multiple `Seller` that have been assigned
    a `Group` or `Permission`, that `Group` and/or `Permission` object will also have
    to be serialized. Remember, the `Seller` object replaced the default `User` object
    found in the `django.contrib.auth.models` library when we changed the `AUTH_USER_MODEL`
    setting to now equal `‘chapter_3.Seller’` in [*Chapter 3*](B17243_03_ePub.xhtml#_idTextAnchor077),
    *Models, Relations, and Inheritance*. Examples for serializing the `Group` or
    `Permission` objects are not shown because there is only one `Seller` provided
    in the `chapter_3` data fixture, as shown:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中需要注意的一点是，当使用相关字段时，我们需要为所有与其它模型相关的模型创建序列化器。这就是为什么以下练习将展示`chapter_3`应用中所有四个模型的示例。这必须做到，以确保我们在使用Browsable
    API时不会出错，我们将在本章后面介绍Browsable API，以及进行API请求时不会出错。这意味着如果您有多个被分配了`Group`或`Permission`的`Seller`，那么`Group`和/或`Permission`对象也必须进行序列化。记住，当我们将`AUTH_USER_MODEL`设置更改为现在等于`‘chapter_3.Seller’`时，`Seller`对象替换了`django.contrib.auth.models`库中找到的默认`User`对象，如[*第3章*](B17243_03_ePub.xhtml#_idTextAnchor077)中所述，*模型、关系和继承*。由于`chapter_3`数据固定中只提供了一个`Seller`，因此未显示序列化`Group`或`Permission`对象的示例：
- en: '![Figure 8.1 – chapter_3 data fixture – Seller object](img/Figure_8.01_B17243.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图8.1 – chapter_3数据固定 – 卖家对象](img/Figure_8.01_B17243.jpg)'
- en: Figure 8.1 – chapter_3 data fixture – Seller object
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 – chapter_3数据固定 – 卖家对象
- en: The `Seller` here is not assigned to a `Group` or `Permission`, so as a result,
    we should not experience errors in the following exercises. Instead, that `Seller`
    has the `is_superuser` field set to `true`, which allows us to perform all of
    the CRUD operations when logged into the Django admin site.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 此处的 `Seller` 没有分配到 `Group` 或 `Permission`，因此结果是我们不应该在以下练习中遇到错误。相反，该 `Seller`
    的 `is_superuser` 字段被设置为 `true`，这允许我们在登录 Django 管理站点时执行所有 CRUD 操作。
- en: Note
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you experience errors, either delete all but the `Seller` data shown previously
    or it is recommended to just create the additional serializers, viewsets, and
    routers for the `Group` and `Permission` objects. Follow the same code format
    that is used in the following examples. The same applies to the `ContentType`
    object found in the `django.contrib.contenttypes.models` library. This will be
    needed if you have a `depth` property defined in the `Meta` subclass of that serializer
    class, more specifically, if `depth` is set to a value of `2` or greater. We will
    discuss what this property does soon.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到错误，要么删除之前显示的所有除 `Seller` 数据之外的内容，或者建议只创建 `Group` 和 `Permission` 对象的附加序列化器、视图集和路由器。遵循以下示例中使用的相同代码格式。同样适用于
    `django.contrib.contenttypes.models` 库中找到的 `ContentType` 对象。如果你在该序列化器类的 `Meta`
    子类中定义了 `depth` 属性，更具体地说，如果 `depth` 设置为 `2` 或更大的值，这将需要。我们很快将讨论此属性的作用。
- en: Next, let’s begin writing our serializer and learn more about the classes that
    are available to use.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们开始编写我们的序列化器，并了解更多可用的类。
- en: The serializer classes
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 序列化器类
- en: 'The `rest_framework.serializers` library provides us with five classes, as
    follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`rest_framework.serializers` 库为我们提供了五个类，如下所示：'
- en: '`Serializer` – used when nesting `ManyToManyField`, `ForeignKey`, and `OneToOneField`
    relationships.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Serializer` – 用于嵌套 `ManyToManyField`、`ForeignKey` 和 `OneToOneField` 关系时使用。'
- en: '`ModelSerializer` – used to create serializers with fields that map directly
    to fields of models found in your project.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ModelSerializer` – 用于创建具有直接映射到项目中模型字段的序列化器。'
- en: '`HyperlinkedModelSerializer` – used to do everything the `ModelSerializer`
    class does, except it will generate a clickable link to each related object when
    viewed in the Browsable API, instead of displaying those objects as a numeric
    ID.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HyperlinkedModelSerializer` – 用于执行 `ModelSerializer` 类所做的所有操作，但它在 Browsable
    API 中查看时将为每个相关对象生成一个可点击的链接，而不是显示这些对象的数字 ID。'
- en: '`ListSerializer` – used to serialize multiple objects in one request and is
    often used by Django when `Serializer`, `ModelSerializer`, or `HyperlinkedModelSerializer`
    has been initialized with the `many=True` attribute defined.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ListSerializer` – 用于在一个请求中序列化多个对象，并且通常在 Django 中使用，当 `Serializer`、`ModelSerializer`
    或 `HyperlinkedModelSerializer` 已初始化为具有定义了 `many=True` 属性时。'
- en: '`BaseSerializer` – provided to allow developers the ability to create their
    own serialization and deserialization styles. This is similar to how the `BaseStorage`
    class is used in the Django messages framework, as discussed in [*Chapter 7*](B17243_07_ePub.xhtml#_idTextAnchor214),
    *Working with Messages, Email Notifications, and PDF Reports*, in the subsection
    titled *Message storage backends*.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BaseSerializer` – 提供给开发者创建他们自己的序列化和反序列化风格的能力。这与在 Django 消息框架中使用的 `BaseStorage`
    类类似，如在第 7 章[*“消息、电子邮件通知和 PDF 报告”*](B17243_07_ePub.xhtml#_idTextAnchor214)的子标题[*“消息存储后端”*]中讨论的那样。'
- en: 'Begin by following these steps to create a `ModelSerializer` class for each
    model created in [*Chapter 3*](B17243_03_ePub.xhtml#_idTextAnchor077), *Models,
    Relations, and Inheritance*, the `Engine`, `Vehicle`, `VehicleModel`, and `Seller`
    models:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，按照以下步骤为在[*第 3 章*](B17243_03_ePub.xhtml#_idTextAnchor077)中创建的每个模型创建 `ModelSerializer`
    类，包括 `Engine`、`Vehicle`、`VehicleModel` 和 `Seller` 模型：
- en: 'Create a new file in your `/becoming_a_django_entdev/chapter_8/` folder called
    `serializers.py`. Inside this file, add the following imports:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 `/becoming_a_django_entdev/chapter_8/` 文件夹中创建一个名为 `serializers.py` 的新文件。在此文件中，添加以下导入：
- en: '[PRE14]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In this file, add the `EngineSerializer` class shown here:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此文件中，添加以下所示的 `EngineSerializer` 类：
- en: '[PRE15]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In this file, add the `VehicleModelSerializer` class shown here:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此文件中，添加以下所示的 `VehicleModelSerializer` 类：
- en: '[PRE16]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In this file, add the `VehicleSerializer` class shown here:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此文件中，添加以下所示的 `VehicleSerializer` 类：
- en: '[PRE17]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In this file, add the `SellerSerializer` class shown here:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此文件中，添加以下所示的 `SellerSerializer` 类：
- en: '[PRE18]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You might notice that the preceding classes resemble some of the classes used
    in the exercises found in previous chapters. Here, we defined the fields using
    the `‘__all__’` value but we can provide a list of only the fields needed and
    the order in which we need them, as was done with the form classes of [*Chapter
    5*](B17243_05_ePub.xhtml#_idTextAnchor152), *Django Forms*.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到前面的类与之前章节中练习中使用的某些类相似。在这里，我们使用 `‘__all__’` 值定义了字段，但我们可以提供所需字段的列表以及它们的顺序，就像在
    [*第5章*](B17243_05_ePub.xhtml#_idTextAnchor152) 的表单类中那样，*Django 表单*。
- en: The Meta subclass
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`Meta` 子类'
- en: 'The `Meta` subclass provides additional options, similar to how we customized
    the `Meta` subclasses in the models written for [*Chapter 3*](B17243_03_ePub.xhtml#_idTextAnchor077),
    *Models, Relations, and Inheritance*. For a complete breakdown of all the `Meta`
    class options available and anything about serializers in general, visit [https://www.django-rest-framework.org/api-guide/serializers/](https://www.django-rest-framework.org/api-guide/serializers/).
    Other options include the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`Meta` 子类提供了额外的选项，类似于我们在为 [*第3章*](B17243_03_ePub.xhtml#_idTextAnchor077) 的
    *Models, Relations, and Inheritance* 编写的模型中自定义 `Meta` 子类的方式。有关所有 `Meta` 类选项的完整说明以及有关序列化器的一般信息，请访问[此处](https://www.django-rest-framework.org/api-guide/serializers/)。其他选项包括以下内容：'
- en: '`model` – used to specify the model class to map that serializer to.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`model` – 用于指定映射到该序列化器的模型类。'
- en: '`fields` – used to specify what fields, or all fields, to include in that serializer.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fields` – 用于指定在序列化器中包含哪些字段或所有字段。'
- en: '`validators` – used to add validation when performing a create or update operation.
    Similar to how form validation was used in [*Chapter 5*](B17243_05_ePub.xhtml#_idTextAnchor152),
    *Django Forms*, Django will rely on any constraints set at the database level
    first, and then it will check for validation applied at the serializer level.
    More information about serializer validators can be found here: [https://www.django-rest-framework.org/api-guide/validators/](https://www.django-rest-framework.org/api-guide/validators/).'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`validators` – 用于在创建或更新操作时添加验证。类似于在 [*第5章*](B17243_05_ePub.xhtml#_idTextAnchor152)
    的 *Django 表单* 中使用表单验证，Django 首先会依赖于在数据库级别设置的任何约束，然后它会检查序列化器级别上应用的验证。有关序列化器验证器的更多信息，请参阅[此处](https://www.django-rest-framework.org/api-guide/validators/)。'
- en: '`depth` – used to represent related objects as nested JSON instead of using
    the numeric ID up to the depth specified. The default value for this option is
    `0`.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`depth` – 用于将相关对象表示为嵌套 JSON，而不是使用指定深度的数字 ID。此选项的默认值为 `0`。'
- en: '`read_only_fields` – used to specify the fields that are read-only at the serializer
    level.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`read_only_fields` – 用于指定在序列化器级别上只读的字段。'
- en: '`extra_kwargs` – used to specify extra keyword arguments on specific fields
    within that serializer.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`extra_kwargs` – 用于在序列化器中的特定字段上指定额外的关键字参数。'
- en: '`list_serializer_class` – used to specify a custom `ListSerializer` that was
    created using the `ListSerializer` class. This is done when you need to modify
    the behavior of the `ListSerializer` class, such as performing custom validation
    on the entire set, for example, comparing values of nested objects versus performing
    field-level validation.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`list_serializer_class` – 用于指定使用 `ListSerializer` 类创建的自定义 `ListSerializer`。这通常在你需要修改
    `ListSerializer` 类的行为时进行，例如，在整个集合上执行自定义验证，例如比较嵌套对象的值或执行字段级别的验证。'
- en: Now that we have serializer classes to work with, we need to create a view class
    for them. We can do that with the `ModelViewSet` class provided by the Django
    REST framework.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了可以工作的序列化器类，我们需要为它们创建一个视图类。我们可以使用 Django REST 框架提供的 `ModelViewSet` 类来完成这个任务。
- en: The viewset classes
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图集类
- en: 'Instead of creating views/methods for each CRUD operation, the Django REST
    framework offers a class that combines them all into one. It starts by creating
    a view class within the `views.py` file, similar to what we did in [*Chapter 4*](B17243_04_ePub.xhtml#_idTextAnchor116),
    *URLs, Views, and Templates*, except they are constructed using one of the following
    viewset classes. The Django REST framework provides the following four viewset
    classes:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 与为每个 CRUD 操作创建视图/方法不同，Django REST 框架提供了一个将它们全部组合在一起的类。它首先在 `views.py` 文件中创建一个视图类，类似于我们在
    [*第4章*](B17243_04_ePub.xhtml#_idTextAnchor116) 的 *URLs, Views, and Templates*
    中所做的那样，除了它们是使用以下视图集类之一构建的。Django REST 框架提供了以下四个视图集类：
- en: '`GenericViewSet` – includes methods that perform certain operations, commonly
    used for creating APIs that are not model-based.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GenericViewSet` – 包含执行某些操作的方法，通常用于创建非基于模型的 API。'
- en: '`ModelViewSet` – this class includes all of the methods needed to perform CRUD
    operations and is intended to map directly to the models of your project.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ModelViewSet` – 这个类包括执行 CRUD 操作所需的所有方法，并旨在直接映射到您项目的模型。'
- en: '`ReadOnlyModelViewSet` – only provides read actions and all other methods will
    not be provided. This viewset is also intended to work with the models of your
    project.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReadOnlyModelViewSet` – 只提供读取操作，其他所有方法将不会提供。这个视图集也旨在与您项目的模型一起工作。'
- en: '`ViewSet` – used by developers to create custom viewsets similar to how the
    `BaseSerializer` and `BaseStorage` classes were used. This class does not provide
    any actions and those methods will have to be created by the developer in order
    to use this class.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ViewSet` – 开发者用来创建类似于 `BaseSerializer` 和 `BaseStorage` 类使用的自定义视图集。这个类不提供任何操作，这些方法将由开发者创建以便使用此类。'
- en: 'Follow these steps to prepare your viewset classes:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤准备您的视图集类：
- en: 'In your `/chapter_8/views.py` file, add the following imports:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的 `/chapter_8/views.py` 文件中，添加以下导入：
- en: '[PRE19]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In that same file, add the following `EngineViewSet` class, as shown:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一文件中，添加以下 `EngineViewSet` 类，如下所示：
- en: '[PRE20]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In that same file, add the following `VehicleModelViewSet` class, as shown:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一文件中，添加以下 `VehicleModelViewSet` 类，如下所示：
- en: '[PRE21]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In that same file, add the following `VehicleViewSet` class, as shown:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一文件中，添加以下 `VehicleViewSet` 类，如下所示：
- en: '[PRE22]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In that same file, add the following `SellerViewSet` class, as shown:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一文件中，添加以下 `SellerViewSet` 类，如下所示：
- en: '[PRE23]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In each class depicted, we define only three properties for each of those classes,
    the `queryset`, `serializer_class`, and `permission_classes` properties. In the
    preceding examples, we are only using the `all()` method to search for all records
    within that table. Instead of using the `all()` method, the `filter()` and `get()`
    functions can also be used to look up specific records. The `serializer_class`
    property is used to map your view to the serializer class that we constructed
    in the previous subsection; it maps to the model class that we are performing
    the query on. The `permission_classes` property is used to define the permissions
    for that request. Permissions differ from the authentication token that we will
    discuss toward the end of this chapter. Permissions ensure the user who is accessing
    the system is allowed to perform those specific CRUD operations on the model in
    question. These are the only three properties available and only the first two
    are required when using a `ModelViewSet` or `GenericViewSet` class; the last is
    optional. You can also customize these using a callable method or even override
    the default action methods yourself. To learn more about viewsets, visit [https://www.django-rest-framework.org/api-guide/viewsets/](https://www.django-rest-framework.org/api-guide/viewsets/).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个类中，我们只为这些类定义了三个属性，即 `queryset`、`serializer_class` 和 `permission_classes`
    属性。在前面的示例中，我们只使用了 `all()` 方法来搜索该表中所有记录。除了使用 `all()` 方法外，还可以使用 `filter()` 和 `get()`
    函数来查找特定记录。`serializer_class` 属性用于将视图映射到我们在前面的子节中构建的序列化器类；它映射到我们正在查询的模型类。`permission_classes`
    属性用于定义该请求的权限。权限与我们在本章末尾将要讨论的认证令牌不同。权限确保访问系统的用户被允许在所讨论的模型上执行那些特定的 CRUD 操作。这些属性只有三个，并且在使用
    `ModelViewSet` 或 `GenericViewSet` 类时，只有前两个是必需的；最后一个是可以选的。您还可以使用可调用方法自定义这些属性，甚至可以自己覆盖默认的操作方法。要了解更多关于视图集的信息，请访问
    [https://www.django-rest-framework.org/api-guide/viewsets/](https://www.django-rest-framework.org/api-guide/viewsets/)。
- en: Next, let’s configure those URL routers to map to the viewsets that we just
    created. These will be the API endpoints of your project.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们配置这些 URL 路由器以映射到我们刚刚创建的视图集。这些将是您项目的 API 端点。
- en: Using URL routers
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 URL 路由器
- en: URL routers are used as a way to prevent developers from having to write individual
    URL patterns for each of the CRUD operations pertaining to each model in your
    API. That can get very complicated after a while and the Django REST framework
    provides these URL routers as a means to automatically generate each endpoint
    for you.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: URL 路由器被用作一种防止开发者必须为 API 中每个模型相关的 CRUD 操作编写单独 URL 模式的手段。这可能会在一段时间后变得非常复杂，而 Django
    REST 框架提供这些 URL 路由器作为自动为您生成每个端点的一种方式。
- en: 'Follow these steps to configure your routers:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤配置您的路由器：
- en: 'In your `/chapter_8/urls.py` file, add the following `import` statements:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的`/chapter_8/urls.py`文件中，添加以下`import`语句：
- en: '[PRE24]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In that same file, add the following `router` and `register` statements:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一文件中，添加以下`router`和`register`语句：
- en: '[PRE25]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In that same file, include the following `include` path for your routers:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一文件中，包含以下`include`路径以供您的路由器使用：
- en: '[PRE26]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `include(router.urls)` path shown previously is placed between the `api-auth`
    path and below your admin and home page paths. A router variable is defined for
    each model using the `routers.DefaultRouter()` class provided by the Django REST
    framework. Each `router.register()` function creates a set of URL patterns for
    that model. For example, where the `engines` path is shown in this URL, `http://localhost:8000/chapter-8/engines/`,
    that is what is defined in the first parameter of the first register function,
    as `r’engines’`. The router generated a set of URL patterns, one for each object
    in that table, which gets added to your `urlpatterns` list using the `path(‘chapter-8/’,
    include(router.urls))` path. Adding `chapter-8` to this `path()` function is where
    we are telling Django to prefix `http://localhost:8000/chapter-8/` for every path
    created using this set of routers.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 之前显示的`include(router.urls)`路径位于`api-auth`路径和您的管理页面路径之间。对于每个模型，使用Django REST框架提供的`routers.DefaultRouter()`类定义一个路由器变量。每个`router.register()`函数为该模型创建一组URL模式。例如，在这个URL中显示的`engines`路径，即`http://localhost:8000/chapter-8/engines/`，这就是在第一个注册函数的第一个参数中定义的，即`r'engines'`。路由器生成了一组URL模式，每个模式对应表中的一个对象，这些模式通过使用`path('chapter-8/',
    include(router.urls))`路径添加到您的`urlpatterns`列表中。将`chapter-8`添加到这个`path()`函数中，就是告诉Django为使用这组路由器创建的每个路径添加前缀`http://localhost:8000/chapter-8/`。
- en: That’s it; you now have a very basic API to use with the four models created
    in [*Chapter 3*](B17243_03_ePub.xhtml#_idTextAnchor077), *Models, Relations, and
    Inheritance*. To test your API and see the data that would be sent and received
    in each request, we will use the Browsable API next, which is provided with the
    Django REST framework.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样；现在您已经有一个非常基础的API可以与在[*第3章*](B17243_03_ePub.xhtml#_idTextAnchor077)“模型、关系和继承”中创建的四个模型一起使用了。为了测试您的API并查看每个请求发送和接收的数据，我们将使用Django
    REST框架提供的可浏览API。
- en: Using the Browsable API
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用可浏览API
- en: '`chapter-8` path to the URL routers in the previous section, we activated that
    path as what is called the `http://localhost:8000/chapter-8/` to see these URLs,
    as depicted here:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中提到的`chapter-8`路径是URL路由器的路径，我们激活了该路径，称为`http://localhost:8000/chapter-8/`，以查看这些URL，如图所示：
- en: '![Figure 8.2 – The Browsable API – API root'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.2 – 可浏览API – API根'
- en: '](img/Figure_8.02_B17243.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.02_B17243.jpg)'
- en: Figure 8.2 – The Browsable API – API root
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 – 可浏览API – API根
- en: 'When building custom API endpoints, as we will do later in this chapter, you
    will likely not see them displayed in your API root. You’ll see that the serializers
    for the groups, permissions, and content types have all been included with the
    code of this book. There is a dropdown at the top right of every main router path
    that we created, to switch between the two formats, API and JSON, as shown in
    the following screenshot:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建自定义API端点时，就像我们在本章后面将要做的那样，您可能不会在API根中看到它们。您会看到，组、权限和内容类型的序列化器都包含在这本书的代码中。在每个主要路由路径的右上角有一个下拉菜单，可以在这两种格式之间切换，即API和JSON，如图所示：
- en: '![Figure 8.3 – The Browsable API – GET formats'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.3 – 可浏览API – GET格式'
- en: '](img/Figure_8.03_B17243.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.03_B17243.jpg)'
- en: Figure 8.3 – The Browsable API – GET formats
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 – 可浏览API – GET格式
- en: 'If using `HyperlinkedModelSerializer` to construct your serializer classes,
    each object will be displayed as a clickable URL versus an ID that is not clickable.
    The hyperlinked version is shown in the following screenshot, when visiting the
    main URL path that the router created for the `Seller` model at `http://localhost:8000/chapter-8/sellers/`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用`HyperlinkedModelSerializer`来构建您的序列化器类，每个对象将显示为可点击的URL，而不是不可点击的ID。超链接版本如图所示，当访问路由器为`Seller`模型在`http://localhost:8000/chapter-8/sellers/`创建的主要URL路径时：
- en: '![Figure 8.4 – The Browsable API – Sellers list'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.4 – 可浏览API – 卖家列表'
- en: '](img/Figure_8.04_B17243.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.04_B17243.jpg)'
- en: Figure 8.4 – The Browsable API – Sellers list
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 – 可浏览API – 卖家列表
- en: 'To view the same results as in the preceding screenshot, just change `ModelSerializer`
    to `HyperlinkedModelSerializer` in all of your serializer classes. Also, change
    your `SellerSerializer` class to exclude the fields shown in the following code
    in order to prevent an error indicating an incorrectly configured `lookup_field`,
    which is an advanced topic that goes beyond the scope of this book to resolve:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看与前面截图相同的结果，只需将所有序列化器类中的`ModelSerializer`更改为`HyperlinkedModelSerializer`。还将您的`SellerSerializer`类更改为排除以下代码中显示的字段，以防止出现指示配置错误的`lookup_field`的错误，这是一个超出本书范围的高级主题：
- en: '[PRE27]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'On each of the routers registered in the previous subsection, the main URL,
    such as the `http://localhost:8000/chapter-8/sellers/` link shown previously,
    will allow you to perform a create operation (a `POST` request) using the form
    at the bottom of that page. Just viewing this page performs a read operation (a
    `GET` request). A `http://localhost:8000/chapter-8/sellers/1/`, includes a form
    at the bottom of that page that will allow you to perform `PUT`, `PATCH`, and
    `DELETE` operations for the object being viewed, as shown here:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一小节中注册的每个路由器上，主URL，例如之前显示的`http://localhost:8000/chapter-8/sellers/`链接，将允许您使用该页面底部的表单执行创建操作（`POST`请求）。仅查看此页面就执行读取操作（`GET`请求）。`http://localhost:8000/chapter-8/sellers/1/`包括一个位于该页面底部的表单，允许您对该视图中的对象执行`PUT`、`PATCH`和`DELETE`操作，如下所示：
- en: '![Figure 8.5 – The Browsable API – Sellers detail'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.5 – 可浏览的API – 卖家详情'
- en: '](img/Figure_8.05_B17243.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_8.05_B17243.jpg)'
- en: Figure 8.5 – The Browsable API – Sellers detail
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5 – 可浏览的API – 卖家详情
- en: By default, Django will show the `Seller` that does not have superuser status,
    then that user/seller must have group or individual permission-level access granted
    in order to perform any of the CRUD operations on that model object. If a user/seller
    only has permission to do one thing and not the other, such as update but not
    delete or create and not update, then only those action buttons will appear. If
    you do not see any of the action buttons where you would expect to see them, double-check
    your permission settings for that user.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Django将显示没有超级用户状态的`Seller`，然后该用户/卖家必须获得组或个人权限级别访问权限才能对该模型对象执行任何CRUD操作。如果用户/卖家只有执行一项操作而没有执行另一项操作的权限，例如更新但不删除或创建但不更新，那么只会出现那些操作按钮。如果您没有看到您预期看到任何操作按钮，请仔细检查该用户的权限设置。
- en: Now that we have a working API and have explored how to use the Browsable API,
    let’s build pages that change content without needing to reload or redirect that
    page.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有一个工作的API并探索了如何使用可浏览的API，让我们构建不需要重新加载或重定向页面的内容更改页面。
- en: Building SPA-like pages
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建类似SPA的页面
- en: '**Single-Page App** (**SPA**) pages are web pages where content gets updated
    within containers/nodes rather than reloading or redirecting the page to display
    that data. Usually, some of the work of the server is offloaded to the client’s
    browser to perform these requests and/or render the HTML, usually with JavaScript
    or jQuery. When an event is triggered, such as the clicking of a button or submission
    of a form, JavaScript is used to obtain the data from the server and then render
    that content onto the page, wherever we want it to display.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**单页应用**（**SPA**）页面是内容在容器/节点内更新而不是重新加载或重定向页面以显示数据的网页。通常，服务器的一些工作会卸载到客户端浏览器来执行这些请求和/或渲染HTML，通常使用JavaScript或jQuery。当触发事件时，例如点击按钮或提交表单，JavaScript用于从服务器获取数据，然后将该内容渲染到页面上，无论我们希望在何处显示。'
- en: In this exercise, we will use the API endpoint of the `Seller` created by the
    router, at `http://localhost:8000/chapter-8/sellers/1/`, to render JSON as a string
    within a container found in the body of a query page. The query page is just a
    standard page that uses JavaScript to communicate with an API endpoint.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用由路由器创建的`Seller` API端点，在`http://localhost:8000/chapter-8/sellers/1/`，将JSON作为字符串渲染在查询页面体中的容器内。查询页面只是一个标准的页面，它使用JavaScript与API端点进行通信。
- en: Creating the view
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建视图
- en: In this subsection, we will build the view to handle a page where the user can
    enter a number relating to the ID of a `Seller` that they want to query. This
    will be known as the `GetSellerView` class and it will be used as the backbone
    for the remaining two exercises of this chapter.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们将构建视图来处理用户可以输入与想要查询的`Seller` ID相关的数字的页面。这将是`GetSellerView`类，它将作为本章剩余两个练习的骨干使用。
- en: 'To get started, take the following step:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，请执行以下步骤：
- en: 'Open the `/chapter_8/views.py` file and add the following `GetSellerView` class:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`/chapter_8/views.py`文件，并添加以下`GetSellerView`类：
- en: '[PRE38]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In the preceding example, we are constructing a class-based view the same as
    we did in [*Chapter 4*](B17243_04_ePub.xhtml#_idTextAnchor116), *URLs, Views,
    and Templates*. The only thing we are doing differently here is we are not including
    the `post()` method; we only provided the `get()` method. Since we are not working
    with form submissions. The call-to-action button will be controlled using JavaScript
    as a button of `type=’button’` and not `type=’submit’`. There is no need to use
    the `post()` method when that is done. Also, we are creating a standard Django
    view class and not a REST API view class because this page is only used to communicate
    with API endpoints and not to serve as an API endpoint itself.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们正在构建一个基于类的视图，就像我们在[*第4章*](B17243_04_ePub.xhtml#_idTextAnchor116)，*URLs,
    Views, and Templates*中所做的那样。我们在这里所做的唯一不同的事情是我们没有包括`post()`方法；我们只提供了`get()`方法。因为我们不处理表单提交。操作按钮将通过JavaScript作为`type=’button’`类型的按钮来控制，而不是`type=’submit’`。完成这些后，就没有必要使用`post()`方法了。此外，我们正在创建一个标准的Django视图类，而不是REST
    API视图类，因为这个页面仅用于与API端点通信，而不是作为API端点本身。
- en: Now, let’s create the template to format the HTML that gets rendered to the
    page.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个模板来格式化要渲染到页面上的HTML。
- en: Building the template
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建模板
- en: The previous subsection constructed the view for this exercise. This subsection
    will create the template that is used in our exercise.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个子节构建了这个练习的视图。本节将创建用于我们练习的模板。
- en: 'Follow these steps to create your template:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建你的模板：
- en: Create the `get_seller.html` template file in the `/chapter_8/templates/chapter_8/spa_pages/`
    folder.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`/chapter_8/templates/chapter_8/spa_pages/`文件夹中创建`get_seller.html`模板文件。
- en: Earlier, in [*Chapter 4*](B17243_04_ePub.xhtml#_idTextAnchor116), *URLs, Views,
    and Templates*, we created a file called `/chapter_4/templates/chapter_4/base/base_template_1.html`.
    We will repurpose that file for this chapter. Go ahead and copy this file and
    any related template files, into your `chapter_8` app. Related template files
    include the header, footer, JavaScript, and CSS files that are referenced inside
    the `base_template_1.html` file. Place them in the `templates` and `static` directories
    in the same subfolders that you copied them from and then rename any mention of
    `chapter_4` and `chapter-4` to now reference `chapter_8` and `chapter-8` inside
    those files. You can always copy the `chapter_8` JavaScript, CSS, and template
    files found in the code of this book.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在[*第4章*](B17243_04_ePub.xhtml#_idTextAnchor116)，*URLs, Views, and Templates*中，我们创建了一个名为`/chapter_4/templates/chapter_4/base/base_template_1.html`的文件。我们将重新使用这个文件为本章服务。请将此文件以及任何相关的模板文件复制到你的`chapter_8`应用中。相关的模板文件包括在`base_template_1.html`文件中引用的标题、页脚、JavaScript和CSS文件。将它们放在与复制来源相同的子文件夹中的`templates`和`static`目录中，然后在文件中任何提及`chapter_4`和`chapter-4`的地方将其重命名为`chapter_8`和`chapter-8`。你可以始终复制本书代码中找到的`chapter_8`
    JavaScript、CSS和模板文件。
- en: 'Next, in the `get_seller.html` file that you created in *step 1*, add the following
    code shown:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在你在*步骤1*中创建的`get_seller.html`文件中，添加以下代码所示：
- en: '[PRE39]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This page is pretty simple. All we are doing is creating an input field of `type=”text”`
    and then a button of `type=”button”`. We gave the button an `onclick` attribute
    that fires off a JavaScript function called `$gotoSPA_Page()`. There is a `<div>`
    container with an attribute of `id=”details”`, which contains a paragraph of text,
    indicating that there is nothing to display at this time.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个页面非常简单。我们所做的只是创建一个`type=”text”`类型的输入字段，然后是一个`type=”button”`类型的按钮。我们给按钮添加了一个`onclick`属性，它会触发一个名为`$gotoSPA_Page()`的JavaScript函数。有一个带有`id=”details”`属性的`<div>`容器，其中包含一段文本，表明目前没有内容可以显示。
- en: The idea here is that we will replace all of the content of the `<div id=”details”>`
    container with the contents of what is received from the API request. A `<form>`
    container is not necessary for this particular setup; it has been added only to
    conform to the same CSS styles and HTML node structuring that was written in previous
    chapters. It is acceptable to deviate from this structure and create your own.
    Please use the preceding structure for the purpose of demonstrating this exercise.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的想法是我们将用从API请求接收到的内容替换`<div id=”details”>`容器中的所有内容。在这个特定的设置中不需要`<form>`容器；它只是为了符合之前章节中编写的相同的CSS样式和HTML节点结构而添加的。可以偏离这种结构并创建自己的。请使用前面的结构来演示这个练习。
- en: Next, let’s add the JavaScript responsible for performing an API request. We
    will be performing this action on the client side and not on the server side.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们添加执行API请求的JavaScript。我们将在这个客户端而不是服务器端执行这个操作。
- en: Writing the JavaScript
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写JavaScript
- en: We don’t need much JavaScript, just one small function that utilizes the native
    JavaScript `fetch()` function. This is almost identical to the jQuery `.ajax()`
    function, but it does differ slightly. The `fetch()` function differs in that
    it won’t send `cross-origin` headers, the default mode is set to `no-cors`, and
    the `.ajax()` function sets the default mode to `same-origin`. That could be important
    depending on your project’s requirements. The result of the request will then
    be displayed in the container with the CSS ID attribute of `details`, better known
    as the `details` container.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要很多JavaScript，只需要一个利用原生JavaScript `fetch()`函数的小函数。这几乎与jQuery的`.ajax()`函数相同，但也有一些不同。`fetch()`函数的不同之处在于它不会发送`cross-origin`头信息，默认模式设置为`no-cors`，而`.ajax()`函数将默认模式设置为`same-origin`。这可能会根据你的项目需求而变得重要。请求的结果将随后在具有CSS
    ID属性`details`的容器中显示，更广为人知的是`details`容器。
- en: 'If you copied your JavaScript file from `chapter_4`, that file should be blank
    right now. Take the following steps to prepare your JavaScript. If you copied
    this file from `chapter_8` found in the code of the book, make sure to comment
    out all but the following code:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从`chapter_4`复制了你的JavaScript文件，那么现在这个文件应该是空的。请按照以下步骤准备你的JavaScript。如果你从书中代码的`chapter_8`复制了这个文件，请确保只注释掉以下代码：
- en: 'In your `/chapter_8/static/chapter_8/js/site-js.js` file, add the following
    code:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`/chapter_8/static/chapter_8/js/site-js.js`文件中，添加以下代码：
- en: '[PRE40]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In the same `$gotoSPA_Page()` function, add the `fetch()` method just below
    your constants and variables, as shown:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在相同的`$gotoSPA_Page()`函数中，在你的常量和变量下面添加`fetch()`方法，如下所示：
- en: '[PRE41]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This is the `$gotoSPA_Page()` function that we configured in the previous subsection
    to execute when the `onclick` action of the **Get Seller Details** button is triggered.
    That’s it! This is all the JavaScript that we need to complete a single task of
    retrieving an individual record from a database, using the API that we created.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在前一小节中配置的`$gotoSPA_Page()`函数，当`Get Seller Details`按钮的`onclick`动作被触发时执行。就这样！这就是我们完成从数据库中检索单个记录的单个任务所需的全部JavaScript。
- en: In the preceding code, we wrote three constants, one called `input` to target
    the `input` field node and another called `container` to target the `details`
    container node. The third, called `id`, is used to capture the `value` of the
    input field at the time that this function is executed. The `url` variable is
    used to construct a string using the `value` of the `input` field as the keyword
    argument of that path converter. In JavaScript, this is known as concatenating
    strings, and because we are doing this, you need to make sure the backtick character
    (`` ` ``) is used instead of a single-quote character (`‘`). They look almost
    identical; if you are just glancing at the preceding code, be careful. Here, we
    are telling that `url` variable to point to the URL created by the router of the
    `Seller` API.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们编写了三个常量，一个名为`input`的用于定位`input`字段节点，另一个名为`container`的用于定位`details`容器节点。第三个，名为`id`的用于在函数执行时捕获输入字段的`value`。`url`变量用于使用该路径转换器的`value`作为关键字参数构造一个字符串。在JavaScript中，这被称为字符串连接，因为我们正在这样做，你需要确保使用反引号字符（``
    ` ``）而不是单引号字符（`‘`）。它们看起来几乎一模一样；如果你只是匆匆浏览前面的代码，请小心。在这里，我们告诉`url`变量指向由`Seller` API的router创建的URL。
- en: The `fetch()` function accepts the `url` variable as the first positional argument
    of that function, which is a required argument. We then pass in additional optional
    arguments, such as the method that accepts these values (`GET`, `POST`, `PUT`,
    `PATCH`, and `DELETE`). All we want to demonstrate for now is retrieving the data,
    so we will use the `GET` method in this exercise. The headers argument is sometimes
    used to specify `‘Content-Type’`; in this case, it is set to `‘application/json’`.
    The method and headers shown previously are the defaults to using the `fetch()`
    function. They are not needed for the read operation since they are the default
    values but they are provided for illustrative purposes.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetch()` 函数接受 `url` 变量作为该函数的第一个位置参数，这是一个必需的参数。然后我们传递额外的可选参数，例如接受这些值的方法（`GET`、`POST`、`PUT`、`PATCH`
    和 `DELETE`）。目前我们只想展示如何获取数据，因此在这个练习中我们将使用 `GET` 方法。有时会使用头参数来指定 `‘Content-Type’`；在这种情况下，它被设置为
    `‘application/json’`。之前显示的方法和头参数是使用 `fetch()` 函数的默认值。对于读取操作来说，它们不是必需的，因为它们是默认值，但提供它们是为了说明目的。'
- en: The `fetch()` function also uses the two `then()` methods shown previously;
    they each return a promise as a response object in JSON format. In simple terms,
    a promise is an object that consists of a state and a result. The second `then()`
    method uses the returned promise as the `data` variable, which we then use by
    writing a simple statement to place that `data` into the `details` container.
    We use the `JSON.stringify()` method to convert that JSON object into a readable
    format, particularly a string placed inside that container. Without using the
    `JSON.stringify()` function, we would only see a single object printed to the
    screen in brackets, which won’t make much sense to us when we are looking at it.
    We will see screenshots of this in action in the subsection titled *First demo*
    of this chapter.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetch()` 函数还使用了之前显示的两个 `then()` 方法；它们各自返回一个 JSON 格式的响应对象作为承诺。简单来说，承诺是一个包含状态和结果的物体。第二个
    `then()` 方法使用返回的承诺作为 `data` 变量，然后我们通过编写一个简单的语句将那个 `data` 放入 `details` 容器中。我们使用
    `JSON.stringify()` 方法将那个 JSON 对象转换成可读的格式，特别是将一个字符串放入那个容器中。如果不使用 `JSON.stringify()`
    函数，我们只会看到一个对象被打印到屏幕上，用括号括起来，这在我们查看时不会很有意义。我们将在本章标题为 *First demo* 的子节中看到这个操作的截图。'
- en: Currently, all we are doing is printing the string of JSON into the `<div>`
    container. We are not creating HTML nodes and/or CSS styles for those nodes. This
    is where you would have to either write additional JavaScript to do that for you
    manually or use the power of a JavaScript-based framework. Let’s finish this exercise
    to see it working first, and then we will show you how to render that HTML and
    CSS on the server side, in the section titled *Writing custom API endpoints* of
    this chapter.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们只是在 `<div>` 容器中打印 JSON 字符串。我们没有为这些节点创建 HTML 元素和/或 CSS 样式。这就是你可能需要编写额外的
    JavaScript 来手动完成这些操作，或者使用基于 JavaScript 的框架的强大功能的地方。让我们先完成这个练习，看看它是如何工作的，然后我们将向你展示如何在章节标题为
    *Writing custom API endpoints* 的部分中在服务器端渲染 HTML 和 CSS。
- en: Using the async and await keywords
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 async 和 await 关键字
- en: Traditional JavaScript is synchronous and single-threaded. It will run one process
    after the other and if one process gets hung up on, say, an API request where
    the server takes a long time to respond, then processes that take place after
    will hang up too. The problem is that a page can become unresponsive when this
    occurs. Asynchronous JavaScript allows functions to run side by side while other
    functions might be waiting for a response from the server. A `then()` function
    returning a promise is already an asynchronous function and is the reason why
    we gravitated toward using the `fetch()` function. JavaScript provides the `async`
    and `await` keywords, which make using and working with asynchronous functions
    a little bit easier, especially when your code begins to grow beyond these basic
    usage examples.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的 JavaScript 是同步和单线程的。它将依次运行一个进程，如果其中一个进程因为例如 API 请求（服务器响应时间过长）而挂起，那么后续的进程也会挂起。问题是当这种情况发生时，页面可能会变得无响应。异步
    JavaScript 允许函数在等待服务器响应的同时并行运行。返回承诺的 `then()` 函数已经是一个异步函数，这也是我们倾向于使用 `fetch()`
    函数的原因。JavaScript 提供了 `async` 和 `await` 关键字，这使得使用和操作异步函数变得更容易，尤其是在你的代码开始超出这些基本用法示例时。
- en: Take the following step to modify your JavaScript.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 采取以下步骤修改你的 JavaScript。
- en: 'Make the highlighted changes in the following code block to your `$gotoSPA_Page()`
    function from the previous example:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码块中，将高亮显示的更改应用到前面示例中的`$gotoSPA_Page()`函数：
- en: '[PRE42]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The variable and constants are still needed. They are left unchanged and are
    represented by the previous three-dot notation. We now have enough to almost run
    our project and demonstrate this exercise in action. We just need to map a URL
    pattern to the view we create next.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 变量和常量仍然需要。它们保持不变，并使用前三个点表示法表示。我们现在几乎可以运行我们的项目并演示这个练习的实际应用。我们只需要将URL模式映射到我们创建的视图。
- en: Mapping the URL pattern
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 映射URL模式
- en: Now, we are going to wire up the view that we created to a URL pattern, listening
    for the `/chapter-8/get-seller/` path.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将把创建的视图连接到一个URL模式，监听`/chapter-8/get-seller/`路径。
- en: Take the following step to configure your URL pattern.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来配置你的URL模式。
- en: 'In your `/chapter_8/urls.py` file, add the following path to the `urlpatterns`
    list:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的`/chapter_8/urls.py`文件中，将以下路径添加到`urlpatterns`列表中：
- en: '[PRE59]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: You also need to import the `GetSellerView` class to map to the preceding pattern.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要导入`GetSellerView`类以映射到前面的模式。
- en: Next, let’s demonstrate this code in action.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们演示这段代码的实际应用。
- en: First demo
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一次演示
- en: 'To demonstrate the code depicted in the *Building SPA-like pages* exercise,
    follow these steps:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 要演示*构建SPA-like页面*练习中展示的代码，请按照以下步骤操作：
- en: 'Navigate to the get seller page at http://localhost:8000/chapter-8/get-seller/,
    and it should look similar to the following screenshot:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到获取卖家页面 http://localhost:8000/chapter-8/get-seller/，它应该看起来与以下截图类似：
- en: '![Figure 8.6 – Get seller page'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.6 – 获取卖家页面'
- en: '](img/Figure_8.06_B17243.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.06_B17243.jpg)'
- en: Figure 8.6 – Get seller page
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6 – 获取卖家页面
- en: Next, enter the number `1` into the input field shown in the preceding screenshot,
    relating to the ID of the first `Seller` in your database. Then, click the button
    labeled **Get Seller Details**.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在前面截图所示的输入字段中输入数字`1`，这与你数据库中第一个`Seller`的ID相关。然后，点击标有**获取卖家详情**的按钮。
- en: 'To witness what is happening, in any major browser, right-click and select
    `console.log()` messages or errors that occur during runtime. If this action was
    successful, you should see the words **!!! No Details to Display !!!** replaced
    with the results of the request, as shown in the following screenshot:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要见证正在发生的事情，在任何主要浏览器中，右键单击并选择在运行时发生的`console.log()`消息或错误。如果此操作成功，你应该会看到**!!!
    无详细信息显示 !!!**的单词被请求的结果所替换，如图所示：
- en: '![Figure 8.7 – Get seller results – JSON.stringify()'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.7 – 获取卖家结果 – JSON.stringify()'
- en: '](img/Figure_8.07_B17243.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.07_B17243.jpg)'
- en: Figure 8.7 – Get seller results – JSON.stringify()
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7 – 获取卖家结果 – JSON.stringify()
- en: Tip
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: You will need to have the **Network** tab opened at all times in order for data
    to be logged into this tab. Open this tab and then refresh the page to get accurate
    results as you perform these actions.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要始终打开**网络**标签，以便将数据记录到该标签。打开此标签，然后刷新页面，以在执行这些操作时获得准确的结果。
- en: 'Now, look at the Network tab again, and you should see that we have two **/chapter-8/get-seller/**
    requests displayed in that list, as shown here:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，再次查看网络标签，你应该会看到列表中显示了两个**/chapter-8/get-seller/**请求，如图所示：
- en: '![Figure 8.8 – Get seller page – Network tab'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.8 – 获取卖家页面 – 网络标签'
- en: '](img/Figure_8.08_B17243.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.08_B17243.jpg)'
- en: Figure 8.8 – Get seller page – Network tab
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8 – 获取卖家页面 – 网络标签
- en: The first request, at the top of this list, was initiated by the browser when
    the user first loaded the page at http://localhost:8000/chapter-8/get-seller/.
    The second `site-js.js` file, which is the file where we wrote the `$gotoSPA_Page()`
    function. The last column shows the time it took to perform each request. All
    of the files in between are other assets, such as CSS and JavaScript files used
    by other apps in your project.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 列表顶部的第一个请求是由浏览器在用户首次加载http://localhost:8000/chapter-8/get-seller/页面时发起的。第二个`site-js.js`文件，这是我们编写`$gotoSPA_Page()`函数的文件。最后一列显示了执行每个请求所需的时间。所有介于这些文件之间的文件都是其他应用在项目中使用的其他资产，例如CSS和JavaScript文件。
- en: Note
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: There is no need to worry if you do not see these files; it just means they
    have not been loaded for one reason or another.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有看到这些文件，无需担心；这仅仅意味着它们由于某种原因尚未加载。
- en: 'Next, remove the `JSON.stringify()` function used in the `$gotoSPA_Page()`
    function and just use the `thisData` variable instead. Then, refresh this page
    and perform the query one more time. What we should see is a single object, as
    shown here:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，移除在`$gotoSPA_Page()`函数中使用的`JSON.stringify()`函数，只需使用`thisData`变量即可。然后，刷新此页面并再次执行查询。我们应该看到单个对象，如下所示：
- en: '![Figure 8.9 – Get seller results – standard'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.9 – 获取卖家结果 – 标准'
- en: '](img/Figure_8.09_B17243.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.09_B17243.jpg)'
- en: Figure 8.9 – Get seller results – standard
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9 – 获取卖家结果 – 标准
- en: It is here that we can see why we had to use the `JSON.stringify()` function.
    Without this function, we can see the object is depicted as **[object Object]**,
    which is not very helpful.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正是这里，我们可以看到为什么我们必须使用`JSON.stringify()`函数。没有这个函数，我们可以看到对象被描述为**[object Object]**，这并不很有帮助。
- en: Now that we have the client side of our API up and running, let’s explore how
    to return rendered HTML instead of a string representation of the JSON object
    that is returned.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们的API客户端已经启动并运行，让我们来探索如何返回渲染的HTML而不是返回的JSON对象的字符串表示。
- en: Writing custom API endpoints
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写自定义API端点
- en: Creating our own API endpoints is just as easy as writing another URL pattern.
    This section will teach us how to write our own API endpoints and practice sending
    preformatted HTML back to the client. You do not need to create all custom API
    endpoints to return preformatted HTML but we will practice doing that. Preformatting
    HTML only works well if the app communicating with your API does not need to restructure
    or restyle the HTML in any way after it has been received. This means the server/developer
    needs to know exactly how the client will use the data that it receives. No more
    JavaScript will be needed other than what was already written in the `$gotoSPA_Page()`
    function of the previous exercise. We will reuse that same function and just alter
    one or two things before we move forward. We will create a new view class and
    add permission logic to secure that endpoint from unwanted users accessing the
    API.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 创建我们自己的API端点就像编写另一个URL模式一样简单。本节将教会我们如何编写自己的API端点并练习发送预格式化的HTML回客户端。您不需要创建所有自定义API端点来返回预格式化的HTML，但我们将练习这样做。预格式化HTML只有在与您的API通信的应用程序在收到HTML后不需要以任何方式重新结构或重新样式化HTML时才能很好地工作。这意味着服务器/开发者需要确切地知道客户端将如何使用它接收到的数据。除了之前在`$gotoSPA_Page()`函数中已经写过的JavaScript之外，不再需要更多的JavaScript。我们将重用那个相同的函数，并在继续之前只更改一两个东西。我们将创建一个新的视图类，并添加权限逻辑来保护该端点免受不受欢迎的用户访问API。
- en: Let’s begin working on this exercise in the same order as the previous exercise,
    starting with the view.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照之前练习的顺序开始这个练习，从视图开始。
- en: Creating the view
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建视图
- en: 'Follow these steps to create your `APIView` class:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建您的`APIView`类：
- en: 'In your `/chapter_8/views.py` file, add the `import` statements shown here:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的`/chapter_8/views.py`文件中，添加以下`import`语句：
- en: '[PRE70]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'In that same file, create the `GetSellerHTMLView` class and `get()` method,
    as shown:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一个文件中，创建`GetSellerHTMLView`类和`get()`方法，如下所示：
- en: '[PRE71]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Here, the new `GetSellerHTMLView` class mimics the `GetSellerView` class that
    we created in the previous exercise, except now it uses the `APIView` class, provided
    by the Django REST framework. We only need to specify the `get()` method in this
    class as well; there is no need for the `post()` method since we are not working
    with form objects. We are only creating a view that handles the `GET` API method
    at this time, to view/read an object. The template we are mapping to this view
    is the `/chapter_8/templates/chapter_8/details/seller.html` file, which we will
    create in the next subsection. We need to pass `id=0` into the `get()` method,
    as is highlighted in the preceding code, in anticipation for how we will write
    the URL pattern for this API endpoint. We have to explicitly set `id=0` in the
    `get()` method since we are using the `APIView` class. If you are inheriting the
    regular `View`, `FormView`, `CreateView`, `UpdateView`, or `DeleteView` classes,
    you would only have to write `id` without the `=0` part. The same applies to the
    `format=None` argument, which is only needed when working with `APIView` classes
    and not regular `View` classes.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，新的`GetSellerHTMLView`类模仿了我们之前练习中创建的`GetSellerView`类，但现在它使用的是Django REST框架提供的`APIView`类。我们只需要在这个类中指定`get()`方法即可；因为我们不处理表单对象，所以不需要`post()`方法。我们目前只创建一个处理`GET`
    API方法的视图，用于查看/读取一个对象。我们将这个视图映射到的模板是`/chapter_8/templates/chapter_8/details/seller.html`文件，我们将在下一小节中创建它。我们需要将`id=0`传递给`get()`方法，正如前面代码中突出显示的那样，以期待我们如何编写这个API端点的URL模式。由于我们使用的是`APIView`类，我们必须在`get()`方法中显式设置`id=0`。如果你继承的是常规的`View`、`FormView`、`CreateView`、`UpdateView`或`DeleteView`类，你只需要写`id`，而不需要`=0`部分。同样适用于`format=None`参数，这个参数只有在与`APIView`类一起工作时才需要，而不是常规的`View`类。
- en: This approach is reliant on a user logged into your system, by accessing the
    currently logged-in user with the `request.user` object. Users outside your organization,
    who do not have access to the Django admin site, would have to use an authorization
    token to log in, which will be discussed later in this chapter. Even though we
    changed the `AUTH_USER_MODEL` setting in [*Chapter 3*](B17243_03_ePub.xhtml#_idTextAnchor077),
    *Models, Relations, and Inheritance*, to use the `Seller` model instead of the
    Django `User` model, we can still access the current user in the `request` object
    by using `request.user`. You do not have to use `request.seller`; in fact, that
    will result in an error. When using the `is_authenticated` property of that user,
    we can determine whether the user is actually logged in with an active session.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法依赖于用户登录到你的系统，通过使用`request.user`对象访问当前登录的用户。那些没有访问Django管理站点的组织外用户，将不得不使用授权令牌来登录，这将在本章后面讨论。尽管我们在[*第三章*](B17243_03_ePub.xhtml#_idTextAnchor077)中更改了`AUTH_USER_MODEL`设置，使用`Seller`模型而不是Django的`User`模型，但我们仍然可以通过使用`request.user`在`request`对象中访问当前用户。你不需要使用`request.seller`；实际上，这将导致错误。当使用该用户的`is_authenticated`属性时，我们可以确定用户是否实际上已通过活动会话登录。
- en: The `has_perm()` method is used to check the permissions of that user. In this
    case, we are checking whether the user has read/view permissions on a `Seller`
    model object using `‘chapter_3.view_seller’`. If the user is authenticated and
    has the correct permissions, we are performing a query to look up the `Seller`
    object being searched by using the ID provided. If the user is not authenticated,
    then we are setting the `seller` variable to `None`, which we will use to compare
    whether or not it has a value within the template file.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`has_perm()`方法用于检查该用户的权限。在这种情况下，我们使用`‘chapter_3.view_seller’`检查用户是否有对`Seller`模型对象的读取/查看权限。如果用户已认证并且具有正确的权限，我们将执行查询以查找由提供的ID指定的`Seller`对象。如果用户未认证，我们将设置`seller`变量为`None`，我们将在模板文件中使用它来比较它是否有值。'
- en: That `seller` variable then gets passed into the `context` of the template being
    used, so that we can access its data. Also, we need to wrap the query statement
    in a `try`/`except` block, which is necessary to prevent runtime errors when the
    user searches for a `Seller` that does not exist. With the `try`/`except` block,
    we can set the value of `seller` to `None`, allowing the program to continue to
    run without errors. When used in the template, it will indicate that the search
    returned nothing.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`seller` 变量被传递到正在使用的模板的 `context` 中，这样我们就可以访问其数据。此外，我们需要将查询语句包裹在 `try`/`except`
    块中，这是防止当用户搜索不存在的 `Seller` 时出现运行时错误所必需的。使用 `try`/`except` 块，我们可以将 `seller` 的值设置为
    `None`，允许程序在没有错误的情况下继续运行。在模板中使用时，它将指示搜索没有返回任何内容。
- en: We are using the `render()` method provided by the `django.shortcuts` library
    instead of the `TemplateResponse` class that we have been using up to now. This
    is because we want to return only a snippet of HTML and not an entire HTML page,
    with all of the bells and whistles that a page may have.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用 `django.shortcuts` 库提供的 `render()` 方法，而不是我们迄今为止一直在使用的 `TemplateResponse`
    类。这是因为我们只想返回一小段 HTML，而不是整个 HTML 页面，页面可能包含所有可能的装饰。
- en: Now that the view is created, let’s construct the template that uses that `seller`
    object as context.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了视图，接下来让我们构建使用该 `seller` 对象作为上下文的模板。
- en: Building the template
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建模板
- en: 'Follow these steps to prepare your template:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤准备您的模板：
- en: Create a file called `seller.html` in the `/chapter_8/templates/chapter_8/details/`
    directory.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `/chapter_8/templates/chapter_8/details/` 目录下创建一个名为 `seller.html` 的文件。
- en: 'Inside that file, add the following code:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在该文件中，添加以下代码：
- en: '[PRE72]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Note that we are not extending any another template in this file. All we are
    doing is displaying simple text objects as a component of a page and not the page
    in whole. A conditional statement compares whether or not the `seller` object
    has a value, using the `{% if seller %}` statement. If no `seller` object exists,
    text is rendered showing the message `seller` does exist, then another conditional
    statement compares whether or not the `seller` has any `vehicles`, using the `{%
    if seller.vehicles %}` statement. If `vehicles` do exist, we iterate through all
    of the vehicle objects using the `{% for vehicle in seller.vehicles.all %}` statement.
    It is important that you add `.all` to the end of this statement; otherwise, you
    will receive errors. This is how you access any nested list of objects found in
    a single object within the Django template language. We use the `fullname` property
    method created in [*Chapter 3*](B17243_03_ePub.xhtml#_idTextAnchor077), *Models,
    Relations, and Inheritance*, to print the full name of the vehicle as an `<li>`
    HTML node object.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在这个文件中并没有扩展任何其他模板。我们只是将简单的文本对象作为页面组件的一部分来显示，而不是整个页面。一个条件语句比较 `seller` 对象是否有值，使用
    `{% if seller %}` 语句。如果没有 `seller` 对象，将渲染显示消息 `seller` does exist，然后另一个条件语句比较
    `seller` 是否有任何 `vehicles`，使用 `{% if seller.vehicles %}` 语句。如果 `vehicles` 存在，我们将使用
    `{% for vehicle in seller.vehicles.all %}` 语句遍历所有的车辆对象。非常重要的一点是，您需要在语句末尾添加 `.all`；否则，您将收到错误。这是在
    Django 模板语言中访问单个对象中找到的任何嵌套对象列表的方法。我们使用在 [*第 3 章*](B17243_03_ePub.xhtml#_idTextAnchor077)
    中创建的 `fullname` 属性方法，*模型、关系和继承*，来打印车辆的全名作为一个 `<li>` HTML 节点对象。
- en: Now that we have our template, let’s move on to modify the `$gotoSPA_Page()`
    function created in the previous exercise.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了模板，接下来让我们修改之前练习中创建的 `$gotoSPA_Page()` 函数。
- en: Modifying the JavaScript
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改 JavaScript
- en: Change the `url` variable in the existing `$gotoSPA_Page()` function to point
    to the new endpoint, which we will write in the next subsection as `` `/chapter-8/seller/${id}/`
    ``, as in a singular `seller` in contrast to the plural `sellers` that we used
    in the previous exercise.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 将现有 `$gotoSPA_Page()` 函数中的 `url` 变量更改为指向新的端点，我们将在下一小节中编写，即 `` `/chapter-8/seller/${id}/`
    ``，与之前练习中使用的复数 `sellers` 相比，这里是一个单数的 `seller`。
- en: Take the following step to modify your JavaScript function.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来修改您的 JavaScript 函数。
- en: 'In the `$gotoSPA_Page()` function, make the following highlighted changes:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `$gotoSPA_Page()` 函数中，进行以下突出显示的更改：
- en: '[PRE73]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: In the preceding code, we are still using the `async` and `await` keywords but
    you are not required to do so. The first three constants of the `$gotoSPA_Page()`
    function, `container`, `input`, and `id`, are left untouched and are represented
    by the preceding three-dot notation.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们仍然使用了`async`和`await`关键字，但你不需要这样做。`$gotoSPA_Page()`函数的前三个常量`container`、`input`和`id`保持不变，并由前面的省略号表示。
- en: That’s it; now all we have to do is create the URL pattern that will act as
    the API endpoint being used.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样；现在我们只需要创建一个URL模式，它将作为API端点被使用。
- en: Mapping the URL pattern
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 映射URL模式
- en: Take the following step to map your URL pattern.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来映射你的URL模式。
- en: 'In your `/chapter_8/urls.py` file, add the following highlighted pattern, keeping
    the `get-seller` path that we previously wrote:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的`/chapter_8/urls.py`文件中，添加以下突出显示的模式，保留我们之前编写的`get-seller`路径：
- en: '[PRE87]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: We will still need that first URL pattern because it is the page that triggers
    the API request, containing the **Get Seller Details** button.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要第一个URL模式，因为它是触发API请求的页面，包含**获取卖家详情**按钮。
- en: That should be it. Now, let’s see what this looks like in action.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。现在，让我们看看这个动作的实际效果。
- en: Second demo
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第二个演示
- en: 'To demonstrate this in action, follow these steps:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一动作，请按照以下步骤操作：
- en: Make sure you are currently logged into the Django admin site at `http://localhost:8000/admin/`,
    with your superuser account.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你目前登录到`http://localhost:8000/admin/`的Django管理站点，使用你的超级用户账户。
- en: Then, navigate to the get seller page at http://localhost:8000/chapter-8/get-seller/
    and it should look the same as before, in *Figure 8.6*, in the previous exercise.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，导航到获取卖家页面`http://localhost:8000/chapter-8/get-seller/`，它应该与之前的*图8.6*中的页面相同。
- en: 'Enter the number `1` into the input field on this page and then click the `details`
    container found on this page, as is also shown here:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此页面的输入字段中输入数字`1`，然后点击此页面上的`details`容器，如图所示：
- en: '![Figure 8.10 – Get seller page – custom API endpoint'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.10 – 获取卖家页面 – 定制API端点'
- en: '](img/Figure_8.10_B17243.jpg)'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.10_B17243.jpg)'
- en: Figure 8.10 – Get seller page – custom API endpoint
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.10 – 获取卖家页面 – 定制API端点
- en: If you have the Network tab of your browser tools open, you will also see that
    this action was performed without reloading or redirecting your page. You can
    style this to look exactly as you need it. For this example, we just used simple
    HTML nodes with minimal styling and formatting to demonstrate this exercise.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开了浏览器工具的网络标签页，你也会看到这个操作是在不重新加载或重定向你的页面的情况下完成的。你可以根据需要对其进行样式设置。在这个例子中，我们只是使用了简单的HTML节点，并进行了最小化的样式和格式化来演示这个练习。
- en: Next, add or create a new superuser account using the Django admin site at `http://localhost:8000/admin/chapter_3/seller/`.
    This can also be done through the command line just as we did in [*Chapter 2*](B17243_02_ePub.xhtml#_idTextAnchor037),
    *Project Configuration*.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用位于`http://localhost:8000/admin/chapter_3/seller/`的Django管理站点添加或创建一个新的超级用户账户。这也可以像我们在[*第2章*](B17243_02_ePub.xhtml#_idTextAnchor037)的*项目配置*中做的那样，通过命令行完成。
- en: In a different browser or incognito window, log in with the new superuser that
    you just created.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在不同的浏览器或隐身窗口中，使用你刚刚创建的新超级用户登录。
- en: 'Next, navigate to the original superuser’s edit page, found here: `http://localhost:8000/admin/chapter_3/seller/1/change/`.
    This is the user with the username `admin` and an ID of `1`.'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，导航到原始超级用户的编辑页面，位于`http://localhost:8000/admin/chapter_3/seller/1/change/`。这是用户名为`admin`且ID为`1`的用户。
- en: 'In the **Permissions** section of this page, uncheck the **Superuser status**
    checkbox, restricting that user from doing anything. Leave the **Active** and
    **Staff status** checkboxes enabled. Make sure the **Chosen user permissions**
    box has nothing selected, as shown here:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此页面的**权限**部分，取消选中**超级用户状态**复选框，限制该用户执行任何操作。保留**激活**和**员工状态**复选框启用。确保**选择用户权限**框中没有选择，如图所示：
- en: '![Figure 8.11 – Editing superuser permissions'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.11 – 编辑超级用户权限'
- en: '](img/Figure_8.11_B17243.jpg)'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.11_B17243.jpg)'
- en: Figure 8.11 – Editing superuser permissions
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.11 – 编辑超级用户权限
- en: In your first browser, where you are already logged in as `Seller` with the
    username of `admin`, navigate to http://localhost:8000/chapter-8/get-seller/ in
    a different tab or refresh the existing tab if it is still open.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的第一个浏览器中，你已以`Seller`身份登录，用户名为`admin`，请在不同的标签页中导航到`http://localhost:8000/chapter-8/get-seller/`，或者如果它仍然打开，请刷新现有标签页。
- en: 'Enter the number `1` into the input field and then click the **Get Seller Details**
    button again. It should say that you do not have permission, as depicted in the
    following screenshot:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在输入字段中输入数字 `1`，然后再次点击 **获取卖家详情** 按钮。它应该显示你没有权限，如以下截图所示：
- en: '![Figure 8.12 – Get seller page – permission restricted'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.12 – 获取卖家页面 – 权限受限'
- en: '](img/Figure_8.12_B17243.jpg)'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.12_B17243.jpg)'
- en: Figure 8.12 – Get seller page – permission restricted
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.12 – 获取卖家页面 – 权限受限
- en: This is because we removed the original permission for this user. The preceding
    message is the HTML that we wrote in the `/chapter_8/details/seller.html` template,
    specifically in the condition that checks whether the `seller` object has a value.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是因为我们移除了该用户的原始权限。前面的消息是我们写在 `/chapter_8/details/seller.html` 模板中的 HTML，具体是在检查
    `seller` 对象是否有值的条件。
- en: To ensure that the `seller` object has no value as a result of a permission
    issue and not because of a non-existent query, you can write `print()` statements
    in your code to provide that indicator for you. Go back to the other browser window
    that is open at `http://localhost:8000/admin/chapter_3/seller/1/change/`, where
    you are logged in with the new superuser created for this exercise, and edit the
    `admin` user one more time.
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确保 `seller` 对象没有值是由于权限问题而不是由于不存在的查询，你可以在你的代码中写入 `print()` 语句来为你提供该指示器。回到另一个打开在
    `http://localhost:8000/admin/chapter_3/seller/1/change/` 的浏览器窗口，你用为这次练习创建的新超级用户登录，并再次编辑
    `admin` 用户。
- en: 'Go ahead and give that user the **chapter_3 | Seller | Can view Seller** permission,
    as depicted in the following screenshot:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下截图所示，给那个用户分配 **第 3 章 | 卖家 | 可以查看卖家** 权限：
- en: '![Figure 8.13 – Editing superuser permissions – view Seller'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.13 – 编辑超级用户权限 – 查看 Seller'
- en: '](img/Figure_8.13_B17243.jpg)'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.13_B17243.jpg)'
- en: Figure 8.13 – Editing superuser permissions – view Seller
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.13 – 编辑超级用户权限 – 查看 Seller
- en: By doing this, we are giving this user the exact permission that we are checking
    for in the `GetSellerHTMLView` class. Remember to click the **Save** button at
    the bottom of this page before proceeding.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们给这个用户分配了我们正在 `GetSellerHTMLView` 类中检查的确切权限。记住在继续之前点击此页面的底部 **保存** 按钮。
- en: In your first browser, on the get seller page at http://localhost:8000/chapter-8/get-seller/,
    make sure you are still logged in with the original `admin` user and click the
    **Get Seller Details** button one more time. Here, we will see the same results
    that we saw before in *Figure 8.9*.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的第一个浏览器中，在 http://localhost:8000/chapter-8/get-seller/ 的获取卖家页面上，确保你仍然使用原始的
    `admin` 用户登录，并再次点击 **获取卖家详情** 按钮。在这里，我们将看到与之前在 *图 8.9* 中看到相同的成果。
- en: This exercise demonstrated how to use the Django template language to preformat
    HTML that is being returned in an API `GET` request. As we discovered working
    with this exercise, we actually need a user who is already logged into the Django
    admin site of the site before performing this operation. Without being logged
    in, this approach will not work. This is controlled by the **Staff status** checkbox,
    under the **Permissions** section when editing a user, which grants that user
    the ability to access the Django admin site. With the **Staff status** checkbox
    left unchecked, a user cannot access your system and thus, will not be able to
    use any of the permissions in the permission system.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习演示了如何使用 Django 模板语言来预格式化在 API `GET` 请求中返回的 HTML。正如我们在做这个练习时所发现的，我们实际上需要在执行此操作之前登录到该网站的
    Django 管理站点。如果没有登录，这种方法将不起作用。这是通过在编辑用户时 **权限** 部分下的 **员工状态** 复选框控制的，它授予用户访问 Django
    管理站点的权限。如果 **员工状态** 复选框未被勾选，则用户无法访问您的系统，因此将无法使用权限系统中的任何权限。
- en: Note
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Switch your original superuser, with the username `admin`, back to its original
    settings, with the **Staff status** and **Superuser status** checkboxes enabled
    and the individual permissions and group permissions all removed. Make sure this
    is done and that you are logged in with this user before proceeding to the next
    exercise.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 将原始超级用户（用户名为 `admin`）的设置切换回原始状态，启用 **员工状态** 和 **超级用户状态** 复选框，并移除所有个人权限和组权限。确保这样做，并且在使用此用户登录之前完成此操作。
- en: If you need to build an API that doesn’t grant users access to your Django admin
    site, then authentication tokens will be needed. In the next exercise, we will
    use authentication tokens in combination with the Django REST framework to achieve
    this task.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要构建一个不授予用户访问 Django 管理网站的 API，那么将需要认证令牌。在下一个练习中，我们将结合使用认证令牌和 Django REST
    框架来完成这个任务。
- en: Authenticating with tokens
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用令牌进行认证
- en: In this exercise, we will be treating the API that we built earlier in this
    chapter as if it is now an API provided by a third party. Pretend for a moment
    that you did not build your API and we will practice authenticating by using a
    security token. Token security will be used in addition to the individual model
    permissions as we did in the previous exercise. This will be done whether you
    grant a user access to the Django admin site or not. That also means we will create
    a new user/seller for this exercise and then restrict that user’s access to the
    Django admin site for demonstration purposes.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将把本章之前构建的 API 视为第三方提供的 API。假设您没有构建您的 API，我们将通过使用安全令牌来练习认证。除了我们在上一个练习中使用的单个模型权限之外，我们还将使用令牌安全。这将无论您是否授予用户访问
    Django 管理网站都将执行。这也意味着我们将为这个练习创建一个新的用户/卖家，然后为了演示目的限制该用户对 Django 管理网站的访问。
- en: We will follow the same steps as the previous two exercises next.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将遵循与之前两个练习相同的步骤。
- en: Project configuration
  id: totrans-348
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目配置
- en: This exercise requires a little bit of configuration inside the project’s `settings.py`
    file before we can get started with the same steps as before.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以开始使用之前的步骤之前，这个练习需要在我们项目的 `settings.py` 文件中进行一些配置。
- en: 'Follow these steps to configure your project:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤配置您的项目：
- en: 'In your `settings.py` file, add the following app to your `INSTALLED_APPS`
    list, as well as the highlighted additions to the `REST_FRAMEWORK` setting, as
    shown:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的 `settings.py` 文件中，将以下应用程序添加到您的 `INSTALLED_APPS` 列表中，以及 `REST_FRAMEWORK`
    设置中突出显示的添加，如下所示：
- en: '[PRE107]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: The `rest_framework.authtoken` app is already installed in your virtual environment,
    so you do not have to install any additional `pip` packages. It comes standard
    when installing the `djangorestframework` package but does not get enabled in
    your project with just the basic settings needed for this framework. If we actually
    intend to use it, we have to add the two authentication classes shown previously
    to the `REST_FRAMEWORK` setting, telling the Django REST framework to use token
    authentication with all of its `APIView` classes. This means that tokens will
    be needed for any custom endpoints that we create using that `APIView` class,
    as well as all of the endpoints created using the `router` method from earlier
    in this chapter.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '`rest_framework.authtoken` 应用程序已经安装在了您的虚拟环境中，因此您不需要安装任何额外的 `pip` 包。它在安装 `djangorestframework`
    包时是标准配置的一部分，但仅使用该框架所需的基本设置并不会在您的项目中启用。如果我们实际上打算使用它，我们必须将之前显示的两个认证类添加到 `REST_FRAMEWORK`
    设置中，告诉 Django REST 框架使用所有 `APIView` 类进行令牌认证。这意味着我们将需要使用该 `APIView` 类创建的任何自定义端点以及本章之前使用
    `router` 方法创建的所有端点。'
- en: Endpoints created using the `router` method are all constructed using the `APIView`
    class. Adding the `SessionAuthentication` class means that we will enable the
    ability for users to log into the Django admin site to test that endpoint using
    the Browsable API. Without it, you will see a message indicating you are not authenticated.
    We will also leave the `DjangoModelPermissionsOrAnonReadOnly` permission class
    in the settings shown previously to continue to check for model-level permissions.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `router` 方法创建的端点都是使用 `APIView` 类构建的。添加 `SessionAuthentication` 类意味着我们将启用用户登录
    Django 管理网站以使用 Browsable API 测试该端点的功能。如果没有它，您将看到一条消息表明您尚未认证。我们还将保留之前显示的 `DjangoModelPermissionsOrAnonReadOnly`
    权限类，以继续检查模型级别的权限。
- en: Please also make sure you are following proper Python indentation. There is
    not enough room to display that properly in the code shown previously.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保您遵循正确的 Python 缩进。在之前显示的代码中，没有足够的空间来正确显示这一点。
- en: 'Now that we have added new packages to our `settings.py` file for this project,
    we will need to run the following migrate command:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经为这个项目添加了新的包到 `settings.py` 文件中，我们需要运行以下迁移命令：
- en: '[PRE108]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Next, make sure that you are logged into the Django admin site with your `admin`
    user and navigate to `http://localhost:8000/admin/chapter_3/seller/add/`, to create
    a new user/seller with the username `test`. You may already have a test user from
    a previous chapter. If so, just delete that user and recreate it for this exercise.
    This time, leave the **Staff status** and **Superuser status** checkboxes unchecked.
    Give that new user only one permission, the same **chapter_3 | Seller | Can view
    Seller** permission that we used before.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，确保你已使用 `admin` 用户登录 Django 管理站点，并导航到 `http://localhost:8000/admin/chapter_3/seller/add/`，以创建一个名为
    `test` 的新用户/卖家。你可能已经有一个来自前几章的测试用户。如果是这样，只需删除该用户并重新创建它以供此练习使用。这次，不要勾选 **Staff status**
    和 **Superuser status** 复选框。只给这个新用户一个权限，即之前使用的 **chapter_3 | Seller | Can view
    Seller** 权限。
- en: 'Next, navigate to the URL `http://localhost:8000/admin/authtoken/tokenproxy/`
    and add a new token for the user you just created. This can also be done in your
    command-line window or terminal by executing the following command:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，导航到 URL `http://localhost:8000/admin/authtoken/tokenproxy/` 并为刚刚创建的用户添加一个新的令牌。这也可以在命令行窗口或终端中通过执行以下命令来完成：
- en: '[PRE109]'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Copy the token key that was created for that user and save it for later, in
    Notepad or something.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制为该用户创建的令牌密钥，并将其保存以备后用，可以使用记事本或其他类似工具。
- en: Next, we will proceed in the same order as we did for the last two exercises.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将按照与上次两个练习相同的顺序进行。
- en: Creating the view
  id: totrans-363
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建视图
- en: Now, we need to create a new view class for this exercise. It will be used for
    a new endpoint that we will add to the API before we treat it like someone else
    built it for us. This endpoint will only return standard JSON data and will not
    return the preformatted HTML that we practiced doing in the previous exercise.
    JSON is what is traditionally returned in API requests.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要为这个练习创建一个新的视图类。它将被用于在将 API 视为他人为我们构建之前，我们添加到 API 中的一个新端点。此端点将仅返回标准 JSON
    数据，而不会返回我们在上一个练习中练习过的预格式化 HTML。JSON 是 API 请求中传统上返回的内容。
- en: 'Follow these steps to prepare your view class:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤准备你的视图类：
- en: 'In your `/chapter_8/views.py` file, add the following highlighted `import`
    statement and the `GetSellerWithTokenView` class shown:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 `/chapter_8/views.py` 文件中，添加以下高亮的 `import` 语句和 `GetSellerWithTokenView`
    类：
- en: '[PRE110]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Inside that same `GetSellerWithTokenView` class, add the following `get()`
    method and conditional statement:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一个 `GetSellerWithTokenView` 类中，添加以下 `get()` 方法和条件语句：
- en: '[PRE111]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Inside that same `get()` method, add the following `context`, `serializer`,
    `new_context`, and `return` statements below what you just added to that method:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一个 `get()` 方法中，在刚刚添加到该方法的以下 `context`、`serializer`、`new_context` 和 `return`
    语句下方添加以下内容：
- en: '[PRE112]'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: In the preceding class, we are following the same logic format as was used in
    the `GetSellerHTMLView` class, written in the previous exercise. We added a property
    called `permission_classes`, which uses the `IsAuthenticated` class. This is needed
    to work with token authentication. We added an additional query to the `get()`
    method. The logic here is that we are using two items added to the request headers
    when the request is sent, using the `fetch()` JavaScript function. Those two headers
    are `HTTP_AUTHORIZATION` and `HTTP_USER`, which we will soon add to our JavaScript
    function.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的类中，我们遵循了与上一个练习中编写的 `GetSellerHTMLView` 类相同的逻辑格式。我们添加了一个名为 `permission_classes`
    的属性，它使用 `IsAuthenticated` 类。这是与令牌身份验证一起工作所需的。我们在 `get()` 方法中添加了一个额外的查询。这里的逻辑是我们使用在请求发送时添加到请求头部的两个项目，使用
    `fetch()` JavaScript 函数。这两个头是 `HTTP_AUTHORIZATION` 和 `HTTP_USER`，我们很快将添加到我们的 JavaScript
    函数中。
- en: The `request._user` item is used to look up the user associated with that `request`,
    whether the user is logged into the Django admin site or is passed into the request
    via the `HTTP_USER` header, that being the `test` user created for this exercise,
    the user we will associate with the API request. We are looking up that user to
    compare individual model permissions using the same `has_perm()` method from the
    previous exercise. If the API request user is found, then we are performing the
    same logic as before to check whether that user has permission to view a `seller`
    object. This time, we removed the `is_authenticated` property from that conditional
    statement, as we are now relying on this class’s token authentication. If you
    granted your `test` user the ability to view a `seller` object, the logic continues
    to look up the `seller` with the ID provided in that input field, the same as
    before. If your `test` user is not granted the ability to view a `seller` object,
    then the `perm_granted` context item will return `False`, to provide an indicator
    in the data being returned to us.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '`request._user`项用于查找与该`request`关联的用户，无论该用户是否登录到Django管理站点，还是通过`HTTP_USER`头传递给请求，即为本练习创建的`test`用户，我们将将其与API请求关联。我们查找该用户以使用与之前练习中相同的`has_perm()`方法比较单个模型权限。如果找到API请求用户，则我们执行与之前相同的逻辑来检查该用户是否有权查看`seller`对象。这次，我们从那个条件语句中移除了`is_authenticated`属性，因为我们现在依赖于这个类的令牌认证。如果你授予了`test`用户查看`seller`对象的能力，逻辑将继续查找在输入字段中提供的ID的`seller`，与之前相同。如果你的`test`用户没有被授予查看`seller`对象的能力，那么`perm_granted`上下文项将返回`False`，以在返回给我们的数据中提供指示。'
- en: The context was broken up into two different items, shown in *step 3*, because
    the request is needed in the context when using `SellerSerializer`. Then, we are
    removing that request from the final context being returned as `JsonResponse()`.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文被拆分为两个不同的项目，如*步骤 3*所示，因为在使用`SellerSerializer`时需要在该上下文中请求。然后，我们从最终返回的`JsonResponse()`中移除该请求。
- en: Building the template
  id: totrans-375
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建模板
- en: This exercise does not require a brand-new template. It will be returning only
    JSON and is not following the preformatted HTML example.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习不需要一个新的模板。它将只返回JSON，并且不遵循预格式化的HTML示例。
- en: Modifying the JavaScript
  id: totrans-377
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改JavaScript
- en: We will be using the same JavaScript example provided in the *Modifying the
    JavaScript* subsection under the *Writing custom API endpoints* section.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用在*编写自定义API端点*部分下的*修改JavaScript*子部分中提供的相同JavaScript示例。
- en: Take the following step to modify your JavaScript for this exercise.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来修改你的JavaScript以完成这个练习。
- en: 'In the same JavaScript file, make the following highlighted changes to your
    existing `$gotoSPA_Page()` function:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一个JavaScript文件中，对现有的`$gotoSPA_Page()`函数进行以下突出显示的更改：
- en: '[PRE113]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: In this example, we are leaving the first three constants, `container`, `input`,
    and `id`, the same as they have been written in previous examples and represented
    by the preceding three-dot notation. We are changing the `url` variable to point
    to a new path that we will create shortly, `` `/chapter-8/sellertoken/${id}/`
    ``. The rest of the `fetch()` function is left the same as before, where we are
    returning the result as preformatted HTML instead of JSON. The only thing different
    is that we are adding the `‘Authorization’` and `‘User’` items to the `headers`
    of this request. The value of the `‘Authorization’` item is the value of the token
    that was created, the one you were asked to copy earlier; paste that in place
    of the preceding `your_token` shown. The value of the `‘User’` item is the username
    of the new user/seller that you just created, the one assigned to the token that
    you are providing.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们保留了前三个常量`container`、`input`和`id`，它们与之前示例中的写法相同，并由前面的三个点符号表示。我们将`url`变量更改为指向我们将要创建的新路径，即``
    `/chapter-8/sellertoken/${id}/` ``。`fetch()`函数的其余部分与之前相同，我们返回的结果是预格式化的HTML而不是JSON。唯一不同的是，我们向这个请求的`headers`中添加了`‘Authorization’`和`‘User’`项。`‘Authorization’`项的值是创建的令牌的值，即你之前被要求复制的那个；将此粘贴到之前显示的`your_token`的位置。`‘User’`项的值是新用户/卖家的用户名，即分配给你要提供的令牌的用户。
- en: Note
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Tokens should *never* be kept in a JavaScript file, as is done in the preceding
    example. An explanation for why this is done in the preceding example is provided
    in the subsection titled *Third demo* at the end of this exercise.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 标记*永远*不应该保存在JavaScript文件中，就像前面示例中所做的那样。为什么在前面示例中这样做的原因在练习末尾的*第三演示*子部分中提供了解释。
- en: Mapping the URL pattern
  id: totrans-400
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 映射 URL 模式
- en: We are almost done! We just need to map the endpoint that we are communicating
    with to our new view class.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了！我们只需要将我们正在通信的端点映射到我们新的视图类。
- en: Take the following step to map your URL pattern.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤映射你的 URL 模式。
- en: 'In your `/chapter_8/urls.py` file, add the following path. You can leave the
    other paths that have already been created, as depicted:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 `/chapter_8/urls.py` 文件中，添加以下路径。你可以保留已经创建的其他路径，如图所示：
- en: '[PRE129]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: That’s it; let’s demonstrate this code in action next.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了；让我们接下来演示这段代码的实际应用。
- en: Third demo
  id: totrans-427
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第三次演示
- en: 'Follow these steps to see this in action:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤查看实际效果：
- en: Open a new incognito window and navigate to `http://localhost:8000/chapter-8/get-seller/`.
    The reason I am asking you to open an incognito window is to ensure that you are
    not logged into the Django admin site with any user for this test run. You can
    also navigate to `http://localhost:8000/admin/` to double-check, making sure that
    you are not logged in.
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的无痕窗口，并导航到 `http://localhost:8000/chapter-8/get-seller/`。我要求你打开无痕窗口是为了确保你在这次测试运行中未以任何用户登录到
    Django 管理站点。你也可以导航到 `http://localhost:8000/admin/` 来双重检查，确保你没有登录。
- en: 'Next, enter the number `1` into the input field and click the `seller` data
    in JSON format, including the extra `perm_granted` context that we passed in,
    as shown in the following screenshot:'
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在输入字段中输入数字 `1`，并点击 JSON 格式的 `seller` 数据，包括我们传递的额外 `perm_granted` 上下文，如下截图所示：
- en: '![Figure 8.14 – Get seller page – custom API endpoint with token auth'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.14 – 获取卖家页面 – 带令牌认证的自定义 API 端点'
- en: '](img/Figure_8.14_B17243.jpg)'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_8.14_B17243.jpg)'
- en: Figure 8.14 – Get seller page – custom API endpoint with token auth
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.14 – 获取卖家页面 – 带令牌认证的自定义 API 端点
- en: You could also add `print()` statements to your code to verify if and when each
    condition is actually met. Additional `print()` statements and comments providing
    details have been included with the code of this book.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在你的代码中添加 `print()` 语句来验证每个条件是否实际满足。本书代码中已包含额外的 `print()` 语句和提供详细信息的注释。
- en: Note
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You will see hyperlinked vehicles in the preceding example if you are inheriting
    the `HyperlinkedModelSerializer` class in your serializers. If you are still using
    the `ModelSerializer` class, only numeric IDs will be displayed.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在你的序列化器中继承 `HyperlinkedModelSerializer` 类，你将在前一个示例中看到超链接车辆。如果你仍然使用 `ModelSerializer`
    类，则只会显示数字 ID。
- en: 'If you were not successful or you enter an incorrect token in your JavaScript
    file, then you will see an `fetch()` function just to see the `1` into the input
    field again, and click the **Get Seller Details** button. The invalid token message
    should look something as in the following screenshot:'
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你没有成功或者你在 JavaScript 文件中输入了错误的令牌，那么你将看到一个 `fetch()` 函数，再次将 `1` 输入到输入字段中，并点击
    **获取卖家详情** 按钮。无效令牌消息应该看起来像以下截图所示：
- en: '![Figure 8.15 – Get seller page – invalid token'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.15 – 获取卖家页面 – 无效令牌'
- en: '](img/Figure_8.15_B17243.jpg)'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_8.15_B17243.jpg)'
- en: Figure 8.15 – Get seller page – invalid token
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.15 – 获取卖家页面 – 无效令牌
- en: Important Note
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'In a real-world example, the token should *never* be kept directly in the JavaScript
    file or even a Python file, if you are using the `requests` package. Instead,
    you should consider creating an additional API endpoint that utilizes the built-in
    token generator called `obtain_auth_token`, as discussed here: [https://www.django-rest-framework.org/api-guide/authentication/#generating-tokens](https://www.django-rest-framework.org/api-guide/authentication/#generating-tokens).
    The token generator works by accepting a username and password that is attached
    to the headers of the first API request and then receives a newly created token
    in return. Then, a second API request is used to execute the action desired by
    attaching the token received from the first request to the second request’s headers.
    The Django REST framework does the rest of the work to authenticate that request
    using the credentials provided. The examples provided in this exercise are intended
    only to demonstrate how to perform requests after the token has already been received.
    The approach of generating tokens requires the use and knowledge of signals, which
    goes beyond the scope of this book.'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的例子中，如果使用`requests`包，则不应将令牌直接保存在JavaScript文件或Python文件中。相反，您应考虑创建一个额外的API端点，该端点使用内置的令牌生成器`obtain_auth_token`，如本节所述：[https://www.django-rest-framework.org/api-guide/authentication/#generating-tokens](https://www.django-rest-framework.org/api-guide/authentication/#generating-tokens)。令牌生成器通过接受附加在第一个API请求头部的用户名和密码来工作，然后返回一个新创建的令牌。然后，使用从第一个请求中接收到的令牌附加到第二个请求的头部来执行所需的操作。Django
    REST框架将执行剩余的工作，使用提供的凭据来验证该请求。本练习中提供的示例仅用于演示在收到令牌后如何执行请求。生成令牌的方法需要使用和了解信号，这超出了本书的范围。
- en: If using the double-request approach as noted in the preceding information box,
    you can now let developers of third-party apps communicate with your API without
    needing to create user accounts. However, you can still create a user in your
    system for that third-party user in order to keep using the granular permission
    levels of your system as was done throughout this exercise. The path you take
    is determined by the requirements of your project.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用前述信息框中提到的双请求方法，现在您可以允许第三方应用的开发者与您的API通信，而无需创建用户账户。然而，您仍然可以在系统中为该第三方用户创建一个用户，以便继续使用本练习中一直使用的细粒度权限级别。您采取的路径取决于您项目的需求。
- en: Summary
  id: totrans-444
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The examples provided throughout this chapter demonstrate a simple way to construct
    and work with your newly created API, in a variety of ways! If you want to give
    your app an SPA-like feel, the simplest implementation is to use the vanilla JavaScript
    `fetch()` function or the jQuery `ajax()` function. Instead of writing your own
    actions with either of these two functions, you could settle upon using a JavaScript-based
    framework, such as React, AngularJS, or Vue.js, just to name a few. The JavaScript-based
    frameworks can format and style your HTML on the client side. One of the template-based
    approaches provided in this chapter also demonstrates how this work can be transferred
    from the client side onto the server side. This provides you with numerous tools
    in your toolbox, in regard to building and working with an API.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中提供的示例展示了构建和使用您新创建的API的简单方法，以多种方式！如果您想给您的应用带来类似SPA（单页应用）的感觉，最简单的实现方式是使用纯JavaScript的`fetch()`函数或jQuery的`ajax()`函数。您不必使用这两个函数中的任何一个来编写自己的操作，而可以考虑使用基于JavaScript的框架，例如React、AngularJS或Vue.js，仅举几个例子。基于JavaScript的框架可以在客户端格式化和样式化您的HTML。本章提供的基于模板的方法之一还展示了如何将这项工作从客户端转移到服务器端。这为您提供了在构建和使用API方面的众多工具。
- en: We also learned how to work with authentication tokens and discovered that we
    can still work with tokens when formatting HTML on the server side. However, the
    token approach does require additional, more advanced topics of Django and security
    measures before being able to fully implement that approach on a live site. The
    Django REST framework is intended to be the backend of an API and is designed
    to work with any frontend that a team settles upon.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了如何处理认证令牌，并发现我们可以在服务器端格式化HTML时仍然使用令牌。然而，在实站上完全实现这种方法之前，需要了解Django的更多高级主题和安全措施。Django
    REST框架旨在成为API的后端，并设计为与团队确定的任何前端一起工作。
- en: In the next chapter, we’ll explore how to test our project and make sure what
    has been written does actually work. To do that, we will explore how to write
    automated test scripts, and then install a new package that provides even more
    tools, as well as learning how to use them.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何测试我们的项目并确保所编写的代码确实能够工作。为了做到这一点，我们将学习如何编写自动化测试脚本，然后安装一个新的包，该包提供了更多的工具，以及学习如何使用这些工具。
