- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Middleware and Webhooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we delve into the advanced and crucial aspects of middleware
    and webhooks in FastAPI. Middleware in FastAPI allows you to process requests
    and responses globally before they reach your route handlers and after they leave
    them. Webhooks, on the other hand, enable your FastAPI application to communicate
    with other services by sending real-time data updates. Both middleware and webhooks
    are essential for building robust, efficient, and scalable applications.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by exploring how to create custom **Asynchronous Server Gateway
    Interface** (**ASGI**) middleware from scratch. This will give you a deep understanding
    of how middleware works at a fundamental level.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll develop middleware specifically for response modification, allowing
    you to intercept and alter responses before they are sent back to the client.
  prefs: []
  type: TYPE_NORMAL
- en: We will also cover handling **Cross-Origin Resource Sharing** (**CORS**) with
    middleware. This is particularly important for applications that need to interact
    with different domains securely. Finally, we will dive into creating webhooks
    in FastAPI, demonstrating how to set them up and test them effectively.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a comprehensive understanding of how
    to implement and utilize middleware and webhooks in your FastAPI applications.
    These skills will enable you to build more dynamic, responsive, and integrated
    web services.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to go through the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom ASGI middleware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing middleware for request modification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing middleware for response modification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling CORS with middleware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restricting incoming requests from hosts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing webhooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this stage of the book, you should already have a good understanding of the
    basics of FastAPI, how to install it, and how to run it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code used in the chapter is hosted on GitHub at the following address:
    [https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter11](https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter11).'
  prefs: []
  type: TYPE_NORMAL
- en: It is recommended to set up a virtual environment for the project in the project
    root folder to efficiently manage dependencies and maintain project isolation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Throughout the chapter, we will only be using the standard `fastapi` library
    with `uvicorn`. You can install all the dependencies within your virtual environment
    using `pip` from the command line by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: For the *Handling CORS with middleware* recipe, having some basic knowledge
    of JavaScript and HTML will be beneficial.
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom ASGI middleware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ASGI is a specification for Python web servers and applications to communicate
    with each other, designed to support asynchronous functionality. Middleware is
    a critical component in web applications, providing a way to process requests
    and responses.
  prefs: []
  type: TYPE_NORMAL
- en: We have already seen, in the *Creating custom middleware* recipe in [*Chapter
    8*](B21025_08.xhtml#_idTextAnchor262), *Advanced Features and Best Practices*,
    how to create custom middleware. However, this technique relies on the `BasicHTTPMiddleware`
    class from the Starlette library, which is a high-level implementation of HTTP
    middleware.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we’ll learn how to create custom ASGI middleware from scratch
    and integrate it into a FastAPI application. The middleware will be simple and
    will only print log message information on the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: This approach provides greater control over the request/response cycle compared
    to the `BasicHTTPMiddleware` class, allowing for advanced customizations and the
    creation of any kind of middleware with a deeper level of customization.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we will use the Starlette library to build middleware, a sound knowledge
    of this library would be beneficial, although not necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Regarding the development environment, we will exclusively utilize the `fastapi`
    package with `uvicorn`. Ensure they are installed in your environment.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start by creating a project root folder called `middleware_project`.
    Under the root folder, create a folder called `middleware` containing a module
    called `asgi_middleware.py`. Let’s start the module by declaring the logger that
    we will use during the middleware call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can define the middleware class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to include the middleware in our application. Under the project
    root folder, create the `main.py` module containing the FastAPI class to run the
    application, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This is all you need to implement custom ASGI middleware in a FastAPI application.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To see the middleware in action, let’s create a general endpoint in `main.py`
    module, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Spin up the server by running `uvicorn main:app` from the command line. You
    will see the following messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Among the messages, you will notice those indicating that we have already entered
    the middleware. Now try to call the root endpoint. You can do it by opening the
    browser at `http://localhost:8000/`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Still on the terminal, this time you will notice both middleware messages for
    entering and exiting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As we understand from the logs, we entered the middleware twice, once on the
    startup and once when calling the endpoint, but we exited the middleware only
    once.
  prefs: []
  type: TYPE_NORMAL
- en: This is why the ASGI middleware intercepts every event of the application, not
    only the HTTP request but also the `lifespan` event, which includes the startup
    and shutdown.
  prefs: []
  type: TYPE_NORMAL
- en: 'Information on the event type within the middleware is stored in the `scope`
    parameter of the `__call__` method. Let’s include the following logs in the `ASGIMiddleware.__call__`
    method to improve our understanding of the mechanism:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If you restart the server and remake the call to `http://localhost:8000/`, you
    will now see the log messages specifying the event scope type to be `lifespan`
    at the server startup and `http` after the endpoint call.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have just seen how to build ASGI middleware as a class. However, you can
    also do it by leveraging the function decorator pattern. For example, you can
    build the same middleware like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the equivalent of the `ASGIMiddleware` class defined earlier in the
    *How to do it…* subsection. To make it work, it should be passed as an argument
    to the FastAPI instance in exactly the same way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Based on your personal preference, you can choose the style you prefer. However,
    for the rest of the chapter, we will continue using the middleware class style.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can read more on the ASGI specification in the dedicated documentation
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: '*ASGI* *Documentation*: [https://asgi.readthedocs.io/en/latest/](https://asgi.readthedocs.io/en/latest/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Middleware classes in FastAPI derive from the Starlette library. You can find
    extensive documentation on creating ASGI middleware on the Starlette documentation
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Pure ASGI* *Middleware*: [https://www.starlette.io/middleware/#pure-asgi-middleware](https://www.starlette.io/middleware/#pure-asgi-middleware)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing middleware for request modification
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Middleware in web applications serves as a powerful tool for processing requests.
    Custom middleware can intercept and modify these messages, allowing developers
    to add or modify functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we’ll focus on developing custom ASGI middleware to modify responses
    before they are sent to the client by hashing the body of each request, if necessary.
    This approach provides the flexibility to add or change response headers, body
    content, and other properties dynamically. By the end of the recipe, you will
    be able to develop custom middleware to control every API request.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we begin, please make sure you have completed the previous recipe, *Creating
    custom ASGI middleware*, to create specific custom ASGI middleware. We will be
    working on the `middleware_project` application, but the recipe can easily be
    applied to any application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before creating the middleware, in the `main.py` module, let’s create a `POST
    /send` endpoint that accepts body content in the request, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The endpoint will print the body content to the terminal and return it as a
    response as well.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our endpoint, we can create the middleware to hash the body
    content before sending it to the endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the `middleware` folder, let’s create a module called `request_middleware.py`
    that will host our middleware class. Let’s go through the following steps to create
    the middleware:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start the module with the required imports like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will use the types from the Starlette library to create the middleware class
    and the `sha1` function to hash the body.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Given that only certain `HTTP` verbs accept the body (`POST` and `PUT`, but
    not `GET` for example), we will pass to the middleware the paths as parameters
    where the modifications should be applied.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a middleware class called `HashBodyContentMiddleware`, as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will pass the list of paths into the `allowed_paths` parameters.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Define the `__call__` method of the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the event is not an HTTP request or the path is not listed, the middleware
    won’t take any action and will leave the request passing through the next step.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The information about the body is brought by the `receive` variable. However,
    the `receive` variable is a coroutine, and it should be passed as that to the
    `self.app` object. We will overcome this by creating a new coroutine within the
    function, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The body request will be modified by the coroutine that is passed to the following
    steps of the FastAPI object application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now we need to add the middleware to the FastAPI instance. We can do it in
    the `main.py` module. But this time we will leverage the `add_middleware` method
    of the FastAPI instance object like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now the application will make the request pass through our middleware.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This is all you need to implement it. To test the middleware, let’s spin up
    the server with `uvicorn` from the command line by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then go to the interactive documentation at `http://localhost:8000/docs` and
    test the `POST/send` endpoint. For example, check whether you can send a body
    string like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything is correctly done, you should receive a response body like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: You have just implemented custom ASGI middleware that hashes the body for the
    specified endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: This was a simple example, but the potential of controlling requests is limitless.
    For example, you can use it to introduce an additional security layer to prevent
    cross-scripting injection of undesired content.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Creating middleware to modify the request is documented on the Starlette documentation
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Inspecting or modifying the* *request*: [https://www.starlette.io/middleware/#inspecting-or-modifying-the-request](https://www.starlette.io/middleware/#inspecting-or-modifying-the-request)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing middleware for response modification
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Besides processing requests, middleware in web applications is also a powerful
    tool for processing responses. Custom middleware allows us to intercept responses
    before they are returned to the API caller. This can be useful for checking response
    content or personalizing the response. In this recipe, we will develop custom
    ASGI middleware to add customized headers to all the responses.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will be creating custom ASGI middleware that modifies the response of each
    HTTP call. Before we get started on this recipe, take a look at the *Creating
    custom ASGI middleware* recipe. Also, this recipe will be complementary to the
    previous recipe, *Developing middleware for* *request modification*.
  prefs: []
  type: TYPE_NORMAL
- en: While you can apply this recipe to your own project, we will continue working
    on the `middleware_project` project that we initialized in the *Developing middleware
    for request* *modification* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will create our middleware class in a dedicated module in the `middleware`
    folder. We will call the module `response_middleware.py`. Let's start building
    the middleware by going through the following steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start writing the imports we will use to define the middleware:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we can start defining the `ExtraHeadersResponseMiddleware` middleware
    class as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will pass the headers list as an argument to the middleware. Then, the `__call__`
    method will be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We restrain the middleware to HTTP event calls. Similar to what we saw in the
    previous recipe, *Developing middleware for request modification*, we modify the
    send object, which is a coroutine, and we pass it to the next middleware, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The response’s headers are generated from the `message` parameter of the `send_with_extra_headerds`
    coroutine object.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once the middleware is defined, we need to add it to the `FastAPI` object instance
    to make it effective. We can add it in the `main.py` module as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we add two headers to the response, `new-header` and `another-header`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To test it, spin up the server by running `uvicorn main:app` and open the interactive
    documentation. Call one of the endpoints and check the headers in the response.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Here is the list of the headers you get when calling the `GET /` endpoint:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You will find the two headers we previously added to the default ones.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You have just implemented middleware that modifies API responses.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the Starlette documentation, you can find an example of how to create middleware
    that modifies the response:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Inspecting or modifying the* *response*: [https://www.starlette.io/middleware/#inspecting-or-modifying-the-response](https://www.starlette.io/middleware/#inspecting-or-modifying-the-response)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling CORS with middleware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CORS is a security feature implemented in web browsers to prevent malicious
    websites from making unauthorized requests to APIs hosted on different origins.
    When building APIs, especially for public consumption, it’s crucial to handle
    CORS properly to ensure legitimate requests are served while unauthorized ones
    are blocked.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will explore how to handle CORS using custom middleware in
    FastAPI. This approach allows us to deeply understand the CORS mechanism and gain
    flexibility in customizing the behavior to fit specific requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will apply the recipe to the `middleware_project` application. Make sure
    you have the FastAPI application running with at least the `GET /` endpoint already
    set up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the recipe will show how to set up CORS middleware to manage CORS, you
    will need a simple HTML web page that calls our API.
  prefs: []
  type: TYPE_NORMAL
- en: You can create one yourself or download the `cors_page.xhtml` file from the
    project’s GitHub repository. The file is a simple HTML page that sends a request
    to the FastAPI application at `http://localhost:8000/` and displays the response
    on the same page.
  prefs: []
  type: TYPE_NORMAL
- en: Before starting the recipe, spin up your FastAPI application by running `uvicorn
    main:app`. To view the page, open `cors_page.xhtml` using a modern browser. Then,
    open the developer console. In most browsers, you can do this by right-clicking
    on the page, selecting **Inspect** from the menu, and then toggling to the **Console**
    tab.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the page, press the **Send CORS Request** button. You should see an error
    message on the command line like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: That means that the call has been blocked by the CORS policy.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start the recipe and see how to fix it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In FastAPI, CORS can be handled with a dedicated `CORSMiddleware` class from
    the Starlette library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add the middleware to our application in the `main.py` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now, rerun the server, open `cors_page.xhtml` again, and try to press the **Send
    CORS Request** button. This time, you see the response message directly on the
    page.
  prefs: []
  type: TYPE_NORMAL
- en: The `allow_origins` parameter specifies the host origin from which the CORS
    should be allowed. If `allow_origins=[*]`, it means that any origin is allowed.
  prefs: []
  type: TYPE_NORMAL
- en: The `allow_methods` parameter specifies the HTTP methods that are allowed. By
    default, only `GET` is allowed, and if `allow_methods=[*]`, it means that all
    methods are allowed.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the `allow_headers` parameter specifies the headers that are allowed.
    Similarly, if we use `allow_headers=[*]`, it means that all headers are allowed.
  prefs: []
  type: TYPE_NORMAL
- en: In a production environment, it’s important to carefully evaluate each of these
    parameters to ensure security standards and to make your application run safely.
  prefs: []
  type: TYPE_NORMAL
- en: This is all that’s needed to implement CORS middleware for allowing CORS from
    clients.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For more information about CORS, check out the **Mozilla** documentation page:'
  prefs: []
  type: TYPE_NORMAL
- en: '*CORS*: [https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can see more about the functionalities and discover other parameters of
    the CORS middleware in FastAPI on the documentation page:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Use* *CORSMiddleware*: [https://fastapi.tiangolo.com/tutorial/cors/#use-corsmiddleware](https://fastapi.tiangolo.com/tutorial/cors/#use-corsmiddleware)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can also have a look at the Starlette documentation page:'
  prefs: []
  type: TYPE_NORMAL
- en: '*CORSMiddleware*: [https://www.starlette.io/middleware/#corsmiddleware](https://www.starlette.io/middleware/#corsmiddleware)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restricting incoming requests from hosts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In modern web applications, security is paramount. One crucial aspect of security
    is ensuring that your application only processes requests from trusted sources.
    This practice helps to mitigate risks such as **Domain Name System** (**DNS**)
    rebinding attacks, where an attacker tricks a user’s browser into interacting
    with an unauthorized domain.
  prefs: []
  type: TYPE_NORMAL
- en: FastAPI provides middleware called `TrustedHostMiddleware`, which allows you
    to specify which hosts are considered trusted. Requests from any other hosts will
    be rejected. This recipe will guide you through setting up and using the `TrustedHostMiddleware`
    class to secure your FastAPI application by accepting requests only from specific
    hosts.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will apply the recipe to the `middleware_project` application. The application
    will need to be working with at least one endpoint to test.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s restrict the request to calls coming from localhost. In `main.py`, let’s
    import `TrustedHostMiddleware` and add it to the FastAPI object instance application,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'To test it, let’s try to refuse a call. Let’s spin up the server by broadcasting
    our service to the network. We can do it by specifying the undefined host address,
    `0.0.0.0`, when running `uvicorn`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This will make our application visible to the network.
  prefs: []
  type: TYPE_NORMAL
- en: To retrieve the address of your machine within the local network, you can run
    `ipconfig` on Windows or `ip addr` on Linux or macOS.
  prefs: []
  type: TYPE_NORMAL
- en: 'From another device connected to the same local network as the machine running
    our FastAPI application (such as a smartphone), open a browser and enter `http://<your
    local address>:8000`. If everything is correctly set up, you will see the following
    message in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'While on the machine running the FastAPI server, you will see a log message
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This is all you need to set up middleware to prevent your application from being
    reached by undesired hosts.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can learn more about `TrustedHostMiddleware` on the FastAPI documentation
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: '*TrustedHostMiddleware*: [https://fastapi.tiangolo.com/advanced/middleware/#trustedhostmiddleware](https://fastapi.tiangolo.com/advanced/middleware/#trustedhostmiddleware)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since `TrustedHostMiddleware` is defined in the Starlette library, you can
    also find it in the Starlette documentation at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '*TrustedHostMiddleware*: [https://www.starlette.io/middleware/#trustedhostmiddleware](https://www.starlette.io/middleware/#trustedhostmiddleware)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing webhooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Webhooks** play a crucial role in modern web development by enabling different
    systems to communicate and respond to events in real time. They are essentially
    HTTP callbacks triggered by specific events in one system, which then send a message
    or payload to another system. This asynchronous event-driven architecture allows
    for seamless integration with third-party services, real-time notifications, and
    automated workflows. Understanding how to implement webhooks effectively will
    empower you to build more interactive and responsive applications.'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will see how to create webhooks in FastAPI. We will create
    a webhook that notifies the webhook subscribers for each request of the API, acting
    like a monitoring system. By the end of this recipe, you will be able to implement
    a robust webhook system in your FastAPI application, facilitating real-time communication
    and integration with other services.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To set up the webhook for sending requests to the subscriber, we will use custom
    ASGI middleware. Please ensure that you have already followed the *Creating custom
    ASGI middleware* recipe. We will be continuing our work on the `middleware_project`
    API. However, you will find guidelines on how to implement your webhook that can
    be easily adapted to the specific needs of your project.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are starting a new project from scratch, make sure to install the `fastapi`
    package with `uvicorn` in your environment. You can do this using `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Once you have the packages, we can start the recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To build a webhook system in our API, we will need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Set up the URL registration system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the webhook callbacks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Document the webhook.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s go through the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the URL registration system
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A webhook call will send an HTTP request to the list of URLs registered to the
    webhook. The API will require a URL registration system. This can be achieved
    by creating a dedicated endpoint that will store the URL in a stateful system,
    such as a database. However, for demonstration purposes, we will store the URLs
    in the application state, which might also be a good choice for small applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create it by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `main.py`, let’s create the lifespan context manager to store the registered
    URLs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s pass the lifespan as an argument to the FastAPI object, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we can create the endpoint to register the URL, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The endpoint will accept a text string in the body. If the `http` or `https`
    protocol is missing in the string, an `"http://"` string will be prepended to
    the URL before being stored.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You have just implemented the URL registration system. Now, let’s continue to
    implement the webhook callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the webhook callbacks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'After setting up the registration system, we can begin creating the webhook’s
    calls. As previously stated, this particular webhook will alert subscribers for
    every API call. We’ll utilize this information to develop specialized middleware
    that will handle the calls. Let’s do it by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a new module in the `middleware` folder called `webhook.py` and
    define the event to communicate with the subscribers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we define a coroutine that will be used to make the requests to the subscriber
    URLs, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The client sends a request to the URL. If the request fails, a message is printed
    to the terminal.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We then define the middleware that will intercept the request. We start with
    the imports, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We then add the `WebhookSenderMiddleware` class, as follows
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will filter only the HTTP requests, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We continue in the `same __call__` function by defining the `event` object
    to pass to the webhook subscribers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we iterate the calls over the URLs by running the `send_event_to_url`
    coroutine, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We finalize the method by returning the modified `receive` function to the
    application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have just defined the middleware that will make the calls.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now we need to import the `WebhookSenderMiddleWare` middleware in the application.
    We can do this inside `main.py` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The application will now include our middleware to handle the webhook callbacks.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: That is all you need to implement a complete webhook within your FastAPI application.
  prefs: []
  type: TYPE_NORMAL
- en: Documenting the webhook
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is important to provide API users with documentation on how the webhook functions.
    FastAPI allows us to document a webhook in the OpenAPI documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'To accomplish this, you need to create a function with an empty body and declare
    it as a webhook endpoint. You can do it in `main.py` as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also provide an example of the body content by adding specifications
    to the `Event` class in the `middleware/webhook.py` module, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: $ python ./http_server.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
