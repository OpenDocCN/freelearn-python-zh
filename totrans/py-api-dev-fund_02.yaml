- en: 2\. Starting to Build Our Project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learning Objectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: Build a Restful API service efficiently using the Flask-Restful package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build an extendable Flask project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perform CRUD operations using the model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test RESTful APIs using curl, httpie, and Postman
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will start to work on the food recipe-sharing platform and
    learn how to create a RESTful API application.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we've introduced APIs and learned a bit about HTTP and REST, we will
    work on building an application (the recipe-sharing app known as Smilecook). In
    this chapter, we aim to kick-start the actual project development. This is a recipe-sharing
    platform in which users can create accounts and share their own recipes with other
    users. As you can imagine, it will contain a lot of API endpoints for our users
    so that they can manage their recipes. We will be using the Flask-RESTful package
    to efficiently develop our RESTful API.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will talk about the **CRUD** (**Create, Read, Update, Delete**)
    of these recipes, as well as how to set the publish status of the recipe.
  prefs: []
  type: TYPE_NORMAL
- en: What is Flask-RESTful?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Flask-RESTful is a Flask extension that allows us to quickly develop RESTful
    APIs. Compared to the built-in wrapper, `@app.route('/')`, which we discussed
    in the previous chapter, Flask-RESTful allows us to maintain and structure the
    API endpoints in a much better and easier way.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will develop our project using this Flask extension so that
    you will see how we can structure our endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Using Flask-RESTful to Develop Our Recipe-Sharing Platform, "Smilecook"
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this book, we are going to develop a recipe-sharing platform called **Smilecook**.
    Beginning with this chapter, we will start adding functions to it. We believe
    this approach will help you learn about the key concepts and skills you will need
    so that you can develop this application and help it reach its full potential,
    while at the same time helping you understand the entire development workflow.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will build the basic CRUD functions of the recipes. The Flask-RESTful
    package allows us to structure our code in a more comprehensive way. We will define
    certain methods in a resource and link them to the endpoints. The flow of a GET
    request, for example, will be for the request to be sent to the endpoints (`http://localhost:5000/recipes`),
    which will then be handled by the `GET` method we are going to implement in the
    resource. This will result in the recipes being returned to us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from the basic CRUD functions, we will also implement the publish and
    unpublish functions on these recipes. This can be done through the `PUT` and `DELETE`
    methods, which can be found in the `RecipePublishResource` class. We will link
    these two methods to the `http://localhost:5000/recipes/1/publish` endpoint (for
    the recipe whose *ID = 1*). For details of our endpoint design, please refer to
    the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/C15309_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.1: Details of our endpoint designs'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Virtual Environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PyCharm will help us create a virtual environment. We want to develop our project
    in its own virtual environment in order to keep it isolated. Due to this, we will
    have absolute control over the versions of the packages that we are going to use.
  prefs: []
  type: TYPE_NORMAL
- en: The best way to learn is through practice. Let's get our hands dirty now!
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5: Creating a Development Project in PyCharm'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before you start developing the Python application, you''ll need to create
    a development project in PyCharm. PyCharm manages things using projects. In this
    exercise, you will learn how to create a new development project in PyCharm called
    Smilecook. You will also need to install the necessary packages for this project.
    Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the project and name it **smilecook**:![](img/C15309_02_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 2.2: Creating a project'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: Check the project structure and ensure that the virtual environment has been
    created. Once the module has been created, we will be able to see the project's
    hierarchy on the left-hand side panel. We can see the **venv** folder under the
    project folder, which was created and activated by PyCharm. Now, when we write
    code under this project, it will be run in the virtual environment:![](img/C15309_02_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 2.3: Checking the project structure and ensuring that the virtual environment
    has been created'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Install the required packages for this chapter. To do this, create a file called
    `requirements.txt` under our project folder. Type in the following code to specify
    the packages you want to install:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the `pip` command to install these packages. After that, in the `pip` command
    to install the packages that we specified in the `requirements.txt` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You should now see something similar in the following screenshot. Here, we can
    see that the packages are being installed on the virtual environment:![](img/C15309_02_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 2.4: Installing the packages on the virtual environment'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Congratulations! You have created a PyCharm project for our Smilecook application.
    This is the first step of you embarking on your journey as a developer!
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Recipe Model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you can imagine, a recipe may have several attributes. To save every detail
    of these attributes, we will model the recipe using a class. This recipe class
    is going to have several essential attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a brief description of the attributes that we will define in the recipe
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name`: The name of the recipe.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`description`: The description of the recipe.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`num_of_servings`: The number of servings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cook_time`: The cooking time required. This is an integer whose units are
    in seconds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`directions`: The directions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`is_publish`: The publish status of the recipe; the default is draft.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next exercise, we will show you how to code the recipe class so that
    it has these attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 6: Creating the Recipe Model'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this exercise, we will code the recipe model, step by step. The `recipe`
    class will contain the attributes that we discussed previously. The code file
    for this exercise can be found in `Lesson2/Exercise06/models/recipe.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create the recipe class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Right-click* on the project name, that is, Smilecook, and create a `Python
    Package`. Name it `models`:![](img/C15309_02_05.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 2.5: Creating a Python package and naming it models'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Then, create a file called `recipe.py` under `models` and type in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let's pause for a while and examine the code here. First, we define `recipe_list
    = []` so that we can store the recipes in the application memory. Then, we define
    the `get_last_id` function to get the ID of our last recipe. Later, when we create
    a new recipe, we will use this method to evaluate the last ID in `recipe_list`
    so that we can come up with a new ID for the new recipe.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Define the recipe class using the following code. Type the following code into
    `recipe.py`, right after the `get_last_id` function that we implemented:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `Recipe` class has the `__init__` constructor method, which will take in
    parameters such as `name`, `description`, `num_of_servings`, `cook_time`, and
    `directions`, and create the recipe object based on that. The ID is self-incremented
    and `is_publish` is set to `false` by default. This means that, by default, the
    recipe will be set to draft (not published).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the same `Recipe` class, define the `data` method for returning the data
    as a dictionary object. You will recall that, in Python, indentation matters.
    The following code is indented since it is under the `Recipe` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that we have built the recipe model, we will go ahead and build the API
    endpoint using Flask-RESTful.
  prefs: []
  type: TYPE_NORMAL
- en: Resourceful Routing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The main building blocks in Flask-RESTful are resources. Resources are built
    on top of Flask's pluggable view. The concept of resourceful routing is that we
    want to structure all the client requests around resources. In our recipe-sharing
    platform, we are going to group the CRUD actions on a recipe under `RecipeResource`.
    For publish and unpublish actions, we will group them under a different `RecipePublishResource`.
    This provides a clear structure that other developers can follow.
  prefs: []
  type: TYPE_NORMAL
- en: 'The way in which we can implement these resources is simple: we just need to
    inherit from the `flask_restful.Resource` class and implement the methods that
    correspond to the HTTP verb inside it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next exercise, we will define three subclasses: one for the collection
    of recipes, one for a single recipe, and one for publishing the recipe.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 7: Defining an API Endpoint for the Recipe Model'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To build an API endpoint, we need to define a class that inherits from `flask_restful.Resource`.
    Then, we can declare the get and post methods inside the class. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a folder called `resources` under the project and then create a file
    called `recipe.py` under the `resources` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: The code file for this can be found in the [https://github.com/TrainingByPackt/Python-API-Development-Fundamentals/tree/master/Lesson02/Exercise07/resources](https://github.com/TrainingByPackt/Python-API-Development-Fundamentals/tree/master/Lesson02/Exercise07/resources).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Import the necessary packages, classes, and functions using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Right after the preceding code import, create the `RecipeListResource` class.
    This class has `GET` and `POST` methods, which are used to get and create the
    recipe''s resources, respectively. We will finish the get method first:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we have created and implemented the `RecipeListResource` class, which
    inherits from `flask-restful.Resource`. The `get` method that we implemented is
    for, getting all the public recipes back. It does this by declaring a `data` list
    and getting all the recipes with `is_publish` = `true` in `recipe_list`. These
    recipes are appended to our `data` list and returned to the users.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the `post` method. This is used to create the recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this exercise, we have built two methods that handle the GET and POST client
    requests. The following table summarizes the methods that we have built in this
    exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/C15309_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.6: Client request methods that we used in this exercise'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We have skipped the step to jsonify the object before returning data to the
    client because Flask-RESTful has already done that for us behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: The `post` method that we built in this exercise is for creating a new recipe.
    It is a `POST` method. It does this by getting the JSON data back from the request
    using `request.get_json` and then creates the recipe object and stores that in
    `recipe_list`. Finally, it returns the recipe record with an HTTP status code
    **201 CREATED**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 8: Defining the Recipe Resource'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will define the recipe resource. We are going to use two
    methods: the get method, for getting back a single recipe; and the put method,
    for updating the recipe. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the `RecipeResource` resource and implement the `get` method by using
    the following sample code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Similarly, `RecipeResource` also inherits from `flask-restful.Resource`. The
    get method we are implementing here is getting back a single recipe. We do that
    by searching for `recipe_id` in `recipe_list`. We will only get back those recipes
    with `is_publish = true`. If no such recipe is found, we will return the message
    **recipe not found**. Otherwise, we will return the recipe, along with an HTTP
    status of **200 OK**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Implement the `put` method with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The second method we've implemented here is `put`. It gets the recipe details
    from the client request using `request.get_json` and updates the recipe object.
    Then, it returns the HTTP status code **200 OK** if everything goes well.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Here, we have built two methods for the recipe resources. The `GET` and `PUT`
    methods are used to handle the corresponding client request. The following table
    shows the methods that we have built for the `RecipeResource` class in this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/C15309_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.7: Methods that we have built for the RecipeResource class'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Exercise 9: Publishing and Unpublishing the Recipes'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the previous exercises, we created the recipe resources and their associated
    methods. Now, our Smilecook application can read/write actions on recipes. However,
    at the beginning of this chapter, we said that the recipes can have two Statuses
    (unpublished and published). This allows the user to continue updating their unpublished
    recipes before publishing them to the world. In this exercise, we will define
    the resource for publishing and unpublishing a recipe. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the `RecipePublic` resource and implement the `put` method that will
    handle the HTTP PUT request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`RecipePublishResource` inherits from `flask_restful.Resource`. The `put` method
    will locate the recipe with the passed-in `recipe_id` and update the `is_publish`
    status to true. Then, it will return `HTTPStatus.NO_CONTENT`, which shows us that
    the recipe has been published successfully.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Implement the `delete` method, which will handle the HTTP DELETE request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `delete` method is the opposite of the `put` method. Instead of setting
    `is_publish` to `true`, it sets it to `false` in order to unpublish the recipe.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can also see that we are using these methods in a flexible manner; the `put`
    method is not necessarily for update, and the `delete` method is not necessarily
    for removal.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following table shows all the methods that we have created in this exercise.
    Now that we have all three resources ready (`RecipeListResource`, `RecipeResource`,
    and `RecipePublishResource`), we will discuss endpoint configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/C15309_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.8: Methods that we used in this exercise'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If the client request is with an HTTP verb that has no corresponding handling
    method in the resource, Flask-RESTful will return the HTTP status code **405 Method
    Not Allowed**.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Endpoints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have defined all our resources, we will set up some endpoints so
    that users can send requests to them. These endpoints can be accessed by the users
    and are connected to specific resources. We will be using the `add_resource` method
    on the API object to specify the URL for these endpoints and route the client
    HTTP request to our resources.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the `api.add_resource(RecipeListResource, '/recipes')` syntax is
    used to link the route (relative URL path) to `RecipeListResource` so that HTTP
    requests will be directed to this resource. Depending on the HTTP verb (for example,
    `GET`, and `POST`), the request will be handled by the corresponding methods in
    the resource accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 10: Creating the Main Application File'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will create our `app.py` file, which will be our main
    application file. We will set up Flask and initialize our `flask_restful.API`
    there. Finally, we will set up the endpoints so that users can send requests to
    our backend services. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the `app.py` file under the project folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the necessary classes using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set up Flask and initialize `flask_restful.API` with our Flask app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add resource routing by passing in the URL so that it will route to our resources.
    Each resource will have its own HTTP method defined:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: In `RecipeListResource`, we have defined the `get` and `post` methods. So, when
    there is a GET HTTP request to the "/recipes" URL route, it will invoke the `get`
    method under `RecipeListResource` and get back all the published recipes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the preceding code, you will notice that we have used `<int: recipe_id >`
    in the code. It is there as a placeholder for the recipe ID. When a GET HTTP request
    has been sent to the `route "/recipes/2"` URL, this will invoke the get method
    under `RecipeResource` with a parameter, that is, `recipe_id = 2`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Save `app.py` and *right-click* on it to run the application. Flask will then
    start up and run on the localhost (`127.0.0.1`) at port `5000`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/C15309_02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.9: Flask started and running on localhost'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Congratulations! You have completed the API endpoint. Now, let's move on to
    testing. You can either test it in curl/httpie or Postman.
  prefs: []
  type: TYPE_NORMAL
- en: Making HTTP Requests to the Flask API using curl and httpie
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, we are going to use the `httpie` and `curl` commands to test our API endpoints.
    We will test the functions for getting all the recipes back from the server and
    create/update/delete, publish, and unpublish the recipes. The best way to learn
    this is to complete a hands-on exercise. Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 11: Testing the Endpoints Using curl and httpie'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we are going to use the httpie and curl commands to send
    requests to the endpoints so that we can create our first recipe. We want you
    to get comfortable using the httpie and curl command-line testing tool. Let''s
    get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the Terminal in PyCharm and type in the following commands. You can use
    either the httpie or curl command. The following is the httpie command (`= is
    for string and := is for non-string`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following is the curl command. The `-H` argument is used to specify the
    header in the client request. We will set `Content-Type: application/json` as
    the header here. The `-d` argument is used for HTTP POST data, that is, the recipe
    in JSON format:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Examine the response, you should see the following. Carefully examine it, it
    should be the same recipe as the one that was used in our request in *Step 1*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: Once the client request has been sent to the server using the HTTP `POST` method,
    the `post` method in `RecipeResource` will pick up the request and save the recipe
    in the request to the application memory. The new recipe will be appended in `recipe_list`.
    Once everything is done, it will return HTTP `201 CREATED` and the newly created
    recipe in JSON format.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We have successfully created our first recipe on the platform. This recipe is
    stored on the server-side and we already have the API to retrieve it. Let's continue
    by creating our second recipe and retrieving all our recipes in one go.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 12: Testing the Auto-Incremented Recipe ID'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we have implemented the auto-incremented ID in our Smilecook application,
    let''s see how it works in practice. In this exercise, we will create the second
    recipe using the httpie and curl commands. Note that the ID is auto- incremented
    for our second recipe. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a second recipe and note that the ID is automatically incremented. Send
    the following client request using httpie:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Alternatively, send the request using curl. Again, the `-H` argument is used
    to specify the header in the client request. We will set "`Content-Type: application/json`"
    as the header here. The `-d` argument is used for HTTP POST data, meaning that
    the recipe is in JSON format:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see the following response. Examine it carefully, it should be the
    same recipe as the one that was used in our request in *Step 1*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once the preceding client request has been sent to the server using the HTTP
    `POST` method, the `post` method in `RecipeResource` will pick up the request
    and save the recipe in the request to the application memory. The new recipe will
    be appended in `recipe_list`. This time, the ID will be automatically assigned
    to 2.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise 13: Getting All the Recipes Back'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will be using the httpie and curl commands to get back
    all the recipes that we have created. We are doing this to ensure that our recipes
    are there in the backend server. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Retrieve all the recipes by sending the following client request using httpie:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Alternatively, send the following request using curl. The `-i` argument is
    used to state that we want to see the response header. `-X GET` means that we
    are sending the client request using the HTTP `GET` method:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see the following response. Please examine it carefully:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once the preceding client request has been sent to the server using the HTTP
    GET method, the get method in `RecipeResource` will pick up the request and retrieve
    all the published recipes from `recipe_list` in the application memory.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: We should see an empty list in the HTTP response because all the recipes we
    have created in the previous steps are in draft form (not published).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise 14: Testing the Recipe Resources'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We have already tested the endpoints we built around the recipe resources.
    In this exercise, we will continue to use the httpie and curl commands to test
    the recipe publishing API. We can test it by sending requests asking to publish
    our recipes on the API endpoint. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the publish status of the recipe with ID 1\. We can send the following
    client request using the httpie command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Alternatively, we can use the following curl command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: Once the preceding client request has been sent to the server using the HTTP
    PUT method, the `put` method in `RecipePublishResource` will pick up the request
    and assign `recipe_id` to be 1\. The application will look for the recipe with
    `ID = 1` and update its publish status to `True`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You should see the following response. Please examine it carefully:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, retrieve all the published recipes and examine them. Then, send the following
    client request using httpie:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Alternatively, send the following request using curl. The `-i` argument is
    used to say that we want to see the response header. `-X GET` means that we are
    sending the client request using the HTTP GET method:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see the following response. Please examine it carefully:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once the preceding client request has been sent to the server using the HTTP
    `GET` method, the get method in `RecipeResource` will pick up the request and
    retrieve all the published recipes from `recipe_list` in the application memory.
    This time, because the recipe with ID 1 has been set to publish, we shall see
    it in the HTTP response.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise 15: Negative Testing'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the previous exercise, we successfully published our recipe. This is good
    because it shows us that the APIs that we''ve developed work. But the whole point
    of testing is to discover potential issues if any. We can perform so-called negative
    testing here. This is the process of deliberately testing the scenario with unwanted
    input. This exercise is going to test a request with an HTTP VERB that has no
    corresponding method defined in the resource. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Send the following request to the server-side. This HTTP method has not been
    defined; let''s see what happens:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following is the curl command, which does the same thing:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see the following response. Please examine it carefully:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We should see a response with an HTTP status of `RecipeListResource`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Negative testing is important. We always want our testing to be more complete
    and covers more scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 16: Modifying the Recipes'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In our Smilecook application, authors are allowed to update their recipes.
    It is like a blogging platform, where the authors can take their time to perfect
    their work, even after it has been published. Since we have already built the
    API, we would like to test it using Postman. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the PUT method to send the request to `localhost:5000/recipes/1`, along
    with the new recipe details:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Alternatively, send the following request using curl. The `-H` argument is
    used to specify the header in the client request. We will set "`Content-Type:
    application/json`" as the header here. The `-d` argument is used for HTTP POST
    data, meaning that the recipe will be in JSON format:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see the following response. Please examine it carefully:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once the preceding client request has been sent to the server using the HTTP
    PUT method, the `put` method in `RecipeResource` will pick up the request and
    assign `recipe_id` to be 1\. The application will look for the recipe with `id
    = 1` and update its details with those in the client request. The preceding response
    shows that the recipe with ID 1 is modified.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We just finished testing another important feature. You have been doing great.
    Let's keep going!
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 17: Getting Back Specific Recipes with a Certain ID'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So far, we have tested getting all the recipes back. But in the real world,
    a user will want to only get the recipes that they want to see. They can do this
    by using the recipe ID. This exercise will show you how to get a particular recipe
    with a certain ID. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Send the following client request using httpie:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Alternatively, use the following curl command, which does the same thing:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once the preceding client request has been sent to the server using the HTTP
    `GET` method, the get method in `RecipeResource` will pick up the request and
    assign `recipe_id` to be 1\. It will retrieve all the published recipes from `recipe_list`
    in the application memory with an HTTP status of HTTP `200`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We have just tested our Smilecook application and confirmed that it can give
    us back the recipe we want.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 3: Testing the APIs Using Postman'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We added quite a few functions in the previous exercise. Now, we need to make
    sure that they work properly before we move on and develop other functions. In
    this activity, instead of using httpie/curl, we will be testing our API using
    Postman. Please follow these high-level steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the first recipe using Postman.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the second recipe using Postman.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Retrieve all the recipes using Postman.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the recipes to published using Postman.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Retrieve all the recipes using Postman again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify the recipe using Postman.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get a specific recipe back using Postman.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution to this activity can be found on page 293.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Activity 4: Implementing the Delete Recipe Function'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this activity, you will implement the delete recipe function in the Smilecook
    application yourself. Do this by adding a delete function to `RecipeResource`,
    similar to what we did in the previous exercises. Then, we will follow the standard
    software development life cycle flow, which is used to test our implementation,
    using Postman. Follow these steps to complete this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the delete function to `RecipeResource`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start up the Flask server for testing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the first recipe using Postman.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the recipe using Postman.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution to this activity can be found on page 299.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we built the RESTful API using the Flask-RESTful package. By
    doing this, you have seen how simple and easy it is to perform such tasks. We
    are building our project in a structural manner, which allows us to easily extend
    the project in the subsequent chapters. In this chapter, we created the models
    and resources folder; we will be developing more models and resources later in
    this book. So far, our food recipe-sharing platform, Smilecook, is capable of
    performing CRUD, as well as setting the publish status of the recipe. We have
    also tested the application to make sure it is working properly. Finally, you
    started to realize the power of Postman, which greatly automates the whole testing
    process. In the next chapter, we will learn about how to perform data validation.
  prefs: []
  type: TYPE_NORMAL
