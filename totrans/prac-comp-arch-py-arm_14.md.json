["```py\n\n      bsr abc    @ Call the subroutine on the line labeled abc\n      . . .\n      . . .\nabc:  . . .      @ Subroutine abc entry point\n      . . .\n      rts        @ Subroutine abc return to calling point\n```", "```py\n\n        bl     sub_A          @ Branch to sub_A with link and save return address in r14\n```", "```py\n\n        mov    pc,lr          @ We can also write this as mov r15,r14\n```", "```py\n\nFunc1:  cmp    r0,#0          @ Test for x > 0\n        movgt  r0,r0, lsl #4  @ If x > 0 then x = 16x\n        addgt  r0,r0,#1       @ If x > 0 then x = 16x + 1\n        movle  r0,r0, lsl #5  @ ELSE if x < 0 THEN x = 32x\n        mov    pc,lr          @ Return by restoring saved PC\n```", "```py\n\nPUSH:    [SP]   ← [SP] – 4    @ Move stack pointer up one word (up toward lower addresses)\n         [[SP]] ← data        @ Push data onto the stack. Push uses pre-decrementing.\nPULL:    data  ← [[SP]]       @ Pull data off the stack by reading TOS\n```", "```py\n         [SP]  ← [SP] + 4     @ Move stack pointer down one word (pull uses post-incrementing)\n```", "```py\n\n      sub  r13,r13,#4       @ Pre-decrement the stack pointer (r13 is used as the SP)\n      str  r15,[r13]        @ Push the return address in r15 on the stack\n      b    Target           @ Jump to the target address\n        ...                 @ Return here\n```", "```py\n\n      ldr  r12,[r13],#+4    @ Get saved PC from stack and post-increment the stack pointer\n      mov  r15,r12          @ Load PC with return address\n```", "```py\n\n.section .text\n.global _start\n_start: mov  r0,#9          @ Dummy operation\n        sub  sp,sp,#4       @ Decrement stack\n        str  pc,[sp]        @ Save pc on stack\n        b    target         @ Branch to subroutine \"target\"\n        mov  r2,#0xFFFFFFFF @ Return here ... this is a marker\n        nop                 @ Dummy operation\n        mov  r7,#1          @ Set up exit code\n        svc  0              @ Leave program\ntarget: mov  r1,#0xFF       @ Subroutine ... dummy operation\n        ldr  r12,[sp],#+4   @ Pull pc off the stack\n        mov  r15,r12        @ Return\n```", "```py\n        .end\n```", "```py\n\nRegister group: general\nr0             0x9                 9\nr1             0xff                255\nr2             0xffffffff          4294967295\nr12            0x10064             65636\nsp             0xbefff380          0xbefff380\nlr             0x0                 0\npc             0x1006c             0x1006c <_start+24>\n```", "```py\n\nB+ 0x10054 <_start>        mov    r0, #9\n   0x10058 <_start+4>      sub    sp, sp, #4\n   0x1005c <_start+8>      str    pc, [sp]\n   0x10060 <_start+12>     b      0x10074 <target>\n   0x10064 <_start+16>     mvn    r2, #0\n   0x10068 <_start+20>     nop                    ; (mov r0, r0)\n  ^0x1006c <_start+24>     mov    r7, #1\n   0x10070 <_start+28>     svc    0x00000000\n   0x10074 <target>        mov    r1, #255        ; 0xff\n   0x10078 <target+4>      pop    {r12}           ; (ldr r12, [sp], #4)\n   0x1007c <target+8>      mov    pc, r12\n```", "```py\n\n    adr  r0,DataToGo    @ Load r0 with the address of the data area\n    ldr  r1,[r0],#4     @ Load r1 with the word pointed at by r0 and update the pointer\n    ldr  r2,[r0],#4     @ Load r2 with the word pointed at by r0 and update the pointer\n    ldr  r3,[r0],#4     @ and so forth for the remaining registers r3 and r5…\n    ldr  r5,[r0],#4\n```", "```py\n\nstmia  r0!,{r1-r3,r5}   @ Note block move syntax. The register list is in braces\n                        @ r0! is the destination register with auto indexing\n                        @ The register list is {r1-r3,r5} r1,r2,r3,r5\n```", "```py\n\n           .text                       @ This is a code section\n           .global _start              @ Define entry point for code execution\n _start:    nop                        @ nop = no operation and is a dummy instruction\n           ldr    r0,=0xFFFFFFFF       @ Dummy values for testing\n           ldr    r1,=0x11111111\n           ldr    r2,=0x22222222\n           ldr    r3,=0x33333333\n           ldr    r4,=0x44444444\n           ldr    r5,=0x55555555\n           ldr    r0,adr_mem           @ Load pointer r0 with memory\n           stmia  r0!,{r1-r3,r5}       @ Do a multiple load to memory\n           mov    r10,r0               @ Save r0 in r10 (for debugging)\n           ldmdb  r0!,{r6-r9}          @ Now load data from memory\n           mov    r11,r0\n           mov    r1,#1                @ Terminate command\n           svc    0                    @ Call OS to leave\n           .word  0xFFFFFFFF           @ A dummy value for testing\n           .word  0xAAAAAAAA           @ Another dummy value\nadr_mem:   .word  memory               @ The address of the memory for storing data\n           .data                       @ Declare a memory segment for the data\nmemory:    .word  0xBBBBBBBB           @ Yet another memory marker\n           .space 32                   @ Reserve space for storage (8 words)\n           .word  0xCCCCCCCC           @ Final memory marker\n           .end\n```", "```py\n\npi@raspberrypi:~/Desktop $ as -g -o blockMove1.o blockMove1.s\npi@raspberrypi:~/Desktop $ ld -o blockMove1 blockMove1.o\npi@raspberrypi:~/Desktop $ gdb blockMove1\n(gdb) b 1\nBreakpoint 1 at 0x10078: file blockMove1.s, line 6.\n(gdb) r\nStarting program: /home/pi/Desktop/blockMove1\nBreakpoint 1, _start () at blockMove1.s:6\n6               ldr    r0,=0xFFFFFFFF         @ Dummy value for testing\n(gdb) i r\nr0             0x0                 0          # These are the initial registers before we start\nr1             0x0                 0\nr2             0x0                 0\nr3             0x0                 0\nr4             0x0                 0\nr5             0x0                 0\nr6             0x0                 0\nr7             0x0                 0\nr8             0x0                 0\nr9             0x0                 0\nr10            0x0                 0\nr11            0x0                 0\nr12            0x0                 0\nsp             0xbefff380          0xbefff380 # The OS sets up the stack pointer\nlr             0x0                 0\npc             0x10078             0x10078 <_start+4>  # The OS sets up stack pointer\n```", "```py\n\n(gdb) si 1\n7              ldr    r1,=0x11111111          # Here we trace seven instructions\n8              ldr    r2,=0x22222222\n9              ldr    r3,=0x33333333\n10             ldr    r4,=0x44444444\n11             ldr    r5,=0x55555555\n12             ldr    r0,adr_mem              @ Load pointer r0 with memory\n13             stmia  r0!,{r1-r3,r5}          @ Multiple load to memory\n(gdb) i r\nr0             0x200cc             131276\n```", "```py\n\nr1             0x11111111          286331153\nr2             0x22222222          572662306\nr3             0x33333333          858993459\nr4             0x44444444          1145324612\nr5             0x55555555          1431655765\nr6             0x0                 0\n```", "```py\n\npc             0x10094             0x10094 <_start+32>\n(gdb) x/16xw 0x200cc\n0x200cc:    0xbbbbbbbb    0x00000000    0x00000000    0x00000000\n0x200dc:    0x00000000    0x00000000    0x00000000    0x00000000\n0x200ec:    0x00000000    0xcccccccc    0x00001141    0x61656100\n0x200fc:    0x01006962    0x00000007    0x00000108    0x0000001c\n```", "```py\n\n(gdb) si 1\n14               mov    r10,r0\n15               ldmdb  r0!,{r6-r9}             @ Now load data from memory\n(gdb) i r\nr0             0x200dc             131292\nr1             0x11111111          286331153\nr2             0x22222222          572662306\nr3             0x33333333          858993459\nr4             0x44444444          1145324612\nr5             0x55555555          1431655765\nr6             0x0                 0\nr10            0x200dc             131292\npc             0x1009c             0x1009c <_start+40>\n```", "```py\n\n(gdb) x/16xw 0x200cc\n0x200cc:    0x11111111    0x22222222    0x33333333    0x55555555\n0x200dc:    0x00000000    0x00000000    0x00000000    0x00000000\n0x200ec:    0x00000000    0xcccccccc    0x00001141    0x61656100\n```", "```py\n0x200fc:    0x01006962    0x00000007    0x00000108    0x0000001c\n```", "```py\n\n(gdb) si 1\n16               mov    r11,r0\n18               mov    r1,#1      @ Terminate command\n(gdb) i r\nr0             0x200cc             131276\nr1             0x11111111          286331153\nr2             0x22222222          572662306\nr3             0x33333333          858993459\nr4             0x44444444          1145324612\nr5             0x55555555          1431655765\nr6             0x11111111          286331153       Data copied to registers r6 - r9\nr7             0x22222222          572662306\nr8             0x33333333          858993459\nr9             0x55555555          1431655765\nr10            0x200dc             131292\n```", "```py\n\n(gdb) disassemble /m\nDump of assembler code for function _start:\n5 _start:            nop\n   0x00010074 <+0>:  nop ;  (mov r0, r0)\n6                    ldr     r0,=0xFFFFFFFF  @ Dummy value for testing\n=> 0x00010078 <+4>:  mvn     r0, #0\n7                    ldr     r1,=0x11111111\n   0x0001007c <+8>:  ldr     r1, [pc, #52]   ; 0x100b8 <adr_mem+4>\n8                    ldr     r2,=0x22222222\n0x00010080 <+12>: ldr     r2, [pc, #52]   ; 0x100bc <adr_mem+8>\n9                    ldr     r3,=0x33333333\n   0x00010084 <+16>: ldr     r3, [pc, #52]   ; 0x100c0 <adr_m\n10                   ldr     r4,=0x44444444\n   0x00010088 <+20>: ldr     r4, [pc, #52]   ; 0x100c4 <adr_mem+16>\n11                   ldr     r5,=0x55555555      \n   0x0001008c <+24>: ldr     r5, [pc, #52]   ; 0x100c8 <adr_mem+20>\n12                   ldr     r0,adr_mem      @ Load pointer r0 with memory\n   0x00010090 <+28>: ldr     r0, [pc, #28]   ; 0x100b4 <adr_mem>\n13                   stmia   r0!,{r1-r3,r5}  @ Do a multiple load to memory\n   0x00010094 <+32>: stmia   r0!, {r1,r2,r3,r5}\n14                   mov     r10,r0\n   0x00010098 <+36>: mov     r10, r0\n15                   ldmdb   r0!,{r6-r9}     @ Now load data from memory\n   0x0001009c <+40>: ldmdb   r0!, {r6,r7,r8,r9}\n16                   mov     r11,r0\n   0x000100a0 <+44>: mov     r11, r0\n18                   mov     r1,#1           @ Terminate command\n   0x000100a4 <+48>: mov     r1, #1\n19                   svc     0               @ Call OS to leave  \n   0x000100a8 <+52>: svc 0x00000000\n   0x000100ac <+56>: ; <UNDEFINED> instruction: 0xffffffff\n   0x000100b0 <+60>: bge 0xfeabab60\n   0x000100b4 <+0>:  andeq r0, r2, r12, asr #1\n```", "```py\n\n(gdb) x/32xw 0x100a8                         This displays 32 words of memory\n0x100a8 <_start+52>:  0xef000000 0xffffffff 0xaaaaaaaa 0x000200cc\n0x100b8 <adr_mem+4>:  0x11111111 0x22222222 0x33333333 0x44444444\n0x100c8 <adr_mem+20>: 0x55555555 0xbbbbbbbb 0x00000000 0x00000000\n0x100d8:              0x00000000 0x00000000 0x00000000 0x00000000\n0x100e8:              0x00000000 0x00000000 0xcccccccc 0x00001141\n0x100f8:              0x61656100 0x01006962 0x00000007 0x00000108\n0x10108:              0x0000001c 0x00000002 0x00040000 0x00000000\n```", "```py\n0x10118:              0x00010074 0x00000058 0x00000000 0x00000000\n```", "```py\n\n7                      ldr      r1,=0x11111111\n   0x0001007c <+8>:    ldr     r1, [pc, #52]   ; 0x100b8 <adr_mem+4>\n```", "```py\n\n12                   ldr     r0,adr_mem      @ Load pointer r0 with memory\n   0x00010090 <+28>: ldr     r0, [pc, #28]   @ 0x100b4 <adr_mem>\n```", "```py\n\nPush r0 to r3 on the stack    stmfd sp!,{r0-r3}     or    stmdb sp!,{r0-r3}\nPull r0 to r3 off the stack      ldmfd sp!,{r0-r3}     or    ldmia sp!,{r0-r3}\n```", "```py\n\nPush r0 to r3 on the stack    stmfa sp!,{r0-r3}     or    stmib sp!,{r0-r3}\nPull r0 to r3 off the stack      ldmfa sp!,{r0-r3}     or    ldmda sp!,{r0-r3}\n```", "```py\n\nPush r0 to r3 on the stack    stmea sp!,{r0-r3}     or    stmia sp!,{r0-r3}\nPull r0 to r3 off the stack      ldmea sp!,{r0-r3}     or    ldmdb sp!,{r0-r3}\n```", "```py\n\n                                   @ Call abc and save some registers\n       bl     abc                  @ Call subroutine abc, save return address in lr (r14)\n       .\nabc:   stmfd  sp!,{r0-r3,r8}       @ Subroutine abc. Block move saves registers on the stack\n       .\n       .                           @ Body of code\n       .\n       ldmfd  sp!,{r0-r3,r8}       @ Subroutine complete. Now restore the registers\n       mov    pc,lr                @ Copy the return address in lr to the PC\n```", "```py\n\nabc:   stmfd  sp!,{r0-r3,r8,lr}    @ Save registers plus address in link register\n        :\n       ldmfd  sp!,{r0-r3,r8,pc}    @ Restore registers and transfer lr to PC\n```", "```py\n\n       adr    r0,pqr               @ r0 points to source (note the pseudo-op adr)\n       adr    r1,xyz               @ r1 points to the destination\n       mov    r2,#32               @ 32 blocks of eight words to move (256 words total)\nLoop:  ldrfd  r0!,{r3-r10}         @ REPEAT Load 8 registers in r3 to r10\n       strfd  r1!,{r3-r10          @ Store the registers (moving 8 words at once)\n       subs   r2,r2,#1             @ Decrement loop counter\n       bne    Loop                 @ Loop back until zero\n```"]