<html><head></head><body>
<div><div><div><h1 id="_idParaDest-110" class="contributor"><a id="_idTextAnchor118" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/><a id="_idTextAnchor119" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>7</h1>
			<h1 id="_idParaDest-111" class="contributor"><a id="_idTextAnchor120" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Building a Backend with FastAPI</h1>
			<p class="calibre5">In the previous chapters, you learned the basic mechanics of authentication and authorization, and now you are ready to implement it and secure a web API, built with FastAPI. In this chapter, you will put this knowledge to good use and create a simple, yet fully functional REST API showcasing used cars and their pictures.</p>
			<p class="calibre5">In this chapter, you will learn about the following actions, which can be thought of as a loosely coupled blueprint when creating a REST API with FastAPI.</p>
			<p class="calibre5">This chapter will cover the following topics:</p>
			<ul class="calibre14">
				<li class="calibre17">Connecting the FastAPI instance to MongoDB Atlas by using the Python Motor driver</li>
				<li class="calibre17">Defining the Pydantic models according to the specification and initial creation of the FastAPI application</li>
				<li class="calibre17">Creating the API router and implementing CRUD operations</li>
				<li class="calibre17">Securing the API with a JWT</li>
				<li class="calibre17">Deployment to Render</li>
			</ul>
			<h1 id="_idParaDest-112" class="contributor"><a id="_idTextAnchor121" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Technical requirements</h1>
			<p class="calibre5">The requirements for this chapter are similar to those defined earlier. You will work with:</p>
			<ul class="calibre14">
				<li class="calibre17">Python 3.11.7 or higher</li>
				<li class="calibre17">Visual Studio Code</li>
				<li class="calibre17">An account on MongoDB Atlas</li>
			</ul>
			<p class="calibre5">Later on, you will need to create an account on the image-hosting service <strong class="bold">Cloudinary</strong> (free) and the <strong class="bold">Render</strong> platform for hosting the API (also a free tier account). Again, you will use HTTPie for manually testing the API endpoints that you are going to implement.</p>
			<p class="calibre5">Let’s start by understanding the application to be developed and what the backend will require.</p>
			<h1 id="_idParaDest-113" class="contributor"><a id="_idTextAnchor122" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Introducing the application</h1>
			<p class="calibre5">It is much easier to start working with a framework while having a specific problem that needs solving, even if the requirements are somewhat vague. The task at hand is rather simple: you need to create a REST API backend for storing and retrieving data about used cars for a fictional car sales company.</p>
			<p class="calibre5">The data structure that describes a vehicle is rather simple but can become more complicated as soon as you delve into the details such as engine models, interior colors, types of suspension, and so on.</p>
			<p class="calibre5">In your first simple <strong class="bold">create</strong>, <strong class="bold">read</strong>, <strong class="bold">update</strong>, <strong class="bold">delete</strong> (<strong class="bold">CRUD</strong>) application, you will keep the resource data limited. A car will be described by the following fields:</p>
			<ul class="calibre14">
				<li class="calibre17"><code>Brand</code>: The brand of the car (Ford, Renault, etc.), represented by a <em class="italic">string</em></li>
				<li class="calibre17">Make or model: For example, Fiesta or Clio, represented by a <em class="italic">string</em></li>
				<li class="calibre17"><code>Year</code>: The year of production, an <em class="italic">integer</em> limited to a reasonable range (1970–2024)</li>
				<li class="calibre17"><code>Cm3</code>: The displacement of the engine, proportional to the power of the engine, a ranged <em class="italic">integer</em></li>
				<li class="calibre17"><code>kW</code>: Power of the engine in kW, an <em class="italic">integer</em></li>
				<li class="calibre17"><code>Km</code>: How many kilometers the car has travelled, an <em class="italic">integer</em> in the hundreds of thousands range</li>
				<li class="calibre17"><code>Price</code>: The price in euros</li>
				<li class="calibre17">An image URL: This is optional</li>
			</ul>
			<p class="calibre5">An essential feature of every car sales website is the presence of images, so you will implement an image-uploading pipeline with one of the leading services for image hosting and processing—<strong class="bold">Cloudinary</strong>. Later, you will aid the employees even more by generating compelling copy text for each car model, which will make the API richer while showcasing FastAPI’s simplicity.</p>
			<h1 id="_idParaDest-114" class="contributor"><a id="_idTextAnchor123" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Creating an Atlas instance and a collection</h1>
			<p class="calibre5">Log in to your Atlas account, and create a new database called <code>carBackend</code> inside a collection named <code>cars</code>. You can refer to <a href="B22406_02.xhtml#_idTextAnchor026" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><em class="italic">Chapter 2</em></a>, <em class="italic">Setting Up the Database with MongoDB</em>. After creating the database and the collection, take note of the MongoDB connection string and save it in a text file for later, when you will be creating your secret environment keys.</p>
			<h2 id="_idParaDest-115" class="about-the-author"><a id="_idTextAnchor124" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Setting up the Python environment</h2>
			<p class="calibre5">After creating the MongoDB database on Atlas and connecting it, it is time for you to set up a brand new Python virtual environment and install the requirements:</p>
			<ol class="calibre14">
				<li class="calibre15">First, create a plain text file called <code>requirements.txt</code> and insert the following lines in it:<pre class="source-code">
fastapi==0.111.0
motor==3.4.0
uvicorn==0.29.0
pydantic-settings==2.2.1</pre></li>				<li class="calibre15">The package versioning is important if you want to be able to reproduce exactly the code used in this book and you can always refer to the <code>requirements.txt</code> file in the book’s repository. Run the <code>pip</code> installation command that reads the previously defined requirements file:<pre class="source-code">
pip install -r requirements.txt</pre></li>			</ol>
			<p class="calibre5">Your environment is ready. Now, armed with the knowledge of Python type hints and Pydantic from <a href="B22406_03.xhtml#_idTextAnchor051" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><em class="italic">Chapter 3</em></a>, <em class="italic">Python Type Hints and Pydantic</em>, you will model this relatively simple car data structure.</p>
			<h2 id="_idParaDest-116" class="about-the-author"><a id="_idTextAnchor125" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Defining the Pydantic models</h2>
			<p class="calibre5">Let’s begin with the first Pydantic model, for a single car. Here, one of the main problems that need to be solved upfront is how to serialize and define the MongoDB <code>ObjectID</code> key in Pydantic. While there are different ways of representing the <code>ObjectID</code>, the simplest and the one currently recommended by MongoDB is to cast the <code>ObjectID</code> to a string. You can refer to the following documentation for further details:  <a href="https://www.mongodb.com/developer/languages/python/python-quickstart-fastapi/" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2">https://www.mongodb.com/developer/languages/python/python-quickstart-fastapi/</a>.</p>
			<p class="calibre5">MongoDB uses the field name <code>_id</code> for the identifier. In Python, since attributes that start with an underscore have a special meaning, you cannot use the original field name for model population.</p>
			<p class="calibre5">Pydantic aliases provide a simple and elegant solution; you can name the field <code>id</code> but also give it an alias of <code>_id</code> and set the <code>populate_by_name</code> flag to <code>True</code>, as shown in <a href="B22406_03.xhtml#_idTextAnchor051" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><em class="italic">Chapter 3</em></a>, <em class="italic">Python Type Hints </em><em class="italic">and Pydantic</em>.</p>
			<p class="calibre5">Finally, you will need to cast the <code>ObjectID</code> as a string. To do so, you will use a simple Python annotation, and the Pydantic <code>BeforeValidator</code> module.</p>
			<ol class="calibre14">
				<li class="calibre15">Create a folder named <code>Chapter7</code> and a <code>models.py</code> file inside of it, and start with the imports and the <code>ObjectID</code> type:<pre class="source-code">
<strong class="bold">#models.py</strong>
from typing import Optional, Annotated, List
from pydantic import BaseModel, ConfigDict, Field, BeforeValidator, field_validator
PyObjectId = Annotated[str, BeforeValidator(str)]</pre></li>				<li class="calibre15">After the imports, and creating a new type, <code>PyObjectId</code>, which will be used to represent MongoDB’s original <code>ObjectID</code> as a string, continue populating the model:<pre class="source-code">
class CarModel(BaseModel):
    id: Optional[PyObjectId] = Field(
       alias="_id", default=None)
    brand: str = Field(...)
    make: str = Field(...)
    year: int = Field(..., gt=1970, lt=2025)
    cm3: int = Field(..., gt=0, lt=5000)
    km: int = Field(..., gt=0, lt=500000)
    price: int = Field(..., gt=0, lt=100000)</pre><p class="list-inset">These fields should be very familiar if you read the chapter on Pydantic; you are simply declaring the car fields, marking all of them as required, and setting some reasonable limits on the numerical quantities (<code>cm3</code>, <code>km</code>, <code>price</code>, and <code>year</code>).</p><p class="list-inset">Bear in mind that the number of car brands is limited, so it is possible and probably advisable to create an <strong class="bold">enumerated</strong> type for the brand name, but in this case, you will keep things simple.</p></li>				<li class="calibre15">Add two convenient field validators that act as modifiers. You want to return the title of every car brand and model:<pre class="source-code">
@field_validator("brand")
@classmethod
def check_brand_case(cls, v: str) -&gt; str:
    return v.title()
@field_validator("make")
@classmethod
def check_make_case(cls, v: str) -&gt; str:
    return v.title()</pre></li>				<li class="calibre15">To complete the model, finally, add a configuration dictionary that will allow it to be populated by name and allow arbitrary types:<pre class="source-code">
model_config = ConfigDict(
    populate_by_name=True,
    arbitrary_types_allowed=True,
    json_schema_extra={
        "example": {
            "brand": "Ford",
            "make": "Fiesta",
            "year": 2019,
            "cm3": 1500,
            "km": 120000,
            "price": 10000,
        }
    },
)</pre></li>				<li class="calibre15">You can now test the model by adding the following (temporary) lines at the end of the file, outside of the class definition, and running it:<pre class="source-code">
test_car = CarModel(
    brand="ford", make="fiesta", year=2019, cm3=1500, km=120000, price=10000
)
print(test_car.model_dump())</pre></li>				<li class="calibre15">Run the <code>models.py</code> file:<pre class="source-code">
python models.py
{'id': None, 'brand': 'Ford', 'make': 'Fiesta', 'year': 2019, 'cm3': 1500, 'km': 120000, 'price': 10000}.</pre><p class="list-inset">Now, it’s time to define other models for updating a single instance and getting a list of cars. The <code>update</code> model will need to allow only specific fields to be changed. In theory, only the <code>price</code> should be updatable since cars are pretty immutable objects in their own right, but this system will allow for some ambiguity and situations in which the inserted data is just wrong and needs to be manually corrected via the API.</pre></li>				<li class="calibre15">After deleting or commenting out the testing lines from <code>models.py</code>, proceed with creating the <code>UpdateCarModel</code> model:<pre class="source-code">
class UpdateCarModel(BaseModel):
    brand: Optional[str] = Field(...)
    make: Optional[str] = Field(...)
    year: Optional[int] = Field(..., gt=1970, lt=2025)
    cm3: Optional[int] = Field(..., gt=0, lt=5000)
    km: Optional[int] = Field(..., gt=0, lt=500 * 1000)
    price: Optional[int] = Field(..., gt=0, lt=100 * 1000)</pre><p class="list-inset">The remaining part of the class is identical to the <code>CarModel</code> class and will be omitted for brevity.</p></li>				<li class="calibre15">Finally, the <code>ListCarsModel</code> class will be very simple, as it only needs to handle a list of <code>CarModel</code> classes:<pre class="source-code">
class CarCollection(BaseModel):
    cars: List[CarModel]</pre><p class="list-inset">With the models now in place, you are ready to make a simple test and see how <code>ListCarsModel</code> works.</p></li>				<li class="calibre15">Create a new testing file called <code>test_models.py</code>, add the following lines in order to create two different car models and a list, and then print a model dump:<pre class="source-code">
from models import CarCollection, CarModel
test_car_1 = CarModel(
    brand="ford", make="fiesta", year=2019, cm3=1500, km=120000, price=10000
)
test_car_2 = CarModel(
    brand="fiat", make="stilo", year=2003, cm3=1600, km=320000, price=3000
)
car_list = CarCollection(cars=[test_car_1, test_car_2])
print(car_list.model_dump())</pre><p class="list-inset">If you run the <code>test_models.py</code> file with Python, the output should be the following:</p><pre class="source-code">{'cars': [{'id': None, 'brand': 'Ford', 'make': 'Fiesta', 'year': 2019, 'cm3': 1500, 'km': 120000, 'price': 10000}, {'id': None, 'brand': 'Fiat', 'make': 'Stilo', 'year': 2003, 'cm3': 1600, 'km': 320000, 'price': 3000}]}</pre></li>			</ol>
			<p class="calibre5">The models, at least an initial iteration of them (and MongoDB is excellent for iterative data modeling), are complete, so you can start scaffolding your FastAPI application structure in the next section.</p>
			<h1 id="_idParaDest-117" class="contributor"><a id="_idTextAnchor126" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Scaffolding a FastAPI application</h1>
			<p class="calibre5"><code>Motor</code> driver. Initially, you will only create a generic and minimal FastAPI application, and gradually add functionality.</p>
			<p class="calibre5">You will begin by storing the secret environment data—in your case, just the MongoDB Atlas database URL—into a <code>.env</code> file. These values should be always kept outside the reach of the repositories. You want to be able to connect to your MongoDB database and verify whether the connection is successful.</p>
			<h2 id="_idParaDest-118" class="about-the-author"><a id="_idTextAnchor127" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Creating a .env file to keep the secrets</h2>
			<p class="calibre5">For managing values that should be kept secret and out of the version control system, you will use an environment file (<code>.env</code>). Perform the following steps to set up the environment variables and exclude them from the version control:</p>
			<ol class="calibre14">
				<li class="calibre15">First, create a <code>.env</code> file and, inside it, put your secret connection string in the following format, without quotes:<pre class="source-code">
DB_URL=mongodb+srv://&lt;USERNAME&gt;:&lt;PASSWORD&gt;@cluster0.fkm24.mongodb.net/?retryWrites=true&amp;w=majority&amp;appName=Cluster0
DB_NAME=carBackend</pre><p class="list-inset">This <code>.env</code> file will later host other secret files for external services that you might need to use in your API development.</p></li>				<li class="calibre15">Now, create a <code>.gitignore</code> file, and populate it with the basic entries: directories and files that are not to be tracked by Git. Open a file, name it <code>.gitignore</code>, and insert the following:<pre class="source-code">
__pycache__/
.env
venv/</pre><p class="list-inset">There are numerous examples of Python-related <code>.gitignore</code> files on the web, so feel free to look around, but this will be more than sufficient for our purposes.</p></li>				<li class="calibre15">Now, you can put the working directory under version control with the following Git commands:<pre class="source-code">
git init
git add .
git commit -m "initial commit"</pre></li>			</ol>
			<h3 class="calibre8">Creating a Pydantic configuration with pydantic_settings</h3>
			<p class="calibre5">In the next steps, you will use the previously created environment variables and provide them to the <code>pydantic_settings</code>—the Pydantic class for managing application settings, covered in <a href="B22406_03.xhtml#_idTextAnchor051" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><em class="italic">Chapter 3</em></a><em class="italic">, Python Type Hints and Pydantic</em>. This class will later be easily invoked wherever the environment variables will be necessary.</p>
			<p class="calibre5">After this preparatory work, create a <code>config.py</code> file that will leverage the <code>pydantic_settings</code> package for managing your settings, as follows:</p>
			<ol class="calibre14">
				<li class="calibre15">Create a configuration file, aptly named <code>config.py</code>, which you will use for reading the settings of the application. You will be able to change them easily later when you introduce some automated testing or make different settings for production, a different database, and so on. Paste the following code into <code>config.py</code>:<pre class="source-code">
from typing import Optional
from pydantic_settings import BaseSettings, SettingsConfigDict
class BaseConfig(BaseSettings):
    DB_URL: Optional[str]
    DB_NAME: Optional[str]
    model_config = SettingsConfigDict(env_file=".env", extra="ignore")</pre><p class="list-inset">Now, you will use these configuration settings to get the environment data to connect to the MongoDB Atlas instance.</p></li>				<li class="calibre15">Finally, you can start scaffolding the actual application file by creating a new Python file, named <code>app.py</code>. In this file, first, instantiate a FastAPI instance and create a root route with a simple message:<pre class="source-code">
from fastapi import FastAPI
app = FastAPI()
@app.get("/")
async def get_root():
    return {"Message": "Root working"}</pre></li>				<li class="calibre15">You should be able to run this bare-bones application in the terminal with your server of choice:<pre class="source-code">
uvicorn app:app</pre></li>			</ol>
			<p class="calibre5">The simple root message is available at <code>127.0.0.1:8000</code> and you have the application running.</p>
			<h3 class="calibre8">Connecting to Atlas</h3>
			<p class="calibre5">Now it is time to connect it to Atlas. To do so, you will use the <strong class="bold">Lifespan Events</strong> of FastAPI, which is the newer way of handling events that need to occur only once before the application starts up and begins receiving requests. Lifespan Events also allow you to handle events that should fire only after the application finishes handling requests.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The FastAPI website has excellent documentation about the topic: <a href="https://fastapi.tiangolo.com/advanced/events/" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2">https://fastapi.tiangolo.com/advanced/events/</a>.</p>
			<p class="calibre5">For the use case in this chapter, you will use an <strong class="bold">asynchronous context manager</strong> that will allow you to yield the application instance, and fire events before and after the application starts. Follow these steps:</p>
			<ol class="calibre14">
				<li class="calibre15">To showcase how this works, edit the <code>app.py</code> file:<pre class="source-code">
from contextlib import asynccontextmanager
from fastapi import FastAPI
@asynccontextmanager
async def lifespan(app: FastAPI):
    print("Starting up!")
    yield
    print("Shutting down!")
app = FastAPI(lifespan=lifespan)
@app.get("/")
async def get_root():
    return {"Message": "Root working!"}</pre><p class="list-inset">If you start the application with the same command as shown previously and then shut it down with <em class="italic">Ctrl+C</em>, you will see that the <code>print</code> statements display messages in the console.</p><p class="list-inset">The <code>lifespan</code> event async context is the mechanism you will use to connect to your Atlas instance, through the use of the settings.</p></li>				<li class="calibre15">Again, open up the <code>app.py</code> file, add the configuration settings, change the <code>lifespan</code> function, and bring in the <code>Motor</code> driver:<pre class="source-code">
from fastapi import FastAPI
from motor import motor_asyncio
from config import BaseConfig
settings = BaseConfig()
async def lifespan(app: FastAPI):
    app.client = motor_asyncio.AsyncIOMotorClient(settings.DB_URL)
    app.db = app.client[settings.DB_NAME]
    try:
        app.client.admin.command("ping")
        print("Pinged your deployment. You have successfully connected to MongoDB!")
        print("Mongo address:", settings.DB_URL)
    except Exception as e:
        print(e)
    yield
    app.client.close()
app = FastAPI(lifespan=lifespan)
@app.get("/")
async def get_root():
    return {"Message": "Root working!"}</pre></li>				<li class="calibre15">If you start the application now, you should receive a message similar to the following:<pre class="source-code">
INFO:     Started server process [28228]
INFO:     Waiting for application startup.
Pinged your deployment. You have successfully connected to MongoDB!
Mongo address: &lt;your connection string&gt;
INFO:     Application startup complete.
INFO:     Uvicorn running on http://127.0.0.1:8000 (Press</pre></li>			</ol>
			<p class="calibre5">You have implemented quite a lot in this setup:</p>
			<ul class="calibre14">
				<li class="calibre17">You have created the FastAPI instance, the backbone of your API.</li>
				<li class="calibre17">You have set the environment variables with <code>pydantic_settings</code> and they are, thus, manageable and maintainable.</li>
				<li class="calibre17">You have connected to the Atlas cluster that you have set up.</li>
				<li class="calibre17">You have also “attached“ the MongoDB database to the application, so you will be able to access it conveniently from the API routers through the request.</li>
			</ul>
			<p class="calibre5">Now, let's start implementing the routes for the <strong class="bold">CRUD</strong> operations, starting from a solid and expansible setup.</p>
			<h1 id="_idParaDest-119" class="contributor"><a id="_idTextAnchor128" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>CRUD operations</h1>
			<p class="calibre5">The four basic operations at the heart of almost every web application are often referred by the acronym <strong class="bold">CRUD</strong> (<strong class="bold">create</strong>, <strong class="bold">read</strong>, <strong class="bold">update</strong>, and <strong class="bold">delete</strong>). These operations enable users to interact with data by creating new resources, retrieving one or more instances of existing resources, and modifying and deleting resources. Here, a more formal definition of APIs is used, but resources, in this case, are simply cars.</p>
			<p class="calibre5">FastAPI is strongly tied to web standards, so these operations map to specific HTTP request methods: <code>POST</code> is used for creating new instances, <code>GET</code> is for reading one or more cars, <code>PUT</code> is for updating, and <code>DELETE</code> is for deleting resources. In your case, the resources are represented by <code>cars</code>, which map to MongoDB documents.</p>
			<h3 class="calibre8">Set up the API router</h3>
			<p class="calibre5">After having the application ready and serving a basic root endpoint, the environment variables set up, and the connection to the Atlas MongoDB database in place, you are now ready to start implementing the endpoints.</p>
			<p class="calibre5">In fact, in the following sections, we will add a router for users; this will be needed to enable you to associate individual cars with particular users/salespersons, and to allow for some basic authentication and authorization.</p>
			<p class="calibre5">Like most modern web frameworks (Express.js, Flask, etc.), FastAPI allows you to structure and group endpoints into API routers. <code>APIRouter</code> is a module designed to handle a group of operations related to a single type of object or resource: in your case, cars, and later, users.</p>
			<p class="calibre5">Perform the following steps to create the API router for managing cars:</p>
			<ol class="calibre14">
				<li class="calibre15">Create a dedicated folder inside your app directory and name it <code>/routers</code>. This directory will contain all the API routers . Inside it, create an empty <code>__init__.py</code> file to turn the folder into a Python package.</li>
				<li class="calibre15">Now, create a file named <code>/routers/cars.py</code>. This will be the first router in this app but, potentially, you could add more should the application grow. It is a convention to name the routers according to the resources they manage.</li>
				<li class="calibre15">Inside <code>/routers/cars.py</code>, begin scaffolding the router:<pre class="source-code">
from fastapi import APIRouter, Body, Request, status
from models import CarModel
router = APIRouter()</pre><p class="list-inset">The <code>APIRouter</code> instantiation is very similar to the creation of the main FastAPI instance—it can be thought of as a small FastAPI application that becomes an integral part of the main app, as well as its automated documentation.</p><p class="list-inset"><code>APIRouter</code> by itself doesn’t have any functionality—it needs to be plugged into the main application (<code>app.py</code>) in order to perform its tasks.</p></li>				<li class="calibre15">Before proceeding, let’s modify the <code>app.py</code> file and plug the newly created <code>APIRouter</code> in:<pre class="source-code">
from fastapi import FastAPI, status
from fastapi.middleware.cors import CORSMiddleware
from motor import motor_asyncio
from fastapi.exceptions import RequestValidationError
from fastapi.responses import JSONResponse
from fastapi.encoders import jsonable_encoder
from collections import defaultdict
from config import BaseConfig
from routers.cars import router as cars_router
from routers.users import router as users_router
settings = BaseConfig()
async def lifespan(app: FastAPI):
    app.client = motor_asyncio.AsyncIOMotorClient(settings.DB_URL)
    app.db = app.client[settings.DB_NAME]
    try:
        app.client.admin.command("ping")
        print("Pinged your deployment. You have successfully connected to MongoDB!")
    except Exception as e:
        print(e)
    yield
    app. client.close()
app = FastAPI(lifespan=lifespan)
<strong class="bold">app.include_router(cars_router, prefix="/cars", tags=["cars"])</strong>
@app.get("/")
async def get_root():
    return {"Message": "Root working!"}</pre></li>			</ol>
			<p class="calibre5">You have created your first <code>APIRouter</code> that will be handling operations regarding cars and you have connected it, through the <code>app.py</code> file, to the main FastAPI instance.</p>
			<p class="calibre5">Now, you will add functionality to the <code>APIRouter</code> by implementing handlers for various operations.</p>
			<h2 id="_idParaDest-120" class="about-the-author"><a id="_idTextAnchor129" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>The POST handler</h2>
			<p class="calibre5">Now, with the <code>APIRouter</code> connected, you can return to the <code>/routers/cars.py</code> file and create the first endpoint, a <code>POST</code> request handler for creating new instances:</p>
			<pre class="source-code">
@router.post(
    "/",
    response_description="Add new car",
    response_model=CarModel,
    status_code=status.HTTP_201_CREATED,
    response_model_by_alias=False,
)
async def add_car(request: Request, car: CarModel = Body(...)):
    cars = request.app.db["cars"]
    document = car.model_dump(
        by_alias=True, exclude=["id"])
    inserted = await cars.insert_one(document)
    return await cars.find_one({"_id": inserted.inserted_id})</pre>			<p class="calibre5">The code is rather simple and self-explanatory as it uses the previously defined Pydantic model (<code>CarModel</code>), which is flexible enough to be reused (through the alias) as the input and output model.</p>
			<p class="calibre5">The line that creates the document to be inserted from the model uses a couple of Pydantic features, which are covered in <a href="B22406_03.xhtml#_idTextAnchor051" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><em class="italic">Chapter 3</em></a>, <em class="italic">Python Type Hints and Pydantic</em>, namely, the <em class="italic">alias</em> and the <em class="italic">excluded</em> fields.</p>
			<p class="calibre5">Now, launch the application:</p>
			<pre class="source-code">
uvicorn app:app</pre>			<p class="calibre5">In another terminal, still inside the working directory of your project and with the virtual environment activated, test the endpoint with <strong class="bold">HTTPie</strong>:</p>
			<pre class="console">
http POST http://127.0.0.1:8000/cars/ brand="KIA" make="Ceed" year=2015 price=2000 km=100000 cm3=1500</pre>			<p class="calibre5">Your terminal should output the following response:</p>
			<pre class="console">
HTTP/1.1 201 Created
content-length: 109
content-type: application/json
date: Sun, 12 May 2024 15:29:45 GMT
server: uvicorn
{
    "brand": "Kia",
    "cm3": 1500,
    "id": "6640e06ad82a890d261a8a40",
    "km": 100000,
    "make": "Ceed",
    "price": 2000,
    "year": 2015
}</pre>			<p class="calibre5">You have created the first endpoint—you can test it further with HTTPie, or with the interactive documentation at <code>http://127.0.0.1:8000/docs</code>, and try inserting some invalid data, such as a year greater than 2024 or something similar.</p>
			<p class="calibre5">The endpoint should respond with informative JSON that will quickly direct you to the problem or provide feedback to the end user. Now, you will create the <code>GET</code> handlers for viewing the cars inside your database.</p>
			<h2 id="_idParaDest-121" class="about-the-author"><a id="_idTextAnchor130" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Handling the GET requests</h2>
			<p class="calibre5">For viewing resources—cars—in your system, you will use the HTTP <code>GET</code> method. FastAPI makes very good use of HTTP verb semantics and closely follows web standards and good practices.</p>
			<p class="calibre5">Follow these steps:</p>
			<ol class="calibre14">
				<li class="calibre15">First, return the whole collection of cars—if you have played around with the <code>POST</code> endpoint, you might already have a couple of them inserted. Continuing the <code>/routers/cars.py</code> file, let’s add the <code>GET</code> handler:<pre class="source-code">
@router.get(
    "/",
    response_description="List all cars",
    response_model=CarCollection,
    response_model_by_alias=False,
)
async def list_cars(request: Request):
    cars = request.app.db["cars"]
    results = []
    cursor = cars.find()
    async for document in cursor:
        results.append(document)
    return CarCollection(cars=results)</pre></li>				<li class="calibre15">Test this endpoint with HTTPie:<pre class="source-code">
http http://127.0.0.1:8000/cars/</pre><p class="list-inset">After running the preceding command, you should get all the cars inserted up to this point, in a nice JSON structure. The function signature and the decorator are similar to the <code>POST</code> endpoint.</p></li>				<li class="calibre15">Instead of using <code>async</code> <code>for</code>, which can be a bit counterintuitive at first if you are not used to it, you could also swap the population of the empty results list with the following:<pre class="source-code">
return CarCollection(
    cars=await cars.find().to_list(1000)
    )</pre><p class="list-inset">Then, you could use the <code>to_list()</code> method to get the results in a list. If you wish to dive deeper into the <code>Motor</code> documentation on handling cursors, their page is a bit dry but complete: <a href="https://motor.readthedocs.io/en/stable/api-tornado/cursors.html" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2">https://motor.readthedocs.io/en/stable/api-tornado/cursors.html</a>.</p><p class="list-inset">Later, you will learn how to manually add pagination, since the collection will hopefully grow to hundreds of cars, as you will not want to send the user hundreds of results immediately. Now, create the <code>GET</code> endpoint for finding a single car by its ID.</p></li>				<li class="calibre15">In the same <code>/routers/cars.py</code> file, add the following <code>GET</code> handler:<pre class="source-code">
@router.get(
    "/{id}",
    response_description="Get a single car by ID",
    response_model=CarModel,
    response_model_by_alias=False,
)
async def show_car(id: str, request: Request):
    cars = request.app.db["cars"]
    try:
        id = ObjectId(id)
    except Exception:
        raise HTTPException(status_code=404, detail=f"Car {id} not found")
    if (car := await cars.find_one({"_id": ObjectId(id)})) is not None:
        return car
    raise HTTPException(status_code=404, detail=f"Car with {id} not found")</pre></li>			</ol>
			<p class="calibre5">The logic of the endpoint is contained in the line that checks whether the collection contains a car with the desired ID and the ID is supplied via a path parameter. The Python walrus operator (<code>:=</code>), also known as the assignment expression, makes your code more concise: if the car is found (it is not <code>None</code>), it is returned and the operand of the truthiness check—the car instance itself—is passed on; otherwise, the code proceeds to finish with an HTTP exception.</p>
			<p class="calibre5">Again, for the HTTPie command for testing, you will need to look up an ID and provide it as a path parameter (your ID value will be different from the following):</p>
			<pre class="source-code">
http http://127.0.0.1:8000/cars/6640e06ad82a890d261a8a40</pre>			<p class="calibre5">You have implemented two of the most important result listing methods that map to a <code>GET</code> HTTP method: retrieving a list of all items and a specific single item. Other <code>GET</code> endpoints can retrieve queries based on MongoDB aggregations, simpler queries, and filtering, but these two cover the basics.</p>
			<p class="calibre5">Now, let’s complete the API with the <code>UPDATE</code> and <code>DELETE</code> methods.</p>
			<h2 id="_idParaDest-122" class="about-the-author"><a id="_idTextAnchor131" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Updating and deleting records</h2>
			<p class="calibre5">Now you will tackle the most complex endpoint—the <code>PUT</code> method that will be used for updating the car instance. Again, in the same <code>/routers/cars.py</code> file, after the <code>GET</code> routes, continue editing:</p>
			<pre class="source-code">
async def update_car(
    id: str,
    request: Request,
    user=Depends(auth_handler.auth_wrapper),
    car: UpdateCarModel = Body(...),
):
    try:
        id = ObjectId(id)
    except Exception:
        raise HTTPException(status_code=404, detail=f"Car {id} not found")
    car = {
        k: v
        for k, v in car.model_dump(by_alias=True).items()
        if v is not None and k != "_id"
    }</pre>			<p class="calibre5">The first part of the endpoint function analyzes the provided user data and checks which fields should be updated, by merely acknowledging their presence in the provided <code>UpdateCarModel</code> Pydantic model. If the field is present in the request body, its value is passed to the <code>update</code> dictionary.</p>
			<p class="calibre5">Thus, you get a transformed <code>car</code> object that, if not empty, will then be fed to the <code>find_one_and_update()</code> function of MongoDB:</p>
			<pre class="source-code">
    if len(car) &gt;= 1:
        cars = request.app.db["cars"]
        update_result = await cars.find_one_and_update(
            {"_id": ObjectId(id)},
            {"$set": car},
            return_document=ReturnDocument.AFTER,
        )
        if update_result is not None:
            return update_result
        else:
            raise HTTPException(status_code=404, detail=f"Car {id} not found")</pre>			<p class="calibre5">The update result simply performs the asynchronous update and returns the updated document by leveraging PyMongo’s <code>ReturnDocument.AFTER</code> to return the document after the update has been performed.</p>
			<p class="calibre5">Finally, you must also take into account the case in which none of the fields is set for updating, and simply return the original document if it is found:</p>
			<pre class="source-code">
    if (existing_car := await cars.find_one({"_id": id})) is not None:
        return existing_car
    raise HTTPException(status_code=404, detail=f"Car {id} not found")</pre>			<p class="calibre5">The endpoint provides two possibilities of a <code>404</code> exception in case the document is not found: when there are fields to be updated and when there are not.</p>
			<p class="calibre5">Now, finish the implementation of the basic CRUD functionality with the method for deleting cars:</p>
			<pre class="source-code">
@router.delete("/{id}", response_description="Delete a car")
async def delete_car(
    id: str, request: Request, user=Depends(auth_handler.auth_wrapper)
):
    try:
        id = ObjectId(id)
    except Exception:
        raise HTTPException(status_code=404, detail=f"Car {id} not found")
    cars = request.app.db["cars"]
    delete_result = await cars.delete_one({"_id": id})
    if delete_result.deleted_count == 1:
        return Response(status_code=status.HTTP_204_NO_CONTENT)
    raise HTTPException(status_code=404, detail=f"Car with {id} not found")</pre>			<p class="calibre5">This is probably the simplest endpoint; if the car with the ID is found, it is deleted and the appropriate HTTP status is returned on an empty (<code>No </code><code>Content</code>) response.</p>
			<p class="calibre5">This concludes the basic CRUD functionality, but before going on, let’s tackle another aspect that, while not part of the basic functionality, will incur in every real-life project: result pagination.</p>
			<h3 class="calibre8">Result pagination</h3>
			<p class="calibre5">Every application that works with data and users must have an appropriate way to enable and facilitate their communication. Slamming hundreds of results into the browser isn’t exactly the best solution.</p>
			<p class="calibre5">Results pagination with MongoDB, as well as other databases, is achieved with the help of the <code>skip</code> and <code>limit</code> parameters.</p>
			<p class="calibre5">In this case, you will create a simple frontend-friendly pagination system with a custom Pydantic model that will provide two additional JSON properties: the current page and the <code>has_more</code> flag, to indicate whether there are more result pages.</p>
			<p class="calibre5">This pattern matches the pagination UI with the arrows and page numbers that indicate the total number of results to the user.</p>
			<p class="calibre5">Start by commenting out the existing <code>GET</code> route. Open the <code>models.py</code> file and add the following model:</p>
			<pre class="source-code">
class CarCollectionPagination(CarCollection):
    page: int = Field(ge=1, default=1)
    has_more: bool</pre>			<p class="calibre5">This model inherits the <code>CarCollection</code> model and adds the two desired fields – this pattern is useful when dealing with large and complex models.</p>
			<p class="calibre5">In the <code>cars.py</code> file, after instantiating <code>APIRouter</code>, add a hardcoded constant that will define the number of default results per page:</p>
			<pre class="source-code">
CARS_PER_PAGE = 10</pre>			<p class="calibre5">Now you will update (or better, replace entirely) the <code>get all</code> method in the <code>routers/cars.py</code> file:</p>
			<pre class="source-code">
@router.get(
    "/",
    response_description="List all cars, paginated",
    response_model=CarCollectionPagination,
    response_model_by_alias=False,
)
async def list_cars(
    request: Request,
    page: int = 1,
    limit: int = CARS_PER_PAGE,
):
    cars = request.app.db["cars"]
    results = []</pre>			<p class="calibre5">The first part of the function is very similar to the previous version, but we have two new parameters: <code>page</code> and <code>limit</code> (the number of results per page). Now, create the actual pagination:</p>
			<pre class="source-code">
cursor = cars.find().sort("companyName").limit(limit).skip((page - 1) * limit)
    total_documents = await cars.count_documents({})
    has_more = total_documents &gt; limit * page
    async for document in cursor:
        results.append(document)
    return CarCollectionPagination(cars=results, page=page, has_more=has_more)</pre>			<p class="calibre5">The bulk of the work is handled directly by MongoDB, with the <code>limit</code> and <code>skip</code> parameters. The endpoint needs the total number of cars in the collection in order to provide information on the remaining results and their existence.</p>
			<p class="calibre5">This endpoint will work just like the previous one so, to properly test it, open MongoDB Compass and import some data. The accompanying GitHub repository contains a file named <code>cars.csv</code> with 1,249 cars.</p>
			<p class="calibre5">After importing this data, you can perform a <code>GET</code> request like the following:</p>
			<pre class="source-code">
http http://127.0.0.1:8000/cars/?page=12</pre>			<p class="calibre5">The output should contain a list of cars, as in the previous case, but also the indication of the page and whether there are more results:</p>
			<pre class="source-code">
{
    "has_more": false,
    "page": 12
}</pre>			<p class="calibre5">Since you are already pulling the total document count from the database, you could extend this pagination model to include either the total number of cars in the database or the total number of pages given the current pagination. That would be a good exercise that showcases how easy it is to extend and modify the FastAPI setup.</p>
			<p class="calibre5">You have successfully created a fully functional REST API with FastAPI. Now, let’s further enhance the application by providing image-uploading functionality.</p>
			<h1 id="_idParaDest-123" class="contributor"><a id="_idTextAnchor132" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Uploading images to Cloudinary</h1>
			<p class="calibre5">While FastAPI is perfectly capable of serving static files – through the <code>StaticFiles</code> module (<a href="https://fastapi.tiangolo.com/tutorial/static-files/" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2">https://fastapi.tiangolo.com/tutorial/static-files/</a>) – you will rarely want to use your server space and bandwidth to store images or videos.</p>
			<p class="calibre5">Many specialized services can take care of digital asset media management and, in this section, you will learn how to work with one of the premier players in the area—<strong class="bold">Cloudinary</strong>.</p>
			<p class="calibre5">Cloudinary, as its name suggests, is a cloud-based service that provides various solutions for digital media assets and web and mobile applications. These services include uploading and storing images and videos, and these are precisely the functions that we are going to use now.</p>
			<p class="calibre5">However, Cloudinary and other similar specialized services offer much more (image and video manipulations, filters, automatic cropping and formatting, and real-time transformations) and they might be an excellent fit for many media workflows, especially very heavy ones.</p>
			<p class="calibre5">To be able to use the service, you will first need to create a free account by following the instructions at <a href="https://cloudinary.com/users/register_free" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2">https://cloudinary.com/users/register_free</a>.</p>
			<p class="calibre5">After successfully signing up and logging in, you will automatically get assigned a product environment key, visible in the top-left corner. For your purposes, you will only interact through the Python API as you need to be able to upload images to your environment through FastAPI.</p>
			<p class="calibre5">To get started with the Python API, or any other for that matter, in addition to this environment key, you will need two more pieces of information: the <em class="italic">API key</em> and the <em class="italic">API secret</em>. Both can be obtained from the <strong class="bold">Settings</strong> page (<a href="http://console.cloudinary.com./settings" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2">console.cloudinary.com./settings</a>) and by selecting <strong class="bold">API Keys</strong> from the left menu.</p>
			<p class="calibre5">Copy the API key and API secret, or create new ones and copy them into your existing <code>.</code><code>env</code> file:</p>
			<pre class="source-code">
DB_URL=mongodb+srv://xxxxxx:xxxxxxxx@cluster0.fkm24.mongodb.net/?retryWrites=true&amp;w=majority&amp;appName=Cluster0
DB_NAME=carBackend
CLOUDINARY_SECRET_KEY=xxxxxxxxxxxxxxxx
CLOUDINARY_API_KEY=xxxxxxxxxx
CLOUDINARY_CLOUD_NAME=xxxxxxxx</pre>			<p class="calibre5">The environment name is mapped as <code>CLOUDINARY_CLOUD_NAME</code>, while the secret key and API key are prepended by <code>CLOUDINARY</code>.</p>
			<p class="calibre5">You will also need to modify the <code>config.py</code> file to accommodate the new variables:</p>
			<pre class="source-code">
from typing import Optional
from pydantic_settings import BaseSettings, SettingsConfigDict
class BaseConfig(BaseSettings):
    DB_URL: Optional[str]
    DB_NAME: Optional[str]
    <strong class="bold">CLOUDINARY_SECRET_KEY: Optional[str]</strong>
<strong class="bold">    CLOUDINARY_API_KEY: Optional[str]</strong>
<strong class="bold">    CLOUDINARY_CLOUD_NAME: Optional[str]</strong>
    model_config = SettingsConfigDict(env_file=".env", extra="ignore")</pre>			<p class="calibre5">The next step is to install the <code>cloudinary</code> Python package:</p>
			<pre class="source-code">
pip install cloudinary</pre>			<p class="calibre5">Another thing you can do is add it to your <code>requirements.txt</code> file, which, at this point, should look like this:</p>
			<pre class="source-code">
fastapi==0.111.0
motor==3.4.0
uvicorn==0.29.0
httpie==3.2.2
<strong class="bold">cloudinary==1.40.0</strong>
<strong class="bold">pydantic-settings==2.2.1</strong></pre>			<p class="calibre5">The Cloudinary documentation is much richer when it comes to JavaScript, and there seem to be a couple of quirks when setting up the upload client, but the essence is simple.</p>
			<h3 class="calibre8">Updating the models</h3>
			<p class="calibre5">First, you will update the <code>models.py</code> file to accommodate the new field – a string that will store the URL of the uploaded image from Cloudinary:</p>
			<ol class="calibre14">
				<li class="calibre15">Open the <code>models.py</code> file and add just one line in the <code>CarModel</code> class, after the other fields and before the validators:<pre class="source-code">
# add the picture file
    picture_url: Optional[str] = Field(None)</pre></li>				<li class="calibre15">At this point, you should open <code>cars</code> collection, as you will create a new, empty one. Now, comment out the previous route for the <code>POST</code> handler in the <code>cars.py</code> file and create a new one taking into account the image uploading process.</li>
				<li class="calibre15">Cloudinary provides a simple utility module called <code>uploader</code> that needs to be imported, along with the <code>cloudinary</code> module itself. After the existing imports, add the following lines (<code>cars.py</code>):<pre class="source-code">
import cloudinary
from cloudinary import uploader  # noqa: F401</pre><p class="list-inset">These lines import <code>cloudinary</code> and the <code>uploader</code> package, while the <code># noqa</code> line prevents code linters from removing the line upon saving (as it is imported from a package that is already imported as a whole).</p></li>				<li class="calibre15">The next step is configuring your Cloudinary instance, and you can do it in the <code>/routers/cars.py</code> file for convenience, although this could be made application-wide.<p class="list-inset">To be able to read the environment variables, you will need to instantiate the <code>Settings</code> class again in the same file and pass the variables to the <code>cloudinary</code> configuration object.</p></li>
				<li class="calibre15">Open the cars router and modify it. The first part of the <code>/routers/cars.py</code> file should now look like this:<pre class="source-code">
from bson import ObjectId
from fastapi import (
    APIRouter,
    Body,
    File,
    Form,
    HTTPException,
    Request,
    UploadFile,
    status,
)
from fastapi.responses import Response
from pymongo import ReturnDocument
import cloudinary
from cloudinary import uploader  # noqa: F401
from config import BaseConfig
from models import CarCollectionPagination, CarModel, UpdateCarModel
settings = BaseConfig()
router = APIRouter()
CARS_PER_PAGE = 10
cloudinary.config(
    cloud_name=settings.CLOUDINARY_CLOUD_NAME,
    api_key=settings.CLOUDINARY_API_KEY,
    api_secret=settings.CLOUDINARY_SECRET_KEY,
)</pre><p class="list-inset">Now, you must treat the <code>POST</code> handler differently, since it will accept a form and a file (your car picture) and not JSON anymore. You will need to accept the form data:</p><pre class="source-code">@router.post(
    "/",
    response_description="Add new car with picture",
    response_model=CarModel,
    status_code=status.HTTP_201_CREATED,
)
async def add_car_with_picture(
    request: Request,
    brand: str = Form("brand"),
    make: str = Form("make"),
    year: int = Form("year"),
    cm3: int = Form("cm3"),
    km: int = Form("km"),
    price: int = Form("price"),
    picture: UploadFile = File("picture"),
):</pre><p class="list-inset">All the <code>CarModel</code> fields are now mapped to form fields with names, while the picture is defined as an <code>UploadFile</code> and expects a file.</p><p class="list-inset">Continue with the same function, and add the uploading functionality:</p><pre class="source-code">    cloudinary_image = cloudinary.uploader.upload(
        picture.file, crop="fill", width=800
    )
    picture_url = cloudinary_image["url"]</pre><p class="list-inset">The code that handles the actual upload is very simple: just a call to <code>uploader</code> with the received file and there are numerous options, transformations, and filters that you could use.</p></li>			</ol>
			<p class="callout-heading">Note</p>
			<p class="callout">The Cloudinary documentation covers in detail the available transformations: <a href="https://cloudinary.com/documentation/transformations_intro" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2">https://cloudinary.com/documentation/transformations_intro</a>.</p>
			<p class="calibre5">In your case, you are just cropping the image and setting a maximum width. Cloudinary will return a URL once the picture is uploaded, and that URL will be part of the model, along with the data we used previously.</p>
			<p class="calibre5">Finally, you can construct a Pydantic model of the car and pass it to the MongoDB <code>cars</code> collection:</p>
			<pre class="source-code">
    car = CarModel(
        brand=brand,
        make=make,
        year=year,
        cm3=cm3,
        km=km,
        price=price,
        picture_url=picture_url,
    )
    cars = request.app.db["cars"]
    document = car.model_dump(by_alias=True, exclude=["id"])
    inserted = await cars.insert_one(document)
    return await cars.find_one({"_id": inserted.inserted_id})</pre>			<p class="calibre5">You can test the endpoint through the interactive documentation that FastAPI serves on <code>127.0.0.1:8000/docs</code>; just select an image and pass it to the file field that is present in the <code>POST</code> handler for the root route, and don’t forget to fill the remaining fields or there will be an error—just like dealing with JSON.</p>
			<p class="calibre5">You can also test the route with HTTPie, but first provide an image and name it accordingly:</p>
			<pre class="console">
http --form POST 127.0.0.1:8000/cars brand="Ford" make="Focus" year=2000 cm3=1500 price=12000 km=23000 picture="ford.jpg"</pre>			<p class="calibre5">After having the <code>Cars</code> API router ready, now you will create the second router for handling users.</p>
			<h1 id="_idParaDest-124" class="contributor"><a id="_idTextAnchor133" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Adding the user model</h1>
			<p class="calibre5">You have successfully created a REST API powered by the Cloudinary image hosting and processing power and, following a similar procedure, you could easily integrate other third-party services into your API, making your application more complex and powerful.</p>
			<p class="calibre5">Without authentication, however, it would be very risky to deploy even the simplest API online. For instance, a malicious user (or even a kid willing to pull some pranks) could easily “bomb” your API with images that you wouldn’t want displayed and in quantities that would quickly fill your free quota. Therefore, before committing your API to GitHub and deploying it—in this case, to Render.com—you will add a user model and a JWT-based authentication scheme very similar to the one shown in <a href="B22406_06.xhtml#_idTextAnchor105" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><em class="italic">Chapter 6</em></a>, <em class="italic">Authentication </em><em class="italic">and Authorization</em>.</p>
			<p class="calibre5">In the following section, you will create a simple user model and allow users to log in to the application, in order to perform some operations otherwise unavailable – namely, creating, updating, and deleting resources (cars). You will begin by abstracting the authentication logic into a class.</p>
			<h3 class="calibre8">Creating the authentication functionality</h3>
			<p class="calibre5">In this section, you will implement an authentication class, similar to the one used in <a href="B22406_06.xhtml#_idTextAnchor105" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><em class="italic">Chapter 6</em></a>, <em class="italic">Authentication and Authorization</em>, that will abstract the functionalities needed for authentication and authorization—password encryption, JWT encoding and decoding, and the dependency that will be used for protecting routes. Follow these steps:</p>
			<ol class="calibre14">
				<li class="calibre15">First, create a file called <code>authentication.py</code> in the root folder of your project and import the modules needed for authentication:<pre class="source-code">
from datetime import datetime
import jwt
from fastapi import HTTPException, Security
from fastapi.security import HTTPAuthorizationCredentials, HTTPBearer
from passlib.context import CryptContext</pre></li>				<li class="calibre15">Next, implement an <code>AuthHandler</code> class that will provide all the needed functionality for hashing and verifying passwords and encoding and decoding tokens:<pre class="source-code">
class AuthHandler:
    security = HTTPBearer()
    pwd_context = CryptContext(
        schemes=["bcrypt"], deprecated="auto"
    )
    secret = "FARMSTACKsecretString"
    def get_password_hash(self, password):
        return self.pwd_context.hash(password)
    def verify_password(
        self, plain_password, hashed_password
    ):
        return self.pwd_context.verify(
            plain_password, hashed_password
        )
    def encode_token(self, user_id, username):
        payload = {
            "exp": datetime.datetime.now(
                datetime.timezone.utc)
            + datetime.timedelta(minutes=30),
            "iat": datetime.datetime.now(datetime.timezone.utc),
            "sub": {
                "user_id": user_id,
                 "username": username},
        }
        return jwt.encode(payload, self.secret, algorithm="HS256")
    def decode_token(self, token):
try:
    payload = jwt.decode(
        token, self.secret, algorithms=["HS256"]
    )
    return payload["sub"]
except jwt.ExpiredSignatureError:
    raise HTTPException(
        status_code=401,
        detail="Signature has expired"
    )
except jwt.InvalidTokenError:
    raise HTTPException(
        status_code=401,
        detail="Invalid token"
    )</pre></li>				<li class="calibre15">Finally, you will end the file with the <code>auth_wrapper</code> function, which will be injected as a dependency into the FastAPI endpoints that require an authenticated user:<pre class="source-code">
    def auth_wrapper(
        self,
        auth: HTTPAuthorizationCredentials =
            Security(security)
    ):
        return self.decode_token(auth.credentials)</pre><p class="list-inset">The authentication class is nearly identical to the one defined in <a href="B22406_06.xhtml#_idTextAnchor105" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><em class="italic">Chapter 6</em></a><em class="italic">, Authentication and Authorization</em>—it provides methods for password hashing and verification, for JWT encoding and decoding, and a handy <code>auth_wrapper</code> method that is used as a dependency injection.</p></li>				<li class="calibre15">With the <code>authentication.py</code> file ready, add the user model, very similar to the one defined in the previous chapter, bearing in mind that this model could be much more complex.</li>
				<li class="calibre15">In the <code>models.py</code> file, edit the <code>CarModel</code> class and add another field—<code>user_id</code>. That way, you will be able to associate an inserted car with a particular user and require a valid user for every creation operation:<pre class="source-code">
class CarModel(BaseModel):
    id: Optional[PyObjectId] = Field(alias="_id", default=None)
    brand: str = Field(...)
    make: str = Field(...)
    year: int = Field(..., gt=1970, lt=2025)
    cm3: int = Field(..., gt=0, lt=5000)
    km: int = Field(..., gt=0, lt=500 * 1000)
    price: int = Field(..., gt=0, lt=100000)
    <strong class="bold">user_id: str = Field(...)</strong>
    picture_url: Optional[str] = Field(None)</pre></li>				<li class="calibre15">The model for updating the car will not need the <code>user_id</code> field as you do not want to make that field editable. Now, after all the car models, let’s add the user-related models in the same <code>models.py</code> file:<pre class="source-code">
class UserModel(BaseModel):
    id: Optional[PyObjectId] = Field(alias="_id", default=None)
    username: str = Field(..., min_length=3, max_length=15)
    password: str = Field(...)
class LoginModel(BaseModel):
    username: str = Field(...)
    password: str = Field(...)
class CurrentUserModel(BaseModel):
    id: PyObjectId = Field(alias="_id", default=None)
    username: str = Field(..., min_length=3, max_length=15)</pre></li>			</ol>
			<p class="calibre5">The three models correspond to the three ways you will be accessing the user data: the full model with all the data, the login and registration model, and the current user that should return <code>_id</code> and the username.</p>
			<h3 class="calibre8">Creating the User router</h3>
			<p class="calibre5">After the Pydantic models are set up, create a new router for users and allow some basic operations such as registration, logging in, and verifying the user based on the JWT.</p>
			<p class="calibre5">Open the file named <code>users.py</code> inside the <code>routers</code> folder and add the imports:</p>
			<pre class="source-code">
from bson import ObjectId
from fastapi import APIRouter, Body, Depends, HTTPException, Request, Response
from fastapi.responses import JSONResponse
from authentication import AuthHandler
from models import CurrentUserModel, LoginModel, UserModel
router = APIRouter()
auth_handler = AuthHandler()</pre>			<p class="calibre5">The <code>authhandler</code> class encapsulates all of your authentication logic and you will see this functionality in the endpoint functions.</p>
			<p class="calibre5">Let’s create the registration route:</p>
			<pre class="source-code">
@router.post("/register", response_description="Register user")
async def register(request: Request, newUser: LoginModel = Body(...)) -&gt; UserModel:
    users = request.app.db["users"]
    # hash the password before inserting it into MongoDB
    newUser.password = auth_handler.get_password_hash(newUser.password)
    newUser = newUser.model_dump()
    # check existing user or email 409 Conflict:
    if (
        existing_username := await users.find_one({"username": newUser["username"]})
        is not None
    ):
        raise HTTPException(
            status_code=409,
            detail=f"User with username {newUser['username']} already exists",
        )
    new_user = await users.insert_one(newUser)
    created_user = await users.find_one({"_id": new_user.inserted_id})
    return created_user</pre>			<p class="calibre5">The endpoint performs the same functionality as shown in <a href="B22406_06.xhtml#_idTextAnchor105" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><em class="italic">Chapter 6</em></a>, <em class="italic">Authentication and Authorization</em>, except, this time, you are working with a real MongoDB collection. The login functionality is also very similar:</p>
			<pre class="source-code">
@router.post("/login", response_description="Login user")
async def login(request: Request, loginUser: LoginModel = Body(...)) -&gt; str:
    users = request.app.db["users"]
    user = await users.find_one({"username": loginUser.username})
    if (user is None) or (
        not auth_handler.verify_password(loginUser.password, user["password"])
    ):
        raise HTTPException(status_code=401, detail="Invalid username and/or password")
    token = auth_handler.encode_token(str(user["_id"]), user["username"])
    Wrong indentation. check and replace with:
response = JSONResponse(
    content={
        "token": token,
        "username": user["username"]
    }
)
    return response</pre>			<p class="calibre5">If a user is not found by <code>username</code> or the password doesn’t match, the endpoint responds with an HTTP <code>401</code> status and throws a generic message; otherwise, a username and a token are returned.</p>
			<p class="calibre5">The final endpoint consists of a <code>/me</code> route—a route that will be used periodically by the frontend (React) to check the existing JWT and its validity:</p>
			<pre class="source-code">
@router.get(
    "/me",
    response_description="Logged in user data",
    response_ model=CurrentUserModel
)
async def me(
    request: Request,
    response: Response,
    user_data=Depends(auth_handler.auth_wrapper)
):
    users = request.app.db["users"]
    currentUser = await users.find_one(
        {"_id": ObjectId(user_data["user_id"])}
    )
    return currentUser</pre>			<p class="calibre5">With the <code>users</code> router finished, let’s plug it into the <code>app.py</code> file, just below the <code>cars</code> router:</p>
			<pre class="source-code">
app.include_router(
    cars_router, prefix="/cars", tags=["cars"]
    )
app.include_router(
    users_router, prefix="/users", tags=["users"]
    )</pre>			<p class="calibre5">The <code>cars.py</code> file, which contains the <code>APIRouter</code> for managing the cars, will have to be updated to take into account the newly added user data. The creation endpoint will now look like the following:</p>
			<pre class="source-code">
@router.post(
    "/",
    response_description="Add new car with picture",
    response_model=CarModel,
    status_code=status.HTTP_201_CREATED,
)
async def add_car_with_picture(
    request: Request,
    brand: str = Form("brand"),
    make: str = Form("make"),
    year: int = Form("year"),
    cm3: int = Form("cm3"),
    km: int = Form("km"),
    price: int = Form("price"),
    picture: UploadFile = File("picture"),
    <strong class="bold">user: str =Depends(auth_handler.auth_wrapper),</strong>
):</pre>			<p class="calibre5">The user data is provided through dependency injection and <code>auth_wrapper</code>. The rest of the function is largely unaltered—you just need the <code>user_id</code> value from the logged-in user:</p>
			<pre class="source-code">
cloudinary_image = cloudinary.uploader.upload(
    picture.file, folder="FARM2", crop="fill", width=800
)
picture_url = cloudinary_image["url"]
car = CarModel(
    brand=brand,
    make=make,
    year=year,
    cm3=cm3,
    km=km,
    price=price,
    picture_url=picture_url,
<strong class="bold">    user_id=user["user_id"],</strong>
)
cars = request.app.db["cars"]
document = car.model_dump(by_alias=True, exclude=["id"])
inserted = await cars.insert_one(document)
return await cars.find_one({"_id": inserted.inserted_id})</pre>			<p class="calibre5">The API is now quite complete; it handles data of varying complexity and can handle images using a top-quality cloud service. However, before deploying your API to an online cloud platform for the world to see, there is one more thing that needs to be done: setting up the <strong class="bold">cross-origin resource sharing</strong> (<strong class="bold">CORS</strong>) middleware.</p>
			<h1 id="_idParaDest-125" class="contributor"><a id="_idTextAnchor134" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>FastAPI middleware and CORS</h1>
			<p class="calibre5">The concept of middleware is common in almost every reputable web framework, and FastAPI is no exception. Middleware is just a function that accepts requests before they are handed over to the path operations for processing and also responds before they are returned.</p>
			<p class="calibre5">This simple concept is quite powerful and has many uses—a middleware can check for specific headers that contain authentication data (such as a bearer token) and accept or deny requests accordingly, it can be used for rate limiting (often with the Redis key-value database), and so on.</p>
			<p class="calibre5">Creating middleware in FastAPI is based on <em class="italic">Starlette’s</em> middleware, like most web-related concepts in FastAPI, and the documentation provides some nice examples: <a href="https://fastapi.tiangolo.com/tutorial/middleware/" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2">https://fastapi.tiangolo.com/tutorial/middleware/</a>.</p>
			<p class="calibre5">In your application, you will use a ready-made middleware to enable the FastAPI-based backend—which will be running on one machine—to communicate with a frontend (in your case, React) running on a different origin.</p>
			<p class="calibre5">CORS refers to the policy that is applied when you incur situations when the backend and frontend reside on different origins and, by default, it is very restrictive— allowing only sharing data (such as calling JavaScript fetch functions) between systems using the same origin: the combination of a protocol (HTTP, for instance), domain (such as <a href="http://www.packt.com" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2">www.packt.com</a>) and a port (for example, <code>3000</code> or <code>80</code>).</p>
			<p class="calibre5">By default, the policy blocks all communication, so if you were to deploy your backend as it is currently, you couldn’t reach it from a React.js or Next.js application running even on the same machine but a different port.</p>
			<p class="calibre5">FastAPI’s solution for this task is achieved through middleware, and it allows granular precision.</p>
			<p class="calibre5">In your <code>app.py</code> file, import the following to import the CORS middleware:</p>
			<pre class="source-code">
from fastapi.middleware.cors import CORSMiddleware</pre>			<p class="calibre5">After having imported the middleware, you need to configure it. After instantiating the FastAPI instance with the lifespan, add the middleware:</p>
			<pre class="source-code">
app = FastAPI(lifespan=lifespan)
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)</pre>			<p class="calibre5">This is a catch-all CORS setup that should be avoided in production, but it will be enough for our purposes and this example backend. The square brackets contain lists of allowed methods (such as <code>POST</code>, <code>GET</code>, and so on), origins, headers, and whether credentials should be allowed.</p>
			<p class="calibre5">You can restart the Uvicorn server and check that it works like before. Now, you will deploy the backend on a cloud platform.</p>
			<h1 id="_idParaDest-126" class="contributor"><a id="_idTextAnchor135" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Deployment to Render.com</h1>
			<p class="calibre5"><em class="italic">Render.com</em> is one of numerous modern cloud platforms that simplify deploying and managing web applications, APIs, static sites, and other types of software projects. It provides developers with an intuitive and simple interface and powerful automation tools and pipelines.</p>
			<p class="calibre5">There are many ways to deploy a FastAPI instance: Vercel (known mainly as the company behind Next.js), Fly.io, Ralway, Heroku, and so on.</p>
			<p class="calibre5">In this case, we will choose Render.com as it provides a simple, fast, streamlined deployment procedure, and has a free tier and excellent documentation.</p>
			<p class="calibre5">The deployment process can be broken into steps, and you will review each one of them briefly; it is also useful to visit their FastAPI-dedicated page if you wish to get up to speed: <a href="https://docs.render.com/deploy-fastapi" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2">https://docs.render.com/deploy-fastapi</a>.</p>
			<p class="calibre5">Here are the steps:</p>
			<ol class="calibre14">
				<li class="calibre15">Set up a GitHub repo for your backend.<p class="list-inset">Again, make sure that your <code>.gitignore</code> file contains entries for the <code>.env</code> file, as well as the <code>env/</code> directory for the Python environment—you do not want to accidentally commit the secrets and passwords to a public repository, nor do you want to upload the entire virtual environment content.</p><p class="list-inset">If you haven’t committed the last changes to your backend, do it now with the following commands:</p><pre class="source-code">
git add .
git commit -m "ready for deployment"</pre><p class="list-inset">Now head to <a href="http://github.com" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2">github.com</a>, use your credentials to log in, and create a new repository. Name it however you see fit; in this example, we will use the name <code>FastAPIbackendCh7</code>.</p></li>				<li class="calibre15">Set up a Render.com account.<p class="list-inset">Now, head over to <a href="http://render.com" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2">render.com</a> and create a free account. You can log in with your GitHub account and then navigate to the dashboard link: <a href="http://dashboard.render.com" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2">dashboard.render.com</a>.</p><p class="list-inset">Locate the <strong class="bold">New +</strong> button and select <strong class="bold">Web Service</strong>. On the next prompt, select <strong class="bold">Build and deploy from a Git repository</strong> and click <strong class="bold">Next</strong>.</p></li>
				<li class="calibre15">Select the GitHub repository.<p class="list-inset">In the right-hand menu, select the <strong class="bold">GitHub Configure</strong> account and you will be taken to GitHub asking you to install Render. Choose your account, the one you used for the backend repository origin, and proceed to select the repo. This will allow Render to know which repository to pull.</p></li>
				<li class="calibre15">Configure the web service.<p class="list-inset">This is the most important and complex step of the process. Render is informed which repository is involved, and now it has to get all the data necessary for the web service to be deployed. We will examine them one by one:</p><ul class="calibre19"><li class="calibre15"><code>main</code>, especially if it is the only branch, as in our case.</li><li class="calibre15"><code>/</code>.</li><li class="calibre15"><strong class="bold">Runtime</strong>: You will be using Python 3; it should be picked up automatically by Render.</li><li class="calibre15"><strong class="bold">Build command</strong>: The command that sets up the environment – in your case, the Python 3 virtual environment, so it should be the following:<pre class="source-code">
pip install -r requirements.txt</pre></li><li class="calibre15"><code>80</code>), the command should be as follows:<pre class="source-code">uvicorn app:app --host 0.0.0.0 --port 80</pre></li><li class="calibre15"><code>.env</code> file, one by one: <code>DB_URL</code> and <code>DB_NAME</code> for MongoDB, and three Cloudinary variables.</li></ul></li>			</ol>
			<p class="calibre5">After checking that you have entered all the settings and variables, you can finally click the blue <strong class="bold">Create Web </strong><strong class="bold">Service</strong> button.</p>
			<p class="calibre5">The final settings page will look similar to the following images. The settings page is quite long and you will have to scroll a bit, but the first thing that has to be specified are the name of the service and the region:</p>
			<p class="calibre5"><img src="img/B22406_07_01.png" alt="" role="presentation" class="calibre41"/></p>
			<p class="calibre5" lang="en-US" xml:lang="en-US">Figure 7.1: The Render web service general settings page</p>
			<p class="calibre5">After setting the name and the region, you will see your selected repository and the branch to be deployed (<strong class="bold">main</strong>, in your case). You can leave the root directory empty by default.</p>
			<p class="calibre5"><img src="img/B22406_07_02.png" alt="" role="presentation" class="calibre42"/></p>
			<p class="calibre5" lang="en-US" xml:lang="en-US">Figure 7.2: The repository and the branch settings</p>
			<p class="calibre5">Next, you will specify the build and the start command. The build command is the one that installs your Python environment, while the start command starts the web service – your API.</p>
			<p class="calibre5"><img src="img/B22406_07_03.png" alt="" role="presentation" class="calibre43"/></p>
			<p class="calibre5" lang="en-US" xml:lang="en-US">Figure 7.3: The build and start commands</p>
			<p class="calibre5">The last step before starting the actual deployment command is to pass the environment variables to Render.com:</p>
			<p class="calibre5"><img src="img/B22406_07_04.png" alt="" role="presentation" class="calibre44"/></p>
			<p class="calibre5" lang="en-US" xml:lang="en-US">Figure 7.4: The environment variables</p>
			<p class="calibre5">After initiating the deployment procedure, you will have to wait a bit—the service will have to create a new Python environment, install all the required dependencies, and start the service. After the process is complete, you can click on the URL on the page (in your case, it will be <a href="https://farm2ch7.onrender.com" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2">https://farm2ch7.onrender.com</a> you will have to use another address) and you can check your API online.</p>
			<p class="calibre5">Your API is now live on the internet and ready to receive requests. It is worth mentioning that due to the recent rise of FastAPI’s popularity, more and more hosting and <code>.</code><code>env</code> files.</p>
			<h1 id="_idParaDest-127" class="contributor"><a id="_idTextAnchor136" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Summary</h1>
			<p class="calibre5">In this chapter, you have taken a simple business requirement and turned it into a fully functional API deployed on the internet.</p>
			<p class="calibre5">You have created the Pydantic models and applied some constraints on the data structure, learned how to connect to a MongoDB Atlas instance, and developed a basic, yet fully functional, CRUD functionality FASTAPI service.</p>
			<p class="calibre5">You have learned how to model entities (in your case, cars and users) through Pydantic and how to make the data flow seamlessly to and from your database of choice – MongoDB – through simple pythonic FastAPI endpoints.</p>
			<p class="calibre5">You have managed the secret keys – for connecting to MongoDB Atlas and Cloudinary – through <code>pydantic_settings</code> and you have crafted simple, yet flexible models that can easily accommodate more requirements, be expanded or include more functionality.</p>
			<p class="calibre5">The service is now ready to be used in the frontend – ultimately, giving life to a full-stack web application.</p>
			<p class="calibre5">In the next chapter, you will add a simple user model to this same API and build a React frontend that will consume the FastAPI backend.</p>
		</div>
	</div>
</div>
</body></html>