- en: Python Object-Oriented Shortcuts
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python面向对象快捷方式
- en: 'There are many aspects of Python that appear more reminiscent of structural
    or functional programming than object-oriented programming. Although object-oriented
    programming has been the most visible paradigm of the past two decades, the old
    models have seen a recent resurgence. As with Python''s data structures, most
    of these tools are syntactic sugar over an underlying object-oriented implementation;
    we can think of them as a further abstraction layer built on top of the (already
    abstracted) object-oriented paradigm. In this chapter, we''ll be covering a grab
    bag of Python features that are not strictly object-oriented:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Python的许多方面看起来更像是结构化或函数式编程，而不是面向对象编程。尽管面向对象编程在过去二十年里是最明显的范式，但旧模型最近又有所复兴。与Python的数据结构一样，这些工具中的大多数都是在底层面向对象实现之上的语法糖；我们可以把它们看作是在（已经抽象化的）面向对象范式之上的进一步抽象层。在本章中，我们将介绍一些不是严格面向对象的Python特性：
- en: Built-in functions that take care of common tasks in one call
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置函数，可以在一次调用中处理常见任务
- en: File I/O and context managers
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件I/O和上下文管理器
- en: An alternative to method overloading
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法重载的替代方案
- en: Functions as objects
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数作为对象
- en: Python built-in functions
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python内置函数
- en: There are numerous functions in Python that perform a task or calculate a result
    on certain types of objects without being methods on the underlying class. They
    usually abstract common calculations that apply to multiple types of classes.
    This is duck typing at its best; these functions accept objects that have certain
    attributes or methods, and are able to perform generic operations using those
    methods. We've used many of the built-in functions already, but let's quickly
    go through the important ones and pick up a few neat tricks along the way.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Python中有许多函数在底层类上执行任务或计算结果，而不作为底层类的方法。它们通常抽象了适用于多个类类型的常见计算。这是鸭子类型的最典型表现；这些函数接受具有某些属性或方法的对象，并能够使用这些方法执行通用操作。我们已经使用了许多内置函数，但让我们快速浏览一下重要的函数，并在过程中学习一些技巧。
- en: The len() function
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`len()`函数'
- en: 'The simplest example is the `len()` function, which counts the number of items
    in some kind of container object, such as a dictionary or list. You''ve seen it
    before, demonstrated as follows::'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的例子是`len()`函数，它计算某种容器对象中项目的数量，例如字典或列表。你之前已经见过它，如下所示：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You may wonder why these objects don't have a length property instead of having
    to call a function on them. Technically, they do. Most objects that `len()` will
    apply to have a method called `__len__()` that returns the same value. So `len(myobj)`
    seems to call `myobj.__len__()`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么这些对象没有长度属性，而必须调用它们上的函数。技术上，它们确实有。大多数`len()`将应用的对象都有一个名为`__len__()`的方法，它返回相同的值。所以`len(myobj)`看起来是调用`myobj.__len__()`。
- en: Why should we use the `len()` function instead of the `__len__` method? Obviously, `__len__`
    is a special double-underscore method, suggesting that we shouldn't call it directly.
    There must be an explanation for this. The Python developers don't make such design
    decisions lightly.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们应该使用`len()`函数而不是`__len__`方法？显然，`__len__`是一个特殊的双下划线方法，暗示我们不应该直接调用它。这肯定有它的原因。Python开发者不会轻易做出这样的设计决策。
- en: The main reason is efficiency. When we call `__len__` on an object, the object
    has to look the method up in its namespace, and, if the special `__getattribute__`
    method (which is called every time an attribute or method on an object is accessed)
    is defined on that object, it has to be called as well. Furthermore, the `__getattribute__`
    for that particular method may have been written to do something nasty, such as
    refusing to give us access to special methods such as `__len__`! The `len()` function
    doesn't encounter any of this. It actually calls the `__len__` function on the
    underlying class, so `len(myobj)` maps to `MyObj.__len__(myobj)`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 主要原因是效率。当我们对一个对象调用`__len__`时，对象必须在其命名空间中查找该方法，并且如果该对象上定义了特殊的`__getattribute__`方法（每次访问对象上的属性或方法时都会调用该方法），它也必须被调用。此外，该特定方法的`__getattribute__`可能被编写为执行一些令人讨厌的操作，例如拒绝给我们访问特殊方法，如`__len__`！`len()`函数不会遇到这些问题。它实际上在底层类上调用`__len__`函数，所以`len(myobj)`映射到`MyObj.__len__(myobj)`。
- en: Another reason is maintainability. In the future, Python developers may want
    to change `len()` so that it can calculate the length of objects that don't have
    `__len__`, for example, by counting the number of items returned in an iterator.
    They'll only have to change one function instead of countless `__len__` methods
    in many objects across the board.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个原因是可维护性。在未来，Python开发者可能想要更改`len()`，使其能够计算没有`__len__`的对象的长度，例如，通过计算迭代器返回的项目数量。他们只需更改一个函数，而不是在许多对象中更改无数个`__len__`方法。
- en: 'There is one other extremely important and often overlooked reason for `len()`
    being an external function: backward compatibility. This is often cited in articles
    as *for historical reasons*, which is a mildly dismissive phrase that an author
    will use to say something is the way it is because a mistake was made long ago
    and we''re stuck with it. Strictly speaking, `len()` isn''t a mistake, it''s a
    design decision, but that decision was made in a less object-oriented time. It
    has stood the test of time and has some benefits, so do get used to it.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常重要的、经常被忽视的原因是`len()`是一个外部函数：向后兼容性。这通常在文章中引用为“出于历史原因”，这是一个轻微的轻蔑说法，作者会用来表示某事之所以如此，是因为很久以前犯了一个错误，我们不得不忍受它。严格来说，`len()`不是一个错误，而是一个设计决策，但这个决策是在一个不那么面向对象的时代做出的。它经受了时间的考验，并有一些好处，所以请习惯它。
- en: Reversed
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逆序
- en: The `reversed()` function takes any sequence as input, and returns a copy of
    that sequence in reverse order. It is normally used in `for` loops when we want
    to loop over items from back to front.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`reversed()`函数接受任何序列作为输入，并返回该序列的逆序副本。它通常在`for`循环中使用，当我们想要从后向前遍历项目时。'
- en: 'Similar to `len`, `reversed` calls the `__reversed__()` function on the class
    for the parameter. If that method does not exist, `reversed` builds the reversed
    sequence itself using calls to `__len__` and `__getitem__`, which are used to
    define a sequence. We only need to override `__reversed__` if we want to somehow
    customize or optimize the process, as demonstrated in the following code:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 与`len`类似，`reversed`在参数的类上调用`__reversed__()`函数。如果该方法不存在，`reversed`将使用定义序列时使用的`__len__`和`__getitem__`调用本身构建逆序序列。我们只需要覆盖`__reversed__`，如果我们想以某种方式自定义或优化这个过程，如下面的代码所示：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `for` loops at the end print reversed versions of a normal list, and instances
    of the two custom sequences. The output shows that `reversed` works on all three
    of them, but has very different results when we define `__reversed__` ourselves:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 结尾的`for`循环打印了正常列表和两个自定义序列的逆序版本。输出显示`reversed`在这三个中都能工作，但当我们自己定义`__reversed__`时，结果非常不同：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When we reverse `CustomSequence`, the `__getitem__` method is called for each
    item, which just inserts an `x` before the index. For `FunkyBackwards`, the `__reversed__`
    method returns a string, each character of which is output individually in the
    `for` loop.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们逆序`CustomSequence`时，`__getitem__`方法会为每个项目被调用，它只是在索引前插入一个`x`。对于`FunkyBackwards`，`__reversed__`方法返回一个字符串，每个字符都在`for`循环中单独输出。
- en: The preceding two classes aren't very good sequences, as they don't define a
    proper version of `__iter__`, so a forward `for` loop over them would never end.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个类并不是很好的序列，因为它们没有定义一个合适的`__iter__`版本，所以对它们的正向`for`循环永远不会结束。
- en: Enumerate
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 枚举
- en: 'Sometimes, when we''re looping over a container in a `for` loop, we want access
    to the index (the current position in the list) of the current item being processed.
    The `for` loop doesn''t provide us with indexes, but the `enumerate` function
    gives us something better: it creates a sequence of tuples, where the first object
    in each tuple is the index and the second is the original item.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，当我们在一个`for`循环中遍历一个容器时，我们想要访问当前正在处理的项目索引（列表中的当前位置）。`for`循环不会为我们提供索引，但`enumerate`函数给了我们更好的东西：它创建了一个元组的序列，其中每个元组的第一个对象是索引，第二个是原始项目。
- en: 'This is useful if we need to use index numbers directly. Consider some simple
    code that outputs each of the lines in a file with line numbers:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要直接使用索引号，这很有用。考虑一些简单的代码，它输出文件中的每一行并带有行号：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Running this code using its own filename as the input file shows how it works:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用其自己的文件名作为输入文件运行此代码，展示了它是如何工作的：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `enumerate` function returns a sequence of tuples, our `for` loop splits
    each tuple into two values, and the `print` statement formats them together. It
    adds one to the index for each line number, since `enumerate`, like all sequences,
    is zero-based.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`enumerate` 函数返回一个元组序列，我们的 `for` 循环将每个元组拆分为两个值，`print` 语句将它们格式化在一起。它为每一行编号加一，因为
    `enumerate`，像所有序列一样，是基于零的。'
- en: 'We''ve only touched on a few of the more important Python built-in functions.
    As you can see, many of them call into object-oriented concepts, while others
    subscribe to purely functional or procedural paradigms. There are numerous others
    in the standard library; some of the more interesting ones include the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只触及了Python内置函数中的一些重要函数。正如你所见，许多函数都调用了面向对象的概念，而其他一些则遵循纯粹的功能或过程式范式。标准库中还有许多其他函数；其中一些有趣的函数包括以下内容：
- en: '`all` and `any`, which accept an iterable object and return `True` if all,
    or any, of the items evaluate to true (such as a non-empty string or list, a non-zero
    number, an object that is not `None`, or the literal `True`).'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`all` 和 `any`，这两个函数接受一个可迭代对象，如果所有或任何项评估为真（例如非空字符串或列表、非零数字、非 `None` 对象或字面量 `True`），则返回
    `True`。'
- en: '`eval`, `exec`, and `compile`, which execute string as code inside the interpreter.
    Be careful with these ones; they are not safe, so don''t execute code an unknown
    user has supplied to you (in general, assume all unknown users are malicious,
    foolish, or both).'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eval`、`exec` 和 `compile`，这三个函数在解释器内部执行字符串作为代码。对这些函数要小心；它们不安全，因此不要执行未知用户提供的代码（通常，假设所有未知用户都是恶意的、愚蠢的或两者兼而有之）。'
- en: '`hasattr`, `getattr`, `setattr`, and `delattr`, which allow attributes on an
    object to be manipulated by their string names.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hasattr`、`getattr`、`setattr` 和 `delattr`，这些函数允许通过对象的字符串名称来操作其属性。'
- en: '`zip`, which takes two or more sequences and returns a new sequence of tuples,
    where each tuple contains a single value from each sequence.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`zip` 函数接受两个或更多序列，并返回一个新的元组序列，其中每个元组包含每个序列的单个值。'
- en: And many more! See the interpreter help documentation for each of the functions
    listed in `dir(__builtins__)`.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以及更多！请参阅 `dir(__builtins__)` 中列出的每个函数的解释器帮助文档。
- en: File I/O
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件输入/输出
- en: Our examples so far that have touched the filesystem have operated entirely
    on text files without much thought as to what is going on under the hood. Operating
    systems, however, actually represent files as a sequence of bytes, not text. We'll
    take a deep dive into the relationship between bytes and text in [Chapter 8](9a6335a2-1c69-4fa8-a685-02bbeeba23be.xhtml),
    *Strings and Serialization*. For now, be aware that reading textual data from
    a file is a fairly involved process. Python, especially Python 3, takes care of
    most of this work for us behind the scenes. Aren't we lucky?!
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止的示例已经涉及到文件系统，但几乎没有考虑底层发生了什么。然而，操作系统实际上将文件表示为字节序列，而不是文本。我们将在第8章深入探讨字节和文本之间的关系，*字符串和序列化*。现在，请注意，从文件中读取文本数据是一个相当复杂的过程。Python，尤其是Python
    3，在幕后为我们处理了大部分工作。我们不是太幸运吗？!
- en: The concept of files has been around since long before anyone coined the term
    *object-oriented programming*. However, Python has wrapped the interface that
    operating systems provide in a sweet abstraction that allows us to work with file
    (or file-like, vis-à-vis duck typing) objects.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的概念早在有人提出“面向对象编程”这个术语之前就已经存在了。然而，Python将操作系统提供的接口封装在一个甜美的抽象中，这使得我们可以与文件（或类似文件的，即鸭子类型）对象一起工作。
- en: The `open()` built-in function is used to open a file and return a file object.
    For reading text from a file, we only need to pass the name of the file into the
    function. The file will be opened for reading, and the bytes will be converted
    to text using the platform default encoding.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`open()` 内置函数用于打开文件并返回一个文件对象。为了从文件中读取文本，我们只需要将文件名传递给该函数。文件将以读取模式打开，并且将使用平台默认编码将字节转换为文本。'
- en: 'Of course, we don''t always want to read files; often we want to write data
    to them! To open a file for writing, we need to pass a `mode` argument as the
    second positional argument, with a value of `"w"`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们并不总是想读取文件；通常我们希望向它们写入数据！为了写入文件，我们需要将一个 `mode` 参数作为第二个位置参数传递，其值为 `"w"`：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We could also supply the value `"a"` as a mode argument, to append to the end
    of the file, rather than completely overwriting existing file content.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以将值 `"a"` 作为模式参数提供，以将内容追加到文件末尾，而不是完全覆盖现有文件内容。
- en: These files with built-in wrappers for converting bytes to text are great, but
    it'd be awfully inconvenient if the file we wanted to open was an image, executable,
    or other binary file, wouldn't it?
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这些内置了将字节转换为文本的包装器的文件很棒，但如果我们要打开的文件是一个图像、可执行文件或其他二进制文件，那就非常不方便了，不是吗？
- en: To open a binary file, we modify the mode string to append `'b'`. So, `'wb'`
    would open a file for writing bytes, while `'rb'` allows us to read them. They
    will behave like text files, but without the automatic encoding of text to bytes.
    When we read such a file, it will return `bytes` objects instead of `str`, and
    when we write to it, it will fail if we try to pass a text object.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要打开一个二进制文件，我们修改模式字符串以附加`'b'`。因此，`'wb'`将打开一个用于写入字节的文件，而`'rb'`允许我们读取它们。它们的行为类似于文本文件，但没有将文本自动编码为字节的操作。当我们读取这样的文件时，它将返回`bytes`对象，而当我们写入它时，如果我们尝试传递一个文本对象，它将失败。
- en: These mode strings for controlling how files are opened are rather cryptic and
    are neither Pythonic nor object-oriented. However, they are consistent with virtually
    every other programming language out there. File I/O is one of the fundamental
    jobs an operating system has to handle, and all programming languages have to
    talk to the operating system using the same system calls. Just be glad that Python
    returns a file object with useful methods instead of the integer that most major
    operating systems use to identify a file handle!
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 用于控制文件打开方式的这些模式字符串相当晦涩，既不符合Python风格，也不是面向对象的。然而，它们与几乎所有其他编程语言都保持一致。文件I/O是操作系统必须处理的基本任务之一，所有编程语言都必须使用相同的系统调用来与操作系统通信。庆幸的是，Python返回了一个带有有用方法的文件对象，而不是像大多数主要操作系统那样使用整数来标识文件句柄！
- en: Once a file is opened for reading, we can call the `read`, `readline`, or `readlines`
    methods to get the contents of the file. The `read` method returns the entire
    contents of the file as a `str` or `bytes` object, depending on whether there
    is `'b'` in the mode. Be careful not to use this method without arguments on huge
    files. You don't want to find out what happens if you try to load that much data
    into memory!
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦文件被打开用于读取，我们可以调用`read`、`readline`或`readlines`方法来获取文件的内容。`read`方法返回整个文件的内容，作为一个`str`或`bytes`对象，这取决于模式中是否有`'b'`。小心不要在没有参数的情况下使用这个方法在大型文件上。你不想发现如果你尝试将这么多数据加载到内存中会发生什么！
- en: It is also possible to read a fixed number of bytes from a file; we pass an
    integer argument to the `read` method, describing how many bytes we want to read.
    The next call to `read` will load the next sequence of bytes, and so on. We can
    do this inside a `while` loop to read the entire file in manageable chunks.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 从文件中读取固定数量的字节也是可能的；我们通过传递一个整数参数给`read`方法，来描述我们想要读取的字节数。下一次调用`read`方法将加载下一个字节序列，依此类推。我们可以在`while`循环中这样做，以分块读取整个文件。
- en: The `readline` method returns a single line from the file (where each line ends
    in a newline, a carriage return, or both, depending on the operating system on
    which the file was created). We can call it repeatedly to get additional lines.
    The plural `readlines` method returns a list of all the lines in the file. Like
    the `read` method, it's not safe to use on very large files. These two methods
    even work when the file is open in `bytes` mode, but it only makes sense if we
    are parsing text-like data that has newlines at reasonable positions. An image
    or audio file, for example, will not have newline characters in it (unless the
    newline byte happened to represent a certain pixel or sound), so applying `readline`
    wouldn't make sense.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`readline`方法返回文件中的一行（每行以换行符、回车符或两者都结束，具体取决于创建文件的操作系统）。我们可以反复调用它来获取额外的行。复数形式的`readlines`方法返回文件中所有行的列表。像`read`方法一样，在非常大的文件上使用它并不安全。这两个方法在文件以`bytes`模式打开时也能工作，但这只有在我们要解析具有合理位置的新行的类似文本数据时才有意义。例如，图像或音频文件中不会有换行符（除非换行字节恰好代表某个像素或声音），所以应用`readline`就没有意义。'
- en: For readability, and to avoid reading a large file into memory at once, it is
    often better to use a `for` loop directly on a file object. For text files, it
    will read each line, one at a time, and we can process it inside the loop body.
    For binary files, it's better to read fixed-sized chunks of data using the `read()`
    method, passing a parameter for the maximum number of bytes to read.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高可读性，并避免一次性将大文件读入内存，通常最好直接在文件对象上使用`for`循环。对于文本文件，它将逐行读取，我们可以在循环体内部处理它。对于二进制文件，最好使用`read()`方法以固定大小的数据块读取，传递一个参数来指定要读取的最大字节数。
- en: Writing to a file is just as easy; the `write` method on file objects writes
    a string (or bytes, for binary data) object to the file. It can be called repeatedly
    to write multiple strings, one after the other. The `writelines` method accepts
    a sequence of strings and writes each of the iterated values to the file. The
    `writelines` method does *not* append a new line after each item in the sequence.
    It is basically a poorly named convenience function to write the contents of a
    sequence of strings without having to explicitly iterate over it using a `for`
    loop.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 向文件写入同样简单；文件对象的 `write` 方法将字符串（或字节，对于二进制数据）对象写入文件。它可以被重复调用以写入多个字符串，一个接一个。`writelines`
    方法接受一个字符串序列，并将迭代值中的每个值写入文件。`writelines` 方法不会在序列中的每个项目后添加新行。它基本上是一个命名不佳的便利函数，用于在不显式使用
    `for` 循环迭代的情况下写入字符串序列的内容。
- en: Lastly, and I do mean lastly, we come to the `close` method. This method should
    be called when we are finished reading or writing the file, to ensure any buffered
    writes are written to the disk, that the file has been properly cleaned up, and
    that all resources associated with the file are released back to the operating
    system. Technically, this will happen automatically when the script exits, but
    it's better to be explicit and clean up after ourselves, especially in long-running
    processes.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，而且我确实是指最后，我们来到了 `close` 方法。当我们在完成读取或写入文件后应该调用此方法，以确保任何缓冲的写入都被写入磁盘，文件已经被适当清理，以及所有与文件关联的资源都被释放回操作系统。技术上，当脚本退出时这会自动发生，但最好是明确地清理，尤其是在长时间运行的过程中。
- en: Placing it in context
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 放入上下文中
- en: The need to close files when we are finished with them can make our code quite
    ugly. Because an exception may occur at any time during file I/O, we ought to
    wrap all calls to a file in a `try`...`finally` clause. The file should be closed
    in the `finally` clause, regardless of whether I/O was successful. This isn't
    very Pythonic. Of course, there is a more elegant way to do it.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们完成文件操作时需要关闭文件，这可能会使我们的代码变得相当丑陋。因为文件 I/O 期间可能随时发生异常，我们应该将所有对文件的调用包裹在 `try`...`finally`
    子句中。文件应该在 `finally` 子句中关闭，无论 I/O 是否成功。这并不太符合 Python 风格。当然，还有更优雅的方式来处理。
- en: 'If we run `dir` on a file-like object, we see that it has two special methods
    named `__enter__` and `__exit__`. These methods turn the file object into what
    is known as a **context manager**. Basically, if we use a special syntax called
    the `with` statement, these methods will be called before and after nested code
    is executed. On file objects, the `__exit__` method ensures the file is closed,
    even if an exception is raised. We no longer have to explicitly manage the closing
    of the file. Here is what the `with` statement looks like in practice:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在一个文件对象上运行 `dir`，我们会看到它有两个特殊的方法名为 `__enter__` 和 `__exit__`。这些方法将文件对象转换成所谓的
    **上下文管理器**。基本上，如果我们使用一个特殊的语法，即 `with` 语句，这些方法将在嵌套代码执行前后被调用。在文件对象上，`__exit__` 方法确保即使在抛出异常的情况下文件也会被关闭。我们不再需要显式地管理文件的关闭。以下是在实践中
    `with` 语句的样子：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `open` call returns a file object, which has `__enter__` and `__exit__`
    methods. The returned object is assigned to the variable named `file` by the `as`
    clause. We know the file will be closed when the code returns to the outer indentation
    level, and that this will happen even if an exception is raised.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`open` 调用返回一个文件对象，该对象具有 `__enter__` 和 `__exit__` 方法。通过 `as` 子句，返回的对象被分配给名为
    `file` 的变量。我们知道当代码返回到外层缩进级别时文件将会被关闭，即使抛出了异常也是如此。'
- en: The `with` statement is used in several places in the standard library, where
    start up or cleanup code needs to be executed. For example, the `urlopen` call
    returns an object that can be used in a `with` statement to clean up the socket
    when we're done. Locks in the threading module can automatically release the lock
    when the statement has been executed.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`with` 语句在标准库的多个地方被使用，当需要执行启动或清理代码时。例如，`urlopen` 调用返回一个对象，该对象可以在 `with` 语句中使用来清理套接字，当我们完成时。在
    `threading` 模块中的锁可以自动释放锁，当语句被执行完毕。'
- en: 'Most interestingly, because the `with` statement can apply to any object that
    has the appropriate special methods, we can use it in our own frameworks. For
    example, remember that strings are immutable, but sometimes you need to build
    a string from multiple parts. For efficiency, this is usually done by storing
    the component strings in a list and joining them at the end. Let''s create a simple
    context manager that allows us to construct a sequence of characters and automatically
    convert it to a string upon exit:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最有趣的是，因为`with`语句可以应用于具有适当特殊方法的任何对象，我们可以在自己的框架中使用它。例如，记住字符串是不可变的，但有时你需要从多个部分构建一个字符串。为了效率，这通常是通过将组件字符串存储在列表中并在最后连接它们来完成的。让我们创建一个简单的上下文管理器，允许我们构建一个字符序列，并在退出时自动将其转换为字符串：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This code adds the two special methods required of a context manager to the
    `list` class it inherits from. The `__enter__` method performs any required setup
    code (in this case, there isn't any) and then returns the object that will be
    assigned to the variable after `as` in the `with` statement. Often, as we've done
    here, this is just the context manager object itself. The `__exit__` method accepts
    three arguments. In a normal situation, these are all given a value of `None`.
    However, if an exception occurs inside the `with` block, they will be set to values
    related to the type, value, and traceback for the exception. This allows the `__exit__`
    method to perform any cleanup code that may be required, even if an exception
    occurred. In our example, we take the irresponsible path and create a result string
    by joining the characters in the string, regardless of whether an exception was
    thrown.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将上下文管理器所需的两个特殊方法添加到它继承的`list`类中。`__enter__`方法执行任何所需的设置代码（在这种情况下，没有）然后返回将在`with`语句中的`as`之后分配给变量的对象。通常，就像我们在这里做的那样，这仅仅是上下文管理器对象本身。`__exit__`方法接受三个参数。在正常情况下，这些参数都被赋予`None`的值。然而，如果在`with`块内部发生异常，它们将被设置为与异常类型、值和回溯相关的值。这允许`__exit__`方法执行可能需要的任何清理代码，即使发生了异常。在我们的例子中，我们采取了不负责任的做法，通过连接字符串中的字符来创建一个结果字符串，无论是否抛出异常。
- en: 'While this is one of the simplest context managers we could write, and its
    usefulness is dubious, it does work with a `with` statement. Have a look at it
    in action:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是我们能够编写的最简单的上下文管理器之一，但其实用性值得怀疑，但它确实可以与`with`语句一起工作。看看它是如何运作的：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This code constructs a string of 15 random characters. It appends these to a
    `StringJoiner` using the `append` method it inherited from `list`. When the `with`
    statement goes out of scope (back to the outer indentation level), the `__exit__`
    method is called, and the `result` attribute becomes available on the joiner object.
    We then print this value to see a random string.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码构建了一个由15个随机字符组成的字符串。它使用从`list`继承的`append`方法将这些字符追加到`StringJoiner`中。当`with`语句超出作用域（回到外层缩进级别）时，会调用`__exit__`方法，并且`result`属性在连接器对象上变得可用。然后我们打印这个值以查看一个随机字符串。
- en: An alternative to method overloading
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法重载的替代方案
- en: One prominent feature of many object-oriented programming languages is a tool
    called **method overloading**. Method overloading simply refers to having multiple
    methods with the same name that accept different sets of arguments. In statically
    typed languages, this is useful if we want to have a method that accepts either
    an integer or a string, for example. In non-object-oriented languages, we might
    need two functions, called `add_s` and `add_i`, to accommodate such situations.
    In statically typed object-oriented languages, we'd need two methods, both called
    `add`, one that accepts strings, and one that accepts integers.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 许多面向对象编程语言的一个显著特点是称为**方法重载**的工具。方法重载简单地说就是拥有多个具有相同名称的方法，这些方法接受不同的参数集。在静态类型语言中，如果我们想有一个接受整数或字符串的方法，例如，这很有用。在非面向对象语言中，我们可能需要两个函数，称为`add_s`和`add_i`，以适应这种情况。在静态类型面向对象语言中，我们需要两个方法，都称为`add`，一个接受字符串，另一个接受整数。
- en: In Python, we've already seen that we only need one method, which accepts any
    type of object. It may have to do some testing on the object type (for example,
    if it is a string, convert it to an integer), but only one method is required.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，我们已经看到我们只需要一个方法，该方法接受任何类型的对象。它可能需要对对象类型进行一些测试（例如，如果它是一个字符串，将其转换为整数），但只需要一个方法。
- en: However, method overloading is also useful when we want a method with the same
    name to accept different numbers or sets of arguments. For example, an email message
    method might come in two versions, one of which accepts an argument for the *from* email
    address. The other method might look up a default *from* email address instead.
    Python doesn't permit multiple methods with the same name, but it does provide
    a different, equally flexible, interface.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们想要一个具有相同名称的方法接受不同数量或参数集时，方法重载也是有用的。例如，一个电子邮件消息方法可能有两种版本，其中一种接受一个用于*from*电子邮件地址的参数。另一种方法可能查找默认的*from*电子邮件地址。Python不允许存在多个同名的方法，但它确实提供了一个不同但同样灵活的接口。
- en: 'We''ve seen some of the possible ways to send arguments to methods and functions
    in previous examples, but now we''ll cover all the details. The simplest function
    accepts no arguments. We probably don''t need an example, but here''s one for
    completeness:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在之前的例子中已经看到了向方法和函数发送参数的一些可能方法，但现在我们将涵盖所有细节。最简单的函数不接受任何参数。我们可能不需要示例，但这里有一个为了完整性：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And here''s how it''s called:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以及它是如何被调用的：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: A function that does accept arguments will provide the names of those arguments
    in a comma-separated list. Only the name of each argument needs to be supplied.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 接受参数的函数将提供一个逗号分隔的参数名称列表。只需要提供每个参数的名称。
- en: 'When calling the function, these positional arguments must be specified in
    order, and none can be missed or skipped. This is the most common way in which
    we''ve specified arguments in our previous examples:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用函数时，这些位置参数必须按顺序指定，不能遗漏或跳过。这是我们之前示例中最常见的指定参数的方式：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To call it, type the following::'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用它，请输入以下内容：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Any type of object can be passed as an argument: an object, a container, a
    primitive, even functions and classes. The preceding call shows a hardcoded string,
    an unknown variable, and an integer passed into the function.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 任何类型的对象都可以作为参数传递：一个对象、一个容器、一个原始数据类型，甚至是函数和类。前面的调用显示了硬编码的字符串、一个未知变量和一个整数传递到函数中。
- en: Default arguments
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认参数
- en: If we want to make an argument optional, rather than creating a second method
    with a different set of arguments, we can specify a default value in a single
    method, using an equals sign. If the calling code does not supply this argument,
    it will be assigned a default value. However, the calling code can still choose
    to override the default by passing in a different value. Often, a default value
    of `None`, or an empty string or list, is suitable.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要使一个参数可选，而不是创建一个具有不同参数集的第二种方法，我们可以在一个方法中指定一个默认值，使用等号。如果调用代码没有提供这个参数，它将被分配一个默认值。然而，调用代码仍然可以选择通过传递不同的值来覆盖默认值。通常，`None`、空字符串或空列表的默认值是合适的。
- en: 'Here''s a function definition with default arguments:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个带有默认参数的函数定义：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The first three arguments are still mandatory and must be passed by the calling
    code. The last two parameters have default arguments supplied.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 前三个参数仍然是强制性的，必须由调用代码提供。最后两个参数提供了默认参数。
- en: 'There are several ways we can call this function. We can supply all arguments
    in order, as though all the arguments were positional arguments, as can be seen
    in the following::'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以几种方式调用这个函数。我们可以按顺序提供所有参数，就像所有参数都是位置参数一样，如下所示：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Alternatively, we can supply just the mandatory arguments in order, leaving
    the keyword arguments to be assigned their default values:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们也可以按顺序提供强制参数，让关键字参数分配它们的默认值：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can also use the equals sign syntax when calling a function to provide values
    in a different order, or to skip default values that we aren''t interested in.
    For example, we can skip the first keyword arguments and supply the second one:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在调用函数时使用等号语法来提供不同的顺序的值，或者跳过我们不感兴趣的默认值。例如，我们可以跳过第一个关键字参数并提供第二个参数：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Surprisingly, we can even use the equals sign syntax to mix up the order of
    positional arguments, so long as all of them are supplied:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 惊讶的是，我们甚至可以使用等号语法来混合位置参数的顺序，只要所有参数都提供：
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You may occasionally find it useful to make a *keyword-only* argument, that
    is, an argument that must be supplied as a keyword argument. You can do that by
    placing a `*` before the keyword-only arguments:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会偶尔发现，将一个*关键字仅*参数（即必须作为关键字参数提供的参数）是有用的。你可以通过在关键字仅参数之前放置一个`*`来实现这一点：
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This function has one positional argument, `x`, and three keyword arguments,
    `y`, `a`, and `b`. `x` and `y` are both mandatory, but `a` can only be passed
    as a keyword argument. `y` and `b` are both optional with default values, but
    if `b` is supplied, it can only be a keyword argument.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数有一个位置参数`x`和三个关键字参数`y`、`a`和`b`。`x`和`y`都是强制性的，但`a`只能作为关键字参数传递。`y`和`b`都是可选的，有默认值，但如果提供了`b`，它只能作为关键字参数。
- en: 'This function fails if you don''t pass `a`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不传递`a`，这个函数会失败：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'It also fails if you pass `a` as a positional argument:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你以位置参数传递`a`，它也会失败：
- en: '[PRE20]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'But you can pass `a` and `b` as keyword arguments:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 但你可以将`a`和`b`作为关键字参数传递：
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: With so many options, it may seem hard to pick one, but if you think of the
    positional arguments as an ordered list, and keyword arguments as sort of like
    a dictionary, you'll find that the correct layout tends to fall into place. If
    you need to require the caller to specify an argument, make it mandatory; if you
    have a sensible default, then make it a keyword argument. Choosing how to call
    the method normally takes care of itself, depending on which values need to be
    supplied, and which can be left at their defaults.  Keyword-only arguments are
    relatively rare, but when the use case comes up, they can make for a more elegant
    API.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 有这么多选项，可能看起来很难选择，但如果你将位置参数视为有序列表，将关键字参数视为类似字典的东西，你会发现正确的布局往往自然而然地就位。如果你需要要求调用者指定一个参数，就让它成为强制性的；如果你有一个合理的默认值，那么就将其作为关键字参数。如何调用方法通常取决于需要提供哪些值，哪些可以保留为默认值。仅关键字参数相对较少，但在用例出现时，它们可以使API更加优雅。
- en: 'One thing to take note of with keyword arguments is that anything we provide
    as a default argument is evaluated when the function is first interpreted, not
    when it is called. This means we can''t have dynamically generated default values.
    For example, the following code won''t behave quite as expected:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在关键字参数方面需要注意的一点是，我们提供的任何默认参数都是在函数首次解释时评估的，而不是在调用时。这意味着我们不能有动态生成的默认值。例如，以下代码的行为可能不会完全符合预期：
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If we run this code, it outputs the number `8` first, but then it outputs the
    number `5` for the call with no arguments. We had set the variable to the number
    `6`, as evidenced by the last line of output, but when the function is called,
    the number `5` is printed; the default value was calculated when the function
    was defined, not when it was called.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这段代码，它首先输出数字`8`，然后对于不带参数的调用，它输出数字`5`。我们已将变量设置为数字`6`，如输出最后一行所示，但在函数调用时，打印的是数字`5`；默认值是在函数定义时计算的，而不是在调用时。
- en: 'This is tricky with empty containers such as lists, sets, and dictionaries.
    For example, it is common to ask calling code to supply a list that our function
    is going to manipulate, but the list is optional. We''d like to make an empty
    list as a default argument. We can''t do this; it will create only one list, when
    the code is first constructed, demonstrated as follows::'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '对于空容器，如列表、集合和字典，这很棘手。例如，通常要求调用代码提供一个列表，我们的函数将要对其进行操作，但这个列表是可选的。我们希望将一个空列表作为默认参数。我们不能这样做；当代码首次构建时，它只会创建一个列表，如下所示::'
- en: '[PRE23]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Whoops, that's not quite what we expected! The usual way to get around this
    is to make the default value `None`, and then use the `iargument = argument if
    argument else []` idiom inside the method. Pay close attention!
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀，这并不是我们预期的！通常绕过这个问题的方法是使默认值`None`，然后在方法内部使用`iargument = argument if argument
    else []`惯用表达式。请务必注意！
- en: Variable argument lists
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可变参数列表
- en: Default values alone do not allow us all the flexible benefits of method overloading.
    One thing that makes Python really slick is the ability to write methods that
    accept an arbitrary number of positional or keyword arguments without explicitly
    naming them. We can also pass arbitrary lists and dictionaries into such functions.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 仅默认值并不能给我们带来方法重载的所有灵活好处。使Python真正出色的一点是能够编写接受任意数量位置或关键字参数的方法，而无需显式命名它们。我们还可以将任意列表和字典传递到这样的函数中。
- en: 'For example, a function to accept a link or list of links and download the
    web pages could use such variadic arguments, or **varargs**. Instead of accepting
    a single value that is expected to be a list of links, we can accept an arbitrary
    number of arguments, where each argument is a different link. We do this by specifying
    the `*` operator in the function definition, as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个接受链接或链接列表并下载网页的函数可以使用这样的可变参数，或称为 **varargs**。我们不需要接受一个预期为链接列表的单个值，而是可以接受任意数量的参数，其中每个参数都是不同的链接。我们通过在函数定义中指定
    `*` 运算符来实现这一点，如下所示：
- en: '[PRE24]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `*links` parameter says, *I''ll accept any number of arguments and put
    them all in a list named* `links`. If we supply only one argument, it''ll be a
    list with one element; if we supply no arguments, it''ll be an empty list. Thus,
    all these function calls are valid:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`*links` 参数表示，**“我会接受任意数量的参数并将它们全部放入一个名为* `links` 的列表中”。如果我们只提供一个参数，它将是一个只有一个元素的列表；如果我们不提供任何参数，它将是一个空列表。因此，所有这些函数调用都是有效的**：'
- en: '[PRE25]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can also accept arbitrary keyword arguments. These arrive in the function
    as a dictionary. They are specified with two asterisks (as in `**kwargs`) in the
    function declaration. This tool is commonly used in configuration setups. The
    following class allows us to specify a set of options with default values:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以接受任意的关键字参数。这些参数以字典的形式传递给函数。它们在函数声明中用两个星号（如 `**kwargs`）指定。这个工具在配置设置中常用。以下类允许我们指定一组具有默认值的选项：
- en: '[PRE26]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'All the interesting stuff in this class happens in the `__init__` method. We
    have a dictionary of default options and values at the class level. The first
    thing the `__init__` method does is make a copy of this dictionary. We do that
    instead of modifying the dictionary directly, in case we instantiate two separate
    sets of options. (Remember, class-level variables are shared between instances
    of the class.) Then, `__init__` uses the `update` method on the new dictionary
    to change any non-default values to those supplied as keyword arguments. The `__getitem__`
    method simply allows us to use the new class using indexing syntax. Here''s a
    session demonstrating the class in action:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类中所有有趣的事情都发生在 `__init__` 方法中。我们在类级别有一个默认选项和值的字典。`__init__` 方法首先做的事情是复制这个字典。我们这样做而不是直接修改字典，以防我们实例化两个不同的选项集。（记住，类级别的变量在类的实例之间是共享的。）然后，`__init__`
    使用新字典上的 `update` 方法将任何非默认值更改为作为关键字参数提供的值。`__getitem__` 方法简单地允许我们使用新的类，并使用索引语法。以下是一个演示该类如何工作的会话：
- en: '[PRE27]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We're able to access our `options` instance using dictionary indexing syntax,
    and the dictionary includes both default values and the ones we set using keyword
    arguments.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够使用字典索引语法访问我们的 `options` 实例，并且这个字典包括默认值和我们使用关键字参数设置的值。
- en: The keyword argument syntax can be dangerous, as it may break the *explicit
    is better than implicit* rule. In the preceding example, it's possible to pass
    arbitrary keyword arguments to the `Options` initializer to represent options
    that don't exist in the default dictionary. This may not be a bad thing, depending
    on the purpose of the class, but it makes it hard for someone using the class
    to discover what valid options are available. It also makes it easy to enter a
    confusing typo (*Debug* instead of *debug*, for example) that adds two options
    where only one should have existed.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字参数的语法可能很危险，因为它可能会破坏**“显式优于隐式”**的规则。在上面的例子中，我们可以向 `Options` 初始化器传递任意的关键字参数来表示默认字典中不存在的选项。这可能不是一件坏事，取决于类的用途，但它使得使用该类的人很难发现哪些有效的选项可用。这也使得容易输入令人困惑的拼写错误（例如，*Debug*
    而不是 *debug*），这会在只有一个选项应该存在的地方添加两个选项。
- en: 'Keyword arguments are also very useful when we need to accept arbitrary arguments
    to pass to a second function, but we don''t know what those arguments will be.
    We saw this in action in [Chapter 3](ba7b3eb7-17cc-4f1c-bb74-fb7d5ee7d517.xhtml),
    *When Objects Are Alike*, when we were building support for multiple inheritance.
    We can, of course, combine the variable argument and variable keyword argument
    syntax in one function call, and we can use normal positional and default arguments
    as well. The following example is somewhat contrived, but demonstrates the four
    types in action:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要接受任意参数传递给第二个函数，但我们不知道这些参数将是什么时，关键字参数也非常有用。我们在[第3章](ba7b3eb7-17cc-4f1c-bb74-fb7d5ee7d517.xhtml)，*当对象相似时*，看到了这一点，当时我们在构建多重继承的支持。当然，我们可以在一个函数调用中结合可变参数和可变关键字参数的语法，并且我们还可以使用正常的定位参数和默认参数。以下例子有些牵强，但演示了四种类型在实际中的应用：
- en: '[PRE28]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This example processes an arbitrary list of files. The first argument is a target
    folder, and the default behavior is to move all remaining non-keyword argument
    files into that folder. Then there is a keyword-only argument, `verbose`, which
    tells us whether to print information on each file processed. Finally, we can
    supply a dictionary containing actions to perform on specific filenames; the default
    behavior is to move the file, but if a valid string action has been specified
    in the keyword arguments, it can be ignored or copied instead. Notice the ordering
    of the parameters in the function; first, the positional argument is specified,
    then the `*filenames` list, then any specific keyword-only arguments, and finally,
    a `**specific` dictionary to hold remaining keyword arguments.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例处理一个任意文件列表。第一个参数是目标文件夹，默认行为是将所有剩余的非关键字参数文件移动到该文件夹中。然后是一个仅关键字参数，`verbose`，它告诉我们是否要在每个处理的文件上打印信息。最后，我们可以提供一个包含对特定文件名执行操作的字典；默认行为是移动文件，但如果在关键字参数中指定了有效的字符串操作，则可以忽略或复制它。注意函数中参数的顺序；首先指定位置参数，然后是`*filenames`列表，然后是任何特定的仅关键字参数，最后是一个`**specific`字典来保存剩余的关键字参数。
- en: We create an inner helper function, `print_verbose`, which will print messages
    only if the `verbose` key has been set. This function keeps code readable by encapsulating
    this functionality in a single location.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个内部辅助函数`print_verbose`，该函数仅在设置了`verbose`键时打印消息。这个函数通过将此功能封装在单个位置来保持代码的可读性。
- en: 'In common cases, assuming the files in question exist, this function could
    be called as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在常见情况下，假设相关的文件存在，此函数可以如下调用：
- en: '[PRE29]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This command would move the files `one` and `two` into the `move_here` directory,
    assuming they exist (there's no error checking or exception handling in the function,
    so it would fail spectacularly if the files or target directory didn't exist).
    The move would occur without any output, since `verbose` is `False` by default.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令会将文件`one`和`two`移动到`move_here`目录中，假设它们存在（函数中没有错误检查或异常处理，所以如果文件或目标目录不存在，它将失败得非常惨烈）。由于默认情况下`verbose`为`False`，移动操作将没有任何输出。
- en: 'If we want to see the output, we can call it with the help of the following
    command:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想查看输出，我们可以使用以下命令来调用它：
- en: '[PRE30]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This moves one file named `three`, and tells us what it's doing. Notice that
    it is impossible to specify `verbose` as a positional argument in this example;
    we must pass a keyword argument. Otherwise, Python would think it was another
    filename in the `*filenames` list.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这将移动一个名为`three`的文件，并告诉我们它在做什么。注意，在这个例子中，不可能将`verbose`指定为位置参数；我们必须传递一个关键字参数。否则，Python会认为它是`*filenames`列表中的另一个文件名。
- en: 'If we want to copy or ignore some of the files in the list, instead of moving
    them, we can pass additional keyword arguments, as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在列表中复制或忽略一些文件，而不是移动它们，我们可以传递额外的关键字参数，如下所示：
- en: '[PRE31]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This will move the sixth file and copy the fourth, but won''t display any output,
    since we didn''t specify `verbose`. Of course, we can do that too, and keyword
    arguments can be supplied in any order, demonstrated as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这将移动第六个文件并复制第四个，但由于我们没有指定`verbose`，所以不会显示任何输出。当然，我们也可以这样做，并且关键字参数可以以任何顺序提供，如下所示：
- en: '[PRE32]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Unpacking arguments
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数解包
- en: 'There''s one more nifty trick involving variable arguments and keyword arguments.
    We''ve used it in some of our previous examples, but it''s never too late for
    an explanation. Given a list or dictionary of values, we can pass those values
    into a function as if they were normal positional or keyword arguments. Have a
    look at this code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个涉及可变参数和关键字参数的巧妙技巧。我们在一些之前的例子中使用过它，但解释永远不会太晚。给定一个值列表或字典，我们可以将这些值作为正常的位置参数或关键字参数传递给函数。看看这段代码：
- en: '[PRE33]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Here''s what it looks like when we run it:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行它时，看起来是这样的：
- en: '[PRE34]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The function accepts three arguments, one of which has a default value. But
    when we have a list of three arguments, we can use the `*` operator inside a function
    call to unpack it into the three arguments. If we have a dictionary of arguments,
    we can use the `**` syntax to unpack it as a collection of keyword arguments.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 函数接受三个参数，其中一个具有默认值。但是，当我们有三个参数的列表时，我们可以在函数调用中使用`*`运算符将其解包为三个参数。如果我们有一个参数字典，我们可以使用`**`语法将其解包为关键字参数集合。
- en: This is most often useful when mapping information that has been collected from
    user input or from an outside source (for example, an internet page or a text
    file) to a function or method call.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常在将收集自用户输入或外部来源（例如，网页或文本文件）的信息映射到函数或方法调用时非常有用。
- en: Remember our earlier example that used headers and lines in a text file to create
    a list of dictionaries with contact information? Instead of just adding the dictionaries
    to a list, we could use keyword unpacking to pass the arguments to the `__init__`
    method on a specially built `Contact` object that accepts the same set of arguments.
    See if you can adapt the example to make this work.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们之前使用文本文件中的标题和行来创建包含联系信息的字典列表的例子吗？我们不仅可以将字典添加到列表中，还可以使用关键字解包将参数传递给一个特别构建的`Contact`对象的`__init__`方法，该对象接受相同的参数集。看看你是否能修改这个例子使其工作。
- en: 'This unpacking syntax can be used in some areas outside of function calls,
    too. The `Options` class earlier had an `__init__` method that looked like this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这种解包语法也可以用在函数调用之外的一些区域。之前提到的`Options`类有一个`__init__`方法，看起来是这样的：
- en: '[PRE35]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'An even more succinct way to do this would be to unpack the two dictionaries
    like this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 做这件事的一个更简洁的方法是这样的：
- en: '[PRE36]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Because the dictionaries are unpacked in order from left to right, the resulting
    dictionary will contain all the default options, with any of the kwarg options
    replacing some of the keys. Here''s an example:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 因为字典是从左到右按顺序解包的，所以生成的字典将包含所有默认选项，其中任何关键字参数选项将替换一些键。这里有一个例子：
- en: '[PRE37]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Functions are objects too
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数也是对象
- en: Programming languages that overemphasize object-oriented principles tend to
    frown on functions that are not methods. In such languages, you're expected to
    create an object to sort of wrap the single method involved. There are numerous
    situations where we'd like to pass around a small object that is simply called
    to perform an action. This is most frequently done in event-driven programming,
    such as graphical toolkits or asynchronous servers; we'll see some design patterns
    that use it in [Chapter 10](345fe617-9a90-4c59-9355-e7076759f9a4.xhtml), *Design
    Patterns I*, and [Chapter 11](8f3d1c0f-4a63-4d06-8fb2-ad4dfe2669a3.xhtml), *Design
    Patterns II*.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 过度强调面向对象原则的编程语言往往对不是方法的函数持批评态度。在这些语言中，你被期望创建一个对象来包装涉及的单个方法。有许多情况下，我们希望传递一个简单的对象来执行某个动作。这在事件驱动编程中最为常见，例如图形工具包或异步服务器；我们将在第10章[设计模式I](345fe617-9a90-4c59-9355-e7076759f9a4.xhtml)和第11章[设计模式II](8f3d1c0f-4a63-4d06-8fb2-ad4dfe2669a3.xhtml)中看到一些使用它的设计模式。
- en: 'In Python, we don''t need to wrap such methods in an object because functions
    already are objects! We can set attributes on functions (though this isn''t a
    common activity), and we can pass them around to be called at a later date. They
    even have a few special properties that can be accessed directly. Here''s yet
    another contrived example:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，我们不需要将这些方法包装在对象中，因为函数本身就是对象！我们可以在函数上设置属性（尽管这不是一个常见的活动），并且我们可以将它们传递出去，以便在稍后的日期调用。它们甚至有一些可以直接访问的特殊属性。这里还有一个人为的例子：
- en: '[PRE38]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'If we run this code, we can see that we were able to pass two different functions
    into our third function, and get different output for each one:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这段代码，我们可以看到我们能够将两个不同的函数传递给我们的第三个函数，并且为每个函数得到不同的输出：
- en: '[PRE39]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We set an attribute on the function, named `description` (not very good descriptions,
    admittedly). We were also able to see the function's `__name__` attribute, and
    to access its class, demonstrating that the function really is an object with
    attributes. Then, we called the function by using the callable syntax (the parentheses).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在函数上设置了一个名为`description`的属性（诚然，这些描述并不很好）。我们还能够看到函数的`__name__`属性，以及访问其类，这表明函数确实是一个具有属性的实体。然后，我们通过使用可调用语法（括号）调用了该函数。
- en: 'The fact that functions are top-level objects is most often used to pass them
    around to be executed at a later date, for example, when a certain condition has
    been satisfied. Let''s build an event-driven timer that does just this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 函数作为顶级对象的事实最常用于将它们传递出去，以便在稍后的日期执行，例如，当满足某个条件时。让我们构建一个事件驱动的计时器来完成这个任务：
- en: '[PRE40]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In production, this code should definitely have extra documentation using docstrings!
    The `call_after` method should at least mention that the `delay` parameter is
    in seconds, and that the `callback` function should accept one argument: the timer
    doing the calling.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产中，此代码应该使用docstrings添加额外的文档！`call_after`方法至少应该提到`delay`参数是以秒为单位的，并且`callback`函数应接受一个参数：执行调用的计时器。
- en: We have two classes here. The `TimedEvent` class is not really meant to be accessed
    by other classes; all it does is store `endtime` and `callback`. We could even
    use a `tuple` or `namedtuple` here, but as it is convenient to give the object
    a behavior that tells us whether or not the event is ready to run, we use a class
    instead.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个类。`TimedEvent`类并不打算被其他类访问；它所做的只是存储`endtime`和`callback`。我们甚至可以使用`tuple`或`namedtuple`，但考虑到方便给对象一个告诉我们事件是否准备好运行的行为，我们使用了一个类。
- en: 'The `Timer` class simply stores a list of upcoming events. It has a `call_after`
    method to add a new event. This method accepts a `delay` parameter representing
    the number of seconds to wait before executing the callback, and the `callback`
    function itself: a function to be executed at the correct time. This `callback`
    function should accept one argument.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`Timer`类简单地存储一个即将发生的事件列表。它有一个`call_after`方法来添加新的事件。此方法接受一个表示在执行回调之前等待秒数的`delay`参数，以及`callback`函数本身：在正确时间执行的功能。此`callback`函数应接受一个参数。'
- en: The `run` method is very simple; it uses a generator expression to filter out
    any events whose time has come, and executes them in order. The *timer* loop then
    continues indefinitely, so it has to be interrupted with a keyboard interrupt
    (*Ctrl* + *C*, or *Ctrl* + *Break*). We sleep for half a second after each iteration
    so as to not grind the system to a halt.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`run`方法非常简单；它使用生成器表达式过滤掉任何时间已到的事件，并按顺序执行它们。然后，*计时器*循环无限期地继续，因此必须使用键盘中断（*Ctrl*
    + *C*，或*Ctrl* + *Break*）来中断它。我们每次迭代后休眠半秒钟，以免系统停止运行。'
- en: The important things to note here are the lines that touch callback functions.
    The function is passed around like any other object and the timer never knows
    or cares what the original name of the function is or where it was defined. When
    it's time to call the function, the timer simply applies the parenthesis syntax
    to the stored variable.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的重要事项是那些接触回调函数的行。该函数像任何其他对象一样被传递，计时器永远不会知道或关心该函数的原始名称或定义位置。当需要调用该函数时，计时器只需将括号语法应用于存储的变量。
- en: 'Here''s a set of callbacks that test the timer:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一组测试计时器的回调：
- en: '[PRE41]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This example allows us to see how multiple callbacks interact with the timer.
    The first function is the `format_time` function. It uses the format string syntax
    to add the current time to the message; we'll read about them in the next chapter.
    Next, we create three simple callback methods that simply output the current time
    and a short message telling us which callback has been fired.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例让我们看到多个回调如何与计时器交互。第一个函数是`format_time`函数。它使用格式字符串语法将当前时间添加到消息中；我们将在下一章中了解它们。接下来，我们创建了三个简单的回调方法，它们只是输出当前时间和一条简短的消息，告诉我们哪个回调已被触发。
- en: 'The `Repeater` class demonstrates that methods can be used as callbacks too,
    since they are really just functions that happen to be bound to an object. It
    also shows why the `timer` argument to the callback functions is useful: we can
    add a new timed event to the timer from inside a presently running callback. We
    then create a timer and add several events to it that are called after different
    amounts of time. Finally, we start the timer running; the output shows that events
    are run in the expected order:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`Repeater`类演示了方法也可以用作回调，因为它们实际上只是绑定到对象的函数。它还展示了回调函数中的`timer`参数为什么有用：我们可以在当前正在运行的回调内部向计时器添加新的定时事件。然后我们创建一个计时器并向它添加了几个不同时间后调用的事件。最后，我们开始运行计时器；输出显示事件按预期顺序运行：'
- en: '[PRE42]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Python 3.4 introduced a generic event loop architecture similar to this. We'll
    be discussing it later, in [Chapter 13](580eef91-bc55-4407-9475-9c31c5c4da80.xhtml),
    *Concurrency*.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3.4引入了类似于这种的通用事件循环架构。我们将在[第13章](580eef91-bc55-4407-9475-9c31c5c4da80.xhtml)中讨论它，*并发*。
- en: Using functions as attributes
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用函数作为属性
- en: 'One of the interesting effects of functions being objects is that they can
    be set as callable attributes on other objects. It is possible to add or change
    a function to an instantiated object, demonstrated as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 函数作为对象的一个有趣的效果是，它们可以被设置为其他对象的可调用属性。我们可以在实例化的对象上添加或更改一个函数，如下所示进行演示：
- en: '[PRE43]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This code creates a very simple class with a `print` method that doesn't tell
    us anything we didn't know. Then, we create a new function that tells us something
    we don't believe.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码创建了一个非常简单的类，它有一个`print`方法，这个方法并没有告诉我们任何我们不知道的事情。然后，我们创建了一个新的函数，它告诉我们一些我们不相信的事情。
- en: 'When we call `print` on an instance of the `A` class, it behaves as expected.
    If we then set the `print` method to point at a new function, it tells us something
    different:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在`A`类的实例上调用`print`时，它表现得如我们所预期。如果我们然后将`print`方法指向一个新的函数，它就会告诉我们一些不同的事情：
- en: '[PRE44]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: It is also possible to replace methods on classes instead of objects, although,
    in that case, we have to add the `self` argument to the parameter list. This will
    change the method for all instances of that object, even ones that have already
    been instantiated. Obviously, replacing methods like this can be both dangerous
    and confusing to maintain. Somebody reading the code will see that a method has
    been called and look up that method on the original class. But the method on the
    original class is not the one that was called. Figuring out what really happened
    can become a tricky, frustrating debugging session.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以在类上而不是对象上替换方法，尽管在这种情况下，我们必须在参数列表中添加`self`参数。这将改变该对象的所有实例的方法，即使是已经实例化的实例。显然，以这种方式替换方法既可能危险也可能令人困惑，难以维护。阅读代码的人会看到调用了某个方法，并会在原始类上查找该方法。但原始类上的方法并不是被调用的那个方法。弄清楚实际发生了什么可能成为一个棘手、令人沮丧的调试会话。
- en: It does have its uses though. Often, replacing or adding methods at runtime
    (called **monkey patching**) is used in automated testing. If testing a client-server
    application, we may not want to actually connect to the server while testing the
    client; this may result in accidental transfers of funds or embarrassing test
    emails being sent to real people. Instead, we can set up our test code to replace
    some of the key methods on the object that sends requests to the server so that
    it only records that the methods have been called.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它确实有其用途。通常，在运行时替换或添加方法（称为**猴子补丁**）用于自动化测试。如果我们正在测试客户端-服务器应用程序，我们可能不想在测试客户端时实际连接到服务器；这可能会导致意外转账或尴尬的测试邮件发送给真实的人。相反，我们可以设置我们的测试代码来替换对象上发送请求到服务器的一些关键方法，这样它只会记录这些方法已被调用。
- en: Monkey-patching can also be used to fix bugs or add features in third-party
    code that we are interacting with, and does not behave quite the way we need it
    to. It should, however, be applied sparingly; it's almost always a *messy hack*.
    Sometimes, though, it is the only way to adapt an existing library to suit our
    needs.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 猴子补丁也可以用来修复与我们交互的第三方代码中的错误或添加功能，而这些代码并不完全按照我们的需求运行。然而，应该谨慎使用；它几乎总是*一团糟的解决方案*。有时，尽管如此，它是唯一一种适应现有库以满足我们需求的方法。
- en: Callable objects
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可调用对象
- en: Just as functions are objects that can have attributes set on them, it is possible
    to create an object that can be called as though it were a function.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 正如函数是可以设置属性的物体一样，我们也可以创建一个可以被当作函数调用的对象。
- en: 'Any object can be made callable by simply giving it a `__call__` method that
    accepts the required arguments. Let''s make our `Repeater` class, from the timer
    example, a little easier to use by making it a callable, as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 任何对象都可以通过简单地给它一个接受所需参数的`__call__`方法来使其可调用。让我们通过使其可调用，使我们的`Repeater`类（来自计时器示例）更容易使用，如下所示：
- en: '[PRE45]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This example isn''t much different from the earlier class; all we did was change
    the name of the `repeater` function to `__call__` and pass the object itself as
    a callable. Note that, when we make the `call_after` call, we pass the argument
    `Repeater()`. Those two parentheses are creating a new instance of the class;
    they are not explicitly calling the class. This happens later, inside the timer.
    If we want to execute the `__call__` method on a newly instantiated object, we''d
    use a rather odd syntax: `Repeater()()`. The first set of parentheses constructs
    the object; the second set executes the `__call__` method. If we find ourselves
    doing this, we may not be using the correct abstraction. Only implement the `__call__`
    function on an object if the object is meant to be treated like a function.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子与之前的类并没有太大的不同；我们只是将 `repeater` 函数的名称更改为 `__call__`，并将对象本身作为可调用对象传递。请注意，当我们调用
    `call_after` 时，我们传递了 `Repeater()` 参数。这两个括号创建了一个新实例；它们并不是显式地调用类。这发生在计时器内部。如果我们想在新生成的对象上执行
    `__call__` 方法，我们将使用一个相当奇怪的语法：`Repeater()()`。第一组括号构建了对象；第二组执行 `__call__` 方法。如果我们发现自己这样做，我们可能没有使用正确的抽象。只有当对象被期望像函数一样处理时，才在对象上实现
    `__call__` 函数。
- en: Case study
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例研究
- en: To tie together some of the principles presented in this chapter, let's build
    a mailing list manager. The manager will keep track of email addresses categorized
    into named groups. When it's time to send a message, we can pick a group and send
    the message to all email addresses assigned to that group.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将本章中提出的一些原则结合起来，让我们构建一个邮件列表管理器。管理器将跟踪被分类到命名组中的电子邮件地址。当发送消息的时间到来时，我们可以选择一个组，并将消息发送到分配给该组的所有电子邮件地址。
- en: 'Now, before we start working on this project, we ought to have a safe way to
    test it, without sending emails to a bunch of real people. Luckily, Python has
    our back here; like the test HTTP server, it has a built-in **Simple Mail Transfer
    Protocol** (**SMTP**) server that we can instruct to capture any messages we send
    without actually sending them. We can run the server with the following command:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始这个项目之前，我们应该有一个安全的方式来测试它，而无需向一大群真实的人发送电子邮件。幸运的是，Python 在这里支持我们；就像测试 HTTP
    服务器一样，它有一个内置的 **简单邮件传输协议**（**SMTP**）服务器，我们可以指示它捕获我们发送的任何消息，而实际上并不发送它们。我们可以使用以下命令来运行服务器：
- en: '[PRE46]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Running this command at command prompt will start an SMTP server running on
    port 1025 on the local machine. But we've instructed it to use the `DebuggingServer`
    class (this class comes with the built-in SMTP module), which, instead of sending
    mails to the intended recipients, simply prints them on the terminal screen as
    it receives them.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令提示符下运行此命令将在本地机器上启动一个运行在端口 1025 上的 SMTP 服务器。但我们指示它使用 `DebuggingServer` 类（这个类是内置
    SMTP 模块的一部分），它不是将邮件发送给预期的收件人，而是在接收它们时简单地将它们打印在终端屏幕上。
- en: 'Now, before writing our mailing list, let''s write some code that actually
    sends mail. Of course, Python supports this in the standard library, too, but
    it''s a bit of an odd interface, so we''ll write a new function to wrap it all
    cleanly, as can be seen in the following code snipet:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们编写邮件列表之前，让我们编写一些实际发送邮件的代码。当然，Python 在标准库中也支持这一点，但它的接口有点奇怪，所以我们将编写一个新函数来干净地包装它，如下面的代码片段所示：
- en: '[PRE47]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We won't cover the code inside this method too thoroughly; the documentation
    in the standard library can give you all the information you need to use the `smtplib`
    and `email` modules effectively.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会对这个方法内部的代码进行过于详细的介绍；标准库中的文档可以提供你使用 `smtplib` 和 `email` 模块所需的所有信息。
- en: We've used both variable argument and keyword argument syntax in the function
    call. The variable argument list allows us to supply a single string in the default
    case of having a single `to` address, as well as permitting multiple addresses
    to be supplied if required. Any extra keyword arguments are mapped to email headers.
    This is an exciting use of variable arguments and keyword arguments, but it's
    not really a great interface for the person calling the function. In fact, it
    makes many things the programmer will want to do impossible.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在函数调用中使用了变量参数和关键字参数语法。变量参数列表允许我们在只有一个 `to` 地址的默认情况下提供一个单独的字符串，以及在需要时允许提供多个地址。任何额外的关键字参数都映射到电子邮件头。这是变量参数和关键字参数的一个令人兴奋的使用，但它并不是一个很好的函数调用接口。实际上，它使得程序员想要做的许多事情变得不可能。
- en: The headers passed into the function represent auxiliary headers that can be
    attached to a method. Such headers might include `Reply-To`, `Return-Path`, or
    *X-pretty-much-anything*. But in order to be a valid identifier in Python, a name
    cannot include the `-` character. In general, that character represents subtraction.
    So, it's not possible to call a function with `Reply-To``=``my@email.com`. As
    often happens, it appears we were too eager to use keyword arguments because they
    are a shiny new tool we just learned.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给函数的标题代表可以附加到方法上的辅助标题。这些标题可能包括`Reply-To`、`Return-Path`或*X-pretty-much-anything*。但是，为了在Python中成为一个有效的标识符，名称不能包含`-`字符。通常，该字符代表减法。因此，不可能用`Reply-To`=`my@email.com`来调用一个函数。正如经常发生的那样，我们似乎太急于使用关键字参数了，因为它们是我们刚刚学到的闪亮的新工具。
- en: 'We''ll have to change the argument to a normal dictionary; this will work because
    any string can be used as a key in a dictionary. By default, we''d want this dictionary
    to be empty, but we can''t make the default parameter an empty dictionary. So,
    we''ll have to make the default argument `None`, and then set up the dictionary
    at the beginning of the method, as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须将参数更改为普通字典；这将有效，因为任何字符串都可以用作字典的键。默认情况下，我们希望这个字典为空，但我们不能将空字典作为默认参数。因此，我们将默认参数设置为`None`，然后在方法的开头设置字典，如下所示：
- en: '[PRE48]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'If we have our debugging SMTP server running in one terminal, we can test this
    code in a Python interpreter:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在一个终端中运行调试SMTP服务器，我们可以在Python解释器中测试这段代码：
- en: '[PRE49]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Then, if we check the output from the debugging SMTP server, we get the following:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果我们检查调试SMTP服务器的输出，我们得到以下内容：
- en: '[PRE50]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Excellent, it has *sent* our email to the two expected addresses with subject
    and message contents included. Now that we can send messages, let's work on the
    email group management system. We'll need an object that somehow matches email
    addresses with the groups they are in. Since this is a many-to-many relationship
    (any one email address can be in multiple groups; any one group can be associated
    with multiple email addresses), none of the data structures we've studied seem
    ideal. We could try a dictionary of group names matched to a list of associated
    email addresses, but that would duplicate email addresses. We could also try a
    dictionary of email addresses matched to groups, resulting in a duplication of
    groups. Neither seems optimal. For fun, let's try this latter version, even though
    intuition tells me the groups to email address solution would be more straightforward.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，它已经*发送*了电子邮件到两个预期的地址，包括主题和消息内容。现在我们可以发送消息了，让我们来处理电子邮件组管理系统。我们需要一个对象，它能够以某种方式将电子邮件地址与它们所在的组匹配起来。由于这是一个多对多关系（任何一个电子邮件地址可以属于多个组；任何一个组可以与多个电子邮件地址相关联），我们研究过的数据结构似乎都不理想。我们可以尝试将组名与相关联的电子邮件地址列表匹配的字典，但这会导致电子邮件地址重复。我们也可以尝试将电子邮件地址与组匹配的字典，这会导致组重复。这两种方法似乎都不太理想。为了好玩，让我们尝试这个后一种版本，尽管直觉告诉我电子邮件地址与组解决方案会更直接。
- en: 'Since the values in our dictionary will always be collections of unique email
    addresses, we can store them in a `set` container. We can use `defaultdict` to
    ensure that there is always a `set` container available for each key, demonstrated
    as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们字典中的值始终是唯一电子邮件地址的集合，我们可以将它们存储在`set`容器中。我们可以使用`defaultdict`来确保对于每个键都始终有一个`set`容器可用，如下所示：
- en: '[PRE51]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now, let''s add a method that allows us to collect all the email addresses
    in one or more groups. This can be done by converting the list of groups to a
    set:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加一个方法，允许我们收集一个或多个组中的所有电子邮件地址。这可以通过将组列表转换为集合来完成：
- en: '[PRE52]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'First, look at what we''re iterating over: `self.email_map.items()`. This method,
    of course, returns a tuple of key-value pairs for each item in the dictionary.
    The values are sets of strings representing the groups. We split these into two
    variables named `e` and `g`, short for email and groups. We add the email address
    to the set of return values only if the passed-in groups intersect with the email
    address groups. The `g``&``groups` syntax is a shortcut for `g.intersection(groups)`;
    the `set` class does this by implementing the special `__and__` method to call
    `intersection`.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，看看我们正在迭代的：`self.email_map.items()`。这个方法当然返回字典中每个项目的键值对元组。值是表示组的字符串集合。我们将这些值分成两个变量，分别命名为`e`和`g`，分别代表电子邮件和组。只有当传入的组与电子邮件地址组相交时，我们才将电子邮件地址添加到返回值的集合中。`g
    & groups`语法是`g.intersection(groups)`的快捷方式；`set`类通过实现特殊的`__and__`方法来调用`intersection`。
- en: This code could be made a wee bit more concise using a set comprehension, which
    we'll discuss in [Chapter 9](0abbcae0-eb3f-4237-adda-32765e1cce32.xhtml), *The
    Iterator Pattern*.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可以通过使用集合推导式变得更加简洁，我们将在第9章[《迭代器模式》](0abbcae0-eb3f-4237-adda-32765e1cce32.xhtml)中讨论。
- en: 'Now, with these building blocks, we can trivially add a method to our `MailingList`
    class that sends messages to specific groups:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有了这些构建块，我们可以轻易地向我们的`MailingList`类添加一个方法，用于向特定组发送消息：
- en: '[PRE53]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This function relies on variable argument lists. As input, it takes a list of
    groups as variable arguments. It gets the list of emails for the specified groups
    and passes those as variable arguments into `send_email`, along with other arguments
    that were passed into this method.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数依赖于可变参数列表。作为输入，它接受一个作为可变参数的组列表。它获取指定组的电子邮件列表，并将这些作为可变参数传递给`send_email`，同时传递给这个方法的其他参数。
- en: 'The program can be tested by ensuring that the SMTP debugging server is running
    in one command prompt, and, in a second prompt, loading the code using the following:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过确保SMTP调试服务器在一个命令提示符中运行，并在第二个提示符中加载代码来测试程序：
- en: '[PRE54]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Create a `MailingList` object with the help of the following command:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令创建一个`MailingList`对象：
- en: '[PRE55]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Then, create a few fake email addresses and groups, along the lines of:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，创建一些伪造的电子邮件地址和组，例如：
- en: '[PRE56]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Finally, use a command like this to send emails to specific groups:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用类似以下命令将电子邮件发送到特定组：
- en: '[PRE57]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Emails to each of the addresses in the specified groups should show up in the
    console on the SMTP server.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 指定组中的每个地址的电子邮件应该显示在SMTP服务器的控制台上。
- en: The mailing list works fine as it is, but it's kind of useless; as soon as we
    exit the program, our database of information is lost. Let's modify it to add
    a couple of methods to load and save the list of email groups from and to a file.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 邮件列表本身运行良好，但有点无用；一旦我们退出程序，我们的信息数据库就会丢失。让我们修改它，添加一些方法来从文件中加载和保存电子邮件组列表。
- en: In general, when storing structured data on disk, it is a good idea to put a
    lot of thought into how it is stored. One of the reasons myriad database systems
    exist is that if someone else has put this thought into how data is stored, you
    don't have to. We'll be looking at some data serialization mechanisms in the next
    chapter, but for this example, let's keep it simple and go with the first solution
    that could possibly work.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当在磁盘上存储结构化数据时，仔细考虑其存储方式是个好主意。众多数据库系统存在的一个原因就是，如果有人已经考虑过如何存储数据，你就不必再考虑。我们将在下一章探讨一些数据序列化机制，但在这个例子中，让我们保持简单，采用第一个可能可行的解决方案。
- en: The data format I have in mind is to store each email address followed by a
    space, followed by a comma-separated list of groups. This format seems reasonable,
    and we're going to go with it because data formatting isn't the topic of this
    chapter. However, to illustrate just why you need to think hard about how you
    format data on disk, let's highlight a few problems with the format.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我心中所想的数据格式是存储每个电子邮件地址后跟一个空格，然后是逗号分隔的组列表。这种格式看起来是合理的，我们将采用它，因为数据格式化不是本章的主题。然而，为了说明为什么你需要认真思考如何在磁盘上格式化数据，让我们突出一些格式的问题。
- en: First, the space character is technically legal in email addresses. Most email
    providers prohibit it (with good reason), but the specification defining email
    addresses says an email can contain a space if it is in quotation marks. If we
    are to use a space as a sentinel in our data format, we should technically be
    able to differentiate between that space and a space that is part of an email.
    We're going to pretend this isn't true, for simplicity's sake, but real-life data
    encoding is full of stupid issues like this.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，空格字符在电子邮件地址中在技术上是被允许的。大多数电子邮件提供商禁止使用它（有很好的理由），但定义电子邮件地址的规范说明，如果电子邮件地址在引号内，则可以包含空格。如果我们打算在我们的数据格式中使用空格作为哨兵，那么在技术上我们应该能够区分这个空格和电子邮件地址中的一部分空格。为了简单起见，我们将假装这不是真的，但现实生活中的数据编码充满了这类愚蠢的问题。
- en: 'Second, consider the comma-separated list of groups. What happens if someone
    decides to put a comma in a group name? If we decide to make commas illegal in
    group names, we should add validation to enforce such naming in our `add_to_group`
    method. For pedagogical clarity, we''ll ignore this problem too. Finally, there
    are many security implications we need to consider: can someone get themselves
    into the wrong group by putting a fake comma in their email address? What does
    the parser do if it encounters an invalid file?'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，考虑逗号分隔的组列表。如果有人决定在组名中放置一个逗号会发生什么？如果我们决定在组名中使逗号非法，我们应该在`add_to_group`方法中添加验证来强制执行这种命名。为了教学清晰，我们也将忽略这个问题。最后，还有许多我们需要考虑的安全影响：有人可以通过在他们的电子邮件地址中放置一个假的逗号来让自己进入错误的组吗？如果解析器遇到无效的文件，它会做什么？
- en: The takeaway from this discussion is to try to use a data storage method that
    has been field tested, rather than designing our own data serialization protocols.
    There are a ton of bizarre edge cases you might overlook, and it's better to use
    code that has already encountered and fixed those edge cases.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 从这次讨论中得到的启示是，尝试使用经过实地测试的数据存储方法，而不是设计我们自己的数据序列化协议。可能会有很多奇怪的边缘情况被忽视，而且使用已经遇到并修复了这些边缘情况的代码会更好。
- en: 'But forget that. Let''s just write some basic code that uses an unhealthy dose
    of wishful thinking to pretend this simple data format is safe, demonstrated as
    follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 但先别管那个。让我们只写一些基本的代码，用不切实际的幻想来假装这种简单的数据格式是安全的，如下所示：
- en: '[PRE58]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The code to do this is as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一点的代码如下：
- en: '[PRE59]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: In the `save` method, we open the file in a context manager and write the file
    as a formatted string. Remember the newline character; Python doesn't add that
    for us. The `load` method first resets the dictionary (in case it contains data
    from a previous call to `load`). It adds a call to the standard library `suppress`
    context manager, available as `from contextlib import suppress`. This context
    manager catches any I/O Errors and ignores them. Not the best error handling,
    but it's prettier than try...finally...pass.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在`save`方法中，我们使用上下文管理器打开文件，并将文件写入为格式化的字符串。记住换行符；Python不会为我们添加它。`load`方法首先重置字典（以防它包含来自之前`load`调用的数据）。它添加了一个对标准库`suppress`上下文管理器的调用，可通过`from
    contextlib import suppress`访问。这个上下文管理器会捕获任何I/O错误并忽略它们。这不是最好的错误处理方式，但比try...finally...pass更美观。
- en: Then, the load method uses the `for`...`in` syntax, which loops over each line
    in the file. Again, the newline character is included in the line variable, so
    we have to call `.strip()` to take it off. We'll learn more about such string
    manipulation in the next chapter.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，加载方法使用`for...in`语法，它遍历文件中的每一行。同样，换行符包含在行变量中，所以我们必须调用`.strip()`来移除它。我们将在下一章中了解更多关于此类字符串操作的内容。
- en: 'Before using these methods, we need to make sure the object has a `self.data_file`
    attribute, which can be done by modifying `__init__` as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用这些方法之前，我们需要确保对象有一个`self.data_file`属性，这可以通过修改`__init__`来实现，如下所示：
- en: '[PRE60]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We can test these two methods in the interpreter as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在解释器中如下测试这两个方法：
- en: '[PRE61]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The resulting `addresses.db` file contains the following lines, as expected:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 结果的`addresses.db`文件包含以下行，正如预期的那样：
- en: '[PRE62]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We can also load this data back into a `MailingList` object successfully:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以成功地将这些数据重新加载到`MailingList`对象中：
- en: '[PRE63]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'As you can see, I forgot to add the `load` command, and it might be easy to
    forget the `save` command as well. To make this a little easier for anyone who
    wants to use our `MailingList` API in their own code, let''s provide the methods
    to support a context manager:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我忘记添加了`load`命令，而且也可能容易忘记`save`命令。为了让任何想要在自己的代码中使用我们的`MailingList` API的人更容易操作，让我们提供支持上下文管理器的函数：
- en: '[PRE64]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'These simple methods just delegate their work to load and save, but we can
    now write code like this in the interactive interpreter and know that all the
    previously stored addresses were loaded on our behalf, and that the whole list
    will be saved to the file when we are done:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这些简单的方法只是将工作委托给加载和保存，但现在我们可以在交互式解释器中编写如下代码，并知道所有之前存储的地址都已被加载，而且当我们完成时，整个列表将被保存到文件中：
- en: '[PRE65]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Exercises
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: If you haven't encountered the `with` statements and context managers before,
    I encourage you, as usual, to go through your old code, find all the places where
    you were opening files, and make sure they are safely closed using the `with`
    statement. Look for places to write your own context managers as well. Ugly or
    repetitive `try`...`finally` clauses are a good place to start, but you may find
    them useful any time you need to do before and/or after tasks in context.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前没有遇到过`with`语句和上下文管理器，我鼓励你，像往常一样，检查你的旧代码，找到所有你曾经打开文件的地方，并确保它们使用`with`语句安全关闭。也要寻找可以编写自己的上下文管理器的地方。丑陋或重复的`try`...`finally`子句是一个很好的起点，但你可能会在任何需要执行上下文中的前后任务时发现它们很有用。
- en: You've probably used many of the basic built-in functions before now. We covered
    several of them, but didn't go into a great deal of detail. Play with `enumerate`,
    `zip`, `reversed`, `any`, and `all`, until you know you'll remember to use them
    when they are the right tool for the job. The `enumerate` function is especially
    important, because not using it results in some pretty ugly `while` loops.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能之前已经使用过许多基本内置函数。我们介绍了几种，但并没有深入细节。玩转`enumerate`、`zip`、`reversed`、`any`和`all`，直到你确信自己会在需要时记得使用它们。`enumerate`函数尤其重要，因为不使用它会导致一些相当丑陋的`while`循环。
- en: Also explore some applications that pass functions around as callable objects,
    as well as using the `__call__` method to make your own objects callable. You
    can get the same effect by attaching attributes to functions or by creating a
    `__call__` method on an object. In which case would you use one syntax, and when
    would it be more suitable to use the other?
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 还要探索一些将函数作为可调用对象传递的应用，以及使用`__call__`方法使自己的对象可调用的方法。你可以通过将属性附加到函数或在一个对象上创建`__call__`方法来达到相同的效果。在哪种情况下你会使用一种语法，何时又更适合使用另一种语法？
- en: Our mailing list object could overwhelm an email server if there is a massive
    number of emails to be sent out. Try refactoring it so that you can use different
    `send_email` functions for different purposes. One such function could be the
    version we used here. A different version might put the emails in a queue to be
    sent by a server in a different thread or process. A third version could just
    output the data to the terminal, obviating the need for a dummy SMTP server. Can
    you construct the mailing list with a callback such that the `send_mailing` function
    uses whatever is passed in? It would default to the current version if no callback
    is supplied.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的邮件列表对象需要发送大量邮件，可能会压倒邮件服务器。尝试重构它，以便你可以为不同的目的使用不同的`send_email`函数。这里使用的一个版本可能是一个版本，它可能将邮件放入队列，由不同线程或进程的服务器发送。第三个版本可能只是将数据输出到终端，从而消除了需要虚拟SMTP服务器的需求。你能构建一个带有回调的邮件列表，使得`send_mailing`函数使用传递的任何内容吗？如果没有提供回调，它将默认使用当前版本。
- en: The relationship between arguments, keyword arguments, variable arguments, and
    variable keyword arguments can be a bit confusing. We saw how painfully they can
    interact when we covered multiple inheritance. Devise some other examples to see
    how they can work well together, as well as to understand when they don't.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 参数、关键字参数、可变参数和可变关键字参数之间的关系可能会有些令人困惑。我们在介绍多重继承时看到了它们如何痛苦地交互。设计一些其他示例来了解它们如何协同工作，以及了解它们何时不能协同工作。
- en: Summary
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We covered a grab bag of topics in this chapter. Each represented an important
    non-object-oriented feature that is popular in Python. Just because we can use
    object-oriented principles does not always mean we should!
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了一系列主题。每个主题都代表了一个在Python中流行的、重要的非面向对象特性。仅仅因为我们可以使用面向对象原则，并不意味着我们总是应该这样做！
- en: However, we also saw that Python typically implements such features by providing
    a syntax shortcut to traditional object-oriented syntax. Knowing the object-oriented
    principles underlying these tools allows us to use them more effectively in our
    own classes.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们也看到Python通常通过提供传统面向对象语法的语法快捷方式来实现这些功能。了解这些工具背后的面向对象原则使我们能够更有效地在我们的类中使用它们。
- en: We discussed a series of built-in functions and file I/O operations. There are
    a whole bunch of different syntaxes available to us when calling functions with
    arguments, keyword arguments, and variable argument lists. Context managers are
    useful for the common pattern of sandwiching a piece of code between two method
    calls. Even functions are objects, and, conversely, any normal object can be made
    callable.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了一系列内置函数和文件输入输出操作。当我们调用带有参数、关键字参数和可变参数列表的函数时，有大量的不同语法可供选择。上下文管理器对于在两个方法调用之间嵌入代码的常见模式非常有用。甚至函数也是对象，反之，任何普通对象都可以被赋予可调用性。
- en: 'In the next chapter, we''ll learn more about string and file manipulation,
    and even spend some time with one of the least object-oriented topics in the standard
    library: regular expressions.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习更多关于字符串和文件操作的知识，甚至还会花一些时间探讨标准库中最不面向对象的主题之一：正则表达式。
