<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis">
<head>
  <meta charset="UTF-8"/>
  <title>Automating Tests</title>
  <link type="text/css" rel="stylesheet" media="all" href="style.css"/>
  <link type="text/css" rel="stylesheet" media="all" href="core.css"/>
</head>
<body>
  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Automating Tests</h1>
                </header>
            
            <article>
                
<p class="chapter-content">In this chapter, we will add some automated testing to our RESTful Web Services and we will execute the tests within a test database. We won't cover all the tests that we should write for our complex RESTful Web Service. However, we will follow the first steps and we will gain an understanding of:</p>
<ul>
<li>Getting ready for unit testing with pytest</li>
<li>Writing unit tests for a RESTful Web Service</li>
<li>Discovering and running unit tests with pytest</li>
<li>Writing new unit tests to improve tests' code coverage</li>
<li>Running new unit tests</li>
</ul>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready for unit testing with pytest</h1>
                </header>
            
            <article>
                
<p class="chapter-content">So far, we have been writing code to add features to our RESTful Web Service and configuring many settings for the Django REST framework. We used command-line and GUI tools to understand how all the pieces worked together and to check the results of diverse HTTP requests. Now, we will write unit tests that will allow us to make sure that our RESTful Web Service will work as expected. Before we can start writing unit tests, it is necessary to install many additional packages in our virtual environment. Make sure you quit Django's development server. Remember that you just need to press <em>Ctrl</em> + <em>C</em> in the terminal or go to the Command Prompt window in which it is running. First, we will make some changes to work with a single version of our RESTful Web Service.</p>
<p class="chapter-content">This way, it will be easier to focus on tests for a single version in our examples. Replace the code in the <kbd>urls.py</kbd> file in the <kbd>restful01/restful01</kbd> folder, specifically, the <kbd>restful01/restful01/urls.py</kbd> file. The file defines the root URL configurations, and therefore, we want to include only the URL patterns for the first version of our web service. The code file for the sample is included in the <kbd>hillar_django_restful_10_01</kbd> folder, in the <kbd>restful01/restful01/urls.py</kbd> file:</p>
<pre>from django.conf.urls import url, include 
 
urlpatterns = [ 
    url(r'^', include('drones.urls')), 
    url(r'^api-auth/', include('rest_framework.urls')) <br/>]</pre>
<p class="chapter-content">We will install the following Python packages in our virtual environment:</p>
<ul>
<li><kbd>pytest</kbd>: This is a very popular Python unit test framework that makes testing easy and reduces boilerplate code</li>
<li><kbd>pytest-django</kbd>: This <kbd>pytest</kbd> plugin allows us to easily use and configure the features provided by <kbd>pytest</kbd> in our Django tests</li>
</ul>
<div class="packt_tip">Notice that we won't be working with Django's <kbd>manage.pytest</kbd> command. We will work with <kbd>pytest</kbd> instead. However, in case you don't want to work with <kbd>pytest</kbd>, most of the things you will learn can be easily adapted to any other test framework. In fact, the code is compatible with <kbd>nose</kbd> in case you decide to use the most common, yet a bit outdated, configuration for testing with the Django REST framework. Nowadays, <kbd>pytest</kbd> is the preferred unit test framework for Python.</div>
<p class="chapter-content">Run the following command to install the <kbd>pytest</kbd> package:</p>
<pre><strong>pip install pytest</strong></pre>
<p class="chapter-content">The last lines for the output will indicate that the <kbd>pytest</kbd> package and its required packages have been successfully installed:</p>
<pre><strong>Installing collected packages: attrs, pluggy, six, py, pytest</strong><strong>  Running setup.py install for pluggy ... done</strong><strong>Successfully installed attrs-17.3.0 pluggy-0.6.0 py-1.5.2 pytest-3.3.1 six-1.11.0</strong></pre>
<p class="chapter-content">We just need to run the following command to install the <kbd>pytest-django</kbd> package:</p>
<pre><strong>pip install pytest-django</strong></pre>
<p class="chapter-content">The last lines for the output will indicate that the <kbd>pytest-django</kbd> package has been successfully installed:</p>
<pre class="chapter-content"><strong>Installing collected packages: pytest-django</strong><br/><strong>Successfully installed pytest-django-3.1.2</strong></pre>
<p class="chapter-content">Now, go to the <kbd>restful01</kbd> folder that contains the <kbd>manage.py</kbd> file and create a new file named <kbd>pytest.ini</kbd>. Write the following code in this new file. The following lines show the code for this file that specifies the Django settings module (<kbd>restful01.settings</kbd>) and the pattern that <kbd>pytest</kbd> will use to locate the Python files, the declare tests. The code file for the sample is included in the <kbd>hillar_django_restful_10_01</kbd> folder in the <kbd>restful01/pytest.ini</kbd> file:</p>
<pre>[pytest] 
DJANGO_SETTINGS_MODULE = restful01.settings 
python_files = tests.py test_*.py *_tests.py </pre>
<p class="chapter-content">Whenever we execute pytest to run tests, the test runner will check the following to find test definitions:</p>
<ul>
<li>Python files named <kbd>tests.py</kbd></li>
<li>Python files whose name starts with the <kbd>test_</kbd> prefix</li>
<li>Python files whose name ends with the <kbd>_tests</kbd> suffix</li>
</ul>
<p class="chapter-content">In <a href="dj-rst-websvc_ch17.html">Chapter 9</a>,&#160;<em>Applying Throttling Rules and Versioning Management</em>, we configured throttling rules for our RESTful Web Service. We want to run our tests considering the throttling rules. In fact, we should write tests to make sure that the throttling rules are working OK. We will be running requests many times, and therefore, the low values we used for the throttling rules might complicate running all the requests required by our tests. Hence, we will increase the values for the throttling rules to simplify our testing samples. Open the <kbd>restful01/restful01/settings.py</kbd> file that declares module-level variables that define the configuration of Django for the <kbd>restful01</kbd> project. We will make some changes to this Django settings file. Replace the code for the highlighted lines included in the <kbd>REST_FRAMEWORK</kbd> dictionary. The following lines show the new declaration of the <kbd>REST_FRAMEWORK</kbd> dictionary. The code file for the sample is included in the <kbd>hillar_django_restful_10_01</kbd> folder in the <kbd>restful01/restful01/settings.py</kbd> file:</p>
<pre>REST_FRAMEWORK = { 
    'DEFAULT_PAGINATION_CLASS': 
    'drones.custompagination.LimitOffsetPaginationWithUpperBound', 
    'PAGE_SIZE': 4, 
    'DEFAULT_FILTER_BACKENDS': ( 
        'django_filters.rest_framework.DjangoFilterBackend', 
        'rest_framework.filters.OrderingFilter', 
        'rest_framework.filters.SearchFilter', 
        ), 
    'DEFAULT_AUTHENTICATION_CLASSES': ( 
        'rest_framework.authentication.BasicAuthentication', 
        'rest_framework.authentication.SessionAuthentication', 
        ), 
    'DEFAULT_THROTTLE_CLASSES': ( 
        'rest_framework.throttling.AnonRateThrottle', 
        'rest_framework.throttling.UserRateThrottle', 
    ), 
    <strong>'DEFAULT_THROTTLE_RATES': { 
        'anon': '300/hour', 
        'user': '100/hour', 
        'drones': '200/hour', 
        'pilots': '150/hour', 
    }</strong> 
} </pre>
<p class="chapter-content">We increased the number of requests per hour that we can execute in each of the throttling rates configurations. This way, we will be able to run our tests without issues.</p>
<div class="packt_tip">In this case, we are using the same settings file for our tests in order to avoid running additional steps and repeating test settings. However, in most cases, we would create a specific Django configuration file for testing.</div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Writing unit tests for a RESTful Web Service</h1>
                </header>
            
            <article>
                
<p>Now, we will write our first round of unit tests related to the drone category class based views: <kbd>DroneCategoryList</kbd> and <kbd>DroneCategoryDetail</kbd>. Open the existing <kbd>restful01/drones/tests.py</kbd> file and replace the existing code with the following lines that declare many <kbd>import</kbd> statements and the <kbd>DroneCategoryTests</kbd> class. The code file for the sample is included in the <kbd>hillar_django_restful_10_01</kbd> folder in the <kbd>restful01/drones/tests.py</kbd> file:</p>
<pre>from django.utils.http import urlencode 
from django.core.urlresolvers import reverse 
from rest_framework import status 
from rest_framework.test import APITestCase 
from drones.models import DroneCategory 
from drones import views 
 
 
class DroneCategoryTests(APITestCase): 
    <strong>def post_drone_category(self, name):</strong> 
        url = reverse(views.DroneCategoryList.name) 
        data = {'name': name} 
        response = self.client.post(url, data, format='json') 
        return response 
 
    <strong>def test_post_and_get_drone_category(self):</strong> 
        """ 
        Ensure we can create a new DroneCategory and then retrieve it 
        """ 
        new_drone_category_name = 'Hexacopter' 
        response = self.post_drone_category(new_drone_category_name) 
        print("PK {0}".format(DroneCategory.objects.get().pk)) 
        assert response.status_code == status.HTTP_201_CREATED 
        assert DroneCategory.objects.count() == 1 
        assert DroneCategory.objects.get().name == new_drone_category_name </pre>
<p>The <kbd>DroneCategoryTests</kbd> class is a subclass of the <kbd>rest_framework.test.APITestCase</kbd> superclass and declares the <kbd>post_drone_category</kbd> method that receives the desired <kbd>name</kbd> for the new drone category as an argument.</p>
<p>This method builds the URL and the data dictionary to compose and send an HTTP <kbd>POST</kbd> request to the view associated with the <kbd>views.DroneCategoryList.name</kbd> name (<kbd>dronecategory-list</kbd>) and returns the response generated by this request.</p>
<div class="packt_tip">The code uses the <kbd>self.client</kbd> attribute to access the <kbd>APIClient</kbd> instance that allows us to easily compose and send HTTP requests for testing our RESTful Web Service that uses the Django REST framework. For this test, the code calls the <kbd>post</kbd> method with the built <kbd>url</kbd>, the <kbd>data</kbd> dictionary, and the desired format for the data: <kbd>'json'</kbd>.</div>
<p>Many test methods will call the <kbd>post_drone_category</kbd> method to create a new drone category and then compose and send other HTTP requests to the RESTful Web Service. For example, we will need a drone category to post a new drone.</p>
<p>The <kbd>test_post_and_get_drone_category</kbd> method tests whether we can create a new <kbd>DroneCategory</kbd> and then retrieve it. The method calls the <kbd>post_drone_category</kbd> method and then calls <kbd>assert</kbd> many times to check for the following expected results:</p>
<ol>
<li>The <kbd>status_code</kbd> attribute for the response is equal to HTTP 201 Created (<kbd>status.HTTP_201_CREATED</kbd>)</li>
<li>The total number of <kbd>DroneCategory</kbd> objects retrieved from the database is <kbd>1</kbd></li>
<li>The value of the <kbd>name</kbd> attribute for the retrieved <kbd>DroneCategory</kbd> object is equal to the <kbd>new_drone_category_name</kbd> variable passed as a parameter to the <kbd>post_drone_category</kbd> method</li>
</ol>
<p>The previously coded tests make sure that we can create a new drone category with the RESTful Web Service, it is persisted in the database, and the serializer does its job as expected. The drone category is a very simple entity because it just has a primary key and a name. Now, we will add more test methods that will allow us to cover more scenarios related to drone categories.</p>
<p>Add the <kbd>test_post_existing_drone_category_name</kbd> method to the recently created <kbd>DroneCategoryTests</kbd> class in the <kbd>restful01/drones/tests.py</kbd> file. The code file for the sample is included in the <kbd>hillar_django_restful_10_01</kbd> folder in the <kbd>restful01/drones/tests.py</kbd> file:</p>
<pre>    def test_post_existing_drone_category_name(self): 
        """ 
        Ensure we cannot create a DroneCategory with an existing name 
        """ 
        url = reverse(views.DroneCategoryList.name) 
        new_drone_category_name = 'Duplicated Copter' 
        data = {'name': new_drone_category_name} 
        response1 = self.post_drone_category(new_drone_category_name) 
        assert response1.status_code == status.HTTP_201_CREATED 
        response2 = self.post_drone_category(new_drone_category_name) 
        print(response2) 
        assert response2.status_code == status.HTTP_400_BAD_REQUEST </pre>
<p>The new method tests whether the unique constraint for the drone category name works as expected and doesn't make it possible for us to create two drone categories with the same name. The second time we compose and send an HTTP <kbd>POST</kbd> request with a duplicate drone name, we must receive an HTTP <kbd>400 Bad Request</kbd> status code (<kbd>status.HTTP_400_BAD_REQUEST</kbd>).</p>
<p>Add the <kbd>test_filter_drone_category_by_name</kbd> method to the <kbd>DroneCategoryTests</kbd> class in the <kbd>restful01/drones/tests.py</kbd> file. The code file for the sample is included in the <kbd>hillar_django_restful_10_01</kbd> folder in the <kbd>restful01/drones/tests.py</kbd> file:</p>
<pre>    def test_filter_drone_category_by_name(self): 
        """ 
        Ensure we can filter a drone category by name 
        """ 
        drone_category_name1 = 'Hexacopter' 
        self.post_drone_category(drone_category_name1) 
        drone_caregory_name2 = 'Octocopter' 
        self.post_drone_category(drone_caregory_name2) 
        filter_by_name = { 'name' : drone_category_name1 } 
        url = '{0}?{1}'.format( 
            reverse(views.DroneCategoryList.name), 
            urlencode(filter_by_name)) 
        print(url) 
        response = self.client.get(url, format='json') 
        print(response) 
        <strong>assert response.status_code == status.HTTP_200_OK 
        # Make sure we receive only one element in the response 
        assert response.data['count'] == 1 
        assert response.data['results'][0]['name'] == <br/>        drone_category_name1</strong> </pre>
<p>The new method tests whether we can filter a drone category by name, and therefore, checks the usage of the filter field we have configured for the <kbd>DroneCategoryList</kbd> class-based view. The code creates two drone categories and then calls the <kbd>django.utils.http.urlencode</kbd> function to build an encoded URL from the <kbd>filter_by_name</kbd> dictionary. This dictionary includes the field name as a key and the desired string for the field as a value. In this case, <kbd>drone_category_name1</kbd> is equal to <kbd>'Hexacopter'</kbd>, and therefore, the encoded URL saved in the <kbd>url</kbd> variable will be <kbd>'name=Hexacopter'</kbd>.</p>
<p>After the call to <kbd>self.client.get</kbd> with the built URL to retrieve the filtered list of drone categories, the method verifies the data included in the response JSON body by inspecting the <kbd>data</kbd> attribute for the response. The second line that calls <kbd>assert</kbd> checks whether the value for <kbd>count</kbd> is equal to <kbd>1</kbd> and the next lines verify whether the <kbd>name</kbd> key for the first element in the <kbd>results</kbd> array is equal to the value hold in the <kbd>drone_category_name1</kbd> variable. The code is easy to read and understand.</p>
<p>Add the <kbd>test_get_drone_categories_collection</kbd> method to the <kbd>DroneCategoryTests</kbd> class in the <kbd>restful01/drones/tests.py</kbd> file. The code file for the sample is included in the <kbd>hillar_django_restful_10_01</kbd> folder in the <kbd>restful01/drones/tests.py</kbd> file:</p>
<pre>    def test_get_drone_categories_collection(self): 
        """ 
        Ensure we can retrieve the drone categories collection 
        """ 
        new_drone_category_name = 'Super Copter' 
        self.post_drone_category(new_drone_category_name) 
        url = reverse(views.DroneCategoryList.name) 
        response = self.client.get(url, format='json') 
        <strong>assert response.status_code == status.HTTP_200_OK 
        # Make sure we receive only one element in the response 
        assert response.data['count'] == 1 
        assert response.data['results'][0]['name'] == <br/>        new_drone_category_name </strong></pre>
<p>The method tests whether we can retrieve the drone categories collection. First, the code creates a new drone category and then makes an HTTP <kbd>GET</kbd> request to retrieve the drones collection. The lines that call <kbd>assert</kbd> check that the results include the only created and persisted drone and that its name is equal to the name used for the call to the <kbd>POST</kbd> method to create the new drone category.</p>
<p>Add the <kbd>test_update_drone_category</kbd> method to the <kbd>DroneCategoryTests</kbd> class in the <kbd>restful01/drones/tests.py</kbd> file. The code file for the sample is included in the <kbd>hillar_django_restful_10_01</kbd> folder in the <kbd>restful01/drones/tests.py</kbd> file:</p>
<pre>    def test_update_drone_category(self): 
        """ 
        Ensure we can update a single field for a drone category 
        """ 
        drone_category_name = 'Category Initial Name' 
        response = self.post_drone_category(drone_category_name) 
        url = reverse( 
            views.DroneCategoryDetail.name,  
            None,  
            {response.data['pk']}) 
        updated_drone_category_name = 'Updated Name' 
        data = {'name': updated_drone_category_name} 
        patch_response = self.client.patch(url, data, format='json') 
        <strong>assert patch_response.status_code == status.HTTP_200_OK 
        assert patch_response.data['name'] == <br/>        updated_drone_category_name</strong></pre>
<p>The new method tests whether we can update a single field for a drone category. First, the code creates a new drone category and then makes an HTTP <kbd>PATCH</kbd> request to update the name field for the previously persisted drone category. The lines that call <kbd>assert</kbd> check that the returned status code is <kbd>HTTP 200 OK</kbd> and that the value of the <kbd>name</kbd> key in the response body is equal to the new name that we specified in the HTTP <kbd>PATCH</kbd> request.</p>
<p>Add the <kbd>test_get_drone_category</kbd> method to the <kbd>DroneCategoryTests</kbd> class in the <kbd>restful01/drones/tests.py</kbd> file. The code file for the sample is included in the <kbd>hillar_django_restful_10_01</kbd> folder in the <kbd>restful01/drones/tests.py</kbd> file:</p>
<pre>    def test_get_drone_category(self): 
        """ 
        Ensure we can get a single drone category by id 
        """ 
        drone_category_name = 'Easy to retrieve' 
        response = self.post_drone_category(drone_category_name) 
        url = reverse( 
            views.DroneCategoryDetail.name,  
            None,  
            {response.data['pk']}) 
        get_response = self.client.get(url, format='json') 
        <strong>assert get_response.status_code == status.HTTP_200_OK 
        assert get_response.data['name'] == drone_category_name</strong> </pre>
<p>The new method tests whether we can retrieve a single category with an HTTP <kbd>GET</kbd> request. First, the code creates a new drone category and then makes an HTTP <kbd>GET</kbd> request to retrieve the previously persisted drone category. The lines that call <kbd>assert</kbd> check that the returned status code is <kbd>HTTP 200 OK</kbd> and that the value of the <kbd>name</kbd> key in the response body is equal to the name that we specified in the HTTP <kbd>POST</kbd> request that created the drone category.</p>
<p>Each test method that requires a specific condition in the database must execute all the necessary code to generate the required data. For example, in order to update the name for an existing drone category, it was necessary to create a new drone category before making the HTTP <kbd>PATCH</kbd> request to update it. Pytest and the Django REST framework will execute each test method without data from the previously executed test methods in the database, that is, each test will run with a database cleansed of data from the previous tests.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Discovering and running unit tests with pytest</h1>
                </header>
            
            <article>
                
<p>Now, go to the <kbd>restful01</kbd> folder that contains the <kbd>manage.py</kbd> file, with the virtual environment activated, and run the following command:</p>
<pre><strong>pytest</strong></pre>
<p>The <kbd>pytest</kbd> command and the Django REST framework will perform the following actions:</p>
<ol>
<li>Create a clean test database name <kbd>test_drones</kbd>.</li>
<li>Run all the migrations required for the database.</li>
<li>Discover the tests that have to be executed based on the settings specified in the <kbd>pytest.ini</kbd> file.</li>
<li>Run all the methods whose name starts with the <kbd>test_</kbd> prefix in the <kbd>DroneCategoryTests</kbd> class and display the results. We declared this class in the <kbd>tests.py</kbd> file and it matches the pattern specified for the <kbd>python_files</kbd> setting in the <kbd>pytest.ini</kbd> file.</li>
<li>Drop the test database named <kbd>test_drones</kbd>.</li>
</ol>
<div class="packt_tip">It is very important to know that the tests won't make changes to the database we have been using when working with our RESTful Web Service. Notice that the test database name is <kbd>test_drones</kbd> and the database name that we have been using with Django's development server is <kbd>drones</kbd>.</div>
<p>The following screenshot shows a sample output generated by the <kbd>pytest</kbd> command:</p>
<div class="CDPAlignCenter CDPAlign"><img height="150" width="500" src="images/6cc2cb23-d8d3-44a7-856e-86f7d770a77f.png"/></div>
<p>The output indicated that the test runner collected and executed six tests and all of them passed. However, the output didn't show the names of the tests that passed. Hence, we will run <kbd>pytest</kbd> again with the <kbd>-v</kbd> option to increase verbosity. Run the following command:</p>
<pre><strong>pytest -v</strong></pre>
<p>The following screenshot shows a sample output generated by the <kbd>pytest</kbd> command with the increased verbosity:</p>
<div class="CDPAlignCenter CDPAlign"><img height="195" width="437" src="images/158cd88e-eaef-4ad7-b999-28c4563d5bed.png"/></div>
<p>We enabled verbose mode, and therefore, the new output displayed the full test names. Pytest displays the following information for each discovered and executed test: the Python file that defines it, the class name, and the method, such as the following line:</p>
<pre><strong>drones/tests.py::DroneCategoryTests::test_filter_drone_category_by_name PASSED [16%]</strong></pre>
<p>The line indicates that the <kbd>test_filter_drone_category_by_name</kbd> test method declared in the <kbd>DroneCategoryTests</kbd> class, within the <kbd>drones/tests.py</kbd> module has been executed, passed, and its execution represents 16% of the discovered tests.</p>
<div class="packt_tip">The verbose mode makes it possible to know the specific tests that have been executed.</div>
<p>Some of the test methods include calls to the <kbd>print</kbd> function. By default, pytest captures both the&#160;<kbd>stdout</kbd> and <kbd>stderr</kbd> and only shows the captured content for the tests that fail. Sometimes, it is useful for us to see the results of calls to the <kbd>print</kbd> function while <kbd>pytest</kbd> runs the tests. We will run <kbd>pytest</kbd> again with <kbd>-s</kbd> option combined with the <kbd>-v</kbd> option to disable capturing and increase verbosity. Notice that the <kbd>-s</kbd> option is a shortcut that is equivalent to the <kbd>-capture=no</kbd> option. Run the following command:</p>
<pre><strong>pytest -vs</strong></pre>
<p>The following screenshot shows a sample output for the previous command:</p>
<div class="CDPAlignCenter CDPAlign"><img height="346" width="533" src="images/32a2544d-1693-4676-8db5-6e8b6bba9390.png"/></div>
<p>The new output displayed the results of each call to the <kbd>print</kbd> function. In addition, we will notice that there are two messages displayed that are printed by Django, one line before the first test runs and another line after the last test finishes its execution:</p>
<pre><strong>Creating test database for alias 'default'...</strong><strong>Destroying test database for alias 'default'...</strong></pre>
<p>These messages indicate that Django created the test database before running the first test and drops the database after all the tests have been executed.</p>
<p>The <kbd>test_filter_drone_category_by_name</kbd> test method declared in the <kbd>DroneCategoryTests</kbd> class has the following two calls to the <kbd>print</kbd> function:</p>
<pre>url = '{0}?{1}'.format( 
    reverse(views.DroneCategoryList.name), 
    urlencode(filter_by_name)) 
<strong>print(url)</strong> 
response = self.client.get(url, format='json') 
<strong>print(response) </strong></pre>
<p>The previous output shows the results of the two calls to the <kbd>print</kbd> function. First, the tests output display the value of the <kbd>url</kbd> variable with the composed URL and then the output shows the response of the call to <kbd>self.client.get</kbd> as a string:</p>
<pre><strong>drones/tests.py::DroneCategoryTests::test_filter_drone_category_by_name Creating test database for alias 'default'...</strong><strong>/drone-categories/?name=Hexacopter</strong><strong>&lt;Response status_code=200, "application/json"&gt;</strong><strong>PASSED     [ 16%]</strong></pre>
<p>In this case, the output is clear. However, as you might notice in the previous screenshot, the output generated by the other print statements is shown at the right-hand side of the test method name that was executed and it is not so clear. Hence, whenever we want to provide helpful output for tests, it is always a good idea to make sure we start with a new line (<kbd>'n'</kbd>) and provide some context for the output we are displaying.</p>
<p>Now, we will replace the line that calls the <kbd>print</kbd> function in the <kbd>test_post_and_get_drone_category</kbd> method for the <kbd>DroneCategoryTests</kbd> class in the <kbd>restful01/drones/tests.py</kbd> file. The code file for the sample is included in the <kbd>hillar_django_restful_10_02</kbd> folder in the <kbd>restful01/drones/tests.py</kbd> file. The replaced line is highlighted:</p>
<pre>    def test_post_and_get_drone_category(self): 
        """ 
        Ensure we can create a new DroneCategory and then retrieve it 
        """ 
        new_drone_category_name = 'Hexacopter' 
        response = self.post_drone_category(new_drone_category_name) 
        <strong>print("nPK {0}n".format(DroneCategory.objects.get().pk))</strong> 
        assert response.status_code == status.HTTP_201_CREATED 
        assert DroneCategory.objects.count() == 1 
        assert DroneCategory.objects.get().name == <br/>        new_drone_category_name </pre>
<p>Run the following command to execute pytest again with the <kbd>-s</kbd> and <kbd>-v</kbd> options combined:</p>
<pre><strong>pytest -vs</strong></pre>
<p>The following screenshot shows a sample output for the previous command:</p>
<div class="CDPAlignCenter CDPAlign"><img height="332" width="542" src="images/1260c896-8211-407c-8ba3-3bbe651a3f2d.png"/></div>
<p>The edits made in the call to the print statement that added a new line before and after the output made it easier to read the output. The generated output is highlighted in the previous screenshot. It is very important to take this formatting into account when working with <kbd>pytest</kbd>.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Writing new unit tests to improve the tests' code coverage</h1>
                </header>
            
            <article>
                
<p>Our first round of unit tests was related to the drone category class-based views: <kbd>DroneCategoryList</kbd> and <kbd>DroneCategoryDetail</kbd>. Now, we will write a second round of unit tests related to the pilot class-based views: <kbd>PilotList</kbd> and <kbd>PilotDetail</kbd>. The new tests will be a bit more complex because we will have to work with authenticated requests.</p>
<p>In <a href="dj-rst-websvc_ch17.html"><em>Chapter 8</em></a>, <em>Securing the API with Authentication and Permissions</em>, we configured authentication and permission policies for the class-based views that work with the <kbd>Pilot</kbd> model. We overrode the values for the <kbd>authentication_classes</kbd> and <kbd>permission_classes</kbd> class attributes for the <kbd>PilotDetail</kbd> and <kbd>PilotList</kbd> classes. In order to create, read, update, or delete pilots, we have to provide an authentication token. Hence, we will write tests to make sure that an unauthenticated request cannot perform operations related to pilots. In addition, we want to make sure that an authenticated request with a token can create a new pilot and then retrieve it.</p>
<p>Open the <kbd>restful01/drones/tests.py</kbd> file and add the following lines after the last line that declares the imports, before the declaration of the <kbd>DroneCategoryTests</kbd> class:</p>
<pre>from drones.models import Pilot 
from rest_framework.authtoken.models import Token 
from django.contrib.auth.models import User </pre>
<p>Add the following code to the existing <kbd>restful01/drones/tests.py</kbd> file to create the new <kbd>PilotTests</kbd> class. The code file for the sample is included in the <kbd>hillar_django_restful_10_02</kbd> folder in the <kbd>restful01/drones/tests.py</kbd> file:</p>
<pre>class PilotTests(APITestCase):    
    <strong>def post_pilot(self, name, gender, races_count):</strong> 
        url = reverse(views.PilotList.name) 
        print(url) 
        data = { 
            'name': name, 
            'gender': gender, 
            'races_count': races_count, 
            } 
        response = self.client.post(url, data, format='json') 
        return response 
 
    <strong>def create_user_and_set_token_credentials(self):</strong> 
        user = User.objects.create_user( 
            'user01', 'user01@example.com', 'user01P4ssw0rD') 
        token = Token.objects.create(user=user) 
        self.client.credentials( 
            HTTP_AUTHORIZATION='Token {0}'.format(token.key)) 
 
    <strong>def test_post_and_get_pilot(self):</strong> 
        """ 
        Ensure we can create a new Pilot and then retrieve it 
        Ensure we cannot retrieve the persisted pilot without a token 
        """ 
        self.create_user_and_set_token_credentials() 
        new_pilot_name = 'Gaston' 
        new_pilot_gender = Pilot.MALE 
        new_pilot_races_count = 5 
        response = self.post_pilot( 
            new_pilot_name, 
            new_pilot_gender, 
            new_pilot_races_count) 
        print("nPK {0}n".format(Pilot.objects.get().pk)) 
        assert response.status_code == status.HTTP_201_CREATED 
        assert Pilot.objects.count() == 1 
        saved_pilot = Pilot.objects.get() 
        assert saved_pilot.name == new_pilot_name 
        assert saved_pilot.gender == new_pilot_gender 
        assert saved_pilot.races_count == new_pilot_races_count 
        url = reverse( 
            views.PilotDetail.name,  
            None, 
            {saved_pilot.pk}) 
        authorized_get_response = self.client.get(url, format='json') 
        assert authorized_get_response.status_code == <br/>        status.HTTP_200_OK 
        assert authorized_get_response.data['name'] == new_pilot_name 
        # Clean up credentials 
        self.client.credentials() 
        unauthorized_get_response = self.client.get(url, format='json') 
        assert unauthorized_get_response.status_code == <br/>        status.HTTP_401_UNAUTHORIZED </pre>
<p>The <kbd>PilotTests</kbd> class is a subclass of the <kbd>rest_framework.test.APITestCase</kbd> superclass and declares the <kbd>post_pilot</kbd> method that receives the desired <kbd>name</kbd> and <kbd>gender</kbd> for the new pilot as arguments.</p>
<p>This method builds the URL and the data dictionary to compose and send an HTTP <kbd>POST</kbd> request to the view associated with the <kbd>views.PilotList.name</kbd> name (<kbd>pilot-list</kbd>) and returns the response generated by this request.</p>
<p>Many test methods will call the <kbd>post_pilot</kbd> method to create a new pilot and then compose and send other HTTP requests to the RESTful Web Service. Notice that the <kbd>post_pilot</kbd> method doesn't configure authentication credentials, and therefore, we will be able to call this method for unauthenticated or authenticated users. We already know that unauthenticated users shouldn't be able to post a pilot, and a test will call this method without a token and make sure no pilot is persisted in the database.</p>
<p>The <kbd>create_user_and_set_token_credentials</kbd> method executes the following actions:</p>
<ul>
<li>Creates a Django user with a call to the <kbd>User.objects.create_user</kbd> method.</li>
<li>Creates a token for the previously created Django user with a call to the <kbd>Token.objects.create</kbd> method.</li>
<li>Includes the token generated for the Django user as the value for the <kbd>Authorization</kbd> HTTP header key with the <kbd>'Token '</kbd> string as a prefix for the token. The last line calls the <kbd>self.client.credentials</kbd> method to set the generated HTTP header as the value for the <kbd>HTTP_AUTHORIZATION</kbd> named argument.</li>
</ul>
<div class="packt_tip">Remember that the <kbd>self.client</kbd> attribute allows us to access the <kbd>APIClient</kbd> instance.</div>
<p>Whenever a test wants to perform an HTTP request with a token, the code will call the <kbd>create_user_and_set_token_credentials</kbd> method. In order to clean up the credentials configured for the <kbd>APIClient</kbd> instance saved in <kbd>self.client</kbd>, it is necessary to call the <kbd>self.client.credentials()</kbd> method without arguments.</p>
<p>The <kbd>test_post_and_get_pilot</kbd> method tests the following path:</p>
<ol>
<li>We can create a new <kbd>Pilot</kbd> with an HTTP <kbd>POST</kbd> request that has an appropriate authentication token</li>
<li>We can retrieve the recently created <kbd>Pilot</kbd> with an HTTP <kbd>GET</kbd> request that has an appropriate authentication token</li>
<li>We cannot retrieve the recently created <kbd>Pilot</kbd> with an unauthenticated HTTP <kbd>GET</kbd> request</li>
</ol>
<p>The code calls the <kbd>create_user_and_set_token_credentials</kbd> method and then calls the <kbd>post_pilot</kbd> method. Then, the code calls <kbd>assert</kbd> many times to check for the following expected results:</p>
<ol>
<li>The <kbd>status_code</kbd> attribute for the response is equal to HTTP 201 Created (<kbd>status.HTTP_201_CREATED</kbd>)</li>
<li>The total number of <kbd>Pilot</kbd> objects retrieved from the database is <kbd>1</kbd></li>
</ol>
<ol start="3">
<li>The value of the <kbd>name</kbd>, <kbd>gender</kbd>, and <kbd>races_count</kbd> attributes for the retrieved <kbd>Pilot</kbd> object is equal to the values passed as parameters to the <kbd>post_pilot</kbd> method</li>
</ol>
<p>Then, the code calls the <kbd>self.client.get</kbd> with the built URL to retrieve the previously persisted pilot. This request will use the same credentials applied to the HTTP <kbd>POST</kbd> request, and therefore, the new request is authenticated by a valid token. The method verifies the data included in the response JSON body by inspecting the <kbd>data</kbd> attribute for the response. The code calls <kbd>assert</kbd> twice to check for the following expected results:</p>
<ol>
<li>The <kbd>status_code</kbd> attribute for the response is equal to HTTP 201 Created (<kbd>status.HTTP_201_CREATED</kbd>)</li>
<li>The value of the <kbd>name</kbd> key in the response body is equal to the <kbd>name</kbd> that we specified in the HTTP <kbd>POST</kbd> request</li>
</ol>
<p>Then, the code calls the <kbd>self.client.credentials</kbd> method without arguments to clean up the credentials and calls the <kbd>self.client.get</kbd> method again with the same built URL, this time, without a token. Finally, the code calls assert to check that the status_code attribute for the response is equal to HTTP 401 Unauthorized (<kbd>status.HTTP_401_UNAUTHORIZED</kbd>).</p>
<p>The previously coded test makes sure that we can create a new pilot with the RESTful Web Service and the appropriate authentication requirement we configured, the pilot is persisted in the database, and the serializer does its job as expected. In addition, unauthenticated users aren't able to access a pilot.</p>
<p>Add the <kbd>test_try_to_post_pilot_without_token</kbd> method to the recently created <kbd>DroneCategoryTests</kbd> class in the <kbd>restful01/drones/tests.py</kbd> file. The code file for the sample is included in the <kbd>hillar_django_restful_10_02</kbd> folder in the <kbd>restful01/drones/tests.py</kbd> file:</p>
<pre>    def test_try_to_post_pilot_without_token(self): 
        """ 
        Ensure we cannot create a pilot without a token 
        """ 
        new_pilot_name = 'Unauthorized Pilot' 
        new_pilot_gender = Pilot.MALE 
        new_pilot_races_count = 5 
        response = self.post_pilot( 
            new_pilot_name, 
            new_pilot_gender, 
            new_pilot_races_count) 
        print(response) 
        print(Pilot.objects.count()) 
        assert response.status_code == status.HTTP_401_UNAUTHORIZED 
        assert Pilot.objects.count() == 0</pre>
<p>The new method tests that the combination of permission and authentication classes configured for the <kbd>PilotList</kbd> class doesn't make it possible for an unauthenticated HTTP <kbd>POST</kbd> request to create a pilot. The code calls the <kbd>post_pilot</kbd> method without configuring any credentials, and therefore the request runs without authentication. Then, the code calls <kbd>assert</kbd> twice to check for the following expected results:</p>
<ol>
<li>The <kbd>status_code</kbd> attribute for the response is equal to HTTP 401 Unauthorized (<kbd>status.HTTP_401_UNAUTHORIZED</kbd>)</li>
<li>The total number of <kbd>Pilot</kbd> objects retrieved from the database is <kbd>0</kbd> because the received data to create a new pilot wasn't processed</li>
</ol>
<p>We have increased the scenarios covered by our tests. We should write more tests related to pilots. However, with all the examples provided, you will have the necessary information to write all the tests required to make sure that each new version of a RESTful Web Service developed with Django and the Django REST framework works as expected.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Running unit tests again with pytest</h1>
                </header>
            
            <article>
                
<p>Now, go to the <kbd>restful01</kbd> folder that contains the <kbd>manage.py</kbd> file, with the virtual environment activated, and run the following command to execute <kbd>pytest</kbd> again with the <kbd>-v</kbd> option to increase verbosity:</p>
<pre><strong>pytest -v</strong></pre>
<p>In this case, pytest will run all the methods whose name starts with the <kbd>test_</kbd> prefix in both the <kbd>DroneCategoryTests</kbd> and <kbd>PilotTests</kbd> classes and display the results.</p>
<p>The following screenshot shows a sample output generated for the new execution of the <kbd>pytest</kbd> command with the increased verbosity:</p>
<div class="CDPAlignCenter CDPAlign"><img height="243" width="483" src="images/e539bf0a-53d0-45f4-8402-5f08dc821699.png"/></div>
<p>We enabled verbose mode again, and therefore, the output displayed the full test names that the <kbd>test_post_and_get_pilot</kbd> and <kbd>test_try_to_post_pilot_without_token test methods</kbd> passed.</p>
<p>We should continue writing tests related to pilots, drone categories, drones,&#160;and competitions. It is extremely important that we cover all the scenarios for our RESTful Web Service. Automated tests will make it possible for us to make sure that each new version of our RESTful Web Service will work as expected after it is deployed to production.</p>
<p>We built RESTful Web Services with Django, the Django REST framework, and Python 3.6. We learned to design a RESTful Web Service from scratch, starting with the requirements, and to run some of the necessary tests to make sure our web service runs as expected. We learned to work with different command-line and GUI tools to make our development tests easy. We understood many features included in the Django REST framework and how to configure them.</p>
<p>Now, we are ready to create RESTful Web Services with Django and the Django REST framework. We will definitely need to dive deep into additional features, packages, and configurations. We definitely have a great baseline to develop our next RESTful Web Service with the most versatile programming language: Python.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Test your knowledge</h1>
                </header>
            
            <article>
                
<p>Let's see whether you can answer the following questions correctly.</p>
<ol>
<li>In a subclass of <kbd>APITestCase</kbd>, <kbd>self.client</kbd> is:
<ol>
<li>The <kbd>APITestCase</kbd> instance that allows us to easily compose and send HTTP requests for testing</li>
<li>The <kbd>APITestClient</kbd> instance that allows us to easily compose and send HTTP requests for testing</li>
<li>The <kbd>APIClient</kbd> instance that allows us to easily compose and send HTTP requests for testing</li>
</ol>
</li>
<li>Which of the following lines clean up the credentials of a method within a subclass of <kbd>APITestCase</kbd>?
<ol>
<li><kbd>self.client.credentials()</kbd></li>
<li><kbd>self.client.clean_credentials()</kbd></li>
<li><kbd>self.client.credentials = {}</kbd></li>
</ol>
</li>
<li>Which of the following methods for <kbd>self.client</kbd> in a method within a subclass of <kbd>APITestCase</kbd> allows us to make an HTTP POST request?
<ol>
<li><kbd>http_post</kbd></li>
<li><kbd>make_http_post_request</kbd></li>
<li><kbd>post</kbd></li>
</ol>
</li>
<li>Which of the following methods for self.client in a method within a subclass of <kbd>APITestCase</kbd> allows us to make an HTTP GET request?
<ol>
<li><kbd>http_get</kbd></li>
<li><kbd>make_http_get_request</kbd></li>
<li><kbd>get</kbd></li>
</ol>
</li>
<li>Which of the following methods for <kbd>self.client</kbd> in a method within a subclass of <kbd>APITestCase</kbd> allows us to make an HTTP PATCH request?
<ol>
<li><kbd>http_patch</kbd></li>
<li><kbd>make_http_patch_request</kbd></li>
<li><kbd>patch</kbd></li>
</ol>
</li>
</ol>
<p>&#160;</p>
<p><span>The rights answers are included in the <a href="https://cdp.packtpub.com/django_restful_web_services__/wp-admin/post.php?post=44&amp;action=edit#post_454" target="_blank">Appendix</a>,&#160;<em>Solutions</em>.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we learned to write unit tests for our RESTful Web Service. We installed the necessary packages and made the appropriate configurations to work with the modern and popular pytest unit test framework. Then, we wrote our first round of unit tests for the RESTful Web Service related to different scenarios with drone categories.</p>
<p>We worked with the different options for the pytest command to discover and run unit tests in the default mode, the increase verbosity mode, and the disable capture mode. We understood how to combine pytest with the testing classed provided by the Django REST framework.</p>
<p>Finally, we wrote additional unit tests for the RESTful Web Service related to different scenarios with pilots and the token authentication requirements for specific requests. We are able to continue adding tests for our RESTful Web Service with all the things we have learned.</p>
<p>Now, it is your turn. You can start developing RESTful Web Services with Django,&#160; Django REST framework, and Python 3.6.</p>


            </article>

            
        </section>
    </div>
</body>
</html>