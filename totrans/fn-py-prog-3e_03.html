<html><head></head><body>
<section id="chapter-3-functions-iterators-and-generators" class="level2 chapterHead" data-number="0.7">&#13;
<h2 class="chapterHead" data-number="0.7"><span class="titlemark"> 3</span><br/>&#13;
<span id="x1-510003"/>Functions, Iterators, and Generators</h2>&#13;
<p>The core of functional programming is the use of pure functions to map values from the input domain to the output range. Avoiding side effects reduces any dependence on variable assignment to maintain the state of a computation. We can’t purge the assignment statement from the Python language, but we can reduce our dependence on stateful objects. This means choosing among the available Python built-in functions and data structures to select those that don’t require stateful operations.</p>&#13;
<p>This chapter will present several Python features from a functional viewpoint, as follows:</p>&#13;
<ul>&#13;
<li><p>Pure functions, free of side effects</p></li>&#13;
<li><p>Functions as objects that can be passed as arguments or returned as results</p></li>&#13;
<li><p>The use of Python’s object-oriented suffix notation and prefix notation</p></li>&#13;
<li><p>Using tuples as a way to create immutable objects, which avoid the confusion of state changes</p></li>&#13;
<li><p>Using iterable collections as our primary design tool for functional programming</p></li>&#13;
</ul>&#13;
<p>We’ll look at generators and generator expressions, since these are ways to work with collections of objects. As we noted in <a href="Chapter_02.xhtml#x1-340002"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 2</span></a>, <a href="Chapter_02.xhtml#x1-340002"><span class="cmti-10x-x-109">Introducing Essential</span> <span class="cmti-10x-x-109">Functional Concepts</span></a>, there are some boundary issues when trying to replace all generator expressions with recursions. Python imposes a recursion limit and doesn’t automatically handle <span class="keyWord">Tail-Call Optimization </span>(<span class="keyWord">TCO</span>): we must optimize recursions manually using a generator expression.</p>&#13;
<p>We’ll write generator expressions that will perform the following tasks:</p>&#13;
<ul>&#13;
<li><p>Conversions</p></li>&#13;
<li><p>Restructuring</p></li>&#13;
<li><p>Complex calculations</p></li>&#13;
</ul>&#13;
<p>We’ll take a quick survey of many of the built-in Python collections and how we can work with collections while pursuing a functional paradigm. This may change our approach to working with lists, dicts, and sets. Writing functional Python encourages us to focus on tuples and immutable collections. In the next chapter, we’ll emphasize more functional ways to work with specific kinds of collections. <span id="x1-51001r49"/></p>&#13;
<section id="writing-pure-functions" class="level3 sectionHead" data-number="0.7.1">&#13;
<h3 class="sectionHead" data-number="0.7.1"><span class="titlemark">3.1 </span> <span id="x1-520001"/>Writing pure functions</h3>&#13;
<p>In <a href="Chapter_02.xhtml#x1-340002"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 2</span></a>, <a href="Chapter_02.xhtml#x1-340002"><span class="cmti-10x-x-109">Introducing Essential Functional Concepts</span></a>, we looked at pure functions. In this section, we’ll look at a common problem with non-functional programming: a function that has a reference to a global variable. When a global variable is assigned, the <span class="obeylines-h"><span class="verb"><code class="inlineCode">global</code></span></span> statement will be used. When a global variable is read, however, this is called a <span class="keyWord">free variable</span>,<span id="dx1-52001"/> and there’s no obvious marker in the Python code.</p>&#13;
<p>Any references to values in the Python global namespace (using a free variable) is something we can rework into a proper parameter. In most cases, it’s quite easy. Here is an example that depends on a free variable:</p>&#13;
<pre id="listing-24" class="lstlisting"><code>global_adjustment: float &#13;
 &#13;
def some_function(a: float, b: float, t: float) -&gt; float: &#13;
    return a+b*t+global_adjustment</code></pre>&#13;
<p>After refactoring the function, we would need to change each reference to this function. This may have a ripple effect through a complex application. We’ll leave the refactoring as an exercise.</p>&#13;
<p>There are many internal Python objects that are stateful. Objects used for input and output are generally called file objects or file-like objects; these are examples of stateful objects in common use. See the <span class="obeylines-h"><span class="verb"><code class="inlineCode">io</code></span></span> module for more information on file objects. We observe that some of the commonly used stateful objects in Python generally behave as context managers. In a few cases, stateful objects don’t completely implement the context manager interface; in these cases, there’s often a <span class="obeylines-h"><span class="verb"><code class="inlineCode">close()</code></span></span> method. We can use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">contextlib.closing()</code></span></span> function to provide these objects with the proper context manager interface.</p>&#13;
<p>A context manager provides a way to perform operations on entry to and exit from a block of code. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">with</code></span></span> statement uses a context manager to perform the entry operation, execute the indented block of code, and perform the exit operation. It’s important to note the exit operation is <span class="cmti-10x-x-109">always</span> performed, even if an exception is raised in the indented block of code. This makes for a tidy way to perform state-changing operations, making the code easier to reason about. In practice, it looks like the following example:</p>&#13;
<pre id="listing-25" class="lstlisting"><code>from pathlib import Path &#13;
 &#13;
def write_file(some_path: Path) -&gt; None: &#13;
    result = "Hello, world!" &#13;
    with some_path.open(’w’) as output_file: &#13;
        output_file.write(result + "\n")</code></pre>&#13;
<p>The file is only open for writing inside the <span class="obeylines-h"><span class="verb"><code class="inlineCode">with</code></span></span> statement. This makes it easier to see where state-changing operations are performed.</p>&#13;
<p>We can’t easily eliminate all stateful Python objects. Therefore, we must strike a balance between managing state while still exploiting the strengths of functional design. To this end, we should always use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">with</code></span></span> statement to encapsulate stateful file objects into a well-defined scope.</p>&#13;
<div id="tcolobox-30" class="packt_tip">&#13;
&#13;
&#13;
<p>Always use file objects in a <span class="obeylines-h"><span class="verb"><code class="inlineCode">with</code></span></span> context. This defines a context in which state-changing operations will be performed.</p>&#13;
&#13;
</div>&#13;
<p>We should always avoid global file objects, global database connections, and the associated stateful object issues. A global file object is a common pattern for handling open files or databases. We may have a function as shown in the following example:</p>&#13;
<pre id="listing-26" class="lstlisting"><code>from typing import TextIO &#13;
ifile: TextIO &#13;
ofile: TextIO &#13;
 &#13;
def open_files(iname: str, oname: str) -&gt; None: &#13;
    """A bad idea...""" &#13;
    global ifile, ofile &#13;
    ifile = open(iname, "r") &#13;
    ofile = open(oname, "w")</code></pre>&#13;
<p>This function creates an easily overlooked pair of global variables. Other functions can use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">ifile</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">ofile</code></span></span> variables, hoping they properly refer to the global files, which are left open and will endure a difficult-to-understand series of state changes.</p>&#13;
<p>This is not a very functional design, and we need to avoid it. The files should be proper parameters to functions, and the open files should be nested in a <span class="obeylines-h"><span class="verb"><code class="inlineCode">with</code></span></span> statement to ensure that their stateful behavior is handled properly. This is an important rewrite to change these variables from globals to formal parameters: it makes the file operations more visible.</p>&#13;
<p>The rewrite will involve locating every function using <span class="obeylines-h"><span class="verb"><code class="inlineCode">ifile</code></span></span> or <span class="obeylines-h"><span class="verb"><code class="inlineCode">ofile</code></span></span> as free variables. For example, we might have a function like the following:</p>&#13;
<pre id="listing-27" class="lstlisting"><code>def next_line_with(prefix: str) -&gt; str | None: &#13;
    """Also a bad idea...""" &#13;
    line = ifile.readline() &#13;
    while (line is not None and not line.startswith(prefix)): &#13;
        line = ifile.readline() &#13;
    return line</code></pre>&#13;
<p>We’ll need to make the <span class="obeylines-h"><span class="verb"><code class="inlineCode">ifile</code></span></span> global variable reference into a parameter to this function. This will create ripples of change to the functions that call <span class="obeylines-h"><span class="verb"><code class="inlineCode">next_line_with()</code></span></span>. This can become an extensive rewrite to identify and localize the state changes. This may lead to rethinking the design to replace a function like <span class="obeylines-h"><span class="verb"><code class="inlineCode">next_line_with()</code></span></span>.</p>&#13;
<p>This context manager design pattern also applies to databases. A database connection object should generally be provided as a formal argument to an application’s functions. This is contrary to the way some popular web frameworks work: some frameworks rely on a global database connection in an effort to make the database a transparent feature of the application. This transparency obscures a dependency between a web operation and the database; it can make unit testing more complex than necessary. Additionally, a multithreaded web server may not benefit from sharing a single database connection: a connection pool is often better. This suggests that there are some benefits of a hybrid approach that uses functional design with a few isolated stateful features. <span id="x1-52027r55"/></p>&#13;
</section>&#13;
<section id="functions-as-first-class-objects-1" class="level3 sectionHead" data-number="0.7.2">&#13;
<h3 class="sectionHead" data-number="0.7.2"><span class="titlemark">3.2 </span> <span id="x1-530002"/>Functions as first-class objects</h3>&#13;
<p>In <a href="Chapter_02.xhtml#x1-340002"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 2</span></a>, <a href="Chapter_02.xhtml#x1-340002"><span class="cmti-10x-x-109">Introducing Essential Functional Concepts</span></a>, we looked at ways in which Python functions are first-class objects. In Python, function objects have a number of attributes. The reference<span id="dx1-53001"/> manual lists a number of special member names that apply to functions. Since functions are objects with attributes, we can extract the docstring or the name of a function, using special attributes such as <span class="obeylines-h"><span class="verb"><code class="inlineCode">__doc__</code></span></span> or <span class="obeylines-h"><span class="verb"><code class="inlineCode">__name__</code></span></span>. We can also extract the body of the function through the <span class="obeylines-h"><span class="verb"><code class="inlineCode">__code__</code></span></span> attribute. In compiled languages, this introspection can be either impossible or quite complicated.</p>&#13;
<p>Additionally, a callable object helps us to create functions. We can consider the callable class definition as a higher-order function. We do need to be judicious in how we use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">__init__()</code></span></span> method of a callable object; we should avoid setting stateful class variables. One common application is to use an <span class="obeylines-h"><span class="verb"><code class="inlineCode">__init__()</code></span></span> method to create objects that fit the <span class="keyWord">Strategy </span>design<span id="dx1-53002"/> pattern.</p>&#13;
<p>A class following the Strategy design pattern depends on other objects to provide an algorithm or parts of an algorithm. This allows us to inject algorithmic details at runtime, rather than compiling the details into the class.</p>&#13;
<p>To focus on the overall design<span id="dx1-53003"/> principles, we’ll look at a function that does a tiny computation. This computes one of the Mersenne prime numbers. See <a href="https://www.mersenne.org/primes/" class="url">https://www.mersenne.org/primes/</a> for ongoing research into this topic.</p>&#13;
<p>Here is an example of the definition of a callable object class with an embedded Strategy object:</p>&#13;
<pre id="listing-28" class="lstlisting"><code>from collections.abc import Callable &#13;
 &#13;
class Mersenne1: &#13;
 &#13;
    def __init__( &#13;
            self, &#13;
            algorithm : Callable[[int], int] &#13;
    ) -&gt; None: &#13;
        self.pow2 = algorithm &#13;
 &#13;
    def __call__(self, arg: int) -&gt; int: &#13;
        return self.pow2(arg) - 1</code></pre>&#13;
<p>This class uses <span class="obeylines-h"><span class="verb"><code class="inlineCode">__init__()</code></span></span> to save a reference to another function, <span class="obeylines-h"><span class="verb"><code class="inlineCode">algorithm</code></span></span>, as <span class="obeylines-h"><span class="verb"><code class="inlineCode">self.pow2</code></span></span>. We’re not creating any stateful instance variables; the value of <span class="obeylines-h"><span class="verb"><code class="inlineCode">self.pow2</code></span></span> isn’t expected to change. It’s a common practice to use a name like <span class="obeylines-h"><span class="verb"><code class="inlineCode">_pow2</code></span></span> to suggest this attribute isn’t expected to be used by a client of this class. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">algorithm</code></span></span> parameter has a type hint of <span class="obeylines-h"><span class="verb"><code class="inlineCode">Callable[[int],</code><code class="inlineCode"> int]</code></span></span>, which describes a function that takes an integer argument and returns an integer value.</p>&#13;
<div id="tcolobox-31" class="infobox note">&#13;
&#13;
&#13;
<p>We’ve used the <span class="obeylines-h"><span class="verb"><code class="inlineCode">Callable</code></span></span> type hint from the <span class="obeylines-h"><span class="verb"><code class="inlineCode">collections.abc</code></span></span> module, where it is defined. An alias is available in the <span class="obeylines-h"><span class="verb"><code class="inlineCode">typing</code></span></span> module, but since PEP 585 was implemented, the use of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">typing.Callable</code></span></span> is deprecated. We’ll use a number of generic types from the <span class="obeylines-h"><span class="verb"><code class="inlineCode">collections.abc</code></span></span> module throughout this chapter.</p>&#13;
&#13;
</div>&#13;
<p>The function given as a Strategy<span id="dx1-53016"/> object must raise 2 to the given power. We can plug in any function that performs this computation. Three candidate<span id="dx1-53017"/> objects that we can plug into this class are as follows:</p>&#13;
<pre id="listing-29" class="lstlisting"><code>def shifty(b: int) -&gt; int: &#13;
    return 1 &lt;&lt; b &#13;
 &#13;
def multy(b: int) -&gt; int: &#13;
    if b == 0: return 1 &#13;
    return 2 * multy(b - 1) &#13;
 &#13;
def faster(b: int) -&gt; int: &#13;
    if b == 0: return 1 &#13;
    if b % 2 == 1: return 2 * faster(b-1) &#13;
    t = faster(b // 2) &#13;
    return t * t</code></pre>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">shifty()</code></span></span> function raises 2 to the desired power using a left shift of the bits. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">multy()</code></span></span> function uses a naive recursive multiplication. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">faster()</code></span></span> function uses a <span class="keyWord">divide and conquer </span>strategy<span id="dx1-53030"/> that will perform log <sub><span class="cmr-8">2</span></sub>(<span class="italic">b</span>) multiplications instead of <span class="italic">b </span>multiplications.</p>&#13;
<p>All three of these functions have identical function signatures. Each of them can be summarized as <span class="obeylines-h"><span class="verb"><code class="inlineCode">Callable[[int],</code><code class="inlineCode"> int]</code></span></span>, which matches the parameter, <span class="obeylines-h"><span class="verb"><code class="inlineCode">algorithm</code></span></span>, of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">Mersenne1.__init__()</code></span></span> method.</p>&#13;
<p>We can create instances of our <span class="obeylines-h"><span class="verb"><code class="inlineCode">Mersenne1</code></span></span> class with an embedded Strategy algorithm, as follows:</p>&#13;
<pre id="listing-30" class="lstlisting"><code>m1s = Mersenne1(shifty) &#13;
 &#13;
m1m = Mersenne1(multy) &#13;
 &#13;
m1f = Mersenne1(faster)</code></pre>&#13;
<p>Each of the resulting<span id="dx1-53036"/> functions, <span class="obeylines-h"><span class="verb"><code class="inlineCode">m1s()</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">m1m()</code></span></span>, and <span class="obeylines-h"><span class="verb"><code class="inlineCode">m1f()</code></span></span>, is built from another function. The functions <span class="obeylines-h"><span class="verb"><code class="inlineCode">shifty()</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">multy()</code></span></span>, and <span class="obeylines-h"><span class="verb"><code class="inlineCode">faster()</code></span></span> are incorporated into resulting functions. This shows how we can define alternative<span id="dx1-53037"/> functions that produce the same result but use different algorithms.</p>&#13;
<p>The callable objects created by this class behave as ordinary Python functions, as shown in the following example:</p>&#13;
<div id="tcolobox-32" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; m1s(17) &#13;
131071 &#13;
&gt;&gt;&gt; m1f(89) &#13;
618970019642690137449562111</code></pre>&#13;
&#13;
</div>&#13;
<div id="tcolobox-33" class="packt_tip">&#13;
&#13;
&#13;
<p>Python allows us to compute <span class="italic">M</span><sub><span class="cmr-8">89</span></sub> = 2<sup><span class="cmr-8">89</span></sup> <span class="cmsy-10x-x-109">− </span>1, since this doesn’t even come close to the recursion limits in Python. This is quite a large prime number, as it has 27 digits. In order to exceed the limits of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">multy()</code></span></span> function, we’d have to ask for the value of <span class="italic">M</span><sub><span class="cmr-8">1</span><span class="cmmi-8">,</span><span class="cmr-8">279</span></sub>, a number with 386 digits.</p>&#13;
&#13;
</div>&#13;
<p><span id="x1-53043r56"/></p>&#13;
</section>&#13;
<section id="using-strings" class="level3 sectionHead" data-number="0.7.3">&#13;
<h3 class="sectionHead" data-number="0.7.3"><span class="titlemark">3.3 </span> <span id="x1-540003"/>Using strings</h3>&#13;
<p>Since Python strings<span id="dx1-54001"/> are immutable, they’re an excellent example of functional programming objects. A Python <span class="obeylines-h"><span class="verb"><code class="inlineCode">str</code></span></span> object has a number of methods, all of which produce a new string as the result. These methods are pure functions with no side effects.</p>&#13;
<p>The syntax for methods is postfix, where most functions are prefix. This mixture of syntax styles means complex string operations can be hard to read when they’re co-mingled with conventional functions. For example, in this expression, <span class="obeylines-h"><span class="verb"><code class="inlineCode">len(variable.title())</code></span></span>, the <span class="obeylines-h"><span class="verb"><code class="inlineCode">title()</code></span></span> method is in postfix notation and the <span class="obeylines-h"><span class="verb"><code class="inlineCode">len()</code></span></span> function is in prefix notation. (We touched on this in <a href="Chapter_02.xhtml#x1-340002"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 2</span></a>, <a href="Chapter_02.xhtml#x1-340002"><span class="cmti-10x-x-109">Introducing Essential Functional Concepts</span></a>, in the <a href="Chapter_02.xhtml#x1-430007"><span class="cmti-10x-x-109">Familiar territory</span></a> section.)</p>&#13;
<p>When scraping<span id="dx1-54002"/> data from a web page, we may have a function to clean the data. This could apply a number of transformations to a string to clean up the punctuation and return a <span class="obeylines-h"><span class="verb"><code class="inlineCode">Decimal</code></span></span> object for use by the rest of the application. This will involve a mixture of prefix and postfix syntax.</p>&#13;
<p>It could look like the following code snippet:</p>&#13;
<pre id="listing-31" class="lstlisting"><code>from decimal import Decimal &#13;
 &#13;
def clean_decimal(text: str | None) -&gt; Decimal | None: &#13;
    if text is None: return None &#13;
    return Decimal( &#13;
        text.replace("$", "").replace(",", "") &#13;
    )</code></pre>&#13;
<p>This function does two replacements on the string to remove <span class="obeylines-h"><span class="verb"><code class="inlineCode">$</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">,</code></span></span> string values. The resulting string is used as an argument to the <span class="obeylines-h"><span class="verb"><code class="inlineCode">Decimal</code></span></span> class constructor, which returns the desired object. If the input value is <span class="obeylines-h"><span class="verb"><code class="inlineCode">None</code></span></span>, this is preserved; this is why the <span class="obeylines-h"><span class="verb"><code class="inlineCode">str</code><code class="inlineCode"> |</code><code class="inlineCode"> None</code></span></span> type hint is used.</p>&#13;
<p>To make the syntax look more consistent, we can consider defining our own prefix functions for the string methods, as follows:</p>&#13;
<pre id="listing-32" class="lstlisting"><code>def replace(text: str, a: str, b: str) -&gt; str: &#13;
    return text.replace(a, b)</code></pre>&#13;
<p>This can allow us to use <span class="obeylines-h"><span class="verb"><code class="inlineCode">Decimal(replace(replace(text,</code><code class="inlineCode"> "$",</code><code class="inlineCode"> ""),</code><code class="inlineCode"> ",",</code><code class="inlineCode"> ""))</code></span></span> with consistent-looking prefix syntax. It’s not clear whether this kind of consistency is a significant improvement over the mixed prefix and postfix notation. This may be an example of a foolish consistency.</p>&#13;
<p>A slightly better approach may be to define a more meaningful prefix function to strip punctuation, such as the following<span id="dx1-54012"/> code snippet:</p>&#13;
<pre id="listing-33" class="lstlisting"><code>def remove(str: str, chars: str) -&gt; str: &#13;
    if chars: &#13;
        return remove( &#13;
            str.replace(chars[0], ""), &#13;
            chars[1:] &#13;
        ) &#13;
    return str</code></pre>&#13;
<p>This function will recursively remove each of the characters from the <span class="obeylines-h"><span class="verb"><code class="inlineCode">chars</code></span></span> variable. We can use it as <span class="obeylines-h"><span class="verb"><code class="inlineCode">Decimal(remove(text,</code><code class="inlineCode"> "$,"))</code></span></span> to make the intent of our string cleanup more clear. <span id="x1-54020r57"/></p>&#13;
</section>&#13;
<section id="using-tuples-and-named-tuples" class="level3 sectionHead" data-number="0.7.4">&#13;
<h3 class="sectionHead" data-number="0.7.4"><span class="titlemark">3.4 </span> <span id="x1-550004"/>Using tuples and named tuples</h3>&#13;
<p>Since Python tuples<span id="dx1-55001"/> are immutable objects, they’re another excellent example of objects suitable for functional programming. A Python tuple has very few methods, so almost everything is done using prefix syntax. There are a number of use cases for tuples, particularly when working with list-of-tuple, tuple-of-tuple, and generator-of-tuple constructs.</p>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">typing.NamedTuple</code></span></span> class adds an essential<span id="dx1-55002"/> feature to a tuple: names to use instead of cryptic index numbers. We can exploit named tuples to create objects that are accretions of data. This allows us to write pure functions based on stateless objects, yet keep data bound into tidy object-like packages. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">collections.namedtuple()</code></span></span> can also be used to define an immutable class of objects. This lacks a mechanism for providing type hints, making it less desirable than the <span class="obeylines-h"><span class="verb"><code class="inlineCode">typing.NamedTuple</code></span></span> class.</p>&#13;
<p>The decision to use a tuple or <span class="obeylines-h"><span class="verb"><code class="inlineCode">typing.NamedTuple</code></span></span> object is entirely a matter of convenience. As an example, consider working with a sequence of color values as a three-tuple of the form <span class="obeylines-h"><span class="verb"><code class="inlineCode">(number,</code><code class="inlineCode"> number,</code><code class="inlineCode"> number)</code></span></span>. It’s not clear that these are in red, green, blue order. We have a number of approaches for making the tuple structure explicit.</p>&#13;
<p>One purely functional approach to expose the triple structure is by creating functions to pick a three-tuple apart, as shown in the following code snippet:</p>&#13;
<pre id="listing-34" class="lstlisting"><code>from collections.abc import Callable &#13;
from typing import TypeAlias &#13;
 &#13;
Extractor: TypeAlias = Callable[[tuple[int, int, int, str]], int] &#13;
 &#13;
red: Extractor = lambda color: color[0] &#13;
 &#13;
green: Extractor = lambda color: color[1] &#13;
 &#13;
blue: Extractor = lambda color: color[2]</code></pre>&#13;
<p>Given a tuple, <span class="obeylines-h"><span class="verb"><code class="inlineCode">item</code></span></span>, we can use <span class="obeylines-h"><span class="verb"><code class="inlineCode">red(item)</code></span></span> to select the item that has the red component. This style is used in a number<span id="dx1-55013"/> of purely functional<span id="dx1-55014"/> languages; it has a structure that matches mathematical abstractions nicely.</p>&#13;
<p>In Python, it can sometimes help to provide a more formal type hint on each variable, as follows:</p>&#13;
<pre id="listing-35" class="lstlisting"><code>from collections.abc import Callable &#13;
from typing import TypeAlias &#13;
 &#13;
RGB: TypeAlias = tuple[int, int, int, str] &#13;
 &#13;
redt: Callable[[RGB], int] = lambda color: color[0]</code></pre>&#13;
<p>This defines a new type alias, <span class="obeylines-h"><span class="verb"><code class="inlineCode">RGB</code></span></span>, as a four-tuple. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">redt()</code></span></span> function is provided with a type hint of <span class="obeylines-h"><span class="verb"><code class="inlineCode">Callable[[RGB],</code><code class="inlineCode"> int]</code></span></span> to indicate it should be considered to be a function that accepts an argument value of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">RGB</code></span></span> class and produces an integer result. This follows other styles of functional programming and adds type hints that can be checked by <span class="keyWord">mypy</span>.</p>&#13;
<p>A somewhat better technique is to use Python’s <span class="obeylines-h"><span class="verb"><code class="inlineCode">typing.NamedTuple</code></span></span> class. This uses a class definition instead of function definitions and looks like this:</p>&#13;
<pre id="listing-36" class="lstlisting"><code>from typing import NamedTuple &#13;
class Color(NamedTuple): &#13;
    """An RGB color.""" &#13;
    red: int &#13;
    green: int &#13;
    blue: int &#13;
    name: str</code></pre>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">Color</code></span></span> class defines a tuple<span id="dx1-55028"/> with specific names and type hints for each position within the tuple. This preserves the advantages<span id="dx1-55029"/> of performance and immutability. It adds the ability for the <span class="keyWord">mypy </span>program to confirm that the tuple is used properly.</p>&#13;
<p>This also means we’ll use <span class="obeylines-h"><span class="verb"><code class="inlineCode">color.red</code></span></span> instead of <span class="obeylines-h"><span class="verb"><code class="inlineCode">red(color)</code></span></span>. Using an attribute name to access a member of a tuple seems to add clarity.</p>&#13;
<p>There are a number of additional approaches for working with immutable tuples. We’ll look at all of these immutable class techniques in <a href="Chapter_07.xhtml#x1-1530007"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 7</span></a>, <a href="Chapter_07.xhtml#x1-1530007"><span class="cmti-10x-x-109">Complex</span> <span class="cmti-10x-x-109">Stateless Objects</span></a>. <span id="x1-55030r58"/></p>&#13;
</section>&#13;
<section id="using-generator-expressions" class="level3 sectionHead" data-number="0.7.5">&#13;
<h3 class="sectionHead" data-number="0.7.5"><span class="titlemark">3.5 </span> <span id="x1-560005"/>Using generator expressions</h3>&#13;
<p>We’ve shown some examples of generator expressions<span id="dx1-56001"/> already in the <a href="Chapter_02.xhtml#x1-400004"><span class="cmti-10x-x-109">Lazy and</span> <span class="cmti-10x-x-109">eager evaluation</span></a> section of <a href="Chapter_02.xhtml#x1-340002"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 2</span></a>, <a href="Chapter_02.xhtml#x1-340002"><span class="cmti-10x-x-109">Introducing Essential Functional Concepts</span></a>. We’ll show some more later in this chapter. In this section, we’ll introduce some more generator techniques.</p>&#13;
<p>Python collections are described as iterable. We can use a <span class="obeylines-h"><span class="verb"><code class="inlineCode">for</code></span></span> statement to iterate over the values. The key mechanism is the ability of a collection to create an iterator object to be used by the <span class="obeylines-h"><span class="verb"><code class="inlineCode">for</code></span></span> statement. This concept generalizes to encompass a function that is an iterator over values. We call these generator functions. We can also write generator expressions.</p>&#13;
<p>It’s common to see generator expressions used to create the <span class="obeylines-h"><span class="verb"><code class="inlineCode">list</code></span></span> or <span class="obeylines-h"><span class="verb"><code class="inlineCode">dict</code></span></span> literals through list comprehension or a dictionary comprehension syntax. This is a list comprehension example, <span class="lstinline"><span style="color:#000000"><code class="inlineCode">[</code></span><span style="color:#000000"><code class="inlineCode">x</code></span><span style="color:#000000"><code class="inlineCode">**2</code></span><span style="color:#000000"> </span><span style="color:#000000"><code class="inlineCode">for</code></span><span style="color:#000000"> </span><span style="color:#000000"><code class="inlineCode">x</code></span><span style="color:#000000"> </span><span style="color:#000000"><code class="inlineCode">in</code></span><span style="color:#000000"> </span><span style="color:#000000"><code class="inlineCode">range</code></span><span style="color:#000000"><code class="inlineCode">(10)</code></span><span style="color:#000000"><code class="inlineCode">]</code></span></span>, a kind of list display. A list comprehension is one of several places in Python where generator expressions are used. In this example, the list literal <span class="obeylines-h"><span class="verb"><code class="inlineCode">[]</code></span></span> characters wrap the generator expression, <span class="obeylines-h"><span class="verb"><code class="inlineCode">x**2</code><code class="inlineCode"> for</code><code class="inlineCode"> x</code><code class="inlineCode"> in</code><code class="inlineCode"> range(10)</code></span></span>. This list comprehension creates a list object from the enclosed generator expression.</p>&#13;
<p>The underlying <span class="obeylines-h"><span class="verb"><code class="inlineCode">x**2</code><code class="inlineCode"> for</code><code class="inlineCode"> x</code><code class="inlineCode"> in</code><code class="inlineCode"> range(10)</code></span></span> expression yields a sequence of values. These must be consumed by a client function. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">list()</code></span></span> function can consume the values. This means we have two ways to create a list object from a generator expression, as shown in the following example:</p>&#13;
<div id="tcolobox-34" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; list(x**2 for x in range(10)) == [x**2 for x in range(10)] &#13;
True</code></pre>&#13;
&#13;
</div>&#13;
<p>There are other kinds of comprehensions<span id="dx1-56005"/> to create dictionaries and sets. When the enclosing characters are <span class="obeylines-h"><span class="verb"><code class="inlineCode">{}</code></span></span>, this is a set comprehension. When the enclosing characters are <span class="obeylines-h"><span class="verb"><code class="inlineCode">{}</code></span></span>, and there are <span class="obeylines-h"><span class="verb"><code class="inlineCode">:</code></span></span> to separate keys and values, this is a dictionary comprehension. In this section, we’re going to focus on the generator expressions, separate from the specific kind of collection object they might create.</p>&#13;
<p>A collection object and a generator expression have some similar behaviors because both are iterable. They’re not equivalent, as we’ll see in the following code. Using a display object has the disadvantage of creating a (potentially large) collection of objects. A generator expression is lazy and creates objects only as required; this can improve performance.</p>&#13;
<p>We have to provide two important caveats on generator expressions, as follows:</p>&#13;
<ul>&#13;
<li><p>Generators have some of the same internal methods as lists. This means we can apply functions like <span class="obeylines-h"><span class="verb"><code class="inlineCode">sorted()</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">iter()</code></span></span> to either generators or lists. An exception is the <span class="obeylines-h"><span class="verb"><code class="inlineCode">len()</code></span></span> function, which needs to know the size of the collection and won’t work for a generator.</p></li>&#13;
<li><p>Generators can be used only once. After that, they appear empty.</p></li>&#13;
</ul>&#13;
<p>A generator<span id="dx1-56006"/> function is a function that has a <span class="obeylines-h"><span class="verb"><code class="inlineCode">yield</code></span></span> expression in it. This makes the function act as an iterator. Each individual <span class="obeylines-h"><span class="verb"><code class="inlineCode">yield</code></span></span> value must be individually consumed by a client function. For a tutorial introduction, see <a href="https://wiki.python.org/moin/Generators" class="url">https://wiki.python.org/moin/Generators</a>.</p>&#13;
<p>Also, see <a href="https://docs.python.org/3/howto/functional.html#generator-expressions-and-list-comprehensions" class="url">https://docs.python.org/3/howto/functional.html#generator-expressions-and-list-comprehensions</a>.</p>&#13;
<p>We can use something like the following to create a sequence of possible prime numbers:</p>&#13;
<pre id="listing-37" class="lstlisting"><code>from collections.abc import Iterator &#13;
 &#13;
def candidates() -&gt; Iterator[int]: &#13;
    for i in range(2, 1024): &#13;
        yield m1f(i)</code></pre>&#13;
<p>This function iterates through 1,024 result values. It doesn’t compute them eagerly, however. It is lazy, and computes<span id="dx1-56012"/> values as they’re requested. The built-in <span class="obeylines-h"><span class="verb"><code class="inlineCode">next()</code></span></span> function is one way to consume values. Here’s an example of consuming values from a generator function:</p>&#13;
<div id="tcolobox-35" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; c = candidates() &#13;
&gt;&gt;&gt; next(c) &#13;
3 &#13;
&gt;&gt;&gt; next(c) &#13;
7 &#13;
&gt;&gt;&gt; next(c) &#13;
15 &#13;
&gt;&gt;&gt; next(c) &#13;
31</code></pre>&#13;
&#13;
</div>&#13;
<p>When the <span class="obeylines-h"><span class="verb"><code class="inlineCode">candidates()</code></span></span> function is evaluated, it creates a generator object, which is saved in the variable <span class="obeylines-h"><span class="verb"><code class="inlineCode">c</code></span></span>. Each time we use <span class="obeylines-h"><span class="verb"><code class="inlineCode">next(c)</code></span></span>, the generator function computes one more value and yields it. In this example, it will get a new value from the <span class="obeylines-h"><span class="verb"><code class="inlineCode">range</code></span></span> object, and evaluate the <span class="obeylines-h"><span class="verb"><code class="inlineCode">m1f()</code></span></span> function to compute a new value.</p>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">yield</code><code class="inlineCode"> from</code></span></span> expression extends the <span class="obeylines-h"><span class="verb"><code class="inlineCode">yield</code></span></span> expression. This will consume values from some iterator, yielding each of the values it consumes. As a small example, consider the following function:</p>&#13;
<pre id="listing-38" class="lstlisting"><code>from collections.abc import Iterator &#13;
 &#13;
def bunch_of_numbers() -&gt; Iterator[int]: &#13;
    for i in range(5): &#13;
        yield from range(i)</code></pre>&#13;
<p>Each time a value is requested, it will be produced<span id="dx1-56028"/> by the <span class="obeylines-h"><span class="verb"><code class="inlineCode">yield</code><code class="inlineCode"> from</code></span></span> nested inside the <span class="obeylines-h"><span class="verb"><code class="inlineCode">for</code></span></span> statement. This will yield <span class="obeylines-h"><span class="verb"><code class="inlineCode">i</code></span></span> distinct values, one from each request. Since <span class="obeylines-h"><span class="verb"><code class="inlineCode">i</code></span></span> is set by the containing <span class="obeylines-h"><span class="verb"><code class="inlineCode">for</code></span></span> statement, this will be used to produce ever longer sequences of numbers.</p>&#13;
<p>Here’s what the result looks like:</p>&#13;
<div id="tcolobox-36" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; list(bunch_of_numbers()) &#13;
[0, 0, 1, 0, 1, 2, 0, 1, 2, 3]</code></pre>&#13;
&#13;
</div>&#13;
<p>Here is a generator function that we’ll use for some more examples:</p>&#13;
<pre id="listing-39" class="lstlisting"><code>from collections.abc import Iterator &#13;
import math &#13;
 &#13;
def pfactorsl(x: int) -&gt; Iterator[int]: &#13;
    if x % 2 == 0: &#13;
        yield 2 &#13;
        if x // 2 &gt; 1: &#13;
            yield from pfactorsl(x // 2) &#13;
        return &#13;
    for i in range(3, int(math.sqrt(x) + .5) + 1, 2): &#13;
        if x % i == 0: &#13;
            yield i &#13;
            if x // i &gt; 1: &#13;
                yield from pfactorsl(x // i) &#13;
            return &#13;
    yield x</code></pre>&#13;
<p>We’re locating the prime factors of a number. If the number, <span class="obeylines-h"><span class="verb"><code class="inlineCode">x</code></span></span>, is even, we’ll yield 2 and then recursively yield all prime factors of <span class="obeylines-h"><span class="verb"><code class="inlineCode">x</code><code class="inlineCode"> //</code><code class="inlineCode"> 2</code></span></span>.</p>&#13;
<p>For odd numbers, we’ll step through odd values greater than or equal to 3 to locate a candidate factor of the number. When we locate a factor, <span class="obeylines-h"><span class="verb"><code class="inlineCode">i</code></span></span>, we’ll yield that factor, and then recursively yield all prime factors of <span class="obeylines-h"><span class="verb"><code class="inlineCode">x</code><code class="inlineCode"> //</code><code class="inlineCode"> i</code></span></span>.</p>&#13;
<p>In the event that we can’t locate a factor, the number, <span class="obeylines-h"><span class="verb"><code class="inlineCode">x</code></span></span>, must be prime, so we can yield the number.</p>&#13;
<p>We handle 2 as a special case to cut the number of iterations in half. All prime numbers, except 2, are odd.</p>&#13;
<p>We’ve used one important <span class="obeylines-h"><span class="verb"><code class="inlineCode">for</code></span></span> statement in addition<span id="dx1-56048"/> to recursion. This is an optimization, and it’s a teaser for the content of <a href="Chapter_06.xhtml#x1-1260006"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 6</span></a>, <a href="Chapter_06.xhtml#x1-1260006"><span class="cmti-10x-x-109">Recursions and</span> <span class="cmti-10x-x-109">Reductions</span></a>. This optimization allows us to easily handle numbers that have as many as 1,000 factors. (As an example, 2<sup><span class="cmr-8">1</span><span class="cmmi-8">,</span><span class="cmr-8">000</span></sup>, a number with 300 digits, will have 1,000 factors.) Since the <span class="obeylines-h"><span class="verb"><code class="inlineCode">for</code></span></span> variable, <span class="obeylines-h"><span class="verb"><code class="inlineCode">i</code></span></span>, is not used outside the indented body of the statement, the stateful nature of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">i</code></span></span> variable won’t lead to confusion if we make any changes to the body of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">for</code></span></span> statement.</p>&#13;
<p>Because the function, as a whole, is a generator, the <span class="obeylines-h"><span class="verb"><code class="inlineCode">yield</code><code class="inlineCode"> from</code></span></span> statement is used to consume values from the recursive call and yield them to the caller. It provides an iterable sequence of values as a result.</p>&#13;
<div id="tcolobox-37" class="packt_tip">&#13;
&#13;
&#13;
<p>In a recursive generator function, be careful of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">return</code></span></span> statement.</p>&#13;
<p>Do not use the following statement: <span class="obeylines-h"><span class="verb"><code class="inlineCode">return</code><code class="inlineCode"> recursive_iter(args)</code></span></span>. It returns only a generator object; it doesn’t evaluate the <span class="obeylines-h"><span class="verb"><code class="inlineCode">recursive_iter()</code></span></span> function to return the generated values. Use any of the following alternatives:</p>&#13;
<ul>&#13;
<li><p>A <span class="obeylines-h"><span class="verb"><code class="inlineCode">yield</code></span></span> expression:</p>&#13;
<pre id="listing-40" class="lstlisting"><code>for result in recursive_iter(args): &#13;
    yield result</code></pre></li>&#13;
<li><p>A <span class="obeylines-h"><span class="verb"><code class="inlineCode">yield</code><code class="inlineCode"> from</code></span></span> expression:</p>&#13;
<pre id="listing-41" class="lstlisting"><code>yield from recursive_iter(args)</code></pre></li>&#13;
</ul>&#13;
&#13;
</div>&#13;
<p>A function that implements the <span class="obeylines-h"><span class="verb"><code class="inlineCode">Iterator</code></span></span> protocol is often described<span id="dx1-56052"/> as being a <span class="keyWord">generator function</span>. There is a separate <span class="obeylines-h"><span class="verb"><code class="inlineCode">Generator</code></span></span> protocol, which extends the essential <span class="obeylines-h"><span class="verb"><code class="inlineCode">Iterator</code></span></span> definition. We often find that functional<span id="dx1-56053"/> Python programs can be structured around the generator expression construct. This tends to focus the design effort on functions and stateless objects. <span id="x1-56054r52"/></p>&#13;
<section id="exploring-the-limitations-of-generators" class="level4 subsectionHead" data-number="0.7.5.1">&#13;
<h4 class="subsectionHead" data-number="0.7.5.1"><span class="titlemark">3.5.1 </span> <span id="x1-570001"/>Exploring the limitations of generators</h4>&#13;
<p>We noted that there are some limitations of generator<span id="dx1-57001"/> expressions and generator functions. The limitations can be observed by executing the following command snippet:</p>&#13;
<div id="tcolobox-38" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; pfactorsl(1560) &#13;
&lt;generator object pfactorsl at ...&gt; &#13;
 &#13;
&gt;&gt;&gt; list(pfactorsl(1560)) &#13;
[2, 2, 2, 3, 5, 13] &#13;
 &#13;
&gt;&gt;&gt; len(pfactorsl(1560)) &#13;
Traceback (most recent call last): &#13;
    File "&lt;stdin&gt;", line 1, in &lt;module&gt; &#13;
TypeError: object of type ’generator’ has no len()</code></pre>&#13;
&#13;
</div>&#13;
<p>In the first example, we saw the generator function, <span class="obeylines-h"><span class="verb"><code class="inlineCode">pfactors1()</code></span></span>, created a generator. The generator is lazy, and doesn’t have a proper value until we consume the results yielded by the generator. By itself, this isn’t a limitation; lazy evaluation is an important reason why generator expressions fit with functional programming in Python.</p>&#13;
<p>In the second example, we materialized a list object from the results yielded by the generator function. This is handy for seeing the output and writing unit test cases.</p>&#13;
<p>In the third example, we saw one limitation of generator functions: there’s no <span class="obeylines-h"><span class="verb"><code class="inlineCode">len()</code></span></span>. Because the generator is lazy, the size can’t be known until after all of the values are consumed.</p>&#13;
<p>The other limitation of a generator object is that they can only be used once. For example, look at the following command<span id="dx1-57013"/> snippet:</p>&#13;
<div id="tcolobox-39" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; result = pfactorsl(1560) &#13;
&gt;&gt;&gt; sum(result) &#13;
27 &#13;
 &#13;
&gt;&gt;&gt; sum(result) &#13;
0</code></pre>&#13;
&#13;
</div>&#13;
<p>The first evaluation of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">sum()</code></span></span> function performed evaluation of the generator object, <span class="obeylines-h"><span class="verb"><code class="inlineCode">result</code></span></span>. All of the values were consumed. The second evaluation of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">sum()</code></span></span> function found that the generator object was now empty. We can only consume the values of a generator object once.</p>&#13;
<p>The generator function, <span class="obeylines-h"><span class="verb"><code class="inlineCode">pfactorsl()</code></span></span>, can produce an indefinite number of generator objects. In many cases, we’ll define generator functions that consume the results yielded by other generators. In these cases, we may not be able to trivially create generators, but must create a whole pipeline of generators.</p>&#13;
<p>Generators have a stateful life in Python. While they’re very nice for some aspects of functional programming, they’re not quite perfect.</p>&#13;
<p>We can try to use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">itertools.tee()</code></span></span> function to overcome the once-only limitation. We’ll look at this in depth in <a href="Chapter_08.xhtml#x1-1700008"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 8</span></a>, <a href="Chapter_08.xhtml#x1-1700008"><span class="cmti-10x-x-109">The Itertools Module</span></a>. It’s not a great idea because it can consume a great deal of memory.</p>&#13;
<p>Here is a quick example of its usage:</p>&#13;
<pre id="listing-42" class="lstlisting"><code>import itertools &#13;
from typing import Any &#13;
from collections.abc import Iterable &#13;
 &#13;
def limits(iterable: Iterable[Any]) -&gt; Any: &#13;
    max_tee, min_tee = itertools.tee(iterable, 2) &#13;
    return max(max_tee), min(min_tee)</code></pre>&#13;
<p>We created two clones of the parameter<span id="dx1-57028"/> generator expression, <span class="obeylines-h"><span class="verb"><code class="inlineCode">max_tee</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">min_tee</code></span></span>. We can consume these two clones to get maximum and minimum values from the iterable. Interestingly, because the two clones are used serially, this leads to consuming a great deal of memory to cache items. This specific example often works out better using a list object instead of using <span class="obeylines-h"><span class="verb"><code class="inlineCode">tee()</code></span></span> to clone an iterator.</p>&#13;
<p>Once consumed, a generator object will not provide any more values. When we want to compute multiple kinds of reductions—for example, sums and counts, or minimums and maximums—we need to design with this one-pass-only limitation in mind. <span id="x1-57029r60"/></p>&#13;
</section>&#13;
<section id="combining-generator-expressions" class="level4 subsectionHead" data-number="0.7.5.2">&#13;
<h4 class="subsectionHead" data-number="0.7.5.2"><span class="titlemark">3.5.2 </span> <span id="x1-580002"/>Combining generator expressions</h4>&#13;
<p>The essence of functional programming<span id="dx1-58001"/> comes from the ways we can easily combine generator expressions and generator functions to create very sophisticated composite processing sequences. When working with generator expressions, we can combine generators in several ways.</p>&#13;
<p>One common way to combine generator functions is when we create a composite function. We may have a generator that computes <span class="obeylines-h"><span class="verb"><code class="inlineCode">(f(x)</code><code class="inlineCode"> for</code><code class="inlineCode"> x</code><code class="inlineCode"> in</code><code class="inlineCode"> some_iterable)</code></span></span>. If we want to compute <span class="obeylines-h"><span class="verb"><code class="inlineCode">g(f(x))</code></span></span>, we have several ways to combine two generators.</p>&#13;
<p>We can tweak the original generator expression as follows:</p>&#13;
<pre id="listing-43" class="lstlisting"><code>g_f_x = (g(f(x)) for x in some_iterable)</code></pre>&#13;
<p>While technically correct, this defeats any idea of reuse. Rather than reusing an expression, we rewrote it.</p>&#13;
<p>We can also substitute one expression within another expression, as follows:</p>&#13;
<pre id="listing-44" class="lstlisting"><code>g_f_x = (g(y) for y in (f(x) for x in some_iterable))</code></pre>&#13;
<p>This has the advantage of allowing us to use simple substitution. We can revise this slightly to emphasize reuse, using the following<span id="dx1-58004"/> commands:</p>&#13;
<pre id="listing-45" class="lstlisting"><code>f_x = (f(x) for x in some_iterable) &#13;
g_f_x = (g(y) for y in f_x)</code></pre>&#13;
<p>This has the advantage of leaving the initial expression, <span class="obeylines-h"><span class="verb"><code class="inlineCode">(f(x)</code><code class="inlineCode"> for</code><code class="inlineCode"> x</code><code class="inlineCode"> in</code><code class="inlineCode"> some_iterable)</code></span></span>, essentially unchanged. All we did was assign the expression to a variable without altering the syntax.</p>&#13;
<p>The resulting composite function is also a generator expression, which is also lazy. This means that extracting the next value from <span class="obeylines-h"><span class="verb"><code class="inlineCode">g_f_x</code></span></span> will extract one value from <span class="obeylines-h"><span class="verb"><code class="inlineCode">f_x</code></span></span>, which will extract one value from the source <span class="obeylines-h"><span class="verb"><code class="inlineCode">some_iterable</code></span></span> object. <span id="x1-58007r59"/></p>&#13;
</section>&#13;
</section>&#13;
<section id="cleaning-raw-data-with-generator-functions" class="level3 sectionHead" data-number="0.7.6">&#13;
<h3 class="sectionHead" data-number="0.7.6"><span class="titlemark">3.6 </span> <span id="x1-590006"/>Cleaning raw data with generator functions</h3>&#13;
<p>One of the tasks that arise in exploratory<span id="dx1-59001"/> data analysis is cleaning up raw source data. This is often done as a composite<span id="dx1-59002"/> operation applying several scalar functions to each piece of input data to create a usable dataset.</p>&#13;
<p>Let’s look at a simplified set of data. This data is commonly used to show techniques in exploratory data analysis. It’s called <span class="keyWord">Anscombe’s quartet</span>, and it comes<span id="dx1-59003"/> from the article <span class="cmti-10x-x-109">Graphs in Statistical Analysis</span>, by F. J. Anscombe, that appeared in <span class="cmti-10x-x-109">American Statistician </span>in 1973. The following are the first few rows of a downloaded file with this dataset:</p>&#13;
<pre id="listing-46" class="lstlisting"><code>Anscombe’s quartet &#13;
I II III IV &#13;
x y x y x y x y &#13;
10.0 8.04 10.0 9.14 10.0 7.46 8.0 6.58 &#13;
8.0 6.95 8.0 8.14 8.0 6.77 8.0 5.76 &#13;
13.0 7.58 13.0 8.74 13.0 12.74 8.0 7.71</code></pre>&#13;
<p>Since the data is properly tab-delimited, we can use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">csv.reader()</code></span></span> function to iterate through the various rows. Sadly, we can’t trivially process this with the <span class="obeylines-h"><span class="verb"><code class="inlineCode">csv</code></span></span> module. We have to do a little bit of parsing<span id="dx1-59010"/> to extract the useful information from this file. We can define a function to iterate<span id="dx1-59011"/> over the raw data as follows:</p>&#13;
<pre id="listing-47" class="lstlisting"><code>import csv &#13;
from typing import TextIO &#13;
from collections.abc import Iterator, Iterable &#13;
 &#13;
def row_iter(source: TextIO) -&gt; Iterator[list[str]]: &#13;
    return csv.reader(source, delimiter="\t")</code></pre>&#13;
<p>We wrapped a file in a <span class="obeylines-h"><span class="verb"><code class="inlineCode">csv.reader()</code></span></span> function to create an iterator over the rows of raw data. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">typing</code></span></span> module provides a handy definition, <span class="obeylines-h"><span class="verb"><code class="inlineCode">TextIO</code></span></span>, for file objects that read (or write) string values. Each row is a list of text values. It can be helpful to define an additional type, <span class="obeylines-h"><span class="verb"><code class="inlineCode">Row</code><code class="inlineCode"> =</code><code class="inlineCode"> list[str]</code></span></span>, to make this more explicit.</p>&#13;
<p>We can use this <span class="obeylines-h"><span class="verb"><code class="inlineCode">row_iter()</code></span></span> function in the following context:</p>&#13;
<div id="tcolobox-40" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; from pathlib import Path &#13;
&gt;&gt;&gt; source_path = Path("Anscombe.txt") &#13;
&gt;&gt;&gt; with source_path.open() as source: &#13;
...     print(list(row_iter(source)))</code></pre>&#13;
&#13;
</div>&#13;
<p>While this will display useful information, the problem is the first three items in the resulting iterable aren’t data. The Anscombe’s quartet file starts with the following header rows:</p>&#13;
<div id="tcolobox-41" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>[["Anscombe’s quartet"], &#13;
 [’I’, ’II’, ’III’, ’IV’], &#13;
 [’x’, ’y’, ’x’, ’y’, ’x’, ’y’, ’x’, ’y’],</code></pre>&#13;
&#13;
</div>&#13;
<p>We need to filter these three non-data rows from the iterable. There are several possible approaches. Here is a function that will excise three expected title rows, validate they are the expected headers, and return an iterator over the remaining rows:</p>&#13;
<pre id="listing-48" class="lstlisting"><code>from collections.abc import Iterator &#13;
 &#13;
def head_split_fixed( &#13;
        row_iter: Iterator[list[str]] &#13;
) -&gt; Iterator[list[str]]: &#13;
    title = next(row_iter) &#13;
    assert (len(title) == 1 &#13;
        and title[0] == "Anscombe’s quartet") &#13;
    heading = next(row_iter) &#13;
    assert (len(heading) == 4 &#13;
        and heading == [’I’, ’II’, ’III’, ’IV’]) &#13;
 &#13;
    columns = next(row_iter) &#13;
    assert (len(columns) == 8 &#13;
        and columns == [’x’,’y’, ’x’,’y’, ’x’,’y’, ’x’,’y’]) &#13;
    return row_iter</code></pre>&#13;
<p>This function<span id="dx1-59043"/> plucks three rows from the source<span id="dx1-59044"/> data, an iterator. It asserts that each row has an expected value. If the file doesn’t meet these basic expectations, it’s a sign that the file was damaged or perhaps our analysis is focused on the wrong file.</p>&#13;
<p>Since both the <span class="obeylines-h"><span class="verb"><code class="inlineCode">row_iter()</code></span></span> and the <span class="obeylines-h"><span class="verb"><code class="inlineCode">head_split_fixed()</code></span></span> functions expect an iterator as an argument value, they can be combined, as follows:</p>&#13;
<pre id="listing-49" class="lstlisting"><code>from pathlib import Path &#13;
from collections.abc import Iterator &#13;
 &#13;
def get_rows(path: Path) -&gt; Iterator[list[str]]: &#13;
    with path.open() as source: &#13;
        yield from head_split_fixed(row_iter(source))</code></pre>&#13;
<p>We’ve applied one iterator to the results of another iterator. In effect, this defines a composite function. We’re not done, of course; we still need to convert the string values to the float values, and we also need to pick apart the four parallel series of data in each row.</p>&#13;
<p>The final conversions and data extractions are more easily done with higher-order functions, such as <span class="obeylines-h"><span class="verb"><code class="inlineCode">map()</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">filter()</code></span></span>. We’ll return to those in <a href="Chapter_05.xhtml#x1-1000005"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 5</span></a>, <a href="Chapter_05.xhtml#x1-1000005"><span class="cmti-10x-x-109">Higher-Order Functions</span></a>. <span id="x1-59051r62"/></p>&#13;
</section>&#13;
<section id="applying-generators-to-built-in-collections" class="level3 sectionHead" data-number="0.7.7">&#13;
<h3 class="sectionHead" data-number="0.7.7"><span class="titlemark">3.7 </span> <span id="x1-600007"/>Applying generators to built-in collections</h3>&#13;
<p>We’ll now look at ways to apply generator<span id="dx1-60001"/> expressions to a number of Python’s built-in collections. This section will cover the following topics:</p>&#13;
<ul>&#13;
<li><p>Generators for lists, dicts, and sets</p></li>&#13;
<li><p>Working with stateful collections</p></li>&#13;
<li><p>Using the <span class="obeylines-h"><span class="verb"><code class="inlineCode">bisect</code></span></span> module to create a mapping</p></li>&#13;
<li><p>Using stateful sets</p></li>&#13;
</ul>&#13;
<p>Each of these looks at some specialized cases of Python collections and generator functions. In particular, we’ll look at ways to produce a collection, and consume the collection in later processing.</p>&#13;
<p>This is a lead-in to the next chapter, <a href="Chapter_04.xhtml#x1-740004"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 4</span></a>, <a href="Chapter_04.xhtml#x1-740004"><span class="cmti-10x-x-109">Working with Collections</span></a>, which covers the Python collections in considerably more detail. <span id="x1-60002r61"/></p>&#13;
<section id="generators-for-lists-dicts-and-sets" class="level4 subsectionHead" data-number="0.7.7.1">&#13;
<h4 class="subsectionHead" data-number="0.7.7.1"><span class="titlemark">3.7.1 </span> <span id="x1-610001"/>Generators for lists, dicts, and sets</h4>&#13;
<p>A Python sequence<span id="dx1-61001"/> object, such as a list, is iterable. However, it has some additional features. We can think of a list as a materialized<span id="dx1-61002"/> iterable. We’ve used the <span class="obeylines-h"><span class="verb"><code class="inlineCode">tuple()</code></span></span> function in several examples<span id="dx1-61003"/> to collect the output of a generator expression or generator function into a single tuple object. We can use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">list()</code></span></span> function to materialize a sequence to create a list object.</p>&#13;
<p>In Python, a <span class="keyWord">list display</span>, or <span class="keyWord">list comprehension</span>, offers simple<span id="dx1-61004"/> syntax to materialize a generator: we add the <span class="obeylines-h"><span class="verb"><code class="inlineCode">[]</code></span></span> brackets. This is ubiquitous<span id="dx1-61005"/> to the point where the distinction between generator expression and list comprehension can be lost. We need to disentangle the idea of a generator expression from a list display that uses a generator expression.</p>&#13;
<p>The following is an example to enumerate the cases:</p>&#13;
<div id="tcolobox-42" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; range(10) &#13;
range(0, 10) &#13;
 &#13;
&gt;&gt;&gt; [range(10)] &#13;
[range(0, 10)] &#13;
 &#13;
&gt;&gt;&gt; [x for x in range(10)] &#13;
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9] &#13;
 &#13;
&gt;&gt;&gt; list(range(10)) &#13;
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</code></pre>&#13;
&#13;
</div>&#13;
<p>The first example<span id="dx1-61018"/> is the <span class="obeylines-h"><span class="verb"><code class="inlineCode">range</code></span></span> object, which is a type of generator function. It doesn’t produce any values because it’s lazy.</p>&#13;
<p>The second example<span id="dx1-61019"/> shows a list composed of a single instance of the generator function. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">[]</code></span></span> syntax creates a list literal of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">range()</code></span></span> object without consuming any values created by the iterator.</p>&#13;
<p>The third example<span id="dx1-61020"/> shows a list comprehension built from a generator expression that includes a generator function. The function, <span class="obeylines-h"><span class="verb"><code class="inlineCode">range(10)</code></span></span>, is evaluated by a generator expression, <span class="obeylines-h"><span class="verb"><code class="inlineCode">x</code><code class="inlineCode"> for</code><code class="inlineCode"> x</code><code class="inlineCode"> in</code><code class="inlineCode"> range(10)</code></span></span>. The resulting values are collected into a list object.</p>&#13;
<p>We can also use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">list()</code></span></span> function to build a list from an iterable or a generator expression. This also works for <span class="obeylines-h"><span class="verb"><code class="inlineCode">set()</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">tuple()</code></span></span>, and <span class="obeylines-h"><span class="verb"><code class="inlineCode">dict()</code></span></span>.</p>&#13;
<div id="tcolobox-43" class="packt_tip">&#13;
&#13;
&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">list(range(10))</code></span></span> function evaluates the generator object. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">[range(10)]</code></span></span> list literal does not evaluate the <span class="obeylines-h"><span class="verb"><code class="inlineCode">range(10)</code></span></span> generator object.</p>&#13;
&#13;
</div>&#13;
<p>While there’s shorthand syntax for <span class="obeylines-h"><span class="verb"><code class="inlineCode">list</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">dict</code></span></span>, and <span class="obeylines-h"><span class="verb"><code class="inlineCode">set</code></span></span> using <span class="obeylines-h"><span class="verb"><code class="inlineCode">[]</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">{}</code></span></span>, there’s no shorthand syntax for a tuple. To materialize a tuple, we must use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">tuple()</code></span></span> function. For this reason, it often seems most consistent to use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">list()</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">tuple()</code></span></span>, and <span class="obeylines-h"><span class="verb"><code class="inlineCode">set()</code></span></span> functions as the preferred syntax.</p>&#13;
<p>In the data cleansing code in the previous section, we used a composite function to create a list of four tuples. The function looked as follows:</p>&#13;
<div id="tcolobox-44" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; data = list(get_rows(Path("Anscombe.txt"))) &#13;
&gt;&gt;&gt; data[0] &#13;
[’10.0’, ’8.04’, ’10.0’, ’9.14’, ’10.0’, ’7.46’, ’8.0’, ’6.58’] &#13;
&gt;&gt;&gt; data[1] &#13;
[’8.0’, ’6.95’, ’8.0’, ’8.14’, ’8.0’, ’6.77’, ’8.0’, ’5.76’] &#13;
&gt;&gt;&gt; data[-1] &#13;
[’5.0’, ’5.68’, ’5.0’, ’4.74’, ’5.0’, ’5.73’, ’8.0’, ’6.89’]</code></pre>&#13;
&#13;
</div>&#13;
<p>We assigned the results of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">get_rows()</code></span></span> composite function to a name, <span class="obeylines-h"><span class="verb"><code class="inlineCode">data</code></span></span>. Each of these rows is a collection of four (<span class="italic">x,y</span>) pairs.</p>&#13;
<p>To extract<span id="dx1-61029"/> one of the (<span class="italic">x,y</span>) pairs, we’ll need to do a little bit more processing to make this useful. First, we need<span id="dx1-61030"/> to pick pairs of columns<span id="dx1-61031"/> from the eight-tuple. Since the pairs are always adjacent, we can select a pair of columns with a slice operation of the form <span class="obeylines-h"><span class="verb"><code class="inlineCode">row[2</code><code class="inlineCode"> *</code><code class="inlineCode"> n:</code><code class="inlineCode"> 2</code><code class="inlineCode"> *</code><code class="inlineCode"> n</code><code class="inlineCode"> +</code><code class="inlineCode"> 2]</code></span></span>. The idea is that pair <span class="italic">n </span>is in positions 2 <span class="cmsy-10x-x-109">× </span><span class="italic">n </span>and 2 <span class="cmsy-10x-x-109">× </span><span class="italic">n </span>+ 1. The slice expression <span class="obeylines-h"><span class="verb"><code class="inlineCode">2</code><code class="inlineCode"> *</code><code class="inlineCode"> n:</code><code class="inlineCode"> 2</code><code class="inlineCode"> *</code><code class="inlineCode"> n</code><code class="inlineCode"> +</code><code class="inlineCode"> 2</code></span></span> includes the start element, <span class="obeylines-h"><span class="verb"><code class="inlineCode">2</code><code class="inlineCode"> *</code><code class="inlineCode"> n</code></span></span>, and stops just before the stop element, <span class="obeylines-h"><span class="verb"><code class="inlineCode">2</code><code class="inlineCode"> *</code><code class="inlineCode"> n</code><code class="inlineCode"> +</code><code class="inlineCode"> 2</code></span></span>. We can wrap this with a reusable function, as shown in the following definition:</p>&#13;
<pre id="listing-50" class="lstlisting"><code>from typing import cast, TypeVar &#13;
from collections.abc import Iterator, Iterable &#13;
 &#13;
SrcT = TypeVar("SrcT") &#13;
 &#13;
def series( &#13;
        n: int, &#13;
        row_iter: Iterable[list[SrcT]] &#13;
) -&gt; Iterator[tuple[SrcT, SrcT]]: &#13;
    for row in row_iter: &#13;
        yield cast(tuple[SrcT, SrcT], tuple(row[n * 2: n * 2 + 2]))</code></pre>&#13;
<p>This function picks two adjacent columns based on a number between 0 and 3. It creates a tuple object from those two columns. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">cast()</code></span></span> function is a type hint to inform the <span class="keyWord">mypy </span>tool that the result will be a two-tuple where both items are strings. This is required because it’s difficult for the <span class="keyWord">mypy </span>tool to determine<span id="dx1-61043"/> that the expression <span class="obeylines-h"><span class="verb"><code class="inlineCode">tuple(row[n</code><code class="inlineCode"> *</code><code class="inlineCode"> 2:</code><code class="inlineCode"> n</code><code class="inlineCode"> *</code><code class="inlineCode"> 2</code><code class="inlineCode"> +</code><code class="inlineCode"> 2])</code></span></span> will select exactly two elements from the row collection.</p>&#13;
<p>This example<span id="dx1-61044"/> uses a type variable, <span class="obeylines-h"><span class="verb"><code class="inlineCode">SrcT</code></span></span>, to make a deeper claim about the transformation. Specifically, the type variable<span id="dx1-61045"/> tells people reading the code (and tools like <span class="keyWord">mypy</span>) that the input object types will be the resulting<span id="dx1-61046"/> object types. If the source is, for example, an iterable of lists of <span class="obeylines-h"><span class="verb"><code class="inlineCode">str</code></span></span>, then <span class="obeylines-h"><span class="verb"><code class="inlineCode">SrcT</code><code class="inlineCode"> =</code><code class="inlineCode"> str</code></span></span>, and the output will be an iterator over tuples with two <span class="obeylines-h"><span class="verb"><code class="inlineCode">str</code></span></span> values.</p>&#13;
<p>We can use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">series()</code></span></span> function to extract collections from the source file as follows:</p>&#13;
<div id="tcolobox-45" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; from pathlib import Path &#13;
&gt;&gt;&gt; source_path = Path("Anscombe.txt") &#13;
&gt;&gt;&gt; with source_path.open() as source: &#13;
...     data = tuple(head_split_fixed(row_iter(source))) &#13;
&gt;&gt;&gt; series_I = tuple(series(0, data)) &#13;
&gt;&gt;&gt; series_II = tuple(series(1, data)) &#13;
&gt;&gt;&gt; series_III = tuple(series(2, data)) &#13;
&gt;&gt;&gt; series_IV = tuple(series(3, data))</code></pre>&#13;
&#13;
</div>&#13;
<p>We applied the <span class="obeylines-h"><span class="verb"><code class="inlineCode">tuple()</code></span></span> function to a composite function based on the <span class="obeylines-h"><span class="verb"><code class="inlineCode">series()</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">head_split_fixed()</code></span></span>, and <span class="obeylines-h"><span class="verb"><code class="inlineCode">row_iter()</code></span></span> functions. Each of these expressions will create an object that we can reuse in several other functions. We can then do analysis on subsets of the source data.</p>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">series_I</code></span></span> sequence looks as follows:</p>&#13;
<div id="tcolobox-46" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; series_I &#13;
((’10.0’, ’8.04’), (’8.0’, ’6.95’), ... (’5.0’, ’5.68’))</code></pre>&#13;
&#13;
</div>&#13;
<p>The other three sequences are similar in structure. The values, however, are quite different.</p>&#13;
<p>The final thing we’ll need to do is create proper numeric values from the strings that we’ve accumulated so that we can compute some statistical summary values. We can apply the <span class="obeylines-h"><span class="verb"><code class="inlineCode">float()</code></span></span> function conversion as the last step. There are many alternative places to apply the <span class="obeylines-h"><span class="verb"><code class="inlineCode">float()</code></span></span> function, and we’ll look at some choices in <a href="Chapter_05.xhtml#x1-1000005"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 5</span></a>, <a href="Chapter_05.xhtml#x1-1000005"><span class="cmti-10x-x-109">Higher-Order Functions</span></a>.</p>&#13;
<p>To reduce memory<span id="dx1-61059"/> use and increase<span id="dx1-61060"/> performance, we prefer to use generator expressions and functions<span id="dx1-61061"/> as much as possible. These iterate through collections in a lazy manner, computing values only when required. Since iterators can only be used once, we’re sometimes forced to materialize a collection as a tuple (or list) object. Materializing a collection costs memory and time, so we do it reluctantly.</p>&#13;
<p>Programmers familiar with <span class="keyWord">Clojure</span><span id="dx1-61062"/> can match Python’s lazy generators with the <span class="obeylines-h"><span class="verb"><code class="inlineCode">lazy-seq</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">lazy-cat</code></span></span> functions. The idea is that we can specify a potentially infinite sequence, but only take values from it as needed. <span id="x1-61063r64"/></p>&#13;
</section>&#13;
<section id="using-stateful-mappings" class="level4 subsectionHead" data-number="0.7.7.2">&#13;
<h4 class="subsectionHead" data-number="0.7.7.2"><span class="titlemark">3.7.2 </span> <span id="x1-620002"/>Using stateful mappings</h4>&#13;
<p>Python offers several stateful<span id="dx1-62001"/> collections; the various mappings include the <span class="obeylines-h"><span class="verb"><code class="inlineCode">dict</code></span></span> class and a number of related mappings defined in the <span class="obeylines-h"><span class="verb"><code class="inlineCode">collections</code></span></span> module. We need to emphasize the stateful nature of these mappings and use them carefully.</p>&#13;
<p>For our purposes, learning functional programming techniques in Python, there are two use cases for mapping: a stateful dictionary that accumulates a mapping and a frozen dictionary that can’t be updated. Python doesn’t provide an easy-to-use definition of an immutable mapping. We can use the abstract base class <span class="obeylines-h"><span class="verb"><code class="inlineCode">Mapping</code></span></span> from the <span class="obeylines-h"><span class="verb"><code class="inlineCode">collections.abc</code></span></span> module. We can also create an immutable <span class="obeylines-h"><span class="verb"><code class="inlineCode">MappingProxyType</code></span></span> object from a mutable mapping. For more information, see the <span class="obeylines-h"><span class="verb"><code class="inlineCode">types</code></span></span> module.</p>&#13;
<p>The stateful dictionary can be further decomposed into the following two typical use cases:</p>&#13;
<ul>&#13;
<li><p>A dictionary built once and never updated. In this case, we want to exploit the hashed keys feature of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">dict</code></span></span> class to optimize performance. We can create a dictionary from any iterable sequence of <span class="obeylines-h"><span class="verb"><code class="inlineCode">(key,</code><code class="inlineCode"> value)</code></span></span> two-tuples using the expression <span class="obeylines-h"><span class="verb"><code class="inlineCode">dict(sequence)</code></span></span>.</p></li>&#13;
<li><p>A dictionary built incrementally. This is an optimization we can use to avoid materializing and sorting a list object. We’ll look at this in <a href="Chapter_06.xhtml#x1-1260006"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 6</span></a>, <a href="Chapter_06.xhtml#x1-1260006"><span class="cmti-10x-x-109">Recursions and Reductions</span></a>, where we’ll look at the <span class="obeylines-h"><span class="verb"><code class="inlineCode">collections.Counter</code></span></span> class as a sophisticated reduction. Incremental building is particularly helpful for memoization. We’ll defer memoization until <a href="Chapter_10.xhtml#x1-21700010"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 10</span></a>, <a href="Chapter_10.xhtml#x1-21700010"><span class="cmti-10x-x-109">The Functools Module</span></a>.</p></li>&#13;
</ul>&#13;
<p>The first example, building a dictionary<span id="dx1-62002"/> once, stems from an application with three operating phases: gather some input, create a <span class="obeylines-h"><span class="verb"><code class="inlineCode">dict</code></span></span> object, and then process input based on the mappings in the dictionary. As an example of this kind of application, we may be doing some image processing and have a specific palette of colors, represented by names and <span class="obeylines-h"><span class="verb"><code class="inlineCode">(R,</code><code class="inlineCode"> G,</code><code class="inlineCode"> B)</code></span></span> tuples. If we use the <span class="keyWord">GNU Image Manipulation Program</span> (<span class="keyWord">GIMP</span>) file format, the color palette may look like the following command snippet:</p>&#13;
<pre id="listing-51" class="lstlisting"><code>GIMP Palette &#13;
Name: Small &#13;
Columns: 3 &#13;
# &#13;
0 0 0 Black &#13;
255 255 255 White &#13;
238 32 77 Red &#13;
28 172 120 Green &#13;
31 117 254 Blue</code></pre>&#13;
<p>The details of parsing this file are the subject of <a href="Chapter_06.xhtml#x1-1260006"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 6</span></a>, <a href="Chapter_06.xhtml#x1-1260006"><span class="cmti-10x-x-109">Recursions and</span> <span class="cmti-10x-x-109">Reductions</span></a>. What’s important is the results of the parsing.</p>&#13;
<p>First, we’ll define a <span class="obeylines-h"><span class="verb"><code class="inlineCode">typing.NamedTuple</code></span></span> class <span class="obeylines-h"><span class="verb"><code class="inlineCode">Color</code></span></span> as follows:</p>&#13;
<pre id="listing-52" class="lstlisting"><code>from typing import NamedTuple &#13;
 &#13;
class Color(NamedTuple): &#13;
    red: int &#13;
    green: int &#13;
    blue: int &#13;
    name: str</code></pre>&#13;
<p>Second, we’ll assume that we have a parser that produces an iterable of <span class="obeylines-h"><span class="verb"><code class="inlineCode">Color</code></span></span> objects. If we materialized it as a tuple, it would look like the following:</p>&#13;
<div id="tcolobox-47" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; palette = [ &#13;
...     Color(red=239, green=222, blue=205, name=’Almond’), &#13;
...     Color(red=205, green=149, blue=117, name=’Antique Brass’), &#13;
...     Color(red=253, green=217, blue=181, name=’Apricot’), &#13;
...     Color(red=197, green=227, blue=132, name=’Yellow Green’), &#13;
...     Color(red=255, green=174, blue=66, name=’Yellow Orange’) &#13;
... ]</code></pre>&#13;
&#13;
</div>&#13;
<p>To locate a given color name quickly, we will create a frozen dictionary from this sequence. This is not the only way to get fast lookups of a color by name. We’ll look at another option later.</p>&#13;
<p>To create a mapping<span id="dx1-62027"/> from an iterable sequence of tuples, we will use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">process(wrap(iterable))</code></span></span> design pattern. The following command shows how we can create the color name mapping:</p>&#13;
<div id="tcolobox-48" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; name_map = dict((c.name, c) for c in palette)</code></pre>&#13;
&#13;
</div>&#13;
<p>Here are three three parts to the design pattern:</p>&#13;
<ul>&#13;
<li><p>The source <span class="cmti-10x-x-109">iterable </span>is the <span class="obeylines-h"><span class="verb"><code class="inlineCode">palette</code></span></span>. We could formalize this with the hint <span class="obeylines-h"><span class="verb"><code class="inlineCode">Iterable[Color]</code></span></span>.</p></li>&#13;
<li><p>The <span class="cmti-10x-x-109">wrap </span>is the <span class="obeylines-h"><span class="verb"><code class="inlineCode">(c.name,</code><code class="inlineCode"> c)</code></span></span> expression to transform a <span class="obeylines-h"><span class="verb"><code class="inlineCode">Color</code></span></span> object to a <span class="obeylines-h"><span class="verb"><code class="inlineCode">tuple[str,</code><code class="inlineCode"> Color]</code></span></span> pair.</p></li>&#13;
<li><p>The <span class="cmti-10x-x-109">process </span>is the <span class="obeylines-h"><span class="verb"><code class="inlineCode">dict()</code></span></span> function to create a mapping.</p></li>&#13;
</ul>&#13;
<p>The resulting dictionary looks as follows:</p>&#13;
<div id="tcolobox-49" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; name_map[’Antique Brass’] &#13;
Color(red=205, green=149, blue=117, name=’Antique Brass’) &#13;
&gt;&gt;&gt; name_map[’Yellow Orange’] &#13;
Color(red=255, green=174, blue=66, name=’Yellow Orange’)</code></pre>&#13;
&#13;
</div>&#13;
<p>This can also be done using a dictionary comprehension. We leave that as an exercise for the reader.</p>&#13;
<p>Now that we’ve materialized the mapping, we can use this <span class="obeylines-h"><span class="verb"><code class="inlineCode">dict()</code></span></span> object in some later processing for repeated transformations from color name to <span class="obeylines-h"><span class="verb"><code class="inlineCode">(R,</code><code class="inlineCode"> G,</code><code class="inlineCode"> B)</code></span></span> color numbers. The lookup will be blazingly<span id="dx1-62035"/> fast because a dictionary does a rapid transformation from key to hash value followed by lookup in the dictionary. <span id="x1-62036r65"/></p>&#13;
</section>&#13;
<section id="using-the-bisect-module-to-create-a-mapping" class="level4 subsectionHead" data-number="0.7.7.3">&#13;
<h4 class="subsectionHead" data-number="0.7.7.3"><span class="titlemark">3.7.3 </span> <span id="x1-630003"/>Using the bisect module to create a mapping</h4>&#13;
<p>In the previous<span id="dx1-63001"/> example, we created a <span class="obeylines-h"><span class="verb"><code class="inlineCode">dict</code></span></span> object to achieve a fast mapping<span id="dx1-63002"/> from a color name to a <span class="obeylines-h"><span class="verb"><code class="inlineCode">Color</code></span></span> object. This isn’t the only choice; we can use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">bisect</code></span></span> module instead. Using the <span class="obeylines-h"><span class="verb"><code class="inlineCode">bisect</code></span></span> module means that we have to create a sorted sequence, which we can then search. To be perfectly compatible with the dictionary implementation, we can use <span class="obeylines-h"><span class="verb"><code class="inlineCode">collections.Mapping</code></span></span> as the base class.</p>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">dict</code></span></span> class uses a hash computation to locate items almost immediately. However, this requires allocating a fairly large block of memory. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">bisect</code></span></span> mapping does a search, which doesn’t require as much memory, but performance cannot be described as immediate. The performance drops from <span class="keyWord">O</span>(1) to <span class="keyWord">O</span>(log <span class="italic">n</span>). While this is dramatic, the savings in memory can be critical for processing large collections of data.</p>&#13;
<p>A static mapping class looks like the following command snippet:</p>&#13;
<pre id="listing-53" class="lstlisting"><code>import bisect &#13;
from collections.abc import Mapping, Iterable &#13;
from typing import Any &#13;
 &#13;
class StaticMapping(Mapping[str, Color]): &#13;
    def __init__(self, &#13;
            iterable: Iterable[tuple[str, Color]] &#13;
    ) -&gt; None: &#13;
        self._data: tuple[tuple[str, Color], ...] = tuple(iterable) &#13;
        self._keys: tuple[str, ...] = tuple(sorted(key for key, _ in self._data)) &#13;
 &#13;
    def __getitem__(self, key: str) -&gt; Color: &#13;
        ix = bisect.bisect_left(self._keys, key) &#13;
        if (ix != len(self._keys) and self._keys[ix] == key): &#13;
            return self._data[ix][1] &#13;
        raise ValueError(f"{key!r} not found") &#13;
 &#13;
    def __iter__(self) -&gt; Iterator[str]: &#13;
        return iter(self._keys) &#13;
 &#13;
    def __len__(self) -&gt; int: &#13;
        return len(self._keys)</code></pre>&#13;
<p>This class extends<span id="dx1-63025"/> the abstract<span id="dx1-63026"/> superclass <span class="obeylines-h"><span class="verb"><code class="inlineCode">collections.Mapping</code></span></span>. It provides an initialization and implementations for three functions missing from the abstract definition. The type of <span class="obeylines-h"><span class="verb"><code class="inlineCode">tuple[str,</code><code class="inlineCode"> Color]</code></span></span> defines a specific kind of two-tuple expected by this mapping.</p>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">__getitem__()</code></span></span> method uses the <span class="obeylines-h"><span class="verb"><code class="inlineCode">bisect.bisect_left()</code></span></span> function to search the collection of keys. If the key is found, the appropriate value is returned. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">__iter__()</code></span></span> method returns an iterator, as required by the superclass. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">__len__()</code></span></span> method, similarly, provides the required length of the collection.</p>&#13;
<p>This class may not seem to embody too many functional programming principles. Our goal here is to support a larger application that minimizes the use of stateful variables. This class saves a static collection of key-value pairs. As an optimization, it materializes two objects.</p>&#13;
<p>An application would create an instance of this class to perform relatively rapid lookups of values associated with keys. The superclass does not support updates to the object. The collection, as a whole, is stateless. It’s not as fast as the built-in <span class="obeylines-h"><span class="verb"><code class="inlineCode">dict</code></span></span> class, but it uses less memory and, through the formality of being a subclass of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">Mapping</code></span></span> class, we can be assured that this object is not used to contain a processing state. <span id="x1-63027r66"/></p>&#13;
</section>&#13;
<section id="using-stateful-sets" class="level4 subsectionHead" data-number="0.7.7.4">&#13;
<h4 class="subsectionHead" data-number="0.7.7.4"><span class="titlemark">3.7.4 </span> <span id="x1-640004"/>Using stateful sets</h4>&#13;
<p>Python offers several<span id="dx1-64001"/> stateful collections, including the <span class="obeylines-h"><span class="verb"><code class="inlineCode">set</code></span></span> collection. For our purposes, there are two use cases for a set:</p>&#13;
<ul>&#13;
<li><p>A stateful <span class="obeylines-h"><span class="verb"><code class="inlineCode">set</code></span></span> that accumulates items</p></li>&#13;
<li><p><span class="obeylines-h"><span class="verb"><code class="inlineCode">frozenset</code></span></span>, which can be used to optimize searches for an item</p></li>&#13;
</ul>&#13;
<p>We can create <span class="obeylines-h"><span class="verb"><code class="inlineCode">frozenset</code></span></span> from an iterable in the same way we create a tuple object from an iterable, via a <span class="obeylines-h"><span class="verb"><code class="inlineCode">frozenset(some_iterable)</code></span></span> expression; this will create a structure that has the advantage of a very fast <span class="obeylines-h"><span class="verb"><code class="inlineCode">in</code></span></span> operator. This can be used in an application that gathers data, creates a set, and then uses a <span class="obeylines-h"><span class="verb"><code class="inlineCode">frozenset</code></span></span> to match other data items against the set.</p>&#13;
<p>We may have a set of colors<span id="dx1-64002"/> that we will use as a kind of <span class="keyWord">chroma-key</span>: we will use this color to create a mask that will be used to combine two images. Pragmatically, a single color isn’t appropriate, but a small set of very similar colors works best. In this case, we can examine each pixel of an image file to see if the pixel is in the chroma-key set or not. For this kind of processing, the chroma-key colors can be loaded into <span class="obeylines-h"><span class="verb"><code class="inlineCode">frozenset</code></span></span> before processing the target images. The set lookup is extremely fast.</p>&#13;
<p>As with mappings—specifically the <span class="obeylines-h"><span class="verb"><code class="inlineCode">Counter</code></span></span> class—there are some algorithms that can benefit from a memoized set of values. Some functions benefit from memoization because a function is a mapping between domain values and range values, a job where mapping works well. A few algorithms benefit from a memoized set, which is stateful and grows as data is processed.</p>&#13;
<p>We’ll return to memoization in <a href="Chapter_10.xhtml#x1-21700010"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 10</span></a>, <a href="Chapter_10.xhtml#x1-21700010"><span class="cmti-10x-x-109">The Functools Module</span></a>. <span id="x1-64003r63"/></p>&#13;
</section>&#13;
</section>&#13;
<section id="summary-2" class="level3 sectionHead" data-number="0.7.8">&#13;
<h3 class="sectionHead" data-number="0.7.8"><span class="titlemark">3.8 </span> <span id="x1-650008"/>Summary</h3>&#13;
<p>In this chapter, we looked again at writing pure functions free of side effects. We looked at generator functions and how we can use these as the backbone of functional programming to process collections of items. We also examined a number of the built-in collection classes to show how they’re used in the functional paradigm. While the general idea behind functional programming is to limit the use of stateful variables, the collection objects have a stateful implementation. For many algorithms, they’re often essential. Our goal is to be judicious in our use of Python’s non-functional features.</p>&#13;
<p>In the next two chapters, we’ll look at functions for processing collections. After that, we’ll look closely at higher-order functions: functions that accept functions as arguments as well as returning functions. In later chapters, we’ll look at techniques for defining our own higher-order functions. We’ll also look at the <span class="obeylines-h"><span class="verb"><code class="inlineCode">itertools</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">functools</code></span></span> modules and their higher-order functions in later chapters. <span id="x1-65001r68"/></p>&#13;
</section>&#13;
<section id="exercises-2" class="level3 sectionHead" data-number="0.7.9">&#13;
<h3 class="sectionHead" data-number="0.7.9"><span class="titlemark">3.9 </span> <span id="x1-660009"/>Exercises</h3>&#13;
<p>This chapter’s exercises are based on code available from Packt Publishing on GitHub. See <a href="https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition" class="url">https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition</a>.</p>&#13;
<p>In some cases, the reader will notice that the code provided on GitHub includes partial solutions to some of the exercises. These serve as hints, allowing the reader to explore alternative solutions.</p>&#13;
<p>In many cases, exercises will need unit test cases to confirm they actually solve the problem. These are often identical to the unit test cases already provided in the GitHub repository. The reader should replace the book’s example function name with their own solution to confirm that it works. <span id="x1-66001r67"/></p>&#13;
<section id="rewrite-the-some_function-function" class="level4 subsectionHead" data-number="0.7.9.1">&#13;
<h4 class="subsectionHead" data-number="0.7.9.1"><span class="titlemark">3.9.1 </span> <span id="x1-670001"/>Rewrite the some_function() function</h4>&#13;
<p>In the <a href="#x1-520001"><span class="cmti-10x-x-109">Writing pure functions</span></a> section, a function was shown that relied on a global variable.</p>&#13;
<p>Create a small application that sets the global variable and calls the function. The application can expand on the following example:</p>&#13;
<pre id="listing-54" class="lstlisting"><code>def some_function ... &#13;
 &#13;
def main(): &#13;
    """ &#13;
    &gt;&gt;&gt; main() &#13;
    some_function(2, 3, 5)=30 &#13;
    some_function(2, 3, 5)=34 &#13;
    """ &#13;
    global global_adjustment &#13;
    global_adjustment = 13 &#13;
    print(f"{some_function(2, 3, 5)=}") &#13;
    global_adjustment = 17 &#13;
    print(f"{some_function(2, 3, 5)=}") &#13;
 &#13;
    if __name__ == "__main__": &#13;
        main()</code></pre>&#13;
<p>First, create a test suite for <span class="obeylines-h"><span class="verb"><code class="inlineCode">some_function()</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">main()</code></span></span>. A <span class="obeylines-h"><span class="verb"><code class="inlineCode">doctest</code></span></span> suite embedded in docstring is shown in the example.</p>&#13;
<p>Second, rewrite <span class="obeylines-h"><span class="verb"><code class="inlineCode">some_function()</code></span></span> to make <span class="obeylines-h"><span class="verb"><code class="inlineCode">global_adjustment</code></span></span> into a parameter. This will lead to revising <span class="obeylines-h"><span class="verb"><code class="inlineCode">main()</code></span></span> and all of the test cases. <span id="x1-67017r70"/></p>&#13;
</section>&#13;
<section id="alternative-mersenne-class-definition" class="level4 subsectionHead" data-number="0.7.9.2">&#13;
<h4 class="subsectionHead" data-number="0.7.9.2"><span class="titlemark">3.9.2 </span> <span id="x1-680002"/>Alternative Mersenne class definition</h4>&#13;
<p>The examples in the <a href="#x1-530002"><span class="cmti-10x-x-109">Functions as first-class objects</span></a> section show a <span class="obeylines-h"><span class="verb"><code class="inlineCode">Mersenne1</code></span></span> class that accepts a function as a parameter to the <span class="obeylines-h"><span class="verb"><code class="inlineCode">__init__()</code></span></span> method.</p>&#13;
<p>An alternative is to provide a plug-in <span class="keyWord">Strategy </span>function as part of the class definition.</p>&#13;
<p>This would permit the following kinds of object definitions:</p>&#13;
<div id="tcolobox-50" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code> &#13;
&gt;&gt;&gt; class ShiftyMersenne(Mersenne2): &#13;
...     pow2 = staticmethod(shifty) &#13;
 &#13;
&gt;&gt;&gt; m2s = ShiftyMersenne() &#13;
&gt;&gt;&gt; m2s(17) &#13;
131071</code></pre>&#13;
&#13;
</div>&#13;
<p>The use of <span class="obeylines-h"><span class="verb"><code class="inlineCode">staticmethod()</code></span></span> is essential because the <span class="obeylines-h"><span class="verb"><code class="inlineCode">shifty()</code></span></span> function does not expect the <span class="obeylines-h"><span class="verb"><code class="inlineCode">self</code></span></span> argument when it is evaluated. It’s essential to make sure this function is understood as being ”static”—that is, not using a <span class="obeylines-h"><span class="verb"><code class="inlineCode">self</code></span></span> parameter. <span id="x1-68007r71"/></p>&#13;
</section>&#13;
<section id="alternative-algorithm-implementations" class="level4 subsectionHead" data-number="0.7.9.3">&#13;
<h4 class="subsectionHead" data-number="0.7.9.3"><span class="titlemark">3.9.3 </span> <span id="x1-690003"/>Alternative algorithm implementations</h4>&#13;
<p>Consider the following algorithm:</p>&#13;
<div class="algorithm">&#13;
<figure>&#13;
<img src="../Images/Algo_3.1.JPG" class="frac" data-align="middle" alt="Algorithm 4: Imperative iteration "/>&#13;
<figcaption aria-hidden="true"><span class="id">Algorithm 4: </span><span class="content">Imperative iteration </span></figcaption>&#13;
</figure>&#13;
</div>&#13;
<p>As we’ve seen in this chapter, there are three ways to write this in Python:</p>&#13;
<ul>&#13;
<li><p>As a <span class="obeylines-h"><span class="verb"><code class="inlineCode">for</code></span></span> statement that updates stateful variables</p></li>&#13;
<li><p>As a generator expression</p></li>&#13;
<li><p>As a <span class="obeylines-h"><span class="verb"><code class="inlineCode">map()</code></span></span> operation to apply the function</p></li>&#13;
</ul>&#13;
<p>Write all three versions in Python.</p>&#13;
<p>A test case is the following data:</p>&#13;
<div class="math-display" style="text-align:center">&#13;
<img src="../Images/file32.jpg" class="math-display" alt="V ← {7.46,6.77,12.74,7.11,7.81,8.84,6.08,5.39,8.15,6.42,5.73} "/>&#13;
</div>&#13;
<p>And the following scaling function:</p>&#13;
<div class="math-display" style="text-align:center">&#13;
<img src="../Images/file33.jpg" class="math-display" alt=" (v-−-7.5) f(v) = 2.031 "/>&#13;
</div>&#13;
<p>The computed value for <span class="italic">m </span>is approximately zero. <span id="x1-69003r72"/></p>&#13;
</section>&#13;
<section id="map-and-filter" class="level4 subsectionHead" data-number="0.7.9.4">&#13;
<h4 class="subsectionHead" data-number="0.7.9.4"><span class="titlemark">3.9.4 </span> <span id="x1-700004"/>Map and filter</h4>&#13;
<p>The built-in <span class="obeylines-h"><span class="verb"><code class="inlineCode">map()</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">filter()</code></span></span> functions always have an equivalent generator expression. In order to have consistent-looking code, a project team is wrestling with the idea of insisting that all code use generator expressions, avoiding the built-in <span class="obeylines-h"><span class="verb"><code class="inlineCode">map()</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">filter()</code></span></span> functions.</p>&#13;
<ol>&#13;
<li><div id="x1-70002x1">&#13;
<p>Take the side of only using generator expressions and provide reasons for which this is advantageous.</p>&#13;
</div></li>&#13;
<li><div id="x1-70004x2">&#13;
<p>Take the side of only using built-in <span class="obeylines-h"><span class="verb"><code class="inlineCode">map()</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">filter()</code></span></span> functions and provide reasons why this alternative might be advantageous.</p>&#13;
</div></li>&#13;
<li><div id="x1-70006x3">&#13;
<p>In looking at the reasons for the first two parts of this exercise, is there a clearly articulated decision on which approach is better? If not, why not? If so, what rule should the team use?</p>&#13;
</div></li>&#13;
</ol>&#13;
<p><span id="x1-70007r74"/></p>&#13;
</section>&#13;
<section id="dictionary-comprehension" class="level4 subsectionHead" data-number="0.7.9.5">&#13;
<h4 class="subsectionHead" data-number="0.7.9.5"><span class="titlemark">3.9.5 </span> <span id="x1-710005"/>Dictionary comprehension</h4>&#13;
<p>In the <a href="#x1-620002"><span class="cmti-10x-x-109">Using stateful mappings</span></a> section, we built a mapping from a list of two-tuples. We can also build a mapping using a dictionary comprehension. Rewrite the expression <span class="obeylines-h"><span class="verb"><code class="inlineCode">dict((c.name,</code><code class="inlineCode"> c)</code><code class="inlineCode"> for</code><code class="inlineCode"> c</code><code class="inlineCode"> in</code><code class="inlineCode"> palette)</code></span></span> as a dictionary comprehension. <span id="x1-71001r75"/></p>&#13;
</section>&#13;
<section id="raw-data-cleanup" class="level4 subsectionHead" data-number="0.7.9.6">&#13;
<h4 class="subsectionHead" data-number="0.7.9.6"><span class="titlemark">3.9.6 </span> <span id="x1-720006"/>Raw data cleanup</h4>&#13;
<p>A file, <span class="obeylines-h"><span class="verb"><code class="inlineCode">Anscombe.txt</code></span></span>, is almost a valid CSV format file. The problem is there are three lines of useless text at the beginning. The lines are easy to recognize because applying the <span class="obeylines-h"><span class="verb"><code class="inlineCode">float()</code></span></span> function to the values in those header rows will raise a <span class="obeylines-h"><span class="verb"><code class="inlineCode">ValueError</code></span></span> exception.</p>&#13;
<p>Some team members suggest using a regular expression to examine the values to see if they are valid numbers. This can be called Look Before You Leap (LBYL):</p>&#13;
<div class="algorithm">&#13;
<figure>&#13;
<img src="../Images/Algo_3.2.JPG" class="frac" data-align="middle" alt="Algorithm 4: Imperative iteration "/>&#13;
&#13;
</figure>&#13;
</div>&#13;
<p>Other team members suggest using a simpler <span class="obeylines-h"><span class="verb"><code class="inlineCode">try:</code></span></span> statement to uncover the invalid non-numeric headers and discard them. This can be called Easier to Ask Forgiveness Than Permission (EAFP):</p>&#13;
<div class="algorithm">&#13;
<figure>&#13;
<img src="../Images/Algo_3.3.JPG" class="frac" data-align="middle" alt="Algorithm 4: Imperative iteration "/>&#13;
&#13;
</figure>&#13;
</div>&#13;
<p>Both algorithms work. It’s instructive to implement each one in Python to compare them. Here are a few starting points for comparing the algorithms:</p>&#13;
<ul>&#13;
<li><p>The LBYL variant can rely entirely on generator expressions. However, it requires writing a regular expression that recognizes all possible floating-point values. Is this a responsibility that should be part of this application?</p></li>&#13;
<li><p>The EAFP variant needs a separate function to implement the <span class="obeylines-h"><span class="verb"><code class="inlineCode">try:</code></span></span> statement processing. Otherwise, it seems amenable to also being written via generator expressions or the <span class="obeylines-h"><span class="verb"><code class="inlineCode">map()</code></span></span> function.</p></li>&#13;
</ul>&#13;
<p>After building the two variants, which seems to be more expressive of the purpose of filtering and acquiring data?</p>&#13;
</section>&#13;
</section>&#13;
<section id="join-our-community-discord-space-3" class="level3 likesectionHead" data-number="0.7.10">&#13;
<h3 class="likesectionHead" data-number="0.7.10"><span id="x1-730006"/>Join our community Discord space</h3>&#13;
<p>Join our Python Discord workspace to discuss and know more about the book: <a href="https://packt.link/dHrHU">https://packt.link/dHrHU</a></p>&#13;
<p><img src="../Images/file1.png" alt="PIC" width="85" height="85"/></p>&#13;
<p><span id="x1-73001r54"/></p>&#13;
</section>&#13;
</section>&#13;
</body></html>