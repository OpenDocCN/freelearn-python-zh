- en: Chapter 15. Next Steps
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 15 章。下一步
- en: After studying the Python basics, what's next? Each developer's journey will
    vary, based on the general architecture of the application that they're going
    to build. In this chapter, we'll look at four kinds of Python applications. We'll
    look at **command-line interface** (**CLI**) applications in some depth. We'll
    look briefly at **graphical user interface** (**GUI**) applications. There are
    a number of graphics libraries and a number of frameworks that we might use for
    this; it's difficult to address all of the alternatives.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习 Python 基础之后，接下来是什么？每个开发者的旅程将因他们将要构建的应用程序的一般架构而异。在本章中，我们将探讨四种类型的 Python 应用程序。我们将深入探讨
    **命令行界面**（**CLI**）应用程序。我们也会简要地看看 **图形用户界面**（**GUI**）应用程序。我们可以使用许多图形库和框架来完成这项工作；很难涵盖所有替代方案。
- en: Web server applications often involve a sophisticated web framework that handles
    the standardized overheads. Our Python code will plug into this framework. As
    with GUI applications, there are several commonly used frameworks. We'll look
    quickly at a few common features of web frameworks. We'll also look at the big
    data context as epitomized by the Hadoop server's streaming interface.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 网络服务器应用程序通常涉及一个复杂的网络框架，该框架处理标准化的开销。我们的 Python 代码将连接到这个框架。与 GUI 应用程序一样，有几个常用的框架。我们将快速查看网络框架的一些常见功能。我们还将探讨以
    Hadoop 服务器流式接口为代表的大数据环境。
- en: This isn't intended to be complete or even representative. Python is used in
    many different ways.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是要全面或具有代表性。Python 被以许多不同的方式使用。
- en: Leveraging the standard library
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用标准库
- en: When implementing Python solutions, it's helpful to scan the standard library
    for relevant modules. The library is large, making it somewhat intimidating at
    first. We can, however, focus our search.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现 Python 解决方案时，扫描标准库以查找相关模块是有帮助的。这个库很大，一开始可能会让人感到有些畏惧。然而，我们可以集中我们的搜索。
- en: We can break the *Python Standard Library* document into three portions. The
    first five chapters are general reference material that all Python programmers
    need to understand. The next 20 chapters, plus chapters 28 and 32, describe modules
    that we might incorporate into a wide variety of applications. The remaining chapters
    are less useful; they're more focused on Python internals and ways in which to
    extend the language itself.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将 *Python 标准库* 文档分为三个部分。前五章是所有 Python 程序员都需要了解的一般参考材料。接下来的 20 章以及第 28 章和第
    32 章描述了我们可能将其纳入各种应用程序的模块。剩下的章节不太有用；它们更多地关注 Python 的内部结构和扩展语言本身的方法。
- en: The name and the summary of a module in the library table of contents may not
    provide enough information to see all of the ways in which a module might be used.
    The `bisect` module, for example, can be extended to create a fast dictionary
    that retains its keys in a defined order. This isn't obvious without careful reading
    of the description of the module.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 库目录表中的模块名称和摘要可能不足以展示模块可能被使用的所有方式。例如，`bisect` 模块可以被扩展来创建一个快速字典，该字典保留其键的既定顺序。如果不仔细阅读模块的描述，这一点并不明显。
- en: Some of the library modules have relatively small, easy-to-understand implementations.
    For larger modules and packages, there are often pieces that can be lifted out
    of context and reused widely. As an example, consider an application that uses
    `http.client` to make REST web services requests. We often need functions from
    the `urllib.parse` module to encode a query string or properly quote parts of
    the URL. It's common to see a long list of imports at the front of Python applications.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 一些库模块具有相对较小、易于理解的实现。对于较大的模块和包，通常有一些可以从上下文中提取出来并广泛重用的部分。例如，考虑一个使用 `http.client`
    来进行 REST 网络服务请求的应用程序。我们经常需要 `urllib.parse` 模块中的函数来编码查询字符串或正确引用 URL 的部分。在 Python
    应用程序的前端通常可以看到一个长长的导入列表。
- en: Leveraging PyPI – the Python Package Index
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用 PyPI – Python 包索引
- en: After scanning the library, the next place to look for additional Python packages
    is the **Python Package Index** (**PyPI**) at [https://pypi.python.org/pypi](https://pypi.python.org/pypi).
    There are thousands of packages listed here, with varying degrees of support and
    quality.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在扫描库之后，寻找更多 Python 包的下一个地方是位于 [https://pypi.python.org/pypi](https://pypi.python.org/pypi)
    的 **Python 包索引**（**PyPI**）。这里列出了数千个包，它们的支持和质量各不相同。
- en: As we noted in [Chapter 1](ch01.html "Chapter 1. Getting Started"), *Getting
    Started*, Python 3.4 also installs two scripts to help us add packages, `pip`
    and `easy_install`. These search PyPI for the requested package. Most packages
    can be found by using their name; the tools locate the appropriate release for
    the platform and Python version.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在[第1章](ch01.html "第1章。入门")中所述，*入门*，Python 3.4还安装了两个脚本来帮助我们添加包，`pip`和`easy_install`。这些工具在PyPI上搜索请求的包。大多数包可以通过使用它们的名称找到；工具定位适合平台和Python版本的适当版本。
- en: 'We''ve mentioned a few external libraries in other chapters:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在其他章节中提到了一些外部库：
- en: '`nose` for writing tests, see [https://pypi.python.org/pypi/nose/1.3.6](https://pypi.python.org/pypi/nose/1.3.6)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`nose`编写测试，请参阅[https://pypi.python.org/pypi/nose/1.3.6](https://pypi.python.org/pypi/nose/1.3.6)
- en: '`docutils` for writing documentation, see [https://pypi.python.org/pypi/docutils/0.12](https://pypi.python.org/pypi/docutils/0.12)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`docutils`编写文档，请参阅[https://pypi.python.org/pypi/docutils/0.12](https://pypi.python.org/pypi/docutils/0.12)
- en: '`Sphinx` for writing complex documentation, see [https://pypi.python.org/pypi/Sphinx/1.3.1](https://pypi.python.org/pypi/Sphinx/1.3.1)'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Sphinx`编写复杂文档，请参阅[https://pypi.python.org/pypi/Sphinx/1.3.1](https://pypi.python.org/pypi/Sphinx/1.3.1)
- en: 'Additionally, there are bundles of packages available: we might install Anaconda,
    NumPy, or SciPy, each of which includes a number of other packages in one tidy
    distribution. See [http://continuum.io/downloads](http://continuum.io/downloads),
    [http://www.numpy.org](http://www.numpy.org), or [http://www.scipy.org](http://www.scipy.org).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有许多包集合可用：我们可能会安装Anaconda、NumPy或SciPy，每个都包含一个整洁的分发中的多个其他包。请参阅[http://continuum.io/downloads](http://continuum.io/downloads)、[http://www.numpy.org](http://www.numpy.org)或[http://www.scipy.org](http://www.scipy.org)。
- en: In some cases, we may have Python configurations that are incompatible with
    each other. For example, we may have to work in two environments, one using the
    older Beautiful Soup 3 with the other using the newer version 4\. Refer to [https://pypi.python.org/pypi/beautifulsoup4/4.3.2](https://pypi.python.org/pypi/beautifulsoup4/4.3.2).
    To simplify this switch, we can use the `virtualenv` tool to create isolated Python
    environments with their own complex trees of interdependent modules. See [https://virtualenv.pypa.io/en/latest/](https://virtualenv.pypa.io/en/latest/).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可能有一些相互不兼容的Python配置。例如，我们可能需要在两个环境中工作，一个使用较旧的Beautiful Soup 3，另一个使用较新的版本4。请参阅[https://pypi.python.org/pypi/beautifulsoup4/4.3.2](https://pypi.python.org/pypi/beautifulsoup4/4.3.2)。为了简化这个切换，我们可以使用`virtualenv`工具创建具有自己复杂依赖模块树的隔离Python环境。请参阅[https://virtualenv.pypa.io/en/latest/](https://virtualenv.pypa.io/en/latest/)。
- en: The Python ecosystem is large and sophisticated. There's no good reason to invent
    a solution in a vacuum. It's often best to locate the appropriate components or
    partial solutions, then download and extend them.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Python生态系统庞大而复杂。没有好的理由在真空中发明解决方案。通常最好找到适当的组件或部分解决方案，然后下载并扩展它们。
- en: Types of applications
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序类型
- en: We'll look at four types of Python applications. These are neither the most
    common nor the most popular kinds of Python applications; they were selected more
    or less randomly based on the author's narrow experience. Python is used widely,
    and any attempt to summarize all of the various places where Python is used runs
    the risk of misleading rather than informing.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨四种类型的Python应用程序。这些既不是最常见的也不是最受欢迎的Python应用程序类型；它们是根据作者的有限经验随机选择的。Python被广泛使用，任何试图总结Python被使用的各种地方的努力都有误导而不是提供信息的风险。
- en: We'll look at CLI applications for two reasons. Firstly, they can be relatively
    simple, relying on fewer additional packages or frameworks than other kinds of
    applications. Secondly, more complex applications will often be launched from
    a CLI main script. For these reasons, the CLI features seem to be fundamental
    to most uses of Python.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨CLI应用程序的两个原因。首先，它们可能相对简单，比其他类型的应用程序依赖更少的额外包或框架。其次，更复杂的应用程序通常从CLI主脚本启动。出于这些原因，CLI功能似乎对Python的大多数使用都是基本的。
- en: 'We''ll look at GUI applications because they are popular on the desktop. The
    difficulty here is that there are many GUI frameworks available for Python software
    development. Here''s one list: [https://wiki.python.org/moin/GuiProgramming](https://wiki.python.org/moin/GuiProgramming).
    We''ll focus on the `turtle` package because it''s simple and built-in.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨GUI应用程序，因为它们在桌面电脑上很受欢迎。这里的困难在于，Python软件开发中有许多可用的GUI框架。以下是一个列表：[https://wiki.python.org/moin/GuiProgramming](https://wiki.python.org/moin/GuiProgramming)。我们将重点关注`turtle`包，因为它简单且内置。
- en: 'We''ll look at web applications because Python is used with frameworks such
    as Django or Flask (among many others) to build high-volume websites. Here''s
    a list of Python web frameworks: [https://wiki.python.org/moin/WebFrameworks](https://wiki.python.org/moin/WebFrameworks).
    We''ll focus on Flask because it''s relatively simple.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨Web应用程序，因为Python与Django或Flask（以及其他许多框架）一起用于构建高流量网站。以下是一个Python Web框架列表：[https://wiki.python.org/moin/WebFrameworks](https://wiki.python.org/moin/WebFrameworks)。我们将重点关注Flask，因为它相对简单。
- en: We'll also look at how Python can be used with Hadoop streaming to perform data
    analytics. Rather than download and install Apache Hadoop, we'll touch on how
    we build and test pipelined map-reduce processing on our desktop.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将探讨如何使用Python与Hadoop流进行数据分析。我们不会下载和安装Apache Hadoop，而是简要介绍如何在我们的桌面上构建和测试管道映射-归约处理。
- en: Building CLI applications
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建命令行应用程序
- en: 'Our focus from the initial script example in [Chapter 1](ch01.html "Chapter 1. Getting
    Started"), *Getting Started*, was on using CLI scripting to learn Python basics.
    CLI applications have a number of common features:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 从[第1章](ch01.html "第1章。入门")的初始脚本示例“入门”中，我们的重点是使用CLI脚本学习Python基础知识。CLI应用程序具有许多共同特性：
- en: They often read from the standard input file, write to a standard output file,
    and produce logs or errors in the standard error file. The OS assures us that
    these files are always available. Python provides them as `sys.stdin`, `sys.stdout`,
    and `sys.stderr`. Furthermore, functions such as `input()` and `print()` use these
    files by default.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们通常从标准输入文件读取，写入标准输出文件，并在标准错误文件中产生日志或错误。操作系统保证这些文件始终可用。Python通过`sys.stdin`、`sys.stdout`和`sys.stderr`提供它们。此外，`input()`和`print()`等函数默认使用这些文件。
- en: They often use environment variables for configuration. These values are available
    through `os.environ`.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们通常使用环境变量进行配置。这些值通过`os.environ`可用。
- en: They may also rely on shell features, like expanding `~` into a user's home
    directory, something done by `os.path.expanduser()`.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们也可能依赖于shell功能，如将`~`扩展为用户的家目录，这是由`os.path.expanduser()`完成的。
- en: They often parse command-line arguments. While the variable `sys.argv` has the
    argument strings, these are awkward to work with directly. We'll use the `argparse`
    module to define the argument patterns, parse the strings, and create an object
    with the relevant argument values.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们通常解析命令行参数。虽然变量`sys.argv`包含参数字符串，但直接使用它们很麻烦。我们将使用`argparse`模块来定义参数模式，解析字符串，并创建一个包含相关参数值的对象。
- en: These basic features cover many programming alternatives. A web server, for
    example, can be thought of as a CLI program that runs forever, servicing requests
    that come from a specific port number. A GUI application might start from the
    command line, but then open windows to permit user interaction.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这些基本功能涵盖了多种编程选择。例如，一个网络服务器可以被视为一个永远运行的CLI程序，它从特定的端口号接收请求。一个GUI应用程序可能从命令行开始，但随后打开窗口以允许用户交互。
- en: Getting command-line arguments with argparse
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用argparse获取命令行参数
- en: We'll create a parser to use the command-line arguments, using the `argparse`
    module. Once configured, we can use that parser to create a small namespace object
    which has all of the argument values that were provided on the command line, or
    has default values. Our application can use this object to control its behavior.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`argparse`模块创建一个解析器来使用命令行参数。一旦配置完成，我们可以使用这个解析器创建一个小的命名空间对象，该对象包含在命令行上提供的所有参数值，或者包含默认值。我们的应用程序可以使用这个对象来控制其行为。
- en: 'Generally, we want to isolate command-line handling from the rest of our application.
    Here''s a function that handles parsing, and then uses the parsed options to invoke
    another function to do the real work:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们希望将命令行处理与我们的应用程序的其他部分隔离开。以下是一个处理解析的函数，然后使用解析的选项调用另一个函数来完成实际工作：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We've built an `ArgumentParser` method using all of the default parameters.
    We could have identified the program name, provided a summary of usage, or have
    had anything else displayed when someone uses the `-h` option to get help. We
    omitted these extra bits of documentation to keep the example small.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用所有默认参数构建了一个`ArgumentParser`方法。我们本可以识别程序名称，提供使用说明，或者当有人使用`-h`选项获取帮助时显示任何其他内容。我们省略了这些额外的文档，以保持示例简洁。
- en: 'We''ve defined two arguments for this application: an optional argument and
    a positional argument. The optional argument, `-v` or `--verbose`, stores a constant
    value in the resulting collection of options. The name of this attribute is the
    long name of the argument, `verbose`. The constant provided is `logging.DEBUG`;
    the default value if the option isn''t present is `logging.INFO`.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为这个应用程序定义了两个参数：一个可选参数和一个位置参数。可选参数`-v`或`--verbose`在结果选项集合中存储一个常量值。这个属性的名称是参数的长名称，即`verbose`。提供的常量是`logging.DEBUG`；如果选项不存在，则默认值为`logging.INFO`。
- en: The positional argument, `c`, accepts one command-line argument after all of
    the options have been parsed. The value for `nargs` can be omitted; it can be
    `'*'` to collect all arguments. We've provided a requirement that the input value
    is converted by the `float()` function, which means that non-numeric values will
    be rejected with an error during argument parsing. This will be set as the `c`
    attribute of the resulting object.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 位置参数`c`在解析完所有选项之后接受一个命令行参数。`nargs`的值可以省略；它可以设置为`'*'`以收集所有参数。我们提供了一个要求，即输入值通过`float()`函数转换，这意味着在参数解析期间将拒绝非数值值并显示错误。这将设置为结果对象的`c`属性。
- en: When we evaluate the `parse_args()` method, the defined arguments are used to
    parse the command-line values in `sys.argv`. The `options` object will have the
    resulting values or defaults.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们评估`parse_args()`方法时，定义的参数用于解析`sys.argv`中的命令行值。`options`对象将具有结果值或默认值。
- en: In the second part of `main()`, we've used the `options` object to set the logging
    level for the root logger using the `verbose` argument value. We've then used
    a global `logger` object to dump the single positional argument value that will
    be assigned to the `c` attribute of the `options` object.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main()`函数的第二部分，我们使用`options`对象通过`verbose`参数值设置根日志记录器的日志级别。然后我们使用全局`logger`对象将单个位置参数值输出，该值将被分配给`options`对象的`c`属性。
- en: Finally, we've evaluated our application function with the input argument value;
    the parser assigned this to the `options.c` variable. The function which does
    the real work is designed to be entirely separate from the command-line interface
    that is used to invoke it. The function accepts a floating-point value and prints
    a result to a standard output. It can leverage the module global `logger` object.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用输入参数值评估我们的应用程序函数；解析器将此分配给`options.c`变量。执行实际工作的函数设计为完全独立于用于调用它的命令行界面。该函数接受一个浮点值并将结果打印到标准输出。它可以利用模块全局`logger`对象。
- en: Our goal in designing a CLI application is to completely separate the useful
    work from all interface considerations. This allows us to import the function
    which does the real work, and build larger or more complex applications from individual
    pieces. It generally means that the command-line arguments are transformed into
    ordinary function arguments or class constructor arguments.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设计命令行应用程序的目标是将有用的工作与所有界面考虑完全分离。这允许我们导入执行实际工作的函数，并从单个组件构建更大或更复杂的应用程序。这通常意味着命令行参数被转换为普通函数参数或类构造函数参数。
- en: Using the cmd module for interactive applications
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用cmd模块进行交互式应用程序
- en: Some CLI applications require user interaction. The `sftp` command, for example,
    can be used from the command line to exchange files with a server. We can create
    similar interactive applications using Python's `cmd` module.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一些命令行应用程序需要用户交互。例如，`sftp`命令可以从命令行使用，以与服务器交换文件。我们可以使用Python的`cmd`模块创建类似交互式应用程序。
- en: To build a more complex interactive application, we can create a class which
    extends the `cmd.Cmd` class. Each method in this class that has a name starting
    with `do_` defines an interactive command. For example, if we define a method
    `do_get()`, this means that our application now has an interactive `get` command.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建更复杂的交互式应用程序，我们可以创建一个扩展`cmd.Cmd`类的类。这个类中任何以`do_`开头命名的函数定义了一个交互式命令。例如，如果我们定义了一个方法`do_get()`，这意味着我们的应用程序现在有一个交互式的`get`命令。
- en: Any subsequent text after the user's input of `get` will be provided as an argument
    to the `do_get()` method. The `do_get()` function is then responsible for any
    further parsing and processing of the text after the command.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 用户输入`get`命令后的任何后续文本都将作为参数提供给`do_get()`方法。然后`do_get()`函数负责对命令之后的文本进行进一步解析和处理。
- en: We can create an instance of this class, and call that inherited `cmdloop()`
    method to have a working interactive application. This allows us to deploy a working,
    interactive application very quickly and simply. While we're limited to a character-mode,
    command-line interface, we can easily add features without much extra work.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建此类的一个实例，并调用继承的 `cmdloop()` 方法来拥有一个工作着的交互式应用程序。这使我们能够非常快速和简单地部署一个工作着的交互式应用程序。虽然我们受限于字符模式、命令行界面，但我们可以轻松地添加功能而无需做太多额外的工作。
- en: Building GUI applications
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建 GUI 应用程序
- en: We can differentiate between applications which merely work with graphics and
    applications which are deeply interactive. In the first case, we might have a
    command-line application which creates or modifies image files. In the second
    case, we'll define an application which responds to input events. These interactive
    applications create an event loop which accepts mouse clicks, screen gestures,
    keyboard characters, and other events, and responds to those events. In some respects,
    the only unique feature of a GUI program is the wide variety of events it responds
    to.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以区分仅与图形工作以及深度交互的应用程序。在前一种情况下，我们可能有一个命令行应用程序，它创建或修改图像文件。在第二种情况下，我们将定义一个响应输入事件的程序。这些交互式应用程序创建一个事件循环，它接受鼠标点击、屏幕手势、键盘字符和其他事件，并对这些事件做出响应。在某种程度上，GUI
    程序的唯一独特特性是它响应事件的广泛多样性。
- en: The `tkinter` module is an interface between Python and the **Tk** user interface
    widget toolkit. This module helps us build richly interactive applications. When
    we use Python's built-in IDLE editor, we're using an application that was built
    with `tkinter`. The `tkinter` module documentation includes background information
    on the **Tk** widgets.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`tkinter` 模块是 Python 和 **Tk** 用户界面小部件工具包之间的接口。此模块帮助我们构建丰富的交互式应用程序。当我们使用 Python
    内置的 IDLE 编辑器时，我们正在使用一个用 `tkinter` 构建的应用程序。`tkinter` 模块文档包括关于 **Tk** 小部件的背景信息。'
- en: The `turtle` module also depends on the underlying **Tk** graphics. This module
    also allows us to build simple interactive applications. The turtle idea comes
    from the Logo programming language, in which graphic commands are used to animate
    a "turtle" which traverses the drawing space. The `turtle` model provides a very
    handy specification for certain types of graphics. For example, drawing a rotated
    rectangle can involve a rather complex calculation involving sine and cosine to
    determine the final locations of the four corners. Alternatively, we can direct
    the turtle to use commands such as `forward(w)`, `forward(l)`, and `right(90)`
    to draw a rectangle of the size *w* × *l* from any starting position and any initial
    rotation.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`turtle` 模块还依赖于底层的 **Tk** 图形。此模块还允许我们构建简单的交互式应用程序。turtle 的想法来自 Logo 编程语言，其中图形命令用于使一个“turtle”在绘图空间中移动。`turtle`
    模型为某些类型的图形提供了一种非常方便的规范。例如，绘制一个旋转的矩形可能涉及到一个相当复杂的计算，包括正弦和余弦来确定四个角最终的位置。或者，我们可以指导
    turtle 使用诸如 `forward(w)`、`forward(l)` 和 `right(90)` 等命令，从任何起始位置和任何初始旋转绘制大小为 *w*
    × *l* 的矩形。'
- en: In order to make it easy to learn Python, the `turtle` module provides some
    essential classes that implement a `Screen` and a `Turtle`. The module also includes
    a rich collection of functions that implicitly work with a singleton `Turtle`
    and `Screen` object, eliminating any need to set up the graphics environment.
    For beginners, this function-only environment is a language of simple verbs that
    can be used to learn the foundations of programming.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让学习 Python 更容易，`turtle` 模块提供了一些基本的类，这些类实现了 `Screen` 和 `Turtle`。该模块还包括一个丰富的函数集合，这些函数隐式地与单例
    `Turtle` 和 `Screen` 对象一起工作，消除了设置图形环境的需求。对于初学者来说，这个仅提供函数的环境是一种简单的动词语言，可以用来学习编程的基础。
- en: 'Simple programs look like this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的程序看起来像这样：
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We've used `from turtle import *` to introduce all of the individual functions.
    This is the common setup for beginners.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `from turtle import *` 来引入所有单个函数。这是初学者的常见设置。
- en: We've defined a function, `on_screen()`, which compares the turtle's position,
    given by the `pos()` function, with the overall size of the screen, given by the
    `screensize()` function. Our function uses a simple logical expression to determine
    if the current turtle position is still within the display boundaries.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个函数，`on_screen()`，它将 `pos()` 函数给出的 turtle 位置与 `screensize()` 函数给出的屏幕整体大小进行比较。我们的函数使用一个简单的逻辑表达式来确定当前
    turtle 位置是否仍然在显示边界内。
- en: For people learning to program, the implementation details of the `pos()` and
    `screensize()` functions may not be that helpful. More advanced programmers may
    want to know that the `pos()` function uses the `Turtle.pos()` method of a singleton,
    global `Turtle` instance. Similarly, the `screensize()` function uses the `Screen.screensize()`
    method of a singleton, global `Screen` instance.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 对于学习编程的人来说，`pos()`和`screensize()`函数的实现细节可能并不那么有帮助。更高级的程序员可能想知道`pos()`函数使用单例全局`Turtle`实例的`Turtle.pos()`方法。同样，`screensize()`函数使用单例全局`Screen`实例的`Screen.screensize()`方法。
- en: The function `spiral()` will draw a spiral-like shape using three parameters
    that define the line segments that comprise the spiral. This function relies on
    the `right()` and `forward()` functions from the `turtle` package to set the turtle's
    orientation and then draw a line segment. While the calculation of the end point
    of the segment drawn by `forward()` may involve a bit of trigonometry, a new programmer
    is able to learn the basics of iteration without struggling with sine or cosine.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`spiral()`函数将使用定义螺旋线段的三参数来绘制螺旋形状。这个函数依赖于`turtle`包中的`right()`和`forward()`函数来设置海龟的方向并绘制线段。虽然`forward()`函数绘制的线段端点的计算可能涉及一点三角学，但新程序员能够学习迭代的基本知识，而无需与正弦或余弦函数纠缠。'
- en: 'Here''s how we can use this function:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何使用这个函数的方法：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As part of the initialization, we've set the turtle speed to 10, which is fast.
    For people struggling with loops or conditions, a slower speed can help them follow
    their code as they watch the turtle. We've evaluated the `spiral()` function with
    a set of argument values.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 作为初始化的一部分，我们将海龟的速度设置为10，这相当快。对于在循环或条件语句上遇到困难的人来说，较慢的速度可以帮助他们在观察海龟时更好地跟随代码。我们已经使用一组参数值评估了`spiral()`函数。
- en: The `done()` function will start a GUI event processing loop that will wait
    for user interaction. We've started the loop *after* the interesting part of the
    drawing because the only expected event is the closing of the graphics window.
    When the window is closed by the user, the `done()` function will also finish.
    Our script can then end normally.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`done()`函数将启动一个GUI事件处理循环，等待用户交互。我们在绘制有趣的部分之后启动了循环，因为唯一预期的事件是图形窗口的关闭。当用户关闭窗口时，`done()`函数也会结束。然后我们的脚本可以正常结束。'
- en: If we're going to build more complex interactive applications, there's a proper
    `mainloop()` function which we can use. This captures events so that our programs
    can respond to those events.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要构建更复杂的交互式应用程序，有一个合适的`mainloop()`函数可以使用。这个函数可以捕获事件，使我们的程序能够对这些事件做出响应。
- en: The Logo language—and the related `turtle` package—allow a novice programmer
    to learn the essentials of programming without having to master too many details
    at one time. The `turtle` package isn't designed to produce the same kinds of
    sophisticated technical graphics as a package such as **matplotlib** or **Pillow.**
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Logo语言及其相关的`turtle`包允许初学者在不必须一次掌握太多细节的情况下学习编程的基本知识。`turtle`包并不是为了产生与**matplotlib**或**Pillow**等包相同类型的复杂技术图形。
- en: Using more sophisticated packages
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用更复杂的包
- en: We can create complex image-processing applications using the Pillow library.
    This package allows us to create thumbnails of large images, convert image formats,
    and verify that a file actually contains encoded image data. We can also use this
    package to create simple scientific graphics showing two-dimensional plots of
    data points. This package isn't designed to build a complete GUI since it doesn't
    handle input events for us. For more information, see [https://pypi.python.org/pypi/Pillow/2.8.1](https://pypi.python.org/pypi/Pillow/2.8.1).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Pillow库创建复杂的图像处理应用程序。这个包允许我们创建大图像的缩略图，转换图像格式，并验证文件实际上是否包含编码的图像数据。我们还可以使用这个包创建简单的科学图形，显示数据点的二维图。这个包并不是为了构建完整的GUI，因为它不会为我们处理输入事件。更多信息，请参阅[https://pypi.python.org/pypi/Pillow/2.8.1](https://pypi.python.org/pypi/Pillow/2.8.1)。
- en: For mathematical, scientific, and statistical work, the matplotlib package is
    widely used. This includes very sophisticated tools for creating essential data
    plots in two and three dimensions. This package is bundled with SciPy and Anaconda.
    For more information, see [http://matplotlib.org](http://matplotlib.org).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数学、科学和统计工作，matplotlib包被广泛使用。这个包包括创建二维和三维基本数据图的非常复杂工具。这个包与SciPy和Anaconda捆绑在一起。更多信息，请参阅[http://matplotlib.org](http://matplotlib.org)。
- en: There are several more generalized graphical frameworks. One that's often used
    to learn more about Python is the **Pygame** framework. This has a large number
    of components which include tools for graphics as well as sound and image processing.
    The Pygame package includes a number of graphics drivers and is capable of smooth
    animation with a large number of moving objects. See [http://www.pygame.org/news.html](http://www.pygame.org/news.html).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个更通用的图形框架。其中一个常用于学习Python的是**Pygame**框架。它包含大量组件，包括图形、声音和图像处理工具。Pygame包包括多个图形驱动程序，能够以平滑的方式处理大量移动对象。请参阅[http://www.pygame.org/news.html](http://www.pygame.org/news.html)。
- en: Building web applications
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建Web应用程序
- en: Web applications involve a great deal of processing, which is best described
    as boilerplate. The essential handling of the HTTP protocol, for example, is often
    standardized, with libraries that handle it gracefully. The details of parsing
    request headers and mapping a URL path to a specific resource don't need to be
    reinvented.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Web应用程序涉及大量的处理，这最好描述为样板代码。例如，HTTP协议的基本处理通常是标准化的，有库可以优雅地处理它。解析请求头和将URL路径映射到特定资源的细节不需要重新发明。
- en: There is, however, a profound distinction between simply handling the HTTP protocol
    and mapping a URL to an application-specific resource. These two layers drive
    the definition of the **Web Services Gateway Interface** (**WSGI**) design and
    the `wsgi` module is in the standard library. For more information, see **Python
    Enhancement Proposal** (**PEP**) 3333, [https://www.python.org/dev/peps/pep-3333/](https://www.python.org/dev/peps/pep-3333/).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，简单地处理HTTP协议和将URL映射到特定应用程序资源之间存在深刻的区别。这两个层次推动了**Web服务网关接口**（**WSGI**）设计和`wsgi`模块在标准库中的定义。有关更多信息，请参阅**Python增强提案**（**PEP**）3333，[https://www.python.org/dev/peps/pep-3333/](https://www.python.org/dev/peps/pep-3333/)。
- en: The idea behind WSGI is that all web services should adhere to a single, minimum
    standard for handling the details of HTTP requests and responses. This standard
    allows a complex web server to include a variety of Python tools and frameworks
    that are fitted together using WSGI to ensure that components interconnect properly.
    The mapping of URLs to resources must be handled in the context of this standard.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: WSGI背后的想法是所有Web服务都应该遵守处理HTTP请求和响应细节的单个、最小标准。这个标准允许复杂的Web服务器包含各种Python工具和框架，这些工具和框架通过WSGI组合在一起，以确保组件正确互联。URL到资源的映射必须在标准上下文中处理。
- en: A `mod_wsgi` module can be plugged into an Apache HTTPD server. This module
    will pass requests and responses between the Apache frontend and backend Python
    instances. With a little bit of planning, we can be sure that static content—graphics,
    style sheets, JavaScript libraries, and so on—are handled by the frontend web
    server. The dynamic content—HTML pages, XML, or JSON documents—are handled by
    our Python application.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将`mod_wsgi`模块插入到Apache HTTPD服务器中。此模块将在Apache前端和后端Python实例之间传递请求和响应。通过一点规划，我们可以确保静态内容（如图形、样式表、JavaScript库等）由前端Web服务器处理。动态内容（如HTML页面、XML或JSON文档）则由我们的Python应用程序处理。
- en: For more information on `mod_wsgi`, see [http://www.modwsgi.org/](http://www.modwsgi.org/).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`mod_wsgi`的更多信息，请参阅[http://www.modwsgi.org/](http://www.modwsgi.org/)。
- en: Using a web framework
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Web框架
- en: Web applications in this context are generally built using a framework that
    parses URLs and invokes a Python function to return the resource located by the
    URL. While this is clearly the minimum required to create a web server, there
    are often a large number of additional features that we'd like to have.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个背景下，Web应用程序通常使用一个解析URL并调用Python函数以返回由URL定位的资源框架来构建。虽然这显然是创建Web服务器所需的最小要求，但通常还有大量我们希望拥有的附加功能。
- en: Authentication and authorization, for example, are features we often need and
    would prefer not to have to implement. It's much nicer to work with a framework
    that allows us to add OAuth client code. A website that uses cookies will also
    benefit from having session management features that integrate seamlessly.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，身份验证和授权是我们经常需要且希望不需要实现的功能。与一个允许我们添加OAuth客户端代码的框架一起工作会更好。使用cookie的网站也将从具有无缝集成的会话管理功能中受益。
- en: Many websites offer RESTful web services. Sometimes these services are thin
    wrappers around database access. When the database is relational, we often want
    an **Object Relational Mapper** (**ORM**) layer that allows us to expose more
    complete objects through the RESTful service. This, too, is a good option for
    a web server framework.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 许多网站提供 RESTful 网络服务。有时这些服务是数据库访问的薄包装。当数据库是关系型时，我们通常需要一个 **对象关系映射器**（**ORM**）层，它允许我们通过
    RESTful 服务暴露更完整的对象。这也是一个良好的网络服务器框架选项。
- en: 'There are two broad approaches to providing web services in Python: kits and
    parts. The kits approach is epitomized by packages such as Django which offer
    just about everything that could possibly be required in a unified collection
    of modules and packages. See [https://www.djangoproject.com](https://www.djangoproject.com).'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中提供网络服务有两种主要方法：套件和组件。套件方法以 Django 等包为代表，这些包提供了一个统一集合中的几乎所有可能需要的模块和包。请参阅
    [https://www.djangoproject.com](https://www.djangoproject.com)。
- en: The parts approach can be seen in projects such as Flask. This is called a **microframework**
    because it does relatively little. A Flask server focuses on URL routing, making
    it ideal for building RESTful services. It may include session management, allowing
    it to be used for HTML sites. It cooperates well with other projects such as Jinja2,
    WTForms, SQLAlchemy, OAuth authentication modules, and many other modules. For
    more information, see [http://flask.pocoo.org/docs/0.10/](http://flask.pocoo.org/docs/0.10/).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 组件方法可以在 Flask 等项目中看到。这被称为 **微框架**，因为它相对较少。Flask 服务器专注于 URL 路由，使其非常适合构建 RESTful
    服务。它可能包括会话管理，使其可用于 HTML 网站。它与 Jinja2、WTForms、SQLAlchemy、OAuth 认证模块和其他许多模块很好地协作。有关更多信息，请参阅
    [http://flask.pocoo.org/docs/0.10/](http://flask.pocoo.org/docs/0.10/)。
- en: Building a RESTful web service with Flask
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Flask 构建 RESTful 网络服务
- en: We'll demonstrate a very simple web service. We'll use the algorithm shown earlier
    in the turtle example, with some minor modifications, to create a dynamic graphic
    download. To make it easier to create a downloadable file, we'll discard the simplistic
    turtle graphics package and use the Pillow package to create the image file. Many
    websites use Pillow to validate uploaded images and create thumbnails. It's an
    essential part of any site that uses images.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将演示一个非常简单的网络服务。我们将使用之前在 turtle 示例中展示的算法，进行一些小的修改，以创建动态图形下载。为了更容易创建可下载的文件，我们将放弃简单的
    turtle 图形包，并使用 Pillow 包来创建图像文件。许多网站使用 Pillow 来验证上传的图像并创建缩略图。它是任何使用图像的网站的必要组成部分。
- en: For more information on Pillow, see [https://pypi.python.org/pypi/Pillow/2.8.1](https://pypi.python.org/pypi/Pillow/2.8.1).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Pillow 的更多信息，请参阅 [https://pypi.python.org/pypi/Pillow/2.8.1](https://pypi.python.org/pypi/Pillow/2.8.1)。
- en: A web service must provide a resource in response to an HTTP request. A simple
    Flask-powered site will have an overall application object and a number of routes
    which map URLs (and possibly method names) to functions.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 网络服务必须对 HTTP 请求提供资源。一个简单的 Flask 网站将有一个整体的应用程序对象和多个路由，这些路由将 URL（以及可能的方法名称）映射到函数。
- en: 'Here''s a simple example:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单的例子：
- en: '[PRE3]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This example shows three central features of Flask applications. This script
    defines a `Flask` instance. We've based the instance on the filename, which will
    be `"__main__"` for a main script, but will have the module name for an imported
    script. We've assigned that `Flask` container to a variable, `spiral_app`, for
    use throughout the module file.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例展示了 Flask 应用程序的核心三个特性。此脚本定义了一个 `Flask` 实例。我们基于文件名定义了该实例，对于主脚本，它将是 `"__main__"`，而对于导入的脚本，它将是模块名。我们将该
    `Flask` 容器分配给一个变量 `spiral_app`，以便在整个模块文件中使用。
- en: A more complex Flask application may have a number of individual view functions
    in a package of submodules. Each of these will depend on the global Flask application.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更复杂的 Flask 应用程序可能在一个子模块包中包含多个单独的视图函数。这些中的每一个都将依赖于全局 Flask 应用程序。
- en: Our image resource is created by the `image()` function. We provided a `route`
    decorator for this function that shows the URL path and the methods that work
    with this resource. There are a large number of methods defined for the HTTP protocol.
    Many RESTful web services focus on POST, GET, PUT, and DELETE because these match
    the idea of the **Create, Retrieve, Update, and Delete** (**CRUD**) rules commonly
    used to summarize database operations.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过`image()`函数创建图像资源。为此函数提供了一个`route`装饰器，它显示了URL路径以及与此资源一起工作的方法。为HTTP协议定义了大量的方法。许多RESTful网络服务专注于POST、GET、PUT和DELETE，因为这些与常用的**创建、检索、更新和删除**（**CRUD**）规则相匹配，这些规则通常用于总结数据库操作。
- en: 'We''ve broken down the `image()` function into four separate pieces. First,
    we need to parse the URL. The `route` includes a placeholder, `<spec>`, which
    Flask parses and provides as a parameter to the function. This will be the URL-encoded
    parameter to describe the spiral. It might look like this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`image()`函数分解为四个独立的部分。首先，我们需要解析URL。`route`包括一个占位符`<spec>`，Flask会解析并提供给函数作为参数。这将是一个用于描述螺旋的URL编码参数。它可能看起来像这样：
- en: '[PRE4]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Once we''ve decoded the specification, we''ll have a special multi-valued dictionary.
    This looks as if the input came from an HTML form. The structure will be a mapping
    from form field names to a list of values for each field. The object looks like
    this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们解码了规范，我们将有一个特殊的多元值字典。这看起来像是来自HTML表单的输入。结构将是表单字段名称到每个字段值的列表的映射。对象看起来像这样：
- en: '[PRE5]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `image()` function only uses one value from each item; each input must be
    converted to numeric values. We've collected all of the potential exceptions into
    a single `except` clause, obscuring the details of any incorrect input. We use
    the Flask `make_response()` function to build a response with an error message
    and a status code of 403 ("Forbidden"). A more sophisticated function would use
    the **Accept** header to formulate a response as JSON or XML, depending on the
    client's stated preference. We've left it as the default MIME type of text/plain.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`image()`函数只使用每个项目中的一个值；每个输入都必须转换为数值。我们将所有潜在的异常收集到一个单独的`except`子句中，从而掩盖了任何错误输入的细节。我们使用Flask的`make_response()`函数构建一个包含错误消息和状态码403（“禁止”）的响应。一个更复杂的函数会使用**Accept**头根据客户端声明的偏好将响应格式化为JSON或XML。我们将其保留为默认的MIME类型text/plain。'
- en: The image is saved into a temporary file, created with the `tempfile.mkstemp()`
    function. In this case, we're going to save that temporary file from the Flask
    application. For a low-volume website, this is acceptable. For a higher-volume
    website, a Python application should never handle downloads. The file should be
    created in a directory where the Apache HTTPD server can download the image instead
    of a Python application.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图像被保存到一个临时文件中，该文件是用`tempfile.mkstemp()`函数创建的。在这种情况下，我们将从Flask应用程序中保存那个临时文件。对于低流量网站，这是可以接受的。对于高流量网站，Python应用程序永远不应该处理下载。文件应该创建在Apache
    HTTPD服务器可以下载图像的目录中，而不是Python应用程序。
- en: The image construction uses a few Pillow-defined objects to define the drawing
    space. A customized class defines a `Pen` instance which parallels the `turtle.Turtle`
    class. Once the image has been constructed, it's saved with the given filename.
    Note that the Pillow package can save files in a wide variety of formats; we've
    used `.png` in this example.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图像构建使用了一些Pillow定义的对象来定义绘图空间。一个定制的类定义了一个`Pen`实例，它与`turtle.Turtle`类平行。一旦图像构建完成，它就会使用给定的文件名保存。请注意，Pillow包可以以多种格式保存文件；在这个例子中我们使用了`.png`格式。
- en: The final section downloads the file. The comment notes that a high-volume website
    would redirect to a URL from which Apache would download the image file. This
    frees up the Flask server to handle another request.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个部分下载文件。注释指出，高流量网站会重定向到一个URL，Apache会从该URL下载图像文件。这使Flask服务器能够处理另一个请求。
- en: Note that the local namespace in this function will have two copies of the image.
    The `im` variable will hold the entire, detailed image. The `data` variable will
    hold the compressed filesystem version of the image document. We could use `del
    im` to remove the image object; however, it is generally better to decompose this
    into two functions so that namespaces handle object removal for us.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这个函数的本地命名空间中会有两个图像副本。`im`变量将保存整个详细的图像。`data`变量将保存图像文档的压缩文件系统版本。我们可以使用`del
    im`来删除图像对象；然而，通常将此分解为两个函数更好，这样命名空间会为我们处理对象删除。
- en: 'We can run a demonstration version of this service with the following script:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下脚本运行此服务的演示版本：
- en: '[PRE6]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This allows us to work with a running web server on our desktop. We can then
    experiment with different implementation alternatives.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们在桌面上使用一个运行中的Web服务器。然后我们可以尝试不同的实现方案。
- en: What's important about this example is that we can—very quickly—have a service
    running in our desktop environment. We can then explore and experiment with the
    user experience very easily. For example, since the image will be embedded in
    an HTML page, we want to design and debug the HTML, CSS, and JavaScript for that
    page. This whole development process is made easier when we have a simple, easily-tweaked
    web server.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子的重要之处在于我们可以——非常快速地——在我们的桌面环境中运行一个服务。然后我们可以轻松地探索和实验用户体验。例如，由于图像将嵌入到HTML页面中，我们希望为该页面设计和调试HTML、CSS和JavaScript。当我们有一个简单、易于调整的Web服务器时，整个开发过程会变得更加容易。
- en: Plugging into a MapReduce framework
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接到MapReduce框架
- en: 'For background on the Apache Hadoop server, see [https://hadoop.apache.org](https://hadoop.apache.org).
    Here''s the summary:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Apache Hadoop服务器的背景信息，请参阅[https://hadoop.apache.org](https://hadoop.apache.org)。以下是摘要：
- en: '*The Apache Hadoop software library is a framework that allows for the distributed
    processing of large datasets across clusters of computers using simple programming
    models. It is designed to scale up from single servers to thousands of machines,
    each offering local computation and storage.*'
  id: totrans-105
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*Apache Hadoop软件库是一个框架，它允许使用简单的编程模型在计算机集群上分布式处理大型数据集。它旨在从单个服务器扩展到数千台机器，每台机器都提供本地计算和存储。*'
- en: 'One part of the Hadoop distributed processing is the MapReduce module. This
    module allows us to decompose analysis of data into two complementary operations:
    map and reduce. These operations are distributed around the Hadoop cluster to
    be run concurrently. A map operation processes all of the rows of datasets that
    are scattered around the cluster. The outputs from map operations are then fed
    to reduce operations to be summarized.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Hadoop分布式处理的一部分是MapReduce模块。此模块允许我们将数据分析分解为两个互补的操作：映射和缩减。这些操作在Hadoop集群中分布，以并发运行。映射操作处理集群中分散的数据集的所有行。然后，映射操作的输出被输送到缩减操作以进行汇总。
- en: The Hadoop streaming interface can be used by Python programmers. This involves
    a Hadoop "wrapper" that will present the data to a Python mapper program as the
    standard input file. The standard output from a mapper must be tab-delimited key-value
    pairs. These are sent to the reduce programs, again as standard input. For more
    information on packages that help Python programmers use Hadoop, see [http://blog.cloudera.com/blog/2013/01/a-guide-to-python-frameworks-for-hadoop/](http://blog.cloudera.com/blog/2013/01/a-guide-to-python-frameworks-for-hadoop/).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Python程序员可以使用Hadoop流接口。这涉及到一个Hadoop“包装器”，它将数据作为标准输入文件呈现给Python映射程序。映射程序的标准输出必须是制表符分隔的键值对。这些被发送到缩减程序，再次作为标准输入。有关帮助Python程序员使用Hadoop的包的更多信息，请参阅[http://blog.cloudera.com/blog/2013/01/a-guide-to-python-frameworks-for-hadoop/](http://blog.cloudera.com/blog/2013/01/a-guide-to-python-frameworks-for-hadoop/)。
- en: 'One common example of MapReduce operations is creating a concordance of words
    found in books. The mapping operation will transform a giant text file into sequences
    of words found in the text file. The reduce operation will count the occurrences
    of each word, resulting in a final summary of words and their popularity. (For
    more information on how important this can be, visit the NLTK website: [http://www.nltk.org](http://www.nltk.org).)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: MapReduce操作的一个常见示例是创建书中找到的单词的索引。映射操作将巨型文本文件转换为文本文件中找到的单词序列。缩减操作将计算每个单词的出现次数，从而得出单词及其流行度的最终汇总。（有关其重要性的更多信息，请访问NLTK网站：[http://www.nltk.org](http://www.nltk.org)。）
- en: 'Practical problems may involve multiple mappings and multiple reductions. In
    many cases, the mappings will often seem trivial: they''ll extract a key and a
    value from each row of source data. Rather than study Hadoop too much, we''ll
    show how we can write and test mappers and reducers on our desktop.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 实际问题可能涉及多个映射和多个缩减。在许多情况下，映射似乎很简单：它们会从源数据中的每一行提取一个键和一个值。我们不会过多地研究Hadoop，而是展示如何在我们的桌面上编写和测试映射器和缩减器。
- en: 'Our goal is to have two programs, `map.py` and `reduce.py`, that can be combined
    into a stream like this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是拥有两个程序，`map.py`和`reduce.py`，它们可以组合成如下流：
- en: '[PRE7]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This approach will simulate Hadoop streaming by supplying data to our `map.py`
    program and our `reduce.py` program. This will serve as a simple integration test
    for our map and reduce processing. For Windows, we would use the `type` command
    instead of the Linux `cat` program.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法将通过向我们的`map.py`程序和`reduce.py`程序提供数据来模拟Hadoop流。这将成为我们映射和减少处理的一个简单集成测试。对于Windows，我们将使用`type`命令而不是Linux的`cat`程序。
- en: Let's look at some raw climate data from the US National Ocean and Atmospheric
    Administration's National Climatic Data Center. Refer to [http://www.ncdc.noaa.gov/cdo-web/](http://www.ncdc.noaa.gov/cdo-web/)
    for climate data online. We can request files with details such as snowfall for
    a given time period.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看美国国家海洋和大气管理局国家气候数据中心的一些原始气候数据。有关在线气候数据，请参阅[http://www.ncdc.noaa.gov/cdo-web/](http://www.ncdc.noaa.gov/cdo-web/)。我们可以请求包含特定时间段降雪等详细信息的文件。
- en: Our question is "Which months have snowfall at the Richmond, VA, airport?" The
    snowfall data attribute is named `TSNW`. It's in units of one-tenth of an inch,
    so our mapper needs to convert it to `Decimal` inches to be more useful.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的问题是“哪几个月在弗吉尼亚州里士满机场有降雪？”降雪数据属性名为`TSNW`。它的单位是1/10英寸，因此我们的映射器需要将其转换为`Decimal`英寸，以便更实用。
- en: 'We can write a map script that looks like this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写一个看起来像这样的映射脚本：
- en: '[PRE8]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Because our input is in more or less standard CSV notation—with a heading—we
    can use a `csv.DictReader` object to parse the input. Each row of data is a `dict`
    object with keys defined by the first line of the CSV file. The output is more
    specialized: with Hadoop it must be a tab-delimited key and value, terminated
    with a newline character.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的输入在大约标准CSV表示法中——带有标题——我们可以使用`csv.DictReader`对象来解析输入。每一行数据都是一个`dict`对象，其键由CSV文件的第一行定义。输出更加专业化：在Hadoop中，它必须是一个制表符分隔的关键字和值，以换行符结束。
- en: For each input dictionary object, we'll convert the date from text to a proper
    Python date so that we can reliably extract the month. We could do this by using
    `row['DATE'][4:6]`, but that seems opaque. The mapper includes a filter to reject
    months that have no snow, or have a domain-specific null value (9999 or -9999)
    instead of a measurement.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个输入字典对象，我们将日期从文本转换为适当的Python日期，以便我们可以可靠地提取月份。我们可以通过使用`row['DATE'][4:6]`来完成此操作，但这似乎很模糊。映射器包括一个过滤器，以拒绝没有降雪的月份，或者有特定领域的空值（9999或-9999）而不是测量值。
- en: The output is a key and a value. Our key is the reported month; the value is
    the snowfall converted from one-tenth inch to inch measurements. We've used the
    `Decimal` class to avoid introducing floating-point approximations.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是一个键和一个值。我们的键是报告的月份；值是将十分之一英寸的降雪转换为英寸测量值。我们使用了`Decimal`类来避免引入浮点近似。
- en: 'The reduce operation uses a `Counter` object to summarize the results produced
    by the mapper. For this example, the reduce looks like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 减少操作使用`Counter`对象来总结映射器产生的结果。对于这个例子，减少操作看起来像这样：
- en: '[PRE9]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The reduce reader matches the mapper''s writer: they both use a delimiter of
    a tab and a line terminator of the newline character. This follows Hadoop''s requirements
    for the data that flows from mappers to reducers. We''ve also created a `Counter`
    object to store our snowfall data.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 减少读取器与映射器的写入器相匹配：它们都使用制表符作为分隔符，使用换行符作为行终止符。这遵循了Hadoop对从映射器到减少器的数据的要求。我们还创建了一个`Counter`对象来存储我们的降雪数据。
- en: For each line of input, we extract the inches of snowfall and accumulate those
    in the `Counter` object with a key of the month number. The final result will
    show the inches of snow for each month in the greater Richmond metropolitan area.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每一行输入，我们提取降雪英寸数，并将这些数累加到以月份数字为键的`Counter`对象中。最终结果将显示大里士满都会区每个月的降雪英寸数。
- en: 'We can easily test and experiment with this on our desktop. We can execute
    a pipeline of mapper, sort, and reducer using either a shell script or perhaps
    a little wrapper program like this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以很容易地在我们的桌面上测试和实验这个。我们可以使用shell脚本或可能是一个像这样的小包装程序来执行映射器、排序和减少器的管道：
- en: '[PRE10]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We've created a command that will work on Mac OS X or Linux, and substituted
    a filename into that command. For Windows we can use `type` instead of `cat`;
    the Python program might be named `python` instead of `python3`. Otherwise, the
    shell pipeline should work fine in Windows.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个在Mac OS X或Linux上工作的命令，并将文件名替换到该命令中。对于Windows，我们可以使用`type`而不是`cat`；Python程序可能被命名为`python`而不是`python3`。否则，shell管道应该在Windows上正常工作。
- en: We've used the `subprocess.check_output()` function to run this shell command
    and collect the output. This is a quick way to experiment with our Hadoop programs
    while avoiding the delays associated with using a busy Hadoop cluster.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了 `subprocess.check_output()` 函数来运行这个 shell 命令并收集输出。这是一种快速实验我们的 Hadoop 程序的方法，同时避免了使用繁忙的
    Hadoop 集群相关的延迟。
- en: This approach works well as long as we stick to elements of the libraries that
    are properly installed in the Hadoop environment. In some cases, our cluster might
    have Anaconda installed, giving us access to a wide variety of packages. When
    we want to use our own package—one that's not installed throughout the cluster—we'll
    need to provide the additional module to the Hadoop streaming command to be sure
    that our additional modules are downloaded to each node in the cluster, along
    with our mapper and reducer.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 只要我们坚持使用在 Hadoop 环境中正确安装的库元素，这种方法就能很好地工作。在某些情况下，我们的集群可能已经安装了 Anaconda，这使我们能够访问各种包。当我们想使用自己的包——一个在整个集群中未安装的包时，我们需要将额外的模块提供给
    Hadoop 流命令，以确保我们的额外模块被下载到集群中的每个节点，包括我们的映射器和归约器。
- en: Summary
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we've looked at several kinds of Python applications. While
    Python is used widely, we've picked a few areas of focus. We've looked at CLI
    applications capable of processing large volumes of data. The command-line interface
    is also present in other kinds of applications, making this a fundamental part
    of any program.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了多种 Python 应用程序。虽然 Python 被广泛使用，但我们选择了一些重点关注的领域。我们研究了能够处理大量数据的 CLI
    应用程序。命令行界面也存在于其他类型的应用程序中，这使得它成为任何程序的基本部分。
- en: We've looked at GUI programs, using only the built-in `turtle` module. The GUI
    frameworks that are widely used involve downloads, installation, and more sophisticated
    programming that we could not illustrate in a single chapter. There are several
    popular choices; there's no consensus on a "best" package for GUI applications.
    Making a choice is difficult.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还研究了使用内置的 `turtle` 模块进行 GUI 程序。广泛使用的 GUI 框架涉及下载、安装和更复杂的编程，我们无法在一个章节中展示。有几个流行的选择；对于
    GUI 应用程序来说，没有关于“最佳”包的共识。做出选择是困难的。
- en: We've also looked at web applications, using the Flask module. This is also
    a separate download. In many cases, there are a number of related downloads that
    will become part of a web application. We might include Jinja2, WTForms, OAuth,
    SQLAlchemy, and Pillow, to expand the web server's libraries.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还研究了使用 Flask 模块的网络应用程序。这也是一个单独的下载。在许多情况下，有许多相关的下载将成为网络应用程序的一部分。我们可能包括 Jinja2、WTForms、OAuth、SQLAlchemy
    和 Pillow，以扩展网络服务器的库。
- en: We've also looked at how we might leverage desktop Python to develop Hadoop
    applications. Rather than download and install Hadoop, we can create a processing
    pipeline that follows the Hadoop approach. We can write mappers and reducers using
    only desktop tools, allowing us to create reliable unit tests. This gives us the
    confidence that we'll get the expected results when running our applications on
    the Hadoop cluster with a complete set of data.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还研究了如何利用桌面 Python 来开发 Hadoop 应用程序。我们不必下载和安装 Hadoop，可以创建一个遵循 Hadoop 方法的处理管道。我们可以仅使用桌面工具编写映射器和归约器，这样我们就可以创建可靠的单元测试。这使我们有了信心，当我们使用完整的数据集在
    Hadoop 集群上运行应用程序时，我们会得到预期的结果。
- en: This isn't all, of course. Python can be used inside another application as
    the language for automating that application. A program can embed a Python interpreter
    which interacts with the overall application. For more information, see [https://docs.python.org/2/extending/embedding.html](https://docs.python.org/2/extending/embedding.html).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这还不是全部。Python 可以作为自动化其他应用程序的语言在另一个应用程序中使用。一个程序可以嵌入一个 Python 解释器，该解释器与整体应用程序交互。有关更多信息，请参阅
    [https://docs.python.org/2/extending/embedding.html](https://docs.python.org/2/extending/embedding.html)。
- en: 'We can imagine the universe of Python applications as a large body of water
    filled with islands, archipelagos, inlets, and estuaries. Chesapeake Bay on the
    US East Coast is an example. We''ve tried to show the principal features of this
    bay: the headlands, points, shallows, and coastlines. We''ve avoided the effects
    of currents, weather, and tides, so that we can focus on the essential features
    of the bay. Pragmatic navigation along a specific route requires more study of
    the area of interest: detailed navigation charts, pilot guides, and local knowledge
    from other mariners.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将 Python 应用程序的世界想象成一个充满岛屿、群岛、湾口和河口的大水体。美国东海岸的切萨皮克湾就是一个例子。我们试图展示这个湾的主要特征：海角、尖端、浅滩和海岸线。我们避开了洋流、天气和潮汐的影响，以便我们可以专注于湾的必要特征。沿着特定路线进行实用导航需要更深入地研究感兴趣的区域：详细的航海图、飞行员指南以及来自其他船员的当地知识。
- en: It's important to consider the extent of the Python universe. The distance to
    a destination can appear daunting. Our objective has been to show some principal
    waypoints that can help break a long voyage into shorter legs. If we isolate the
    legs of a long journey, we can solve each of them separately and build a larger
    solution from the pieces.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑 Python 世界的广度是很重要的。到达目的地的距离可能会显得令人畏惧。我们的目标一直是展示一些主要航标，这些航标可以帮助将漫长的航行分解成更短的航程。如果我们孤立出漫长旅程的各个部分，我们就可以分别解决它们，并从这些部分构建出一个更大的解决方案。
