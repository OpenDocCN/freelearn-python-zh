- en: Chapter 15. Next Steps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After studying the Python basics, what's next? Each developer's journey will
    vary, based on the general architecture of the application that they're going
    to build. In this chapter, we'll look at four kinds of Python applications. We'll
    look at **command-line interface** (**CLI**) applications in some depth. We'll
    look briefly at **graphical user interface** (**GUI**) applications. There are
    a number of graphics libraries and a number of frameworks that we might use for
    this; it's difficult to address all of the alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: Web server applications often involve a sophisticated web framework that handles
    the standardized overheads. Our Python code will plug into this framework. As
    with GUI applications, there are several commonly used frameworks. We'll look
    quickly at a few common features of web frameworks. We'll also look at the big
    data context as epitomized by the Hadoop server's streaming interface.
  prefs: []
  type: TYPE_NORMAL
- en: This isn't intended to be complete or even representative. Python is used in
    many different ways.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging the standard library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When implementing Python solutions, it's helpful to scan the standard library
    for relevant modules. The library is large, making it somewhat intimidating at
    first. We can, however, focus our search.
  prefs: []
  type: TYPE_NORMAL
- en: We can break the *Python Standard Library* document into three portions. The
    first five chapters are general reference material that all Python programmers
    need to understand. The next 20 chapters, plus chapters 28 and 32, describe modules
    that we might incorporate into a wide variety of applications. The remaining chapters
    are less useful; they're more focused on Python internals and ways in which to
    extend the language itself.
  prefs: []
  type: TYPE_NORMAL
- en: The name and the summary of a module in the library table of contents may not
    provide enough information to see all of the ways in which a module might be used.
    The `bisect` module, for example, can be extended to create a fast dictionary
    that retains its keys in a defined order. This isn't obvious without careful reading
    of the description of the module.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the library modules have relatively small, easy-to-understand implementations.
    For larger modules and packages, there are often pieces that can be lifted out
    of context and reused widely. As an example, consider an application that uses
    `http.client` to make REST web services requests. We often need functions from
    the `urllib.parse` module to encode a query string or properly quote parts of
    the URL. It's common to see a long list of imports at the front of Python applications.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging PyPI – the Python Package Index
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After scanning the library, the next place to look for additional Python packages
    is the **Python Package Index** (**PyPI**) at [https://pypi.python.org/pypi](https://pypi.python.org/pypi).
    There are thousands of packages listed here, with varying degrees of support and
    quality.
  prefs: []
  type: TYPE_NORMAL
- en: As we noted in [Chapter 1](ch01.html "Chapter 1. Getting Started"), *Getting
    Started*, Python 3.4 also installs two scripts to help us add packages, `pip`
    and `easy_install`. These search PyPI for the requested package. Most packages
    can be found by using their name; the tools locate the appropriate release for
    the platform and Python version.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve mentioned a few external libraries in other chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`nose` for writing tests, see [https://pypi.python.org/pypi/nose/1.3.6](https://pypi.python.org/pypi/nose/1.3.6)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docutils` for writing documentation, see [https://pypi.python.org/pypi/docutils/0.12](https://pypi.python.org/pypi/docutils/0.12)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sphinx` for writing complex documentation, see [https://pypi.python.org/pypi/Sphinx/1.3.1](https://pypi.python.org/pypi/Sphinx/1.3.1)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Additionally, there are bundles of packages available: we might install Anaconda,
    NumPy, or SciPy, each of which includes a number of other packages in one tidy
    distribution. See [http://continuum.io/downloads](http://continuum.io/downloads),
    [http://www.numpy.org](http://www.numpy.org), or [http://www.scipy.org](http://www.scipy.org).'
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, we may have Python configurations that are incompatible with
    each other. For example, we may have to work in two environments, one using the
    older Beautiful Soup 3 with the other using the newer version 4\. Refer to [https://pypi.python.org/pypi/beautifulsoup4/4.3.2](https://pypi.python.org/pypi/beautifulsoup4/4.3.2).
    To simplify this switch, we can use the `virtualenv` tool to create isolated Python
    environments with their own complex trees of interdependent modules. See [https://virtualenv.pypa.io/en/latest/](https://virtualenv.pypa.io/en/latest/).
  prefs: []
  type: TYPE_NORMAL
- en: The Python ecosystem is large and sophisticated. There's no good reason to invent
    a solution in a vacuum. It's often best to locate the appropriate components or
    partial solutions, then download and extend them.
  prefs: []
  type: TYPE_NORMAL
- en: Types of applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll look at four types of Python applications. These are neither the most
    common nor the most popular kinds of Python applications; they were selected more
    or less randomly based on the author's narrow experience. Python is used widely,
    and any attempt to summarize all of the various places where Python is used runs
    the risk of misleading rather than informing.
  prefs: []
  type: TYPE_NORMAL
- en: We'll look at CLI applications for two reasons. Firstly, they can be relatively
    simple, relying on fewer additional packages or frameworks than other kinds of
    applications. Secondly, more complex applications will often be launched from
    a CLI main script. For these reasons, the CLI features seem to be fundamental
    to most uses of Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll look at GUI applications because they are popular on the desktop. The
    difficulty here is that there are many GUI frameworks available for Python software
    development. Here''s one list: [https://wiki.python.org/moin/GuiProgramming](https://wiki.python.org/moin/GuiProgramming).
    We''ll focus on the `turtle` package because it''s simple and built-in.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll look at web applications because Python is used with frameworks such
    as Django or Flask (among many others) to build high-volume websites. Here''s
    a list of Python web frameworks: [https://wiki.python.org/moin/WebFrameworks](https://wiki.python.org/moin/WebFrameworks).
    We''ll focus on Flask because it''s relatively simple.'
  prefs: []
  type: TYPE_NORMAL
- en: We'll also look at how Python can be used with Hadoop streaming to perform data
    analytics. Rather than download and install Apache Hadoop, we'll touch on how
    we build and test pipelined map-reduce processing on our desktop.
  prefs: []
  type: TYPE_NORMAL
- en: Building CLI applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our focus from the initial script example in [Chapter 1](ch01.html "Chapter 1. Getting
    Started"), *Getting Started*, was on using CLI scripting to learn Python basics.
    CLI applications have a number of common features:'
  prefs: []
  type: TYPE_NORMAL
- en: They often read from the standard input file, write to a standard output file,
    and produce logs or errors in the standard error file. The OS assures us that
    these files are always available. Python provides them as `sys.stdin`, `sys.stdout`,
    and `sys.stderr`. Furthermore, functions such as `input()` and `print()` use these
    files by default.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They often use environment variables for configuration. These values are available
    through `os.environ`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They may also rely on shell features, like expanding `~` into a user's home
    directory, something done by `os.path.expanduser()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They often parse command-line arguments. While the variable `sys.argv` has the
    argument strings, these are awkward to work with directly. We'll use the `argparse`
    module to define the argument patterns, parse the strings, and create an object
    with the relevant argument values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These basic features cover many programming alternatives. A web server, for
    example, can be thought of as a CLI program that runs forever, servicing requests
    that come from a specific port number. A GUI application might start from the
    command line, but then open windows to permit user interaction.
  prefs: []
  type: TYPE_NORMAL
- en: Getting command-line arguments with argparse
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll create a parser to use the command-line arguments, using the `argparse`
    module. Once configured, we can use that parser to create a small namespace object
    which has all of the argument values that were provided on the command line, or
    has default values. Our application can use this object to control its behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally, we want to isolate command-line handling from the rest of our application.
    Here''s a function that handles parsing, and then uses the parsed options to invoke
    another function to do the real work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We've built an `ArgumentParser` method using all of the default parameters.
    We could have identified the program name, provided a summary of usage, or have
    had anything else displayed when someone uses the `-h` option to get help. We
    omitted these extra bits of documentation to keep the example small.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve defined two arguments for this application: an optional argument and
    a positional argument. The optional argument, `-v` or `--verbose`, stores a constant
    value in the resulting collection of options. The name of this attribute is the
    long name of the argument, `verbose`. The constant provided is `logging.DEBUG`;
    the default value if the option isn''t present is `logging.INFO`.'
  prefs: []
  type: TYPE_NORMAL
- en: The positional argument, `c`, accepts one command-line argument after all of
    the options have been parsed. The value for `nargs` can be omitted; it can be
    `'*'` to collect all arguments. We've provided a requirement that the input value
    is converted by the `float()` function, which means that non-numeric values will
    be rejected with an error during argument parsing. This will be set as the `c`
    attribute of the resulting object.
  prefs: []
  type: TYPE_NORMAL
- en: When we evaluate the `parse_args()` method, the defined arguments are used to
    parse the command-line values in `sys.argv`. The `options` object will have the
    resulting values or defaults.
  prefs: []
  type: TYPE_NORMAL
- en: In the second part of `main()`, we've used the `options` object to set the logging
    level for the root logger using the `verbose` argument value. We've then used
    a global `logger` object to dump the single positional argument value that will
    be assigned to the `c` attribute of the `options` object.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we've evaluated our application function with the input argument value;
    the parser assigned this to the `options.c` variable. The function which does
    the real work is designed to be entirely separate from the command-line interface
    that is used to invoke it. The function accepts a floating-point value and prints
    a result to a standard output. It can leverage the module global `logger` object.
  prefs: []
  type: TYPE_NORMAL
- en: Our goal in designing a CLI application is to completely separate the useful
    work from all interface considerations. This allows us to import the function
    which does the real work, and build larger or more complex applications from individual
    pieces. It generally means that the command-line arguments are transformed into
    ordinary function arguments or class constructor arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Using the cmd module for interactive applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some CLI applications require user interaction. The `sftp` command, for example,
    can be used from the command line to exchange files with a server. We can create
    similar interactive applications using Python's `cmd` module.
  prefs: []
  type: TYPE_NORMAL
- en: To build a more complex interactive application, we can create a class which
    extends the `cmd.Cmd` class. Each method in this class that has a name starting
    with `do_` defines an interactive command. For example, if we define a method
    `do_get()`, this means that our application now has an interactive `get` command.
  prefs: []
  type: TYPE_NORMAL
- en: Any subsequent text after the user's input of `get` will be provided as an argument
    to the `do_get()` method. The `do_get()` function is then responsible for any
    further parsing and processing of the text after the command.
  prefs: []
  type: TYPE_NORMAL
- en: We can create an instance of this class, and call that inherited `cmdloop()`
    method to have a working interactive application. This allows us to deploy a working,
    interactive application very quickly and simply. While we're limited to a character-mode,
    command-line interface, we can easily add features without much extra work.
  prefs: []
  type: TYPE_NORMAL
- en: Building GUI applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can differentiate between applications which merely work with graphics and
    applications which are deeply interactive. In the first case, we might have a
    command-line application which creates or modifies image files. In the second
    case, we'll define an application which responds to input events. These interactive
    applications create an event loop which accepts mouse clicks, screen gestures,
    keyboard characters, and other events, and responds to those events. In some respects,
    the only unique feature of a GUI program is the wide variety of events it responds
    to.
  prefs: []
  type: TYPE_NORMAL
- en: The `tkinter` module is an interface between Python and the **Tk** user interface
    widget toolkit. This module helps us build richly interactive applications. When
    we use Python's built-in IDLE editor, we're using an application that was built
    with `tkinter`. The `tkinter` module documentation includes background information
    on the **Tk** widgets.
  prefs: []
  type: TYPE_NORMAL
- en: The `turtle` module also depends on the underlying **Tk** graphics. This module
    also allows us to build simple interactive applications. The turtle idea comes
    from the Logo programming language, in which graphic commands are used to animate
    a "turtle" which traverses the drawing space. The `turtle` model provides a very
    handy specification for certain types of graphics. For example, drawing a rotated
    rectangle can involve a rather complex calculation involving sine and cosine to
    determine the final locations of the four corners. Alternatively, we can direct
    the turtle to use commands such as `forward(w)`, `forward(l)`, and `right(90)`
    to draw a rectangle of the size *w* × *l* from any starting position and any initial
    rotation.
  prefs: []
  type: TYPE_NORMAL
- en: In order to make it easy to learn Python, the `turtle` module provides some
    essential classes that implement a `Screen` and a `Turtle`. The module also includes
    a rich collection of functions that implicitly work with a singleton `Turtle`
    and `Screen` object, eliminating any need to set up the graphics environment.
    For beginners, this function-only environment is a language of simple verbs that
    can be used to learn the foundations of programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'Simple programs look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We've used `from turtle import *` to introduce all of the individual functions.
    This is the common setup for beginners.
  prefs: []
  type: TYPE_NORMAL
- en: We've defined a function, `on_screen()`, which compares the turtle's position,
    given by the `pos()` function, with the overall size of the screen, given by the
    `screensize()` function. Our function uses a simple logical expression to determine
    if the current turtle position is still within the display boundaries.
  prefs: []
  type: TYPE_NORMAL
- en: For people learning to program, the implementation details of the `pos()` and
    `screensize()` functions may not be that helpful. More advanced programmers may
    want to know that the `pos()` function uses the `Turtle.pos()` method of a singleton,
    global `Turtle` instance. Similarly, the `screensize()` function uses the `Screen.screensize()`
    method of a singleton, global `Screen` instance.
  prefs: []
  type: TYPE_NORMAL
- en: The function `spiral()` will draw a spiral-like shape using three parameters
    that define the line segments that comprise the spiral. This function relies on
    the `right()` and `forward()` functions from the `turtle` package to set the turtle's
    orientation and then draw a line segment. While the calculation of the end point
    of the segment drawn by `forward()` may involve a bit of trigonometry, a new programmer
    is able to learn the basics of iteration without struggling with sine or cosine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how we can use this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As part of the initialization, we've set the turtle speed to 10, which is fast.
    For people struggling with loops or conditions, a slower speed can help them follow
    their code as they watch the turtle. We've evaluated the `spiral()` function with
    a set of argument values.
  prefs: []
  type: TYPE_NORMAL
- en: The `done()` function will start a GUI event processing loop that will wait
    for user interaction. We've started the loop *after* the interesting part of the
    drawing because the only expected event is the closing of the graphics window.
    When the window is closed by the user, the `done()` function will also finish.
    Our script can then end normally.
  prefs: []
  type: TYPE_NORMAL
- en: If we're going to build more complex interactive applications, there's a proper
    `mainloop()` function which we can use. This captures events so that our programs
    can respond to those events.
  prefs: []
  type: TYPE_NORMAL
- en: The Logo language—and the related `turtle` package—allow a novice programmer
    to learn the essentials of programming without having to master too many details
    at one time. The `turtle` package isn't designed to produce the same kinds of
    sophisticated technical graphics as a package such as **matplotlib** or **Pillow.**
  prefs: []
  type: TYPE_NORMAL
- en: Using more sophisticated packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can create complex image-processing applications using the Pillow library.
    This package allows us to create thumbnails of large images, convert image formats,
    and verify that a file actually contains encoded image data. We can also use this
    package to create simple scientific graphics showing two-dimensional plots of
    data points. This package isn't designed to build a complete GUI since it doesn't
    handle input events for us. For more information, see [https://pypi.python.org/pypi/Pillow/2.8.1](https://pypi.python.org/pypi/Pillow/2.8.1).
  prefs: []
  type: TYPE_NORMAL
- en: For mathematical, scientific, and statistical work, the matplotlib package is
    widely used. This includes very sophisticated tools for creating essential data
    plots in two and three dimensions. This package is bundled with SciPy and Anaconda.
    For more information, see [http://matplotlib.org](http://matplotlib.org).
  prefs: []
  type: TYPE_NORMAL
- en: There are several more generalized graphical frameworks. One that's often used
    to learn more about Python is the **Pygame** framework. This has a large number
    of components which include tools for graphics as well as sound and image processing.
    The Pygame package includes a number of graphics drivers and is capable of smooth
    animation with a large number of moving objects. See [http://www.pygame.org/news.html](http://www.pygame.org/news.html).
  prefs: []
  type: TYPE_NORMAL
- en: Building web applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Web applications involve a great deal of processing, which is best described
    as boilerplate. The essential handling of the HTTP protocol, for example, is often
    standardized, with libraries that handle it gracefully. The details of parsing
    request headers and mapping a URL path to a specific resource don't need to be
    reinvented.
  prefs: []
  type: TYPE_NORMAL
- en: There is, however, a profound distinction between simply handling the HTTP protocol
    and mapping a URL to an application-specific resource. These two layers drive
    the definition of the **Web Services Gateway Interface** (**WSGI**) design and
    the `wsgi` module is in the standard library. For more information, see **Python
    Enhancement Proposal** (**PEP**) 3333, [https://www.python.org/dev/peps/pep-3333/](https://www.python.org/dev/peps/pep-3333/).
  prefs: []
  type: TYPE_NORMAL
- en: The idea behind WSGI is that all web services should adhere to a single, minimum
    standard for handling the details of HTTP requests and responses. This standard
    allows a complex web server to include a variety of Python tools and frameworks
    that are fitted together using WSGI to ensure that components interconnect properly.
    The mapping of URLs to resources must be handled in the context of this standard.
  prefs: []
  type: TYPE_NORMAL
- en: A `mod_wsgi` module can be plugged into an Apache HTTPD server. This module
    will pass requests and responses between the Apache frontend and backend Python
    instances. With a little bit of planning, we can be sure that static content—graphics,
    style sheets, JavaScript libraries, and so on—are handled by the frontend web
    server. The dynamic content—HTML pages, XML, or JSON documents—are handled by
    our Python application.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on `mod_wsgi`, see [http://www.modwsgi.org/](http://www.modwsgi.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Using a web framework
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Web applications in this context are generally built using a framework that
    parses URLs and invokes a Python function to return the resource located by the
    URL. While this is clearly the minimum required to create a web server, there
    are often a large number of additional features that we'd like to have.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication and authorization, for example, are features we often need and
    would prefer not to have to implement. It's much nicer to work with a framework
    that allows us to add OAuth client code. A website that uses cookies will also
    benefit from having session management features that integrate seamlessly.
  prefs: []
  type: TYPE_NORMAL
- en: Many websites offer RESTful web services. Sometimes these services are thin
    wrappers around database access. When the database is relational, we often want
    an **Object Relational Mapper** (**ORM**) layer that allows us to expose more
    complete objects through the RESTful service. This, too, is a good option for
    a web server framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two broad approaches to providing web services in Python: kits and
    parts. The kits approach is epitomized by packages such as Django which offer
    just about everything that could possibly be required in a unified collection
    of modules and packages. See [https://www.djangoproject.com](https://www.djangoproject.com).'
  prefs: []
  type: TYPE_NORMAL
- en: The parts approach can be seen in projects such as Flask. This is called a **microframework**
    because it does relatively little. A Flask server focuses on URL routing, making
    it ideal for building RESTful services. It may include session management, allowing
    it to be used for HTML sites. It cooperates well with other projects such as Jinja2,
    WTForms, SQLAlchemy, OAuth authentication modules, and many other modules. For
    more information, see [http://flask.pocoo.org/docs/0.10/](http://flask.pocoo.org/docs/0.10/).
  prefs: []
  type: TYPE_NORMAL
- en: Building a RESTful web service with Flask
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll demonstrate a very simple web service. We'll use the algorithm shown earlier
    in the turtle example, with some minor modifications, to create a dynamic graphic
    download. To make it easier to create a downloadable file, we'll discard the simplistic
    turtle graphics package and use the Pillow package to create the image file. Many
    websites use Pillow to validate uploaded images and create thumbnails. It's an
    essential part of any site that uses images.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on Pillow, see [https://pypi.python.org/pypi/Pillow/2.8.1](https://pypi.python.org/pypi/Pillow/2.8.1).
  prefs: []
  type: TYPE_NORMAL
- en: A web service must provide a resource in response to an HTTP request. A simple
    Flask-powered site will have an overall application object and a number of routes
    which map URLs (and possibly method names) to functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This example shows three central features of Flask applications. This script
    defines a `Flask` instance. We've based the instance on the filename, which will
    be `"__main__"` for a main script, but will have the module name for an imported
    script. We've assigned that `Flask` container to a variable, `spiral_app`, for
    use throughout the module file.
  prefs: []
  type: TYPE_NORMAL
- en: A more complex Flask application may have a number of individual view functions
    in a package of submodules. Each of these will depend on the global Flask application.
  prefs: []
  type: TYPE_NORMAL
- en: Our image resource is created by the `image()` function. We provided a `route`
    decorator for this function that shows the URL path and the methods that work
    with this resource. There are a large number of methods defined for the HTTP protocol.
    Many RESTful web services focus on POST, GET, PUT, and DELETE because these match
    the idea of the **Create, Retrieve, Update, and Delete** (**CRUD**) rules commonly
    used to summarize database operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve broken down the `image()` function into four separate pieces. First,
    we need to parse the URL. The `route` includes a placeholder, `<spec>`, which
    Flask parses and provides as a parameter to the function. This will be the URL-encoded
    parameter to describe the spiral. It might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we''ve decoded the specification, we''ll have a special multi-valued dictionary.
    This looks as if the input came from an HTML form. The structure will be a mapping
    from form field names to a list of values for each field. The object looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `image()` function only uses one value from each item; each input must be
    converted to numeric values. We've collected all of the potential exceptions into
    a single `except` clause, obscuring the details of any incorrect input. We use
    the Flask `make_response()` function to build a response with an error message
    and a status code of 403 ("Forbidden"). A more sophisticated function would use
    the **Accept** header to formulate a response as JSON or XML, depending on the
    client's stated preference. We've left it as the default MIME type of text/plain.
  prefs: []
  type: TYPE_NORMAL
- en: The image is saved into a temporary file, created with the `tempfile.mkstemp()`
    function. In this case, we're going to save that temporary file from the Flask
    application. For a low-volume website, this is acceptable. For a higher-volume
    website, a Python application should never handle downloads. The file should be
    created in a directory where the Apache HTTPD server can download the image instead
    of a Python application.
  prefs: []
  type: TYPE_NORMAL
- en: The image construction uses a few Pillow-defined objects to define the drawing
    space. A customized class defines a `Pen` instance which parallels the `turtle.Turtle`
    class. Once the image has been constructed, it's saved with the given filename.
    Note that the Pillow package can save files in a wide variety of formats; we've
    used `.png` in this example.
  prefs: []
  type: TYPE_NORMAL
- en: The final section downloads the file. The comment notes that a high-volume website
    would redirect to a URL from which Apache would download the image file. This
    frees up the Flask server to handle another request.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the local namespace in this function will have two copies of the image.
    The `im` variable will hold the entire, detailed image. The `data` variable will
    hold the compressed filesystem version of the image document. We could use `del
    im` to remove the image object; however, it is generally better to decompose this
    into two functions so that namespaces handle object removal for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can run a demonstration version of this service with the following script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This allows us to work with a running web server on our desktop. We can then
    experiment with different implementation alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: What's important about this example is that we can—very quickly—have a service
    running in our desktop environment. We can then explore and experiment with the
    user experience very easily. For example, since the image will be embedded in
    an HTML page, we want to design and debug the HTML, CSS, and JavaScript for that
    page. This whole development process is made easier when we have a simple, easily-tweaked
    web server.
  prefs: []
  type: TYPE_NORMAL
- en: Plugging into a MapReduce framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For background on the Apache Hadoop server, see [https://hadoop.apache.org](https://hadoop.apache.org).
    Here''s the summary:'
  prefs: []
  type: TYPE_NORMAL
- en: '*The Apache Hadoop software library is a framework that allows for the distributed
    processing of large datasets across clusters of computers using simple programming
    models. It is designed to scale up from single servers to thousands of machines,
    each offering local computation and storage.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'One part of the Hadoop distributed processing is the MapReduce module. This
    module allows us to decompose analysis of data into two complementary operations:
    map and reduce. These operations are distributed around the Hadoop cluster to
    be run concurrently. A map operation processes all of the rows of datasets that
    are scattered around the cluster. The outputs from map operations are then fed
    to reduce operations to be summarized.'
  prefs: []
  type: TYPE_NORMAL
- en: The Hadoop streaming interface can be used by Python programmers. This involves
    a Hadoop "wrapper" that will present the data to a Python mapper program as the
    standard input file. The standard output from a mapper must be tab-delimited key-value
    pairs. These are sent to the reduce programs, again as standard input. For more
    information on packages that help Python programmers use Hadoop, see [http://blog.cloudera.com/blog/2013/01/a-guide-to-python-frameworks-for-hadoop/](http://blog.cloudera.com/blog/2013/01/a-guide-to-python-frameworks-for-hadoop/).
  prefs: []
  type: TYPE_NORMAL
- en: 'One common example of MapReduce operations is creating a concordance of words
    found in books. The mapping operation will transform a giant text file into sequences
    of words found in the text file. The reduce operation will count the occurrences
    of each word, resulting in a final summary of words and their popularity. (For
    more information on how important this can be, visit the NLTK website: [http://www.nltk.org](http://www.nltk.org).)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Practical problems may involve multiple mappings and multiple reductions. In
    many cases, the mappings will often seem trivial: they''ll extract a key and a
    value from each row of source data. Rather than study Hadoop too much, we''ll
    show how we can write and test mappers and reducers on our desktop.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our goal is to have two programs, `map.py` and `reduce.py`, that can be combined
    into a stream like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This approach will simulate Hadoop streaming by supplying data to our `map.py`
    program and our `reduce.py` program. This will serve as a simple integration test
    for our map and reduce processing. For Windows, we would use the `type` command
    instead of the Linux `cat` program.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at some raw climate data from the US National Ocean and Atmospheric
    Administration's National Climatic Data Center. Refer to [http://www.ncdc.noaa.gov/cdo-web/](http://www.ncdc.noaa.gov/cdo-web/)
    for climate data online. We can request files with details such as snowfall for
    a given time period.
  prefs: []
  type: TYPE_NORMAL
- en: Our question is "Which months have snowfall at the Richmond, VA, airport?" The
    snowfall data attribute is named `TSNW`. It's in units of one-tenth of an inch,
    so our mapper needs to convert it to `Decimal` inches to be more useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can write a map script that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Because our input is in more or less standard CSV notation—with a heading—we
    can use a `csv.DictReader` object to parse the input. Each row of data is a `dict`
    object with keys defined by the first line of the CSV file. The output is more
    specialized: with Hadoop it must be a tab-delimited key and value, terminated
    with a newline character.'
  prefs: []
  type: TYPE_NORMAL
- en: For each input dictionary object, we'll convert the date from text to a proper
    Python date so that we can reliably extract the month. We could do this by using
    `row['DATE'][4:6]`, but that seems opaque. The mapper includes a filter to reject
    months that have no snow, or have a domain-specific null value (9999 or -9999)
    instead of a measurement.
  prefs: []
  type: TYPE_NORMAL
- en: The output is a key and a value. Our key is the reported month; the value is
    the snowfall converted from one-tenth inch to inch measurements. We've used the
    `Decimal` class to avoid introducing floating-point approximations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reduce operation uses a `Counter` object to summarize the results produced
    by the mapper. For this example, the reduce looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The reduce reader matches the mapper''s writer: they both use a delimiter of
    a tab and a line terminator of the newline character. This follows Hadoop''s requirements
    for the data that flows from mappers to reducers. We''ve also created a `Counter`
    object to store our snowfall data.'
  prefs: []
  type: TYPE_NORMAL
- en: For each line of input, we extract the inches of snowfall and accumulate those
    in the `Counter` object with a key of the month number. The final result will
    show the inches of snow for each month in the greater Richmond metropolitan area.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can easily test and experiment with this on our desktop. We can execute
    a pipeline of mapper, sort, and reducer using either a shell script or perhaps
    a little wrapper program like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We've created a command that will work on Mac OS X or Linux, and substituted
    a filename into that command. For Windows we can use `type` instead of `cat`;
    the Python program might be named `python` instead of `python3`. Otherwise, the
    shell pipeline should work fine in Windows.
  prefs: []
  type: TYPE_NORMAL
- en: We've used the `subprocess.check_output()` function to run this shell command
    and collect the output. This is a quick way to experiment with our Hadoop programs
    while avoiding the delays associated with using a busy Hadoop cluster.
  prefs: []
  type: TYPE_NORMAL
- en: This approach works well as long as we stick to elements of the libraries that
    are properly installed in the Hadoop environment. In some cases, our cluster might
    have Anaconda installed, giving us access to a wide variety of packages. When
    we want to use our own package—one that's not installed throughout the cluster—we'll
    need to provide the additional module to the Hadoop streaming command to be sure
    that our additional modules are downloaded to each node in the cluster, along
    with our mapper and reducer.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've looked at several kinds of Python applications. While
    Python is used widely, we've picked a few areas of focus. We've looked at CLI
    applications capable of processing large volumes of data. The command-line interface
    is also present in other kinds of applications, making this a fundamental part
    of any program.
  prefs: []
  type: TYPE_NORMAL
- en: We've looked at GUI programs, using only the built-in `turtle` module. The GUI
    frameworks that are widely used involve downloads, installation, and more sophisticated
    programming that we could not illustrate in a single chapter. There are several
    popular choices; there's no consensus on a "best" package for GUI applications.
    Making a choice is difficult.
  prefs: []
  type: TYPE_NORMAL
- en: We've also looked at web applications, using the Flask module. This is also
    a separate download. In many cases, there are a number of related downloads that
    will become part of a web application. We might include Jinja2, WTForms, OAuth,
    SQLAlchemy, and Pillow, to expand the web server's libraries.
  prefs: []
  type: TYPE_NORMAL
- en: We've also looked at how we might leverage desktop Python to develop Hadoop
    applications. Rather than download and install Hadoop, we can create a processing
    pipeline that follows the Hadoop approach. We can write mappers and reducers using
    only desktop tools, allowing us to create reliable unit tests. This gives us the
    confidence that we'll get the expected results when running our applications on
    the Hadoop cluster with a complete set of data.
  prefs: []
  type: TYPE_NORMAL
- en: This isn't all, of course. Python can be used inside another application as
    the language for automating that application. A program can embed a Python interpreter
    which interacts with the overall application. For more information, see [https://docs.python.org/2/extending/embedding.html](https://docs.python.org/2/extending/embedding.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can imagine the universe of Python applications as a large body of water
    filled with islands, archipelagos, inlets, and estuaries. Chesapeake Bay on the
    US East Coast is an example. We''ve tried to show the principal features of this
    bay: the headlands, points, shallows, and coastlines. We''ve avoided the effects
    of currents, weather, and tides, so that we can focus on the essential features
    of the bay. Pragmatic navigation along a specific route requires more study of
    the area of interest: detailed navigation charts, pilot guides, and local knowledge
    from other mariners.'
  prefs: []
  type: TYPE_NORMAL
- en: It's important to consider the extent of the Python universe. The distance to
    a destination can appear daunting. Our objective has been to show some principal
    waypoints that can help break a long voyage into shorter legs. If we isolate the
    legs of a long journey, we can solve each of them separately and build a larger
    solution from the pieces.
  prefs: []
  type: TYPE_NORMAL
