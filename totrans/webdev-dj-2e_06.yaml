- en: 6\. Forms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6. 表单
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter introduces web forms, a method of sending information from the
    browser to the web server. It starts with an introduction to forms in general
    and discusses how data is encoded to be sent to the server. You will learn about
    the differences between sending form data in a `GET` HTTP request and sending
    it in a `POST` HTTP request, and how to choose which one to use. By the end of
    the chapter, you will know how Django's form library is used to build and validate
    forms automatically and how it cuts down the amount of manual HTML you need to
    write.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了Web表单，这是一种从浏览器向Web服务器发送信息的方法。它从对表单的一般介绍开始，并讨论了如何将数据编码以发送到服务器。你将了解在`GET`
    HTTP请求中发送表单数据与在`POST` HTTP请求中发送数据的区别，以及如何选择使用哪一个。到本章结束时，你将了解Django表单库是如何自动构建和验证表单的，以及它是如何减少你需要编写的手动HTML数量的。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: So far, the views we have been building for Django have been one-way only. Our
    browser is retrieving data from the views we have written but it does not send
    any data back to them. In *Chapter 4*, *Introduction to Django Admin*, we created
    model instances using the Django admin and submitting forms, but those were using
    views built into Django, not created by us. In this chapter, we will use the Django
    Forms library to start accepting user-submitted data. The data will be provided
    through `GET` requests in the URL parameters, and/or `POST` requests in the body
    of the request. But before we get into the details, first let us understand what
    are forms in Django.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们为Django构建的视图都是单向的。我们的浏览器正在从我们编写的视图中检索数据，但没有向它们发送任何数据。在*第4章*，*Django
    Admin简介*中，我们使用Django admin创建模型实例并提交表单，但那些是使用Django内置的视图，而不是我们创建的。在本章中，我们将使用Django表单库开始接受用户提交的数据。数据将通过URL参数中的`GET`请求提供，以及/或请求体中的`POST`请求。但在我们深入了解细节之前，首先让我们了解Django中的表单是什么。
- en: What Is a Form?
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是表单？
- en: When working with an interactive web app, we not only want to provide data to
    users but also accept data from them to either customize the responses we are
    generating or let them submit data to the site. When browsing the web, you will
    most definitely have used forms. Whether you're logging in to your internet banking
    account, surfing the web with a browser, posting a message on social media, or
    writing an email in an online email client, in all these cases, you are entering
    data in a form. A form is made up of inputs that define key-value pairs of data
    to submit to the server. For example, when logging in to a website, the data being
    sent would have the keys *username* and *password*, with the values of your username
    and your password, respectively. We will go into the different types of inputs
    in more detail in the *Types of Inputs* section. Each input in the form has a
    *name*, and this is how its data is identified on the server-side (in a Django
    view). There can be multiple inputs with the same *name*, whose data is available
    in a list containing all the posted values with this name – for example, a list
    of checkboxes with permissions to apply to users. Each checkbox would have the
    same name but a different value. The form has attributes that specify which URL
    the browser should submit the data to and what method it should use to submit
    the data (browsers only support `GET` or `POST`).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当与交互式Web应用程序一起工作时，我们不仅希望向用户提供数据，还希望从他们那里接收数据，以便自定义我们正在生成的响应或让他们提交数据到网站。在浏览网页时，你肯定已经使用过表单。无论你是登录互联网银行账户、使用浏览器上网、在社交媒体上发帖，还是在在线电子邮件客户端中写电子邮件，在这些所有情况下，你都是在表单中输入数据。表单由定义要提交给服务器的键值对数据的输入组成。例如，当登录到网站时，发送的数据将包含*用户名*和*密码*键，分别对应你的用户名和密码的值。我们将在*输入类型*部分更详细地介绍不同类型的输入。表单中的每个输入都有一个*名称*，这是在服务器端（在Django视图中）识别其数据的方式。可以有多个具有相同*名称*的输入，其数据在包含所有具有此名称的已发布值的列表中可用——例如，具有应用于用户的权限的复选框列表。每个复选框将具有相同的名称但不同的值。表单具有指定浏览器应提交数据到哪个URL以及应使用什么方法提交数据的属性（浏览器仅支持`GET`或`POST`）。
- en: 'The GitHub login form shown in the next figure is an example of a form:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个图中显示的GitHub登录表单是一个表单的例子：
- en: '![Figure 6.1: The GitHub login page is an example of a form'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.1：GitHub登录页面是一个表单的例子](img/B15509_06_01.jpg)'
- en: '](img/B15509_06_01.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.1：GitHub登录页面是一个表单的例子](img/B15509_06_01.jpg)'
- en: 'Figure 6.1: The GitHub login page is an example of a form'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1：GitHub登录页面是一个表单的例子
- en: 'It has three visible inputs: a text field (`Username`), a `password` field
    (`Password`), and a `submit` button (`Sign in`). It also has a field that is not
    visible – its type is `hidden`, and it contains a special token for security called
    a `Sign In` button, the form data is submitted with a `POST` request. If you entered
    a valid username and password, you are logged in; otherwise, the form will display
    an error as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 它有三个可见的输入：一个文本字段（`用户名`），一个`密码`字段，以及一个`提交`按钮（`登录`）。它还有一个不可见的字段——其类型是`hidden`，它包含一个用于安全的特殊令牌，称为`登录`按钮，表单数据通过`POST`请求提交。如果你输入了有效的用户名和密码，你将登录；否则，表单将显示以下错误：
- en: '![Figure 6.2: Form submitted with an incorrect username or password'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.2：提交了错误的用户名或密码的表单'
- en: '](img/B15509_06_02.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15509_06_02.jpg)'
- en: 'Figure 6.2: Form submitted with an incorrect username or password'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2：提交了错误的用户名或密码的表单
- en: 'There are two states a form can have: **pre-submit** and **post-submit**. The
    first is the initial state when the page is first loaded. All the fields will
    have a default value (usually empty) and no errors will be displayed. If all the
    information that has been entered into a form is valid, then usually when it is
    submitted you will be taken to a page showing the results of submitting the form.
    This might be a search results page, or a page showing you the new object that
    you created. In this case, you will not see the form in its post-submit state.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 表单可以有两种状态：**提交前**和**提交后**。第一种是页面首次加载时的初始状态。所有字段都将有一个默认值（通常是空的）且不会显示任何错误。如果已输入到表单中的所有信息都是有效的，那么通常在提交时，你将被带到显示表单提交结果的页面。这可能是一个搜索结果页面，或者显示你创建的新对象的页面。在这种情况下，你将不会看到表单的提交后状态。
- en: If you did not enter valid information into the form, then it will be rendered
    again in its post-submit state. In this state, you will be shown the information
    that you entered as well as any errors to help you resolve the problems with the
    form. The errors may be **field errors** or **non-field errors**. Field errors
    apply to a specific field. For example, leaving a required field blank or entering
    a value that is too large, too small, too long, or too short. If a form required
    you to enter your name and you left it blank, this would be displayed as a field
    error next to that field.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有在表单中输入有效信息，那么它将再次以提交后的状态呈现。在这个状态下，你会看到你输入的信息以及任何错误，以帮助你解决表单中的问题。错误可能是**字段错误**或**非字段错误**。字段错误适用于特定字段。例如，遗漏必填字段或输入过大、过小、过长或过短的价值。如果表单要求你输入你的名字而你留空了，这将在该字段旁边显示为字段错误。
- en: Non-field errors either do not apply to a field, or apply to multiple fields,
    and are displayed at the top of the form. In *Figure 6.2*, we see a message that
    either the username or password may be incorrect when logging in. For security,
    GitHub does not reveal whether a username is valid, and so this is displayed as
    a non-field error rather than a field error for the username or password (Django
    also follows this convention). Non-field errors also apply to fields that depend
    on each other. For example, on a credit card form, if the payment is rejected,
    we might not know if the credit card number or security code is incorrect; therefore,
    we cannot show that error on a specific field. It applies to the form as a whole.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 非字段错误可能不适用于字段，或者适用于多个字段，并在表单顶部显示。在*图6.2*中，我们看到一条消息，表明在登录时用户名或密码可能不正确。出于安全考虑，GitHub不会透露用户名是否有效，因此这被显示为非字段错误，而不是用户名或密码的字段错误（Django也遵循这个约定）。非字段错误也适用于相互依赖的字段。例如，在信用卡表单中，如果支付被拒绝，我们可能不知道是信用卡号码还是安全码不正确；因此，我们无法在特定字段上显示该错误。它适用于整个表单。
- en: The <form> Element
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`<form>`元素'
- en: 'All inputs used during form submission must be contained inside a `<form>`
    element. There are three HTML attributes that you will be using to modify the
    behavior of the form:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在表单提交过程中使用的所有输入都必须包含在`<form>`元素内。你将使用以下三个HTML属性来修改表单的行为：
- en: '`method`'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`method`'
- en: This is the HTTP method used to submit the form, either `GET` or `POST`. If
    omitted, this defaults to `GET` (because this is the default method when typing
    a URL into the browser and hitting *Enter*).
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是提交表单时使用的HTTP方法，可以是`GET`或`POST`。如果省略，则默认为`GET`（因为这是在浏览器中键入URL并按*Enter*时的默认方法）。
- en: '`action`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`action`'
- en: This refers to the URL (or path) to send the form data to. If omitted, the data
    gets sent back to the current page.
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这指的是发送表单数据到的URL（或路径）。如果省略，数据将返回到当前页面。
- en: '`enctype`'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enctype`'
- en: This sets the encoding type of the form. You only need to change this if you
    are using the form to upload files. The most common values are `application/x-www-form-urlencoded`
    (the default if this value is omitted) or `multipart/form-data` (set this if uploading
    files). Note that you don't have to worry about the encoding type in your view;
    Django handles the different types automatically.
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这设置了表单的编码类型。只有在你使用表单上传文件时才需要更改此设置。最常用的值是 `application/x-www-form-urlencoded`（如果省略此值则为默认值）或
    `multipart/form-data`（如果上传文件则设置此值）。请注意，你不需要担心视图中的编码类型；Django 会自动处理不同类型。
- en: 'Here is an example of a form without any of its attributes set:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个没有设置任何属性的表单示例：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It will submit its data using a `GET` request, to the current URL that the form
    is being displayed on, using the `application/x-www-form-urlencoded` encoding
    type.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 它将使用 `GET` 请求提交数据，到当前表单显示的当前 URL，使用 `application/x-www-form-urlencoded` 编码类型。
- en: 'In this next example, we will set all three attributes on a form:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们将在一个表单上设置所有三个属性：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This form will submit its data with a `POST` request to the `/form-submit` path,
    encoding the data as `multipart/form-data`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此表单将使用 `POST` 请求将数据提交到 `/form-submit` 路径，并将数据编码为 `multipart/form-data`。
- en: How do `GET` and `POST` requests differ in how the data is sent? Recall in *Chapter
    1*, *Introduction to Django*, we discussed what the underlying HTTP request and
    response data that your browser sends looks like. In these next two examples,
    we will submit the same form twice, the first time using `GET` and the second
    time using `POST`. The form will have two inputs, a first name, and the last name.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`GET` 和 `POST` 请求在数据发送方式上有什么不同？回想一下 *第一章*，*Django 简介*，我们讨论了浏览器发送的底层 HTTP 请求和响应数据的样子。在接下来的两个示例中，我们将两次提交相同的表单，第一次使用
    `GET`，第二次使用 `POST`。表单将有两个输入，一个姓和一个名。'
- en: 'A form submitted using `GET` sends its data in the URL, like this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `GET` 提交的表单将数据放在 URL 中，如下所示：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'A form submitted using `POST` sends its data in the body of the request, like
    this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `POST` 提交的表单将数据放在请求体中，如下所示：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You will notice that the form data is encoded the same way in both cases; it
    is just placed differently for the `GET` and `POST` requests. In an upcoming section,
    we will discuss how to choose between these two types of requests.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，在两种情况下表单数据都是用相同的方式进行编码；只是 `GET` 和 `POST` 请求放置的位置不同。在接下来的一个部分中，我们将讨论如何在这两种请求类型之间进行选择。
- en: Types of Inputs
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输入类型
- en: We have seen four examples of inputs so far (*text*, *password*, *submit*, and
    *hidden*). Most inputs are created with an `<input>` tag, and their type is specified
    with its `type` attribute. Each input has a `name` attribute that defines the
    key for the key-value pairs that are sent to the server in the HTTP request.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了四个输入示例（*文本*、*密码*、*提交*和*隐藏*）。大多数输入都是通过 `<input>` 标签创建的，并且它们的类型通过其 `type`
    属性指定。每个输入都有一个 `name` 属性，它定义了发送到服务器的 HTTP 请求中的键值对的键。
- en: In the next exercise, let's look at how we can build a form in HTML. This will
    allow you to get up to speed on many different form fields.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，让我们看看我们如何使用 HTML 构建表单。这将使你能够熟悉许多不同的表单字段。
- en: Note
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The code for all the exercises and activities used in this chapter can be found
    on the book's GitHub repository at [http://packt.live/2KGjlaM](http://packt.live/2KGjlaM).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的所有练习和活动的代码可以在书的 GitHub 仓库中找到，网址为 [http://packt.live/2KGjlaM](http://packt.live/2KGjlaM)。
- en: 'Exercise 6.01: Building a Form in HTML'
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 6.01：在 HTML 中构建表单
- en: 'For the first few exercises of this chapter, we will need an HTML form to test
    with. We will manually code one in this exercise. This will also allow you to
    experiment with how different fields are validated and submitted. This will be
    done in a new Django project so that we don''t interfere with Bookr. You can refer
    to *Chapter 1*, *Introduction to Django*, to refresh your memory on creating a
    Django project:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前几个练习中，我们需要一个 HTML 表单来进行测试。我们将在这个练习中手动编写一个。这还将允许你实验不同字段如何进行验证和提交。这将在一个新的
    Django 项目中完成，这样我们就不干扰 Bookr。你可以参考 *第一章*，*Django 简介*，来刷新你对创建 Django 项目的记忆：
- en: 'We will start by creating the new Django project. You can re-use the `bookr`
    virtual environment that already has Django installed. Open a new terminal and
    activate the virtual environment. Then, use `django-admin` to start a Django project
    named `form_project`. To do this, run the command:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先创建新的 Django 项目。你可以重用已经安装了 Django 的 `bookr` 虚拟环境。打开一个新的终端并激活虚拟环境。然后，使用 `django-admin`
    启动一个名为 `form_project` 的 Django 项目。为此，请运行以下命令：
- en: '[PRE4]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This will scaffold the Django project in a directory named `form_example`.
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将在名为`form_example`的目录中构建Django项目。
- en: 'Create a new Django app in this project by using the `startapp` management
    command. The app should be called `form_example`. To do this, `cd` into the `form_project`
    directory, then run this:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用`startapp`管理命令在此项目中创建一个新的Django应用。该应用应命名为`form_example`。为此，请`cd`到`form_project`目录，然后运行以下命令：
- en: '[PRE5]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This will create the `form_example` app directory inside the `form_project`
    directory.
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将在`form_project`目录内创建`form_example`应用目录。
- en: 'Launch PyCharm, then open the `form_project` directory. If you already have
    a project open, you can do this by choosing `File` -> `Open`; otherwise, just
    click `Open` in the `Welcome to PyCharm` window. Navigate to the `form_project`
    directory, select it, then click `Open`. The `form_project` project window should
    be shown similar to this:![Figure 6.3: The form_project project open'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动PyCharm，然后打开`form_project`目录。如果您已经有一个项目打开，可以通过选择`文件` -> `打开`来完成此操作；否则，只需在`欢迎使用PyCharm`窗口中点击`打开`。导航到`form_project`目录，选择它，然后点击`打开`。`form_project`项目窗口应类似于以下所示：![图6.3：form_project项目已打开
- en: '](img/B15509_06_03.jpg)'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15509_06_03.jpg)'
- en: 'Figure 6.3: The form_project project open'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图6.3：form_project项目已打开
- en: 'Create a new run configuration to execute `manage.py runserver` for the project.
    You can re-use the `bookr` virtual environment again. The `Run/Debug Configurations`
    window should look similar to the following figure when you''re done:![Figure
    6.4: Run/Debug Configurations for Runserver'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的运行配置来执行项目的`manage.py runserver`。您可以再次使用`bookr`虚拟环境。完成设置后，`运行/调试配置`窗口应类似于以下图示：![图6.4：运行/调试配置为Runserver
- en: '](img/B15509_06_04.jpg)'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15509_06_04.jpg)'
- en: 'Figure 6.4: Run/Debug Configurations for Runserver'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图6.4：运行/调试配置为Runserver
- en: You can test that the configuration is set up correctly by clicking the `Run`
    button, then visiting `http://127.0.0.1:8000/` in your browser. You should see
    the Django welcome screen. If the debug server fails to start or you see the Bookr
    main page, then you probably still have the Bookr project running. Try stopping
    the Bookr `runserver` process and then starting the new one you just set up.
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以通过点击`运行`按钮来测试配置是否设置正确，然后在浏览器中访问`http://127.0.0.1:8000/`。您应该看到Django欢迎屏幕。如果调试服务器无法启动或您看到Bookr主页面，那么您可能仍然有Bookr项目在运行。尝试停止Bookr的`runserver`进程，然后启动您刚刚设置的新进程。
- en: Open `settings.py` in the `form_project` directory and add `'form_example'`
    to the `INSTALLED_APPS` setting.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`form_project`目录中打开`settings.py`文件，并将`'form_example'`添加到`INSTALLED_APPS`设置中。
- en: The last step in setting up this new project is to create a `templates` directory
    for the `form_example` app. Right-click on the `form_example` directory and then
    select `New` -> `Directory`. Name it `templates`.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置此新项目的最后一步是为`form_example`应用创建一个`templates`目录。在`form_example`目录上右键单击，然后选择`新建`
    -> `目录`。将其命名为`templates`。
- en: We need an HTML template to display our form. Create one by right-clicking the
    `templates` directory you just created and choosing `New` -> `HTML File`. In the
    dialog box that appears, enter the name `form-example.html` and hit *Enter* to create
    it.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一个HTML模板来显示我们的表单。通过右键单击您刚刚创建的`templates`目录并选择`新建` -> `HTML文件`来创建一个。在出现的对话框中，输入名称`form-example.html`并按*Enter*键创建它。
- en: The `form-example.html` file should now be open in the editor pane of PyCharm.
    Start by creating the `form` element. We will set its `method` attribute to `post`.
    The `action` attribute will be omitted, which means the form will submit back
    to the same URL on which it was loaded.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`form-example.html`文件现在应在PyCharm的编辑器窗格中打开。首先创建`form`元素。我们将将其`method`属性设置为`post`。`action`属性将被省略，这意味着表单将提交回加载它的同一URL。'
- en: 'Insert this code between the `<body>` and `</body>` tags:'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`<body>`和`</body>`标签之间插入此代码：
- en: '[PRE6]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now let us add a few inputs. To add a little bit of spacing between each input,
    we will wrap them inside `<p>` tags. We will start with a text field and password
    field. This code should be inserted between the `<form>` tags you just created:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们添加一些输入。为了在各个输入之间添加一些间距，我们将它们包裹在`<p>`标签内。我们将从一个文本字段和一个密码字段开始。此代码应插入到您刚刚创建的`<form>`标签之间：
- en: '[PRE7]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, we will add two checkboxes and three radio buttons. Insert this code
    after the HTML you added in the previous step; it should come before the `</form>` tag:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将添加两个复选框和三个单选按钮。在您在上一步中添加的HTML代码之后插入此代码；它应该在`</form>`标签之前：
- en: '[PRE8]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next is a dropdown select menu to allow the user to choose a favorite book.
    Add this code after that of the previous step but before the `</form>` tag:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是一个下拉选择菜单，允许用户选择喜欢的书籍。在上一步骤的代码之后但`</form>`标签之前添加以下代码：
- en: '[PRE9]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It will display four options that are split into two groups. The user will only
    be able to select one option.
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它将显示四个选项，分为两组。用户只能选择一个选项。
- en: 'The next is a multiple select (achieved by using the `multiple` attribute).
    Add this code after that of the previous step but before the `</form>` tag:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个是多选（通过使用`multiple`属性实现）。在上一步骤的代码之后但`</form>`标签之前添加以下代码：
- en: '[PRE10]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The user can select zero or more options from the four. They are displayed in
    two groups.
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 用户可以从四个选项中选择零个或多个。它们分为两组显示。
- en: 'Next is `textarea`. It is like a text field but has multiple lines. This code
    should be added like in the previous steps, before the closing `</form>` tag:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是`textarea`。它就像一个文本字段，但有多行。这段代码应该像在之前的步骤中一样添加，在关闭`</form>`标签之前：
- en: '[PRE11]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, add some fields for specific data types: `number`, `email`, and `date`
    inputs. Add this all before the `</form>` tag:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加一些特定数据类型的字段：在`</form>`标签之前添加`number`、`email`和`date`输入。添加以下所有内容：
- en: '[PRE12]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now add some buttons to submit the form. Once again, insert this before the
    closing `</form>` tag:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在添加一些按钮来提交表单。再次，在关闭`</form>`标签之前插入以下内容：
- en: '[PRE13]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This demonstrates two ways of creating submit buttons, either as `<input>` or `<button>`.
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这展示了两种创建提交按钮的方式，要么作为`<input>`，要么作为`<button>`。
- en: 'Finally, add a hidden field. Insert this before the closing `</form>` tag:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加一个隐藏字段。在关闭`</form>`标签之前插入以下内容：
- en: '[PRE14]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This field cannot be seen or edited so it has a fixed value. You can save and
    close `form-example.html`.
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个字段既看不见也编辑不了，因此它有一个固定的值。你可以保存并关闭`form-example.html`。
- en: 'As with any template, we cannot see it unless we have a view to render it.
    Open the `form_example` app''s `views.py` file and add a new view called `form_example`.
    It should render and return the template you just created, like so:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像任何模板一样，除非我们有视图来渲染它，否则我们看不到它。打开`form_example`应用的`views.py`文件，并添加一个名为`form_example`的新视图。它应该渲染并返回你刚刚创建的模板，如下所示：
- en: '[PRE15]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You can now save and close `views.py`.
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你现在可以保存并关闭`views.py`。
- en: 'You should be familiar with the next step now, which is to add a URL mapping
    to the view. Open the `urls.py` file in the `form_project` package directory.
    Add a mapping for the path `form-example` to your `form_example` view, to the
    `urlpatterns` variable. It should look like this:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在应该熟悉下一步，即添加一个URL映射到视图。打开`form_project`包目录中的`urls.py`文件。将`form-example`路径映射到`form_example`视图的`urlpatterns`变量。它应该看起来像这样：
- en: '[PRE16]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Make sure you also add an import of `form_example.views`. Save and close `urls.py`.
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保你还要添加对`form_example.views`的导入。保存并关闭`urls.py`。
- en: 'Start the Django dev server (if it is not already running), then load your
    new view in your web browser; the address is `http://127.0.0.1:8000/form-example/`.
    Your page should look like this:![Figure 6.5: Example inputs page'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Django开发服务器（如果尚未运行），然后在你的网页浏览器中加载你的新视图；地址是`http://127.0.0.1:8000/form-example/`。你的页面应该看起来像这样：![图6.5：示例输入页面
- en: '](img/B15509_06_05.jpg)'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15509_06_05.jpg)'
- en: 'Figure 6.5: Example inputs page'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图6.5：示例输入页面
- en: 'You can now familiarize yourself with the behavior of the web forms and see
    how they are generated from the HTML you specified. One activity to try is to
    enter invalid data into the number, date, or email inputs and click the submit
    button – the built-in HTML validation should prevent the form from being submitted:'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你现在可以熟悉网页表单的行为，并查看它们是如何从你指定的HTML生成的。一个可以尝试的活动是将无效数据输入到数字、日期或电子邮件输入框中，然后点击提交按钮——内置的HTML验证应该阻止表单提交：
- en: '![Figure 6.6: Browser error due to an invalid number'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图6.6：由于无效数字导致的浏览器错误'
- en: '](img/B15509_06_06.jpg)'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15509_06_06.jpg)'
- en: 'Figure 6.6: Browser error due to an invalid number'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图6.6：由于无效数字导致的浏览器错误
- en: 'We have not yet set up everything for form submission, so if you correct all
    the errors in the form and try to submit it (by clicking either of the submit
    buttons), you will receive an error stating `CSRF verification failed. Request
    aborted.`, as we can see in the next figure. We will talk about what this means,
    and how to fix it, later in the chapter:'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还没有为表单提交设置好一切，所以如果你纠正表单中的所有错误并尝试提交（通过点击任一提交按钮），你将收到一个错误，指出`CSRF验证失败。请求已中止。`，正如我们可以在下一张图中看到的那样。我们将在本章后面讨论这意味着什么，以及如何修复它：
- en: '![Figure 6.7: CSRF verification error'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图6.7：CSRF验证错误'
- en: '](img/B15509_06_07.jpg)'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15509_06_07.jpg)'
- en: 'Figure 6.7: CSRF verification error'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图6.7：CSRF验证错误
- en: If you do receive the error, just go back in your browser to return to the input
    example page.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你确实收到了错误，只需在浏览器中返回到输入示例页面。
- en: In this exercise, you created an example page showcasing many HTML inputs, then
    created a view to render it and a URL to map to it. You loaded the page in your
    browser and experimented with changing data and trying to submit the form when
    it contained errors.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你创建了一个展示许多HTML输入的示例页面，然后创建了一个视图来渲染它，并创建了一个URL来映射它。你在浏览器中加载了这个页面，并尝试更改数据，当表单包含错误时尝试提交它。
- en: Form Security with Cross-Site Request Forgery Protection
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带有跨站请求伪造保护的表单安全
- en: Throughout the book, we have mentioned features that Django includes to prevent
    certain types of security exploits. One of these features is protection against
    CSRF.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们提到了Django包含的一些功能，以防止某些类型的安全漏洞。其中之一就是防止CSRF的功能。
- en: 'A CSRF attack exploits the fact that a form on a website can be submitted to
    any other website. The `action` attribute of `form` just needs to be set appropriately.
    Let''s take an example for Bookr. We don''t have this set up yet, but we will
    be adding a view and URL that allows us to post a review for a book. To do this,
    we''ll have a form for posting the review content and selecting the rating. Its
    HTML is like this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: CSRF攻击利用了网站上的表单可以被提交到任何其他网站的事实。"form"的"action"属性只需设置得当。以Bookr为例。我们还没有设置这个，但我们将添加一个视图和URL，允许我们为书籍发表评论。为此，我们将有一个用于发布评论内容和选择评分的表单。它的HTML如下所示：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'And on a web page, it would look like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在网页上，它看起来会是这样：
- en: '![Figure 6.8: Example review creation form'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.8：示例评论创建表单'
- en: '](img/B15509_06_08.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15509_06_08.jpg)'
- en: 'Figure 6.8: Example review creation form'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8：示例评论创建表单
- en: 'Someone could take this form, make a few changes, and host it on their own
    website. For example, they could make the inputs hidden and hardcode a good review
    and rating for a book, and then make it look like some other kind of form, like
    this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 某人可以拿走这个表单，做一些修改，然后在自己的网站上托管它。例如，他们可以隐藏输入并硬编码一个好评和评分，然后让它看起来像其他类型的表单，如下所示：
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Of course, the hidden fields don't display, so the form looks like this on the
    malicious website.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，隐藏字段不会显示，所以在恶意网站上表单看起来是这样的。
- en: '![Figure 6.9: Hidden inputs are not visible'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.9：隐藏输入不可见'
- en: '](img/B15509_06_09.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15509_06_09.jpg)'
- en: 'Figure 6.9: Hidden inputs are not visible'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.9：隐藏输入不可见
- en: The user would think they were clicking a button to enter a website, but while
    clicking it, they would submit the hidden values to the original view on Bookr.
    Of course, a user could check the source code of the page they were on to check
    what data is being sent and where, but most users are unlikely to inspect every
    form they come across. The attacker could even have the form with no submit button
    and just use JavaScript to submit it, which means the user would be submitting
    the form without even realizing it.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 用户会以为他们点击的是一个按钮以进入一个网站，但在点击的过程中，他们会向Bookr上的原始视图提交隐藏的值。当然，用户可以检查他们所在页面的源代码来查看正在发送什么数据以及发送到何处，但大多数用户不太可能检查他们遇到的每一个表单。攻击者甚至可以有一个没有提交按钮的表单，只用JavaScript来提交它，这意味着用户在甚至没有意识到的情况下就提交了表单。
- en: You may think that requiring the user to log in to Bookr will prevent this type
    of attack, and it does limit its effectiveness somewhat, as the attack would then
    only work for logged-in users. But because of the way authentication works, once
    a user is logged in, they have a cookie set in their browser that identifies them
    to the Django application. This cookie is sent on every request so that the user
    does not have to provide their login credentials on every page. Because of the
    way web browsers work, they will include the server's authentication cookie in
    *all* requests they send to that particular server. Even though our form is hosted
    on a malicious site, ultimately it is sending a request to our application, so
    it will send through our server's cookies.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为要求用户登录到Bookr可以防止这种攻击，这确实在一定程度上限制了其有效性，因为攻击将仅对已登录用户有效。但由于认证的方式，一旦用户登录，他们的浏览器中就会设置一个cookie来识别他们到Django应用程序。这个cookie在每次请求时都会发送，这样用户就不必在每一页上提供他们的登录凭证。由于网络浏览器的工作方式，它们会在发送到特定服务器的所有请求中包含服务器的认证cookie。即使我们的表单托管在恶意网站上，最终它还是会发送一个请求到我们的应用程序，所以它会通过我们的服务器cookie发送。
- en: 'How can we prevent CSRF attacks? Django uses something called a CSRF token,
    which is a small random string that is unique to each site visitor – in general,
    you can consider a visitor to be one browser session. Different browsers on the
    same computer would be different visitors, and the same Django user logged in
    on two different browsers would also be different visitors. When the form is read,
    Django puts the token into the form as a hidden input. The CSRF token must be
    included in all `POST` requests being sent to Django, and it must match the token
    Django has stored on the server-side for the visitor, otherwise, a 403 status
    HTTP response is returned. This protection can be disabled – either for the whole
    site or for an individual view – but it is not advisable to do so unless you really
    need to. The CSRF token must be added into the HTML for every form being sent
    and is done with the `{% csrf_token %}` template tag. We''ll add it to our example
    review form now, and the code in the template will look like this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何防止 CSRF 攻击？Django 使用一种称为 CSRF 令牌的东西，这是一个对每个网站访客唯一的随机字符串——一般来说，你可以认为一个访客是一个浏览器会话。同一台电脑上的不同浏览器会是不同的访客，而且同一个
    Django 用户在两个不同的浏览器上登录也会是不同的访客。当表单被读取时，Django 会将令牌作为隐藏输入放入表单中。CSRF 令牌必须包含在所有发送到
    Django 的 `POST` 请求中，并且它必须与 Django 在服务器端为访客存储的令牌匹配，否则将返回 403 状态 HTTP 响应。这种保护可以禁用——要么是整个站点，要么是单个视图——但除非你真的需要这样做，否则不建议这样做。CSRF
    令牌必须添加到每个要发送的表单的 HTML 中，并且使用 `{% csrf_token %}` 模板标签完成。我们现在将把它添加到我们的示例评论表单中，模板中的代码将看起来像这样：
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When the template gets rendered, the template tag is interpolated, so the output
    HTML ends up like this (note that the inputs are still in the output; they have
    just been removed here for brevity):'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当模板被渲染时，模板标签会被插值，所以输出的 HTML 最终会像这样（注意，输入仍然在输出中；这里只是为了简洁而移除了它们）：
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Since this is a hidden field, the form on the page does not look any different
    from how it did before.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个隐藏字段，页面上的表单看起来与之前没有区别。
- en: The CSRF token is unique to every visitor on the site and periodically changes.
    If an attacker were to copy the HTML from our site, they would get their own CSRF
    token that would not match that of any other user, so Django would reject the
    form when it was posted by someone else.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: CSRF 令牌对网站上的每个访客都是唯一的，并且会定期更改。如果攻击者从我们的网站上复制 HTML，他们会得到一个自己的 CSRF 令牌，这个令牌不会与任何其他用户的令牌匹配，所以当其他人提交表单时，Django
    会拒绝该表单。
- en: CSRF tokens also change periodically. This limits how long the attacker would
    have to take advantage of a particular user and token combination. Even if they
    were able to get the CSRF token of a user that they were trying to exploit, they
    would have a short window of time to be able to use it.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: CSRF 令牌也会定期更改。这限制了攻击者利用特定用户和令牌组合的时间。即使他们能够获取他们试图利用的用户的 CSRF 令牌，他们也只有很短的时间窗口可以使用它。
- en: Accessing Data in the View
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在视图中访问数据
- en: As we discussed in *Chapter 1*, *Introduction to Django*, Django provides two
    `QueryDict` objects on the `HTTPRequest` instances that are passed to the view
    function. These are `request.GET`, which contains parameters passed in the URL,
    and `request.POST`, which contains parameters in the HTTP request body. Even though
    `request.GET` has `GET` in its name, this variable is populated even for non-`GET`
    HTTP requests. This is because the data it contains is parsed from the URL. Since
    all HTTP requests have a URL, all HTTP requests may contain `GET` data, even if
    they are `POST` or `PUT`, and so on. In the next exercise, we will add code to
    our view to read and display the `POST` data.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 *第一章*，*Django 简介* 中所讨论的，Django 在传递给视图函数的 `HTTPRequest` 实例上提供了两个 `QueryDict`
    对象。这些是 `request.GET`，它包含通过 URL 传递的参数，以及 `request.POST`，它包含 HTTP 请求体中的参数。尽管 `request.GET`
    的名字中有 `GET`，但这个变量即使在非 `GET` HTTP 请求中也会被填充。这是因为它包含的数据是从 URL 解析出来的。由于所有 HTTP 请求都有一个
    URL，所以所有 HTTP 请求都可能包含 `GET` 数据，即使它们是 `POST` 或 `PUT` 等等。在下一个练习中，我们将向我们的视图添加代码来读取和显示
    `POST` 数据。
- en: 'Exercise 6.02: Working with POST Data in a View'
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 6.02：在视图中处理 POST 数据
- en: 'We will now add some code to our example view to print out the received `POST`
    data to the console. We will also insert the HTTP method that was used to generate
    the page into the HTML output. This will allow us to be sure of what method was
    used to generate the page (`GET` or `POST`) and see how the form differs for each
    type:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将向我们的示例视图添加一些代码，将接收到的 `POST` 数据打印到控制台。我们还将把生成页面的 HTTP 方法插入到 HTML 输出中。这将使我们能够确定用于生成页面的方法（`GET`
    或 `POST`）并查看每种类型的表单如何不同：
- en: 'First, in PyCharm, open the `form_example` app''s `views.py` file. Alter the
    `form_example` view to print each value in the `POST` request to the console by
    adding this code inside the function:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在 PyCharm 中，打开 `form_example` 应用程序的 `views.py` 文件。修改 `form_example` 视图，通过在函数内部添加以下代码，将
    `POST` 请求中的每个值打印到控制台：
- en: '[PRE21]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This code iterates over each key in the request `POST` data `QueryDict` and
    prints the key and list of values to the console. We already know that each `QueryDict`
    can have multiple values for a key, so we use the `getlist` function to get them
    all.
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此代码遍历请求 `POST` 数据 `QueryDict` 中的每个键，并将键和值列表打印到控制台。我们已经知道每个 `QueryDict` 可以为一个键有多个值，因此我们使用
    `getlist` 函数来获取所有值。
- en: 'Pass `request.method` to the template in a context variable named `method`.
    Do this by updating the call to `render` in the view, so that it''s like this:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `request.method` 通过名为 `method` 的上下文变量传递到模板中。通过更新视图中的 `render` 调用来完成此操作，使其如下所示：
- en: '[PRE22]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We will now display the `method` variable in the template. Open the `form-example.html`
    template and use an `<h4>` tag to show the `method` variable. Put this just after
    the opening `<body>` tag, like so:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将显示模板中的 `method` 变量。打开 `form-example.html` 模板，并使用 `<h4>` 标签显示 `method`
    变量。将其放在 `<body>` 标签之后，如下所示：
- en: '[PRE23]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note that we could access the method directly inside the template without passing
    it in a context dictionary, by using the `request` method variable and attribute
    properly. We know from *Chapter 3*, *URL Mapping, Views, and Templates*, that
    by using the render shortcut function, the request is always available in the
    template. We just demonstrated how to access the method in the view here because
    later on, we will change the behavior of the page based on the method.
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们可以通过使用 `request` 方法变量和属性正确地直接在模板中访问方法，而无需将其传递到上下文字典中。我们从 *第 3 章*，*URL 映射、视图和模板*
    中知道，通过使用 `render` 快捷函数，请求始终在模板中可用。我们在这里展示了如何访问视图中的方法，因为稍后我们将根据方法更改页面的行为。
- en: 'We also need to add the CSRF token to the form HTML. We do this by putting
    the `{% csrf_token %}` template tag after the opening `<form>` tag. The start
    of the form should look like this:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要将 CSRF 令牌添加到表单 HTML 中。我们通过在 `<form>` 标签之后放置 `{% csrf_token %}` 模板标签来完成此操作。表单的开始应如下所示：
- en: '[PRE24]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now, save the file.
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，保存文件。
- en: 'Start the Django dev server if it''s not already running. Load the example
    page (`http://127.0.0.1:8000/form-example/`) in your browser, and you should see
    it now displays the method at the top of the page (`GET`):![Figure 6.10: Method
    at the top of the page'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 Django 开发服务器尚未运行，请启动它。在浏览器中加载示例页面（`http://127.0.0.1:8000/form-example/`），你应该会看到它现在在页面顶部显示了方法（`GET`）：![图
    6.10：页面顶部的请求方法
- en: '](img/B15509_06_10.jpg)'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15509_06_10.jpg)'
- en: 'Figure 6.10: Method at the top of the page'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 6.10：页面顶部的请求方法
- en: 'Enter some text or data in each of the inputs and submit the form, by clicking
    the `Submit Input` button:![Figure 6.11: Clicking the Submit Input button to submit
    the form'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个输入框中输入一些文本或数据，然后通过点击 `Submit Input` 按钮提交表单：![图 6.11：点击提交输入按钮提交表单
- en: '](img/B15509_06_11.jpg)'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15509_06_11.jpg)'
- en: 'Figure 6.11: Clicking the Submit Input button to submit the form'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 6.11：点击提交输入按钮提交表单
- en: 'You should see the page reload and the method displayed change to `POST`:'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该会看到页面重新加载，并且显示的方法更改为 `POST`：
- en: '![Figure 6.12: Method updated to POST after the form is submitted'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 6.12：表单提交后方法更新为 POST'
- en: '](img/B15509_06_12.jpg)'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15509_06_12.jpg)'
- en: 'Figure 6.12: Method updated to POST after the form is submitted'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 6.12：表单提交后方法更新为 POST
- en: 'Switch back to PyCharm and look in the `Run` console at the bottom of the window.
    If it is not visible, click the `Run` button at the bottom of the window to show
    it:![Figure 6.13: Click the Run button at the bottom of the window to display
    the console'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换回 PyCharm，查看窗口底部的 `Run` 控制台。如果它不可见，请点击窗口底部的 `Run` 按钮以显示它：![图 6.13：点击窗口底部的运行按钮以显示控制台
- en: '](img/B15509_06_13.jpg)'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15509_06_13.jpg)'
- en: 'Figure 6.13: Click the Run button at the bottom of the window to display the
    console'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 6.13：点击窗口底部的运行按钮以显示控制台
- en: 'Inside the `Run` console, a list of the values that were posted to the server
    should be displayed:'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 `Run` 控制台中，应显示已发送到服务器的值列表：
- en: '![Figure 6.14: Input values shown in the Run console'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 6.14：运行控制台显示的输入值'
- en: '](img/B15509_06_14.jpg)'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15509_06_14.jpg)'
- en: 'Figure 6.14: Input values shown in the Run console'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 6.14：运行控制台显示的输入值
- en: 'Some things you should notice are as follows:'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该注意以下事项：
- en: All values are sent as text, even `number` and `date` inputs.
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有值都作为文本发送，即使是 `number` 和 `date` 输入。
- en: For the `select` inputs, the selected `value` attributes of the selected options
    are sent, not the text content of the `option` tag.
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `select` 输入，发送的是选中选项的 `value` 属性，而不是 `option` 标签的文本内容。
- en: If you select multiple options for `books_you_own`, then you will see multiple
    values in the request. This is why we use the `getlist` method since multiple
    values are sent for the same input name.
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你为 `books_you_own` 选择多个选项，那么你将在请求中看到多个值。这就是为什么我们使用 `getlist` 方法，因为为相同的输入名称发送了多个值。
- en: If the checkbox was checked, you will have a `checkbox_on` input in the debug
    output. If it was not checked, then the key will not exist at all (that is, there
    is no key, instead of having the key existing with an empty string or `None` value).
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果复选框被选中，你将在调试输出中看到一个 `checkbox_on` 输入。如果没有被选中，则该键将根本不存在（即，没有键，而不是键存在一个空字符串或
    `None` 值）。
- en: We have a value for the name `submit_input`, which is the text `Submit Input`.
    You submitted the form by clicking the `Submit Input` button, so we receive its
    value. Notice that no value is set for the `button_element` input since that button
    was not clicked.
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有一个名为 `submit_input` 的值，其文本为 `Submit Input`。你通过点击 `Submit Input` 按钮提交了表单，因此我们收到了它的值。注意，由于该按钮没有被点击，所以
    `button_element` 输入没有设置任何值。
- en: We will experiment with two other ways of submitting the form, first by hitting
    *Enter* when your cursor is in a text-like input (such as *text*, *password*,
    *date*, and *email*, but not *text area*, as hitting *Enter* there will add a
    new line).
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将尝试两种其他提交表单的方式，首先是在你的光标位于类似文本的输入中（如 *text*、*password*、*date* 和 *email*，但不是
    *text area*，因为在其中按 *Enter* 将添加新行）时按 *Enter* 键。
- en: If you submit a form in this way, the form will act as though you had clicked
    the first submit button on the form, so the `submit_input` input value will be
    included. The output you see should match that of the previous figure.
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你以这种方式提交表单，表单将表现得好像你点击了表单上的第一个提交按钮一样，因此 `submit_input` 输入值将被包含。你看到的输出应该与之前的图相同。
- en: 'The other way to submit the form is by clicking the `Button Element` submit
    input, in which we will try clicking this button to submit the form. You should
    see that `submit_button` is no longer in the list of posted values, while `button_element`
    is now present:'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 提交表单的另一种方式是通过点击 `Button Element` 提交输入，我们将尝试点击此按钮来提交表单。你应该会看到 `submit_button`
    已不再列表中，而 `button_element` 现在已经存在：
- en: '![Figure 6.15: submit_button is now gone from the inputs, and button_element
    is added'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图6.15：submit_button 已从输入中移除，并添加了 button_element'
- en: '](img/B15509_06_15.jpg)'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B15509_06_15.jpg]'
- en: 'Figure 6.15: submit_button is now gone from the inputs, and button_element
    is added'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.15：submit_button 已从输入中移除，并添加了 button_element
- en: You can use this multiple-submit technique to alter how your view behaves depending
    on which button was clicked. You can even have multiple submit buttons with the
    same *name* attribute to make the logic easier to write.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这种多提交技术来改变你的视图行为，取决于哪个按钮被点击。你甚至可以有多个具有相同 *name* 属性的提交按钮，以使逻辑更容易编写。
- en: In this exercise, you added a CSRF token to your `form` element by using the
    `{% csrf_token %}` template tag. This means that your form could then be submitted
    to Django successfully without generating an HTTP Permission Denied response.
    We then added some code to output the values that our form contained when it was
    submitted. We tried submitting the form with various values to see how they are
    parsed into Python variables on the `request.POST` `QueryDict`. We will now discuss
    some more theory around the difference between `GET` and `POST` requests, then
    move on to the Django Forms library, which makes designing and validating forms
    easier.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你通过使用 `{% csrf_token %}` 模板标签将 CSRF 令牌添加到你的 `form` 元素中。这意味着你的表单可以成功提交到
    Django，而不会生成 HTTP 权限拒绝响应。然后我们添加了一些代码来输出表单提交时的值。我们尝试用各种值提交表单，以查看它们是如何被解析成 `request.POST`
    `QueryDict` 中的 Python 变量的。现在我们将讨论一些关于 `GET` 和 `POST` 请求之间差异的理论，然后转向 Django 表单库，它使得设计和验证表单变得更加容易。
- en: Choosing between GET and POST
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择 GET 和 POST
- en: Choosing when to use a `GET` or `POST` request requires the consideration of
    a number of factors. The most important is deciding whether or not the request
    should be idempotent. A request can be said to be idempotent if it can be repeated
    and produce the same result each time. Let us look at some examples.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 选择何时使用 `GET` 或 `POST` 请求需要考虑许多因素。最重要的是决定请求是否应该是幂等的。如果请求可以被重复执行并且每次都产生相同的结果，则可以说该请求是幂等的。让我们看看一些例子。
- en: If you type any web address into your browser (such as any of the Bookr pages
    we have built so far), it will perform a `GET` request to fetch the information.
    You can refresh the page, and no matter how many times you click refresh, you
    will get the same data back. The request you are making will not affect the content
    on the server. You would say these requests are idempotent.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将任何网址输入到你的浏览器中（例如我们迄今为止构建的任何Bookr页面），它将执行一个`GET`请求来获取信息。你可以刷新页面，无论你点击刷新多少次，你都会得到相同的数据。你发出的请求不会影响服务器上的内容。你会说这些请求是幂等的。
- en: 'Now, remember when you added data through the Django admin interface (in *Chapter
    4*, *Introduction to Django Admin*)? You typed in the information for the new
    book in a form, then clicked `Save`. Your browser made a `POST` request to create
    a new book on the server. If you repeated that `POST` request, the server would
    create *another* book and would do so each time you repeated the request. Since
    the request is updating information, it is not idempotent. Your browser will warn
    you about this. If you have ever tried to refresh a page that you were sent to
    after submitting a form, you may have received a message asking if you want to
    *"Repost form data?"* (or something more verbose, as in the following figure).
    This is a warning that you are sending the form data again, which might cause
    the action you just undertook to be repeated:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，记得你通过Django管理界面（在*第4章*，*Django管理界面简介*）添加数据时吗？你在表单中输入了新书的详细信息，然后点击了`保存`。你的浏览器向服务器发送了一个`POST`请求来创建新书。如果你重复那个`POST`请求，服务器将创建*另一本*书，并且每次你重复请求时都会这样做。由于请求正在更新信息，它不是幂等的。你的浏览器会警告你这一点。如果你曾经尝试刷新在提交表单后发送到你的页面，你可能收到一条消息询问你是否想要重新发送表单数据？（或更详细的，如以下图所示）。这是警告你正在再次发送表单数据，这可能会使你刚刚执行的操作被重复：
- en: '![Figure 6.16: Firefox confirming whether information should be resent'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.16：Firefox确认是否应该重新发送信息'
- en: '](img/B15509_06_16.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15509_06_16.jpg)'
- en: 'Figure 6.16: Firefox confirming whether information should be resent'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.16：Firefox确认是否应该重新发送信息
- en: This is not to suggest that all `GET` requests are idempotent and all `POST`
    requests are not – your backend application can be designed in any way you want.
    Although it is not best practice, a developer might have decided to make data
    get updated during a `GET` request in their web application. When you are building
    your applications, you should try to make sure `GET` requests are idempotent and
    leave data-altering to `POST` requests only. Stick to these principles unless
    you have a good reason not to.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是说所有`GET`请求都是幂等的，而所有`POST`请求都不是——你的后端应用可以按照你想要的方式设计。尽管这不是最佳实践，开发者可能已经决定在他们的Web应用中，在`GET`请求期间更新数据。当你构建你的应用时，你应该尽量确保`GET`请求是幂等的，并将数据更改仅留给`POST`请求。除非你有充分的理由不这样做，否则请坚持这些原则。
- en: Another point to consider is that Django only applies CSRF projection to `POST`
    requests. Any `GET` request, including one that alters data, can be accessed without
    a CSRF token.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 另一点需要考虑的是，Django只对`POST`请求应用CSRF保护。任何`GET`请求，包括更改数据的请求，都可以在没有CSRF令牌的情况下访问。
- en: Sometimes, it can be hard to decide if a request is idempotent or not; for example,
    a login form. Before you submitted your username and password, you were not logged
    in, and afterward, the server considered you to be logged in, so could we consider
    that non-idempotent as it changed your authentication status with the server?
    On the other hand, once logged in, if you were able to send your credentials again,
    you would remain logged in. This implies that the request is idempotent and repeatable.
    So, should the request be `GET` or `POST`?
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，判断一个请求是否幂等可能很难；例如，登录表单。在你提交用户名和密码之前，你并未登录，之后服务器认为你已经登录，那么我们是否可以认为非幂等，因为它改变了你与服务器之间的认证状态？另一方面，一旦登录，如果你再次发送凭证，你将保持登录状态。这表明请求是幂等的且可重复的。那么，这个请求应该是`GET`还是`POST`？
- en: This brings us to the second point to consider when choosing what method to
    use. If sending form data with a `GET` request, the form parameters will be visible
    in the URL. For example, if we made a login form use a `GET` request, the login
    URL might be `https://www.example.com/login?username=user&password=password1`.
    The username, and worse, the password, is visible in the web browser's address
    bar. It would also be stored in the browser history, so anyone who used the browser
    after the real user could log in to the site. The URL is often stored in web server
    log files as well, meaning the credentials would be visible there too. In short,
    regardless of the idempotency of a request, don't pass sensitive data through
    URL parameters.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了选择使用哪种方法时需要考虑的第二个问题。如果我们使用 `GET` 请求发送表单数据，表单参数将可见于 URL 中。例如，如果我们使登录表单使用
    `GET` 请求，登录 URL 可能是 `https://www.example.com/login?username=user&password=password1`。用户名，更糟糕的是密码，将可见于网络浏览器的地址栏中。它也会存储在浏览器历史记录中，这意味着任何在真实用户之后使用浏览器的用户都可以登录到该网站。URL
    通常还会存储在 Web 服务器日志文件中，这意味着凭证也会在那里可见。简而言之，无论请求的幂等性如何，都不要通过 URL 参数传递敏感数据。
- en: Sometimes, knowing that the parameter will be visible in the URL might be something
    you desire. For example, when searching with a search engine, usually the search
    parameter will be visible in the URL. To see this in action, try visiting [https://www.google.com](https://www.google.com)
    and searching for something. You'll notice that the page with the results has
    your search term as the `q` parameter. A search for `Django` will take you to
    the URL [https://www.google.com/search?q=Django](https://www.google.com/search?q=Django),
    for example. This allows you to share search results with someone else by sending
    them this URL. In *Activity 6.01, Book Searching*, you will add a search form
    that similarly passes a parameter.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，知道参数将可见于 URL 中可能正是您所希望的。例如，当使用搜索引擎进行搜索时，通常搜索参数将可见于 URL 中。要查看这一功能如何工作，请尝试访问
    [https://www.google.com](https://www.google.com) 并进行搜索。您会注意到包含结果的页面将您的搜索词作为 `q`
    参数。例如，搜索 `Django` 将带您到 URL [https://www.google.com/search?q=Django](https://www.google.com/search?q=Django)。这允许您通过发送此
    URL 与他人共享搜索结果。在 *活动 6.01，图书搜索* 中，您将添加一个类似的搜索表单，该表单会传递一个参数。
- en: Another consideration is that the maximum length of a URL allowed by a browser
    can be short compared to the size of a `POST` body – sometimes only around 2,000
    characters (or about 2 KB) compared to many megabytes or gigabytes that a `POST`
    body can be (assuming your server is set up to allow these sizes of requests).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个考虑因素是，浏览器允许的 URL 最大长度可能比 `POST` 体的尺寸短得多——有时只有大约 2,000 个字符（或大约 2 KB），而 `POST`
    体的尺寸可以是许多兆字节或千兆字节（假设您的服务器已设置允许这些大小的请求）。
- en: As we mentioned earlier, URL parameters are available in `request.GET` regardless
    of the type of request being made (`GET`, `POST`, `PUT`, and so on). You might
    find it useful to send some data in URL parameters and others in the request body
    (available in `request.POST`). For example, you could specify a `format` argument
    in the URL that sets what format some output data will be transformed to, but
    the input data is provided in the `POST` body.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，无论正在进行的请求类型是什么（`GET`、`POST`、`PUT` 等），URL 参数都可在 `request.GET` 中找到。您可能会发现将一些数据通过
    URL 参数发送，而将其他数据放在请求体（在 `request.POST` 中可用）中很有用。例如，您可以在 URL 中指定一个 `format` 参数，该参数设置某些输出数据将被转换成的格式，但输入数据提供在
    `POST` 体内。
- en: Why Use GET When We Can Put Parameters in the URL?
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 当我们可以在 URL 中放置参数时，为什么还要使用 GET？
- en: 'Django allows us to easily define URL maps that contain variables. We could,
    for example, set up a URL mapping for a search view like this:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Django 允许我们轻松定义包含变量的 URL 映射。例如，我们可以设置一个搜索视图的 URL 映射如下：
- en: '[PRE25]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This probably looks like a good approach at first, but when we start wanting
    to customize the results view with arguments, it can get complicated quickly.
    For example, we might want to be able to move from one results page to the next,
    so we add a page argument:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法可能一开始看起来很好，但当我们开始想要使用参数自定义结果视图时，它可能会迅速变得复杂。例如，我们可能希望能够从一个结果页面跳转到下一个结果页面，因此我们添加了一个页面参数：
- en: '[PRE26]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'And then we might also want to order the search results by a specific category,
    such as the author name or the date of publishing, so we add another argument
    for that:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可能还希望按特定类别对搜索结果进行排序，例如作者姓名或发布日期，因此我们为这个目的添加了另一个参数：
- en: '[PRE27]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You might be able to see the problem with this approach – we can't order the
    results without providing a page. If we wanted to also add a `results_per_page`
    argument too, we wouldn't be able to use that without setting `page` and `order`
    keys.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经看到了这种方法的缺点——如果我们不提供页面，就无法对结果进行排序。如果我们还想添加`results_per_page`参数，我们就不能不设置`page`和`order`键来使用它。
- en: 'Contrast this to using query parameters: all of them are optional, so you could
    search like this:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用查询参数的方法相比：所有这些参数都是可选的，因此你可以这样搜索：
- en: '[PRE28]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Or you could set a page like this:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 或者你可以设置一个像这样的页面：
- en: '[PRE29]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Or you could just set the results ordering like this:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 或者你可以只设置结果排序如下：
- en: '[PRE30]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Or you could combine them all:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 或者你可以将它们全部组合：
- en: '[PRE31]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Another reason for using URL query parameters is that when submitting a form,
    the browser always sends the input values in this manner; it cannot be changed
    so that parameters are submitted as path components in the URL. Therefore, when
    submitting a form using `GET`, the URL query parameters must be used as the input data.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 使用URL查询参数的另一个原因是，在提交表单时，浏览器总是以这种方式发送输入值；无法更改，以便将参数作为URL中的路径组件提交。因此，当使用`GET`提交表单时，必须使用URL查询参数作为输入数据。
- en: The Django Forms Library
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Django表单库
- en: 'We''ve looked at how to manually write forms in HTML and how to access the
    data on the request object using `QueryDict`. We saw that the browser provides
    some validation for us for certain field types, such as email or numbers, but
    we have not tried validating the data in the Python view. We should validate the
    form in the Python view for two reasons:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了如何手动在HTML中编写表单以及如何使用`QueryDict`访问请求对象中的数据。我们了解到浏览器为我们提供了一些针对特定字段类型的验证，例如电子邮件或数字，但我们还没有尝试在Python视图中验证数据。我们应该在Python视图中验证表单，原因有两个：
- en: It is not safe to rely solely on browser-based validation of input data. A browser
    may not implement certain validation features, meaning the user could post any
    type of data. For example, older browsers don't validate number fields, so a user
    can type in a number outside the range we are expecting. Furthermore, a malicious
    user could try to send harmful data without using a browser at all. The browser
    validation should be considered as a nicety for the user and that's all.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅仅依赖基于浏览器的输入数据验证是不安全的。浏览器可能没有实现某些验证功能，这意味着用户可以提交任何类型的数据。例如，旧版浏览器不验证数字字段，因此用户可以输入超出我们预期范围的数字。此外，恶意用户甚至可能尝试发送有害数据而不使用浏览器。浏览器验证应被视为对用户的一种便利，仅此而已。
- en: The browser does not allow us to do cross-field validation. For example, we
    can use the `required` attribute for inputs that are mandatory to be filled in.
    Often, though, we want to set the `required` attribute, based on the value of
    another input. For example, the email address input should only be set as `required`
    if the user has checked the `Register My Email` checkbox.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器不允许我们进行跨字段验证。例如，我们可以使用`required`属性来指定必须填写的输入字段。然而，通常我们希望根据另一个输入字段的值来设置`required`属性。例如，如果用户已经勾选了`注册我的邮箱`复选框，那么电子邮件地址输入字段才应该被设置为`required`。
- en: The Django Forms library allows you to quickly define a form using a Python
    class. This is done by creating a subclass of the base Django `Form` class. You
    can then use an instance of this class to render the form in your template and
    validate the input data. We refer to our classes as forms, similar to how we subclass
    Django models to create our own `Model` classes. Forms contain one or more fields
    of a certain type (such as text fields, number fields, or email fields). You'll
    notice this sounds like Django models, and forms *are* similar to models but use
    different field classes. You can even automatically create a form from a model
    – we will cover this in *Chapter 7*, *Advanced Form Validation and Model Forms*.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Django表单库允许你使用Python类快速定义表单。这是通过创建Django基础`Form`类的子类来实现的。然后你可以使用这个类的实例在模板中渲染表单并验证输入数据。我们将我们的类称为表单，类似于我们通过子类化Django模型来创建自己的`Model`类。表单包含一个或多个特定类型的字段（如文本字段、数字字段或电子邮件字段）。你会注意到这听起来像Django模型，而且表单确实与模型类似，但使用不同的字段类。你甚至可以自动从模型创建表单——我们将在*第7章*，*高级表单验证和模型表单*中介绍这一点。
- en: Defining a Form
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义表单
- en: Creating a Django form is similar to creating a Django model. You define a class
    that inherits from the `django.forms.Form` class. The class has attributes, which
    are instances of different `django.forms.Field` subclasses. When rendered, the
    attribute name in the class corresponds to its input `name` in HTML. To give you
    a quick idea of what fields there are, some examples are `CharField`, `IntegerField`,
    `BooleanField`, `ChoiceField`, and `DateField`. Each field generally corresponds
    to one input when rendered in HTML, but there's not always a one-to-one mapping
    between a form field class and an input type. Form fields are more coupled to
    the type of data they collect rather than how they are displayed.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 创建Django表单类似于创建Django模型。你定义一个继承自 `django.forms.Form` 类的类。该类有属性，这些属性是不同 `django.forms.Field`
    子类的实例。当渲染时，类中的属性名称对应于其在HTML中的输入 `name`。为了给你一个关于有哪些字段的快速概念，以下是一些示例：`CharField`、`IntegerField`、`BooleanField`、`ChoiceField`
    和 `DateField`。每个字段在渲染为HTML时通常对应一个输入，但表单字段类和输入类型之间并不总是存在一对一的映射。表单字段更多地与它们收集的数据类型相关联，而不是它们的显示方式。
- en: To illustrate this, consider a `text` input and a `password` input. They both
    accept some typed-in text data, but the main difference between them is that the
    text is visibly displayed in a `text` input, whereas with a `password` input the
    text is obscured. In a Django form, both of these fields are represented using
    `CharField`. The difference in how they are displayed is set by changing the *widget*
    the field is using.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，考虑一个 `text` 输入和一个 `password` 输入。它们都接受一些输入的文本数据，但它们之间的主要区别在于，文本在 `text`
    输入中是可见的，而 `password` 输入中的文本则是隐藏的。在Django表单中，这两个字段都是使用 `CharField` 来表示的。它们显示方式的不同是通过改变字段所使用的
    `*widget*` 来设置的。
- en: Note
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you're not familiar with the word *widget*, it is a term to describe the
    actual input that is being interacted with and how it is displayed. Text inputs,
    password inputs, select menus, checkboxes, and buttons are all examples of different
    widgets. The inputs we have seen in HTML correspond one-to-one with widgets. In
    Django, this is not the case, and the same type of `Field` class can be rendered
    in multiple ways depending on the widget that is specified.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不太熟悉单词 *widget*，它是一个用来描述实际交互的输入及其显示方式的术语。文本输入、密码输入、选择菜单、复选框和按钮都是不同小部件的例子。我们在HTML中看到的输入与这些小部件一一对应。在Django中，情况并非如此，同一个类型的
    `Field` 类可以根据指定的 `widget` 以多种方式渲染。
- en: 'Django defines a number of `Widget` classes that define how a `Field` should
    be rendered as HTML. They inherit from `django.forms.widgets.Widget`. A widget
    can be passed to the `Field` constructor to change how it is rendered. For example,
    a `CharField` instance renders as `text` `<input>` by default. If we use the `PasswordInput`
    widget, it will instead render as `password` `<input>`. The other widgets we will
    use are as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Django定义了一系列 `Widget` 类，它们定义了 `Field` 应如何作为HTML渲染。它们继承自 `django.forms.widgets.Widget`。可以将小部件传递给
    `Field` 构造函数以更改其渲染方式。例如，默认情况下，`CharField` 实例渲染为 `text` `<input>`。如果我们使用 `PasswordInput`
    小部件，它将渲染为 `password` `<input>`。我们将使用的其他小部件如下：
- en: '`RadioSelect`, which renders a `ChoiceField` instance as radio buttons instead
    of a `<select>` menu'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RadioSelect`，它将 `ChoiceField` 实例渲染为单选按钮而不是 `<select>` 菜单'
- en: '`Textarea`, which renders a `CharField` instance as `<textarea>`'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Textarea`，它将 `CharField` 实例渲染为 `<textarea>`'
- en: '`HiddenInput`, which renders a field as a hidden `<input>`'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HiddenInput`，它将字段渲染为隐藏的 `<input>`'
- en: 'We will look at an example form and add fields and features one by one. First,
    let''s just create a form with a text input and a password input:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看一个示例表单，并逐个添加字段和功能。首先，让我们先创建一个包含文本输入和密码输入的表单：
- en: '[PRE32]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `widget` argument can be just a widget subclass, which can be fine a lot
    of the time. If you want to further customize the display of the input and its
    attributes, you can set the widget argument to an instance of the `widget` class
    instead. We will look at further customizing widget displays soon. In this case,
    we're using just the `PasswordInput` class, since we are not customizing it beyond
    changing the type of input being displayed.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`widget` 参数可以只是一个小部件子类，这在很多情况下都是可以接受的。如果你想进一步自定义输入及其属性的显示，你可以将 `widget` 参数设置为
    `widget` 类的实例。我们很快将探讨如何进一步自定义小部件的显示。在这种情况下，我们只是使用了 `PasswordInput` 类，因为我们没有对其进行自定义，只是改变了显示的输入类型。'
- en: 'When the form is rendered in a template, it looks like this:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 当表单在模板中渲染时，它看起来是这样的：
- en: '![Figure 6.17: Django form rendered in a browser'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.17：在浏览器中渲染的Django表单'
- en: '](img/B15509_06_17.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15509_06_17.jpg)'
- en: 'Figure 6.17: Django form rendered in a browser'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.17：在浏览器中渲染的Django表单
- en: Note that the inputs do not contain any content when the page loads; the text
    has been entered to illustrate the different input types.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当页面加载时，输入不包含任何内容；文本已被输入以说明不同的输入类型。
- en: 'If we examine the page source, we can see the HTML that Django generates. For
    the first two fields, it looks like this (some spacing added for readability):'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们检查页面源代码，我们可以看到Django生成的HTML。对于前两个字段，它看起来像这样（添加了一些间距以提高可读性）：
- en: '[PRE33]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Notice that Django has automatically generated a `label` instance with its text
    derived from the field name. The `name` and `id` attributes have been set automatically.
    Django also automatically adds the `required` attribute to the input. Similar
    to model fields, form field constructors also accept a `required` argument – this
    defaults to `True`. Setting this to `False` removes the `required` attribute from
    the generated HTML.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到Django已经自动生成一个`label`实例，其文本来自字段名称。`name`和`id`属性已自动设置。Django还自动将`required`属性添加到输入中。与模型字段类似，表单字段构造函数也接受一个`required`参数——默认为`True`。将其设置为`False`将从生成的HTML中移除`required`属性。
- en: 'Next, we''ll look at how a checkbox is added to the form:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看看如何将复选框添加到表单中：
- en: 'A checkbox is represented with `BooleanField`, as it can have only two values,
    checked or unchecked. It''s added to the form in the same way as the other field:'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复选框用`BooleanField`表示，因为它只有两个值，选中或未选中。它以与其他字段相同的方式添加到表单中：
- en: '[PRE34]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The HTML that Django generates for this new field is similar to the previous
    two fields:'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Django为这个新字段生成的HTML与前面两个字段类似：
- en: '[PRE35]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Next are the select inputs:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是选择输入：
- en: We need to provide a list of choices to display in the `<select>` dropdown.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要提供一个要显示在`<select>`下拉列表中的选择项列表。
- en: 'The field class constructor takes a `choices` argument. The choices are provided
    as a tuple of two-element tuples. The first element in each sub-tuple is the value
    of the choice and the second element is the text or description of the choice.
    For example, choices could be defined like this:'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字段类构造函数接受一个`choices`参数。选择项以两个元素的元组的形式提供。每个子元组中的第一个元素是选择项的值，第二个元素是选择项的文本或描述。例如，选择项可以定义如下：
- en: '[PRE36]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Note that you can use lists instead of tuples if you want (or a combination
    of the two). This can be useful if you want your choices to be mutable:'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，如果你想使用列表而不是元组（或两者的组合），这是可以的。如果你想使你的选择项可变，这可能会很有用：
- en: '[PRE37]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'To implement `optgroup`, we can nest the choices. To implement the choices
    the same way as our previous examples, we use a structure like this:'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要实现`optgroup`，我们可以嵌套选择项。为了以与我们的前例相同的方式实现选择项，我们使用如下结构：
- en: '[PRE38]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `select` functionality is added to the form by using a `ChoiceField` instance.
    The widget defaults to a `select` input so no configuration is necessary apart
    from setting `choices`:'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过使用`ChoiceField`实例将`select`功能添加到表单中。小部件默认为`select`输入，因此除了设置`choices`之外不需要任何配置：
- en: '[PRE39]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This is the HTML that is generated:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这是生成的HTML：
- en: '[PRE40]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Making a multiple select requires the use of `MultipleChoiceField`. It takes
    a `choices` argument in the same format as the regular `ChoiceField` for single selects:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 创建多选需要使用`MultipleChoiceField`。它接受一个`choices`参数，其格式与单选的常规`ChoiceField`相同：
- en: '[PRE41]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'And its HTML is similar to that of the single select, except it has the `multiple`
    attribute added:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 它的HTML与单选类似，但增加了`multiple`属性：
- en: '[PRE42]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Choices can also be set after the form is instantiated. You may want to generate
    the choices `list`/`tuple` inside your view dynamically and then assign it to
    the field''s `choices` attribute. See the following, for example:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 选择项也可以在表单实例化后设置。你可能想在视图中动态生成`list`/`tuple`，然后将其分配给字段的`choices`属性。例如，参见以下内容：
- en: '[PRE43]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Next are the radio inputs, which are similar to selects:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是单选输入，它们与选择类似：
- en: Like selects, radio inputs use `ChoiceField`, as they provide a single choice
    between multiple options.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与选择类似，单选输入使用`ChoiceField`，因为它们在多个选项之间提供单一选择。
- en: The options to choose between are passed into the field constructor with the
    `choices` argument.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选项通过`choices`参数传递给字段构造函数。
- en: 'The choices are provided as a tuple of two-element tuples, also like selects:'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择项以两个元素的元组的形式提供，就像选择一样：
- en: '[PRE44]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '`ChoiceField` defaults to displaying as a `select` input, so the widget must
    be set to `RadioSelect` to have it rendered as radio buttons. Putting the choice
    setting together with this, we add radio buttons to the form like this:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`ChoiceField` 默认以 `select` 输入的形式显示，因此必须将小部件设置为 `RadioSelect` 以使其以单选按钮的形式渲染。将选择设置与此结合，我们可以在表单中添加单选按钮，如下所示：'
- en: '[PRE45]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Here is the HTML that is generated:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的 HTML 如下所示：
- en: '[PRE46]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Django automatically generates a unique label and ID for each of the three
    radio buttons:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: Django 自动为三个单选按钮中的每一个生成唯一的标签和 ID：
- en: 'To create a `textarea` instance, use `CharField` with a `Textarea` widget:'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要创建一个 `textarea` 实例，请使用带有 `Textarea` 小部件的 `CharField`：
- en: '[PRE47]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'You might notice that `textarea` is much larger than the previous ones we have
    seen (see the following figure):'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可能会注意到 `textarea` 比我们之前看到的要大得多（参见以下图示）：
- en: '![Figure 6.18: Normal textarea (top) versus Django''s default textarea (bottom)'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 6.18：普通文本框（顶部）与 Django 默认文本框（底部）的比较'
- en: '](img/B15509_06_18.jpg)'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B15509_06_18.jpg)'
- en: 'Figure 6.18: Normal textarea (top) versus Django''s default textarea (bottom)'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.18：普通文本框（顶部）与 Django 默认文本框（底部）的比较
- en: 'This is because Django automatically adds `cols` and `rows` attributes. These
    set the number of columns and rows, respectively, that the text field displays:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 Django 自动添加 `cols` 和 `rows` 属性。这些属性分别设置文本字段显示的列数和行数：
- en: '[PRE48]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Note that the `cols` and `rows` settings do not affect the amount of text that
    can be entered into a field, only the amount that is displayed at a time. Also
    note that the size of `textarea` can be set using CSS (for example, the `height`
    and `width` properties). This will override the `cols` and `rows` settings.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意，`cols` 和 `rows` 设置不会影响可以输入到字段中的文本量，只会影响一次显示的文本量。另外，`textarea` 的大小可以使用 CSS
    设置（例如，`height` 和 `width` 属性）。这将覆盖 `cols` 和 `rows` 设置。
- en: To create `number` inputs, you might expect Django to have a `NumberField` type,
    but it does not.
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要创建 `number` 输入，你可能期望 Django 有一个 `NumberField` 类型，但实际上并没有。
- en: 'Remember that the Django form fields are data-centric rather than display-centric,
    so instead, Django provides different `Field` classes depending on what type of
    numeric data you want to store:'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 记住，Django 表单字段是数据驱动的，而不是显示驱动的，因此，Django 根据你想要存储的数值类型提供不同的 `Field` 类：
- en: For integers, use `IntegerField`.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于整数，请使用 `IntegerField`。
- en: For floating-point numbers, use `FloatField` or `DecimalField`. The latter two
    differ in how they convert their data to a Python value.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于浮点数，请使用 `FloatField` 或 `DecimalField`。后两者在将数据转换为 Python 值的方式上有所不同。
- en: '`FloatField` will convert to a float while `DecimalField` is a decimal.'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FloatField` 将转换为浮点数，而 `DecimalField` 是十进制数。'
- en: Decimal values offer better accuracy in representing numbers than float values
    but may not integrate well into your existing Python code.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相比于浮点数，十进制值在表示数字时具有更高的精度，但可能无法很好地集成到现有的 Python 代码中。
- en: 'We''ll add all three fields to the form at once:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将一次性将所有三个字段添加到表单中：
- en: '[PRE49]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Here''s the HTML for all three:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是三个文本框的 HTML 代码：
- en: '[PRE50]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The `IntegerField` generated HTML is missing the `step` attribute that the other
    two have, which means the widget will only accept integer values. The other two
    fields (`FloatField` and `DecimalField`) generate very similar HTML. Their behavior
    is the same in the browser; they differ only when their values are used in Django
    code.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的 `IntegerField` HTML 缺少其他两个字段（`FloatField` 和 `DecimalField`）所具有的 `step` 属性，这意味着小部件将只接受整数值。其他两个字段生成的
    HTML 非常相似。它们在浏览器中的行为相同；它们仅在 Django 代码中使用其值时有所不同。
- en: 'As you might have guessed, an `email` input can be created with `EmailField`:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜，可以使用 `EmailField` 创建一个 `email` 输入：
- en: '[PRE51]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Its HTML is similar to the `email` input we created manually:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 它的 HTML 与我们手动创建的 `email` 输入类似：
- en: '[PRE52]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Following our manually created form, the next field we will look at is `DateField`:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们手动创建的表单之后，我们将查看下一个字段 `DateField`：
- en: By default, Django will render `DateField` as `text` input, and the browser
    will not show a calendar popup when the field is clicked.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，Django 将 `DateField` 渲染为 `text` 输入，并且当字段被点击时，浏览器不会显示日历弹出窗口。
- en: 'We can add `DateField` to the form with no arguments, like this:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以不带参数地将 `DateField` 添加到表单中，如下所示：
- en: '[PRE53]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'When rendered, it just looks like a normal `text` input:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 当渲染时，它看起来就像一个普通的 `text` 输入：
- en: '![Figure 6.19: Default DateField display in a form'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.19：表单中默认的 `DateField` 显示'
- en: '](img/B15509_06_19.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B15509_06_19.jpg)'
- en: 'Figure 6.19: Default DateField display in a form'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.19：表单中默认的 `DateField` 显示
- en: 'Here is the HTML generated by default:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 默认生成的 HTML 如下所示：
- en: '[PRE54]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The reason for using a `text` input is that it allows the user to enter the
    date in a number of different formats. For example, by default, the user can type
    in the date in *Year-Month-Day* (dash-separated) or *Month/Day/Year* (slash-separated)
    formats. The accepted formats can be specified by passing a list of formats to
    the `DateField` constructor using the `input_formats` argument. For example, we
    could accept dates in the formats of *Day/Month/Year* or *Day/Month/Year-with-century*,
    like this:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`text`输入的原因是它允许用户以多种不同的格式输入日期。例如，默认情况下，用户可以以*Year-Month-Day*（用连字符分隔）或*Month/Day/Year*（用斜杠分隔）的格式输入日期。可以通过将格式列表传递给`DateField`构造函数的`input_formats`参数来指定接受的格式。例如，我们可以接受*Day/Month/Year*或*Day/Month/Year-with-century*格式的日期，如下所示：
- en: '[PRE55]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We can override any attributes on a field's widget by passing the `attrs` argument
    to the widget constructor. This accepts a dictionary of attribute key/values that
    will be rendered into the input's HTML.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将`attrs`参数传递给小部件构造函数来覆盖字段小部件上的任何属性。这接受一个字典，包含将被渲染到输入HTML中的属性键/值。
- en: 'We have not used this yet, but we will see it again in the next chapter when
    we customize the field rendering further. For now, we''ll just set one attribute,
    `type`, that will overwrite the default input type:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有使用这个功能，但在下一章我们将进一步自定义字段渲染时，我们还会再次看到它。现在，我们只需设置一个属性，`type`，它将覆盖默认的输入类型：
- en: '[PRE56]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'When rendered, it now looks like the date field we had before, and clicking
    on it brings up the calendar date picker:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 当渲染时，它现在看起来就像我们之前拥有的日期字段，点击它将弹出日历日期选择器：
- en: '![Figure 6.20: DateField with date input'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.20：带有日期输入的DateField]'
- en: '](img/B15509_06_20.jpg)'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B15509_06_20.jpg](img/B15509_06_20.jpg)'
- en: 'Figure 6.20: DateField with date input'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.20：带有日期输入的DateField
- en: 'Examining the generated HTML now, we can see it uses the `date` type:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 现在检查生成的HTML，我们可以看到它使用的是`date`类型：
- en: '[PRE57]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The final input that we are missing is the hidden input.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还缺少的最终输入是隐藏输入。
- en: 'Once again, due to the data-centric nature of Django forms, there is no `HiddenField`.
    Instead, we choose the type of field that needs to be hidden and set its `widget`
    to `HiddenInput`. We can then set the value of the field using the field constructor''s
    `initial` argument:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Django表单的数据中心性质，没有`HiddenField`。相反，我们选择需要隐藏的字段类型，并将其`widget`设置为`HiddenInput`。然后我们可以使用字段构造函数的`initial`参数设置字段的值：
- en: '[PRE58]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Here is the generated HTML:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是生成的HTML：
- en: '[PRE59]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Note that as this is a `hidden` input, Django does not generate a `label` instance
    or any surrounding `p` elements. There are other form fields that Django provides
    that work in similar ways. These range from `DateTimeField` (for capturing a date
    and time) to `GenericIPAddressField` (for either IPv4 or IPv6 addresses) and `URLField`
    (for URLs). A full list of fields is available at [https://docs.djangoproject.com/en/3.0/ref/forms/fields/](https://docs.djangoproject.com/en/3.0/ref/forms/fields/).
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于这是一个`隐藏`输入，Django不会生成`label`实例或任何周围的`p`元素。Django还提供了其他一些以类似方式工作的表单字段。这些包括`DateTimeField`（用于捕获日期和时间）、`GenericIPAddressField`（用于IPv4或IPv6地址）和`URLField`（用于URL）。完整的字段列表可在[https://docs.djangoproject.com/en/3.0/ref/forms/fields/](https://docs.djangoproject.com/en/3.0/ref/forms/fields/)找到。
- en: Rendering a Form in a Template
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在模板中渲染表单
- en: We've now seen how to create a form and add fields, and we've seen what the
    form looks like and what HTML is generated. But how is the form actually rendered
    in the template? We simply instantiate the `Form` class and pass it to the `render`
    function in a view, using the context, just like any other variable.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了如何创建表单并添加字段，我们也看到了表单的样式以及生成的HTML。但是表单实际上是如何在模板中渲染的呢？我们只需实例化`Form`类，并将其传递给视图中的`render`函数，使用上下文，就像任何其他变量一样。
- en: 'For example, here''s how to pass our `ExampleForm` to a template:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下是传递我们的`ExampleForm`到模板的方法：
- en: '[PRE60]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Django does not add the `<form>` element or submit button(s) for you when rendering
    the template; you should add these around where your form is placed in the template.
    The form can be rendered like any other variable.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: Django在渲染模板时不会为你添加`<form>`元素或提交按钮；你应该在模板中表单放置的位置周围添加这些元素。表单可以像任何其他变量一样进行渲染。
- en: 'We mentioned briefly earlier that the form is rendered in the template using
    the `as_p` method. This layout method was chosen as it most closely matches the
    example form we built manually. Django offers three layout methods that can be used:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前简要提到过，表单是通过使用`as_p`方法在模板中渲染的。这个布局方法被选择，因为它与我们手动构建的示例表单最接近。Django提供了三种可以使用的布局方法：
- en: '`as_table`'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`as_table`'
- en: 'The form is rendered as table rows, with each input on its own row. Django
    does not generate the surrounding `table` element, so you should wrap the form
    yourself. See the following example:'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '`as_table` is the default rendering method, so `{{ form.as_table }}` and `{{
    form }}` are equivalent. When rendered, the form looks like this:'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.21: Form rendered as a table'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15509_06_21.jpg)'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 6.21: Form rendered as a table'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a small sample of HTML that is generated:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '`as_ul`'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This renders the form fields as list items (`li`) inside either a `ul` or `ol`
    element. Like with `as_table`, the containing element (`<ul>` or `<ol>`) is not
    created by Django and must be added by you:'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Here''s how the form renders using `as_ul`:'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.22: Form rendered using as_ul'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15509_06_22.jpg)'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 6.22: Form rendered using as_ul'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: 'And here''s a sample of the generated HTML:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '`as_p`'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, there is the `as_p` method, which we were using in our previous examples.
    Each input is wrapped within `p` tags, which means that you don''t have to wrap
    the form manually (in `<table>` or `<ul>`) like you did with the previous methods:'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Here''s what the rendered form looks like:'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.23: Form rendered using as_p'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15509_06_23.jpg)'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 6.23: Form rendered using as_p'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: 'And you''ve seen this before, but once again, here''s a sample of the HTML generated:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: It is up to you to decide which method you want to use to render your form,
    depending on which suits your application best. In terms of their behavior and
    use with your view, all of the methods are all identical. In *Chapter 15*, *Django
    Third Party Libraries*, we will also introduce a method of rendering forms that
    will make use of the Bootstrap CSS classes.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have been introduced to Django Forms, we can now update our example
    form page to use a Django Form instead of manually writing all the HTML ourselves.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 6.03: Building and Rendering a Django Form'
  id: totrans-347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will build a Django form using all the fields we have
    seen. The form and view will behave similarly to the form that we built manually;
    however, you will be able to see how much less code is required when writing forms
    using Django. Your form will also automatically get field validation, and if we
    make changes to the form, we don''t have to then make changes to the HTML, as
    it will update dynamically based on the form definition:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: In PyCharm, create a new file called `forms.py` inside the `form_example` app directory.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the Django `forms` library at the top of your `forms.py` file:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Define the choices for the radio buttons by creating a `RADIO_CHOICES` variable.
    Populate it as follows:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: You will use this soon when you create a `ChoiceField` instance called `radio_input`.
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Define the nested choices for the book select inputs by creating a `BOOK_CHOICES`
    variable. Populate it as follows:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Create a class called `ExampleForm` that inherits from the `forms.Form` class:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Add all of the following fields as attributes on the class:'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Save the file.
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open your `form_example` app''s `views.py` file. At the top of the file, add
    a line to import `ExampleForm` from your `forms.py` file:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Inside the `form_example` view, instantiate the `ExampleForm` class and assign
    it to the `form` variable:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Add the `form` variable into the context dictionary, using the `form` key.
    The `return` line should look like this:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Save the file. Make sure you haven't removed the code that prints out the data
    the form has sent, as we will use it again later in this exercise.
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open the `form-example.html` file, inside the `form_example` app''s `templates`
    directory. You can remove nearly all of the contents of the `form` element, except
    the `{% csrf_token %}` template tag and the submit buttons. When you''re done,
    it should look like this:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Add a rendering of the `form` variable using the `as_p` method. Put this on
    the line after the `{%`` csrf_token %}` template tag. The whole `form` element
    should now look like this:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Start the Django dev server if it is not already running, then visit the form
    example page in your browser, at `http://127.0.0.1:8000/form-example/`. It should
    look as follows:![Figure 6.24: Django ExampleForm rendered in the browser'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15509_06_24.jpg)'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 6.24: Django ExampleForm rendered in the browser'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Enter some data in the form – since Django marks all fields as required, you
    will need to enter some text or select values for all fields, including ensuring
    that the checkbox is checked. Submit the form.
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Switch back to PyCharm and look in the Debug Console at the bottom of the window.
    You should see all the values being submitted by the form are printed out to the
    console, similar to *Exercise 6.02, Working with POST Data in a View*:![Figure
    6.25: Values as submitted by the Django form'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15509_06_25.jpg)'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 6.25: Values as submitted by the Django form'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: You can see that the values are still strings, and the names match those of
    the attributes of `ExampleForm` class. Notice that the submit button that you
    clicked is included, as well as the CSRF token. The form you submit can be a mix
    of Django form fields and arbitrary fields you add; both will be contained in
    the `request.POST` `QueryDict` object.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you created a Django form, with many different types of form
    fields. You instantiated it into a variable in your view, then passed it to `form-example.html`
    where it was rendered as HTML. Finally, you submitted the form and looked at the
    values it posted. Notice that the amount of code we had to write to generate the
    same form was greatly reduced. We did not have to manually code any HTML and we
    now have one place that both defines how the form will display and how it will
    validate. In the next section, we will examine how Django forms can automatically
    validate the submitted data, as well as how the data is converted from strings
    to Python objects.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: Validating Forms and Retrieving Python Values
  id: totrans-382
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have seen how Django Forms makes it much simpler to define a form
    using Python code and have it automatically rendered. We will now look at the
    other part of what makes Django forms useful: their ability to automatically validate
    the form and then retrieve native Python objects and values from them.'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了Django表单如何通过Python代码自动渲染来简化定义表单的过程。现在，我们将探讨使Django表单有用的另一部分：它们能够自动验证表单，并从中检索原生Python对象和值。
- en: 'In Django, a form can either be *unbound* or *bound*. These terms describe
    whether or not the form has had the submitted `POST` data sent to it for validation.
    So far, we have only seen unbound forms – they are instantiated without arguments,
    like this:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在Django中，表单可以是*未绑定*或*绑定*的。这些术语描述了表单是否已经接收到用于验证的提交`POST`数据。到目前为止，我们只看到了未绑定的表单——它们是无参数实例化的，如下所示：
- en: '[PRE77]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'A form is bound if it is called with some data to be used for validation, such
    as the `POST` data. A bound form can be created like this:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 如果表单使用一些数据调用以用于验证，例如`POST`数据，则该表单是绑定的。绑定的表单可以创建如下所示：
- en: '[PRE78]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'A bound form allows us to start using built-in validation-related tools: first,
    the `is_valid` method to check the form''s validity, then the `cleaned_data` attribute
    on the form, which contains the values converted from strings to Python objects.
    The `cleaned_data` attribute is only available after the form has been *cleaned*,
    which means the process of "cleaning up" the data and converting it from strings
    to Python objects. The cleaning process runs during the `is_valid` call. You will
    get `AttributeError` raised if you try to access `cleaned_data` before calling
    `is_valid`.'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 使用绑定形式后，我们可以开始使用内置的验证相关工具：首先，使用`is_valid`方法来检查表单的有效性，然后是表单上的`cleaned_data`属性，它包含从字符串转换为Python对象的值。`cleaned_data`属性仅在表单被*清理*后可用，这意味着“清理”数据并将其从字符串转换为Python对象的过程。清理过程在`is_valid`调用期间运行。如果你在调用`is_valid`之前尝试访问`cleaned_data`，将会引发`AttributeError`。
- en: 'A short example of how to access the cleaned data of `ExampleForm` follows:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个如何访问`ExampleForm`清理数据的简短示例：
- en: '[PRE79]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: In this example, `form.cleaned_data["integer_input"]` is the integer value `10`,
    so it can be compared to the number *5*. Compare this to the value that was posted,
    which is the string `"10"`. The cleaning process performs this conversion for
    us. Other fields such as dates or Booleans are converted accordingly.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`form.cleaned_data["integer_input"]`是整数值`10`，因此它可以与数字*5*进行比较。将此与已发布的值进行比较，该值是字符串`"10"`。清理过程为我们执行此转换。其他字段，如日期或布尔值，也会相应转换。
- en: 'The cleaning process also sets any errors on the form and fields that will
    be displayed when the form is rendered again. Let''s see all this in action. Modern
    browsers provide a large amount of client-side validation, so they prevent forms
    from being submitted unless their basic validation rules are met. You might have
    already seen this if you tried to submit the form in the previous exercise with
    empty fields:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 清理过程还会设置表单和字段上的任何错误，这些错误将在表单再次渲染时显示。让我们看看这一切是如何发生的。现代浏览器提供了大量的客户端验证，因此它们会阻止表单提交，除非其基本验证规则得到满足。如果你在之前的练习中尝试提交带有空字段的表单，你可能已经看到了这一点：
- en: '![Figure 6.26: Form submission prevented by the browser'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.26：浏览器阻止表单提交'
- en: '](img/B15509_06_26.jpg)'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15509_06_26.jpg)'
- en: 'Figure 6.26: Form submission prevented by the browser'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.26：浏览器阻止表单提交
- en: '*Figure 6.26* shows the browser preventing form submission. Since the browser
    is preventing the submission, Django never gets the opportunity to validate the
    form itself. To allow the form to be submitted, we need to add some more advanced
    validation that the browser is unable to validate itself.'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6.26*显示了浏览器阻止表单提交。由于浏览器阻止了提交，Django从未有机会验证表单本身。为了允许表单提交，我们需要添加一些更高级的验证，浏览器无法自行验证。'
- en: We will discuss the different types of validations that can be applied to form
    fields in the next section, but for now, we will just add a `max_digits` setting
    of `3` to `decimal_input` for our `ExampleForm`. This means the user should not
    enter more than three digits into the form.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节讨论可以应用于表单字段的不同类型的验证，但到目前为止，我们只是将`max_digits`设置为`3`添加到`ExampleForm`的`decimal_input`中。这意味着用户不应在表单中输入超过三个数字。
- en: Note
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Why should Django validate the form if the browser is already doing this and
    preventing submission? A server-side application should never trust input from
    the user: the user might be using an older browser or another HTTP client to send
    the request, thus not receiving any errors from their "browser." Also, as we have
    just mentioned, there are types of validation that the browser does not understand,
    and so Django must validate these on its end.'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: '`ExampleForm` is updated like this:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Now the view should be updated to pass `request.POST` to the `Form` class when
    the method is `POST`, for example, like this:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'If you pass `request.POST` into the form constructor when the method is not
    `POST`, then the form will always contain errors when first rendered, as `request.POST`
    will be empty. Now the browser will let us submit the form, but we will get an
    error displayed if the `decimal_input` contains more than three digits:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.27: An error displayed when a field is not valid'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_06_27.jpg)'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.27: An error displayed when a field is not valid'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: 'Django is automatically rendering the form differently in the template when
    it has errors. But how can we make the view behave differently depending on the
    validity of the form? As we mentioned earlier, we should use the form''s `is_valid`
    method. A view using this check might have code like this:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: In this example, we are redirecting to a success page if the form is valid.
    Otherwise, assume the execution flow continues as before and passes the invalid
    form back to the `render` function to be displayed to the user with errors.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: 'Why do we return a redirect on success? For two reasons: first, an early return
    prevents the execution of the rest of the view (that is, the failure branch);
    second, it prevents the message about resending the form data if the user then
    reloads the page.'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: In the next exercise, we will see the form validation in action and change the
    view execution flow based on the validity of the form.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 6.04: Validating Forms in a View'
  id: totrans-414
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will update the example view to instantiate the form differently
    depending on the HTTP method. We will also change the form to print out the cleaned
    data instead of the raw `POST` data, but only if the form is valid:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: 'In PyCharm, open the `forms.py` file inside the `form_example` app directory.
    Add a `max_digits=3` argument to `decimal_input` of `ExampleForm`:'
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Once this argument is added, we can submit the form, since the browser does
    not know how to validate this rule, but Django does.
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open the `reviews` app''s `views.py` file. We need to update the `form_example`
    view so that if the request''s method is `POST`, the `ExampleForm` is instantiated
    with the `POST` data; otherwise, it''s instantiated without arguments. Replace
    the current form initialization with this code:'
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Next, also for the `POST` request method, we will check whether the form is
    valid using the `is_valid` method. If the form is valid, we will print out all
    of the cleaned data. Add a condition after the `ExampleForm` instantiation to
    check `form.is_valid()`, then move the debug print loop inside this condition.
    Your `POST` branch should look like this:'
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Instead of iterating over the raw `request.POST` `QueryDict` (in which all
    the data are `string` instances), we will iterate over `cleaned_data` of `form`.
    This is a normal dictionary and contains the values converted to Python objects.
    Replace the `for` line and `print` line with these two:'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: We don't need to use `getlist()` anymore, as `cleaned_data` has already converted
    the multi-value fields into `list` instances.
  id: totrans-425
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Start the Django dev server, if it is not already running. Switch to your browser
    and browse to the example form page at `http://127.0.0.1:8000/form-example/`.
    The form should look as it did before. Fill in all the fields, but be sure to
    enter four or more numbers into the `Decimal input` field to make the form invalid.
    Submit the form, and you should see the error message for `Decimal input` show
    up when the page refreshes:![Figure 6.28: Decimal input error displayed after
    the form is submitted'
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15509_06_28.jpg)'
  id: totrans-427
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 6.28: Decimal input error displayed after the form is submitted'
  id: totrans-428
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Fix the form errors by making sure only three digits are in the `Decimal input`
    field, then submit the form again. Switch back to PyCharm and check the debug
    console. You should see that all the cleaned data has been printed out:![Figure
    6.29: Cleaned data from the form printed out'
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15509_06_29.jpg)'
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 6.29: Cleaned data from the form printed out'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: Notice the conversions that have taken place. The `CharField` instances have
    been converted to `str`, `BooleanField` to `bool`, and `IntegerField`, `FloatField`,
    and `DecimalField` to `int`, `float`, and `Decimal`, respectively. `DateField`
    becomes `datetime.date` and the choice fields retain the string values of their
    initial choice values. Notice that `books_you_own` is automatically converted
    to a `list` of `str` instances.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: Also, note that unlike when we iterated over all of the `POST` data, `cleaned_data`
    only contains form fields. The other data (such as the CSRF token and the submit
    button that was clicked) is present in the `POST` `QueryDict` but is not included
    as it does not include form fields.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you updated `ExampleForm` so the browser allowed it to be
    submitted even though Django would consider it to be invalid. This allowed Django
    to perform its validation on the form. You then updated the `form_example` view
    to instantiate the `ExampleForm` class differently depending on the HTTP method;
    passing in the request's `POST` data for a `POST` request. The view also had its
    debug output code updated to `print` out the `cleaned_data` dictionary. Finally,
    you tested submitting valid and invalid form data to see the different execution
    paths and the types of data that the form generated. We saw that Django automatically
    converted the `POST` data from strings to Python types based on the field class.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will look at how to add more validation options to fields, which will
    allow us to more tightly control the values that can be entered.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: Built-In Field Validation
  id: totrans-436
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have not yet discussed the standard validation arguments that can be used
    on fields. Although we already mentioned the `required` argument (which is `True`
    by default), many others can be used to more tightly control the data being entered
    into a field. Here are a few useful ones:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: '`max_length`'
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sets the maximum number of characters that can be entered into the field; available
    on `CharField` (and `FileField`, which we will cover in *Chapter 8*, *Media Serving
    and File Uploads*).
  id: totrans-439
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`min_length`'
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sets the minimum number of characters that must be entered into the field; available
    on `CharField` (and `FileField`; again, more about this in *Chapter 8*, *Media
    Serving and File Uploads*).
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`max_value`'
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sets the maximum value that can be entered into a numeric field; available on
    `IntegerField`, `FloatField`, and `DecimalField`.
  id: totrans-443
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`min_value`'
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sets the minimum value that can be entered into a numeric field; available on
    `IntegerField`, `FloatField`, and `DecimalField`.
  id: totrans-445
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`max_digits`'
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This sets the maximum number of digits that can be entered; this includes digits
    before and after a decimal point (if one exists). For example, the number *12.34*
    has four digits, and the number *56.7* has three. Used in `DecimalField`.
  id: totrans-447
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`decimal_places`'
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This sets the maximum number of digits that can be after the decimal point.
    This is used in conjunction with `max_digits`, and the number of decimal places
    will always count toward the number of digits even if that number of decimals
    has not been entered after the decimal place. For example, imagine using `max_digits`
    of four and `decimal_places` of three: if the number *12.34* was entered, it would
    actually be interpreted as the value *12.340*; that is, zeros are appended until
    the number of digits after the decimal point is equal to the `decimal_places`
    setting. Since we set three as the value for `decimal_places`, the total number
    of digits ends up being five, which exceeds the `max_digits` setting of four.
    The number *1.2* would be valid since even after expanding to *1.200*, the total
    number of digits is only four.'
  id: totrans-449
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can mix and match the validation rules (provided that the fields support
    them). `CharField` can have `max_length` and `min_length`, numeric fields can
    have both `min_value` and `max_value`, and so on.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: If you need more validation options, you can write custom validators, which
    we will cover in the next section. Right now, we will add some validators to our
    `ExampleForm` to see them in action.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 6.05: Adding Extra Field Validation'
  id: totrans-452
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will add and modify the validation rules for the fields
    of `ExampleForm`. We will then see how these changes affect how the form behaves,
    both in the browser and when Django validates the form:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: In PyCharm, open the `forms.py` file inside the `form_example` app directory.
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will make `text_input` require at most three characters. Add a `max_length=3`
    argument to the `CharField` constructor:'
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-456
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Make `password_input` more secure by requiring a minimum of eight characters.
    Add a `min_length=8` argument to the `CharField` constructor:'
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-458
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The user may have no books, so the `books_you_own` field should not be required.
    Add a `required=False` argument to the `MultipleChoiceField` constructor:'
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-460
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'The user should only be able to enter a value between 1 and 10 in `integer_input`.
    Add `min_value=1` and `max_value=10` arguments to the `IntegerField` constructor:'
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-462
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Finally, add `max_digits=5` and `decimal_places=3` to the `DecimalField` constructor:'
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-464
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Save the file.
  id: totrans-465
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Start the Django dev server if it''s not already running. We do not have to
    make any changes to any other files to get these new validation rules, since Django
    automatically updates the HTML generation and validation logic. This is a great
    benefit you get from using Django forms. Just visit or refresh `http://127.0.0.1:8000/form-example/`
    in your browser and the new validation will be automatically added. The form should
    not look any different until you try to submit it with incorrect values, in which
    case your browser can automatically show errors. Some things to try are as follows:'
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter more than three characters into the `Text input` field; you will not be
    able to.
  id: totrans-467
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Type fewer than eight characters into the `Password` field then click away from
    it. The browser should show an error indicating that this is not valid.
  id: totrans-468
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Do not select any values for the `Books you own` field. This will not prevent
    you from submitting the form anymore.
  id: totrans-469
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Use the stepper buttons on `Integer input`. You will only be able to enter a
    value between `1` and `10`. If you type in a value outside this range, your browser
    should show an error.
  id: totrans-470
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Decimal input` is the only field that does not validate the Django rules in
    the browser. You will need to type in an invalid value (such as `123.456`) and
    submit the form before an error (generated by Django) is displayed.'
  id: totrans-471
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following figure shows some of the fields that the browser can validate
    itself:'
  id: totrans-472
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.30: Browser performing validation with the new rules'
  id: totrans-473
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15509_06_30.jpg)'
  id: totrans-474
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 6.30: Browser performing validation with the new rules'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 6.31* shows an error that can only be generated by Django as the browser
    does not understand the `DecimalField` validation rules:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.31: The browser considers the form valid, but Django does not'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_06_31.jpg)'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.31: The browser considers the form valid, but Django does not'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we implemented some basic validation rules on our form fields.
    We then loaded the form example page in the browser, without having to make any
    changes to our template or view. We tried to submit the form with different values
    to see how the browser can validate the form compared to Django.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: In the activity for this chapter, we will implement the Book Search view using
    a Django form.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 6.01: Book Searching'
  id: totrans-482
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this activity, you will finish the Book Search view that was started in *Chapter
    1*, *Introduction to Django*. You will build a `SearchForm` instance that submits
    and accepts a search string from `request.GET`. It will have a `select` field
    to choose to search for `title` or `contributor`. It will then search for all
    `Book` instances containing the given text in `title` or in `first_names` or `last_names`
    of `Contributor`. You will then render this list of books in the `search-results.html`
    template. The search term should not be required, but if it exists, it should
    have a length of three or fewer characters. Since the view will search even when
    using the `GET` method, the form will always have its validation checked. If we
    made the field `required`, it would always show an error whenever the page loads.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: There will be two ways of performing the search. The first is by submitting
    the search form that is in the `base.html` template and thus in the top-right
    corner of every page. This will only search through `Book` titles. The other method
    is by submitting a `SearchForm` instance that is rendered on the `search-results.html`
    page. This form will display the `ChoiceField` instance for choosing between `title`
    or `contributor` search.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: 'These steps will help you complete this activity:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: Create a `SearchForm` instance in your `forms.py` file.
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`SearchForm` should have two fields. The first is a `CharField` instance with
    the name `search`. This field should not be required but should have a minimum
    length of `3`.'
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second field on `SearchForm` is a `ChoiceField` instance named `search_in`.
    This will allow selecting between `title` and `contributor` (with `Title` and
    `Contributor` labels, respectively). It should not be `required`.
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the `book_search` view to instantiate a `SearchForm` instance using data
    from `request.GET`.
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add code to search for `Book` models using `title__icontains` (for case-insensitive
    searching). This should be done if searching by `title`. The search should only
    be performed if the form is valid and contains some search text. The `search_in`
    value should be retrieved from `cleaned_data` using the `get` method since it
    might not exist, as it's not required. Set its default to `title`.
  id: totrans-490
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When searching for contributors, use `first_names__icontains` or `last_names__icontains`,
    then iterate the contributors and retrieve the books for each contributor. This
    should be done if searching by `contributor`. The search should only be performed
    if the form is valid and contains some search text. There are many ways to combine
    the search results for a first or last name. The easiest method, using the techniques
    that you have been introduced to so far, is to perform two queries, one for matching
    first names and then for last names, and iterating them separately.
  id: totrans-491
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the `render` call to include the `form` variable and the books that were
    retrieved in the context (as well as `search_text` that was already being passed).
    The location of the template was changed in *Chapter 3*, *URL Mapping, Views,
    and Templates*, so update the second argument to `render` accordingly.
  id: totrans-492
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `search-results.html` template we created in *Chapter 1*, *Introduction
    to Django*, is essentially redundant now, so you can clear its content. Update
    the `search-results.html` file to extend from `base.html` instead of being a standalone
    template file.
  id: totrans-493
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `title` block that will display `Search Results for <search_text>` if
    the form is valid and `search_text` was set and will otherwise just display `Book
    Search`. This block will also be added to `base.html` later in this activity.
  id: totrans-494
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `content` block, which should show an `<h2>` heading with the text `Search
    for Books`. Under the `<h2>` heading, render the form. The `<form>` element can
    have no attributes and it will default to making a `GET` request to the same URL
    that it's on. Add a submit button as we have used in previous activities, with
    the `btn btn-primary` class.
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under the form, show a `Search results for <search_text>` message if the form
    is valid and search text was entered, otherwise show no message. This should be
    displayed in an `<h3>` heading, and the search text should be wrapped in `<em>`.
  id: totrans-496
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Iterate over the search results and render each one. Show the book title and
    contributor's first and last names. The book title should link to the `book_detail`
    page. If the books list is empty, show the text `No results found`. You should
    wrap the results in `<ul>` with `class` `list-group`, and each result should be
    an `<li>` instance with `class` `list-group-item`. This will be similar to the
    `book_list` page; however, we won't show as much information (just the title and
    contributors).
  id: totrans-497
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update `base.html` to include an action attribute in the search `<form>` tag.
    Use the `url` template tag to generate the URL for this attribute.
  id: totrans-498
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `name` attribute of the search field to `search` and the `value` attribute
    to the search text that was entered. Also, ensure that the minimum length of the
    field is `3`.
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `base.html`, add a `title` block to the `title` tag that was overridden by
    other templates (as in *step 9*). Add a `block` template tag inside the `<title>`
    HTML element. It should have the content `Bookr`.
  id: totrans-500
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After completing this activity, you should be able to open the Book Search
    page at `http://127.0.0.1:8000/book-search/` and it will look like *Figure 6.32*:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.32: Book Search page without a search'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_06_32.jpg)'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.32: Book Search page without a search'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: When searching for something using just two characters, your browser should
    prevent you from submitting either of the search fields. If you search for something
    that returns no results, you will see a message that there were no results. Searching
    by title (this can be done with either field) will show matching results.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, when searching by the contributor (although this can only be done
    in the lower form), you should see something like the following:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.33: A contributor search'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_06_33.jpg)'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.33: A contributor search'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this activity can be found at [http://packt.live/2Nh1NTJ](http://packt.live/2Nh1NTJ).
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-512
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter was an introduction to forms in Django. We introduced some HTML
    inputs for entering data onto a web page. We talked about how data is submitted
    to a web application and when to use `GET` and `POST` requests. We then looked
    at how Django's form classes can make generating the form HTML simpler, as well
    as allowing the automatic building of forms using models. We enhanced Bookr some
    more by building the book search functionality.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will go deeper into forms and learn how to customize
    the display of form fields, how to add more advanced validation to your form,
    and how to automatically save model instances by using the `ModelForm` class.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
