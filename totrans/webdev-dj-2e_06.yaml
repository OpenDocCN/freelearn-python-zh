- en: 6\. Forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: This chapter introduces web forms, a method of sending information from the
    browser to the web server. It starts with an introduction to forms in general
    and discusses how data is encoded to be sent to the server. You will learn about
    the differences between sending form data in a `GET` HTTP request and sending
    it in a `POST` HTTP request, and how to choose which one to use. By the end of
    the chapter, you will know how Django's form library is used to build and validate
    forms automatically and how it cuts down the amount of manual HTML you need to
    write.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, the views we have been building for Django have been one-way only. Our
    browser is retrieving data from the views we have written but it does not send
    any data back to them. In *Chapter 4*, *Introduction to Django Admin*, we created
    model instances using the Django admin and submitting forms, but those were using
    views built into Django, not created by us. In this chapter, we will use the Django
    Forms library to start accepting user-submitted data. The data will be provided
    through `GET` requests in the URL parameters, and/or `POST` requests in the body
    of the request. But before we get into the details, first let us understand what
    are forms in Django.
  prefs: []
  type: TYPE_NORMAL
- en: What Is a Form?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working with an interactive web app, we not only want to provide data to
    users but also accept data from them to either customize the responses we are
    generating or let them submit data to the site. When browsing the web, you will
    most definitely have used forms. Whether you're logging in to your internet banking
    account, surfing the web with a browser, posting a message on social media, or
    writing an email in an online email client, in all these cases, you are entering
    data in a form. A form is made up of inputs that define key-value pairs of data
    to submit to the server. For example, when logging in to a website, the data being
    sent would have the keys *username* and *password*, with the values of your username
    and your password, respectively. We will go into the different types of inputs
    in more detail in the *Types of Inputs* section. Each input in the form has a
    *name*, and this is how its data is identified on the server-side (in a Django
    view). There can be multiple inputs with the same *name*, whose data is available
    in a list containing all the posted values with this name – for example, a list
    of checkboxes with permissions to apply to users. Each checkbox would have the
    same name but a different value. The form has attributes that specify which URL
    the browser should submit the data to and what method it should use to submit
    the data (browsers only support `GET` or `POST`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The GitHub login form shown in the next figure is an example of a form:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1: The GitHub login page is an example of a form'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_06_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.1: The GitHub login page is an example of a form'
  prefs: []
  type: TYPE_NORMAL
- en: 'It has three visible inputs: a text field (`Username`), a `password` field
    (`Password`), and a `submit` button (`Sign in`). It also has a field that is not
    visible – its type is `hidden`, and it contains a special token for security called
    a `Sign In` button, the form data is submitted with a `POST` request. If you entered
    a valid username and password, you are logged in; otherwise, the form will display
    an error as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2: Form submitted with an incorrect username or password'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_06_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.2: Form submitted with an incorrect username or password'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two states a form can have: **pre-submit** and **post-submit**. The
    first is the initial state when the page is first loaded. All the fields will
    have a default value (usually empty) and no errors will be displayed. If all the
    information that has been entered into a form is valid, then usually when it is
    submitted you will be taken to a page showing the results of submitting the form.
    This might be a search results page, or a page showing you the new object that
    you created. In this case, you will not see the form in its post-submit state.'
  prefs: []
  type: TYPE_NORMAL
- en: If you did not enter valid information into the form, then it will be rendered
    again in its post-submit state. In this state, you will be shown the information
    that you entered as well as any errors to help you resolve the problems with the
    form. The errors may be **field errors** or **non-field errors**. Field errors
    apply to a specific field. For example, leaving a required field blank or entering
    a value that is too large, too small, too long, or too short. If a form required
    you to enter your name and you left it blank, this would be displayed as a field
    error next to that field.
  prefs: []
  type: TYPE_NORMAL
- en: Non-field errors either do not apply to a field, or apply to multiple fields,
    and are displayed at the top of the form. In *Figure 6.2*, we see a message that
    either the username or password may be incorrect when logging in. For security,
    GitHub does not reveal whether a username is valid, and so this is displayed as
    a non-field error rather than a field error for the username or password (Django
    also follows this convention). Non-field errors also apply to fields that depend
    on each other. For example, on a credit card form, if the payment is rejected,
    we might not know if the credit card number or security code is incorrect; therefore,
    we cannot show that error on a specific field. It applies to the form as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: The <form> Element
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All inputs used during form submission must be contained inside a `<form>`
    element. There are three HTML attributes that you will be using to modify the
    behavior of the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '`method`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is the HTTP method used to submit the form, either `GET` or `POST`. If
    omitted, this defaults to `GET` (because this is the default method when typing
    a URL into the browser and hitting *Enter*).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`action`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This refers to the URL (or path) to send the form data to. If omitted, the data
    gets sent back to the current page.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`enctype`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This sets the encoding type of the form. You only need to change this if you
    are using the form to upload files. The most common values are `application/x-www-form-urlencoded`
    (the default if this value is omitted) or `multipart/form-data` (set this if uploading
    files). Note that you don't have to worry about the encoding type in your view;
    Django handles the different types automatically.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Here is an example of a form without any of its attributes set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: It will submit its data using a `GET` request, to the current URL that the form
    is being displayed on, using the `application/x-www-form-urlencoded` encoding
    type.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this next example, we will set all three attributes on a form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This form will submit its data with a `POST` request to the `/form-submit` path,
    encoding the data as `multipart/form-data`.
  prefs: []
  type: TYPE_NORMAL
- en: How do `GET` and `POST` requests differ in how the data is sent? Recall in *Chapter
    1*, *Introduction to Django*, we discussed what the underlying HTTP request and
    response data that your browser sends looks like. In these next two examples,
    we will submit the same form twice, the first time using `GET` and the second
    time using `POST`. The form will have two inputs, a first name, and the last name.
  prefs: []
  type: TYPE_NORMAL
- en: 'A form submitted using `GET` sends its data in the URL, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'A form submitted using `POST` sends its data in the body of the request, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You will notice that the form data is encoded the same way in both cases; it
    is just placed differently for the `GET` and `POST` requests. In an upcoming section,
    we will discuss how to choose between these two types of requests.
  prefs: []
  type: TYPE_NORMAL
- en: Types of Inputs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have seen four examples of inputs so far (*text*, *password*, *submit*, and
    *hidden*). Most inputs are created with an `<input>` tag, and their type is specified
    with its `type` attribute. Each input has a `name` attribute that defines the
    key for the key-value pairs that are sent to the server in the HTTP request.
  prefs: []
  type: TYPE_NORMAL
- en: In the next exercise, let's look at how we can build a form in HTML. This will
    allow you to get up to speed on many different form fields.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The code for all the exercises and activities used in this chapter can be found
    on the book's GitHub repository at [http://packt.live/2KGjlaM](http://packt.live/2KGjlaM).
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 6.01: Building a Form in HTML'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the first few exercises of this chapter, we will need an HTML form to test
    with. We will manually code one in this exercise. This will also allow you to
    experiment with how different fields are validated and submitted. This will be
    done in a new Django project so that we don''t interfere with Bookr. You can refer
    to *Chapter 1*, *Introduction to Django*, to refresh your memory on creating a
    Django project:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start by creating the new Django project. You can re-use the `bookr`
    virtual environment that already has Django installed. Open a new terminal and
    activate the virtual environment. Then, use `django-admin` to start a Django project
    named `form_project`. To do this, run the command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will scaffold the Django project in a directory named `form_example`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a new Django app in this project by using the `startapp` management
    command. The app should be called `form_example`. To do this, `cd` into the `form_project`
    directory, then run this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will create the `form_example` app directory inside the `form_project`
    directory.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Launch PyCharm, then open the `form_project` directory. If you already have
    a project open, you can do this by choosing `File` -> `Open`; otherwise, just
    click `Open` in the `Welcome to PyCharm` window. Navigate to the `form_project`
    directory, select it, then click `Open`. The `form_project` project window should
    be shown similar to this:![Figure 6.3: The form_project project open'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15509_06_03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 6.3: The form_project project open'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a new run configuration to execute `manage.py runserver` for the project.
    You can re-use the `bookr` virtual environment again. The `Run/Debug Configurations`
    window should look similar to the following figure when you''re done:![Figure
    6.4: Run/Debug Configurations for Runserver'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15509_06_04.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 6.4: Run/Debug Configurations for Runserver'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can test that the configuration is set up correctly by clicking the `Run`
    button, then visiting `http://127.0.0.1:8000/` in your browser. You should see
    the Django welcome screen. If the debug server fails to start or you see the Bookr
    main page, then you probably still have the Bookr project running. Try stopping
    the Bookr `runserver` process and then starting the new one you just set up.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Open `settings.py` in the `form_project` directory and add `'form_example'`
    to the `INSTALLED_APPS` setting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The last step in setting up this new project is to create a `templates` directory
    for the `form_example` app. Right-click on the `form_example` directory and then
    select `New` -> `Directory`. Name it `templates`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need an HTML template to display our form. Create one by right-clicking the
    `templates` directory you just created and choosing `New` -> `HTML File`. In the
    dialog box that appears, enter the name `form-example.html` and hit *Enter* to create
    it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `form-example.html` file should now be open in the editor pane of PyCharm.
    Start by creating the `form` element. We will set its `method` attribute to `post`.
    The `action` attribute will be omitted, which means the form will submit back
    to the same URL on which it was loaded.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Insert this code between the `<body>` and `</body>` tags:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now let us add a few inputs. To add a little bit of spacing between each input,
    we will wrap them inside `<p>` tags. We will start with a text field and password
    field. This code should be inserted between the `<form>` tags you just created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will add two checkboxes and three radio buttons. Insert this code
    after the HTML you added in the previous step; it should come before the `</form>` tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next is a dropdown select menu to allow the user to choose a favorite book.
    Add this code after that of the previous step but before the `</form>` tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It will display four options that are split into two groups. The user will only
    be able to select one option.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The next is a multiple select (achieved by using the `multiple` attribute).
    Add this code after that of the previous step but before the `</form>` tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The user can select zero or more options from the four. They are displayed in
    two groups.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next is `textarea`. It is like a text field but has multiple lines. This code
    should be added like in the previous steps, before the closing `</form>` tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, add some fields for specific data types: `number`, `email`, and `date`
    inputs. Add this all before the `</form>` tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now add some buttons to submit the form. Once again, insert this before the
    closing `</form>` tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This demonstrates two ways of creating submit buttons, either as `<input>` or `<button>`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, add a hidden field. Insert this before the closing `</form>` tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This field cannot be seen or edited so it has a fixed value. You can save and
    close `form-example.html`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'As with any template, we cannot see it unless we have a view to render it.
    Open the `form_example` app''s `views.py` file and add a new view called `form_example`.
    It should render and return the template you just created, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can now save and close `views.py`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You should be familiar with the next step now, which is to add a URL mapping
    to the view. Open the `urls.py` file in the `form_project` package directory.
    Add a mapping for the path `form-example` to your `form_example` view, to the
    `urlpatterns` variable. It should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make sure you also add an import of `form_example.views`. Save and close `urls.py`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Start the Django dev server (if it is not already running), then load your
    new view in your web browser; the address is `http://127.0.0.1:8000/form-example/`.
    Your page should look like this:![Figure 6.5: Example inputs page'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15509_06_05.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 6.5: Example inputs page'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can now familiarize yourself with the behavior of the web forms and see
    how they are generated from the HTML you specified. One activity to try is to
    enter invalid data into the number, date, or email inputs and click the submit
    button – the built-in HTML validation should prevent the form from being submitted:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.6: Browser error due to an invalid number'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15509_06_06.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 6.6: Browser error due to an invalid number'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We have not yet set up everything for form submission, so if you correct all
    the errors in the form and try to submit it (by clicking either of the submit
    buttons), you will receive an error stating `CSRF verification failed. Request
    aborted.`, as we can see in the next figure. We will talk about what this means,
    and how to fix it, later in the chapter:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.7: CSRF verification error'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15509_06_07.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 6.7: CSRF verification error'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you do receive the error, just go back in your browser to return to the input
    example page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this exercise, you created an example page showcasing many HTML inputs, then
    created a view to render it and a URL to map to it. You loaded the page in your
    browser and experimented with changing data and trying to submit the form when
    it contained errors.
  prefs: []
  type: TYPE_NORMAL
- en: Form Security with Cross-Site Request Forgery Protection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Throughout the book, we have mentioned features that Django includes to prevent
    certain types of security exploits. One of these features is protection against
    CSRF.
  prefs: []
  type: TYPE_NORMAL
- en: 'A CSRF attack exploits the fact that a form on a website can be submitted to
    any other website. The `action` attribute of `form` just needs to be set appropriately.
    Let''s take an example for Bookr. We don''t have this set up yet, but we will
    be adding a view and URL that allows us to post a review for a book. To do this,
    we''ll have a form for posting the review content and selecting the rating. Its
    HTML is like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'And on a web page, it would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.8: Example review creation form'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_06_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.8: Example review creation form'
  prefs: []
  type: TYPE_NORMAL
- en: 'Someone could take this form, make a few changes, and host it on their own
    website. For example, they could make the inputs hidden and hardcode a good review
    and rating for a book, and then make it look like some other kind of form, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Of course, the hidden fields don't display, so the form looks like this on the
    malicious website.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.9: Hidden inputs are not visible'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_06_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.9: Hidden inputs are not visible'
  prefs: []
  type: TYPE_NORMAL
- en: The user would think they were clicking a button to enter a website, but while
    clicking it, they would submit the hidden values to the original view on Bookr.
    Of course, a user could check the source code of the page they were on to check
    what data is being sent and where, but most users are unlikely to inspect every
    form they come across. The attacker could even have the form with no submit button
    and just use JavaScript to submit it, which means the user would be submitting
    the form without even realizing it.
  prefs: []
  type: TYPE_NORMAL
- en: You may think that requiring the user to log in to Bookr will prevent this type
    of attack, and it does limit its effectiveness somewhat, as the attack would then
    only work for logged-in users. But because of the way authentication works, once
    a user is logged in, they have a cookie set in their browser that identifies them
    to the Django application. This cookie is sent on every request so that the user
    does not have to provide their login credentials on every page. Because of the
    way web browsers work, they will include the server's authentication cookie in
    *all* requests they send to that particular server. Even though our form is hosted
    on a malicious site, ultimately it is sending a request to our application, so
    it will send through our server's cookies.
  prefs: []
  type: TYPE_NORMAL
- en: 'How can we prevent CSRF attacks? Django uses something called a CSRF token,
    which is a small random string that is unique to each site visitor – in general,
    you can consider a visitor to be one browser session. Different browsers on the
    same computer would be different visitors, and the same Django user logged in
    on two different browsers would also be different visitors. When the form is read,
    Django puts the token into the form as a hidden input. The CSRF token must be
    included in all `POST` requests being sent to Django, and it must match the token
    Django has stored on the server-side for the visitor, otherwise, a 403 status
    HTTP response is returned. This protection can be disabled – either for the whole
    site or for an individual view – but it is not advisable to do so unless you really
    need to. The CSRF token must be added into the HTML for every form being sent
    and is done with the `{% csrf_token %}` template tag. We''ll add it to our example
    review form now, and the code in the template will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'When the template gets rendered, the template tag is interpolated, so the output
    HTML ends up like this (note that the inputs are still in the output; they have
    just been removed here for brevity):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Since this is a hidden field, the form on the page does not look any different
    from how it did before.
  prefs: []
  type: TYPE_NORMAL
- en: The CSRF token is unique to every visitor on the site and periodically changes.
    If an attacker were to copy the HTML from our site, they would get their own CSRF
    token that would not match that of any other user, so Django would reject the
    form when it was posted by someone else.
  prefs: []
  type: TYPE_NORMAL
- en: CSRF tokens also change periodically. This limits how long the attacker would
    have to take advantage of a particular user and token combination. Even if they
    were able to get the CSRF token of a user that they were trying to exploit, they
    would have a short window of time to be able to use it.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing Data in the View
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we discussed in *Chapter 1*, *Introduction to Django*, Django provides two
    `QueryDict` objects on the `HTTPRequest` instances that are passed to the view
    function. These are `request.GET`, which contains parameters passed in the URL,
    and `request.POST`, which contains parameters in the HTTP request body. Even though
    `request.GET` has `GET` in its name, this variable is populated even for non-`GET`
    HTTP requests. This is because the data it contains is parsed from the URL. Since
    all HTTP requests have a URL, all HTTP requests may contain `GET` data, even if
    they are `POST` or `PUT`, and so on. In the next exercise, we will add code to
    our view to read and display the `POST` data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 6.02: Working with POST Data in a View'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will now add some code to our example view to print out the received `POST`
    data to the console. We will also insert the HTTP method that was used to generate
    the page into the HTML output. This will allow us to be sure of what method was
    used to generate the page (`GET` or `POST`) and see how the form differs for each
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in PyCharm, open the `form_example` app''s `views.py` file. Alter the
    `form_example` view to print each value in the `POST` request to the console by
    adding this code inside the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code iterates over each key in the request `POST` data `QueryDict` and
    prints the key and list of values to the console. We already know that each `QueryDict`
    can have multiple values for a key, so we use the `getlist` function to get them
    all.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Pass `request.method` to the template in a context variable named `method`.
    Do this by updating the call to `render` in the view, so that it''s like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will now display the `method` variable in the template. Open the `form-example.html`
    template and use an `<h4>` tag to show the `method` variable. Put this just after
    the opening `<body>` tag, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that we could access the method directly inside the template without passing
    it in a context dictionary, by using the `request` method variable and attribute
    properly. We know from *Chapter 3*, *URL Mapping, Views, and Templates*, that
    by using the render shortcut function, the request is always available in the
    template. We just demonstrated how to access the method in the view here because
    later on, we will change the behavior of the page based on the method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We also need to add the CSRF token to the form HTML. We do this by putting
    the `{% csrf_token %}` template tag after the opening `<form>` tag. The start
    of the form should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, save the file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Start the Django dev server if it''s not already running. Load the example
    page (`http://127.0.0.1:8000/form-example/`) in your browser, and you should see
    it now displays the method at the top of the page (`GET`):![Figure 6.10: Method
    at the top of the page'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15509_06_10.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 6.10: Method at the top of the page'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Enter some text or data in each of the inputs and submit the form, by clicking
    the `Submit Input` button:![Figure 6.11: Clicking the Submit Input button to submit
    the form'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15509_06_11.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 6.11: Clicking the Submit Input button to submit the form'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You should see the page reload and the method displayed change to `POST`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.12: Method updated to POST after the form is submitted'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15509_06_12.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 6.12: Method updated to POST after the form is submitted'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Switch back to PyCharm and look in the `Run` console at the bottom of the window.
    If it is not visible, click the `Run` button at the bottom of the window to show
    it:![Figure 6.13: Click the Run button at the bottom of the window to display
    the console'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15509_06_13.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 6.13: Click the Run button at the bottom of the window to display the
    console'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Inside the `Run` console, a list of the values that were posted to the server
    should be displayed:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.14: Input values shown in the Run console'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15509_06_14.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 6.14: Input values shown in the Run console'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Some things you should notice are as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: All values are sent as text, even `number` and `date` inputs.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For the `select` inputs, the selected `value` attributes of the selected options
    are sent, not the text content of the `option` tag.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If you select multiple options for `books_you_own`, then you will see multiple
    values in the request. This is why we use the `getlist` method since multiple
    values are sent for the same input name.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the checkbox was checked, you will have a `checkbox_on` input in the debug
    output. If it was not checked, then the key will not exist at all (that is, there
    is no key, instead of having the key existing with an empty string or `None` value).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We have a value for the name `submit_input`, which is the text `Submit Input`.
    You submitted the form by clicking the `Submit Input` button, so we receive its
    value. Notice that no value is set for the `button_element` input since that button
    was not clicked.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We will experiment with two other ways of submitting the form, first by hitting
    *Enter* when your cursor is in a text-like input (such as *text*, *password*,
    *date*, and *email*, but not *text area*, as hitting *Enter* there will add a
    new line).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you submit a form in this way, the form will act as though you had clicked
    the first submit button on the form, so the `submit_input` input value will be
    included. The output you see should match that of the previous figure.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The other way to submit the form is by clicking the `Button Element` submit
    input, in which we will try clicking this button to submit the form. You should
    see that `submit_button` is no longer in the list of posted values, while `button_element`
    is now present:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.15: submit_button is now gone from the inputs, and button_element
    is added'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15509_06_15.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 6.15: submit_button is now gone from the inputs, and button_element
    is added'
  prefs: []
  type: TYPE_NORMAL
- en: You can use this multiple-submit technique to alter how your view behaves depending
    on which button was clicked. You can even have multiple submit buttons with the
    same *name* attribute to make the logic easier to write.
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you added a CSRF token to your `form` element by using the
    `{% csrf_token %}` template tag. This means that your form could then be submitted
    to Django successfully without generating an HTTP Permission Denied response.
    We then added some code to output the values that our form contained when it was
    submitted. We tried submitting the form with various values to see how they are
    parsed into Python variables on the `request.POST` `QueryDict`. We will now discuss
    some more theory around the difference between `GET` and `POST` requests, then
    move on to the Django Forms library, which makes designing and validating forms
    easier.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing between GET and POST
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Choosing when to use a `GET` or `POST` request requires the consideration of
    a number of factors. The most important is deciding whether or not the request
    should be idempotent. A request can be said to be idempotent if it can be repeated
    and produce the same result each time. Let us look at some examples.
  prefs: []
  type: TYPE_NORMAL
- en: If you type any web address into your browser (such as any of the Bookr pages
    we have built so far), it will perform a `GET` request to fetch the information.
    You can refresh the page, and no matter how many times you click refresh, you
    will get the same data back. The request you are making will not affect the content
    on the server. You would say these requests are idempotent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, remember when you added data through the Django admin interface (in *Chapter
    4*, *Introduction to Django Admin*)? You typed in the information for the new
    book in a form, then clicked `Save`. Your browser made a `POST` request to create
    a new book on the server. If you repeated that `POST` request, the server would
    create *another* book and would do so each time you repeated the request. Since
    the request is updating information, it is not idempotent. Your browser will warn
    you about this. If you have ever tried to refresh a page that you were sent to
    after submitting a form, you may have received a message asking if you want to
    *"Repost form data?"* (or something more verbose, as in the following figure).
    This is a warning that you are sending the form data again, which might cause
    the action you just undertook to be repeated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.16: Firefox confirming whether information should be resent'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_06_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.16: Firefox confirming whether information should be resent'
  prefs: []
  type: TYPE_NORMAL
- en: This is not to suggest that all `GET` requests are idempotent and all `POST`
    requests are not – your backend application can be designed in any way you want.
    Although it is not best practice, a developer might have decided to make data
    get updated during a `GET` request in their web application. When you are building
    your applications, you should try to make sure `GET` requests are idempotent and
    leave data-altering to `POST` requests only. Stick to these principles unless
    you have a good reason not to.
  prefs: []
  type: TYPE_NORMAL
- en: Another point to consider is that Django only applies CSRF projection to `POST`
    requests. Any `GET` request, including one that alters data, can be accessed without
    a CSRF token.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, it can be hard to decide if a request is idempotent or not; for example,
    a login form. Before you submitted your username and password, you were not logged
    in, and afterward, the server considered you to be logged in, so could we consider
    that non-idempotent as it changed your authentication status with the server?
    On the other hand, once logged in, if you were able to send your credentials again,
    you would remain logged in. This implies that the request is idempotent and repeatable.
    So, should the request be `GET` or `POST`?
  prefs: []
  type: TYPE_NORMAL
- en: This brings us to the second point to consider when choosing what method to
    use. If sending form data with a `GET` request, the form parameters will be visible
    in the URL. For example, if we made a login form use a `GET` request, the login
    URL might be `https://www.example.com/login?username=user&password=password1`.
    The username, and worse, the password, is visible in the web browser's address
    bar. It would also be stored in the browser history, so anyone who used the browser
    after the real user could log in to the site. The URL is often stored in web server
    log files as well, meaning the credentials would be visible there too. In short,
    regardless of the idempotency of a request, don't pass sensitive data through
    URL parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, knowing that the parameter will be visible in the URL might be something
    you desire. For example, when searching with a search engine, usually the search
    parameter will be visible in the URL. To see this in action, try visiting [https://www.google.com](https://www.google.com)
    and searching for something. You'll notice that the page with the results has
    your search term as the `q` parameter. A search for `Django` will take you to
    the URL [https://www.google.com/search?q=Django](https://www.google.com/search?q=Django),
    for example. This allows you to share search results with someone else by sending
    them this URL. In *Activity 6.01, Book Searching*, you will add a search form
    that similarly passes a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Another consideration is that the maximum length of a URL allowed by a browser
    can be short compared to the size of a `POST` body – sometimes only around 2,000
    characters (or about 2 KB) compared to many megabytes or gigabytes that a `POST`
    body can be (assuming your server is set up to allow these sizes of requests).
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned earlier, URL parameters are available in `request.GET` regardless
    of the type of request being made (`GET`, `POST`, `PUT`, and so on). You might
    find it useful to send some data in URL parameters and others in the request body
    (available in `request.POST`). For example, you could specify a `format` argument
    in the URL that sets what format some output data will be transformed to, but
    the input data is provided in the `POST` body.
  prefs: []
  type: TYPE_NORMAL
- en: Why Use GET When We Can Put Parameters in the URL?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Django allows us to easily define URL maps that contain variables. We could,
    for example, set up a URL mapping for a search view like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This probably looks like a good approach at first, but when we start wanting
    to customize the results view with arguments, it can get complicated quickly.
    For example, we might want to be able to move from one results page to the next,
    so we add a page argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'And then we might also want to order the search results by a specific category,
    such as the author name or the date of publishing, so we add another argument
    for that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: You might be able to see the problem with this approach – we can't order the
    results without providing a page. If we wanted to also add a `results_per_page`
    argument too, we wouldn't be able to use that without setting `page` and `order`
    keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'Contrast this to using query parameters: all of them are optional, so you could
    search like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you could set a page like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you could just set the results ordering like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you could combine them all:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Another reason for using URL query parameters is that when submitting a form,
    the browser always sends the input values in this manner; it cannot be changed
    so that parameters are submitted as path components in the URL. Therefore, when
    submitting a form using `GET`, the URL query parameters must be used as the input data.
  prefs: []
  type: TYPE_NORMAL
- en: The Django Forms Library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve looked at how to manually write forms in HTML and how to access the
    data on the request object using `QueryDict`. We saw that the browser provides
    some validation for us for certain field types, such as email or numbers, but
    we have not tried validating the data in the Python view. We should validate the
    form in the Python view for two reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: It is not safe to rely solely on browser-based validation of input data. A browser
    may not implement certain validation features, meaning the user could post any
    type of data. For example, older browsers don't validate number fields, so a user
    can type in a number outside the range we are expecting. Furthermore, a malicious
    user could try to send harmful data without using a browser at all. The browser
    validation should be considered as a nicety for the user and that's all.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The browser does not allow us to do cross-field validation. For example, we
    can use the `required` attribute for inputs that are mandatory to be filled in.
    Often, though, we want to set the `required` attribute, based on the value of
    another input. For example, the email address input should only be set as `required`
    if the user has checked the `Register My Email` checkbox.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Django Forms library allows you to quickly define a form using a Python
    class. This is done by creating a subclass of the base Django `Form` class. You
    can then use an instance of this class to render the form in your template and
    validate the input data. We refer to our classes as forms, similar to how we subclass
    Django models to create our own `Model` classes. Forms contain one or more fields
    of a certain type (such as text fields, number fields, or email fields). You'll
    notice this sounds like Django models, and forms *are* similar to models but use
    different field classes. You can even automatically create a form from a model
    – we will cover this in *Chapter 7*, *Advanced Form Validation and Model Forms*.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a Form
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating a Django form is similar to creating a Django model. You define a class
    that inherits from the `django.forms.Form` class. The class has attributes, which
    are instances of different `django.forms.Field` subclasses. When rendered, the
    attribute name in the class corresponds to its input `name` in HTML. To give you
    a quick idea of what fields there are, some examples are `CharField`, `IntegerField`,
    `BooleanField`, `ChoiceField`, and `DateField`. Each field generally corresponds
    to one input when rendered in HTML, but there's not always a one-to-one mapping
    between a form field class and an input type. Form fields are more coupled to
    the type of data they collect rather than how they are displayed.
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate this, consider a `text` input and a `password` input. They both
    accept some typed-in text data, but the main difference between them is that the
    text is visibly displayed in a `text` input, whereas with a `password` input the
    text is obscured. In a Django form, both of these fields are represented using
    `CharField`. The difference in how they are displayed is set by changing the *widget*
    the field is using.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you're not familiar with the word *widget*, it is a term to describe the
    actual input that is being interacted with and how it is displayed. Text inputs,
    password inputs, select menus, checkboxes, and buttons are all examples of different
    widgets. The inputs we have seen in HTML correspond one-to-one with widgets. In
    Django, this is not the case, and the same type of `Field` class can be rendered
    in multiple ways depending on the widget that is specified.
  prefs: []
  type: TYPE_NORMAL
- en: 'Django defines a number of `Widget` classes that define how a `Field` should
    be rendered as HTML. They inherit from `django.forms.widgets.Widget`. A widget
    can be passed to the `Field` constructor to change how it is rendered. For example,
    a `CharField` instance renders as `text` `<input>` by default. If we use the `PasswordInput`
    widget, it will instead render as `password` `<input>`. The other widgets we will
    use are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`RadioSelect`, which renders a `ChoiceField` instance as radio buttons instead
    of a `<select>` menu'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Textarea`, which renders a `CharField` instance as `<textarea>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HiddenInput`, which renders a field as a hidden `<input>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will look at an example form and add fields and features one by one. First,
    let''s just create a form with a text input and a password input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The `widget` argument can be just a widget subclass, which can be fine a lot
    of the time. If you want to further customize the display of the input and its
    attributes, you can set the widget argument to an instance of the `widget` class
    instead. We will look at further customizing widget displays soon. In this case,
    we're using just the `PasswordInput` class, since we are not customizing it beyond
    changing the type of input being displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the form is rendered in a template, it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.17: Django form rendered in a browser'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_06_17.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.17: Django form rendered in a browser'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the inputs do not contain any content when the page loads; the text
    has been entered to illustrate the different input types.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we examine the page source, we can see the HTML that Django generates. For
    the first two fields, it looks like this (some spacing added for readability):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Notice that Django has automatically generated a `label` instance with its text
    derived from the field name. The `name` and `id` attributes have been set automatically.
    Django also automatically adds the `required` attribute to the input. Similar
    to model fields, form field constructors also accept a `required` argument – this
    defaults to `True`. Setting this to `False` removes the `required` attribute from
    the generated HTML.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll look at how a checkbox is added to the form:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A checkbox is represented with `BooleanField`, as it can have only two values,
    checked or unchecked. It''s added to the form in the same way as the other field:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The HTML that Django generates for this new field is similar to the previous
    two fields:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next are the select inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: We need to provide a list of choices to display in the `<select>` dropdown.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The field class constructor takes a `choices` argument. The choices are provided
    as a tuple of two-element tuples. The first element in each sub-tuple is the value
    of the choice and the second element is the text or description of the choice.
    For example, choices could be defined like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note that you can use lists instead of tuples if you want (or a combination
    of the two). This can be useful if you want your choices to be mutable:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To implement `optgroup`, we can nest the choices. To implement the choices
    the same way as our previous examples, we use a structure like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `select` functionality is added to the form by using a `ChoiceField` instance.
    The widget defaults to a `select` input so no configuration is necessary apart
    from setting `choices`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This is the HTML that is generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Making a multiple select requires the use of `MultipleChoiceField`. It takes
    a `choices` argument in the same format as the regular `ChoiceField` for single selects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'And its HTML is similar to that of the single select, except it has the `multiple`
    attribute added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Choices can also be set after the form is instantiated. You may want to generate
    the choices `list`/`tuple` inside your view dynamically and then assign it to
    the field''s `choices` attribute. See the following, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Next are the radio inputs, which are similar to selects:'
  prefs: []
  type: TYPE_NORMAL
- en: Like selects, radio inputs use `ChoiceField`, as they provide a single choice
    between multiple options.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The options to choose between are passed into the field constructor with the
    `choices` argument.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The choices are provided as a tuple of two-element tuples, also like selects:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '`ChoiceField` defaults to displaying as a `select` input, so the widget must
    be set to `RadioSelect` to have it rendered as radio buttons. Putting the choice
    setting together with this, we add radio buttons to the form like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the HTML that is generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Django automatically generates a unique label and ID for each of the three
    radio buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a `textarea` instance, use `CharField` with a `Textarea` widget:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You might notice that `textarea` is much larger than the previous ones we have
    seen (see the following figure):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.18: Normal textarea (top) versus Django''s default textarea (bottom)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15509_06_18.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 6.18: Normal textarea (top) versus Django''s default textarea (bottom)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is because Django automatically adds `cols` and `rows` attributes. These
    set the number of columns and rows, respectively, that the text field displays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `cols` and `rows` settings do not affect the amount of text that
    can be entered into a field, only the amount that is displayed at a time. Also
    note that the size of `textarea` can be set using CSS (for example, the `height`
    and `width` properties). This will override the `cols` and `rows` settings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To create `number` inputs, you might expect Django to have a `NumberField` type,
    but it does not.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Remember that the Django form fields are data-centric rather than display-centric,
    so instead, Django provides different `Field` classes depending on what type of
    numeric data you want to store:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For integers, use `IntegerField`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For floating-point numbers, use `FloatField` or `DecimalField`. The latter two
    differ in how they convert their data to a Python value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FloatField` will convert to a float while `DecimalField` is a decimal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decimal values offer better accuracy in representing numbers than float values
    but may not integrate well into your existing Python code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We''ll add all three fields to the form at once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the HTML for all three:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The `IntegerField` generated HTML is missing the `step` attribute that the other
    two have, which means the widget will only accept integer values. The other two
    fields (`FloatField` and `DecimalField`) generate very similar HTML. Their behavior
    is the same in the browser; they differ only when their values are used in Django
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you might have guessed, an `email` input can be created with `EmailField`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Its HTML is similar to the `email` input we created manually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Following our manually created form, the next field we will look at is `DateField`:'
  prefs: []
  type: TYPE_NORMAL
- en: By default, Django will render `DateField` as `text` input, and the browser
    will not show a calendar popup when the field is clicked.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can add `DateField` to the form with no arguments, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'When rendered, it just looks like a normal `text` input:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.19: Default DateField display in a form'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_06_19.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.19: Default DateField display in a form'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the HTML generated by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason for using a `text` input is that it allows the user to enter the
    date in a number of different formats. For example, by default, the user can type
    in the date in *Year-Month-Day* (dash-separated) or *Month/Day/Year* (slash-separated)
    formats. The accepted formats can be specified by passing a list of formats to
    the `DateField` constructor using the `input_formats` argument. For example, we
    could accept dates in the formats of *Day/Month/Year* or *Day/Month/Year-with-century*,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: We can override any attributes on a field's widget by passing the `attrs` argument
    to the widget constructor. This accepts a dictionary of attribute key/values that
    will be rendered into the input's HTML.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have not used this yet, but we will see it again in the next chapter when
    we customize the field rendering further. For now, we''ll just set one attribute,
    `type`, that will overwrite the default input type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'When rendered, it now looks like the date field we had before, and clicking
    on it brings up the calendar date picker:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.20: DateField with date input'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_06_20.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.20: DateField with date input'
  prefs: []
  type: TYPE_NORMAL
- en: 'Examining the generated HTML now, we can see it uses the `date` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The final input that we are missing is the hidden input.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, due to the data-centric nature of Django forms, there is no `HiddenField`.
    Instead, we choose the type of field that needs to be hidden and set its `widget`
    to `HiddenInput`. We can then set the value of the field using the field constructor''s
    `initial` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the generated HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Note that as this is a `hidden` input, Django does not generate a `label` instance
    or any surrounding `p` elements. There are other form fields that Django provides
    that work in similar ways. These range from `DateTimeField` (for capturing a date
    and time) to `GenericIPAddressField` (for either IPv4 or IPv6 addresses) and `URLField`
    (for URLs). A full list of fields is available at [https://docs.djangoproject.com/en/3.0/ref/forms/fields/](https://docs.djangoproject.com/en/3.0/ref/forms/fields/).
  prefs: []
  type: TYPE_NORMAL
- en: Rendering a Form in a Template
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've now seen how to create a form and add fields, and we've seen what the
    form looks like and what HTML is generated. But how is the form actually rendered
    in the template? We simply instantiate the `Form` class and pass it to the `render`
    function in a view, using the context, just like any other variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here''s how to pass our `ExampleForm` to a template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Django does not add the `<form>` element or submit button(s) for you when rendering
    the template; you should add these around where your form is placed in the template.
    The form can be rendered like any other variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'We mentioned briefly earlier that the form is rendered in the template using
    the `as_p` method. This layout method was chosen as it most closely matches the
    example form we built manually. Django offers three layout methods that can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '`as_table`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The form is rendered as table rows, with each input on its own row. Django
    does not generate the surrounding `table` element, so you should wrap the form
    yourself. See the following example:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`as_table` is the default rendering method, so `{{ form.as_table }}` and `{{
    form }}` are equivalent. When rendered, the form looks like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.21: Form rendered as a table'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15509_06_21.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 6.21: Form rendered as a table'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a small sample of HTML that is generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '`as_ul`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This renders the form fields as list items (`li`) inside either a `ul` or `ol`
    element. Like with `as_table`, the containing element (`<ul>` or `<ol>`) is not
    created by Django and must be added by you:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here''s how the form renders using `as_ul`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.22: Form rendered using as_ul'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15509_06_22.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 6.22: Form rendered using as_ul'
  prefs: []
  type: TYPE_NORMAL
- en: 'And here''s a sample of the generated HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '`as_p`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, there is the `as_p` method, which we were using in our previous examples.
    Each input is wrapped within `p` tags, which means that you don''t have to wrap
    the form manually (in `<table>` or `<ul>`) like you did with the previous methods:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here''s what the rendered form looks like:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.23: Form rendered using as_p'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15509_06_23.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 6.23: Form rendered using as_p'
  prefs: []
  type: TYPE_NORMAL
- en: 'And you''ve seen this before, but once again, here''s a sample of the HTML generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: It is up to you to decide which method you want to use to render your form,
    depending on which suits your application best. In terms of their behavior and
    use with your view, all of the methods are all identical. In *Chapter 15*, *Django
    Third Party Libraries*, we will also introduce a method of rendering forms that
    will make use of the Bootstrap CSS classes.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have been introduced to Django Forms, we can now update our example
    form page to use a Django Form instead of manually writing all the HTML ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 6.03: Building and Rendering a Django Form'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will build a Django form using all the fields we have
    seen. The form and view will behave similarly to the form that we built manually;
    however, you will be able to see how much less code is required when writing forms
    using Django. Your form will also automatically get field validation, and if we
    make changes to the form, we don''t have to then make changes to the HTML, as
    it will update dynamically based on the form definition:'
  prefs: []
  type: TYPE_NORMAL
- en: In PyCharm, create a new file called `forms.py` inside the `form_example` app directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the Django `forms` library at the top of your `forms.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the choices for the radio buttons by creating a `RADIO_CHOICES` variable.
    Populate it as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You will use this soon when you create a `ChoiceField` instance called `radio_input`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Define the nested choices for the book select inputs by creating a `BOOK_CHOICES`
    variable. Populate it as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a class called `ExampleForm` that inherits from the `forms.Form` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add all of the following fields as attributes on the class:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open your `form_example` app''s `views.py` file. At the top of the file, add
    a line to import `ExampleForm` from your `forms.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `form_example` view, instantiate the `ExampleForm` class and assign
    it to the `form` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `form` variable into the context dictionary, using the `form` key.
    The `return` line should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the file. Make sure you haven't removed the code that prints out the data
    the form has sent, as we will use it again later in this exercise.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open the `form-example.html` file, inside the `form_example` app''s `templates`
    directory. You can remove nearly all of the contents of the `form` element, except
    the `{% csrf_token %}` template tag and the submit buttons. When you''re done,
    it should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a rendering of the `form` variable using the `as_p` method. Put this on
    the line after the `{%`` csrf_token %}` template tag. The whole `form` element
    should now look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start the Django dev server if it is not already running, then visit the form
    example page in your browser, at `http://127.0.0.1:8000/form-example/`. It should
    look as follows:![Figure 6.24: Django ExampleForm rendered in the browser'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15509_06_24.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 6.24: Django ExampleForm rendered in the browser'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Enter some data in the form – since Django marks all fields as required, you
    will need to enter some text or select values for all fields, including ensuring
    that the checkbox is checked. Submit the form.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Switch back to PyCharm and look in the Debug Console at the bottom of the window.
    You should see all the values being submitted by the form are printed out to the
    console, similar to *Exercise 6.02, Working with POST Data in a View*:![Figure
    6.25: Values as submitted by the Django form'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15509_06_25.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 6.25: Values as submitted by the Django form'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that the values are still strings, and the names match those of
    the attributes of `ExampleForm` class. Notice that the submit button that you
    clicked is included, as well as the CSRF token. The form you submit can be a mix
    of Django form fields and arbitrary fields you add; both will be contained in
    the `request.POST` `QueryDict` object.
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you created a Django form, with many different types of form
    fields. You instantiated it into a variable in your view, then passed it to `form-example.html`
    where it was rendered as HTML. Finally, you submitted the form and looked at the
    values it posted. Notice that the amount of code we had to write to generate the
    same form was greatly reduced. We did not have to manually code any HTML and we
    now have one place that both defines how the form will display and how it will
    validate. In the next section, we will examine how Django forms can automatically
    validate the submitted data, as well as how the data is converted from strings
    to Python objects.
  prefs: []
  type: TYPE_NORMAL
- en: Validating Forms and Retrieving Python Values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have seen how Django Forms makes it much simpler to define a form
    using Python code and have it automatically rendered. We will now look at the
    other part of what makes Django forms useful: their ability to automatically validate
    the form and then retrieve native Python objects and values from them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Django, a form can either be *unbound* or *bound*. These terms describe
    whether or not the form has had the submitted `POST` data sent to it for validation.
    So far, we have only seen unbound forms – they are instantiated without arguments,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'A form is bound if it is called with some data to be used for validation, such
    as the `POST` data. A bound form can be created like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'A bound form allows us to start using built-in validation-related tools: first,
    the `is_valid` method to check the form''s validity, then the `cleaned_data` attribute
    on the form, which contains the values converted from strings to Python objects.
    The `cleaned_data` attribute is only available after the form has been *cleaned*,
    which means the process of "cleaning up" the data and converting it from strings
    to Python objects. The cleaning process runs during the `is_valid` call. You will
    get `AttributeError` raised if you try to access `cleaned_data` before calling
    `is_valid`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A short example of how to access the cleaned data of `ExampleForm` follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `form.cleaned_data["integer_input"]` is the integer value `10`,
    so it can be compared to the number *5*. Compare this to the value that was posted,
    which is the string `"10"`. The cleaning process performs this conversion for
    us. Other fields such as dates or Booleans are converted accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The cleaning process also sets any errors on the form and fields that will
    be displayed when the form is rendered again. Let''s see all this in action. Modern
    browsers provide a large amount of client-side validation, so they prevent forms
    from being submitted unless their basic validation rules are met. You might have
    already seen this if you tried to submit the form in the previous exercise with
    empty fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.26: Form submission prevented by the browser'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_06_26.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.26: Form submission prevented by the browser'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 6.26* shows the browser preventing form submission. Since the browser
    is preventing the submission, Django never gets the opportunity to validate the
    form itself. To allow the form to be submitted, we need to add some more advanced
    validation that the browser is unable to validate itself.'
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss the different types of validations that can be applied to form
    fields in the next section, but for now, we will just add a `max_digits` setting
    of `3` to `decimal_input` for our `ExampleForm`. This means the user should not
    enter more than three digits into the form.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Why should Django validate the form if the browser is already doing this and
    preventing submission? A server-side application should never trust input from
    the user: the user might be using an older browser or another HTTP client to send
    the request, thus not receiving any errors from their "browser." Also, as we have
    just mentioned, there are types of validation that the browser does not understand,
    and so Django must validate these on its end.'
  prefs: []
  type: TYPE_NORMAL
- en: '`ExampleForm` is updated like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the view should be updated to pass `request.POST` to the `Form` class when
    the method is `POST`, for example, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'If you pass `request.POST` into the form constructor when the method is not
    `POST`, then the form will always contain errors when first rendered, as `request.POST`
    will be empty. Now the browser will let us submit the form, but we will get an
    error displayed if the `decimal_input` contains more than three digits:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.27: An error displayed when a field is not valid'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_06_27.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.27: An error displayed when a field is not valid'
  prefs: []
  type: TYPE_NORMAL
- en: 'Django is automatically rendering the form differently in the template when
    it has errors. But how can we make the view behave differently depending on the
    validity of the form? As we mentioned earlier, we should use the form''s `is_valid`
    method. A view using this check might have code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we are redirecting to a success page if the form is valid.
    Otherwise, assume the execution flow continues as before and passes the invalid
    form back to the `render` function to be displayed to the user with errors.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Why do we return a redirect on success? For two reasons: first, an early return
    prevents the execution of the rest of the view (that is, the failure branch);
    second, it prevents the message about resending the form data if the user then
    reloads the page.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next exercise, we will see the form validation in action and change the
    view execution flow based on the validity of the form.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 6.04: Validating Forms in a View'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will update the example view to instantiate the form differently
    depending on the HTTP method. We will also change the form to print out the cleaned
    data instead of the raw `POST` data, but only if the form is valid:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In PyCharm, open the `forms.py` file inside the `form_example` app directory.
    Add a `max_digits=3` argument to `decimal_input` of `ExampleForm`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once this argument is added, we can submit the form, since the browser does
    not know how to validate this rule, but Django does.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open the `reviews` app''s `views.py` file. We need to update the `form_example`
    view so that if the request''s method is `POST`, the `ExampleForm` is instantiated
    with the `POST` data; otherwise, it''s instantiated without arguments. Replace
    the current form initialization with this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, also for the `POST` request method, we will check whether the form is
    valid using the `is_valid` method. If the form is valid, we will print out all
    of the cleaned data. Add a condition after the `ExampleForm` instantiation to
    check `form.is_valid()`, then move the debug print loop inside this condition.
    Your `POST` branch should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Instead of iterating over the raw `request.POST` `QueryDict` (in which all
    the data are `string` instances), we will iterate over `cleaned_data` of `form`.
    This is a normal dictionary and contains the values converted to Python objects.
    Replace the `for` line and `print` line with these two:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We don't need to use `getlist()` anymore, as `cleaned_data` has already converted
    the multi-value fields into `list` instances.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Start the Django dev server, if it is not already running. Switch to your browser
    and browse to the example form page at `http://127.0.0.1:8000/form-example/`.
    The form should look as it did before. Fill in all the fields, but be sure to
    enter four or more numbers into the `Decimal input` field to make the form invalid.
    Submit the form, and you should see the error message for `Decimal input` show
    up when the page refreshes:![Figure 6.28: Decimal input error displayed after
    the form is submitted'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15509_06_28.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 6.28: Decimal input error displayed after the form is submitted'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Fix the form errors by making sure only three digits are in the `Decimal input`
    field, then submit the form again. Switch back to PyCharm and check the debug
    console. You should see that all the cleaned data has been printed out:![Figure
    6.29: Cleaned data from the form printed out'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15509_06_29.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 6.29: Cleaned data from the form printed out'
  prefs: []
  type: TYPE_NORMAL
- en: Notice the conversions that have taken place. The `CharField` instances have
    been converted to `str`, `BooleanField` to `bool`, and `IntegerField`, `FloatField`,
    and `DecimalField` to `int`, `float`, and `Decimal`, respectively. `DateField`
    becomes `datetime.date` and the choice fields retain the string values of their
    initial choice values. Notice that `books_you_own` is automatically converted
    to a `list` of `str` instances.
  prefs: []
  type: TYPE_NORMAL
- en: Also, note that unlike when we iterated over all of the `POST` data, `cleaned_data`
    only contains form fields. The other data (such as the CSRF token and the submit
    button that was clicked) is present in the `POST` `QueryDict` but is not included
    as it does not include form fields.
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you updated `ExampleForm` so the browser allowed it to be
    submitted even though Django would consider it to be invalid. This allowed Django
    to perform its validation on the form. You then updated the `form_example` view
    to instantiate the `ExampleForm` class differently depending on the HTTP method;
    passing in the request's `POST` data for a `POST` request. The view also had its
    debug output code updated to `print` out the `cleaned_data` dictionary. Finally,
    you tested submitting valid and invalid form data to see the different execution
    paths and the types of data that the form generated. We saw that Django automatically
    converted the `POST` data from strings to Python types based on the field class.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will look at how to add more validation options to fields, which will
    allow us to more tightly control the values that can be entered.
  prefs: []
  type: TYPE_NORMAL
- en: Built-In Field Validation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have not yet discussed the standard validation arguments that can be used
    on fields. Although we already mentioned the `required` argument (which is `True`
    by default), many others can be used to more tightly control the data being entered
    into a field. Here are a few useful ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '`max_length`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sets the maximum number of characters that can be entered into the field; available
    on `CharField` (and `FileField`, which we will cover in *Chapter 8*, *Media Serving
    and File Uploads*).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`min_length`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sets the minimum number of characters that must be entered into the field; available
    on `CharField` (and `FileField`; again, more about this in *Chapter 8*, *Media
    Serving and File Uploads*).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`max_value`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sets the maximum value that can be entered into a numeric field; available on
    `IntegerField`, `FloatField`, and `DecimalField`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`min_value`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sets the minimum value that can be entered into a numeric field; available on
    `IntegerField`, `FloatField`, and `DecimalField`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`max_digits`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This sets the maximum number of digits that can be entered; this includes digits
    before and after a decimal point (if one exists). For example, the number *12.34*
    has four digits, and the number *56.7* has three. Used in `DecimalField`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`decimal_places`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This sets the maximum number of digits that can be after the decimal point.
    This is used in conjunction with `max_digits`, and the number of decimal places
    will always count toward the number of digits even if that number of decimals
    has not been entered after the decimal place. For example, imagine using `max_digits`
    of four and `decimal_places` of three: if the number *12.34* was entered, it would
    actually be interpreted as the value *12.340*; that is, zeros are appended until
    the number of digits after the decimal point is equal to the `decimal_places`
    setting. Since we set three as the value for `decimal_places`, the total number
    of digits ends up being five, which exceeds the `max_digits` setting of four.
    The number *1.2* would be valid since even after expanding to *1.200*, the total
    number of digits is only four.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can mix and match the validation rules (provided that the fields support
    them). `CharField` can have `max_length` and `min_length`, numeric fields can
    have both `min_value` and `max_value`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: If you need more validation options, you can write custom validators, which
    we will cover in the next section. Right now, we will add some validators to our
    `ExampleForm` to see them in action.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 6.05: Adding Extra Field Validation'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will add and modify the validation rules for the fields
    of `ExampleForm`. We will then see how these changes affect how the form behaves,
    both in the browser and when Django validates the form:'
  prefs: []
  type: TYPE_NORMAL
- en: In PyCharm, open the `forms.py` file inside the `form_example` app directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will make `text_input` require at most three characters. Add a `max_length=3`
    argument to the `CharField` constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make `password_input` more secure by requiring a minimum of eight characters.
    Add a `min_length=8` argument to the `CharField` constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The user may have no books, so the `books_you_own` field should not be required.
    Add a `required=False` argument to the `MultipleChoiceField` constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The user should only be able to enter a value between 1 and 10 in `integer_input`.
    Add `min_value=1` and `max_value=10` arguments to the `IntegerField` constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, add `max_digits=5` and `decimal_places=3` to the `DecimalField` constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Start the Django dev server if it''s not already running. We do not have to
    make any changes to any other files to get these new validation rules, since Django
    automatically updates the HTML generation and validation logic. This is a great
    benefit you get from using Django forms. Just visit or refresh `http://127.0.0.1:8000/form-example/`
    in your browser and the new validation will be automatically added. The form should
    not look any different until you try to submit it with incorrect values, in which
    case your browser can automatically show errors. Some things to try are as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter more than three characters into the `Text input` field; you will not be
    able to.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Type fewer than eight characters into the `Password` field then click away from
    it. The browser should show an error indicating that this is not valid.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Do not select any values for the `Books you own` field. This will not prevent
    you from submitting the form anymore.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Use the stepper buttons on `Integer input`. You will only be able to enter a
    value between `1` and `10`. If you type in a value outside this range, your browser
    should show an error.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Decimal input` is the only field that does not validate the Django rules in
    the browser. You will need to type in an invalid value (such as `123.456`) and
    submit the form before an error (generated by Django) is displayed.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following figure shows some of the fields that the browser can validate
    itself:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.30: Browser performing validation with the new rules'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15509_06_30.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 6.30: Browser performing validation with the new rules'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 6.31* shows an error that can only be generated by Django as the browser
    does not understand the `DecimalField` validation rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.31: The browser considers the form valid, but Django does not'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_06_31.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.31: The browser considers the form valid, but Django does not'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we implemented some basic validation rules on our form fields.
    We then loaded the form example page in the browser, without having to make any
    changes to our template or view. We tried to submit the form with different values
    to see how the browser can validate the form compared to Django.
  prefs: []
  type: TYPE_NORMAL
- en: In the activity for this chapter, we will implement the Book Search view using
    a Django form.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 6.01: Book Searching'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this activity, you will finish the Book Search view that was started in *Chapter
    1*, *Introduction to Django*. You will build a `SearchForm` instance that submits
    and accepts a search string from `request.GET`. It will have a `select` field
    to choose to search for `title` or `contributor`. It will then search for all
    `Book` instances containing the given text in `title` or in `first_names` or `last_names`
    of `Contributor`. You will then render this list of books in the `search-results.html`
    template. The search term should not be required, but if it exists, it should
    have a length of three or fewer characters. Since the view will search even when
    using the `GET` method, the form will always have its validation checked. If we
    made the field `required`, it would always show an error whenever the page loads.
  prefs: []
  type: TYPE_NORMAL
- en: There will be two ways of performing the search. The first is by submitting
    the search form that is in the `base.html` template and thus in the top-right
    corner of every page. This will only search through `Book` titles. The other method
    is by submitting a `SearchForm` instance that is rendered on the `search-results.html`
    page. This form will display the `ChoiceField` instance for choosing between `title`
    or `contributor` search.
  prefs: []
  type: TYPE_NORMAL
- en: 'These steps will help you complete this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `SearchForm` instance in your `forms.py` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`SearchForm` should have two fields. The first is a `CharField` instance with
    the name `search`. This field should not be required but should have a minimum
    length of `3`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second field on `SearchForm` is a `ChoiceField` instance named `search_in`.
    This will allow selecting between `title` and `contributor` (with `Title` and
    `Contributor` labels, respectively). It should not be `required`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the `book_search` view to instantiate a `SearchForm` instance using data
    from `request.GET`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add code to search for `Book` models using `title__icontains` (for case-insensitive
    searching). This should be done if searching by `title`. The search should only
    be performed if the form is valid and contains some search text. The `search_in`
    value should be retrieved from `cleaned_data` using the `get` method since it
    might not exist, as it's not required. Set its default to `title`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When searching for contributors, use `first_names__icontains` or `last_names__icontains`,
    then iterate the contributors and retrieve the books for each contributor. This
    should be done if searching by `contributor`. The search should only be performed
    if the form is valid and contains some search text. There are many ways to combine
    the search results for a first or last name. The easiest method, using the techniques
    that you have been introduced to so far, is to perform two queries, one for matching
    first names and then for last names, and iterating them separately.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the `render` call to include the `form` variable and the books that were
    retrieved in the context (as well as `search_text` that was already being passed).
    The location of the template was changed in *Chapter 3*, *URL Mapping, Views,
    and Templates*, so update the second argument to `render` accordingly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `search-results.html` template we created in *Chapter 1*, *Introduction
    to Django*, is essentially redundant now, so you can clear its content. Update
    the `search-results.html` file to extend from `base.html` instead of being a standalone
    template file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `title` block that will display `Search Results for <search_text>` if
    the form is valid and `search_text` was set and will otherwise just display `Book
    Search`. This block will also be added to `base.html` later in this activity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `content` block, which should show an `<h2>` heading with the text `Search
    for Books`. Under the `<h2>` heading, render the form. The `<form>` element can
    have no attributes and it will default to making a `GET` request to the same URL
    that it's on. Add a submit button as we have used in previous activities, with
    the `btn btn-primary` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under the form, show a `Search results for <search_text>` message if the form
    is valid and search text was entered, otherwise show no message. This should be
    displayed in an `<h3>` heading, and the search text should be wrapped in `<em>`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Iterate over the search results and render each one. Show the book title and
    contributor's first and last names. The book title should link to the `book_detail`
    page. If the books list is empty, show the text `No results found`. You should
    wrap the results in `<ul>` with `class` `list-group`, and each result should be
    an `<li>` instance with `class` `list-group-item`. This will be similar to the
    `book_list` page; however, we won't show as much information (just the title and
    contributors).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update `base.html` to include an action attribute in the search `<form>` tag.
    Use the `url` template tag to generate the URL for this attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `name` attribute of the search field to `search` and the `value` attribute
    to the search text that was entered. Also, ensure that the minimum length of the
    field is `3`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `base.html`, add a `title` block to the `title` tag that was overridden by
    other templates (as in *step 9*). Add a `block` template tag inside the `<title>`
    HTML element. It should have the content `Bookr`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After completing this activity, you should be able to open the Book Search
    page at `http://127.0.0.1:8000/book-search/` and it will look like *Figure 6.32*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.32: Book Search page without a search'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_06_32.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.32: Book Search page without a search'
  prefs: []
  type: TYPE_NORMAL
- en: When searching for something using just two characters, your browser should
    prevent you from submitting either of the search fields. If you search for something
    that returns no results, you will see a message that there were no results. Searching
    by title (this can be done with either field) will show matching results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, when searching by the contributor (although this can only be done
    in the lower form), you should see something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.33: A contributor search'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_06_33.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.33: A contributor search'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this activity can be found at [http://packt.live/2Nh1NTJ](http://packt.live/2Nh1NTJ).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter was an introduction to forms in Django. We introduced some HTML
    inputs for entering data onto a web page. We talked about how data is submitted
    to a web application and when to use `GET` and `POST` requests. We then looked
    at how Django's form classes can make generating the form HTML simpler, as well
    as allowing the automatic building of forms using models. We enhanced Bookr some
    more by building the book search functionality.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will go deeper into forms and learn how to customize
    the display of form fields, how to add more advanced validation to your form,
    and how to automatically save model instances by using the `ModelForm` class.
  prefs: []
  type: TYPE_NORMAL
