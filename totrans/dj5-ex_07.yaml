- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tracking User Actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you built a JavaScript bookmarklet to share content
    from other websites on your platform. You also implemented asynchronous actions
    with JavaScript in your project and created an infinite scroll.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to build a follow system and create a user
    activity stream. You will also discover how Django signals work and you will integrate
    Redis’s fast I/O storage into your project to store item views.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: Building a follow system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating many-to-many relationships with an intermediate model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an activity stream application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding generic relations to models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing QuerySets for related objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using signals for denormalizing counts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Django Debug Toolbar to obtain relevant debug information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Counting image views with Redis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a ranking of the most viewed images with Redis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Figure 7.1* shows a representation of the views, templates, and functionalities
    that will be built in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_07_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.1: Diagram of functionalities built in Chapter 7'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will build the `user_list` view to list all users and the
    `user_detail` view to display a single user profile. You will implement a follow
    system with JavaScript, using the `user_follow` view to store user follows. You
    will create a system to store user actions, and you will implement the actions
    for creating an account, following a user, creating an image, and liking an image.
    You will use this system to display an activity stream in the `dashboard` view
    with the latest actions. You will also use Redis to store a *view* every time
    the `image_detail` view is loaded and create the view `image_ranking` to display
    a ranking of the most viewed images.
  prefs: []
  type: TYPE_NORMAL
- en: The source code for this chapter can be found at [https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter07](https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter07).
  prefs: []
  type: TYPE_NORMAL
- en: All Python packages used in this chapter are included in the `requirements.txt`
    file in the source code for the chapter. You can follow the instructions to install
    each Python package in the following sections, or you can install all requirements
    at once with the command `python` `-m` `pip` `install` `-r` `requirements.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: Building a follow system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s build a follow system in your project. This means that your users will
    be able to follow each other and track what other users share on the platform.
    The relationship between users is a *many-to-many* relationship; this means that
    a user can follow multiple users and they, in turn, can be followed by multiple
    users.
  prefs: []
  type: TYPE_NORMAL
- en: Creating many-to-many relationships with an intermediate model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In previous chapters, you created many-to-many relationships by adding the `ManyToManyField`
    to one of the related models and letting Django create the database table for
    the relationship. This is suitable for most cases, but sometimes you may need
    to create an intermediate model for the relationship. Creating an intermediate
    model is necessary when you want to store additional information on the relationship,
    for example, the date when the relationship was created, or a field that describes
    the nature of the relationship.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create an intermediate model to build relationships between users. There
    are two reasons for using an intermediate model:'
  prefs: []
  type: TYPE_NORMAL
- en: You are using the `User` model provided by Django and you want to avoid altering
    it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You want to store the time when the relationship was created
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Edit the `models.py` file of the `account` application and add the following
    code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code shows the `Contact` model that you will use for user relationships.
    It contains the following fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`user_from`: A `ForeignKey` for the user who creates the relationship'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`user_to`: A `ForeignKey` for the user being followed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`created`: A `DateTimeField` field with `auto_now_add=True` to store the time
    when the relationship was created'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A database index is automatically created on the `ForeignKey` fields. In the
    `Meta` class of the model, we have defined a database index in descending order
    for the `created` field. We have also added the `ordering` attribute to tell Django
    that it should sort results by the `created` field by default. We indicate descending
    order by using a hyphen before the field name, like `-created`.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 7.2* shows the intermediate `Contact` model and its corresponding database
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_07_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.2: The intermediate Contact model and its database table'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the ORM, you could create a relationship for a user, `user1`, following
    another user, `user2`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The related managers, `rel_from_set` and `rel_to_set`, will return a QuerySet
    for the `Contact` model. In order to access the end side of the relationship from
    the `User` model, it would be desirable for `User` to contain a `ManyToManyField`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, you tell Django to use your custom intermediate model
    for the relationship by adding `through=Contact` to `ManyToManyField`. This is
    a many-to-many relationship from the `User` model to itself; you refer to `'self'`
    in `ManyToManyField` to create a relationship to the same model.
  prefs: []
  type: TYPE_NORMAL
- en: When you need additional fields in a many-to-many relationship, create a custom
    model with a `ForeignKey` for each side of the relationship. You can manage the
    relationship using the intermediate model, or you can add a `ManyToManyField`
    field in one of the related models and indicate to Django that your intermediate
    model should be used by including it in the `through` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: If the `User` model was part of your application, you could add the previous
    field to the model. However, you can’t alter the `User` class directly because
    it belongs to the `django.contrib.auth` application. Let’s take a slightly different
    approach by adding this field dynamically to the `User` model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `models.py` file of the `account` application and add the following
    lines highlighted in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, you retrieve the user model with the generic function
    `get_user_model()` provided by Django. You use the `add_to_class()` method of
    Django models to monkey patch the `User` model.
  prefs: []
  type: TYPE_NORMAL
- en: Be mindful that using `add_to_class()` is not the recommended way of adding
    fields to models. However, you can take advantage of using it in this case to
    avoid creating a custom user model, keeping all the advantages of Django’s built-in
    `User` model.
  prefs: []
  type: TYPE_NORMAL
- en: You also simplify the way that you retrieve related objects using the Django
    ORM with `user.followers.all()` and `user.following.all()`. You use the intermediate
    `Contact` model and avoid complex queries that would involve additional database
    joins, as would have been the case had you defined the relationship in your custom
    `Profile` model. The table for this many-to-many relationship will be created
    using the `Contact` model. Thus, the `ManyToManyField`, added dynamically, will
    not imply any database changes for the Django `User` model.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that, in most cases, it is preferable to add fields to the `Profile`
    model you created before, instead of monkey patching the `User` model. Ideally,
    you shouldn’t alter the existing Django `User` model. Django allows you to use
    custom user models. If you want to use a custom user model, take a look at the
    documentation at [https://docs.djangoproject.com/en/5.0/topics/auth/customizing/#specifying-a-custom-user-model](https://docs.djangoproject.com/en/5.0/topics/auth/customizing/#specifying-a-custom-user-model).
  prefs: []
  type: TYPE_NORMAL
- en: When you start a new project, it is highly recommended that you create a custom
    user model, even if the default `User` model is sufficient for you. This is because
    you gain the option of customizing the model.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the relationship includes `symmetrical=False`. When you define a `ManyToManyField`
    in the model creating a relationship with itself, Django forces the relationship
    to be symmetrical. In this case, you are setting `symmetrical=False` to define
    a non-symmetrical relationship (if I follow you, it doesn’t mean that you automatically
    follow me).
  prefs: []
  type: TYPE_NORMAL
- en: When you use an intermediate model for many-to-many relationships, some of the
    related manager’s methods are disabled, such as `add()`, `create()`, or `remove()`.
    You need to create or delete instances of the intermediate model instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to generate the initial migrations for the `account`
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You will obtain an output like the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the following command to sync the application with the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see an output that includes the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `Contact` model is now synced to the database, and you are able to create
    relationships between users. However, your site doesn’t offer a way to browse
    users or see a particular user’s profile yet. Let’s build the list and detail
    views for the `User` model.
  prefs: []
  type: TYPE_NORMAL
- en: Creating list and detail views for user profiles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open the `views.py` file of the `account` application and add the following
    code highlighted in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: These are simple list and detail views for `User` objects. We retrieve the `User`
    model dynamically using the `get_user_model()` function. The `user_list` view
    gets all active users. The Django `User` model contains an `is_active` flag to
    designate whether the user account is considered active. You filter the query
    by `is_active=True` to return only active users. This view returns all results,
    but you can improve it by adding pagination in the same way as you did for the
    `image_list` view.
  prefs: []
  type: TYPE_NORMAL
- en: The `user_detail` view uses the `get_object_or_404()` shortcut to retrieve the
    active user with the given username. The view returns an HTTP `404` response if
    no active user with the given username is found.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `urls.py` file of the `account` application and add a URL pattern
    for each view, as follows. The new code is highlighted in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: You will use the `user_detail` URL pattern to generate the canonical URL for
    users. You have already defined a `get_absolute_url()` method in a model to return
    the canonical URL for each object. Another way to specify the URL for a model
    is by adding the `ABSOLUTE_URL_OVERRIDES` setting to your project.
  prefs: []
  type: TYPE_NORMAL
- en: By using the username instead of the user ID in the `user_detail` URL pattern,
    you enhance both usability and security. Usernames, unlike sequential IDs, thwart
    enumeration attacks by obscuring your data structure. This makes it harder for
    attackers to predict URLs and formulate attack vectors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `settings.py` file of your project and add the following code highlighted
    in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Django adds a `get_absolute_url()` method dynamically to any models that appear
    in the `ABSOLUTE_URL_OVERRIDES` setting. This method returns the corresponding
    URL for the given model specified in the setting. In the previous code section,
    you generate the `user_detail` URL for the given user for the `auth.user` object.
    Now, you can use `get_absolute_url()` on a `User` instance to retrieve its corresponding
    URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the Python shell with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then run the following code to test it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The returned URL follows the expected format, `/account/users/<username>/`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will need to create templates for the views that you just built. Add the
    following directory and files to the `templates/account/` directory of the `account`
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit the `account/user/list.html` template and add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The preceding template allows you to list all the active users on the site.
    You iterate over the given users and use the `{% thumbnail %}` template tag from
    `easy-thumbnails` to generate profile image thumbnails.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the users need to have a profile image. To use a default image for
    users that don’t have a profile image, you can add an `if`/`else` statement to
    check whether the user has a profile photo, like `{% if user.profile.photo %}
    {# photo thumbnail #} {% else %} {# default image #} {% endif %}`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `base.html` template of your project and include the `user_list` URL
    in the `href` attribute of the following menu item. The new code is highlighted
    in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Start the development server with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Open `http://127.0.0.1:8000/account/users/` in your browser. You should see
    a list of users like the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, website  Description automatically generated](img/B21088_07_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.3: The user list page with profile image thumbnails'
  prefs: []
  type: TYPE_NORMAL
- en: Remember that if you have any difficulty generating thumbnails, you can add
    `THUMBNAIL_DEBUG = True` to your `settings.py` file in order to obtain debug information
    in the shell.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `account/user/detail.html` template of the `account` application and
    add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Make sure that no template tag is split into multiple lines; Django doesn’t
    support multiple-line tags.
  prefs: []
  type: TYPE_NORMAL
- en: In the `detail` template, the user profile is displayed, and the `{% thumbnail
    %}` template tag is used to show the profile image. The total number of followers
    is presented along with a link to follow or unfollow the user. This link will
    be used to follow/unfollow a particular user. The `data-id` and `data-action`
    attributes of the `<a>` HTML element contain the user ID and the initial action
    to perform when the link element is clicked – `follow` or `unfollow`. The initial
    action (*follow* or *unfollow*) depends on whether the user requesting the page
    is already a follower of the user. The images bookmarked by the user are displayed
    by including the `images/image/list_images.html` template.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your browser again and click on a user who has bookmarked some images.
    The user page will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application, website  Description automatically
    generated](img/B21088_07_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.4: The user detail page'
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding image is of *Chick Corea* by ataelw (Creative Commons Attribution
    2.0 Generic license: [https://creativecommons.org/licenses/by/2.0/](https://creativecommons.org/licenses/by/2.0/)).'
  prefs: []
  type: TYPE_NORMAL
- en: Adding user follow/unfollow actions with JavaScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s add functionality to follow/unfollow users. We will create a new view
    to follow/unfollow users and implement an asynchronous HTTP request with JavaScript
    for the follow/unfollow action.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `views.py` file of the `account` application and add the following
    code highlighted in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `user_follow` view is quite similar to the `image_like` view that you created
    in *Chapter 6*, *Sharing Content on Your Website*. Since you are using a custom
    intermediate model for the user’s many-to-many relationship, the default `add()`
    and `remove()` methods of the automatic manager of `ManyToManyField` are not available.
    Instead, the intermediate `Contact` model is used to create or delete user relationships.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `urls.py` file of the `account` application and add the following
    URL pattern highlighted in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Ensure that you place the preceding pattern before the `user_detail` URL pattern.
    Otherwise, any requests to `/users/follow/` will match the regular expression
    of the `user_detail` pattern and that view will be executed instead. Remember
    that in every HTTP request, Django checks the requested URL against each pattern
    in order of appearance and stops at the first match.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `user/detail.html` template of the `account` application and append
    the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The preceding template block contains the JavaScript code to perform the asynchronous
    HTTP request to follow or unfollow a particular user and also to toggle the follow/unfollow
    link.
  prefs: []
  type: TYPE_NORMAL
- en: The Fetch API is used to perform the AJAX request and set both the `data-action`
    attribute and the text of the HTML `<a>` element based on its previous value.
    When the action is completed, the total number of followers displayed on the page
    is updated as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the user detail page of an existing user and click on the **FOLLOW** link
    to test the functionality you just built. You will see, on the left-hand side
    of the following image, that the followers count has increased:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_07_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.5: The followers count and follow/unfollow button'
  prefs: []
  type: TYPE_NORMAL
- en: The follow system is now complete and users can follow each other. Next, we
    will build an activity stream creating relevant content for each user that is
    based on the people they follow.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an activity stream application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many social websites display an activity stream to their users so that they
    can track what other users do on the platform. An activity stream is a list of
    recent activities performed by a user or a group of users. For example, Facebook’s
    News Feed is an activity stream. Sample actions can be *user X bookmarked image
    Y* or *user X is now following user Y*.
  prefs: []
  type: TYPE_NORMAL
- en: You are going to build an activity stream application so that every user can
    see the recent interactions of the users they follow. To do so, you will need
    a model to save the actions performed by users on the website and a simple way
    to add actions to the feed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new application named `actions` inside your project with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the new application to `INSTALLED_APPS` in the `settings.py` file of your
    project to activate the application in your project. The new line is highlighted
    in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit the `models.py` file of the `actions` application and add the following
    code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code shows the `Action` model that will be used to store user
    activities. The fields of this model are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`user`: The user who performed the action; this is a `ForeignKey` to the `AUTH_USER_MODEL`,
    by default, the Django `User` model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`verb`: The verb describing the action that the user has performed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`created`: The date and time when this action was created. We use `auto_now_add=True`
    to automatically set this to the current datetime when the object is saved for
    the first time in the database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `Meta` class of the model, we have defined a database index in descending
    order for the `created` field. We have also added the `ordering` attribute to
    tell Django that it should sort results by the `created` field in descending order
    by default.
  prefs: []
  type: TYPE_NORMAL
- en: With this basic model, you can only store actions such as *user X did something*.
    You need an extra `ForeignKey` field to save actions that involve a `target` object,
    such as *user X bookmarked image Y* or *user X is now following user Y*. As you
    already know, a normal `ForeignKey` can point to only one model. Instead, you
    will need a way for the action’s `target` object to be an instance of an existing
    model. This is what the Django `contenttypes` framework will help you to do.
  prefs: []
  type: TYPE_NORMAL
- en: Using the contenttypes framework
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Django includes a `contenttypes` framework located at `django.contrib.contenttypes`.
    This application can track all models installed in your project and provides a
    generic interface to interact with your models.
  prefs: []
  type: TYPE_NORMAL
- en: The `django.contrib.contenttypes` application is included in the `INSTALLED_APPS`
    setting by default when you create a new project using the `startproject` command.
    It is used by other `contrib` packages, such as the authentication framework and
    the administration application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `contenttypes` application contains a `ContentType` model. Instances of
    this model represent the actual models of your application, and new instances
    of `ContentType` are automatically created when new models are installed in your
    project. The `ContentType` model has the following fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`app_label`: This indicates the name of the application that the model belongs
    to. This is automatically taken from the `app_label` attribute of the model `Meta`
    options. For example, your `Image` model belongs to the `images` application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`model`: The name of the model class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name`: This is a property that indicates the human-readable name of the model,
    automatically generated from the `verbose_name` attribute of the model `Meta`
    options.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s take a look at how you can interact with `ContentType` objects. Open
    the shell using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'You can obtain the `ContentType` object corresponding to a specific model by
    performing a query with the `app_label` and `model` attributes, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also retrieve the model class from a `ContentType` object by calling
    its `model_class()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s also common to obtain the `ContentType` object for a particular model
    class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: These are just some examples of using `contenttypes`. Django offers more ways
    to work with them. You can find the official documentation for the `contenttypes`
    framework at [https://docs.djangoproject.com/en/5.0/ref/contrib/contenttypes/](https://docs.djangoproject.com/en/5.0/ref/contrib/contenttypes/).
  prefs: []
  type: TYPE_NORMAL
- en: Adding generic relations to your models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In generic relations, `ContentType` objects play the role of pointing to the
    model used for the relationship. You will need three fields to set up a generic
    relation in a model:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A `ForeignKey` field to `ContentType`: This will tell you what the model for
    the relationship is'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A field to store the primary key of the related object: This will usually be
    a `PositiveIntegerField` to match Django’s automatic primary key fields'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A field to define and manage the generic relation using the two previous fields:
    The `contenttypes` framework offers a `GenericForeignKey` field for this purpose'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Edit the `models.py` file of the `actions` application and add the following
    code highlighted in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We have added the following fields to the `Action` model:'
  prefs: []
  type: TYPE_NORMAL
- en: '`target_ct`: A `ForeignKey` field that points to the `ContentType` model'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`target_id`: A `PositiveIntegerField` for storing the primary key of the related
    object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`target`: A `GenericForeignKey` field to the related object based on the combination
    of the two previous fields'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have also added a multiple-field index including the `target_ct` and `target_id`
    fields.
  prefs: []
  type: TYPE_NORMAL
- en: Django does not create `GenericForeignKey` fields in the database. The only
    fields that are mapped to database fields are `target_ct` and `target_id`. Both
    fields have `blank=True` and `null=True` attributes so that a `target` object
    is not required when saving `Action` objects.
  prefs: []
  type: TYPE_NORMAL
- en: You can make your applications more flexible by using generic relations instead
    of foreign keys. Generic relations allow you to associate models in a non-exclusive
    manner, enabling a single model to relate to multiple other models.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 7.6* shows the `Action` model, including the relationship with the
    `ContentType` model of the `contenttypes` Django contrib package:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_07_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.6: The Action model and the ContentType model'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to create initial migrations for this application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, run the next command to sync the application with the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the command should indicate that the new migrations have been
    applied, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s add the `Action` model to the administration site. Edit the `admin.py`
    file of the `actions` application and add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: You just registered the `Action` model on the administration site.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start the development server with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Open `http://127.0.0.1:8000/admin/actions/action/add/` in your browser. You
    should see the page for creating a new `Action` object, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_07_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.7: The Add action page on the Django administration site'
  prefs: []
  type: TYPE_NORMAL
- en: As you will notice in the preceding screenshot, only the `target_ct` and `target_id`
    fields that are mapped to actual database fields are shown. The `GenericForeignKey`
    field does not appear in the form. The `target_ct` field allows you to select
    any of the registered models of your Django project. You can restrict the content
    types to choose from a limited set of models using the `limit_choices_to` attribute
    in the `target_ct` field; the `limit_choices_to` attribute allows you to restrict
    the content of `ForeignKey` fields to a specific set of values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file inside the `actions` application directory and name it `utils.py`.
    You need to define a shortcut function that will allow you to create new `Action`
    objects in a simple way. Edit the new `utils.py` file and add the following code
    to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The `create_action()` function allows you to create actions that optionally
    include a `target` object. You can use this function anywhere in your code as
    a shortcut to add new actions to the activity stream.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding duplicate actions in the activity stream
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, your users might click several times on the **Like** or **Unlike**
    button or perform the same action multiple times in a short period of time. This
    will easily lead to storing and displaying duplicate actions. To avoid this, let’s
    improve the `create_action()` function to skip obvious duplicated actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `utils.py` file of the `actions` application, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'You have changed the `create_action()` function to avoid saving duplicate actions
    and return a Boolean to tell you whether the action was saved. This is how you
    avoid duplicates:'
  prefs: []
  type: TYPE_NORMAL
- en: First, you get the current time using the `timezone.now()` method provided by
    Django. This method does the same as `datetime.datetime.now()` but returns a timezone-aware
    object. Django provides a setting called `USE_TZ` to enable or disable timezone
    support. The default `settings.py` file created using the `startproject` command
    includes `USE_TZ=True`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You use the `last_minute` variable to store the datetime from one minute ago
    and retrieve any identical actions performed by the user since then.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You create an `Action` object if no identical action already exists in the last
    minute. You return `True` if an `Action` object was created or `False` otherwise.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding user actions to the activity stream
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It’s time to add some actions to your views to build the activity stream for
    your users. You will store an action for each of the following interactions:'
  prefs: []
  type: TYPE_NORMAL
- en: A user bookmarks an image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A user likes an image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A user creates an account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A user starts following another user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Edit the `views.py` file of the `images` application and add the following
    import:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `image_create` view, add `create_action()` after saving the image, as
    follows. The new line is highlighted in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `image_like` view, add `create_action()` after adding the user to the
    `users_like` relationship, as follows. The new line is highlighted in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, edit the `views.py` file of the `account` application and add the following
    import:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `register` view, add `create_action()` after creating the `Profile`
    object, as follows. The new line is highlighted in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `user_follow` view, add `create_action()`, as follows. The new line
    is highlighted in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding code, thanks to the `Action` model and the helper
    function, it’s very easy to save new actions to the activity stream.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying the activity stream
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally, you need a way to display the activity stream for each user. You will
    include the activity stream on the user’s dashboard. Edit the `views.py` file
    of the `account` application. Import the `Action` model and modify the `dashboard`
    view, as follows. The new code is highlighted in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding view, you retrieve all actions from the database, excluding
    the ones performed by the current user. By default, you retrieve the latest actions
    performed by all users on the platform.
  prefs: []
  type: TYPE_NORMAL
- en: If the user is following other users, you restrict the query to retrieve only
    the actions performed by the users they follow. Finally, you limit the result
    to the first 10 actions returned. You don’t use `order_by()` in the QuerySet because
    you rely on the default ordering that you provided in the `Meta` options of the
    `Action` model. Recent actions will come first since you set `ordering = ['-created']`
    in the `Action` model.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing QuerySets that involve related objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every time you retrieve an `Action` object, you will usually access its related
    `User` object and the user’s related `Profile` object. The Django ORM offers a
    simple way to retrieve related objects at the same time, thereby avoiding additional
    queries to the database.
  prefs: []
  type: TYPE_NORMAL
- en: Using select_related()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Django offers a QuerySet method called `select_related()` that allows you to
    retrieve related objects for one-to-many relationships. This translates to a single,
    more complex QuerySet, but you avoid additional queries when accessing the related
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: The `select_related` method is for `ForeignKey` and `OneToOne` fields. It works
    by performing a SQL `JOIN` and including the fields of the related object in the
    `SELECT` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'To take advantage of `select_related()`, edit the following line of the preceding
    code in the `views.py` file of the account application to add `select_related`,
    including the fields that you will use, as follows. Edit the `views.py` file of
    the account application. The new code is highlighted in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: You use `user__profile` to join the `Profile` table in a single SQL query. If
    you call `select_related()` without passing any arguments to it, it will retrieve
    objects from all `ForeignKey` relationships. Always limit `select_related()` to
    the relationships that will be accessed afterward.
  prefs: []
  type: TYPE_NORMAL
- en: Using `select_related()` carefully can vastly improve execution time.
  prefs: []
  type: TYPE_NORMAL
- en: Using prefetch_related()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`select_related()` will help you boost the performance for retrieving related
    objects in one-to-many relationships. However, `select_related()` doesn’t work
    for many-to-many or many-to-one relationships (`ManyToMany` or reverse `ForeignKey`
    fields). Django offers a different QuerySet method called `prefetch_related` that
    works for many-to-many and many-to-one relationships in addition to the relationships
    supported by `select_related()`. The `prefetch_related()` method performs a separate
    lookup for each relationship and joins the results using Python. This method also
    supports the prefetching of `GenericRelation` and `GenericForeignKey`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `views.py` file of the `account` application and complete your query
    by adding `prefetch_related()` to it for the target `GenericForeignKey` field,
    as follows. The new code is highlighted in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This query is now optimized for retrieving the user actions, including related
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: Creating templates for actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s now create the template to display a particular `Action` object. Create
    a new directory inside the `actions` application directory and name it `templates`.
    Add the following file structure to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit the `actions/action/detail.html` template file and add the following lines
    to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This is the template used to display an `Action` object. First, you use the
    `{% with %}` template tag to retrieve the user performing the action and the related
    `Profile` object. Then, you display the image of the `target` object if the `Action`
    object has a related `target` object. Finally, you display the link to the user
    who performed the action, the verb, and the `target` object, if any.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `account/dashboard.html` template of the `account` application and
    append the following code highlighted in bold to the bottom of the `content` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Open `http://127.0.0.1:8000/account/` in your browser. Log in as an existing
    user and perform several actions so that they get stored in the database. Then,
    log in using another user, follow the previous user, and take a look at the generated
    action stream on the dashboard page.
  prefs: []
  type: TYPE_NORMAL
- en: 'It should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application, chat or text message  Description
    automatically generated](img/B21088_07_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.8: The activity stream for the current user'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 7.8* image attributions*:*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Tesla’s induction motor* by Ctac(license – Creative Commons Attribution Share-Alike
    3.0 Unported:[https://creativecommons.org/licenses/by-sa/3.0/](https://creativecommons.org/licenses/by-sa/3.0/))'
  prefs: []
  type: TYPE_NORMAL
- en: '*Turing Machine Model Davey 2012* by Rocky Acosta(license – Creative Commons
    Attribution 3.0 Unported: [https://creativecommons.org/licenses/by/3.0/](https://creativecommons.org/licenses/by/3.0/))'
  prefs: []
  type: TYPE_NORMAL
- en: '*Chick Corea* by ataelw (license – Creative Commons Attribution 2.0 Generic:
    [https://creativecommons.org/licenses/by/2.0/](https://creativecommons.org/licenses/by/2.0/))'
  prefs: []
  type: TYPE_NORMAL
- en: You just created a complete activity stream for your users, and you can easily
    add new user actions to it. You can also add infinite scroll functionality to
    the activity stream by implementing the same AJAX paginator that you used for
    the `image_list` view. Next, you will learn how to use Django signals to denormalize
    action counts.
  prefs: []
  type: TYPE_NORMAL
- en: Using signals for denormalizing counts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are some cases when you may want to denormalize your data. Denormalization
    is making data redundant in such a way that it optimizes read performance. For
    example, you might be copying related data to an object to avoid expensive read
    queries to the database when retrieving the related data. You have to be careful
    about denormalization and only start using it when you really need it. The biggest
    issue you will find with denormalization is that it’s difficult to keep your denormalized
    data updated.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at an example of how to improve your queries by denormalizing
    counts. You will denormalize data from your `Image` model and use Django signals
    to keep the data updated.
  prefs: []
  type: TYPE_NORMAL
- en: Working with signals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Django comes with a signal dispatcher that allows receiver functions to get
    notified when certain actions occur. Signals are very useful when you need your
    code to do something every time something else happens. Signals allow you to decouple
    logic: you can capture a certain action, regardless of the application or code
    that triggered that action, and implement logic that gets executed whenever that
    action occurs. For example, you can build a signal receiver function that gets
    executed every time a `User` object is saved. You can also create your own signals
    so that others can get notified when an event happens.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Django provides several signals for models located at `django.db.models.signals`.
    Some of these signals are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pre_save` and `post_save` are sent before or after calling the `save()` method
    of a model'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pre_delete` and `post_delete` are sent before or after calling the `delete()`
    method of a model or QuerySet'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`m2m_changed` is sent when a `ManyToManyField` on a model is changed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are just a subset of the signals provided by Django. You can find a list
    of all built-in signals at [https://docs.djangoproject.com/en/5.0/ref/signals/](https://docs.djangoproject.com/en/5.0/ref/signals/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say you want to retrieve images by popularity. You can use the Django
    aggregation functions to retrieve images ordered by the number of users who like
    them. Remember that you used Django aggregation functions in *Chapter 3*, *Extending
    Your Blog Application*. The following code example will retrieve images according
    to their number of likes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: However, ordering images by counting their total likes is more expensive in
    terms of performance than ordering them by a field that stores total counts. You
    can add a field to the `Image` model to denormalize the total number of likes
    to boost performance in queries that involve this field. The issue is how to keep
    this field updated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `models.py` file of the `images` application and add the following
    `total_likes` field to the `Image` model. The new code is highlighted in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The `total_likes` field will allow you to store the total count of users who
    like each image. Denormalizing counts is useful when you want to filter or order
    QuerySets by them. We have added a database index for the `total_likes` field
    in descending order because we plan to retrieve images ordered by their total
    likes in descending order.
  prefs: []
  type: TYPE_NORMAL
- en: There are several ways to improve performance that you have to take into account
    before denormalizing fields. Consider database indexes, query optimization, and
    caching before starting to denormalize your data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to create the migrations for adding the new field
    to the database table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, run the following command to apply the migration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should include the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: You need to attach a receiver function to the `m2m_changed` signal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file inside the `images` application directory and name it `signals.py`.
    Add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: First, you register the `users_like_changed` function as a receiver function
    using the `receiver()` decorator. You attach it to the `m2m_changed` signal. Then,
    you connect the function to `Image.users_like.through` so that the function is
    only called if the `m2m_changed` signal has been launched by this sender. There
    is an alternate method for registering a receiver function; it consists of using
    the `connect()` method of the `Signal` object.
  prefs: []
  type: TYPE_NORMAL
- en: Django signals are synchronous and blocking. Don’t confuse signals with asynchronous
    tasks. However, you can combine both to launch asynchronous tasks when your code
    gets notified by a signal. You will learn how to create asynchronous tasks with
    Celery in *Chapter 8*, *Building an Online Shop*.
  prefs: []
  type: TYPE_NORMAL
- en: You have to connect your receiver function to a signal so that it gets called
    every time the signal is sent. The recommended method for registering your signals
    is by importing them into the `ready()` method of your application configuration
    class. Django provides an application registry that allows you to configure and
    introspect your applications.
  prefs: []
  type: TYPE_NORMAL
- en: Application configuration classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Django allows you to specify configuration classes for your applications. When
    you create an application using the `startapp` command, Django adds an `apps.py`
    file to the application directory, including a basic application configuration
    that inherits from the `AppConfig` class.
  prefs: []
  type: TYPE_NORMAL
- en: The application configuration class allows you to store metadata and the configuration
    for the application, and it provides introspection for the application. You can
    find more information about application configurations at [https://docs.djangoproject.com/en/5.0/ref/applications/](https://docs.djangoproject.com/en/5.0/ref/applications/).
  prefs: []
  type: TYPE_NORMAL
- en: In order to register your signal receiver functions, when you use the `receiver()`
    decorator, you just need to import the `signals` module of your application inside
    the `ready()` method of the application configuration class. This method is called
    as soon as the application registry is fully populated. Any other initializations
    for your application should also be included in this method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `apps.py` file of the `images` application and add the following code
    highlighted in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: You import the signals for this application in the `ready()` method so that
    they are imported when the `images` application is loaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the development server with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Open your browser to view an image detail page and click on the **Like** button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the administration site, navigate to the edit image URL, such as `http://127.0.0.1:8000/admin/images/image/1/change/`,
    and take a look at the `total_likes` attribute. You should see that the `total_likes`
    attribute is updated with the total number of users who like the image, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface  Description automatically generated](img/B21088_07_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.9: The image edit page on the administration site, including denormalization
    for total likes'
  prefs: []
  type: TYPE_NORMAL
- en: Now, you can use the `total_likes` attribute to order images by popularity or
    display the value anywhere, avoiding using complex queries to calculate it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following query to get images ordered by their likes count in
    descending order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding query can now be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: This results in a less expensive SQL query thanks to denormalizing the total
    likes for images. You have also learned how you can use Django signals.
  prefs: []
  type: TYPE_NORMAL
- en: Use signals with caution since they make it difficult to know the control flow.
    In many cases, you can avoid using signals if you know which receivers need to
    be notified.
  prefs: []
  type: TYPE_NORMAL
- en: You will need to set initial counts for the rest of the `Image` objects to match
    the current status of the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the shell with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the following code in the shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: You have manually updated the likes count for the existing images in the database.
    From now on, the `users_like_changed` signal receiver function will handle updating
    the `total_likes` field whenever the many-to-many related objects change.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you will learn how to use Django Debug Toolbar to obtain relevant debug
    information for requests, including execution time, SQL queries executed, templates
    rendered, signals registered, and much more.
  prefs: []
  type: TYPE_NORMAL
- en: Using Django Debug Toolbar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By this point, you will already be familiar with Django’s debug page. Throughout
    the previous chapters, you have seen the distinctive yellow and gray Django debug
    page several times.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in *Chapter 2*, *Enhancing Your Blog with Advanced Features*, in
    the *Handling pagination errors* section, the debug page showed information related
    to unhandled exceptions when implementing object pagination.
  prefs: []
  type: TYPE_NORMAL
- en: The Django debug page provides useful debug information. However, there is a
    Django application that includes more detailed debug information and can be really
    helpful when developing.
  prefs: []
  type: TYPE_NORMAL
- en: Django Debug Toolbar is an external Django application that allows you to see
    relevant debug information about the current request/response cycle. The information
    is divided into multiple panels that show different information, including request/response
    data, Python package versions used, execution time, settings, headers, SQL queries,
    templates used, cache, signals, and logging.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the documentation for Django Debug Toolbar at [https://django-debug-toolbar.readthedocs.io/](https://django-debug-toolbar.readthedocs.io/).
  prefs: []
  type: TYPE_NORMAL
- en: Installing Django Debug Toolbar
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Install `django-debug-toolbar` via `pip` using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit the `settings.py` file of your project and add `debug_toolbar` to the
    `INSTALLED_APPS` setting, as follows. The new line is highlighted in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'In the same file, add the following line highlighted in bold to the `MIDDLEWARE`
    setting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Django Debug Toolbar is mostly implemented as middleware. The order of `MIDDLEWARE`
    is important. `DebugToolbarMiddleware` has to be placed before any other middleware,
    except for middleware that encodes the response’s content, such as `GZipMiddleware`,
    which, if present, should come first.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following lines at the end of the `settings.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Django Debug Toolbar will only display if your IP address matches an entry in
    the `INTERNAL_IPS` setting. To prevent showing debug information in production,
    Django Debug Toolbar checks that the `DEBUG` setting is `True`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the main `urls.py` file of your project and add the following URL pattern
    highlighted in bold to `urlpatterns`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Django Debug Toolbar is now installed in your project. Let’s try it out!
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the development server with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Open `http://127.0.0.1:8000/images/` with your browser. You should now see
    a collapsible sidebar on the right. It should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_07_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.10: The Django Debug Toolbar sidebar'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 7.10* image attributions:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Chick Corea* by ataelw (license – Creative Commons Attribution 2.0 Generic:
    [https://creativecommons.org/licenses/by/2.0/](https://creativecommons.org/licenses/by/2.0/))'
  prefs: []
  type: TYPE_NORMAL
- en: '*Al Jarreau Düsseldorf 1981* by Eddi Laumanns aka RX-Guru (license – Creative
    Commons Attribution 3.0 Unported: [https://creativecommons.org/licenses/by/3.0/](https://creativecommons.org/licenses/by/3.0/))'
  prefs: []
  type: TYPE_NORMAL
- en: '*Al Jarreau* by Kingkongphoto and www.celebrity-photos.com (license – Creative
    Commons Attribution-ShareAlike 2.0 Generic: [https://creativecommons.org/licenses/by-sa/2.0/](https://creativecommons.org/licenses/by-sa/2.0/))'
  prefs: []
  type: TYPE_NORMAL
- en: If the Debug Toolbar doesn’t appear, check the RunServer shell console log.
    If you see a MIME type error, it is most likely that your MIME map files are incorrect
    or need to be updated.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can apply the correct mapping for JavaScript and CSS files by adding the
    following lines to the `settings.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Django Debug Toolbar panels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Django Debug Toolbar features multiple panels that organize the debug information
    for the request/response cycle. The sidebar contains links to each panel, and
    you can use the checkbox of any panel to activate or deactivate it. The change
    will be applied to the next request. This is useful when we are not interested
    in a specific panel, but the calculation adds too much overhead to the request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on **Time** in the sidebar menu. You will see the following panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_07_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.11: Time panel – Django Debug Toolbar'
  prefs: []
  type: TYPE_NORMAL
- en: The **Time** panel includes a timer for the different phases of the request/response
    cycle. It also shows CPU, elapsed time, and the number of context switches. If
    you are using Windows, you won’t be able to see the **Time** panel. In Windows,
    only the total time is available and displayed in the toolbar.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on **SQL** in the sidebar menu. You will see the following panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_07_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.12: SQL panel – Django Debug Toolbar'
  prefs: []
  type: TYPE_NORMAL
- en: Here, you can see the different SQL queries that have been executed. This information
    can help you identify unnecessary queries, duplicated queries that can be reused,
    or long-running queries that can be optimized. Based on your findings, you can
    improve QuerySets in your views, create new indexes on model fields if necessary,
    or cache information when needed. In this chapter, you learned how to optimize
    queries that involve relationships using `select_related()` and `prefetch_related()`.
    You will learn how to cache data in *Chapter 14*, *Rendering and Caching Content*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on **Templates** in the sidebar menu. You will see the following panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_07_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.13: Templates panel – Django Debug Toolbar'
  prefs: []
  type: TYPE_NORMAL
- en: This panel shows the different templates used when rendering the content, the
    template paths, and the context used. You can also see the different context processors
    used. You will learn about context processors in *Chapter 8*, *Building an Online
    Shop*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on **Signals** in the sidebar menu. You will see the following panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_07_14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.14: Signals panel – Django Debug Toolbar'
  prefs: []
  type: TYPE_NORMAL
- en: In this panel, you can see all the signals that are registered in your project
    and the receiver functions attached to each signal. For example, you can find
    the `users_like_changed` receiver function you created before, attached to the
    `m2m_changed` signal. The other signals and receivers are part of the different
    Django applications.
  prefs: []
  type: TYPE_NORMAL
- en: We have reviewed some of the panels that ship with Django Debug Toolbar. Besides
    the built-in panels, you can find additional third-party panels that you can download
    and use at [https://django-debug-toolbar.readthedocs.io/en/latest/panels.html#third-party-panels](https://django-debug-toolbar.readthedocs.io/en/latest/panels.html#third-party-panels).
  prefs: []
  type: TYPE_NORMAL
- en: Django Debug Toolbar commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Besides the request/response debug panels, Django Debug Toolbar provides a management
    command to debug SQL for ORM calls. The management command `debugsqlshell` replicates
    the Django `shell` command but it outputs SQL statements for queries performed
    with the Django ORM.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the shell with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: You can use this command to test ORM queries before adding them to your views.
    You can check the resulting SQL statement and the execution time for each ORM
    call.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will learn how to count image views using Redis, an
    in-memory database that provides low latency and high-throughput data access.
  prefs: []
  type: TYPE_NORMAL
- en: Counting image views with Redis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Redis is an advanced key/value database that allows you to save different types
    of data. It also has extremely fast I/O operations. Redis stores everything in
    memory, but the data can be persisted by dumping the dataset to disk every once
    in a while, or by adding each command to a log. Redis is very versatile compared
    to other key/value stores: it provides a set of powerful commands and supports
    diverse data structures, such as strings, hashes, lists, sets, ordered sets, and
    even `bitmap` or `HyperLogLog` methods.'
  prefs: []
  type: TYPE_NORMAL
- en: Although SQL is best suited to schema-defined persistent data storage, Redis
    offers numerous advantages when dealing with rapidly changing data, volatile storage,
    or when a quick cache is needed. Let’s take a look at how Redis can be used to
    build new functionality in your project.
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information about Redis on its home page at [https://redis.io/](https://redis.io/).
  prefs: []
  type: TYPE_NORMAL
- en: Redis provides a Docker image that makes it very easy to deploy a Redis server
    with a standard configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Redis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To install the Redis Docker image, make sure Docker is installed on your machine.
    You learned how to install Docker in *Chapter 3*, *Extending Your Blog Application*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command from the shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: This will download the Redis Docker image to your local machine. You can find
    information about the official Redis Docker image at [https://hub.docker.com/_/redis](https://hub.docker.com/_/redis).
    You can find other alternative methods to install Redis at [https://redis.io/download/](https://redis.io/download/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following command in the shell to start the Redis Docker container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: With this command, we run Redis in a Docker container. The `-it` option tells
    Docker to take you straight inside the container for interactive input. The `--rm`
    option tells Docker to automatically clean up the container and remove the file
    system when the container exits. The `--name` option is used to assign a name
    to the container. The `-p` option is used to publish the `6379` port on which
    Redis runs to the same host interface port. `6379` is the default port for Redis.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should see an output that ends with the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Keep the Redis server running on port `6379` and open another shell. Start
    the Redis client with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see a line with the hash symbol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Start the Redis client with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the Redis client shell prompt, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'The Redis client allows you to execute Redis commands directly from the shell.
    Let’s try some commands. Enter the `SET` command in the Redis shell to store a
    value in a key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command creates a `name` key with the string value `"Peter"` in
    the Redis database. The `OK` output indicates that the key has been saved successfully.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, retrieve the value using the `GET` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also check whether a key exists using the `EXISTS` command. This command
    returns `1` if the given key exists and `0` otherwise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'You can set the time for a key to expire using the `EXPIRE` command, which
    allows you to set the time-to-live in seconds. Another option is using the `EXPIREAT`
    command, which expects a Unix timestamp. Key expiration is useful for using Redis
    as a cache or to store volatile data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait for more than two seconds and try to get the same key again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'The `(nil)` response is a null response and means that no key has been found.
    You can also delete any key using the `DEL` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: These are just basic commands for key operations. You can find all Redis commands
    at [https://redis.io/commands/](https://redis.io/commands/) and all Redis data
    types at [https://redis.io/docs/manual/data-types/](https://redis.io/docs/manual/data-types/).
  prefs: []
  type: TYPE_NORMAL
- en: Using Redis with Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You will need Python bindings for Redis. Install `redis-py` via `pip` using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: You can find the `redis-py` documentation at [https://redis-py.readthedocs.io/](https://redis-py.readthedocs.io/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `redis-py` package interacts with Redis, providing a Python interface that
    follows the Redis command syntax. Open the Python shell with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code creates a connection with the Redis database. In Redis, databases
    are identified by an integer index instead of a database name. By default, a client
    is connected to database `0`. The number of available Redis databases is set to
    `16` but you can change this in the `redis.conf` configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, set a key using the Python shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'The command returns `True`, indicating that the key has been successfully created.
    Now you can retrieve the key using the `get()` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: As you will note from the preceding code, the methods of Redis follow the Redis
    command syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s integrate Redis into your project. Edit the `settings.py` file of the
    `bookmarks` project and add the following settings to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: These are the settings for the Redis server and the database that you will use
    for your project.
  prefs: []
  type: TYPE_NORMAL
- en: Storing image views in Redis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s find a way to store the total number of times an image has been viewed.
    If you implement this using the Django ORM, it will involve a SQL `UPDATE` query
    every time an image is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: If you use Redis instead, you just need to increment a counter stored in memory,
    resulting in much better performance and less overhead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `views.py` file of the `images` application and add the following
    code to it after the existing `import` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'With the preceding code, you establish the Redis connection in order to use
    it in your views. Edit the `views.py` file of the `images` application and modify
    the `image_detail` view, like this. The new code is highlighted in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: In this view, you use the `incr` command, which increments the value of a given
    key by `1`. If the key doesn’t exist, the `incr` command creates it. The `incr()`
    method returns the final value of the key after performing the operation. You
    store the value in the `total_views` variable and pass it into the template context.
    You build the Redis key using a notation such as `object-type:id:field` (for example,
    `image:33:id`).
  prefs: []
  type: TYPE_NORMAL
- en: The convention for naming Redis keys is to use a colon sign as a separator for
    creating namespaced keys. By doing so, the key names are especially verbose, and
    related keys share part of the same schema in their names.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `images/image/detail.html` template of the `images` application and
    add the following code highlighted in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the development server with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Open an image detail page in your browser and reload it several times. You
    will see that each time the view is processed, the total views displayed is incremented
    by 1\. Take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application, chat or text message  Description
    automatically generated](img/B21088_07_15.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.15: The image detail page, including the count of likes and views'
  prefs: []
  type: TYPE_NORMAL
- en: Great! You have successfully integrated Redis into your project to count image
    views. In the next section, you will learn how to build a ranking of the most
    viewed images with Redis.
  prefs: []
  type: TYPE_NORMAL
- en: Storing a ranking in Redis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will now create something more complex with Redis. We will use Redis to store
    a ranking of the most viewed images on the platform. We will use Redis sorted
    sets for this. A sorted set is a non-repeating collection of strings in which
    every member is associated with a score. Items are sorted by their score.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `views.py` file of the `images` application and add the following
    code highlighted in bold to the `image_detail` view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: You use the `zincrby()` command to store image views in a sorted set with the
    `image:ranking` key. You will store the image `id` and a related score of `1`,
    which will be added to the total score of this element in the sorted set. This
    will allow you to keep track of all image views globally and have a sorted set
    ordered by the total number of views.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, create a new view to display the ranking of the most viewed images. Add
    the following code to the `views.py` file of the `images` application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'The `image_ranking` view works like this:'
  prefs: []
  type: TYPE_NORMAL
- en: You use the `zrange()` command to obtain the elements in the sorted set. This
    command expects a custom range according to the lowest and highest scores. By
    using `0` as the lowest and `-1` as the highest score, you are telling Redis to
    return all elements in the sorted set. You also specify `desc=True` to retrieve
    the elements ordered by descending score. Finally, you slice the results using
    `[:10]` to get the first 10 elements with the highest score.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You build a list of returned image IDs and store it in the `image_ranking_ids`
    variable as a list of integers. You retrieve the `Image` objects for those IDs
    and force the query to be executed using the `list()` function. It is important
    to force the QuerySet execution because you will use the `sort()` method on it
    (at this point, you need a list of objects instead of a QuerySet).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You sort the `Image` objects by their index of appearance in the image ranking.
    Now you can use the `most_viewed` list in your template to display the 10 most
    viewed images.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new `ranking.html` template inside the `images/image/` template directory
    of the `images` application and add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: The template is pretty straightforward. You iterate over the `Image` objects
    contained in the `most_viewed` list and display their names, including a link
    to the image detail page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you need to create a URL pattern for the new view. Edit the `urls.py`
    file of the `images` application and add the following URL pattern highlighted
    in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the development server, access your site in your web browser, and load
    the image detail page multiple times for different images. Then, access `http://127.0.0.1:8000/images/ranking/`
    from your browser. You should be able to see an image ranking, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, table  Description automatically generated](img/B21088_07_16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.16: The ranking page built with data retrieved from Redis'
  prefs: []
  type: TYPE_NORMAL
- en: Great! You just created a ranking with Redis.
  prefs: []
  type: TYPE_NORMAL
- en: Next steps with Redis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Redis is not a replacement for your SQL database but it does offer fast in-memory
    storage that is more suitable for certain tasks. Add it to your stack and use
    it when you really feel it’s needed. The following are some scenarios in which
    Redis could be useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Counting**: As you have seen, it is very easy to manage counters with Redis.
    You can use `incr()` and `incrby()` for counting stuff.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Storing the latest items**: You can add items to the start/end of a list
    using `lpush()` and `rpush()`. Remove and return the first/last element using
    `lpop()`/`rpop()`. You can trim the list’s length using `ltrim()` to maintain
    its length.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Queues**: In addition to `push` and `pop` commands, Redis offers the blocking
    of queue commands.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Caching**: Using `expire()` and `expireat()` allows you to use Redis as a
    cache. You can also find third-party Redis cache backends for Django.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pub/sub**: Redis provides commands for subscribing/unsubscribing and sending
    messages to channels.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rankings and leaderboards**: Redis’s sorted sets with scores make it very
    easy to create leaderboards.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Real-time tracking**: Redis’s fast I/O makes it perfect for real-time scenarios.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you built a follow system using many-to-many relationships
    with an intermediate model. You also created an activity stream using generic
    relations and you optimized QuerySets to retrieve related objects. This chapter
    then introduced you to Django signals, and you created a signal receiver function
    to denormalize related object counts. We covered application configuration classes,
    which you used to load your signal handlers. You added Django Debug Toolbar to
    your project. You also learned how to install and configure Redis in your Django
    project. Finally, you used Redis in your project to store item views, and you
    built an image ranking with Redis.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to build an online shop. You will create
    a product catalog and build a shopping cart using sessions. You will learn how
    to create custom context processors. You will also manage customer orders and
    send asynchronous notifications using Celery and RabbitMQ.
  prefs: []
  type: TYPE_NORMAL
- en: Expanding your project using AI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you are presented with a task to extend your project, accompanied
    by a sample prompt for ChatGPT to assist you. To engage with ChatGPT, visit [https://chat.openai.com/](https://chat.openai.com/).
    If this is your first interaction with ChatGPT, you can revisit the *Expanding
    your project using AI* section in *Chapter 3*, *Extending Your Blog Application*.
  prefs: []
  type: TYPE_NORMAL
- en: In this project example, you have learned how to use Django signals and successfully
    implemented a signal receiver to update the total number of image likes whenever
    there is a change in the like count. Now, let’s leverage ChatGPT to explore the
    implementation of a signal receiver that automatically generates a related `Profile`
    object whenever a `User` object is created. You can use the prompt provided at
    [https://github.com/PacktPublishing/Django-5-by-example/blob/main/Chapter07/prompts/task.md](https://github.com/PacktPublishing/Django-5-by-example/blob/main/Chapter07/prompts/task.md).
  prefs: []
  type: TYPE_NORMAL
- en: After successfully implementing the signal receiver, you can remove the manual
    profile creation steps previously included in the `register` view of the `account`
    application and from the social authentication pipeline. With the receiver function
    now attached to the `post_save` signal of the `User` model, profiles will be automatically
    created for new users.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re having trouble understanding a particular concept or topic in the
    book, ask ChatGPT to provide additional examples or to explain the concept in
    a different way. This personalized approach can reinforce your learning and ensure
    you grasp complex topics.
  prefs: []
  type: TYPE_NORMAL
- en: Additional resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following resources provide additional information related to the topics
    covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Source code for this chapter: [https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter07](https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter07)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Custom user models: [https://docs.djangoproject.com/en/5.0/topics/auth/customizing/#specifying-a-custom-user-model](https://docs.djangoproject.com/en/5.0/topics/auth/customizing/#specifying-a-custom-user-model)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `contenttypes` framework: [https://docs.djangoproject.com/en/5.0/ref/contrib/contenttypes/](https://docs.djangoproject.com/en/5.0/ref/contrib/contenttypes/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Built-in Django signals: [https://docs.djangoproject.com/en/5.0/ref/signals/](https://docs.djangoproject.com/en/5.0/ref/signals/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Application configuration classes: [https://docs.djangoproject.com/en/5.0/ref/applications/](https://docs.djangoproject.com/en/5.0/ref/applications/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Django Debug Toolbar documentation: [https://django-debug-toolbar.readthedocs.io/](https://django-debug-toolbar.readthedocs.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Django Debug Toolbar third-party panels: [https://django-debug-toolbar.readthedocs.io/en/latest/panels.html#third-party-panels](https://django-debug-toolbar.readthedocs.io/en/latest/panels.html#third-party-panels)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Redis in-memory data store: [https://redis.io/](https://redis.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Official Redis Docker image: [https://hub.docker.com/_/redis](https://hub.docker.com/_/redis).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Redis download options: [https://redis.io/download/](https://redis.io/download/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Redis commands: [https://redis.io/commands/](https://redis.io/commands/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Redis data types: [https://redis.io/docs/manual/data-types/](https://redis.io/docs/manual/data-types/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`redis-py` documentation: [https://redis-py.readthedocs.io/](https://redis-py.readthedocs.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
