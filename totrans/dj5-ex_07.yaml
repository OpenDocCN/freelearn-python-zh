- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Tracking User Actions
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跟踪用户行为
- en: In the previous chapter, you built a JavaScript bookmarklet to share content
    from other websites on your platform. You also implemented asynchronous actions
    with JavaScript in your project and created an infinite scroll.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你构建了一个JavaScript书签工具来分享你平台上其他网站的内容。你还在项目中实现了JavaScript的异步操作并创建了一个无限滚动。
- en: In this chapter, you will learn how to build a follow system and create a user
    activity stream. You will also discover how Django signals work and you will integrate
    Redis’s fast I/O storage into your project to store item views.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何构建一个关注系统并创建用户活动流。你还将了解Django信号的工作原理，并将Redis的快速I/O存储集成到你的项目中以存储项目视图。
- en: 'This chapter will cover the following points:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下内容：
- en: Building a follow system
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建关注系统
- en: Creating many-to-many relationships with an intermediate model
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用中间模型创建多对多关系
- en: Creating an activity stream application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建活动流应用程序
- en: Adding generic relations to models
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向模型添加通用关系
- en: Optimizing QuerySets for related objects
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化相关对象的查询集
- en: Using signals for denormalizing counts
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用信号进行去规范化计数
- en: Using Django Debug Toolbar to obtain relevant debug information
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Django调试工具栏获取相关调试信息
- en: Counting image views with Redis
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Redis统计图片查看次数
- en: Creating a ranking of the most viewed images with Redis
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Redis创建最受欢迎图片的排名
- en: Functional overview
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能概述
- en: '*Figure 7.1* shows a representation of the views, templates, and functionalities
    that will be built in this chapter:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7.1*展示了本章将要构建的视图、模板和功能表示：'
- en: '![](img/B21088_07_01.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21088_07_01.png)'
- en: 'Figure 7.1: Diagram of functionalities built in Chapter 7'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1：第7章构建的功能图
- en: In this chapter, you will build the `user_list` view to list all users and the
    `user_detail` view to display a single user profile. You will implement a follow
    system with JavaScript, using the `user_follow` view to store user follows. You
    will create a system to store user actions, and you will implement the actions
    for creating an account, following a user, creating an image, and liking an image.
    You will use this system to display an activity stream in the `dashboard` view
    with the latest actions. You will also use Redis to store a *view* every time
    the `image_detail` view is loaded and create the view `image_ranking` to display
    a ranking of the most viewed images.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将构建`user_list`视图以列出所有用户和`user_detail`视图以显示单个用户资料。你将使用`user_follow`视图通过JavaScript实现关注系统，并存储用户关注。你将创建一个存储用户行为的系统，并实现创建账户、关注用户、创建图片和喜欢图片的操作。你将使用这个系统在`dashboard`视图中显示最新的行为流。你还将使用Redis在每次加载`image_detail`视图时存储一个*视图*，并创建`image_ranking`视图以显示最受欢迎图片的排名。
- en: The source code for this chapter can be found at [https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter07](https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter07).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可以在[https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter07](https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter07)找到。
- en: All Python packages used in this chapter are included in the `requirements.txt`
    file in the source code for the chapter. You can follow the instructions to install
    each Python package in the following sections, or you can install all requirements
    at once with the command `python` `-m` `pip` `install` `-r` `requirements.txt`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的所有Python包都包含在章节源代码中的`requirements.txt`文件中。你可以按照以下章节中的说明安装每个Python包，或者你可以使用命令`python
    -m pip install -r requirements.txt`一次性安装所有需求。
- en: Building a follow system
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建关注系统
- en: Let’s build a follow system in your project. This means that your users will
    be able to follow each other and track what other users share on the platform.
    The relationship between users is a *many-to-many* relationship; this means that
    a user can follow multiple users and they, in turn, can be followed by multiple
    users.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在项目中构建一个关注系统。这意味着你的用户将能够相互关注并跟踪其他用户在平台上分享的内容。用户之间的关系是*多对多*关系；这意味着一个用户可以关注多个用户，反过来，他们也可以被多个用户关注。
- en: Creating many-to-many relationships with an intermediate model
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用中间模型创建多对多关系
- en: In previous chapters, you created many-to-many relationships by adding the `ManyToManyField`
    to one of the related models and letting Django create the database table for
    the relationship. This is suitable for most cases, but sometimes you may need
    to create an intermediate model for the relationship. Creating an intermediate
    model is necessary when you want to store additional information on the relationship,
    for example, the date when the relationship was created, or a field that describes
    the nature of the relationship.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你通过向相关模型之一添加`ManyToManyField`并让Django创建关系数据库表来创建多对多关系。这在大多数情况下是合适的，但有时你可能需要为关系创建一个中间模型。当你想在关系上存储额外的信息时，例如关系创建的日期或描述关系性质的字段，创建中间模型是必要的。
- en: 'Let’s create an intermediate model to build relationships between users. There
    are two reasons for using an intermediate model:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个中间模型来建立用户之间的关系。使用中间模型的原因有两个：
- en: You are using the `User` model provided by Django and you want to avoid altering
    it
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你正在使用Django提供的`User`模型，并且想要避免修改它
- en: You want to store the time when the relationship was created
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你想要存储关系创建的时间
- en: 'Edit the `models.py` file of the `account` application and add the following
    code to it:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`account`应用的`models.py`文件，并向其中添加以下代码：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding code shows the `Contact` model that you will use for user relationships.
    It contains the following fields:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码展示了你将用于用户关系的`Contact`模型。它包含以下字段：
- en: '`user_from`: A `ForeignKey` for the user who creates the relationship'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`user_from`: 创建关系的用户的`ForeignKey`'
- en: '`user_to`: A `ForeignKey` for the user being followed'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`user_to`: 被关注的用户的`ForeignKey`'
- en: '`created`: A `DateTimeField` field with `auto_now_add=True` to store the time
    when the relationship was created'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`created`: 一个带有`auto_now_add=True`的`DateTimeField`字段，用于存储关系创建的时间'
- en: A database index is automatically created on the `ForeignKey` fields. In the
    `Meta` class of the model, we have defined a database index in descending order
    for the `created` field. We have also added the `ordering` attribute to tell Django
    that it should sort results by the `created` field by default. We indicate descending
    order by using a hyphen before the field name, like `-created`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ForeignKey`字段上会自动创建数据库索引。在模型的`Meta`类中，我们为`created`字段定义了一个降序数据库索引。我们还添加了`ordering`属性来告诉Django默认按`created`字段排序结果。我们通过在字段名前使用连字符来表示降序，例如`-created`。
- en: '*Figure 7.2* shows the intermediate `Contact` model and its corresponding database
    table:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7.2*展示了中间`Contact`模型及其对应的数据库表：'
- en: '![](img/B21088_07_02.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21088_07_02.png)'
- en: 'Figure 7.2: The intermediate Contact model and its database table'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2：中间`Contact`模型及其数据库表
- en: 'Using the ORM, you could create a relationship for a user, `user1`, following
    another user, `user2`, like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ORM，你可以创建一个用户`user1`关注另一个用户`user2`的关系，如下所示：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The related managers, `rel_from_set` and `rel_to_set`, will return a QuerySet
    for the `Contact` model. In order to access the end side of the relationship from
    the `User` model, it would be desirable for `User` to contain a `ManyToManyField`,
    as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 相关管理器`rel_from_set`和`rel_to_set`将返回`Contact`模型的QuerySet。为了从`User`模型访问关系的另一端，最好在`User`中包含一个`ManyToManyField`，如下所示：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding example, you tell Django to use your custom intermediate model
    for the relationship by adding `through=Contact` to `ManyToManyField`. This is
    a many-to-many relationship from the `User` model to itself; you refer to `'self'`
    in `ManyToManyField` to create a relationship to the same model.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，你通过在`ManyToManyField`中添加`through=Contact`来告诉Django使用你的自定义中间模型来处理关系。这是一个从`User`模型到自身的多对多关系；你在`ManyToManyField`中引用`'self'`来创建与同一模型的关系。
- en: When you need additional fields in a many-to-many relationship, create a custom
    model with a `ForeignKey` for each side of the relationship. You can manage the
    relationship using the intermediate model, or you can add a `ManyToManyField`
    field in one of the related models and indicate to Django that your intermediate
    model should be used by including it in the `through` parameter.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在多对多关系中需要额外的字段时，为关系的每一侧创建一个带有`ForeignKey`的自定义模型。你可以使用中间模型来管理关系，或者你可以在相关模型之一中添加一个`ManyToManyField`字段，并通过将其包含在`through`参数中来告诉Django使用你的中间模型。
- en: If the `User` model was part of your application, you could add the previous
    field to the model. However, you can’t alter the `User` class directly because
    it belongs to the `django.contrib.auth` application. Let’s take a slightly different
    approach by adding this field dynamically to the `User` model.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `User` 模型是应用程序的一部分，你可以将前面的字段添加到模型中。然而，你不能直接修改 `User` 类，因为它属于 `django.contrib.auth`
    应用。让我们采取稍微不同的方法，通过动态地将此字段添加到 `User` 模型中。
- en: 'Edit the `models.py` file of the `account` application and add the following
    lines highlighted in bold:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑 `account` 应用的 `models.py` 文件，并添加以下加粗的行：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding code, you retrieve the user model with the generic function
    `get_user_model()` provided by Django. You use the `add_to_class()` method of
    Django models to monkey patch the `User` model.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，你使用 Django 提供的通用函数 `get_user_model()` 获取用户模型。你使用 Django 模型的 `add_to_class()`
    方法来猴子补丁 `User` 模型。
- en: Be mindful that using `add_to_class()` is not the recommended way of adding
    fields to models. However, you can take advantage of using it in this case to
    avoid creating a custom user model, keeping all the advantages of Django’s built-in
    `User` model.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，使用 `add_to_class()` 不是向模型中添加字段的推荐方式。然而，你可以利用它在这个案例中的使用，避免创建自定义用户模型，同时保留
    Django 内置 `User` 模型的所有优点。
- en: You also simplify the way that you retrieve related objects using the Django
    ORM with `user.followers.all()` and `user.following.all()`. You use the intermediate
    `Contact` model and avoid complex queries that would involve additional database
    joins, as would have been the case had you defined the relationship in your custom
    `Profile` model. The table for this many-to-many relationship will be created
    using the `Contact` model. Thus, the `ManyToManyField`, added dynamically, will
    not imply any database changes for the Django `User` model.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你还简化了使用 Django ORM 通过 `user.followers.all()` 和 `user.following.all()` 获取相关对象的方式。你使用中间的
    `Contact` 模型，避免了涉及额外数据库连接的复杂查询，就像你在自定义 `Profile` 模型中定义关系时那样。这个多对多关系的表将使用 `Contact`
    模型创建。因此，动态添加的 `ManyToManyField` 不会对 Django `User` 模型产生任何数据库更改。
- en: Keep in mind that, in most cases, it is preferable to add fields to the `Profile`
    model you created before, instead of monkey patching the `User` model. Ideally,
    you shouldn’t alter the existing Django `User` model. Django allows you to use
    custom user models. If you want to use a custom user model, take a look at the
    documentation at [https://docs.djangoproject.com/en/5.0/topics/auth/customizing/#specifying-a-custom-user-model](https://docs.djangoproject.com/en/5.0/topics/auth/customizing/#specifying-a-custom-user-model).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在大多数情况下，最好是向之前创建的 `Profile` 模型中添加字段，而不是对 `User` 模型进行猴子补丁。理想情况下，你不应该修改现有的
    Django `User` 模型。Django 允许你使用自定义用户模型。如果你想使用自定义用户模型，请查看[https://docs.djangoproject.com/en/5.0/topics/auth/customizing/#specifying-a-custom-user-model](https://docs.djangoproject.com/en/5.0/topics/auth/customizing/#specifying-a-custom-user-model)上的文档。
- en: When you start a new project, it is highly recommended that you create a custom
    user model, even if the default `User` model is sufficient for you. This is because
    you gain the option of customizing the model.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始一个新的项目时，强烈建议你创建一个自定义用户模型，即使默认的 `User` 模型对你来说已经足够。这是因为你获得了自定义模型的选择权。
- en: Note that the relationship includes `symmetrical=False`. When you define a `ManyToManyField`
    in the model creating a relationship with itself, Django forces the relationship
    to be symmetrical. In this case, you are setting `symmetrical=False` to define
    a non-symmetrical relationship (if I follow you, it doesn’t mean that you automatically
    follow me).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，该关系包括 `symmetrical=False`。当你在一个模型中定义一个与自身建立关系的 `ManyToManyField` 时，Django
    会强制该关系是对称的。在这种情况下，你设置 `symmetrical=False` 来定义一个非对称关系（如果我理解正确，这并不意味着你自动跟随我）。
- en: When you use an intermediate model for many-to-many relationships, some of the
    related manager’s methods are disabled, such as `add()`, `create()`, or `remove()`.
    You need to create or delete instances of the intermediate model instead.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用中间模型进行多对多关系时，一些相关管理器的功能被禁用，例如 `add()`、`create()` 或 `remove()`。你需要创建或删除中间模型的实例。
- en: 'Run the following command to generate the initial migrations for the `account`
    application:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以生成 `account` 应用程序的初始迁移：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You will obtain an output like the following one:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你将获得如下所示的输出：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, run the following command to sync the application with the database:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行以下命令以将应用程序与数据库同步：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You should see an output that includes the following line:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到一个包含以下行的输出：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `Contact` model is now synced to the database, and you are able to create
    relationships between users. However, your site doesn’t offer a way to browse
    users or see a particular user’s profile yet. Let’s build the list and detail
    views for the `User` model.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`Contact` 模型现在已同步到数据库，你可以创建用户之间的关系。然而，你的网站还没有提供浏览用户或查看特定用户资料的方法。让我们为 `User`
    模型构建列表和详细视图。'
- en: Creating list and detail views for user profiles
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建用户资料的列表和详细视图
- en: 'Open the `views.py` file of the `account` application and add the following
    code highlighted in bold:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `account` 应用程序的 `views.py` 文件，并添加以下以粗体显示的代码：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: These are simple list and detail views for `User` objects. We retrieve the `User`
    model dynamically using the `get_user_model()` function. The `user_list` view
    gets all active users. The Django `User` model contains an `is_active` flag to
    designate whether the user account is considered active. You filter the query
    by `is_active=True` to return only active users. This view returns all results,
    but you can improve it by adding pagination in the same way as you did for the
    `image_list` view.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是针对 `User` 对象的简单列表和详细视图。我们通过使用 `get_user_model()` 函数动态检索 `User` 模型。`user_list`
    视图获取所有活跃用户。Django 的 `User` 模型包含一个 `is_active` 标志，用于指定用户账户是否被视为活跃。你可以通过 `is_active=True`
    过滤查询，以返回仅活跃用户。此视图返回所有结果，但你可以通过添加分页来改进它，就像你在 `image_list` 视图中做的那样。
- en: The `user_detail` view uses the `get_object_or_404()` shortcut to retrieve the
    active user with the given username. The view returns an HTTP `404` response if
    no active user with the given username is found.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`user_detail` 视图使用 `get_object_or_404()` 快捷方式检索具有给定用户名的活跃用户。如果找不到具有给定用户名的活跃用户，视图将返回
    HTTP `404` 响应。'
- en: 'Edit the `urls.py` file of the `account` application and add a URL pattern
    for each view, as follows. The new code is highlighted in bold:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑 `account` 应用程序的 `urls.py` 文件，并为每个视图添加一个 URL 模式，如下所示。新的代码以粗体显示：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You will use the `user_detail` URL pattern to generate the canonical URL for
    users. You have already defined a `get_absolute_url()` method in a model to return
    the canonical URL for each object. Another way to specify the URL for a model
    is by adding the `ABSOLUTE_URL_OVERRIDES` setting to your project.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用 `user_detail` URL 模式来生成用户的规范 URL。你已经在模型中定义了一个 `get_absolute_url()` 方法，用于返回每个对象的规范
    URL。另一种指定模型 URL 的方法是在项目中添加 `ABSOLUTE_URL_OVERRIDES` 设置。
- en: By using the username instead of the user ID in the `user_detail` URL pattern,
    you enhance both usability and security. Usernames, unlike sequential IDs, thwart
    enumeration attacks by obscuring your data structure. This makes it harder for
    attackers to predict URLs and formulate attack vectors.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 `user_detail` URL 模式中使用用户名而不是用户 ID，你提高了可用性和安全性。与顺序 ID 不同，用户名通过隐藏你的数据结构来阻止枚举攻击。这使得攻击者更难预测
    URL 并制定攻击向量。
- en: 'Edit the `settings.py` file of your project and add the following code highlighted
    in bold:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑你项目的 `settings.py` 文件，并添加以下以粗体显示的代码：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Django adds a `get_absolute_url()` method dynamically to any models that appear
    in the `ABSOLUTE_URL_OVERRIDES` setting. This method returns the corresponding
    URL for the given model specified in the setting. In the previous code section,
    you generate the `user_detail` URL for the given user for the `auth.user` object.
    Now, you can use `get_absolute_url()` on a `User` instance to retrieve its corresponding
    URL.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Django 会动态地将 `get_absolute_url()` 方法添加到任何出现在 `ABSOLUTE_URL_OVERRIDES` 设置中的模型。此方法返回设置中指定的给定模型的对应
    URL。在上面的代码部分中，你为 `auth.user` 对象生成了给定用户的 `user_detail` URL。现在，你可以在 `User` 实例上使用
    `get_absolute_url()` 来检索其对应的 URL。
- en: 'Open the Python shell with the following command:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令打开 Python 命令行界面：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then run the following code to test it:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然后运行以下代码进行测试：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The returned URL follows the expected format, `/account/users/<username>/`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的 URL 符合预期的格式，`/account/users/<username>/`。
- en: 'You will need to create templates for the views that you just built. Add the
    following directory and files to the `templates/account/` directory of the `account`
    application:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要为刚刚创建的视图创建模板。将以下目录和文件添加到 `account` 应用程序的 `templates/account/` 目录中：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Edit the `account/user/list.html` template and add the following code to it:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑 `account/user/list.html` 模板，并向其中添加以下代码：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The preceding template allows you to list all the active users on the site.
    You iterate over the given users and use the `{% thumbnail %}` template tag from
    `easy-thumbnails` to generate profile image thumbnails.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 上述模板允许你列出网站上所有活跃用户。你遍历给定的用户，并使用来自`easy-thumbnails`的`{% thumbnail %}`模板标签生成个人头像缩略图。
- en: 'Note that the users need to have a profile image. To use a default image for
    users that don’t have a profile image, you can add an `if`/`else` statement to
    check whether the user has a profile photo, like `{% if user.profile.photo %}
    {# photo thumbnail #} {% else %} {# default image #} {% endif %}`.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '注意，用户需要有一个个人头像。为了给没有个人头像的用户使用默认头像，你可以在代码中添加一个`if`/`else`语句来检查用户是否有个人照片，例如`{%
    if user.profile.photo %} {# photo thumbnail #} {% else %} {# default image #}
    {% endif %}`。'
- en: 'Open the `base.html` template of your project and include the `user_list` URL
    in the `href` attribute of the following menu item. The new code is highlighted
    in bold:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你的项目的`base.html`模板，并在以下菜单项的`href`属性中包含`user_list` URL。新的代码已加粗：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Start the development server with the following command:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令启动开发服务器：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Open `http://127.0.0.1:8000/account/users/` in your browser. You should see
    a list of users like the following one:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的浏览器中打开`http://127.0.0.1:8000/account/users/`。你应该会看到一个类似以下用户列表：
- en: '![Graphical user interface, text, website  Description automatically generated](img/B21088_07_03.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，网站  自动生成的描述](img/B21088_07_03.png)'
- en: 'Figure 7.3: The user list page with profile image thumbnails'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3：带有个人头像缩略图的用户列表页面
- en: Remember that if you have any difficulty generating thumbnails, you can add
    `THUMBNAIL_DEBUG = True` to your `settings.py` file in order to obtain debug information
    in the shell.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，如果你在生成缩略图时遇到任何困难，你可以在`settings.py`文件中添加`THUMBNAIL_DEBUG = True`来在shell中获得调试信息。
- en: 'Edit the `account/user/detail.html` template of the `account` application and
    add the following code to it:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`account`应用的`account/user/detail.html`模板，并向其中添加以下代码：
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Make sure that no template tag is split into multiple lines; Django doesn’t
    support multiple-line tags.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 确保不要将模板标签拆分成多行；Django不支持多行标签。
- en: In the `detail` template, the user profile is displayed, and the `{% thumbnail
    %}` template tag is used to show the profile image. The total number of followers
    is presented along with a link to follow or unfollow the user. This link will
    be used to follow/unfollow a particular user. The `data-id` and `data-action`
    attributes of the `<a>` HTML element contain the user ID and the initial action
    to perform when the link element is clicked – `follow` or `unfollow`. The initial
    action (*follow* or *unfollow*) depends on whether the user requesting the page
    is already a follower of the user. The images bookmarked by the user are displayed
    by including the `images/image/list_images.html` template.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在`detail`模板中，显示用户个人资料，并使用`{% thumbnail %}`模板标签来显示个人头像。同时展示关注者总数，并提供一个关注或取消关注用户的链接。此链接将用于关注/取消关注特定用户。`<a>`
    HTML元素的`data-id`和`data-action`属性包含用户ID和当链接元素被点击时执行的初始操作——`follow`或`unfollow`。初始操作（`follow`或`unfollow`）取决于请求页面的用户是否已经是该用户的关注者。用户标记的图片通过包含`images/image/list_images.html`模板来显示。
- en: 'Open your browser again and click on a user who has bookmarked some images.
    The user page will look as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 再次打开你的浏览器，点击一个标记了一些图片的用户。用户页面将如下所示：
- en: '![Graphical user interface, text, application, website  Description automatically
    generated](img/B21088_07_04.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序，网站  自动生成的描述](img/B21088_07_04.png)'
- en: 'Figure 7.4: The user detail page'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4：用户详情页面
- en: 'The preceding image is of *Chick Corea* by ataelw (Creative Commons Attribution
    2.0 Generic license: [https://creativecommons.org/licenses/by/2.0/](https://creativecommons.org/licenses/by/2.0/)).'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图片是ataelw创作的* Chick Corea*，采用Creative Commons Attribution 2.0通用许可：[https://creativecommons.org/licenses/by/2.0/](https://creativecommons.org/licenses/by/2.0/)。
- en: Adding user follow/unfollow actions with JavaScript
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用JavaScript添加用户关注/取消关注操作
- en: Let’s add functionality to follow/unfollow users. We will create a new view
    to follow/unfollow users and implement an asynchronous HTTP request with JavaScript
    for the follow/unfollow action.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加关注/取消关注用户的功能。我们将创建一个新的视图来关注/取消关注用户，并使用JavaScript实现异步HTTP请求以执行关注/取消关注操作。
- en: 'Edit the `views.py` file of the `account` application and add the following
    code highlighted in bold:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`account`应用的`views.py`文件，并添加以下加粗代码：
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `user_follow` view is quite similar to the `image_like` view that you created
    in *Chapter 6*, *Sharing Content on Your Website*. Since you are using a custom
    intermediate model for the user’s many-to-many relationship, the default `add()`
    and `remove()` methods of the automatic manager of `ManyToManyField` are not available.
    Instead, the intermediate `Contact` model is used to create or delete user relationships.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`user_follow` 视图与你在 *第 6 章* 中创建的 `image_like` 视图非常相似，*在您的网站上分享内容*。由于你正在使用用于用户多对多关系的自定义中间模型，因此
    `ManyToManyField` 的自动管理器的默认 `add()` 和 `remove()` 方法不可用。相反，使用中间 `Contact` 模型来创建或删除用户关系。'
- en: 'Edit the `urls.py` file of the `account` application and add the following
    URL pattern highlighted in bold:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑 `account` 应用程序的 `urls.py` 文件，并添加以下以粗体显示的 URL 模式：
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Ensure that you place the preceding pattern before the `user_detail` URL pattern.
    Otherwise, any requests to `/users/follow/` will match the regular expression
    of the `user_detail` pattern and that view will be executed instead. Remember
    that in every HTTP request, Django checks the requested URL against each pattern
    in order of appearance and stops at the first match.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将前面的模式放在 `user_detail` URL 模式之前。否则，任何对 `/users/follow/` 的请求都将匹配 `user_detail`
    模式的正则表达式，并且将执行该视图。记住，在每次 HTTP 请求中，Django 都会按照出现的顺序将请求的 URL 与每个模式进行比较，并在第一个匹配项处停止。
- en: 'Edit the `user/detail.html` template of the `account` application and append
    the following code to it:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑 `account` 应用程序的 `user/detail.html` 模板，并向其中添加以下代码：
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The preceding template block contains the JavaScript code to perform the asynchronous
    HTTP request to follow or unfollow a particular user and also to toggle the follow/unfollow
    link.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的模板块包含执行关注或取消关注特定用户的异步 HTTP 请求的 JavaScript 代码，以及切换关注/取消关注链接。
- en: The Fetch API is used to perform the AJAX request and set both the `data-action`
    attribute and the text of the HTML `<a>` element based on its previous value.
    When the action is completed, the total number of followers displayed on the page
    is updated as well.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Fetch API 执行 AJAX 请求，并根据其前一个值设置 `data-action` 属性和 HTML `<a>` 元素的文本。当操作完成后，页面上显示的关注者总数也会更新。
- en: 'Open the user detail page of an existing user and click on the **FOLLOW** link
    to test the functionality you just built. You will see, on the left-hand side
    of the following image, that the followers count has increased:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 打开现有用户的用户详情页面，并点击 **关注** 链接来测试你刚刚构建的功能。你会在以下图像的左侧看到，关注者数量已经增加：
- en: '![](img/B21088_07_05.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21088_07_05.png)'
- en: 'Figure 7.5: The followers count and follow/unfollow button'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5：关注者数量和关注/取消关注按钮
- en: The follow system is now complete and users can follow each other. Next, we
    will build an activity stream creating relevant content for each user that is
    based on the people they follow.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 关注系统现在已经完成，用户可以相互关注。接下来，我们将构建一个活动流，为每个用户创建基于他们关注的人的相关内容。
- en: Creating an activity stream application
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建活动流应用程序
- en: Many social websites display an activity stream to their users so that they
    can track what other users do on the platform. An activity stream is a list of
    recent activities performed by a user or a group of users. For example, Facebook’s
    News Feed is an activity stream. Sample actions can be *user X bookmarked image
    Y* or *user X is now following user Y*.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 许多社交网站向用户展示活动流，以便他们可以跟踪其他用户在平台上的行为。活动流是用户或一组用户最近执行的活动列表。例如，Facebook 的新闻源就是一个活动流。示例操作可以是
    *用户 X 收藏了图片 Y* 或 *用户 X 现在正在关注用户 Y*。
- en: You are going to build an activity stream application so that every user can
    see the recent interactions of the users they follow. To do so, you will need
    a model to save the actions performed by users on the website and a simple way
    to add actions to the feed.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你将构建一个活动流应用程序，以便每个用户都可以看到他们关注的用户的最近互动。为此，你需要一个模型来保存用户在网站上执行的操作，以及一个简单的方法来向流中添加操作。
- en: 'Create a new application named `actions` inside your project with the following
    command:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的项目中使用以下命令创建一个名为 `actions` 的新应用程序：
- en: '[PRE21]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Add the new application to `INSTALLED_APPS` in the `settings.py` file of your
    project to activate the application in your project. The new line is highlighted
    in bold:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 将新应用程序添加到项目中的 `settings.py` 文件中的 `INSTALLED_APPS` 以激活该应用程序。新行以粗体显示：
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Edit the `models.py` file of the `actions` application and add the following
    code to it:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑 `actions` 应用程序的 `models.py` 文件，并向其中添加以下代码：
- en: '[PRE23]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The preceding code shows the `Action` model that will be used to store user
    activities. The fields of this model are as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码显示了将用于存储用户活动的`Action`模型。该模型的字段如下：
- en: '`user`: The user who performed the action; this is a `ForeignKey` to the `AUTH_USER_MODEL`,
    by default, the Django `User` model.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`user`: 执行该操作的用户；这是一个指向`AUTH_USER_MODEL`的`ForeignKey`，默认情况下是Django的`User`模型。'
- en: '`verb`: The verb describing the action that the user has performed.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`verb`: 描述用户所执行操作的动词。'
- en: '`created`: The date and time when this action was created. We use `auto_now_add=True`
    to automatically set this to the current datetime when the object is saved for
    the first time in the database.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`created`: 该操作创建的日期和时间。我们使用`auto_now_add=True`来自动将此字段设置为对象在数据库中首次保存时的当前日期和时间。'
- en: In the `Meta` class of the model, we have defined a database index in descending
    order for the `created` field. We have also added the `ordering` attribute to
    tell Django that it should sort results by the `created` field in descending order
    by default.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在模型的`Meta`类中，我们为`created`字段定义了一个降序数据库索引。我们还添加了`ordering`属性，告诉Django默认按`created`字段降序排序结果。
- en: With this basic model, you can only store actions such as *user X did something*.
    You need an extra `ForeignKey` field to save actions that involve a `target` object,
    such as *user X bookmarked image Y* or *user X is now following user Y*. As you
    already know, a normal `ForeignKey` can point to only one model. Instead, you
    will need a way for the action’s `target` object to be an instance of an existing
    model. This is what the Django `contenttypes` framework will help you to do.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个基本模型，您只能存储诸如“用户X做了某事”之类的操作。您需要一个额外的`ForeignKey`字段来保存涉及`target`对象的操作，例如“用户X收藏了图像Y”或“用户X现在正在关注用户Y”。如您所知，一个普通的`ForeignKey`只能指向一个模型。相反，您将需要一个方法，使操作的`target`对象成为现有模型的一个实例。这正是Django的`contenttypes`框架将帮助您完成的。
- en: Using the contenttypes framework
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`contenttypes`框架
- en: Django includes a `contenttypes` framework located at `django.contrib.contenttypes`.
    This application can track all models installed in your project and provides a
    generic interface to interact with your models.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Django在`django.contrib.contenttypes`位置包含一个`contenttypes`框架。此应用程序可以跟踪您项目中安装的所有模型，并提供一个通用接口与您的模型交互。
- en: The `django.contrib.contenttypes` application is included in the `INSTALLED_APPS`
    setting by default when you create a new project using the `startproject` command.
    It is used by other `contrib` packages, such as the authentication framework and
    the administration application.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用`startproject`命令创建新项目时，`django.contrib.contenttypes`应用程序默认包含在`INSTALLED_APPS`设置中。它被其他`contrib`包使用，例如认证框架和管理应用程序。
- en: 'The `contenttypes` application contains a `ContentType` model. Instances of
    this model represent the actual models of your application, and new instances
    of `ContentType` are automatically created when new models are installed in your
    project. The `ContentType` model has the following fields:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`contenttypes`应用程序包含一个`ContentType`模型。该模型的实例代表您应用程序的实际模型，并且当您的项目中新安装模型时，会自动创建新的`ContentType`实例。`ContentType`模型具有以下字段：'
- en: '`app_label`: This indicates the name of the application that the model belongs
    to. This is automatically taken from the `app_label` attribute of the model `Meta`
    options. For example, your `Image` model belongs to the `images` application.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app_label`: 这表示模型所属的应用程序名称。这自动从模型`Meta`选项的`app_label`属性中获取。例如，您的`Image`模型属于`images`应用程序。'
- en: '`model`: The name of the model class.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`model`: 模型类名称。'
- en: '`name`: This is a property that indicates the human-readable name of the model,
    automatically generated from the `verbose_name` attribute of the model `Meta`
    options.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`: 这是一个属性，表示模型的可读名称，自动从模型`Meta`选项的`verbose_name`属性中生成。'
- en: 'Let’s take a look at how you can interact with `ContentType` objects. Open
    the shell using the following command:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看您如何与`ContentType`对象交互。使用以下命令打开shell：
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You can obtain the `ContentType` object corresponding to a specific model by
    performing a query with the `app_label` and `model` attributes, as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用`app_label`和`model`属性进行查询来获取与特定模型对应的`ContentType`对象，如下所示：
- en: '[PRE25]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You can also retrieve the model class from a `ContentType` object by calling
    its `model_class()` method:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过调用其`model_class()`方法从`ContentType`对象中检索模型类：
- en: '[PRE26]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'It’s also common to obtain the `ContentType` object for a particular model
    class, as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 获取特定模型类的`ContentType`对象也很常见，如下所示：
- en: '[PRE27]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: These are just some examples of using `contenttypes`. Django offers more ways
    to work with them. You can find the official documentation for the `contenttypes`
    framework at [https://docs.djangoproject.com/en/5.0/ref/contrib/contenttypes/](https://docs.djangoproject.com/en/5.0/ref/contrib/contenttypes/).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是使用`contenttypes`的一些示例。Django提供了更多与之交互的方式。您可以在[https://docs.djangoproject.com/en/5.0/ref/contrib/contenttypes/](https://docs.djangoproject.com/en/5.0/ref/contrib/contenttypes/)找到`contenttypes`框架的官方文档。
- en: Adding generic relations to your models
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将泛型关系添加到您的模型中
- en: 'In generic relations, `ContentType` objects play the role of pointing to the
    model used for the relationship. You will need three fields to set up a generic
    relation in a model:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在泛型关系中，`ContentType`对象扮演着指向用于关系的模型的角色。您需要在模型中设置泛型关系时使用三个字段：
- en: 'A `ForeignKey` field to `ContentType`: This will tell you what the model for
    the relationship is'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个指向`ContentType`的`ForeignKey`字段：这将告诉您关系的模型是什么
- en: 'A field to store the primary key of the related object: This will usually be
    a `PositiveIntegerField` to match Django’s automatic primary key fields'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储相关对象主键的字段：这通常将是一个`PositiveIntegerField`，以匹配Django的自动主键字段
- en: 'A field to define and manage the generic relation using the two previous fields:
    The `contenttypes` framework offers a `GenericForeignKey` field for this purpose'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用前两个字段定义和管理泛型关系的字段：`contenttypes`框架为此目的提供了一个`GenericForeignKey`字段
- en: 'Edit the `models.py` file of the `actions` application and add the following
    code highlighted in bold:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`actions`应用程序的`models.py`文件，并向其中添加以下加粗的代码：
- en: '[PRE28]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We have added the following fields to the `Action` model:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已向`Action`模型添加了以下字段：
- en: '`target_ct`: A `ForeignKey` field that points to the `ContentType` model'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`target_ct`: 指向`ContentType`模型的`ForeignKey`字段'
- en: '`target_id`: A `PositiveIntegerField` for storing the primary key of the related
    object'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`target_id`: 存储相关对象主键的`PositiveIntegerField`'
- en: '`target`: A `GenericForeignKey` field to the related object based on the combination
    of the two previous fields'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`target`: 一个基于前两个字段组合的指向相关对象的`GenericForeignKey`字段'
- en: We have also added a multiple-field index including the `target_ct` and `target_id`
    fields.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了一个包含`target_ct`和`target_id`字段的多个字段索引。
- en: Django does not create `GenericForeignKey` fields in the database. The only
    fields that are mapped to database fields are `target_ct` and `target_id`. Both
    fields have `blank=True` and `null=True` attributes so that a `target` object
    is not required when saving `Action` objects.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Django不会在数据库中创建`GenericForeignKey`字段。唯一映射到数据库字段的是`target_ct`和`target_id`字段。这两个字段都有`blank=True`和`null=True`属性，这样在保存`Action`对象时不需要`target`对象。
- en: You can make your applications more flexible by using generic relations instead
    of foreign keys. Generic relations allow you to associate models in a non-exclusive
    manner, enabling a single model to relate to multiple other models.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用泛型关系而不是外键来使您的应用程序更加灵活。泛型关系允许您以非排他方式关联模型，使单个模型能够关联到多个其他模型。
- en: '*Figure 7.6* shows the `Action` model, including the relationship with the
    `ContentType` model of the `contenttypes` Django contrib package:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7.6*显示了`Action`模型，包括与`contenttypes` Django contrib包的`ContentType`模型的关联：'
- en: '![](img/B21088_07_06.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图7.6](img/B21088_07_06.png)'
- en: 'Figure 7.6: The Action model and the ContentType model'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6：Action模型和ContentType模型
- en: 'Run the following command to create initial migrations for this application:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令为此应用程序创建初始迁移：
- en: '[PRE29]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You should see the following output:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下输出：
- en: '[PRE30]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, run the next command to sync the application with the database:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，运行下一个命令以将应用程序与数据库同步：
- en: '[PRE31]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The output of the command should indicate that the new migrations have been
    applied, as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的输出应指示新迁移已应用，如下所示：
- en: '[PRE32]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Let’s add the `Action` model to the administration site. Edit the `admin.py`
    file of the `actions` application and add the following code to it:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将`Action`模型添加到管理网站。编辑`actions`应用程序的`admin.py`文件，并向其中添加以下代码：
- en: '[PRE33]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You just registered the `Action` model on the administration site.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 您已在管理网站上注册了`Action`模型。
- en: 'Start the development server with the following command:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令启动开发服务器：
- en: '[PRE34]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Open `http://127.0.0.1:8000/admin/actions/action/add/` in your browser. You
    should see the page for creating a new `Action` object, as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的浏览器中打开`http://127.0.0.1:8000/admin/actions/action/add/`。您应该看到创建新`Action`对象的页面，如下所示：
- en: '![](img/B21088_07_07.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图7.6](img/B21088_07_07.png)'
- en: 'Figure 7.7: The Add action page on the Django administration site'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7：Django管理网站上的添加操作页面
- en: As you will notice in the preceding screenshot, only the `target_ct` and `target_id`
    fields that are mapped to actual database fields are shown. The `GenericForeignKey`
    field does not appear in the form. The `target_ct` field allows you to select
    any of the registered models of your Django project. You can restrict the content
    types to choose from a limited set of models using the `limit_choices_to` attribute
    in the `target_ct` field; the `limit_choices_to` attribute allows you to restrict
    the content of `ForeignKey` fields to a specific set of values.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面的屏幕截图中所注意到的，只有映射到实际数据库字段的`target_ct`和`target_id`字段被显示。`GenericForeignKey`字段在表单中不出现。`target_ct`字段允许您选择您Django项目中注册的任何模型。您可以使用`target_ct`字段中的`limit_choices_to`属性将内容类型限制为有限的一组模型；`limit_choices_to`属性允许您将`ForeignKey`字段的内容限制为特定的值集。
- en: 'Create a new file inside the `actions` application directory and name it `utils.py`.
    You need to define a shortcut function that will allow you to create new `Action`
    objects in a simple way. Edit the new `utils.py` file and add the following code
    to it:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在`actions`应用目录内创建一个新文件，并将其命名为`utils.py`。您需要定义一个快捷函数，这将允许您以简单的方式创建新的`Action`对象。编辑新的`utils.py`文件，并向其中添加以下代码：
- en: '[PRE35]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `create_action()` function allows you to create actions that optionally
    include a `target` object. You can use this function anywhere in your code as
    a shortcut to add new actions to the activity stream.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`create_action()`函数允许您创建可选包含`target`对象的操作。您可以在代码的任何位置使用此函数作为快捷方式将新操作添加到活动流中。'
- en: Avoiding duplicate actions in the activity stream
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免在活动流中重复操作
- en: Sometimes, your users might click several times on the **Like** or **Unlike**
    button or perform the same action multiple times in a short period of time. This
    will easily lead to storing and displaying duplicate actions. To avoid this, let’s
    improve the `create_action()` function to skip obvious duplicated actions.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您的用户可能会多次点击**喜欢**或**不喜欢**按钮，或者在短时间内多次执行相同的操作。这很容易导致存储和显示重复操作。为了避免这种情况，让我们改进`create_action()`函数以跳过明显的重复操作。
- en: 'Edit the `utils.py` file of the `actions` application, as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下方式编辑`actions`应用的`utils.py`文件：
- en: '[PRE36]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'You have changed the `create_action()` function to avoid saving duplicate actions
    and return a Boolean to tell you whether the action was saved. This is how you
    avoid duplicates:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 您已将`create_action()`函数更改为避免保存重复操作并返回一个布尔值来告诉您操作是否已保存。这就是您避免重复的方法：
- en: First, you get the current time using the `timezone.now()` method provided by
    Django. This method does the same as `datetime.datetime.now()` but returns a timezone-aware
    object. Django provides a setting called `USE_TZ` to enable or disable timezone
    support. The default `settings.py` file created using the `startproject` command
    includes `USE_TZ=True`.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您使用Django提供的`timezone.now()`方法获取当前时间。此方法与`datetime.datetime.now()`执行相同，但返回一个时区感知对象。Django提供了一个名为`USE_TZ`的设置来启用或禁用时区支持。使用`startproject`命令创建的默认`settings.py`文件包括`USE_TZ=True`。
- en: You use the `last_minute` variable to store the datetime from one minute ago
    and retrieve any identical actions performed by the user since then.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您使用`last_minute`变量来存储一分钟前的日期时间，并检索用户从那时起执行的任何相同操作。
- en: You create an `Action` object if no identical action already exists in the last
    minute. You return `True` if an `Action` object was created or `False` otherwise.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在过去一分钟内不存在相同的操作，您将创建一个`Action`对象。如果创建了`Action`对象，则返回`True`，否则返回`False`。
- en: Adding user actions to the activity stream
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将用户操作添加到活动流
- en: 'It’s time to add some actions to your views to build the activity stream for
    your users. You will store an action for each of the following interactions:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候向您的视图添加一些操作来为您的用户构建活动流了。您将为以下每个交互存储一个操作：
- en: A user bookmarks an image
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户收藏图片
- en: A user likes an image
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户喜欢图片
- en: A user creates an account
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户创建账户
- en: A user starts following another user
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户开始关注另一个用户
- en: 'Edit the `views.py` file of the `images` application and add the following
    import:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`images`应用的`views.py`文件并添加以下导入：
- en: '[PRE37]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the `image_create` view, add `create_action()` after saving the image, as
    follows. The new line is highlighted in bold:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在`image_create`视图中，在保存图片后添加`create_action()`，如下所示。新行以粗体突出显示：
- en: '[PRE38]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In the `image_like` view, add `create_action()` after adding the user to the
    `users_like` relationship, as follows. The new line is highlighted in bold:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在`image_like`视图中，在将用户添加到`users_like`关系后添加`create_action()`，如下所示。新行以粗体突出显示：
- en: '[PRE39]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, edit the `views.py` file of the `account` application and add the following
    import:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，编辑 `account` 应用程序的 `views.py` 文件并添加以下导入：
- en: '[PRE40]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In the `register` view, add `create_action()` after creating the `Profile`
    object, as follows. The new line is highlighted in bold:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `register` 视图中，在创建 `Profile` 对象后添加 `create_action()`，如下所示。新行以粗体突出显示：
- en: '[PRE41]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In the `user_follow` view, add `create_action()`, as follows. The new line
    is highlighted in bold:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `user_follow` 视图中，添加 `create_action()`，如下所示。新行以粗体突出显示：
- en: '[PRE42]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: As you can see in the preceding code, thanks to the `Action` model and the helper
    function, it’s very easy to save new actions to the activity stream.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，由于 `Action` 模型和辅助函数，将新操作保存到活动流中非常简单。
- en: Displaying the activity stream
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示活动流
- en: 'Finally, you need a way to display the activity stream for each user. You will
    include the activity stream on the user’s dashboard. Edit the `views.py` file
    of the `account` application. Import the `Action` model and modify the `dashboard`
    view, as follows. The new code is highlighted in bold:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您需要一种方式来显示每个用户的活动流。您将在用户的仪表板上包含活动流。编辑 `account` 应用程序的 `views.py` 文件。导入 `Action`
    模型并修改 `dashboard` 视图，如下所示。新代码以粗体突出显示：
- en: '[PRE43]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In the preceding view, you retrieve all actions from the database, excluding
    the ones performed by the current user. By default, you retrieve the latest actions
    performed by all users on the platform.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的视图中，您从数据库中检索所有操作，但不包括当前用户执行的操作。默认情况下，您检索平台上所有用户执行的最新操作。
- en: If the user is following other users, you restrict the query to retrieve only
    the actions performed by the users they follow. Finally, you limit the result
    to the first 10 actions returned. You don’t use `order_by()` in the QuerySet because
    you rely on the default ordering that you provided in the `Meta` options of the
    `Action` model. Recent actions will come first since you set `ordering = ['-created']`
    in the `Action` model.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户正在关注其他用户，您将查询限制为仅检索他们关注的用户执行的操作。最后，您将结果限制为返回的前 10 个操作。您不使用 `order_by()`
    在 QuerySet 中，因为您依赖于在 `Action` 模型的 `Meta` 选项中提供的默认排序。最近的操作将首先显示，因为您在 `Action` 模型中设置了
    `ordering = ['-created']`。
- en: Optimizing QuerySets that involve related objects
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优化涉及相关对象的 QuerySets
- en: Every time you retrieve an `Action` object, you will usually access its related
    `User` object and the user’s related `Profile` object. The Django ORM offers a
    simple way to retrieve related objects at the same time, thereby avoiding additional
    queries to the database.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 每次检索 `Action` 对象时，您通常会访问其相关的 `User` 对象和用户的 `Profile` 对象。Django ORM 提供了一种简单的方法来同时检索相关对象，从而避免对数据库进行额外的查询。
- en: Using select_related()
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 select_related()
- en: Django offers a QuerySet method called `select_related()` that allows you to
    retrieve related objects for one-to-many relationships. This translates to a single,
    more complex QuerySet, but you avoid additional queries when accessing the related
    objects.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Django 提供了一个名为 `select_related()` 的 QuerySet 方法，允许您检索一对多关系中的相关对象。这相当于一个单一、更复杂的
    QuerySet，但在访问相关对象时可以避免额外的查询。
- en: The `select_related` method is for `ForeignKey` and `OneToOne` fields. It works
    by performing a SQL `JOIN` and including the fields of the related object in the
    `SELECT` statement.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`select_related` 方法用于 `ForeignKey` 和 `OneToOne` 字段。它通过执行 SQL `JOIN` 并在 `SELECT`
    语句中包含相关对象的字段来实现。'
- en: 'To take advantage of `select_related()`, edit the following line of the preceding
    code in the `views.py` file of the account application to add `select_related`,
    including the fields that you will use, as follows. Edit the `views.py` file of
    the account application. The new code is highlighted in bold:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 要利用 `select_related()`，请编辑账户应用程序 `views.py` 文件中前面的代码行，添加 `select_related`，包括您将使用的字段，如下所示。编辑
    `account` 应用程序的 `views.py` 文件。新代码以粗体突出显示：
- en: '[PRE44]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: You use `user__profile` to join the `Profile` table in a single SQL query. If
    you call `select_related()` without passing any arguments to it, it will retrieve
    objects from all `ForeignKey` relationships. Always limit `select_related()` to
    the relationships that will be accessed afterward.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 您使用 `user__profile` 在单个 SQL 查询中连接 `Profile` 表。如果您不对 `select_related()` 传递任何参数，它将检索所有
    `ForeignKey` 关系的对象。始终将 `select_related()` 限制在之后将访问的关系上。
- en: Using `select_related()` carefully can vastly improve execution time.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 谨慎使用 `select_related()` 可以显著提高执行时间。
- en: Using prefetch_related()
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 prefetch_related()
- en: '`select_related()` will help you boost the performance for retrieving related
    objects in one-to-many relationships. However, `select_related()` doesn’t work
    for many-to-many or many-to-one relationships (`ManyToMany` or reverse `ForeignKey`
    fields). Django offers a different QuerySet method called `prefetch_related` that
    works for many-to-many and many-to-one relationships in addition to the relationships
    supported by `select_related()`. The `prefetch_related()` method performs a separate
    lookup for each relationship and joins the results using Python. This method also
    supports the prefetching of `GenericRelation` and `GenericForeignKey`.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`select_related()`可以帮助你提高检索一对多关系中的相关对象的性能。然而，`select_related()`不适用于多对多或多对一关系（`ManyToMany`或反向`ForeignKey`字段）。Django提供了一个不同的查询集方法`prefetch_related`，它除了支持`select_related()`的关系外，还适用于多对多和多对一关系。`prefetch_related()`方法为每个关系执行单独的查找，并使用Python连接结果。此方法还支持`GenericRelation`和`GenericForeignKey`的预取。'
- en: 'Edit the `views.py` file of the `account` application and complete your query
    by adding `prefetch_related()` to it for the target `GenericForeignKey` field,
    as follows. The new code is highlighted in bold:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`account`应用程序的`views.py`文件，并为`target`的`GenericForeignKey`字段添加`prefetch_related()`以完成你的查询，如下所示。新的代码以粗体显示：
- en: '[PRE45]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This query is now optimized for retrieving the user actions, including related
    objects.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询现在已优化以检索用户动作，包括相关对象。
- en: Creating templates for actions
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建动作模板
- en: 'Let’s now create the template to display a particular `Action` object. Create
    a new directory inside the `actions` application directory and name it `templates`.
    Add the following file structure to it:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一个模板来显示特定的`Action`对象。在`actions`应用程序目录内创建一个新的目录，并将其命名为`templates`。向其中添加以下文件结构：
- en: '[PRE46]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Edit the `actions/action/detail.html` template file and add the following lines
    to it:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`actions/action/detail.html`模板文件，并添加以下行：
- en: '[PRE47]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This is the template used to display an `Action` object. First, you use the
    `{% with %}` template tag to retrieve the user performing the action and the related
    `Profile` object. Then, you display the image of the `target` object if the `Action`
    object has a related `target` object. Finally, you display the link to the user
    who performed the action, the verb, and the `target` object, if any.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这是用来显示`Action`对象的模板。首先，你使用`{% with %}`模板标签来检索执行动作的用户和相关的`Profile`对象。然后，如果`Action`对象有一个相关的`target`对象，就显示`target`对象的图片。最后，显示执行动作的用户、动词以及如果有，`target`对象的链接。
- en: 'Edit the `account/dashboard.html` template of the `account` application and
    append the following code highlighted in bold to the bottom of the `content` block:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`account/dashboard.html`模板的`account`应用程序，并将以下以粗体显示的代码追加到`content`块的底部：
- en: '[PRE48]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Open `http://127.0.0.1:8000/account/` in your browser. Log in as an existing
    user and perform several actions so that they get stored in the database. Then,
    log in using another user, follow the previous user, and take a look at the generated
    action stream on the dashboard page.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的浏览器中打开`http://127.0.0.1:8000/account/`。以现有用户身份登录并执行几个动作，以便它们被存储在数据库中。然后，使用另一个用户登录，关注前面的用户，并查看仪表板页面上的生成的动作流。
- en: 'It should look like the following:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该看起来像以下这样：
- en: '![Graphical user interface, text, application, chat or text message  Description
    automatically generated](img/B21088_07_08.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序，聊天或文本消息  自动生成的描述](img/B21088_07_08.png)'
- en: 'Figure 7.8: The activity stream for the current user'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8：当前用户的动态流
- en: '*Figure 7.8* image attributions*:*'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7.8* 图片归属：*'
- en: '*Tesla’s induction motor* by Ctac(license – Creative Commons Attribution Share-Alike
    3.0 Unported:[https://creativecommons.org/licenses/by-sa/3.0/](https://creativecommons.org/licenses/by-sa/3.0/))'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '*特斯拉的感应电机* 由 Ctac 提供（许可 – Creative Commons Attribution Share-Alike 3.0 Unported:
    [https://creativecommons.org/licenses/by-sa/3.0/](https://creativecommons.org/licenses/by-sa/3.0/))'
- en: '*Turing Machine Model Davey 2012* by Rocky Acosta(license – Creative Commons
    Attribution 3.0 Unported: [https://creativecommons.org/licenses/by/3.0/](https://creativecommons.org/licenses/by/3.0/))'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '*图灵机模型 Davey 2012* 由 Rocky Acosta 提供（许可 – Creative Commons Attribution 3.0
    Unported: [https://creativecommons.org/licenses/by/3.0/](https://creativecommons.org/licenses/by/3.0/))'
- en: '*Chick Corea* by ataelw (license – Creative Commons Attribution 2.0 Generic:
    [https://creativecommons.org/licenses/by/2.0/](https://creativecommons.org/licenses/by/2.0/))'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '* Chick Corea* 由 ataelw 提供（许可 – Creative Commons Attribution 2.0 Generic: [https://creativecommons.org/licenses/by/2.0/](https://creativecommons.org/licenses/by/2.0/))'
- en: You just created a complete activity stream for your users, and you can easily
    add new user actions to it. You can also add infinite scroll functionality to
    the activity stream by implementing the same AJAX paginator that you used for
    the `image_list` view. Next, you will learn how to use Django signals to denormalize
    action counts.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为你的用户创建了一个完整的活动流，并且可以轻松地向其中添加新的用户操作。你还可以通过实现用于 `image_list` 视图的相同 AJAX 分页器来向活动流添加无限滚动功能。接下来，你将学习如何使用
    Django 信号来反规范化操作计数。
- en: Using signals for denormalizing counts
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用信号进行反规范化计数
- en: There are some cases when you may want to denormalize your data. Denormalization
    is making data redundant in such a way that it optimizes read performance. For
    example, you might be copying related data to an object to avoid expensive read
    queries to the database when retrieving the related data. You have to be careful
    about denormalization and only start using it when you really need it. The biggest
    issue you will find with denormalization is that it’s difficult to keep your denormalized
    data updated.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些情况下，你可能想要对你的数据进行反规范化。反规范化是以一种使数据冗余的方式，从而优化读取性能。例如，你可能会将相关数据复制到对象中，以避免在检索相关数据时对数据库进行昂贵的读取查询。你必须小心处理反规范化，并且只有在真正需要时才开始使用它。你将发现反规范化的最大问题是难以保持反规范化数据更新。
- en: Let’s take a look at an example of how to improve your queries by denormalizing
    counts. You will denormalize data from your `Image` model and use Django signals
    to keep the data updated.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何通过反规范化计数来改进查询的示例。你将对 `Image` 模型的数据进行反规范化，并使用 Django 信号来保持数据更新。
- en: Working with signals
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与信号一起工作
- en: 'Django comes with a signal dispatcher that allows receiver functions to get
    notified when certain actions occur. Signals are very useful when you need your
    code to do something every time something else happens. Signals allow you to decouple
    logic: you can capture a certain action, regardless of the application or code
    that triggered that action, and implement logic that gets executed whenever that
    action occurs. For example, you can build a signal receiver function that gets
    executed every time a `User` object is saved. You can also create your own signals
    so that others can get notified when an event happens.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: Django 内置了一个信号调度器，允许接收器函数在特定动作发生时得到通知。当需要你的代码在每次其他动作发生时执行某些操作时，信号非常有用。信号允许你解耦逻辑：你可以捕获某个动作，无论触发该动作的应用或代码是什么，都可以实现当该动作发生时执行的逻辑。例如，你可以构建一个信号接收器函数，每次
    `User` 对象被保存时都会执行。你也可以创建自己的信号，以便在事件发生时通知其他人。
- en: 'Django provides several signals for models located at `django.db.models.signals`.
    Some of these signals are as follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: Django 在 `django.db.models.signals` 中提供了几个针对模型的信号。以下是一些信号：
- en: '`pre_save` and `post_save` are sent before or after calling the `save()` method
    of a model'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pre_save` 和 `post_save` 在调用模型的 `save()` 方法之前或之后发送'
- en: '`pre_delete` and `post_delete` are sent before or after calling the `delete()`
    method of a model or QuerySet'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pre_delete` 和 `post_delete` 在调用模型或 QuerySet 的 `delete()` 方法之前或之后发送'
- en: '`m2m_changed` is sent when a `ManyToManyField` on a model is changed'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当模型上的 `ManyToManyField` 发生变化时，会发送 `m2m_changed`
- en: These are just a subset of the signals provided by Django. You can find a list
    of all built-in signals at [https://docs.djangoproject.com/en/5.0/ref/signals/](https://docs.djangoproject.com/en/5.0/ref/signals/).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是 Django 提供的信号的一个子集。你可以在 [https://docs.djangoproject.com/en/5.0/ref/signals/](https://docs.djangoproject.com/en/5.0/ref/signals/)
    找到所有内置信号的列表。
- en: 'Let’s say you want to retrieve images by popularity. You can use the Django
    aggregation functions to retrieve images ordered by the number of users who like
    them. Remember that you used Django aggregation functions in *Chapter 3*, *Extending
    Your Blog Application*. The following code example will retrieve images according
    to their number of likes:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要按受欢迎程度检索图像。你可以使用 Django 聚合函数来检索按用户点赞数排序的图像。记住，你在 *第 3 章*，*扩展你的博客应用* 中使用了
    Django 聚合函数。以下代码示例将根据点赞数检索图像：
- en: '[PRE49]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: However, ordering images by counting their total likes is more expensive in
    terms of performance than ordering them by a field that stores total counts. You
    can add a field to the `Image` model to denormalize the total number of likes
    to boost performance in queries that involve this field. The issue is how to keep
    this field updated.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，按总点赞数对图像进行排序在性能上比按存储总计数的字段进行排序更昂贵。你可以在 `Image` 模型中添加一个字段来反规范化总点赞数，以提升涉及此字段的查询性能。问题是如何保持此字段更新。
- en: 'Edit the `models.py` file of the `images` application and add the following
    `total_likes` field to the `Image` model. The new code is highlighted in bold:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑 `images` 应用程序的 `models.py` 文件，并将以下 `total_likes` 字段添加到 `Image` 模型中。新的代码以粗体显示：
- en: '[PRE50]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The `total_likes` field will allow you to store the total count of users who
    like each image. Denormalizing counts is useful when you want to filter or order
    QuerySets by them. We have added a database index for the `total_likes` field
    in descending order because we plan to retrieve images ordered by their total
    likes in descending order.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`total_likes` 字段将允许你存储喜欢每个图像的用户总数。当你想通过它们过滤或排序查询集时，反规范化计数是有用的。我们为 `total_likes`
    字段添加了一个降序的数据库索引，因为我们计划按总喜欢数降序检索图像。'
- en: There are several ways to improve performance that you have to take into account
    before denormalizing fields. Consider database indexes, query optimization, and
    caching before starting to denormalize your data.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在对字段进行反规范化之前，你必须考虑几种提高性能的方法。在开始反规范化你的数据之前，考虑数据库索引、查询优化和缓存。
- en: 'Run the following command to create the migrations for adding the new field
    to the database table:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以创建向数据库表添加新字段的迁移：
- en: '[PRE51]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'You should see the following output:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '[PRE52]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Then, run the following command to apply the migration:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，运行以下命令以应用迁移：
- en: '[PRE53]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The output should include the following line:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应包括以下行：
- en: '[PRE54]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: You need to attach a receiver function to the `m2m_changed` signal.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要将一个接收器函数附加到 `m2m_changed` 信号。
- en: 'Create a new file inside the `images` application directory and name it `signals.py`.
    Add the following code to it:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `images` 应用程序目录内创建一个新文件，并命名为 `signals.py`。向其中添加以下代码：
- en: '[PRE55]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: First, you register the `users_like_changed` function as a receiver function
    using the `receiver()` decorator. You attach it to the `m2m_changed` signal. Then,
    you connect the function to `Image.users_like.through` so that the function is
    only called if the `m2m_changed` signal has been launched by this sender. There
    is an alternate method for registering a receiver function; it consists of using
    the `connect()` method of the `Signal` object.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用 `receiver()` 装饰器将 `users_like_changed` 函数注册为一个接收器函数，并将其附加到 `m2m_changed`
    信号上。然后，将函数连接到 `Image.users_like.through`，这样只有在 `m2m_changed` 信号由这个发送者触发时，函数才会被调用。注册接收器函数的另一种方法是使用
    `Signal` 对象的 `connect()` 方法。
- en: Django signals are synchronous and blocking. Don’t confuse signals with asynchronous
    tasks. However, you can combine both to launch asynchronous tasks when your code
    gets notified by a signal. You will learn how to create asynchronous tasks with
    Celery in *Chapter 8*, *Building an Online Shop*.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: Django 信号是同步和阻塞的。不要将信号与异步任务混淆。然而，你可以将两者结合起来，当你的代码被信号通知时启动异步任务。你将在 *第8章*，*构建在线商店*
    中学习如何使用 Celery 创建异步任务。
- en: You have to connect your receiver function to a signal so that it gets called
    every time the signal is sent. The recommended method for registering your signals
    is by importing them into the `ready()` method of your application configuration
    class. Django provides an application registry that allows you to configure and
    introspect your applications.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须将你的接收器函数连接到一个信号，以便在信号发送时被调用。注册你的信号推荐的方法是导入它们到你的应用程序配置类的 `ready()` 方法中。Django
    提供了一个应用程序注册器，允许你配置和检查你的应用程序。
- en: Application configuration classes
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序配置类
- en: Django allows you to specify configuration classes for your applications. When
    you create an application using the `startapp` command, Django adds an `apps.py`
    file to the application directory, including a basic application configuration
    that inherits from the `AppConfig` class.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: Django 允许你为你的应用程序指定配置类。当你使用 `startapp` 命令创建一个应用程序时，Django 会将一个 `apps.py` 文件添加到应用程序目录中，包括一个继承自
    `AppConfig` 类的基本应用程序配置。
- en: The application configuration class allows you to store metadata and the configuration
    for the application, and it provides introspection for the application. You can
    find more information about application configurations at [https://docs.djangoproject.com/en/5.0/ref/applications/](https://docs.djangoproject.com/en/5.0/ref/applications/).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序配置类允许你存储元数据和应用程序的配置，并提供应用程序的检查。你可以在 [https://docs.djangoproject.com/en/5.0/ref/applications/](https://docs.djangoproject.com/en/5.0/ref/applications/)
    找到更多关于应用程序配置的信息。
- en: In order to register your signal receiver functions, when you use the `receiver()`
    decorator, you just need to import the `signals` module of your application inside
    the `ready()` method of the application configuration class. This method is called
    as soon as the application registry is fully populated. Any other initializations
    for your application should also be included in this method.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 为了注册你的信号接收器函数，当你使用`receiver()`装饰器时，你只需要在应用配置类的`ready()`方法中导入应用中的`signals`模块。该方法在应用注册表完全填充后立即调用。任何其他的应用初始化也应该包含在这个方法中。
- en: 'Edit the `apps.py` file of the `images` application and add the following code
    highlighted in bold:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`images`应用的`apps.py`文件，并添加以下加粗的代码：
- en: '[PRE56]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: You import the signals for this application in the `ready()` method so that
    they are imported when the `images` application is loaded.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这个应用的`ready()`方法中导入信号，以便在`images`应用加载时导入。
- en: 'Run the development server with the following command:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令运行开发服务器：
- en: '[PRE57]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Open your browser to view an image detail page and click on the **Like** button.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你的浏览器查看图片详情页面，并点击**点赞**按钮。
- en: 'Go to the administration site, navigate to the edit image URL, such as `http://127.0.0.1:8000/admin/images/image/1/change/`,
    and take a look at the `total_likes` attribute. You should see that the `total_likes`
    attribute is updated with the total number of users who like the image, as follows:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 前往管理站点，导航到编辑图片的URL，例如`http://127.0.0.1:8000/admin/images/image/1/change/`，并查看`total_likes`属性。你应该看到`total_likes`属性已更新为喜欢该图片的用户总数，如下所示：
- en: '![Graphical user interface  Description automatically generated](img/B21088_07_09.png)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面  自动生成的描述](img/B21088_07_09.png)'
- en: 'Figure 7.9: The image edit page on the administration site, including denormalization
    for total likes'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.9：管理站点上的图片编辑页面，包括总点赞数的反规范化
- en: Now, you can use the `total_likes` attribute to order images by popularity or
    display the value anywhere, avoiding using complex queries to calculate it.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用`total_likes`属性按受欢迎程度排序图片或显示该值，避免使用复杂的查询来计算它。
- en: 'Consider the following query to get images ordered by their likes count in
    descending order:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下查询以按点赞数降序获取图片：
- en: '[PRE58]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The preceding query can now be written as follows:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的查询现在可以写成以下形式：
- en: '[PRE59]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This results in a less expensive SQL query thanks to denormalizing the total
    likes for images. You have also learned how you can use Django signals.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这得益于对图片总点赞数的反规范化，从而产生了更经济的SQL查询。你也已经学会了如何使用Django信号。
- en: Use signals with caution since they make it difficult to know the control flow.
    In many cases, you can avoid using signals if you know which receivers need to
    be notified.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 使用信号时要谨慎，因为它们会使控制流难以理解。在许多情况下，如果你知道哪些接收器需要被通知，你可以避免使用信号。
- en: You will need to set initial counts for the rest of the `Image` objects to match
    the current status of the database.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要为其余的`Image`对象设置初始计数，以匹配数据库的当前状态。
- en: 'Open the shell with the following command:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令打开shell：
- en: '[PRE60]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Execute the following code in the shell:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在shell中执行以下代码：
- en: '[PRE61]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: You have manually updated the likes count for the existing images in the database.
    From now on, the `users_like_changed` signal receiver function will handle updating
    the `total_likes` field whenever the many-to-many related objects change.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经手动更新了数据库中现有图片的点赞数。从现在起，`users_like_changed`信号接收器函数将处理在多对多相关对象更改时更新`total_likes`字段。
- en: Next, you will learn how to use Django Debug Toolbar to obtain relevant debug
    information for requests, including execution time, SQL queries executed, templates
    rendered, signals registered, and much more.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将学习如何使用Django调试工具栏来获取有关请求的相关调试信息，包括执行时间、执行的SQL查询、渲染的模板、注册的信号等等。
- en: Using Django Debug Toolbar
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Django调试工具栏
- en: By this point, you will already be familiar with Django’s debug page. Throughout
    the previous chapters, you have seen the distinctive yellow and gray Django debug
    page several times.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经开始熟悉Django的调试页面了。在前面的章节中，你已经多次看到了独特的黄色和灰色Django调试页面。
- en: For example, in *Chapter 2*, *Enhancing Your Blog with Advanced Features*, in
    the *Handling pagination errors* section, the debug page showed information related
    to unhandled exceptions when implementing object pagination.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在*第2章*，*使用高级功能增强您的博客*，在*处理分页错误*部分，调试页面显示了在实现对象分页时未处理的异常的相关信息。
- en: The Django debug page provides useful debug information. However, there is a
    Django application that includes more detailed debug information and can be really
    helpful when developing.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: Django调试页面提供了有用的调试信息。然而，有一个Django应用程序包含更详细的调试信息，在开发过程中非常有帮助。
- en: Django Debug Toolbar is an external Django application that allows you to see
    relevant debug information about the current request/response cycle. The information
    is divided into multiple panels that show different information, including request/response
    data, Python package versions used, execution time, settings, headers, SQL queries,
    templates used, cache, signals, and logging.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: Django Debug Toolbar是一个外部Django应用程序，允许你查看当前请求/响应周期相关的调试信息。这些信息被分为多个面板，显示不同的信息，包括请求/响应数据、使用的Python包版本、执行时间、设置、头部、SQL查询、使用的模板、缓存、信号和日志。
- en: You can find the documentation for Django Debug Toolbar at [https://django-debug-toolbar.readthedocs.io/](https://django-debug-toolbar.readthedocs.io/).
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://django-debug-toolbar.readthedocs.io/](https://django-debug-toolbar.readthedocs.io/)找到Django
    Debug Toolbar的文档。
- en: Installing Django Debug Toolbar
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Django Debug Toolbar
- en: 'Install `django-debug-toolbar` via `pip` using the following command:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令通过`pip`安装`django-debug-toolbar`：
- en: '[PRE62]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Edit the `settings.py` file of your project and add `debug_toolbar` to the
    `INSTALLED_APPS` setting, as follows. The new line is highlighted in bold:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑你项目的`settings.py`文件，并将`debug_toolbar`添加到`INSTALLED_APPS`设置中，如下所示。新行加粗：
- en: '[PRE63]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'In the same file, add the following line highlighted in bold to the `MIDDLEWARE`
    setting:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一文件中，将以下加粗的行添加到`MIDDLEWARE`设置中：
- en: '[PRE64]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Django Debug Toolbar is mostly implemented as middleware. The order of `MIDDLEWARE`
    is important. `DebugToolbarMiddleware` has to be placed before any other middleware,
    except for middleware that encodes the response’s content, such as `GZipMiddleware`,
    which, if present, should come first.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: Django Debug Toolbar主要作为中间件实现。`MIDDLEWARE`的顺序很重要。`DebugToolbarMiddleware`必须放在任何其他中间件之前，除了那些编码响应内容的中间件，例如`GZipMiddleware`，如果存在，则应该放在最前面。
- en: 'Add the following lines at the end of the `settings.py` file:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在`settings.py`文件的末尾添加以下行：
- en: '[PRE65]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Django Debug Toolbar will only display if your IP address matches an entry in
    the `INTERNAL_IPS` setting. To prevent showing debug information in production,
    Django Debug Toolbar checks that the `DEBUG` setting is `True`.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: Django Debug Toolbar只有在你的IP地址与`INTERNAL_IPS`设置中的条目匹配时才会显示。为了防止在生产环境中显示调试信息，Django
    Debug Toolbar会检查`DEBUG`设置是否为`True`。
- en: 'Edit the main `urls.py` file of your project and add the following URL pattern
    highlighted in bold to `urlpatterns`:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑你项目的`urls.py`主文件，并将以下加粗的URL模式添加到`urlpatterns`中：
- en: '[PRE66]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Django Debug Toolbar is now installed in your project. Let’s try it out!
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: Django Debug Toolbar现在已安装到你的项目中。让我们试试它！
- en: 'Run the development server with the following command:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令运行开发服务器：
- en: '[PRE67]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Open `http://127.0.0.1:8000/images/` with your browser. You should now see
    a collapsible sidebar on the right. It should look as follows:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你的浏览器打开`http://127.0.0.1:8000/images/`。你现在应该看到一个可折叠的侧边栏在右侧。它应该看起来如下：
- en: '![](img/B21088_07_10.png)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21088_07_10.png)'
- en: 'Figure 7.10: The Django Debug Toolbar sidebar'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.10：Django Debug Toolbar侧边栏
- en: '*Figure 7.10* image attributions:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7.10* 图片归属：'
- en: '*Chick Corea* by ataelw (license – Creative Commons Attribution 2.0 Generic:
    [https://creativecommons.org/licenses/by/2.0/](https://creativecommons.org/licenses/by/2.0/))'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '* Chick Corea* 由ataelw创作（许可 – Creative Commons Attribution 2.0 Generic: [https://creativecommons.org/licenses/by/2.0/](https://creativecommons.org/licenses/by/2.0/))'
- en: '*Al Jarreau Düsseldorf 1981* by Eddi Laumanns aka RX-Guru (license – Creative
    Commons Attribution 3.0 Unported: [https://creativecommons.org/licenses/by/3.0/](https://creativecommons.org/licenses/by/3.0/))'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '*Al Jarreau Düsseldorf 1981* 由Eddi Laumanns即RX-Guru创作（许可 – Creative Commons
    Attribution 3.0 Unported: [https://creativecommons.org/licenses/by/3.0/](https://creativecommons.org/licenses/by/3.0/))'
- en: '*Al Jarreau* by Kingkongphoto and www.celebrity-photos.com (license – Creative
    Commons Attribution-ShareAlike 2.0 Generic: [https://creativecommons.org/licenses/by-sa/2.0/](https://creativecommons.org/licenses/by-sa/2.0/))'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '*Al Jarreau* 由Kingkongphoto和www.celebrity-photos.com创作（许可 – Creative Commons
    Attribution-ShareAlike 2.0 Generic: [https://creativecommons.org/licenses/by-sa/2.0/](https://creativecommons.org/licenses/by-sa/2.0/))'
- en: If the Debug Toolbar doesn’t appear, check the RunServer shell console log.
    If you see a MIME type error, it is most likely that your MIME map files are incorrect
    or need to be updated.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 如果调试工具栏没有出现，检查RunServer shell控制台日志。如果你看到一个MIME类型错误，这很可能是你的MIME映射文件不正确或需要更新。
- en: 'You can apply the correct mapping for JavaScript and CSS files by adding the
    following lines to the `settings.py` file:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在`settings.py`文件中添加以下行来应用JavaScript和CSS文件的正确映射：
- en: '[PRE68]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Django Debug Toolbar panels
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Django调试工具栏面板
- en: Django Debug Toolbar features multiple panels that organize the debug information
    for the request/response cycle. The sidebar contains links to each panel, and
    you can use the checkbox of any panel to activate or deactivate it. The change
    will be applied to the next request. This is useful when we are not interested
    in a specific panel, but the calculation adds too much overhead to the request.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: Django调试工具栏包含多个面板，用于组织请求/响应周期的调试信息。侧边栏包含每个面板的链接，您可以使用任何面板的复选框来激活或停用它。更改将应用于下一个请求。当我们对特定面板不感兴趣，但计算对请求的负载太大时，这很有用。
- en: 'Click on **Time** in the sidebar menu. You will see the following panel:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在侧边栏菜单中点击**时间**。您将看到以下面板：
- en: '![](img/B21088_07_11.png)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21088_07_11.png)'
- en: 'Figure 7.11: Time panel – Django Debug Toolbar'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.11：时间面板 – Django调试工具栏
- en: The **Time** panel includes a timer for the different phases of the request/response
    cycle. It also shows CPU, elapsed time, and the number of context switches. If
    you are using Windows, you won’t be able to see the **Time** panel. In Windows,
    only the total time is available and displayed in the toolbar.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '**时间**面板包括请求/响应周期不同阶段的计时器。它还显示了CPU、经过的时间和上下文切换次数。如果您使用的是Windows，您将无法看到**时间**面板。在Windows中，只有总时间可用，并在工具栏中显示。'
- en: 'Click on **SQL** in the sidebar menu. You will see the following panel:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在侧边栏菜单中点击**SQL**。您将看到以下面板：
- en: '![](img/B21088_07_12.png)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21088_07_12.png)'
- en: 'Figure 7.12: SQL panel – Django Debug Toolbar'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.12：SQL面板 – Django调试工具栏
- en: Here, you can see the different SQL queries that have been executed. This information
    can help you identify unnecessary queries, duplicated queries that can be reused,
    or long-running queries that can be optimized. Based on your findings, you can
    improve QuerySets in your views, create new indexes on model fields if necessary,
    or cache information when needed. In this chapter, you learned how to optimize
    queries that involve relationships using `select_related()` and `prefetch_related()`.
    You will learn how to cache data in *Chapter 14*, *Rendering and Caching Content*.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以查看已执行的不同SQL查询。这些信息可以帮助您识别不必要的查询、可重用的重复查询或可优化的长时间运行查询。根据您的发现，您可以在视图中改进查询集，如果需要，在模型字段上创建新的索引，或在需要时缓存信息。在本章中，您学习了如何使用`select_related()`和`prefetch_related()`优化涉及关系的查询。您将在第14章“渲染和缓存内容”中学习如何缓存数据。
- en: 'Click on **Templates** in the sidebar menu. You will see the following panel:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在侧边栏菜单中点击**模板**。您将看到以下面板：
- en: '![](img/B21088_07_13.png)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21088_07_13.png)'
- en: 'Figure 7.13: Templates panel – Django Debug Toolbar'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.13：模板面板 – Django调试工具栏
- en: This panel shows the different templates used when rendering the content, the
    template paths, and the context used. You can also see the different context processors
    used. You will learn about context processors in *Chapter 8*, *Building an Online
    Shop*.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 此面板显示了渲染内容时使用的不同模板、模板路径以及使用的上下文。您还可以看到使用的不同上下文处理器。您将在第8章“构建在线商店”中了解上下文处理器。
- en: 'Click on **Signals** in the sidebar menu. You will see the following panel:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在侧边栏菜单中点击**信号**。您将看到以下面板：
- en: '![](img/B21088_07_14.png)'
  id: totrans-354
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21088_07_14.png)'
- en: 'Figure 7.14: Signals panel – Django Debug Toolbar'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.14：信号面板 – Django调试工具栏
- en: In this panel, you can see all the signals that are registered in your project
    and the receiver functions attached to each signal. For example, you can find
    the `users_like_changed` receiver function you created before, attached to the
    `m2m_changed` signal. The other signals and receivers are part of the different
    Django applications.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在此面板中，您可以查看在您的项目中注册的所有信号以及附加到每个信号的接收器函数。例如，您可以找到之前创建的`users_like_changed`接收器函数，它附加到`m2m_changed`信号。其他信号和接收器是不同Django应用程序的一部分。
- en: We have reviewed some of the panels that ship with Django Debug Toolbar. Besides
    the built-in panels, you can find additional third-party panels that you can download
    and use at [https://django-debug-toolbar.readthedocs.io/en/latest/panels.html#third-party-panels](https://django-debug-toolbar.readthedocs.io/en/latest/panels.html#third-party-panels).
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经审查了Django调试工具栏附带的一些面板。除了内置面板外，您还可以找到额外的第三方面板，您可以从[https://django-debug-toolbar.readthedocs.io/en/latest/panels.html#third-party-panels](https://django-debug-toolbar.readthedocs.io/en/latest/panels.html#third-party-panels)下载并使用。
- en: Django Debug Toolbar commands
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Django调试工具栏命令
- en: Besides the request/response debug panels, Django Debug Toolbar provides a management
    command to debug SQL for ORM calls. The management command `debugsqlshell` replicates
    the Django `shell` command but it outputs SQL statements for queries performed
    with the Django ORM.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the shell with the following command:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Execute the following code:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'You will see the following output:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: You can use this command to test ORM queries before adding them to your views.
    You can check the resulting SQL statement and the execution time for each ORM
    call.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will learn how to count image views using Redis, an
    in-memory database that provides low latency and high-throughput data access.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: Counting image views with Redis
  id: totrans-368
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Redis is an advanced key/value database that allows you to save different types
    of data. It also has extremely fast I/O operations. Redis stores everything in
    memory, but the data can be persisted by dumping the dataset to disk every once
    in a while, or by adding each command to a log. Redis is very versatile compared
    to other key/value stores: it provides a set of powerful commands and supports
    diverse data structures, such as strings, hashes, lists, sets, ordered sets, and
    even `bitmap` or `HyperLogLog` methods.'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: Although SQL is best suited to schema-defined persistent data storage, Redis
    offers numerous advantages when dealing with rapidly changing data, volatile storage,
    or when a quick cache is needed. Let’s take a look at how Redis can be used to
    build new functionality in your project.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information about Redis on its home page at [https://redis.io/](https://redis.io/).
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: Redis provides a Docker image that makes it very easy to deploy a Redis server
    with a standard configuration.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: Installing Redis
  id: totrans-373
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To install the Redis Docker image, make sure Docker is installed on your machine.
    You learned how to install Docker in *Chapter 3*, *Extending Your Blog Application*.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command from the shell:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: This will download the Redis Docker image to your local machine. You can find
    information about the official Redis Docker image at [https://hub.docker.com/_/redis](https://hub.docker.com/_/redis).
    You can find other alternative methods to install Redis at [https://redis.io/download/](https://redis.io/download/).
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following command in the shell to start the Redis Docker container:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: With this command, we run Redis in a Docker container. The `-it` option tells
    Docker to take you straight inside the container for interactive input. The `--rm`
    option tells Docker to automatically clean up the container and remove the file
    system when the container exits. The `--name` option is used to assign a name
    to the container. The `-p` option is used to publish the `6379` port on which
    Redis runs to the same host interface port. `6379` is the default port for Redis.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: 'You should see an output that ends with the following lines:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Keep the Redis server running on port `6379` and open another shell. Start
    the Redis client with the following command:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'You will see a line with the hash symbol:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Start the Redis client with the following command:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'You will see the Redis client shell prompt, like this:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The Redis client allows you to execute Redis commands directly from the shell.
    Let’s try some commands. Enter the `SET` command in the Redis shell to store a
    value in a key:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The preceding command creates a `name` key with the string value `"Peter"` in
    the Redis database. The `OK` output indicates that the key has been saved successfully.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, retrieve the value using the `GET` command, as follows:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'You can also check whether a key exists using the `EXISTS` command. This command
    returns `1` if the given key exists and `0` otherwise:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'You can set the time for a key to expire using the `EXPIRE` command, which
    allows you to set the time-to-live in seconds. Another option is using the `EXPIREAT`
    command, which expects a Unix timestamp. Key expiration is useful for using Redis
    as a cache or to store volatile data:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Wait for more than two seconds and try to get the same key again:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The `(nil)` response is a null response and means that no key has been found.
    You can also delete any key using the `DEL` command, as follows:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: These are just basic commands for key operations. You can find all Redis commands
    at [https://redis.io/commands/](https://redis.io/commands/) and all Redis data
    types at [https://redis.io/docs/manual/data-types/](https://redis.io/docs/manual/data-types/).
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: Using Redis with Python
  id: totrans-405
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You will need Python bindings for Redis. Install `redis-py` via `pip` using
    the following command:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: You can find the `redis-py` documentation at [https://redis-py.readthedocs.io/](https://redis-py.readthedocs.io/).
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: 'The `redis-py` package interacts with Redis, providing a Python interface that
    follows the Redis command syntax. Open the Python shell with the following command:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Execute the following code:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: The preceding code creates a connection with the Redis database. In Redis, databases
    are identified by an integer index instead of a database name. By default, a client
    is connected to database `0`. The number of available Redis databases is set to
    `16` but you can change this in the `redis.conf` configuration file.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, set a key using the Python shell:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The command returns `True`, indicating that the key has been successfully created.
    Now you can retrieve the key using the `get()` command:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: As you will note from the preceding code, the methods of Redis follow the Redis
    command syntax.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s integrate Redis into your project. Edit the `settings.py` file of the
    `bookmarks` project and add the following settings to it:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: These are the settings for the Redis server and the database that you will use
    for your project.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: Storing image views in Redis
  id: totrans-422
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s find a way to store the total number of times an image has been viewed.
    If you implement this using the Django ORM, it will involve a SQL `UPDATE` query
    every time an image is displayed.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: If you use Redis instead, you just need to increment a counter stored in memory,
    resulting in much better performance and less overhead.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `views.py` file of the `images` application and add the following
    code to it after the existing `import` statements:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'With the preceding code, you establish the Redis connection in order to use
    it in your views. Edit the `views.py` file of the `images` application and modify
    the `image_detail` view, like this. The new code is highlighted in bold:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: In this view, you use the `incr` command, which increments the value of a given
    key by `1`. If the key doesn’t exist, the `incr` command creates it. The `incr()`
    method returns the final value of the key after performing the operation. You
    store the value in the `total_views` variable and pass it into the template context.
    You build the Redis key using a notation such as `object-type:id:field` (for example,
    `image:33:id`).
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: The convention for naming Redis keys is to use a colon sign as a separator for
    creating namespaced keys. By doing so, the key names are especially verbose, and
    related keys share part of the same schema in their names.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `images/image/detail.html` template of the `images` application and
    add the following code highlighted in bold:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Run the development server with the following command:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Open an image detail page in your browser and reload it several times. You
    will see that each time the view is processed, the total views displayed is incremented
    by 1\. Take a look at the following example:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application, chat or text message  Description
    automatically generated](img/B21088_07_15.png)'
  id: totrans-436
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.15: The image detail page, including the count of likes and views'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: Great! You have successfully integrated Redis into your project to count image
    views. In the next section, you will learn how to build a ranking of the most
    viewed images with Redis.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: Storing a ranking in Redis
  id: totrans-439
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will now create something more complex with Redis. We will use Redis to store
    a ranking of the most viewed images on the platform. We will use Redis sorted
    sets for this. A sorted set is a non-repeating collection of strings in which
    every member is associated with a score. Items are sorted by their score.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `views.py` file of the `images` application and add the following
    code highlighted in bold to the `image_detail` view:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: You use the `zincrby()` command to store image views in a sorted set with the
    `image:ranking` key. You will store the image `id` and a related score of `1`,
    which will be added to the total score of this element in the sorted set. This
    will allow you to keep track of all image views globally and have a sorted set
    ordered by the total number of views.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, create a new view to display the ranking of the most viewed images. Add
    the following code to the `views.py` file of the `images` application:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'The `image_ranking` view works like this:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: You use the `zrange()` command to obtain the elements in the sorted set. This
    command expects a custom range according to the lowest and highest scores. By
    using `0` as the lowest and `-1` as the highest score, you are telling Redis to
    return all elements in the sorted set. You also specify `desc=True` to retrieve
    the elements ordered by descending score. Finally, you slice the results using
    `[:10]` to get the first 10 elements with the highest score.
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You build a list of returned image IDs and store it in the `image_ranking_ids`
    variable as a list of integers. You retrieve the `Image` objects for those IDs
    and force the query to be executed using the `list()` function. It is important
    to force the QuerySet execution because you will use the `sort()` method on it
    (at this point, you need a list of objects instead of a QuerySet).
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You sort the `Image` objects by their index of appearance in the image ranking.
    Now you can use the `most_viewed` list in your template to display the 10 most
    viewed images.
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new `ranking.html` template inside the `images/image/` template directory
    of the `images` application and add the following code to it:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: The template is pretty straightforward. You iterate over the `Image` objects
    contained in the `most_viewed` list and display their names, including a link
    to the image detail page.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you need to create a URL pattern for the new view. Edit the `urls.py`
    file of the `images` application and add the following URL pattern highlighted
    in bold:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Run the development server, access your site in your web browser, and load
    the image detail page multiple times for different images. Then, access `http://127.0.0.1:8000/images/ranking/`
    from your browser. You should be able to see an image ranking, as follows:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, table  Description automatically generated](img/B21088_07_16.png)'
  id: totrans-456
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.16: The ranking page built with data retrieved from Redis'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: Great! You just created a ranking with Redis.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: Next steps with Redis
  id: totrans-459
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Redis is not a replacement for your SQL database but it does offer fast in-memory
    storage that is more suitable for certain tasks. Add it to your stack and use
    it when you really feel it’s needed. The following are some scenarios in which
    Redis could be useful:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: '**Counting**: As you have seen, it is very easy to manage counters with Redis.
    You can use `incr()` and `incrby()` for counting stuff.'
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Storing the latest items**: You can add items to the start/end of a list
    using `lpush()` and `rpush()`. Remove and return the first/last element using
    `lpop()`/`rpop()`. You can trim the list’s length using `ltrim()` to maintain
    its length.'
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Queues**: In addition to `push` and `pop` commands, Redis offers the blocking
    of queue commands.'
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Caching**: Using `expire()` and `expireat()` allows you to use Redis as a
    cache. You can also find third-party Redis cache backends for Django.'
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pub/sub**: Redis provides commands for subscribing/unsubscribing and sending
    messages to channels.'
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rankings and leaderboards**: Redis’s sorted sets with scores make it very
    easy to create leaderboards.'
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Real-time tracking**: Redis’s fast I/O makes it perfect for real-time scenarios.'
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  id: totrans-468
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you built a follow system using many-to-many relationships
    with an intermediate model. You also created an activity stream using generic
    relations and you optimized QuerySets to retrieve related objects. This chapter
    then introduced you to Django signals, and you created a signal receiver function
    to denormalize related object counts. We covered application configuration classes,
    which you used to load your signal handlers. You added Django Debug Toolbar to
    your project. You also learned how to install and configure Redis in your Django
    project. Finally, you used Redis in your project to store item views, and you
    built an image ranking with Redis.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to build an online shop. You will create
    a product catalog and build a shopping cart using sessions. You will learn how
    to create custom context processors. You will also manage customer orders and
    send asynchronous notifications using Celery and RabbitMQ.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: Expanding your project using AI
  id: totrans-471
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you are presented with a task to extend your project, accompanied
    by a sample prompt for ChatGPT to assist you. To engage with ChatGPT, visit [https://chat.openai.com/](https://chat.openai.com/).
    If this is your first interaction with ChatGPT, you can revisit the *Expanding
    your project using AI* section in *Chapter 3*, *Extending Your Blog Application*.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: In this project example, you have learned how to use Django signals and successfully
    implemented a signal receiver to update the total number of image likes whenever
    there is a change in the like count. Now, let’s leverage ChatGPT to explore the
    implementation of a signal receiver that automatically generates a related `Profile`
    object whenever a `User` object is created. You can use the prompt provided at
    [https://github.com/PacktPublishing/Django-5-by-example/blob/main/Chapter07/prompts/task.md](https://github.com/PacktPublishing/Django-5-by-example/blob/main/Chapter07/prompts/task.md).
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: After successfully implementing the signal receiver, you can remove the manual
    profile creation steps previously included in the `register` view of the `account`
    application and from the social authentication pipeline. With the receiver function
    now attached to the `post_save` signal of the `User` model, profiles will be automatically
    created for new users.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: If you’re having trouble understanding a particular concept or topic in the
    book, ask ChatGPT to provide additional examples or to explain the concept in
    a different way. This personalized approach can reinforce your learning and ensure
    you grasp complex topics.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: Additional resources
  id: totrans-476
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following resources provide additional information related to the topics
    covered in this chapter:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: 'Source code for this chapter: [https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter07](https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter07)'
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Custom user models: [https://docs.djangoproject.com/en/5.0/topics/auth/customizing/#specifying-a-custom-user-model](https://docs.djangoproject.com/en/5.0/topics/auth/customizing/#specifying-a-custom-user-model)'
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `contenttypes` framework: [https://docs.djangoproject.com/en/5.0/ref/contrib/contenttypes/](https://docs.djangoproject.com/en/5.0/ref/contrib/contenttypes/)'
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Built-in Django signals: [https://docs.djangoproject.com/en/5.0/ref/signals/](https://docs.djangoproject.com/en/5.0/ref/signals/)'
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Application configuration classes: [https://docs.djangoproject.com/en/5.0/ref/applications/](https://docs.djangoproject.com/en/5.0/ref/applications/)'
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Django Debug Toolbar documentation: [https://django-debug-toolbar.readthedocs.io/](https://django-debug-toolbar.readthedocs.io/)'
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Django Debug Toolbar third-party panels: [https://django-debug-toolbar.readthedocs.io/en/latest/panels.html#third-party-panels](https://django-debug-toolbar.readthedocs.io/en/latest/panels.html#third-party-panels)'
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Redis in-memory data store: [https://redis.io/](https://redis.io/)'
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Official Redis Docker image: [https://hub.docker.com/_/redis](https://hub.docker.com/_/redis).'
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Redis download options: [https://redis.io/download/](https://redis.io/download/)'
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Redis commands: [https://redis.io/commands/](https://redis.io/commands/)'
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Redis data types: [https://redis.io/docs/manual/data-types/](https://redis.io/docs/manual/data-types/)'
  id: totrans-489
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`redis-py` documentation: [https://redis-py.readthedocs.io/](https://redis-py.readthedocs.io/)'
  id: totrans-490
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
