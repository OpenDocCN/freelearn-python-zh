<html><head></head><body>
  <div id="sbo-rt-content"><div class="chapter" title="Chapter 10. Grok and Relational Databases"><div class="titlepage"><div><div><h1 class="title"><a id="ch10"/>Chapter 10. Grok and Relational Databases</h1></div></div></div><p>So far, we have been using the ZODB for data storage. As we saw in the last chapter, this is a fine solution. Grok developers truly love the ZODB and would like to see it used a lot more across the Python world. Furthermore, Grok takes excellent advantage of its power and features.</p><p>Having said that, relational databases are currently the most commonly used persistence mechanism for web applications. For one thing, they are reliable, efficient, and scalable. They are also fairly well understood, and many novice web developers already happen to know a thing or two about SQL.</p><p>The fact that relational databases are used consistently for non-web-development projects also makes them more likely to be needed in web applications where access to existing information is required.</p><p>In other words, the ZODB is great, but a good web framework needs to offer ample support for working with relational databases. Of course, Grok is such a framework, so in this chapter, we'll find out what facilities Grok has for relational database access. Here are some specific things that we will cover:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Why is it important that Grok allows developers to use relational databases easily</li><li class="listitem" style="list-style-type: disc">What an Object Relational Mapper is</li><li class="listitem" style="list-style-type: disc">How to use SQLAlchemy with Grok</li><li class="listitem" style="list-style-type: disc">How to change our authentication mechanism to use a relational database instead of the ZODB</li></ul></div><div class="section" title="Object Relational Mappers"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec01"/>Object Relational Mappers</h1></div></div></div><p>Python is an object-oriented language, and Grok uses this object orientation heavily. In practice, this means that we define models with properties and methods, and each model instance represents an object. Thus, we have project or to-do list objects, and our views work with them, and access their properties and call their methods, freely.<a id="id317" class="indexterm"/>
</p><p>When it's time to save our objects, the ZODB comes in handy because we just grab the whole object and stuff it in there, which is why it's called an object database. Relational databases, on the other hand, work in a very different way. They store everything using tables and columns, usually dividing an object into several related tables.</p><p>Obviously, we can't just take one of our to-do list objects and put it into a relational database; some translation is needed, even if there's only one table involved. Relational databases use the SQL language to receive read and write commands for a table or tables, so we could take our object's properties one-by-one, generate a SQL statement as a string, and send it to the database. We would then reverse the process to assemble the object again from the database columns. This doesn't really scale well, so the usual solution is to use a library specifically designed for disassembling objects into tables and assembling them back when queried, transparently generating the required SQL to make it work. These libraries are known as<span class="strong"><strong> Object Relational Mappers</strong></span>, or<span class="strong"><strong> ORMs</strong></span> for short.</p><p>ORMs are also very good at keeping the code independent of the database used, because the developer performs operations in terms of objects, and the ORMs generate a SQL specific for a database, behind the scenes. This makes it a lot easier to switch databases in a project without getting into time-consuming syntax changes in the SQL used.</p><div class="section" title="SQLAlchemy"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec01"/>SQLAlchemy</h2></div></div></div><p>There are many ORMs for Python, but perhaps the most popular one is<span class="strong"><strong> SQLAlchemy</strong></span>. One of the reasons for its popularity is that SQLAlchemy, in addition to being a powerful ORM, offers a data abstraction layer for constructing SQL expressions in a platform-independent way. This gives the developer ample flexibility to work with the model objects without worrying about database or SQL details, but still have the ability to get down to the SQL level if needed, for performance or other reasons.<a id="id318" class="indexterm"/>
</p><p>SQLAlchemy supports a dozen databases, including SQLite, Postgres, MySQL, Oracle, and MS-SQL. It organizes pending operations into queues and flushes them all in one batch, providing efficiency and transaction safety. SQL clauses can be built by using Python functions and expressions, thus allowing the complete range of language constructs to be used. It also takes care of connection pooling, helping to optimize the use of system resources.<a id="id319" class="indexterm"/>
</p></div><div class="section" title="Including SQLAlchemy in our Grok project"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec02"/>Including SQLAlchemy in our Grok project</h2></div></div></div><p>We already saw in the previous chapter how to include a Python package from the PyPI in our project. Just add the package to the<code class="literal"> install_requires</code> variable in the project's<code class="literal"> setup.py</code> file:<a id="id320" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">install_requires=['setuptools',
'grok',
'grokui.admin',
'z3c.testsetup',
'megrok.form',
'SQLAlchemy',
# Add extra requirements here
],
</pre></div><p>After that, rerun the buildout and the package should be included:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ bin/buildout
</strong></span>
</pre></div><p>Once we've done that, SQLAlchemy is ready to use.</p><div class="section" title="Using SQLAlchemy"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec01"/>Using SQLAlchemy</h3></div></div></div><p>To get a feel of how SQLAlchemy operates by itself, let's try it directly from the Python prompt first. Go to the top directory of the project and type:<a id="id321" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ bin/python-console
</strong></span>
</pre></div><p>This will start the Python interpreter in the command line. As we already ran the buildout with the SQLAlchemy package, we should be able to import from it:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; from sqlalchemy import create_engine
&gt;&gt;&gt; engine = create_engine('sqlite:///:memory:',echo=True)
</strong></span>
</pre></div><p>The<code class="literal"> create_engine</code> method is used to tell<code class="literal"> sqlalchemy</code> which database to interact with. The first parameter is called a<span class="strong"><strong> connection string</strong></span> and contains all the information required to connect to the database, such as database name, username, and password. In this example, we use SQLite, which is a lightweight database included with Python since version 2.5. SQLite allows us to work in memory instead of creating a database on disk. As we are just testing, we can use this feature.<a id="id322" class="indexterm"/>
</p><p>The<code class="literal"> echo</code> parameter is passed a value of<code class="literal"> True</code> so that we can see the SQL generated by SQLAlchemy in the console output.<a id="id323" class="indexterm"/>
</p><p>Now we'll do a few more imports:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; from sqlalchemy import Column, Integer, String
&gt;&gt;&gt; from sqlalchemy.ext.declarative import declarative_base
&gt;&gt;&gt; Base = declarative_base()
</strong></span>
</pre></div><p>The<code class="literal"> Column</code> class is used to define a table column.<code class="literal"> Integer</code> and<code class="literal"> String</code> are column data types. We'll use them to define our table.<a id="id324" class="indexterm"/>
</p><p>Next, we import<code class="literal"> declarative_base</code>, which allows us to create a base class for use with our object models. To use it, we have to call it and assign the result to the variable that will act as a base class for our model.</p><p>We are now ready to create a model:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; class User(Base):
... __tablename__ = 'users'
... id = Column(Integer, primary_key=True)
... name = Column(String)
... realname = Column(String)
... role = Column(String)
... password = Column(String)
... def __init__(self, name, real_name, role, password):
... self.name = name
... self.real_name = real_name
... self.role = role
... self.password = password
</strong></span>
</pre></div><p>In this example, we create a<code class="literal"> User</code> class for storing user data. We have to use the<code class="literal"> Base</code> class that we just created with<code class="literal"> declarative_base</code> for SQLAlchemy to be able to work transparently with this model. A<code class="literal"> __tablename__</code> attribute is needed as well to designate the name of the table in the database that will store the model's information.</p><p>Next, the columns are defined using the<code class="literal"> Column</code> class and the types we imported earlier. Note the use of the<code class="literal"> primary_key</code> parameter to make<code class="literal"> id</code> the primary key for this table.<a id="id325" class="indexterm"/>
</p><p>Last, we need to define an<code class="literal"> __init__</code> method to set the column values on creation. After this is done, SQLAlchemy can create the table:<a id="id326" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; metadata = Base.metadata
&gt;&gt;&gt; metadata.create_all(engine)
2009-06-30 03:25:36,368 INFO sqlalchemy.engine.base.Engine.0x...5ecL PRAGMA table_info("users")
2009-06-30 03:25:36,368 INFO sqlalchemy.engine.base.Engine.0x...5ecL ()
2009-06-30 03:25:36,381 INFO sqlalchemy.engine.base.Engine.0x...5ecL
CREATE TABLE users (
id INTEGER NOT NULL,
name VARCHAR,
realname VARCHAR,
role VARCHAR,
password VARCHAR,
PRIMARY KEY (id)
)
</strong></span>
</pre></div><p>The table metadata is stored in the<code class="literal"> metadata</code> attribute of the<code class="literal"> Base</code> class and it can be used to create the table, via the<code class="literal"> create_all</code> method. This method needs to be passed to the engine that we created earlier, to know what dialect of SQL to use and how to connect to the actual database. Notice how the generated SQL is displayed immediately after an SQLAlchemy method call. You can see that the name of the table is the one that we defined by using the<code class="literal"> __tablename__</code> attribute earlier.<a id="id327" class="indexterm"/>
</p><p>Once the table is created, we can populate it with our<code class="literal"> User</code> objects. To do so, we first need to create a session:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; from sqlalchemy.orm import sessionmaker
&gt;&gt;&gt; Session = sessionmaker(bind=engine)
&gt;&gt;&gt; session = Session()
</strong></span>
</pre></div><p>The<code class="literal"> sessionmaker</code> method works in a way similar to that of<code class="literal"> declarative_base</code> and produces a class that we can call to create the actual session. Session creation is done in this way to allow SQLAlchemy to create a specific<code class="literal"> Session</code> class for an engine definition, which is passed to<code class="literal"> sessionmaker</code> by using the<code class="literal"> bind</code> parameter. Once we have a<code class="literal"> sessionmaker</code> tailored to our engine, we can create the database session, and we are ready for our first object instance:<a id="id328" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; grok_user = User('grok','Grok the Caveman','todo.ProjectMember','secret')
&gt;&gt;&gt; session.add(grok_user)
</strong></span>
</pre></div><p>We create an instance of the<code class="literal"> User</code> class, which represents the user 'grok'. To put it in the session queue, we use the<code class="literal"> add</code> method. At this point, the<code class="literal"> User</code> object is ready to be written to the database:<a id="id329" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; session.commit()
2009-06-30 03:30:28,873 INFO sqlalchemy.engine.base.Engine.0x...5ecL BEGIN
2009-06-30 03:30:28,874 INFO sqlalchemy.engine.base.Engine.0x...5ecL INSERT INTO users (name, realname, role, password) VALUES (?, ?, ?, ?)
2009-06-30 03:30:28,874 INFO sqlalchemy.engine.base.Engine.0x...5ecL ['grok', None, 'todo.ProjectMember', 'secret']
2009-06-30 03:30:28,875 INFO sqlalchemy.engine.base.Engine.0x...5ecL COMMIT
</strong></span>
</pre></div><p>We use the<code class="literal"> commit</code> method to save the changes to the database. Once again, we can look at the generated SQL in the console output. Now we can query the database by using Python constructs and use the data as we please:<a id="id330" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; for user in session.query(User):
... print user.name, user.real_name
...
2009-06-30 03:32:18,286 INFO sqlalchemy.engine.base.Engine.0x...5ecL BEGIN
2009-06-30 03:32:18,287 INFO sqlalchemy.engine.base.Engine.0x...5ecL SELECT users.id AS users_id, users.name AS users_name, users.realname AS users_realname, users.role AS users_role, users.password AS users_password
FROM users
2009-06-30 03:32:18,288 INFO sqlalchemy.engine.base.Engine.0x...5ecL []
grok Grok the Caveman
</strong></span>
</pre></div><p>In the preceding example, we use the<code class="literal"> query</code> method of the session to get all of the stored<code class="literal"> User</code> objects, which right now are exactly one. We then print the<code class="literal"> name</code> and<code class="literal"> real_name</code> attribute values of the result.<a id="id331" class="indexterm"/>
</p><p>Once we are finished, we should close the session:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; session.close()
</strong></span>
</pre></div><p>Of course, there's a lot more that the SQLAlchemy can do, but giving an in-depth explanation goes beyond the purpose of this book. There's ample documentation available at the project's website, including a tutorial.</p></div></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Using a relational database for authentication"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec02"/>Using a relational database for authentication</h1></div></div></div><p>We have seen how to use SQLAlchemy by itself, so now we can try to do something with it in our project. One area where relational database connectivity usually comes in handy for a web application, is the authentication process. This is because most of the time, in real enterprise settings, web applications are not isolated but form a part of a series of tools that a company can use in its daily work. It's quite common to have a single database to store all of the company users instead of having a separate database per application.<a id="id332" class="indexterm"/>
</p><p>We will show how to turn our authentication database from a ZODB folder into a relational database table by using SQLAlchemy. To begin, add the following lines to the top of<code class="literal"> auth.py</code>, just after the imports:</p><div class="informalexample"><pre class="programlisting">from sqlalchemy import create_engine
from sqlalchemy import Column, Integer, String
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
engine = create_engine('sqlite:///todo.db',echo=True)
Base = declarative_base()
Session = sessionmaker(bind=engine)
</pre></div><p>We used these imports and the engine setup statements in the previous section. The only difference is that instead of using an in-memory database, we will now use a file to keep our data. SQLite allows us to pass a relative path in the connection string to create a file for the database. In this case, the file will be named<code class="literal"> todo.db</code> and will be stored in the same directory as the root of the project.</p><p>As we are now going to store user data in the database, we don't need the user folder anymore, so we delete its definition from the code. Remove these two lines:<a id="id333" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">Class UserFolder(grok.Container):
pass
</pre></div><p>With that out of the way, the next step is to modify the definition of the<code class="literal"> Account</code> class:<a id="id334" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">class Account(Base):
__tablename__ = 'users'
id = Column(Integer, primary_key=True)
name = Column(String)
real_name = Column(String)
role = Column(String)
password = Column(String)
def __init__(self, name, password, real_name, role):
self.name = name
self.real_name = real_name
self.role = role
self.setPassword(password)
def setPassword(self, password):
passwordmanager = component.getUtility(IPasswordManager, 'SHA1')
self.password = passwordmanager.encodePassword(password)
def checkPassword(self, password):
passwordmanager = component.getUtility(IPasswordManager, 'SHA1')
relational databaserelational databaseAccount class definition, modifyingreturn passwordmanager.checkPassword(self.password, password)
</pre></div><p>Instead of using<code class="literal"> grok.Model</code> as the base class, we switch to the<code class="literal"> Base</code> class from<code class="literal"> declarative_base</code>. Then, we define the columns, using the same names as in the already existing properties as declared in the<code class="literal"> __init__</code> method. Note that all of the other methods of the class remain unchanged from the<code class="literal"> grok.Model-based Account</code> class.<a id="id336" class="indexterm"/>
</p><p>Now that we have an SQLAlchemy-based<code class="literal"> Account</code> class, we can use any SQLAlchemy functionality that we may need in the code. In this case, we have to change the<code class="literal"> UserAuthenticatorPlugin</code> implementation to access the database for user listing, user creation, and user deletion.</p><p>Here's the new implementation. Notice that the<code class="literal"> authenticateCredentials</code> and<code class="literal"> principalInfo</code> methods have not changed from the previous definition, so they are not included:<a id="id337" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">class UserAuthenticatorPlugin(grok.LocalUtility):
grok.implements(IAuthenticatorPlugin)
grok.name('users')
def __init__(self):
metadata = Base.metadata
metadata.create_all(engine)
</pre></div><p>The<code class="literal"> __init__</code> method uses the<code class="literal"> metadata.create_all</code> method with the predefined engine to create the database table when the plugin is initialized.<a id="id338" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">def getAccount(self, login):
session = Session()
result = session.query(Account).filter_by(name=login).first()
return result
</pre></div><p>To get an account, we start a session and then query the<code class="literal"> Account</code> class by using the<code class="literal"> filter_by</code> method, which returns only the database rows that match the login passed. SQLAlchemy allows chaining of query results, so we use the first method on the filtered results to get either the first (and only) match, or<code class="literal"> None</code>, if there is no such user.<a id="id339" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">def addUser(self, username, password, real_name, role):
session = Session()
result = session.query(Account).filter_by(| name=username).first()
if result is None:
user = Account(username, password, real_name, role)
session.add(user)
session.commit()
role_manager = IPrincipalRoleManager(grok.getSite())
if role==u'Project Manager':
role_manager.assignRoleToPrincipal( 'todo.ProjectManager',username)
elif role==u'Application Manager':
role_manager.assignRoleToPrincipal( 'todo.AppManager',username)
else:
role_manager.assignRoleToPrincipal( 'todo.ProjectMember',username)
</pre></div><p>To add a user, we first check if the login exists, using the same<code class="literal"> filter_by</code> call from the<code class="literal"> getAccount</code> method. If the result is<code class="literal"> None</code>, we create the user account and add it to the session. We immediately commit to save the results.<a id="id340" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">def deleteUser(self, username):
session = Session()
result = session.query(Account).filter_by( name=username).first()
if result is not None:
session.delete(result)
session.commit()
</pre></div><p>One thing that we didn't do when we covered authentication back in Chapter 7 was to give administrators the ability to delete users. The<code class="literal"> deleteUser</code> method above does just that. We again use the<code class="literal"> filter_by</code> call to see if a user with the passed login exists. If it does, we call<code class="literal"> session.delete</code> to remove it from the database and commit.<a id="id341" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">def listUsers(self):
session = Session()
results = session.query(Account).all()
return results
</pre></div><p>Finally, on<code class="literal"> listUsers</code>, we simply call the<code class="literal"> all</code> method to return every row in the table.</p><p>This is all that is needed to change authentication from using a<code class="literal"> grok.Container</code> in the ZODB to using a table in a relational database (refer to the next screenshot). To use a different database, we just need to change the engine definition to whatever database we want to use. Be aware, though, you have to install any drivers required by the database in your system, as well as add the corresponding Python driver to the project's<code class="literal"> setup.py</code>. Check the SQLAlchemy documentation for more information.</p><div class="mediaobject"><img src="images/7481_10_01.jpg" alt="Using a relational database for authentication"/></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Handling database transactions securely"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec03"/>Handling database transactions securely</h1></div></div></div><p>So we now have relational database authentication with very little work. However, there is a subtle problem with our code, especially in the<code class="literal"> addUser</code> method. Grok has a transaction machinery, as we have seen, but so does a relational database.<a id="id342" class="indexterm"/>
</p><p>Right now we are calling<code class="literal"> session.commit()</code> right after adding the user to the database. At that moment, the user data is saved to disk. The problem is that after saving this change, we immediately set the appropriate role for the user by using Grok's permission machinery, which is ZODB based.</p><p>Now, if some error occurs when calling<code class="literal"> assignRoleToPrincipal</code>, the Grok transaction will be aborted, meaning that the role will not be set for the new user. Meanwhile, the database transaction has been committed, so we end up with a user that exists in the database but who can't access the application features because it has no roles set.</p><p>This is what we call an inconsistent state for the database and users would call it a bug. In this case, we could move the<code class="literal"> session.commit()</code> call after the role changes and we would at least guarantee that a database error would then result in an aborted transaction in Grok. But clearly there could be more complicated cases where careful placement of the<code class="literal"> session.commit()</code> call would not be enough.<a id="id343" class="indexterm"/>
</p><p>What is needed is a way to synchronize both, the Grok and the SQLAlchemy transactions, so that we don't have to control them separately. Fortunately, the huge collection of packages available for Grok via the Zope Toolkit has the right tool for this job.</p><p>The package that we need is called<code class="literal"> zope.sqlalchemy</code> and it can be found on the PyPI, which means that it can be easily added to our project using<code class="literal"> setup.py</code>. You know the dance by now, add it to the<code class="literal"> install_requires</code> and rerun the buildout:</p><div class="informalexample"><pre class="programlisting">install_requires=['setuptools',
'grok',
'grokui.admin',
'z3c.testsetup',
'megrok.form',
'SQLAlchemy',
'zope.sqlalchemy',
# Add extra requirements here
],
</pre></div><p>The<code class="literal"> zope.sqlalchemy</code> package has a single purpose: to provide a transaction manager for integrating Grok and SQLAlchemy transactions. To use it, we first have to add a couple of imports at the top of<code class="literal"> auth.py:</code>
<a id="id344" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">from sqlalchemy.orm import scoped_session
from zope.sqlalchemy import ZopeTransactionExtension
</pre></div><p>
<code class="literal">scoped_session</code> is a special SQLAlchemy session manager that makes sure that any calls to<code class="literal"> Session()</code> during the same transaction will return the same session object.<code class="literal"> ZopeTransactionExtension</code> will create the object that is responsible for tying up Grok and the SQLAlchemy sessions.<a id="id345" class="indexterm"/>
</p><p>The engine and<code class="literal"> Base</code> declarations at the top of the module remain unchanged, but we have to drop the line where the<code class="literal"> Session</code> class is defined and use the following line of code in its place:<a id="id346" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">Session = scoped_session(sessionmaker(bind=engine, extension=ZopeTransactionExtension()))
</pre></div><p>This will initialize a scoped session and integrate the two transactions by using the<code class="literal"> ZopeTransactionExtension</code>. All that is required now is to substitute all of the<code class="literal"> session.commit()</code> calls with<code class="literal"> transaction.commit()</code> calls and our application will enjoy secure transaction handling. Here's a look at the resulting<code class="literal"> addUser</code> method:<a id="id347" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">def addUser(self, username, password, real_name, role):
session = Session()
result = session.query(Account).filter_by( name=username).first()
if result is None:
user = Account(username, password, real_name, role)
session.add(user)
role_manager = IPrincipalRoleManager(grok.getSite())
if role==u'Project Manager':
role_manager.assignRoleToPrincipal( 'todo.ProjectManager',username)
elif role==u'Application Manager':
role_manager.assignRoleToPrincipal( 'todo.AppManager',username)
else:
role_manager.assignRoleToPrincipal( 'todo.ProjectMember',username)
</pre></div><p>As you can see, committing the<code class="literal"> db</code> transaction is no longer necessary, as we are using the Grok transaction manager now, instead of the SQLAlchemy session object. The database transaction will be automatically committed when Grok commits the transaction for us, and the Grok machinery will make sure that either both transactions succeed or both fail. Less work and no data inconsistencies.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Creating database-backed models and containers"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec04"/>Creating database-backed models and containers</h1></div></div></div><p>We have shown how easy it is to access and use data from a relational database. Very few lines of the program had to be modified and not a line of SQL was used. Of course, authentication is a functionality that is somewhat peripheral to the main application. What if we need to store all the data generated by our application in a relational database?<a id="id348" class="indexterm"/>
</p><p>Grok's<code class="literal"> Model</code> and<code class="literal"> Container</code> classes store information in the ZODB, so if we want to use a relational database, we need to create our own model and container implementations, right? This seems like a lot of work. Fortunately, someone has already done that work for us.</p><div class="section" title="The megrok.rdb package"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec03"/>The megrok.rdb package</h2></div></div></div><p>It turns out that the<code class="literal"> megrok.rdb</code> package provides the Grok developer with<code class="literal"> Container</code> and<code class="literal"> Model</code> classes that work similarly to Grok's own classes, but store all information in a relational database. What's more,<code class="literal"> megrok.rdb</code> also uses SQLAlchemy, so it goes hand in hand with what we have done in this chapter so far.<a id="id349" class="indexterm"/>
</p><p>This package is available from the PyPI, as you might have guessed. Hopefully, by this time you know that<code class="literal"> megrok.rdb</code> should be added to the<code class="literal"> install_requires</code> section of<code class="literal"> setup.py</code> and the buildout needs to be run once again. This way the<code class="literal"> megrok.rdb</code> package will be ready for use.</p></div><div class="section" title="Making an application database backed"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec04"/>Making an application database backed</h2></div></div></div><p>Converting our whole application to use<code class="literal"> megrok.rdb</code> requires more work than is realistic for this introductory chapter, so let's just imagine, how we would design the application if we had a relational database planned for storage from the very beginning.<a id="id350" class="indexterm"/>
</p><p>As this is just an exercise, we will show only the code that would be needed for getting the<code class="literal"> Project</code> class working, along with its contained to-do lists. First, we need some imports from<code class="literal"> sqlalchemy</code>, similar to those we used earlier. Of course, we have to import the<code class="literal"> rdb</code> module from<code class="literal"> megrok.rdb</code> as well:<a id="id351" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">from sqlalchemy import Column, ForeignKey
from sqlalchemy.types import Integer, String
from sqlalchemy.orm import relation
from megrok.rdb import rdb
</pre></div><p>For now, we'll dispense as well with the database connection setup. Just assume that we have created a database as we have done earlier in this chapter. However, we do need a special<code class="literal"> metadata</code> object instead of the one provided by SQLAlchemy. We'll get it from the<code class="literal"> rdb</code> module that we just imported:</p><div class="informalexample"><pre class="programlisting">metadata = rdb.MetaData()
</pre></div><p>We can now create the models. Remember, this code is just for illustration purposes, do not add it to our project.<a id="id352" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">class TodoLists(rdb.Container):
pass
class Project(rdb.Model):
id = Column(Integer, primary_key=True)
title = Column(String(50))
kind = Column(String(50))
description = Column(String(140))
todolists = relation('TodoList', backref='project', collection_class=TodoLists)
class TodoList(rdb.Model):
id = Column(Integer, primary_key=True)
title = Column(String(50))
description = Column(String(140))
project = Column('project_id', Integer, ForeignKey('project.id'))
</pre></div><p>We define the to-do lists container first. It's just an empty class. Then, we define a<code class="literal"> Project</code> model and its columns by using regular SQLAlchemy declarations. We have a<code class="literal"> todolists</code> container as a property on the project, connected with the container that we defined earlier by using the SQLAlchemy relation declaration. This is necessary for having Grok-style containers in our relational database application.</p><p>For the<code class="literal"> TodoList</code> class, we use the<code class="literal"> rdb.Model</code> base class and add its columns as well, but here, we use a foreign key to relate the to-do list with a project.</p><p>Once this is done, we can generate the database structure, which will usually be done at an application's creation time. We have also done this in the previous section, so let's assume that we have everything ready, and start creating content:</p><div class="informalexample"><pre class="programlisting">session = rdb.Session()
project_x = Project(title='Project X',kind='personal', description='My secret project')
session.add(project_x)
</pre></div><p>First, we create a session. After that, we create a new<code class="literal"> Project</code> and add it to the session, just like regular SQLAlchemy usage. Next, we define some to-do lists:</p><div class="informalexample"><pre class="programlisting">planning = TodoList(title='Planning',description='Define steps for master plan')
execution = TodoList(title='Execution',description='Perform plan flawlessly')
world_domination = TodoList(title='World Domination', description='Things to do after conquering the world')
</pre></div><p>This is again just regular SQLAlchemy syntax, but now we come to the part where we use the container that we defined inside the<code class="literal"> Project</code> class to store the to-do lists. This is what makes it possible for us to have Grok container-like functionality for our database objects:<a id="id353" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">project_x.todolists.set(planning)
project_x.todolists.set(execution)
project_x.todolists.set(world_domination)
</pre></div><p>The<code class="literal"> set</code> method takes care of 'adding' the list to the container and lets the database set the key for each row. We could now call Grok container methods, such as<code class="literal"> items()</code> on the<code class="literal"> project_x.todolists</code> container and get the expected results, just like using<code class="literal"> grok.Container</code>.</p><p>There are other things that can be done with<code class="literal"> megrok.rdb</code>, so if you are interested in having a Grok-like database-backed application, you should consult the documentation.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="When to use the ZODB versus a relational database"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec05"/>When to use the ZODB versus a relational database</h1></div></div></div><p>Because it's fairly easy to use relational databases with Grok, people who are used to working with relational applications may wonder why they should use the ZODB at all. As comfortable as it is, to go with what we know best, no database technology is ideal for every kind of project.<a id="id354" class="indexterm"/>
</p><p>A relational database is a flat entity. When working with object-oriented languages such as Python, it's usually necessary to take a complex hierarchy of interrelated objects and "flatten" it to fit into several tables. Sometimes it's a lot easier and faster to simply store the objects exactly as they are, like an object-oriented database does.</p><p>Which one is best for your application? The key words here are<span class="emphasis"><em> flat</em></span> and<span class="emphasis"><em> hierarchy</em></span>. If your application will handle flat information structures, such as customers, products, records, orders, and so on, or if you need to do heavy reporting and data manipulation, a relational database is most likely your best bet. Online stores are a good example of an application that is well suited for relational database use. The user management part of our application which we just did is also a good fit here.</p><p>If you have complex, hierarchical structures of objects, it might be better to use the ZODB and persist the hierarchies in their natural form. Content management applications, where you need to model structures resembling folders and pages that can be nested several levels deep, are ideally suited to an object-oriented database.<a id="id355" class="indexterm"/>
</p><p>In the end, it's usually just a matter of preference, but in any case, Grok will let you use either one or even both of these mechanisms in a simple way, which gives you maximum flexibility.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec06"/>Summary</h1></div></div></div><p>In this chapter, we saw:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">How Grok makes it very easy to use the existing Python relational database packages and ORMs. We also learned to use the more advanced<code class="literal"> megrok.rdb</code> package to transparently turn our models into ORM mappings.</li><li class="listitem" style="list-style-type: disc">How to integrate relational database transactions with ZODB's transaction support.</li><li class="listitem" style="list-style-type: disc">How to use<code class="literal"> megrok.rdb</code> to turn our models into ORM mappings.</li></ul></div></div></div>
</body></html>