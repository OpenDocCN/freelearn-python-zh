- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Harnessing Web Services with the Raspberry Pi
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will begin to write code for web services to turn our Raspberry
    Pi into an **Internet of Things** (**IoT**) device. Using Python, we will design
    programs that pull data from online resources and use the data to create visuals
    on Sense HAT’s dot-matrix display. The practical examples we will cover in this
    chapter will serve as a building block for more advanced IoT web services development.
  prefs: []
  type: TYPE_NORMAL
- en: We begin by exploring the world of web services – understanding their role and
    how we can exploit them to our advantage. We may think of web services as the
    lifeblood of the internet, circulating vital data across the digital world. Understanding
    web services isn’t just about adding another tool to our toolkit; it’s about unlocking
    a world filled with limitless potential.
  prefs: []
  type: TYPE_NORMAL
- en: As we advance, we’ll transform theoretical knowledge into practical application
    through a series of programming projects. These projects are specifically designed
    to utilize the advanced web services offered by providers such as Alpha Vantage
    and OpenWeather. Using the versatile Raspberry Pi Sense HAT, or its emulator,
    we’ll construct applications including a scrolling stock ticker, a weather information
    display, and even a GO-NO-GO decision-maker for youth baseball games. These projects
    don’t just teach us how to use technology; they immerse us in the fundamental
    principles of IoT.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the vast array of opportunities that lie ahead with web services and
    the Raspberry Pi. Today, we’re starting with a simple stock ticker. Tomorrow,
    we might be developing a device that notifies us whenever our favorite team scores
    or even assists us in navigating through traffic. This chapter is our first step
    toward exploring a broader and more thrilling universe of IoT innovation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring web services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a scrolling stock ticker application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing weather display applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s begin!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following is required to complete this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: A Raspberry Pi 5 with either 4 GB or 8 GB of RAM (preferred); however, a late-model
    Raspberry Pi such as the Raspberry Pi 4 may be used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Raspberry Pi Sense HAT (Raspberry OS emulator may be used instead).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keyboard, mouse, and monitor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access to a 3D printer or 3D printing service for the custom stand.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The GitHub repository for the chapter, located at [https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter2](https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter2).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A general knowledge of programming. We will be using the Python programming
    language in this book.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring web services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine remotely controlling our home’s devices from our smartphone – this amazing
    convenience is powered by web services, invisible messengers seamlessly connecting
    our digital world.
  prefs: []
  type: TYPE_NORMAL
- en: Web services form an integral part of today’s internet infrastructure. They
    allow for the seamless exchange of data between different software applications
    over the internet. As a result, they are an essential tool for IoT applications,
    including our Raspberry Pi IoT projects. With web services, we can draw on the
    wealth of data available online and bring it into the physical world using our
    Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: 'At their core, web services are software interfaces that enable one software
    system to interact with another over a network. This interaction is typically
    done via specific protocols, such as **Representational State Transfer** (**REST**)
    or **Simple Object Access Protocol** (**SOAP**). To get a sense of the power of
    web services, consider the example shown in *Figure 2**.1* of a service that provides
    critical sensory data on a patient in a hospital room:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – Client application receiving data from the FHIR web service](img/B21282_02_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – Client application receiving data from the FHIR web service
  prefs: []
  type: TYPE_NORMAL
- en: Here, we see a diagram representing the **Fast Healthcare Interoperability Resources**
    web service. **FHIR** (pronounced “fire”) is a standard developed by **Health
    Level Seven International** (**HL7**) for the electronic exchange of healthcare
    information. Web services such as FHIR offer universal accessibility, enabling
    healthcare professionals to access and share patient data from anywhere at any
    time. They provide superior interoperability, making them more efficient and practical
    than local network **Application Programming Interface** (**API**) calls, especially
    in the healthcare sector where data needs to be shared across different systems
    and devices.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will look at the protocols used by web services. We will
    also explore some of the more popular web services available before we write code
    to call a simple web service using our Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding approaches for web services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the field of web services, two prominent approaches are the REST and SOAP
    protocols. RESTful web services use HTTP methods explicitly and are more straightforward
    and efficient, making them a popular choice for many developers. SOAP, on the
    other hand, is a protocol that permits programs running on siloed systems to communicate
    by using HTTP and its XML-based messaging system. SOAP is highly extensible and
    has strong support for security and reliability, making it suitable for complex
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: In our upcoming projects, we will primarily utilize REST for interacting with
    web services. However, understanding SOAP provides a broader view of the landscape
    of web service interactions. We will start by exploring SOAP, its functionality,
    and its applicable scenarios before diving into REST-based or RESTful web services.
  prefs: []
  type: TYPE_NORMAL
- en: Using SOAP web services
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To understand SOAP, we turn our attention to the custom ordering system illustrated
    in *Figure 2**.2*. As this system was built in-house for a particular company’s
    business operations, it is a complex, enterprise-level application with significant
    requirements in terms of security and reliability. This ordering system represents
    an ideal use case for SOAP-based web services:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – Custom ordering application connecting to the server using SOAP](img/B21282_02_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 – Custom ordering application connecting to the server using SOAP
  prefs: []
  type: TYPE_NORMAL
- en: With SOAP’s stateful nature, the application can manage complex transaction
    management that involves multiple steps, from inventory checks and payment processing
    to order confirmation. The SOAP protocol, with its built-in security features
    and error handling, enables the application to manage orders efficiently and securely.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see in *Figure 2**.2*, an XML file is passed through HTTPS in a SOAP
    transaction. This XML file, nestled within the SOAP message, plays a crucial role
    in communication. It carries detailed instructions that guide the server’s actions.
    The structured format of XML enables complex data exchanges, allowing the custom
    ordering system to seamlessly interact with various other systems despite their
    possible diverse data formats.
  prefs: []
  type: TYPE_NORMAL
- en: If SOAP is the desired approach for enterprise-level applications, REST is preferred
    for public web services. REST’s simplicity, lightweight nature, scalability, and
    resource-oriented approach make it ideal for creating user-friendly and scalable
    web services that interact with resources through standard HTTP protocols.
  prefs: []
  type: TYPE_NORMAL
- en: Investigating RESTful web services
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: RESTful web services are a key aspect of modern web applications, allowing for
    efficient communication between clients and servers using the REST architecture.
    RESTful web services employ HTTP methods such as `GET`, `POST`, `PUT`, and `DELETE`
    to interact with resources and are stateless. Unlike SOAP, which typically uses
    XML, RESTful services can support multiple data formats, including JSON and XML.
    This flexibility often leads to RESTful services being perceived as simpler to
    use and more adaptable than SOAP.
  prefs: []
  type: TYPE_NORMAL
- en: Several widely recognized public RESTful web services have gained popularity
    due to their functionality and ease of use. Among them is the `Twitter` API, which
    allows developers to access and interact with core Twitter data, including timelines,
    status updates, and other information. Another notable example is the Google Maps
    API, which provides developers with the ability to embed Google Maps on web pages
    using JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 2**.3*, we see a simplified diagram of a RESTful web service communicating
    with a web page using the `GET`, `POST`, `PUT`, and `DELETE` HTTP methods. Each
    of these HTTP methods corresponds to a specific type of interaction with the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – Simplified diagram of a RESTful web service](img/B21282_02_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.3 – Simplified diagram of a RESTful web service
  prefs: []
  type: TYPE_NORMAL
- en: The `GET` method retrieves existing data, `POST` is typically used to send new
    data for the creation of a resource, `PUT` is used to update existing resources,
    and `DELETE` removes data.
  prefs: []
  type: TYPE_NORMAL
- en: Difference between an API and a web service
  prefs: []
  type: TYPE_NORMAL
- en: We may find ourselves using the terms *API* and *web service* interchangeably;
    however, there is a difference. An **API** is a broad term defining rules and
    conventions for building and interacting with software applications. APIs can
    operate over various channels and not just the web. A **web service**, however,
    is a specific type of API that operates over the internet, typically using protocols
    such as HTTP. In essence, all web services are APIs, but not all APIs are web
    services.
  prefs: []
  type: TYPE_NORMAL
- en: 'Considering the Twitter API as an example of a web service that we could develop
    a client for, the application of these HTTP methods would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET`: We would use this method to retrieve data from Twitter. For example,
    we would use a `GET` request to fetch a specific user’s tweets or search for tweets
    that contain a specific hashtag.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST`: We would use this method when we want to create new data on Twitter,
    such as a new tweet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT`: We wouldn’t use this method as the Twitter API doesn’t natively support
    the `PUT` HTTP method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE`: We would use the `DELETE` method to remove existing data on Twitter.
    However, this method is not widely used in the Twitter API as deletion capabilities
    are limited due to Twitter’s policies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can see REST methods outlined in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4 – REST methods summarized](img/B21282_02_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.4 – REST methods summarized
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, REST is a straightforward approach that leverages standard HTTP
    or HTTPS methods such as `PUT`, `POST`, `GET`, and `DELETE` while also offering
    flexibility in data formats such as **JavaScript Object Notation** (**JSON**)
    or XML, whereas SOAP is a protocol that typically uses XML to transmit structured
    messages and can operate over various **Internet Protocol** (**IP**) suite networks
    such as HTTP or HTTPS.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a basic understanding of web services and the way we can implement
    them, let’s create a real-world example using our Raspberry Pi and Sense HAT.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to a web service with our Raspberry Pi and Sense HAT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will connect our Raspberry Pi to a web service and display
    the result on the dot-matrix screen of our Sense HAT (or emulator). The service
    we will connect to will be a dummy web service, designed to evaluate RESTful web
    service calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 2**.5*, we see an example of a Raspberry Pi pulling weather information
    from a web service and using the dot-matrix display of the Sense HAT to display
    a cloud:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 – Sense HAT displaying a cloud indicating current weather conditions](img/B21282_02_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.5 – Sense HAT displaying a cloud indicating current weather conditions
  prefs: []
  type: TYPE_NORMAL
- en: The cloud represents current weather conditions (not to be confused with the
    cloud representing the web service). Such an application could show an animation
    on the dot-matrix screen. We could even swap the weather web service for another
    web service and create an entirely new application, leveraging the existing code
    easily.
  prefs: []
  type: TYPE_NORMAL
- en: Before creating a web service client, we need to set up our development environment
    and install the necessary packages for our code to work. We will incorporate a
    Python virtual environment to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our development environment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will use a Python virtual environment for our development. As there are
    libraries that only work with the root installation of Python, we will use system
    packages in our Python virtual environment. To do so, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: On our Raspberry Pi 5, we open a Terminal application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To store our project files, we create a new directory with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then navigate to the new directory with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We create a new Python virtual environment for our project with the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With our new Python virtual environment created, we source into it (set the
    Python virtual environment) with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 2.6 – Terminal using ch2-env environment](img/B21282_02_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.6 – Terminal using ch2-env environment
  prefs: []
  type: TYPE_NORMAL
- en: 'We install the extra packages required for our code with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: exit
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We are now ready to load up Thonny. We do so by clicking on the **Menu** icon
    in the Raspberry Pi taskbar, navigating to the **Programming** category, and selecting
    **Thonny**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By default, Thonny uses the Raspberry Pi’s built-in version of Python. For our
    project, we will use the Python virtual environment we just created. To start,
    we need to view the project files by clicking on **View** and selecting **Files**
    if it is not already selected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Files` section, we locate the `ch2-env` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We then right-click on the folder and select the **Activate virtual** **environment**
    option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.7 – Activating a Python virtual environment in Thonny](img/B21282_02_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.7 – Activating a Python virtual environment in Thonny
  prefs: []
  type: TYPE_NORMAL
- en: With our project folder created, our Python virtual environment set up and activated,
    and the `requests` package installed, we may now start writing code.
  prefs: []
  type: TYPE_NORMAL
- en: Writing our first web service code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We are now ready to write our first web service code. This code will make a
    call to a dummy web service used for testing. Upon successful transmission, a
    success message will scroll across the dot-matrix screen of our Sense HAT:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create our web service application, inside Thonny we create a new tab. Inside
    the tab, we write the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Before we run our code, let’s break it down:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We start by importing the `requests` library, a popular library in Python for
    making HTTP requests.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We then import the `SenseHat` class from the `sense_hat` library, allowing us
    to interact with the Sense HAT board. For those of us using the Sense HAT emulator,
    we would use the `sense_emu` library instead.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We send a `GET` request to the specified URL (`'https://jsonplaceholder.typicode.com/posts'`),
    which is an endpoint of a dummy API that provides placeholder data in the JSON
    format. The response from the server is stored in the `response` variable.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We create an instance of the `SenseHat` class. We use this object to control
    the Sense HAT’s dot-matrix display.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `sense.set_rotation(270)` line adjusts the orientation of the Sense HAT’s
    LED matrix so that it matches the orientation of the Raspberry Pi in our custom
    case (refer to [*Chapter 1*](B21282_01.xhtml#_idTextAnchor014) for information
    on the custom Raspberry Pi case).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Our code then checks the HTTP response’s status code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If the status code is `200`, which indicates a successful HTTP request, the
    following then occurs:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`data = response.json()`: Our code converts the JSON response body into a Python
    data structure.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`print(data[0][''title''])`: Our code prints the title of the first post from
    the response data to the shell in Thonny.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Our code displays a success message on the Sense HAT’s LED matrix, indicating
    the successful status code.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the status code is not `200`, which indicates an unsuccessful HTTP request,
    the following happens:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Our code prints an error message to the Shell, indicating the unsuccessful status
    code.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Our code displays a failure message on the Sense HAT’s LED matrix, indicating
    the unsuccessful status code.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We save the code as `webservice-test.py` and then run it by clicking on the
    green run button at the top, hitting *F5* on the keyboard, or clicking on the
    **Run** menu option at the top and then **Run** **current script**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Upon a successful web service call (which is to be expected with this dummy
    service), we should see a title print to the Shell looking like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.8 – Testing a web service call using Thonny](img/B21282_02_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.8 – Testing a web service call using Thonny
  prefs: []
  type: TYPE_NORMAL
- en: We shouldn’t be too concerned about the contents of the title as it is just
    dummy data. Subsequently, upon successful completion of the web service call,
    we should observe a scrolling message on the Sense HAT display (or the emulator).
    This message signifies the successful status of our call, which should be denoted
    by the `200` HTTP status code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Although our code lacks error checking, we have successfully constructed our
    first IoT device powered by the Raspberry Pi. It’s important to note that considerations
    such as internet connectivity are not incorporated into our simple code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the remaining sections of this chapter, we will elevate our IoT device from
    being a simple web service testing tool to something more engaging. We will take
    on two exciting projects: the construction of a stock ticker application and a
    weather-dependent GO-NO-GO decision-making application.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a scrolling stock ticker application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It’s now time to build our first practical IoT device. For this project, we
    will create a stock ticker application with our Raspberry Pi and Sense HAT. A
    stock ticker is a device, physical or digital, that presents stock prices in real
    time. Our application will fetch real-time stock prices from Alpha Vantage, an
    online service providing free APIs for data on stocks. In our application, we
    will be retrieving the current stock price for Apple, listed on the Nasdaq stock
    exchange as *AAPL*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see our stock ticker application illustrated in *Figure 2**.9*. We will
    use the HTTP `GET` method to retrieve information with the response in JSON format,
    a lightweight data-interchange format that is easy for humans to read and write
    and easy for machines to parse and generate:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.9 – Diagram of our stock ticker application; the double arrows symbolize
    the call and subsequent response from the Alpha Vantage web service](img/B21282_02_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.9 – Diagram of our stock ticker application; the double arrows symbolize
    the call and subsequent response from the Alpha Vantage web service
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, when we request data for the `AAPL` stock symbol, the **Alpha
    Vantage API** sends back a JSON object response, as illustrated in *Figure 2**.10*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.10 – JSON object response from Alpha Vantage web service call](img/B21282_02_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.10 – JSON object response from Alpha Vantage web service call
  prefs: []
  type: TYPE_NORMAL
- en: The response encompasses 10 parameters for every successful API request. Out
    of these parameters, our stock ticker application will focus on `symbol`, `volume`,
    `price`, and `change`. These specific data points will be used to create a message
    that we will scroll across the dot-matrix screen of the Sense HAT.
  prefs: []
  type: TYPE_NORMAL
- en: However, before we can write our web service code, we must first acquire an
    API key from Alpha Vantage. This key grants us permission to make the necessary
    web service calls.
  prefs: []
  type: TYPE_NORMAL
- en: Getting an API key
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Securing an API key from Alpha Vantage is a straightforward process that can
    be accomplished in just a few steps. We start by navigating to the Alpha Vantage
    website at [https://www.alphavantage.co](https://www.alphavantage.co).
  prefs: []
  type: TYPE_NORMAL
- en: From there, we click on the **GET FREE API KEY** button – this should be easy
    to locate on the home page. Clicking this button will lead us to a sign-up form.
    We fill out the required details on this form, making sure to provide a valid
    email address. We should be given an API key once the form has been filled out,
    and we click on the **GET FREE API** **KEY** button.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The preceding instructions are valid as of the time of this writing. Please
    follow any changes to the process to get the API key.
  prefs: []
  type: TYPE_NORMAL
- en: Once the API key has been issued, we must copy and paste it into a text editor
    as we require this key every time we make a call to the Alpha Vantage web service.
    As a free user, we are limited to 5 API requests per minute and a total of 500
    API requests per day.
  prefs: []
  type: TYPE_NORMAL
- en: Armed with our API key, we can now start to write code for our application.
  prefs: []
  type: TYPE_NORMAL
- en: Writing web services client code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will start developing web service code to fetch current
    stock information for the company Apple (AAPL). Our objective is to retrieve the
    JSON object response from the Alpha Vantage web service, which will contain the
    relevant stock data we need for our scrolling stock ticker application.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create our web service code, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We launch Thonny on our Raspberry Pi and activate the `ch2-env` Python virtual
    environment using the steps in the previous section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We then open a new tab in Thonny and enter the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Before we run our code, let’s break it down:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We start by importing the `requests` module, which is a widely used Python library
    for making HTTP requests. It provides convenient methods to send HTTP requests
    such as `GET`, `POST`, and so on and handles underlying network communication.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We then import the built-in `json` module in Python. The `json` module provides
    methods to work with JSON data. It allows encoding Python objects into JSON strings
    (`json.dumps()`) and decoding JSON strings into Python objects (`json.loads()`).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We store our personal API key from Alpha Vantage in a variable called `api_key`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We set the `symbol` variable to `'AAPL'`, representing the stock symbol for
    Apple.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `base_url` variable stores the base URL for the Alpha Vantage API.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We set the `function` variable to `'GLOBAL_QUOTE'`, indicating the specific
    function to retrieve global stock quotes.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We construct the `complete_url` variable by combining the base URL, function,
    symbol, and API key to form a complete URL for the API request.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Our code then sends a `GET` request to the Alpha Vantage API using `requests.get()`
    and stores the response in the `response` variable.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We extract the JSON response from the `response` object using `.json()`, and
    the resulting data is stored in the `data` variable.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, the code prints `data` in a formatted JSON representation using `json.dumps()`
    with the `indent` parameter set to `4`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We save the code as `alphavantage-test.py` and then run it by clicking on the
    green run button, hitting *F5* on the keyboard, or clicking on the **Run** menu
    option at the top and then **Run** **current script**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We should see a JSON object like what we see in *Figure 2**.11* displayed in
    the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.11 – JSON response displayed in Thonny’s Shell](img/B21282_02_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.11 – JSON response displayed in Thonny’s Shell
  prefs: []
  type: TYPE_NORMAL
- en: Important note – code not for production
  prefs: []
  type: TYPE_NORMAL
- en: Please note that in the provided code, error checking has been omitted for the
    sake of simplicity. If this application were to be deployed to a production environment
    (for use by customers, for example), we would be sure to include appropriate error-handling
    and error-checking mechanisms to ensure the reliability and stability of the application.
  prefs: []
  type: TYPE_NORMAL
- en: With our code to pull stock information from the internet done, it is now time
    to utilize the dot-matrix screen of the Sense HAT to create a scrolling stock
    ticker.
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing our application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With our understanding of how to use the Alpha Vantage web service, we are now
    able to create an application that fetches stock data and transforms it into a
    real-life scrolling stock ticker. Our application takes advantage of the Sense
    HAT’s dot-matrix display, turning it into a dynamic canvas for the stock ticker.
    Instead of printing the JSON response to the console, the stock information will
    elegantly scroll across the Sense HAT display, providing a visually captivating
    representation of the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create our web service code, we launch Thonny on our Raspberry Pi and create
    a new tab:'
  prefs: []
  type: TYPE_NORMAL
- en: We launch Thonny on our Raspberry Pi and activate the `ch2-env` Python virtual
    environment using the steps in the previous section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In a new tab in Thonny, we start our code by importing the necessary libraries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In our code, we import the `requests` module, as well as the `SenseHat` class
    from the `sense_hat` module. For those of us using the Sense HAT emulator, we
    would change this to `from sense_emu import SenseHat`. We then import the `time`
    module.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'With our libraries in place, we create and set the variables we use in our
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In these code lines, we use the `api_key` variable to store our unique Alpha
    Vantage API key for accessing a web service. We use the `symbol` variable to store
    the stock symbol (for example, `'AAPL'`) for which data will be fetched. The `base_url`
    variable is used to store the base URL of the web service API. The `function`
    variable is used to define the specific function to be called from the web service
    API (for example, `'GLOBAL_QUOTE'`). We then create an instance of the `SenseHat`
    class and assign it to the `sense` variable to interact with the Sense HAT (or
    emulator). We set the rotation of the Sense HAT display to `270` degrees using
    `sense.set_rotation(270)`. This is so that it matches the orientation of the Raspberry
    Pi in our custom case. We could comment this line out for the emulator. We then
    initialize the `last_call_time` variable with the current time minus 180 seconds,
    which allows an immediate first call to the web service. We initialize the `last_ticker_info`
    variable as an empty string to store the previous ticker information.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Below our variable declarations, we implement an infinite loop to continuously
    display the ticker information; however, to comply with API rate limits of 5 requests
    per minute and 500 requests per day, we introduce a time delay of 3 minutes between
    each web service call. We type the following code below our variable declarations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our code is wrapped in a `while True` loop, which ensures continuous execution
    of the following code block:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We set the `current_time` variable to the current time using `time.time()`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Our code then checks whether the difference between `current_time` and `last_call_time`
    is greater than or equal to 180 seconds.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If `True`, the following happens:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A `complete_url` variable is created using an f-string to form the URL for the
    API call.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: An HTTP `GET` request is sent to the API using `requests.get(complete_url)`,
    and the response is stored in the `response` variable.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The response is parsed as JSON using `response.json()` and assigned to the `data`
    variable.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The relevant stock information is extracted from the `data` dictionary and formatted
    into a `ticker_info` string.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `last_ticker_info` variable is updated to store the current `ticker_info`
    value.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `ticker_info` string is displayed on the Sense HAT’s dot-matrix display
    using `sense.show_message()`, with a scrolling speed of 0.05 seconds and white
    text color (`255,255,255`).
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `last_call_time` variable is updated to the current time (`current_time`)
    to mark the timestamp of the last API call.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If `False`, the previous `last_ticker_info` variable is displayed on the Sense
    HAT display with a scrolling speed of 0.05 seconds and white text color (`255,255,255`).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Our program then sleeps for 1 second using `time.sleep(1)` before the next iteration
    of the loop. This is done to regulate resource consumption and control the update
    frequency of the Sense HAT’s dot-matrix display.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We save our code as `aapl-stock-ticker.py` and then run it by clicking on the
    green run button, hitting *F5* on the keyboard, or clicking on the **Run** menu
    option at the top and then **Run** **current script**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After we execute the code, we should observe a stock message scrolling across
    the dot-matrix screen of the Sense HAT. If we are utilizing the emulator, the
    message will scroll across the simulated dot-matrix display, considering the 270-degree
    orientation set for the emulator. *Figure 2**.12* provides a visual representation
    of how this appears when using the emulator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.12 – Stock ticker information on Sense HAT emulator](img/B21282_02_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.12 – Stock ticker information on Sense HAT emulator
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations are in order as we have successfully built our first real-world
    IoT device, a stock ticker using Raspberry Pi and Sense HAT! This device opens
    a world of possibilities beyond just displaying stock information. In the next
    section, we will start developing applications to display weather conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Developing weather display applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we are experienced IoT application developers, we are ready to take
    our skills to the next level and create more intricate projects. In this section,
    we will leverage the capabilities of Raspberry Pi and Sense HAT to create a weather
    display application and a weather-dependent GO-NO-GO decision-making application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 2**.13*, we see a diagram depicting a call to the OpenWeather API
    from our Raspberry Pi and Sense HAT, enclosed within its custom case. For our
    weather display application, we will follow a similar approach to the scrolling
    stock ticker:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.13 – Using the OpenWeather API to get the current weather conditions](img/B21282_02_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.13 – Using the OpenWeather API to get the current weather conditions
  prefs: []
  type: TYPE_NORMAL
- en: We will first acquire an API key from OpenWeather and verify the API call by
    printing the response to the Shell for testing purposes. We will then utilize
    the Sense HAT to create a ticker-style display that displays the current weather
    conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will replace the scrolling display with visuals as we build a weather-dependent
    GO-NO-GO decision-making application.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by obtaining an API key.
  prefs: []
  type: TYPE_NORMAL
- en: Getting an API key
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To utilize the OpenWeather web service, it is necessary to obtain an API key.
    This API key serves as a unique identifier that grants access to the OpenWeather
    web service. The key is acquired by creating an account on the OpenWeather website
    and generating an API key by subscribing to the appropriate service. The API key
    acts as a credential to authenticate and authorize our requests to the OpenWeather
    web service, enabling us to retrieve weather data for various locations around
    the world. It’s important to keep the API key confidential and securely store
    it as it grants access to the OpenWeather API on our behalf.
  prefs: []
  type: TYPE_NORMAL
- en: 'To obtain a free API key from OpenWeather, we start by navigating to the OpenWeather
    price page located at [https://openweathermap.org/price](https://openweathermap.org/price).
    We then scroll down to the **Current weather and forecasts collection** section
    and click on the **Get API** **key** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.14 – Obtaining an API key from OpenWeather](img/B21282_02_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.14 – Obtaining an API key from OpenWeather
  prefs: []
  type: TYPE_NORMAL
- en: We follow the instructions for creating a new account. After successfully creating
    the account, we gain access to our personal dashboard. Inside the personal dashboard,
    we navigate to the **API keys** tab and locate the API key in the **Key** box.
  prefs: []
  type: TYPE_NORMAL
- en: We copy and paste our key into a text editor as we require this key every time
    we make a call to the OpenWeather web service. As a free user, we are limited
    to 60 API requests per minute and a total of 1,000,000 API requests per month.
    This should be more than enough for our application.
  prefs: []
  type: TYPE_NORMAL
- en: With our OpenWeather API key, we can now start to write code to test out the
    web service.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a scrolling weather information ticker
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With our OpenWeather API key, Raspberry Pi, and Sense HAT, we will now create
    a scrolling weather information device that mimics the functionality of our scrolling
    stock ticker. We will start by acquiring weather data and display the results
    in the Shell of Thonny.
  prefs: []
  type: TYPE_NORMAL
- en: After we are satisfied that our API key and web service work, we will integrate
    the web service data with the Sense HAT, displaying scrolling text that displays
    the temperature and weather conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the web service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before integrating the OpenWeather API into our Raspberry Pi and Sense HAT,
    we will ensure its functionality with a simple program. To create the test code,
    we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We launch Thonny on our Raspberry Pi, activate the `ch2-env` Python virtual
    environment, and create a new tab. Inside the tab, we write the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Before we run our code, let’s break it down:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We start by importing the `requests` module to make HTTP requests.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We then set the `url` variable to the OpenWeather API endpoint.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We set the `api_key` variable with our OpenWeather API key.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We set the `location` variable to the desired location for which we want to
    retrieve weather information. For our example, this is `"Toronto"`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We then create a dictionary called `params` with the parameters for the API
    request, including the location, API key, and desired units.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A `GET` request is sent to the OpenWeather API using `requests.get()`, with
    `url` and `params` as arguments.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We then check whether the response status code is `200` (indicating a successful
    request).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the response is successful, we parse the JSON data from the response using
    `response.json()` and then do the following:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We extract the temperature and weather description from the parsed data.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We then print the current temperature and weather information for the specified
    location.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If there is an error (response status code other than `200`), we print an error
    message indicating the failure to retrieve weather information.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We save our code as `weather-api-test.py` and then run it by clicking on the
    green run button, hitting *F5* on the keyboard, or clicking on the **Run** menu
    option at the top and then **Run** **current script**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After we execute the code, we should observe a message in the Shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.15 – OpenWeather API information on the weather in Toronto](img/B21282_02_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.15 – OpenWeather API information on the weather in Toronto
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see, it is `29.15 °C` and clear in Toronto at the time of this writing.
    If the web service call did not work, we would’ve seen an `Error: Failed to retrieve
    weather information` error in the console.'
  prefs: []
  type: TYPE_NORMAL
- en: With our understanding of how to use the OpenWeather API, we are now ready to
    use the Sense HAT to create our scrolling weather information ticker. For this,
    we may reuse much of the code we wrote for our scrolling stock ticker application.
  prefs: []
  type: TYPE_NORMAL
- en: Scrolling weather information on Sense HAT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we highlighted in our previous project, the versatility of our scrolling
    stock ticker application allows us to adapt it to display various types of information
    beyond stocks. In this section, we will leverage this adaptability by integrating
    the OpenWeather API and our API key to transform our ticker into a dynamic weather
    display, scrolling real-time weather data such as temperature and current conditions.
    We will be able to reuse a lot of the code from the scrolling stock ticker. To
    create the scrolling ticker code, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We launch Thonny on our Raspberry Pi, activate the `ch2-env` Python virtual
    environment, and create a new tab. We will start with our imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: As we have already covered these imports with our scrolling stock ticker application,
    we do not need to cover them again.
  prefs: []
  type: TYPE_NORMAL
- en: 'After our imports, we set our variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this code block, we do the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We start by assigning the `api_key` variable to our OpenWeather API key.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We set the `location` variable to the desired location for which we want to
    retrieve weather information. For our example, this is `'Toronto'`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We then set the `base_url` variable to the OpenWeather API endpoint.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We create a dictionary called `params` with the parameters for the API request,
    including the location, API key, and desired units.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A `GET` request is sent to the OpenWeather API using `requests.get()`, with
    `url` and `params` as arguments.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We then create an instance of the `SenseHat` class and assign it to the `sense`
    variable to interact with the Sense HAT (or emulator).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We set the rotation of the Sense HAT display to 270 degrees using `sense.set_rotation(270)`.
    This is so that it matches the orientation of the Raspberry Pi in our custom case.
    We could comment this line out for the emulator.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We set `last_call_time` to the current time minus 30 seconds.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We then add `last_weather_info`, which is a variable that stores the previous
    weather information.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Below our variable declarations, we implement an infinite loop to continuously
    display the weather ticker information; however, to comply with API rate limits
    of 60 requests per minute and 1,000,000 requests per month, we introduce a time
    delay of 30 seconds between each web service call. We type the following code
    below our variable declarations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As in our scrolling stock ticker application, the heart of our code is wrapped
    in a `while True` loop, which ensures continuous execution of the main code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We set the `current_time` variable to the current time using `time.time()`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Our code then checks whether the difference between `current_time` and `last_call_time`
    is greater than or equal to 30 seconds.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If `True`, the following happens:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A `GET` request is sent to the OpenWeather API using `requests.get()`, with
    `base_url` and `params` as arguments.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The response is parsed as JSON using `response.json()` and assigned to the `data`
    variable.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We extract the temperature and weather description from the parsed data and
    store it as `weather_info.`
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `last_weather_info` variable is updated to store the current `weather_info`
    value.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`weather_info` is displayed on the Sense HAT’s dot-matrix display using `sense.show_message()`,
    with a scrolling speed of 0.05 seconds and white text color (`255,255,255`).'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `last_call_time` variable is updated to the current time (`current_time`)
    to mark the timestamp of the last API call.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If `False`, the previous `last_weather_info` variable is displayed on the Sense
    HAT display with a scrolling speed of 0.05 seconds and white text color (`255,255,255`).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Our program then sleeps for 1 second using `time.sleep(1)` before the next iteration
    of the loop. This is done to regulate resource consumption and control the update
    frequency of the Sense HAT’s dot-matrix display.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We save our code as `weather-scroll.py` and then run it by clicking on the green
    run button, hitting *F5* on the keyboard, or clicking on the **Run** menu option
    at the top and then **Run** **current script**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After we execute the code, we should observe weather information scrolling
    across the dot-matrix screen of the Sense HAT. If we are utilizing the emulator,
    a message will scroll across the simulated dot-matrix display. *Figure 2**.16*
    provides a visual representation of how this appears when using the emulator:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.16 – Weather information scrolling across the simulated dot-matrix
    display](img/B21282_02_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.16 – Weather information scrolling across the simulated dot-matrix
    display
  prefs: []
  type: TYPE_NORMAL
- en: One key takeaway is the power of leveraging existing code to create new applications.
    Despite inherent differences between stock information and weather data, the process
    of obtaining information for both fields remain remarkably similar. With this
    realization, we unlock the potential to create a wide range of dynamic and engaging
    displays using the same underlying code structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few examples of other applications we could build:'
  prefs: []
  type: TYPE_NORMAL
- en: '**News updates**: By modifying the code, we can integrate our device with news
    APIs to display real-time headlines or updates from popular news sources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Social media notifications**: By connecting our application to social media
    APIs, we can configure it to display notifications from popular platforms such
    as Twitter or Facebook.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sports scores**: With the integration of sports data APIs, our stock ticker
    application can be transformed into a real-time sports scoreboard. It can display
    live scores, game updates, or upcoming game schedules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Personalized reminders**: By extending the functionality of the code, we
    can program the stock ticker application to display personalized reminders or
    to-do lists.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our next and final project for the chapter, we will replace our scrolling
    text displays with dot-matrix images and animations. This shift from scrolling
    text elevates the user experience and will make our projects more visually appealing.
  prefs: []
  type: TYPE_NORMAL
- en: Developing a GO-NO-GO application for decision-making
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider the role of a youth baseball league convener, responsible for ensuring
    the safety of playing fields. Critical to this responsibility is making weather-based
    decisions. If the field is excessively wet, it can impact gameplay, potentially
    leading to game postponements or cancellations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.17 – Should the game go on?](img/B21282_02_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.17 – Should the game go on?
  prefs: []
  type: TYPE_NORMAL
- en: Another factor to consider is the age of the players. For younger players, playing
    in the rain raises concerns, as parents are often present and may express dissatisfaction
    with unfavorable weather conditions. On the other hand, older players, who typically
    travel to games independently, may be less affected by wet conditions.
  prefs: []
  type: TYPE_NORMAL
- en: These decision-making scenarios represent an opportunity to develop an IoT application
    that displays a visual indicator, such as a **GO** or **NO-GO** graphic, based
    on weather conditions and player age (*Figure 2**.17*). Imagine a setup with Raspberry
    Pi and Sense HATs for each baseball diamond, where the Sense HAT display provides
    real-time guidance on whether the game should proceed as scheduled, be postponed,
    or be canceled altogether. This IoT application enables efficient decision-making
    and enhances the overall experience and safety of the youth baseball league.
  prefs: []
  type: TYPE_NORMAL
- en: In our simplified example, we will focus on incorporating basic decision-making
    into our IoT application. Based on the age of the players and the presence of
    rain, the Sense HAT will show either a green checkmark or an animated red X sign.
    While we could introduce additional complexity, the primary objective of this
    exercise is to demonstrate how decision-making can be integrated into an IoT application.
    By incorporating these visual indicators, we empower real-time decision-making.
    Instead of relying solely on the convener, our IoT application takes charge by
    providing immediate guidance on whether games should proceed or be postponed.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by writing Sense HAT code for indication. For GO, we will show
    a simple green checkmark against a black background. For NO-GO, we will display
    a flashing red X. We will run our application using the Sense HAT emulator as
    it is easier to display screenshots for this book; however, it is strongly encouraged
    to use the Sense HAT as this makes our application a true IoT device.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by writing code to display a green checkmark.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a checkmark on our Sense HAT
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we will create code that displays a green checkmark against
    a black background on the Sense HAT emulator. To enhance code implementation and
    organization, we will encapsulate the functionality within a Python class. This
    approach simplifies the integration process and promotes code reusability, allowing
    us to easily incorporate the green checkmark display into our IoT application
    project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Prior to writing the code for the GO-NO-GO application, we will create a project
    directory named `GO-NO-GO` on our Raspberry Pi. This dedicated folder will serve
    as a centralized location for organizing and managing files and resources associated
    with our project. To create the checkmark code, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We launch Thonny on our Raspberry Pi, activate the `ch2-env` virtual environment,
    and create a new tab. Inside the tab, we write the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In our code, we do the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We start by importing the `SenseHat` class from the `sense_hat` module (use
    `sense_emu` for the emulator)
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We then define a `GreenCheck` class for displaying a green checkmark on the
    Sense HAT
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We set color values for black and green as RGB tuples.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We then define a list of pixel values representing the checkmark shape.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `GreenCheck` class is initialized with an optional rotation parameter, which
    defaults to `0`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `__init__` method, we create a Sense HAT instance and set the rotation
    to the value of `rotation`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We define a `display` method that sets the Sense HAT’s pixels to the checkmark
    pixel values.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We use `if __name__ == "__main__"` to check whether the code is being run directly
    (not imported).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If `True`, we do the following:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We create an instance of the `GreenCheck` class named `greenCheck` with a rotation
    value of `270`.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We call the `display()` method to show a green checkmark on the Sense HAT.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We save our code as `green_checkmark.py` in the `GO-NO-GO` folder and then run
    it by clicking on the green run button, hitting *F5* on the keyboard, or clicking
    on the **Run** menu option at the top and then **Run** **current script**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After we execute the code, we should see a green checkmark against a black
    background on our Sense HAT emulator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.18 – Green checkmark against black background on Sense HAT’s dot-matrix
    display](img/B21282_02_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.18 – Green checkmark against black background on Sense HAT’s dot-matrix
    display
  prefs: []
  type: TYPE_NORMAL
- en: With the completion of the green checkmark code, we will now shift our focus
    toward creating a NO-GO animation (flashing red X) for our application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a NO-GO animation on our Sense HAT
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The NO-GO animation we have designed consists of a flashing effect on the Sense
    HAT emulator display, alternating between a red X sign on a black background and
    a full red display. To create code for the flashing X sign, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We launch Thonny on our Raspberry Pi, activate the `ch2-env` Python virtual
    environment, and create a new tab. Inside the tab, we start by importing the packages
    we need:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once we have our packages defined, we then start to wrap our code up in a Python
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In our code, we do the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We start by defining a `RedXAnimation` class.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We then set color values for black and red as RGB tuples.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We define `frame1` as a list of pixel values representing a red X sign on a
    black background.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We define `frame2` as a list of pixel values representing a full red display.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From here, we write code for the initialize method in the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In our code, we do the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We use the `__init__` method to initialize the `RedXAnimation` object with an
    optional `rotation` parameter (defaulted to `0`).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside `__init__`, a `SenseHat` instance is created, and the rotation is set
    based on the provided `rotation` value.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `display_animation()` method will cycle through the 2 frames for 59 seconds.
    We do this to align with future client code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In our code, the following happens:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Our `display_animation()` method takes a duration parameter.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We set the number of frames to `2.`
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We calculate the duration for each frame by dividing the total duration by the
    number of frames.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We set the `start_time` variable to the current time using `time.time()`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We calculate the `end_time` value by adding 59 seconds to the `start_time` variable.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We create a loop that runs until the current time exceeds the `end_time` value:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Our code iterates over each frame in the list `[``self.frame1, self.frame2]`.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We set the Sense HAT display pixels to the current frame using `self.sense.set_pixels(frame)`.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We then pause the execution for the frame duration using `time.sleep(frame_duration)`.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We use the `if __name__ == "__main__":` block to ensure that the test code
    is executed only when the script is run directly (not imported as a module):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In our code, the following happens:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: An instance of the `RedXAnimation` class is created with a rotation value of
    270 degrees, assigned to the `animation` variable.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `display_animation()` method of the `animation` object is called, specifying
    a duration of 1 second.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We save our code as `flashing_x.py` in the `GO-NO-GO` folder and then run it
    by clicking on the green run button, hitting *F5* on the keyboard, or clicking
    on the **Run** menu option at the top and then **Run** **current script**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After executing the code, we should observe an animation of a red X sign against
    a black background turn into a full screen of red and back again. In *Figure 2**.19*,
    we can see what this would look like on the emulator:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.19 – NO-GO animation in red screen mode](img/B21282_02_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.19 – NO-GO animation in red screen mode
  prefs: []
  type: TYPE_NORMAL
- en: The NO-GO animation we have created in this section provides a highly effective
    visual indicator on the Sense HAT display. By alternating between a red X sign
    on a black background and a full red display, this animation conveys unfavorable
    conditions that would necessitate the cancellation of a game.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the geolocation for other cities
  prefs: []
  type: TYPE_NORMAL
- en: For finding a city’s geolocation information such as latitude and longitude,
    websites such as *GPS Coordinates* ([https://gps-coordinates.org/](https://gps-coordinates.org/))
    and *Latitude and Longitude Finder* ([https://www.latlong.net/](https://www.latlong.net/))
    are useful. They allow us to input an address or place and receive its precise
    coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: To finish off our application, we will now write the web service and logic layer,
    and we will incorporate our green checkmark and red X sign animation.
  prefs: []
  type: TYPE_NORMAL
- en: Writing GO-NO-GO client code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, it’s time to dive into the exciting phase (subjective, of course) of writing
    code to determine whether a game should be a GO or NO-GO based on weather conditions
    and the age of the players. Our approach will be straightforward: if it’s raining
    and the players are under 16 years of age, it’s a NO-GO; otherwise, it’s a GO.
    While we can certainly implement more complex logic, including **Machine Learning**
    (**ML**) if there are multiple parameters to consider, for simplicity, we’ll focus
    on this basic decision-making process. We do so with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the client code, we launch Thonny on our Raspberry Pi, activate our
    `ch2-env` Python virtual environment, and create a new tab. Inside the tab, we
    start by importing the packages we need:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We’ve covered the first three packages already. For the two modules, we do
    the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We import the `GreenCheck` class from the `green_checkmark` module to display
    a green checkmark for the `RedXAnimation` class from the `flashing_x` module to
    display a flashing red X sign animation when the decision is **NO-GO**.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With our packages and modules in place, we now set our variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In our code, we do the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We set `latitude` to `'42.346268'` and `longitude` to `'-71.095764'` for our
    baseball diamond. For example, this is the GPS coordinates for Fenway Park in
    Boston, Massachusetts, US.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We create a `GreenCheck` object named `go` with a rotation value of 270 degrees.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We create a `RedXAnimation` object named `no_go` with a rotation value of 270
    degrees.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We set our `timer` value to 1 second.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We set the age of our players to 12.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Our code sets the `base_url` value to `"https://api.openweathermap.org/data/2.5/weather"`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we add our OpenWeather `api_key` value.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We then define a `params` dictionary we will use with our web service call (`latitude`,
    `longitude`, `api_key`, and `units`).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We use an infinite loop to check the weather conditions every 60 seconds and
    update the display on our Sense HAT accordingly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In our code, we set up an infinite loop using `while True`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We make a `GET` request to the OpenWeather API using `requests.get()` and store
    the response in `response`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the response status code is `200`, we do the following:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We parse the JSON response into a Python dictionary using `response.json()`
    and assign it to `data`.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We then retrieve the current temperature from `data['main']['temp']` and store
    it in `temperature`.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We retrieve a weather description from `data['weather'][0]['main']` and store
    it in `description`.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We then print the current temperature and weather description. If the weather
    description is `'Thunderstorm'` or (`'Rain'` and `age < 16`), we print `"NO-GO!"`
    to the Shell, display the NO-GO animation using `no_go.display_animation(duration=1)`,
    and set the `timer` variable to 1 second. This is to make the total time before
    calling the web service 60 seconds, as the animation will go on for 59 seconds.
    Otherwise, we print `"GO!"` to the Shell and display the green checkmark animation
    using `go.display()` and then set the `timer` variable to 60 seconds.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If the response status code is not `200`, we print an error message.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We pause the execution for the value of `timer` seconds using `time.sleep(timer)`.
    This will result in a 60-second delay between calls to the OpenWeather web service.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We save our code as `go-no-go.py` in the `GO-NO-GO` folder and then run it by
    clicking on the green run button, hitting *F5* on the keyboard, or clicking on
    the **Run** menu option at the top and then **Run** **current script**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Upon running the code, we will observe the dot-matrix screen of our Sense HAT
    (or emulator) displaying either a green checkmark or a flashing red X sign, indicating
    a GO or NO-GO condition for a game at Fenway Park in Boston. As illustrated in
    *Figure 2**.20*, the current status is a NO-GO for the game involving our players
    (under 16 years of age) due to the presence of thunderstorms:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 2.20 – Screenshot of the GO-NO-GO application using the Sense HAT
    emulator](img/B21282_02_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.20 – Screenshot of the GO-NO-GO application using the Sense HAT emulator
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, the flexibility of our code allows for easy expansion
    of the decision-making logic. In addition to weather data, we can extend our application
    to consider other factors such as wind speed, humidity, or any on-site sensor
    readings. By integrating sensors placed directly at the baseball diamond, we can
    gather real-time data on soil moisture levels or other measurements of interest.
    This sensor information can then be broadcasted to the internet, enabling us to
    seamlessly integrate it into our application.
  prefs: []
  type: TYPE_NORMAL
- en: To make our application more dynamic, we can incorporate scheduling information
    to determine the age of players scheduled to play at a specific baseball diamond
    at any given time. By extracting this information from a spreadsheet or an online
    repository, we can automate the process of obtaining player age data and other
    game-related information such as whether the game is a playoff game. This allows
    our application to dynamically adjust its decision-making process, ensuring a
    more accurate GO or NO-GO decision.
  prefs: []
  type: TYPE_NORMAL
- en: Building other GO-NO-GO applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The GO-NO-GO application marks the last project in the book we will build using
    the Sense HAT. As we have demonstrated, the combination of the Raspberry Pi and
    Sense HAT makes for a powerful IoT device. It’s not hard to imagine how we could
    easily change our baseball GO-NO-GO application for other scenarios. The following
    are a few examples of other GO-NO-GO applications we could build:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Flight status checker**: By integrating with a flight tracking API, we could
    build an application that can display a GO or NO-GO status for a specific flight.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Traffic condition monitor**: Utilizing a traffic data API, we could build
    an application that can assess current traffic conditions on a specific route
    or at a particular location.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event availability indicator**: Integrating with an event ticketing API,
    we could build an application that can determine the availability of tickets for
    a desired event.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Public transportation tracker**: By connecting to a public transportation
    API, we could build an application that can provide real-time updates on the status
    of buses, trains, or other forms of public transportation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The GO-NO-GO IoT application is but a glimpse into our vast potential in utilizing
    web services with IoT. With the Raspberry Pi and Sense HAT, our potential expands
    to diverse IoT applications, monitoring various data and fostering innovation
    beyond weather-related scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we explored the world of web services development using Raspberry
    Pi and Sense HAT. We began by learning about web services and wrote web services
    code. With our newfound knowledge, we created our first IoT application: a scrolling
    stock ticker. By connecting to the Alpha Vantage web service, we retrieved real-time
    stock information and displayed it in a continuous scrolling format on the Sense
    HAT’s dot-matrix display. This project demonstrated the ease of connecting to
    web services to obtain useful information.'
  prefs: []
  type: TYPE_NORMAL
- en: Integrating web services with devices such as the Raspberry Pi is a skill crucial
    in today’s tech industry. By handling data from sources such as Alpha Vantage
    and OpenWeather and displaying it on the Sense HAT, we’ve bridged theory with
    practical application. This knowledge enhances our project capabilities and professional
    skills, positioning us well in the IoT and data-driven domains.
  prefs: []
  type: TYPE_NORMAL
- en: We then ventured into building a weather display application. By leveraging
    the OpenWeather API, we obtained live weather information and transformed it into
    a scrolling message on the Sense HAT. We then took our development to the next
    step and used it to create a decision-making GO-NO-GO IoT application. In the
    GO-NO-GO application, we used weather conditions and player age as criteria to
    determine whether a baseball game should proceed (GO) or be canceled (NO-GO).
    We did so by displaying visual indicators such as a green checkmark or a flashing
    red X sign on the Sense HAT.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore IoT applications that involve physical
    interactions – specifically, the integration of motors. By incorporating motor
    control into our projects, we can create dynamic and interactive experiences that
    bridge the gap between the digital and physical worlds.
  prefs: []
  type: TYPE_NORMAL
