- en: Chapter 7. Lightning Fast Number Crunching with Numba, Parakeet, and pandas
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章：使用Numba、Parakeet和pandas进行闪电般的数值计算
- en: Number crunching is a topic specific to the programming world. However, given
    that Python is so often used for scientific research and data science problems,
    number crunching ends up being a very common topic in the Python world.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 数值计算是编程世界的一个特定主题。然而，鉴于Python经常被用于科学研究与数据科学问题，数值计算最终在Python世界中成为一个非常常见的话题。
- en: That being said, we could just as easily implement our algorithms using the
    information from the earlier six chapters, and we would most likely end up with
    pretty fast and performant code. Again, that information is meant to be for generic
    use cases. There will always be something to say about optimizing for a particular
    case.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，我们同样可以很容易地使用前六章的信息来实现我们的算法，并且我们很可能会得到非常快速且性能良好的代码。再次强调，这些信息旨在用于通用用例。对于特定情况的优化，总会有一些讨论。
- en: In this chapter, we'll cover three options that will help us write faster and
    more optimized code focused on scientific problems. For each one, we'll go over
    the basic installation instructions. We will also look at some code samples showing
    the benefits of each option.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍三种选项，这些选项将帮助我们编写更快、更优化的代码，专注于科学问题。对于每一个，我们将介绍基本安装说明。我们还将查看一些代码示例，展示每个选项的优势。
- en: 'The tools we''ll review in this chapter are as follows:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将要回顾的工具如下：
- en: '**Numba**: This is a module that allows you to write high-performance functions
    in pure Python by generating optimized machine code.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Numba**：这是一个模块，允许你通过生成优化的机器代码，在纯Python中编写高性能函数。'
- en: '**Parakeet**: This is a runtime compiler for scientific operations written
    in a subset of Python. It is ideal for expressing numerical computations.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Parakeet**：这是一个用于在Python子集编写的科学操作的运行时编译器。它非常适合表达数值计算。'
- en: '**pandas**: This is a library that provides a set of high-performance data
    structures and analysis tools.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**pandas**：这是一个提供高性能数据结构和分析工具的库。'
- en: Numba
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Numba
- en: Numba ([http://numba.pydata.org/](http://numba.pydata.org/)) is a module that
    allows you to indicate (via decorators) to the Python interpreter which functions
    should be translated into machine code. Numba thus provides equivalent performance
    to C or Cython without the need to either use a different interpreter or actually
    code in C.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Numba ([http://numba.pydata.org/](http://numba.pydata.org/))是一个模块，允许你通过装饰器指示Python解释器哪些函数应该被转换为机器代码。因此，Numba提供了与C或Cython相当的性能，而无需使用不同的解释器或实际用C语言编写代码。
- en: The module will generate optimized machine code just by requiring it. It can
    even be compiled to run on either CPU or GPU hardware.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块只需要求即可生成优化的机器代码。它甚至可以被编译在CPU或GPU硬件上运行。
- en: 'Here is a very basic example taken from their official site, showing how to
    use it. We''ll go into more detail in a bit:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个来自他们官方网站的非常基础的例子，展示了如何使用它。我们稍后会详细介绍：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note that even though the promise of Numba sounds impressive, the library is
    meant to optimize operations on arrays. It is considerably tied to NumPy (which
    we'll review shortly). So, not every function will be optimizable by it, and using
    it might even hurt performance.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管Numba的承诺听起来很吸引人，但这个库旨在优化数组操作。它与NumPy（我们很快会回顾）有相当大的关联。因此，并非每个函数都可以通过它来优化，使用它甚至可能会损害性能。
- en: 'For instance, let''s take a look at a similar example, one that doesn''t use
    NumPy and accomplishes a similar task:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们看看一个类似的例子，一个不使用NumPy但完成类似任务的例子：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The preceding code has the following execution times, depending on whether
    we keep the `@jit` line or not:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的执行时间取决于我们是否保留了`@jit`行：
- en: 'With the `@jit` line on: 0.3 seconds'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`@jit`行上：0.3秒
- en: 'Without the `@jit` line: 0.1 seconds'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有使用`@jit`行：0.1秒
- en: Installation
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装
- en: 'There are actually two ways to install Numba: you can either use the `conda`
    package manager from Anaconda, or you can just clone the GitHub repo and compile
    it.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，安装Numba有两种方式：你可以使用Anaconda的`conda`包管理器，或者你可以直接克隆GitHub仓库并编译它。
- en: 'If you''re going for the `conda` approach, you can install the command-line
    tool called `miniconda` (which can be downloaded from [http://conda.pydata.org/miniconda.html](http://conda.pydata.org/miniconda.html)).
    After installing it, you can just use the following command:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择使用`conda`方法，你可以安装一个名为`miniconda`的命令行工具（可以从[http://conda.pydata.org/miniconda.html](http://conda.pydata.org/miniconda.html)下载）。安装后，你只需使用以下命令即可：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following screenshot shows the output from this command. The command lists
    all packages that will be installed or updated, specifically `numpy` and `llvmlite`,
    which are direct dependencies from Numba:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了此命令的输出。该命令列出了将要安装或更新的所有包，特别是 `numpy` 和 `llvmlite`，它们是 Numba 的直接依赖项：
- en: '![Installation](img/B02088_07_01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![安装](img/B02088_07_01.jpg)'
- en: 'If, on the other hand, you want to use the source code, you could clone the
    repo by using this command:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想使用源代码，你可以使用以下命令克隆仓库：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You''ll need to have `numpy` and `llvmlite` installed as well. After that,
    you can use the following command:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要安装 `numpy` 和 `llvmlite`。之后，你可以使用以下命令：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the preceding command will succeed even if you don't have the requirements
    installed. However, you won't be able to use Numba unless you install them.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，即使你没有安装这些要求，前面的命令也会成功。然而，除非你安装了它们，否则你将无法使用 Numba。
- en: 'In order to check whether your installation was successful, you can do a simple
    check from the Python REPL:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查你的安装是否成功，你可以在 Python REPL 中进行简单的检查：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Using Numba
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Numba
- en: 'Now that you have managed to install Numba, let''s take a look at what we can
    do with it. The main features provided by this module are as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经成功安装了 Numba，让我们看看我们可以用它做什么。此模块提供的主要功能如下：
- en: On-the-fly code generation
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即时代码生成
- en: Native code generation for both CPU and GPU hardware
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 针对CPU和GPU硬件的原生代码生成
- en: Integration with Python's scientific software, thanks to the Numpy dependency
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于 Numpy 依赖项，与 Python 的科学软件集成
- en: Numba's code generation
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Numba 的代码生成
- en: When it comes to code generation, the main feature of Numba is its `@jit` decorator.
    Using it, you can mark a function for optimization under Numba's JIT compiler.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到代码生成时，Numba 的主要功能是其 `@jit` 装饰器。使用它，你可以标记一个函数在 Numba 的 JIT 编译器下进行优化。
- en: We already talked about the benefits of having a JIT compiler in the previous
    chapter, so we won't go into the details here. Instead, let's see how to use the
    decorator for our benefit.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在上一章中讨论了拥有 JIT 编译器的优势，所以这里不再详细说明。相反，让我们看看如何使用装饰器来为我们带来好处。
- en: 'There are several ways to use this decorator. The default one, which is also
    the recommended way, is the one we already showed earlier:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以使用这个装饰器。默认的方法，也是推荐的方法，就是我们之前展示的方法：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following code will cause Numba to generate the optimized code once the
    function is called. It''ll try to infer the types of its attributes and the return
    type of the function:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将在函数被调用时让 Numba 生成优化代码。它将尝试推断其属性的类型和函数的返回类型：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If you call the same function with different types, then different code paths
    will be generated and optimized.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你用不同的类型调用相同的函数，那么将生成并优化不同的代码路径。
- en: Eager compilation
  id: totrans-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 贪婪编译
- en: On the other hand, if you happen to know the types that your function will receive
    (and optionally, return), you could pass those to the `@jit` decorator. Then,
    only that specific case would be optimized.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果你知道你的函数将接收（可选地，返回）的类型，你可以将这些传递给 `@jit` 装饰器。然后，只有那个特定的案例会被优化。
- en: 'The following code shows the added code needed to pass in the function signature:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了传递函数签名所需的附加代码：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here are the most common types that are used to specify function signatures:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这里列出了用于指定函数签名最常见的类型：
- en: '`void`: These are used as the return type for functions not returning anything'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void`：这些用于不返回任何内容的函数的返回类型'
- en: '`intp` and `uintp`: These are pointer-sized integers, signed and unsigned respectively'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`intp` 和 `uintp`：这些是指针大小的整数，分别是带符号和无符号的'
- en: '`intc` and `uintc`: These are the C equivalent to the int and unsigned int
    types'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`intc` 和 `uintc`：这些是 C 语言中 int 和 unsigned int 类型的等价类型'
- en: '`int8`, `int16`, `int32`, and `int64`: These are the fix-width integers of
    the corresponding bit width (for the unsigned version, just add `u` as a prefix,
    for instance, `uint8`)'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int8`、`int16`、`int32` 和 `int64`：这些是相应位宽的固定宽度整数（对于无符号版本，只需在前面添加 `u` 作为前缀，例如，`uint8`）'
- en: '`float32` and `float64`: These are single and double-precision floating-point
    numbers'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float32` 和 `float64`：这些是单精度和双精度浮点数'
- en: '`complex64` and `complex128`: These represent single and double-precision complex
    numbers'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`complex64` 和 `complex128`：这些表示单精度和双精度复数'
- en: Arrays can also be declared by indexing any of the numeric types, for example,
    `float32[:]` for a one-dimensional floating-point number array and `int32[:,:]`
    for a two-dimensional integer array
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组也可以通过索引任何数值类型来声明，例如，`float32[:]`用于一维浮点数数组，`int32[:,:]`用于二维整数数组
- en: Other configuration settings
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 其他配置设置
- en: Apart from eager compilation, there are two more options we can pass onto the
    `@jit` decorator. These options will help us force Numba's optimization. They
    are described here.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 除了急切编译之外，我们还可以将两个选项传递给`@jit`装饰器。这些选项将帮助我们强制Numba的优化。它们在这里进行了描述。
- en: No GIL
  id: totrans-60
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 无GIL
- en: Whenever our code is optimized using native types (rather than using Python
    types), the GIL (which we discussed in [Chapter 6](ch06.html "Chapter 6. Generic
    Optimization Options"), *Generic Optimization Options*) is no longer necessary.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的代码使用原生类型（而不是使用Python类型）进行优化时，GIL（我们在[第6章](ch06.html "第6章。通用优化选项")中讨论过，*通用优化选项*）就不再必要了。
- en: We have a way of disabling the GIL in such cases. We can pass the `nogil=True`
    attribute to the decorator. This way, we can run Python code (or Numba code) concurrently
    with other threads.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一种方法可以禁用GIL。我们可以将`nogil=True`属性传递给装饰器。这样，我们可以在其他线程中同时运行Python代码（或Numba代码）。
- en: That being said, remember that if you don't have the GIL limitation, then you
    will have to deal with the common problems of multithreaded systems (consistency,
    synchronization, race conditions, and so on).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，请记住，如果您没有GIL限制，那么您将不得不处理多线程系统的常见问题（一致性、同步、竞态条件等）。
- en: NoPython mode
  id: totrans-64
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 无Python模式
- en: This option will let us set the compilation mode of Numba. By default, it will
    try to jump between modes. It will try to decide the best mode possible depending
    on the code of the optimized function.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 此选项将允许我们设置Numba的编译模式。默认情况下，它将尝试在模式之间跳跃。它将根据优化函数的代码尝试决定最佳模式。
- en: There are two modes that are available. On one hand, there is `object` mode.
    It generates code capable of handling all Python objects and uses the C API to
    perform operations on those objects. On the other hand, the `nopython` mode generates
    much faster code by avoiding the calls to the C API. The only problem with it
    is that only a subset of functions and methods are available to be used.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种模式可供选择。一方面，有`object`模式。它生成能够处理所有Python对象的代码，并使用C API对这些对象进行操作。另一方面，`nopython`模式通过避免调用C
    API来生成更快的代码。它的唯一问题是，只有一部分函数和方法可供使用。
- en: The `object` mode will not generate faster code unless Numba can take advantage
    of loop-jitting (which means that a loop can be extracted and compiled in `nopython`
    mode).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 除非Numba可以利用循环即时编译（这意味着可以提取并编译为`nopython`模式的循环），否则`object`模式不会生成更快的代码。
- en: 'What we can do is force Numba to go into `nopython` mode and raise an error
    if such a thing is not possible. This can be done using these lines of code:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以强制Numba进入`nopython`模式，并在这种事情不可能的情况下引发错误。这可以通过以下代码行来完成：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The issue with the `nopython` mode is that it has certain restrictions, apart
    from the limited subset of Python it supports:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`nopython`模式的问题在于它有一些限制，除了支持的Python有限子集之外：'
- en: The native types used for all values inside the function have to be capable
    of being inferred
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数内部使用的所有值的原生类型必须能够被推断
- en: No new memory can be allocated inside the function
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数内部不能分配新的内存
- en: As an added extra, for loop-jitting to take place, the to-be-optimized loops
    can't have a return statement inside. Otherwise, they won't be eligible for optimization.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 作为额外的补充，为了进行循环即时编译，待优化的循环不能包含返回语句。否则，它们将不符合优化条件。
- en: 'So, let''s now look at an example of how this will look for our code:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，现在让我们看看我们的代码将如何呈现这个例子：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The preceding example is taken from the Numba site. It shows a function that
    is eligible for loop-jitting, also called loop-lifting. To make sure it works
    as expected, we can use the Python REPL as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例取自Numba网站。它显示了一个符合循环即时编译条件的函数，也称为循环提升。为了确保它按预期工作，我们可以使用Python REPL如下：
- en: '![NoPython mode](img/B02088_07_02.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![无Python模式](img/B02088_07_02.jpg)'
- en: Alternatively, we can also call the `inspect_types` method directly from our
    code. The benefit of the latter is that we'll also have access to the source code
    of our functions. This is a great advantage when trying to match Numba-generated
    instructions to lines of code.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们也可以直接从我们的代码中调用`inspect_types`方法。后者的好处是，我们还将有权访问我们函数的源代码。当尝试将Numba生成的指令与代码行匹配时，这是一个巨大的优势。
- en: The preceding output is useful to understand the behind-the-scenes action that
    goes on when we optimize our code with Numba. More specifically, we can understand
    how it infers the types, whether there is any automatic optimization going on,
    and basically, how many instructions each Python line is translated into.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出有助于理解我们在使用 Numba 优化代码时幕后发生的动作。更具体地说，我们可以理解它是如何推断类型的，是否有任何自动优化正在进行，以及基本上每行
    Python 代码被转换成多少条指令。
- en: 'Let''s take a look at the output we would get from calling the `inspect_types`
    method from within our code (which is considerably more detailed than using the
    REPL):'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看从我们代码内部调用 `inspect_types` 方法会得到什么输出（这比使用 REPL 得到的输出详细得多）：
- en: Note
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the following code is a reduced version of the entire output. If you
    want to study it completely, you need to run the command on your computer.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下代码是整个输出的简化版本。如果你想完全研究它，你需要在自己的计算机上运行该命令。
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In order to understand the preceding output, notice how every commented block
    starts with the line number of the original source code. It then follows with
    the instructions generated by that line, and finally, you'll see the uncommented
    Python line you wrote.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解前面的输出，请注意每个注释块都是以原始源代码的行号开始的。然后是那条指令生成的指令，最后你会看到你编写的未注释的 Python 代码行。
- en: Notice the `LiftedLoop` line. In this line, you can see the automatic optimization
    done by Numba. Also, notice the type inferred by Numba at the end of most lines.
    Whenever you see a `pyobject` property, it means that it is not using a native
    type. Instead, it is using a generic object that wraps all Python types.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `LiftedLoop` 行。在这行中，你可以看到 Numba 自动进行的优化。同时，注意 Numba 在大多数行末推断的类型。每当看到 `pyobject`
    属性时，这意味着它没有使用原生类型。相反，它使用一个通用的对象，该对象封装了所有 Python 类型。
- en: Running your code on the GPU
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 GPU 上运行你的代码
- en: As it's been already mentioned, Numba provides support to run our code on both
    CPU and GPU hardware. This, in practice, would allow us to improve the performance
    of certain computations by running them in an environment better suited for parallel
    computation than the CPU.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Numba 支持在 CPU 和 GPU 硬件上运行我们的代码。在实践中，这将允许我们通过在更适合并行计算的 CPU 环境中运行某些计算来提高这些计算的性能。
- en: More specifically, Numba supports CUDA programming ([http://www.nvidia.com/object/cuda_home_new.html](http://www.nvidia.com/object/cuda_home_new.html))
    by translating a subset of Python functions into CUDA kernels and devices following
    the CUDA execution model.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，Numba 通过将 Python 函数的子集转换为遵循 CUDA 执行模型的 CUDA 内核和设备，支持 CUDA 编程（[http://www.nvidia.com/object/cuda_home_new.html](http://www.nvidia.com/object/cuda_home_new.html)）。
- en: CUDA is a parallel computing platform and programming model invented by Nvidia.
    It enables considerable speed boosts by harnessing the power of GPUs.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: CUDA 是由 Nvidia 发明的并行计算平台和编程模型。它通过利用 GPU 的能力来实现显著的加速。
- en: GPU programming is a topic that could most likely fill an entire book, so we
    won't go into details here. Instead, we'll just mention that Numba possesses this
    capability and that it can be achieved using the `@cuda.jit` decorator. For full
    documentation on this subject, refer to the official documents at [http://numba.pydata.org/numba-doc/0.18.2/cuda/index.html](http://numba.pydata.org/numba-doc/0.18.2/cuda/index.html).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: GPU 编程是一个可能填满整本书的主题，所以我们在这里不会深入细节。相反，我们只是提到 Numba 具有这种能力，并且可以使用 `@cuda.jit`
    装饰器来实现。关于这个主题的完整文档，请参阅官方文档[http://numba.pydata.org/numba-doc/0.18.2/cuda/index.html](http://numba.pydata.org/numba-doc/0.18.2/cuda/index.html)。
- en: The pandas tool
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: pandas 工具
- en: The second tool that we'll discuss in this chapter is called pandas ([http://pandas.pydata.org/](http://pandas.pydata.org/)).
    It is an open source library that provides high-performance, easy-to-use data
    structures, and data-analysis tools for Python.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将讨论的第二款工具被称为 pandas（[http://pandas.pydata.org/](http://pandas.pydata.org/)）。它是一个开源库，为
    Python 提供高性能、易于使用的数据结构和数据分析工具。
- en: This tool was invented back in 2008 by developer Wes McKinney while needing
    a performant solution to perform quantitative analysis on financial data. The
    library has become one of the most popular and active projects in the Python community.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工具是在 2008 年由开发者 Wes McKinney 发明的，当时他需要一个高性能的解决方案来对金融数据进行定量分析。这个库已经成为 Python
    社区中最受欢迎和最活跃的项目之一。
- en: One thing to note regarding the performance of code written using pandas is
    that parts of its critical code paths were written using Cython (we covered Cython
    in [Chapter 6](ch06.html "Chapter 6. Generic Optimization Options"), *Generic
    Optimization Options*).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 关于使用 pandas 编写的代码的性能，有一点需要注意，那就是其关键代码路径的部分是用 Cython 编写的（我们已经在第 6 章[通用优化选项](ch06.html
    "第 6 章。通用优化选项")中介绍了 Cython）。
- en: Installing pandas
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 pandas
- en: Given the popularity of pandas, there are many ways to install it onto your
    system. It all depends on the type of setup you have.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 pandas 的流行，有许多方法可以将它安装到您的系统上。这完全取决于您的设置类型。
- en: The recommended way is to directly install the Anaconda Python distribution
    ([docs.continuum.io/anaconda/](http://docs.continuum.io/anaconda/)), which comes
    packed with pandas and the rest of the SciPy stack (such as NumPy, Matplotlib,
    and so on). This way, by the time you're done, you'd have installed over 100 packages
    and downloaded several 100 megabytes of data during the process.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐的方式是直接安装 Anaconda Python 发行版（[docs.continuum.io/anaconda/](http://docs.continuum.io/anaconda/))，它包含了
    pandas 和 SciPy 堆栈的其余部分（如 NumPy、Matplotlib 等）。这样，完成时，您将安装超过 100 个软件包，并在过程中下载了几个
    100 兆字节数据。
- en: 'If, on the other hand, you don''t want to deal with the full Anaconda distribution,
    you could use `miniconda` (which we already covered earlier when discussing Numba''s
    installation). With this approach, you can use the `conda` package manager by
    following these steps:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想处理完整的 Anaconda 发行版，可以使用 `miniconda`（我们在讨论 Numba 的安装时已经介绍过它）。采用这种方法，您可以通过以下步骤使用
    `conda` 包管理器：
- en: 'Create a new environment in which you can install a new version of Python using
    this line of code:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码行创建一个新的环境，您可以在其中安装 Python 的新版本：
- en: '[PRE12]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Enable that environment:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用该环境：
- en: '[PRE13]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, install pandas:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，安装 pandas：
- en: '[PRE14]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Additionally, pandas can be installed using the `pip` command-line tool (probably,
    the easiest and most compatible way of doing it) using this line of code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，可以使用 `pip` 命令行工具（可能是最简单、最兼容的方式）通过以下代码行安装 pandas：
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, one more option could be installing it using your OS''s package manager,
    given that the package is available:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还有一个选项是使用您的操作系统包管理器安装它，前提是该软件包可用：
- en: '| Distribution | Repo link | Installation method |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| 发行版 | 仓库链接 | 安装方法 |'
- en: '| --- | --- | --- |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Debian | [packages.debian.org/search?keywords=pandas&searchon=names&suite=all&section=all](http://packages.debian.org/search?keywords=pandas&searchon=names&suite=all&section=all)
    |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| Debian | [packages.debian.org/search?keywords=pandas&searchon=names&suite=all&section=all](http://packages.debian.org/search?keywords=pandas&searchon=names&suite=all&section=all)
    |'
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '|'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Ubuntu | [http://packages.ubuntu.com/search?keywords=pandas&searchon=names&suite=all&section=all](http://packages.ubuntu.com/search?keywords=pandas&searchon=names&suite=all&section=all)
    |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| Ubuntu | [http://packages.ubuntu.com/search?keywords=pandas&searchon=names&suite=all&section=all](http://packages.ubuntu.com/search?keywords=pandas&searchon=names&suite=all&section=all)
    |'
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '|'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| OpenSUSE and Fedora | [http://software.opensuse.org/package/python-pandas?search_term=pandas](http://software.opensuse.org/package/python-pandas?search_term=pandas)
    |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| OpenSUSE 和 Fedora | [http://software.opensuse.org/package/python-pandas?search_term=pandas](http://software.opensuse.org/package/python-pandas?search_term=pandas)
    |'
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '|'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: If the preceding options fail and you choose to install pandas from source,
    you can get the instructions from their website at [http://pandas.pydata.org/pandas-docs/stable/install.html](http://pandas.pydata.org/pandas-docs/stable/install.html).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果前面的选项失败，并且您选择从源安装 pandas，您可以从他们的网站[http://pandas.pydata.org/pandas-docs/stable/install.html](http://pandas.pydata.org/pandas-docs/stable/install.html)获取说明。
- en: Using pandas for data analysis
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 pandas 进行数据分析
- en: In the world of big data and data analytics, having the right tools for the
    job means having the upper hand (of course, this is just one side of the story;
    the other one is knowing how to use them). For data analysis and, more specifically,
    for ad hoc tasks and data cleanup processes, one would normally use a programming
    language. A programming language would provide considerably more flexibility than
    a standard tool.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在大数据和数据分析的世界里，拥有适合工作的正确工具意味着掌握主动权（当然，这只是故事的一方面；另一方面是知道如何使用它们）。对于数据分析，尤其是对于临时任务和数据清理过程，人们通常会使用一种编程语言。编程语言将提供比标准工具大得多的灵活性。
- en: 'That being said, there are two languages that lead this particular performance
    race: R and Python. In the case of Python, this might come as a bit of a shock
    for some, since we''ve been showing nothing but evidence that Python by itself
    is not fast enough when it comes to number crunching. This is why libraries such
    as pandas are created.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，有两种语言在这次特定的性能竞赛中领先：R和Python。对于Python来说，这可能会让一些人感到有些惊讶，因为我们一直展示的证据表明，Python本身在数值计算方面并不足够快。这就是为什么创建了像pandas这样的库。
- en: 'It provides tools designed to ease and simplify the task commonly known as
    "data wrangling", such as:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 它提供了旨在简化通常被称为“数据处理”任务的工具，例如：
- en: The ability to load big data files into memory and stream out
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够将大数据文件加载到内存中并流式传输
- en: Simple integration with `matplotlib` ([http://matplotlib.org/](http://matplotlib.org/)),
    which enables it to create interactive plots with very few lines of code
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单地与`matplotlib`（[http://matplotlib.org/](http://matplotlib.org/)）集成，这使得它能够用很少的代码创建交互式图表
- en: Simple syntax to deal with missing data, dropping fields, and so on
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单的语法来处理缺失数据、删除字段等
- en: Let's now look at a very simple and quick example of how using pandas can benefit
    the performance of your code as well as improve the syntax of your programs. The
    following code grabs a CSV file, with a portion of the export (a 500 MB file)
    from the **311 service requests from 2010 to present** taken from the NYC OpenData
    site ([https://data.cityofnewyork.us/Social-Services/311-Service-Requests-from-2010-to-Present/erm2-nwe9](https://data.cityofnewyork.us/Social-Services/311-Service-Requests-from-2010-to-Present/erm2-nwe9)).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一个非常简单且快速的例子，说明使用pandas如何提高代码的性能以及改进程序的语法。以下代码抓取了一个CSV文件，其中包含从纽约市开放数据网站（[https://data.cityofnewyork.us/Social-Services/311-Service-Requests-from-2010-to-Present/erm2-nwe9](https://data.cityofnewyork.us/Social-Services/311-Service-Requests-from-2010-to-Present/erm2-nwe9)）获取的2010年至现在的**311服务请求**的一部分（一个500MB的文件）。
- en: 'It then tries to simply calculate the number of records per zip code using
    both plain Python and pandas code:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它尝试简单地使用纯Python和pandas代码计算每个邮编的记录数：
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `process` function is very simple. It has only five lines of code. It loads
    the file, does a bit of processing (mainly manual grouping and counting), and
    finally, it sorts the results and returns the first 10 of them. As an added bonus,
    we use the `defaultdict` data type, which we mentioned a few chapters ago as a
    possible performance improvement in these cases.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`process` 函数非常简单。它只有五行代码。它加载文件，进行一些处理（主要是手动分组和计数），最后，它对结果进行排序并返回前10个。作为额外的奖励，我们使用了`defaultdict`数据类型，这是我们之前提到的一种可能的性能改进方法。'
- en: On the other side, the `process_pandas` function does essentially the same thing,
    only with pandas. We have some more lines of code, but they are quite simple to
    understand. They're clearly "data-wrangling oriented", as you can see that there
    are no loops declared. We can even access the columns by name automatically and
    apply functions over those groups of records without having to manually iterate
    over them.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一方面，`process_pandas`函数基本上做了同样的事情，只是使用了pandas。我们有一些更多的代码行，但它们很容易理解。它们显然是“数据处理导向”的，正如您所看到的，没有声明循环。我们甚至可以自动通过名称访问列，并在这些记录组上应用函数，而无需手动遍历它们。
- en: 'The following screenshot shows the output of the preceding code:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了前面代码的输出：
- en: '![Using pandas for data analysis](img/B02088_07_04.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![使用pandas进行数据分析](img/B02088_07_04.jpg)'
- en: 'As you can see, there is a 3-second improvement on the performance of our algorithm
    when we simply reimplement it in pandas. Let''s now dig a bit deeper into the
    API of pandas in order to get even better numbers. There are two major improvements
    we can make to our code, and they''re both related to the `read_csv` method, which
    uses a lot of parameters. Two of these parameters are of real interest to us:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，当我们简单地使用pandas重新实现算法时，我们的算法性能提高了3秒。现在让我们更深入地了解pandas的API，以便获得更好的数据。我们可以对我们的代码进行两项主要改进，它们都与`read_csv`方法有关，该方法使用了许多参数。其中两个参数对我们来说非常有兴趣：
- en: '`usecols`: This will only return the columns we want, effectively helping us
    deal with only 2 columns out of the 40+ our dataset has. This will also help us
    get rid of the logic that we have to drop the columns before returning the results.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`usecols`：这将只返回我们想要的列，有效地帮助我们处理数据集中40多列中的仅2列。这也有助于我们摆脱在返回结果前必须删除列的逻辑。'
- en: '`converters`: This allows us to auto-convert data with a function, instead
    of calling the apply method, as we will do now.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`converters`：这允许我们使用一个函数自动转换数据，而不是像我们现在这样做调用 apply 方法。'
- en: 'Our new function looks like this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新函数看起来是这样的：
- en: '[PRE20]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'That''s right. Only two lines of code! The reader will do all the work for
    us. Then, we need to simply group, count, and sort. Now, check out how this looks
    compared to our previous results:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 没错。只有两行代码！读者将为我们完成所有工作。然后，我们只需要简单地分组、计数和排序。现在，来看看这与我们之前的结果相比如何：
- en: '![Using pandas for data analysis](img/B02088_07_05.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![使用 pandas 进行数据分析](img/B02088_07_05.jpg)'
- en: That's a 10-second improvement on the performance of our algorithm and considerably
    less code to deal with, otherwise known as a "win-win" situation.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在我们的算法性能上提高了 10 秒，并且处理代码量大大减少，这通常被称为“双赢”的情况。
- en: An added bonus to our code is that it scales. The pandas-based function can
    deal with a 5.9 GB file in just 30 seconds with no changes. On the other hand,
    our pure Python code won't even load that file in that time, let alone process
    it if we don't have enough resources.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们代码的一个额外好处是它具有可扩展性。基于 pandas 的函数只需 30 秒就能处理 5.9 GB 的文件，而且无需任何更改。另一方面，我们的纯 Python
    代码甚至无法在这么短的时间内加载该文件，更不用说在没有足够资源的情况下处理它了。
- en: Parakeet
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Parakeet
- en: This one is the most specific tool yet to deal with numbers in Python. It is
    very specific because it only supports a very narrow subset of the resulting combination
    of Python and NumPy. So, if you're dealing with anything outside that universe,
    this might not be an option for you, but if you can fit your solution into it,
    then keep on reading.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这是迄今为止处理 Python 中数字的最具体工具。它非常具体，因为它只支持 Python 和 NumPy 结果组合的非常狭窄的子集。因此，如果你处理的是该宇宙之外的内容，这可能不是你的选择，但如果你可以将你的解决方案放入其中，那么请继续阅读。
- en: 'To be more specific about the limited universe that Parakeet supports (normally
    useful only to express numerical computations), here is a short list:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要更具体地说明 Parakeet 支持的有限宇宙（通常仅用于表示数值计算，通常情况下并不常用），以下是一个简短的列表：
- en: Types supported by Python are numbers, tuples, slices, and NumPy's arrays
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 支持的类型有数字、元组、切片和 NumPy 的数组
- en: Parakeet follows the upcasting rule, that is, whenever two values of different
    types try to reach the same variable, they'll be upcast into a unifying one. For
    instance, the Python expression `1.0 if b else false` would translate to `1.0
    if b else 0.0`, but when automatic casting isn't possible, such as `1.0 if b else
    (1,2)`, then an uncatchable exception (see next point) will be raised during compilation
    time.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Parakeet 遵循向上提升规则，即当两个不同类型的值试图达到同一个变量时，它们将被提升为统一的类型。例如，Python 表达式 `1.0 if b
    else false` 将转换为 `1.0 if b else 0.0`，但当自动转换不可行时，例如 `1.0 if b else (1,2)`，则在编译时将引发不可捕获的异常（见下一点）。
- en: Catching or even raising exceptions isn't possible in Parakeet; neither are
    break and continue statements. This is because Parakeet represents programs using
    structured SSA ([http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.45.4503](http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.45.4503)).
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Parakeet 中无法捕获或甚至引发异常；也无法使用 break 和 continue 语句。这是因为 Parakeet 使用结构化 SSA ([http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.45.4503](http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.45.4503))
    来表示程序。
- en: Array broadcasting (a feature of NumPy) is partially implemented by inserting
    explicit map operators based on the types of array arguments. This is a limited
    implementation because it can't really handle an expansion of dimensions (such
    as broadcasting 8 x 2 x 3 and 7 x 2 arrays).
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组广播（NumPy 的一个特性）通过根据数组参数的类型插入显式的映射操作符部分实现。这是一个有限的实现，因为它实际上无法处理维度的扩展（例如广播 8
    x 2 x 3 和 7 x 2 数组）。
- en: There is only a small subset of the built-in functions of Python and NumPy that
    have been implemented. The complete list can be seen at [https://github.com/iskandr/parakeet/blob/master/parakeet/mappings.py](https://github.com/iskandr/parakeet/blob/master/parakeet/mappings.py).
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有 Python 和 NumPy 内置函数的一小部分被实现。完整的列表可以在[https://github.com/iskandr/parakeet/blob/master/parakeet/mappings.py](https://github.com/iskandr/parakeet/blob/master/parakeet/mappings.py)中查看。
- en: List comprehension expressions are treated as array comprehensions.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表推导表达式被视为数组推导表达式。
- en: Installing Parakeet
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Parakeet
- en: 'The installation of Parakeet is simple enough. There are no hard-to-get requirements
    if you want to go with the `pip` route. Simply type the following command:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Parakeet 的安装很简单。如果你选择使用 `pip` 路径，没有难以满足的要求。只需输入以下命令：
- en: '[PRE21]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: And you're done!
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 完成了！
- en: 'If, on the other hand, you want to directly try the source code approach, you
    would need some other packages installed beforehand. Here is a list of these packages:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要直接尝试源代码方法，你需要在之前安装一些其他包。以下是这些包的列表：
- en: '**Python 2.7**'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Python 2.7**'
- en: '**dsltools** ([https://github.com/iskandr/dsltools](https://github.com/iskandr/dsltools))'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**dsltools** ([https://github.com/iskandr/dsltools](https://github.com/iskandr/dsltools))'
- en: '**nose** for running the tests ([https://nose.readthedocs.org/en/latest/](https://nose.readthedocs.org/en/latest/))'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**nose** 用于运行测试 ([https://nose.readthedocs.org/en/latest/](https://nose.readthedocs.org/en/latest/))'
- en: '**NumPy** ([http://www.scipy.org/install.html](http://www.scipy.org/install.html))'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NumPy** ([http://www.scipy.org/install.html](http://www.scipy.org/install.html))'
- en: '**appDirs** ([https://pypi.python.org/pypi/appdirs/](https://pypi.python.org/pypi/appdirs/))'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**appDirs** ([https://pypi.python.org/pypi/appdirs/](https://pypi.python.org/pypi/appdirs/))'
- en: '**gcc 4.4+** for the OpenMP back-end, which is the default one'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**gcc 4.4+** 用于OpenMP后端，这是默认的后端'
- en: Note
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you're on a Windows box, you would have better luck if it's a 32-bit machine.
    Otherwise, you might be out of luck since there is no official documentation on
    the subject.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是Windows系统，如果是32位机器，你可能会有更好的运气。否则，你可能运气不佳，因为关于这个主题没有官方文档。
- en: If you are a OS X user you'll probably want to install a more up-to-date version
    of the C compiler using HomeBrew, since either clang or the installed version
    of `gcc` might not be updated enough.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是OS X系统，你可能需要使用HomeBrew安装更新版本的C编译器，因为无论是clang还是已安装的`gcc`版本可能更新不足。
- en: 'After the prerequisites are met, simply download the code from: [https://github.com/iskandr/parakeet](https://github.com/iskandr/parakeet)
    and run the following command (from within the code''s folder):'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 满足先决条件后，只需从以下链接下载代码：[https://github.com/iskandr/parakeet](https://github.com/iskandr/parakeet)，并在代码文件夹内运行以下命令：
- en: '[PRE22]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How does Parakeet work?
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Parakeet是如何工作的？
- en: Instead of going deep into the details about the theory behind Parakeet, let's
    simply see how to use it to optimize our code. This will help you get a feel of
    the module without having to chew through all the documentation.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不深入探讨Parakeet背后理论的细节，而是简单看看如何使用它来优化我们的代码。这将帮助你了解这个模块，而无需阅读所有文档。
- en: The main construct of this library is a decorator that you can apply to your
    functions, so Parakeet can take control and optimize your code if possible.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这个库的主要结构是一个装饰器，你可以将其应用于你的函数，这样Parakeet就可以接管并尽可能优化你的代码。
- en: 'For our simple test, let''s take one of the example functions presented on
    Parakeet''s website and run a simple test against a `4000` * `4000` random floating-point
    list. The code will run the same function in both an optimized way using Parakeet,
    and in an unoptimized way. Then, it will measure the time each one takes to process
    the exact same input:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的简单测试，让我们从Parakeet网站上提供的示例函数中选取一个，并对一个`4000` * `4000`的随机浮点数列表进行简单测试。代码将以优化和非优化两种方式运行相同的函数，然后测量每种方式处理相同输入所需的时间：
- en: '[PRE23]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In an i7 processor, with 8 GB of RAM, this is the performance we get:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在i7处理器和8GB RAM的情况下，我们得到了以下性能：
- en: '![How does Parakeet work?](img/B02088_07_06.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![Parakeet是如何工作的？](img/B02088_07_06.jpg)'
- en: The preceding screenshot shows the amazing performance boost we get in this
    particular function (which complies with the required subset of Python supported
    by Parakeet).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 上述截图显示了在这个特定函数（符合Parakeet支持的Python所需子集）中我们获得的惊人的性能提升。
- en: Simply put, the decorated function is being used as a template from which several
    type-specialized functions are created, one for each input type (in our case,
    we only need one). It is these new functions that get optimized in several different
    ways by Parakeet before getting translated into native code.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，被装饰的函数被用作模板，从中创建了多个类型特定的函数，每个输入类型一个（在我们的例子中，我们只需要一个）。这些新函数在转换为本地代码之前，会通过Parakeet以多种不同的方式优化。
- en: Note
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that even though the performance gain is amazing, Parakeet only supports
    a very limited version of Python, so it is not really meant to be a general purpose
    optimizer (quite the opposite actually).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管性能提升惊人，但Parakeet只支持非常有限的Python版本，因此它并不是真正意义上的通用优化器（实际上正好相反）。
- en: Summary
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we covered three alternatives to data processing with Python.
    We covered specific use cases (but with amazing benefits), such as Parakeet, and
    others more generic ones, such as pandas and Numba. For all three of them, we
    covered the basics: description, installation, and an example. There is a lot
    more to discover for each one, depending on your specific needs. However, the
    information provided here should be enough to start you in the right direction.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了使用Python进行数据处理的三种替代方案。我们涵盖了具体的用例（但具有惊人的好处），例如Parakeet，以及其他更通用的方案，如pandas和Numba。对于这三个方案，我们都介绍了基础知识：描述、安装和示例。对于每一个方案，都有更多可以探索的内容，这取决于你的具体需求。然而，这里提供的信息应该足以让你开始正确的方向。
- en: For the next and final chapter, we'll cover a practical example of a script
    in need of optimization. We'll try to apply everything (or as much as makes sense)
    that we've covered so far in the book.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章和最后一章中，我们将讨论一个需要优化的脚本的实际例子。我们将尝试应用本书中迄今为止所涵盖的所有内容（或尽可能多的内容）。
