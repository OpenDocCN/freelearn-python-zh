["```py\nimport pytest\n\n@pytest.fixture\ndef goog():\n    return Stock(\"GOOG\")\n\ndef test_stock_update(goog):\n    assert goog.price is None\n```", "```py\ndef test_stock_update(self):\n    \"\"\"An update should set the price on the stock object\n\n    We will be  using the `datetime` module for the timestamp\n    \"\"\"\n    self.goog.update(datetime(2014, 2, 12), price=10)\n    self.assertEqual(10, self.goog.price)\n```", "```py\ndef test_stock_update(self):\n    self.goog.update(datetime(2014, 2, 12), price=10)\n    self.goog.price.should.equal(10)\n```", "```py\ndef test_stock_price_should_give_the_latest_price(self):\n    self.goog.update(datetime(2014, 2, 12), price=10)\n    self.goog.update(datetime(2014, 2, 13), price=8.4)\n    self.goog.price.should.equal(8.4, epsilon=0.0001)\n```", "```py\ndef test_negative_price_should_throw_ValueError(self):\n    self.goog.update.when.called_with(datetime(2014, 2, 13), -1).\\\n        should.throw(ValueError)\n```", "```py\ndef test_stock_update(self):\n    self.goog.update(datetime(2014, 2, 12), price=10)\n    assert self.goog.price.should.equal(10)\n```", "```py\ndef test_stock_price_should_give_the_latest_price(self):\n    self.goog.update(datetime(2014, 2, 12), price=10)\n    self.goog.update(datetime(2014, 2, 13), price=8.4)\n    expect(self.goog.price).should.equal(8.4, epsilon=0.0001)\n```", "```py\ndef test_stock_update(self):\n    self.goog.update(datetime(2014, 2, 12), price=10)\n    assert_that(self.goog.price, equal_to(10))\n```", "```py\nclass StockCrossoverMatcher(BaseMatcher):\n    signal_names = {\n        StockSignal.buy: \"buy\",\n        StockSignal.sell: \"sell\",\n        StockSignal.neutral: \"neutral\"\n    }\n\n    def __init__(self, signal, date_to_check):\n        self.signal = signal\n        self.date_to_check = date_to_check\n\n    def _matches(self, item):\n        return self.signal == \\\n            item.get_crossover_signal(self.date_to_check)\n\n    def describe_to(self, description):\n        signal_name = self.signal_names[self.signal]\n        return description.append_text(\n                \"stock crossover signal is {} \".format(signal_name))\n```", "```py\ndef is_buy_on(date_to_check):\n    return StockCrossoverMatcher(StockSignal.buy, date_to_check)\n```", "```py\ndef test_with_upward_crossover_returns_buy(self):\n    self.given_a_series_of_prices([\n        29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 46])\n    assert_that(self.goog, is_buy_on(datetime(2014, 2, 13)))\n```", "```py\nimport subprocess\nfrom paver.easy import task, consume_args, options, needs\n\n@task\n@consume_args\ndef test():\n    args = []\n    if hasattr(options, \"args\"):\n        args = options.args\n    p = subprocess.Popen([\"python\", \"-m\", \"unittest\"] + args)\n    p.wait()\n    return p.returncode\n```", "```py\npaver test -t . -s stock_alerter\n\n```", "```py\nimport subprocess\nfrom paver.easy import task, consume_args, options, needs\n\n@task\n@consume_args\ndef test():\n    args = []\n    if hasattr(options, \"args\"):\n        args = options.args\n    p = subprocess.Popen([\"nose2\"] + args)\n    p.wait()\n    return p.returncode\n```", "```py\n@needs(\"test\")\ndef deploy():\n    # put the deployment commands here\n    pass\n```", "```py\nfrom setuptools import setup, find_packages\n\nsetup(\n    name=\"StockAlerter\",\n    version=\"0.1\",\n    packages=find_packages(),\n    test_suite=\"stock_alerter.tests\",\n)\n```", "```py\npython setup.py test\n\n```", "```py\nfrom setuptools import setup, find_packages\n\nsetup(\n    name=\"StockAlerter\",\n    version=\"0.1\",\n    packages=find_packages(),\n    tests_require=[\"nose2\"],\n    test_suite=\"nose2.collector.collector\",\n```", "```py\nimport subprocess\nfrom distutils.core import setup, Command\n\nclass TestCommand(Command):\n\n    user_options = []\n\n    def initialize_options(self):\n        pass\n\n    def finalize_options(self):\n        pass\n\n    def run(self):\n        p = subprocess.Popen([\"python\", \"-m\", \"unittest\"])\n        p.wait()\n        raise SystemExit(p.returncode)\n\nsetup(\n    name=\"StockAlerter\",\n    version=\"0.1\",\n    cmdclass={\n        \"test\": TestCommand\n    }\n)\n```", "```py\nscript:\n   - python -m unittest\n\nor if we are using nose2:\n\nscript:\n   - nose2\n```", "```py\n[tox]\nenvlist = py33,py34\n\n[testenv:py34]\ndeps = nose2\n       sure\n       pyhamcrest\ncommands = nose2\n\n[testenv:py33]\ndeps = enum34\n       sure\n       pyhamcrest\ncommands = python -m unittest\n```", "```py\ndef test_price_is_the_latest_even_if_updates_are_made_out_of_order(self):\n    self.goog.update(datetime(2014, 2, 13), price=8)\n    self.goog.update(datetime(2014, 2, 12), price=10)\n    self.assertEqual(8, self.goog.price)\n```", "```py\ndef update(self, timestamp, price):\n    if price < 0:\n        raise ValueError(\"price should not be negative\")\n    bisect.insort_left(self.price_history, (timestamp, price))\n```", "```py\n@property\ndef price(self):\n    return self.price_history[-1][1] \\\n        if self.price_history else None\n\ndef is_increasing_trend(self):\n    return self.price_history[-3][1] < \\\n        self.price_history[-2][1] < self.price_history[-1][1]\n```", "```py\nPriceEvent = collections.namedtuple(\"PriceEvent\", [\"timestamp\", \"price\"])\n\nclass Stock:\n    def __init__(self, symbol):\n        self.symbol = symbol\n        self.price_history = []\n\n    @property\n    def price(self):\n        return self.price_history[-1].price \\\n            if self.price_history else None\n\n    def update(self, timestamp, price):\n        if price < 0:\n            raise ValueError(\"price should not be negative\")\n        bisect.insort_left(self.price_history, PriceEvent(timestamp, price))\n\n    def is_increasing_trend(self):\n        return self.price_history[-3].price < \\\n            self.price_history[-2].price < \\\n                self.price_history[-1].price\n```", "```py\ndef get_crossover_signal(self, on_date):\n    NUM_DAYS = self.LONG_TERM_TIMESPAN + 1\n    closing_price_list = \\\n        self.history.get_closing_price_list(on_date, NUM_DAYS)\n\n    if len(closing_price_list) < NUM_DAYS:\n        return StockSignal.neutral\n\n    long_term_series = \\\n        closing_price_list[-self.LONG_TERM_TIMESPAN:]\n    prev_long_term_series = \\\n        closing_price_list[-self.LONG_TERM_TIMESPAN-1:-1]\n    short_term_series = \\\n        closing_price_list[-self.SHORT_TERM_TIMESPAN:]\n    prev_short_term_series = \\\n        closing_price_list[-self.SHORT_TERM_TIMESPAN-1:-1]\n\n    long_term_ma = sum([update.value\n                        for update in long_term_series])\\\n                    /self.LONG_TERM_TIMESPAN\n    prev_long_term_ma = sum([update.value\n                             for update in prev_long_term_series])\\\n                         /self.LONG_TERM_TIMESPAN\n    short_term_ma = sum([update.value\n                         for update in short_term_series])\\\n                    /self.SHORT_TERM_TIMESPAN\n    prev_short_term_ma = sum([update.value\n                              for update in prev_short_term_series])\\\n                         /self.SHORT_TERM_TIMESPAN\n\n    if self._is_crossover_below_to_above(prev_short_term_ma,\n                                         prev_long_term_ma,\n                                         short_term_ma,\n                                         long_term_ma):\n                return StockSignal.buy\n\n    if self._is_crossover_below_to_above(prev_long_term_ma,\n                                         prev_short_term_ma,\n                                         long_term_ma,\n                                         short_term_ma):\n                return StockSignal.sell\n\n    return StockSignal.neutral\n```", "```py\nclass MovingAverage:\n    pass\n```", "```py\ndef __init__(self, series, timespan):\n    self.series = series\n    self.timespan = timespan\n```", "```py\nclass MovingAverage:\n    def __init__(self, series, timespan):\n        self.series = series\n        self.timespan = timespan\n\n    def value_on(self, end_date):\n        moving_average_range = self.series.get_closing_price_list(\n                                   end_date, self.timespan)\n        if len(moving_average_range) < self.timespan:\n            raise NotEnoughDataException(\"Not enough data\")\n        price_list = [item.value for item in moving_average_range]\n        return sum(price_list)/len(price_list)\n```", "```py\nclass NotEnoughDataException(Exception):\n    pass\n```", "```py\ndef get_crossover_signal(self, on_date):\n    prev_date = on_date - timedelta(1)\n    long_term_ma = \\\n        MovingAverage(self.history, self.LONG_TERM_TIMESPAN)\n    short_term_ma = \\\n        MovingAverage(self.history, self.SHORT_TERM_TIMESPAN)\n\n    try:\n        long_term_ma_value = long_term_ma.value_on(on_date)\n        prev_long_term_ma_value = long_term_ma.value_on(prev_date)\n        short_term_ma_value = short_term_ma.value_on(on_date)\n        prev_short_term_ma_value = short_term_ma.value_on(prev_date)\n    except NotEnoughDataException:\n        return StockSignal.neutral\n\n    if self._is_crossover_below_to_above(prev_short_term_ma_value,\n                                         prev_long_term_ma_value,\n                                         short_term_ma_value,\n                                         long_term_ma_value):\n                return StockSignal.buy\n\n    if self._is_crossover_below_to_above(prev_long_term_ma_value,\n                                         prev_short_term_ma_value,\n                                         long_term_ma_value,\n                                         short_term_ma_value):\n                return StockSignal.sell\n\n    return StockSignal.neutral\n```", "```py\ndef get_crossover_signal(self, on_date):\n    prev_date = on_date - timedelta(1)\n    long_term_ma = \\\n        MovingAverage(self.history, self.LONG_TERM_TIMESPAN)\n    short_term_ma = \\\n        MovingAverage(self.history, self.SHORT_TERM_TIMESPAN)\n\n    try:\n        if self._is_crossover_below_to_above(\n                short_term_ma.value_on(prev_date),\n                long_term_ma.value_on(prev_date),\n                short_term_ma.value_on(on_date),\n                long_term_ma.value_on(on_date)):\n            return StockSignal.buy\n\n        if self._is_crossover_below_to_above(\n                long_term_ma.value_on(prev_date),\n                short_term_ma.value_on(prev_date),\n                long_term_ma.value_on(on_date),\n                short_term_ma.value_on(on_date)):\n            return StockSignal.sell\n    except NotEnoughDataException:\n        return StockSignal.neutral\n\n    return StockSignal.neutral\n```", "```py\ndef _is_crossover_below_to_above(self, on_date, ma, reference_ma):\n    prev_date = on_date - timedelta(1)\n    return (ma.value_on(prev_date)\n                < reference_ma.value_on(prev_date)\n            and ma.value_on(on_date)\n                > reference_ma.value_on(on_date))\n```", "```py\ndef get_crossover_signal(self, on_date):\n    long_term_ma = \\\n        MovingAverage(self.history, self.LONG_TERM_TIMESPAN)\n    short_term_ma = \\\n        MovingAverage(self.history, self.SHORT_TERM_TIMESPAN)\n\n    try:\n        if self._is_crossover_below_to_above(\n                on_date,\n                short_term_ma,\n                long_term_ma):\n            return StockSignal.buy\n\n        if self._is_crossover_below_to_above(\n                on_date,\n                long_term_ma,\n                short_term_ma):\n            return StockSignal.sell\n    except NotEnoughDataException:\n        return StockSignal.neutral\n\n    return StockSignal.neutral\n```", "```py\npip install unittest2\n\n```", "```py\nimport unittest2\n\nclass StockTest(unittest2.TestCase):\n    ...\n```", "```py\npip install mock\n\n```", "```py\nimport mock\n```", "```py\ntry:\n   import unittest2 as unittest\nexcept ImportError:\n   import unittest\n```", "```py\ntry:\n   from unittest import mock\nexcept ImportError:\n   import mock\n```", "```py\npython.exe -m unittest\n\n```", "```py\npython3 -m unittest discover -s stock_alerter -t .\n\n```", "```py\nunit2 discover -s stock_alerter -t .\n\n```"]