- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exploring Object Transformations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ability to change an object’s location, rotation, and dimension in a space
    is a tenet of any animation software.
  prefs: []
  type: TYPE_NORMAL
- en: Artists are used to changing the values of transform channels to carry out these
    operations. More technical users are aware of the geometric implications of such
    actions.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn how Object Transformations work and how to implement
    them in our script. We will also learn how to add object constraints programmatically
    and how Blender can carry out the more difficult operations for us.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will implement a new command that affects the transformation of
    more objects at once and accepts user input.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following key topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Transforming objects, using coordinate notations, and avoiding pitfalls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying object constraints and hierarchies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using matrix representation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding interactive operators to our add-ons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will use Blender and **Visual Studio Code** (**VS Code**).
  prefs: []
  type: TYPE_NORMAL
- en: 'The examples created in this chapter can be found at the following URL: [https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch4](https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch4).'
  prefs: []
  type: TYPE_NORMAL
- en: Moving objects in space
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Three-dimensional objects can be moved, rotated, and scaled. Since they do not
    change the geometry of an object, location and rotation are considered **rigid
    transformations**. Technically, changing the size of an object using its scale
    value applies a non-rigid transformation, but since the vertex geometry doesn’t
    change, scale is considered an object-level transformation and is displayed alongside
    location and rotation.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will use Python to transform objects in Blender.
  prefs: []
  type: TYPE_NORMAL
- en: Transforming objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An object is transformed by changing the values of its Location, Rotation, and
    Scale channels. Location and scale coordinates are immediately associated with
    the X, Y, and Z of the Cartesian space; rotations have more options as they come
    with some implications.
  prefs: []
  type: TYPE_NORMAL
- en: Affecting an object’s location
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We have already met the `location` attribute in [*Chapter 1*](B18375_01.xhtml#_idTextAnchor014)
    and [*Chapter 2*](B18375_02.xhtml#_idTextAnchor033). If we have an active object,
    such as the cube from Blender’s default scene, the following lines will move it
    to the location with *x*, *y*, *z* coordinates `1.0`, `2.0`, and `3.0`. These
    lines use **tuple assignment** to set all three coordinates at once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Since Blender coordinates can also be assigned through letters, that expression
    is equivalent to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Coordinates are stored inside **Vectors**. Vector components can be accessed
    separately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, they can be accessed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Location and Scale are both stored as Vectors.
  prefs: []
  type: TYPE_NORMAL
- en: Affecting object scale
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Like with location, the three dimensions of scale are accessed through the
    `Vector` coordinates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can assign a non-uniform scale to an object, such as a different value for
    each axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The scale of an object is more often uniform, meaning it is the same on each
    axis. Blender Vectors provide a convenient way for assigning uniform values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Like with `location`, `scale` coordinates can be set individually or together.
    The rest values are different, by the way: the scale at rest is `[1.0, 1.0, 1.0]`
    rather than `[0.0, 0.0, 0.0]`. That reflects how scaling is a multiplicative operation
    while location is additive.'
  prefs: []
  type: TYPE_NORMAL
- en: Rotations are less immediate to combine. We will see that there are different
    ways to represent rotations in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: Affecting object rotations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using rotations, we can orient an object around the *x*, *y*, and *z* axes.
    Doing that will give objects an orientation of their own, with their own *x*,
    *y*, and *z* local axes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We refer to these new axes, aligned with the object, as **Local Orientation**.
    Blender lets the user choose between different axes for transforming objects.
    The axes aligned with the viewport grid are the **Global Orientation** or **World
    Axes**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1: Rotation rings and axes of an object at rest and after a rotation](img/Figure_4.01_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.1: Rotation rings and axes of an object at rest and after a rotation'
  prefs: []
  type: TYPE_NORMAL
- en: 'Even if an object was rotated, we can still change **Rotation Mode** in the
    viewport top bar and use *Global Orientation*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2: A rotated airplane still using Global Orientation](img/Figure_4.02_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.2: A rotated airplane still using Global Orientation'
  prefs: []
  type: TYPE_NORMAL
- en: 'Rotations are more complex than translation and scale: by definition, a rotation
    involves a pivot and a constant distance. For that reason, rotations are affected
    by some minor issues that require extra consideration.'
  prefs: []
  type: TYPE_NORMAL
- en: Issues related to rotations
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Because of their composite nature, rotations around one axis can change the
    rotation value on another. To sum that up, rotation is described as a three-dimensional
    property with only two **degrees of freedom**, as no more than two channels have
    the chance to change freely.
  prefs: []
  type: TYPE_NORMAL
- en: Also, the order in which rotations are stacked together changes the result.
    To visualize a rotated object correctly, we need to know which axes were rotated
    first, that is, the **rotation order**.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could just stick with one rotation order, say *x*, then *y*, and then *z*,
    but that would limit our options against another potential shortcoming: three-dimensional
    rotations that overlap one axis with another end up making one coordinate useless,
    a well-known problem known as **gimbal lock**.'
  prefs: []
  type: TYPE_NORMAL
- en: Since different rotation orders lock at different angles, changing the order
    helps cope with the issue.
  prefs: []
  type: TYPE_NORMAL
- en: These problems aren't specific to Blender or any other animation software; they
    are inherent properties of three-dimensional spaces, up to and including the one
    that we inhabit.
  prefs: []
  type: TYPE_NORMAL
- en: To work around them, rotations provide a wider range of options. In addition
    to different orders for combining the three angles, there are also abstract representations
    such as quaternions. This terminology might sound scary at first, but it will
    become more familiar as we proceed with the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Changing rotation mode
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The **Rotation Mode** box in **Transform Properties** displays the available
    options for rotating objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3: Rotation modes](img/Figure_4.03_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.3: Rotation modes'
  prefs: []
  type: TYPE_NORMAL
- en: 'We do not need to cover this topic in full here, but essentially the following
    provides a brief introduction:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Quaternions**: These are mathematic notations that use four coefficients:
    in Blender, **W**, **X**, **Y**, and **Z**. Quaternions do not suffer from gimbal
    lock.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Euler angles**: These list the angles on three rotation axes. It’s the common
    acceptance of rotation and comes with two caveats: the result depends on the axis
    order, and one axis might end up overlapping another. To mitigate the perils of
    losing a channel to gimbal lock, more combinations of **X**, **Y**, and **Z**
    are allowed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Axis Angle**: This uses **X**, **Y,** and **Z** to define a point as the
    rotation axis. The **W** attribute is the twisting angle in said direction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 4.4: Rotation attributes for the Quaternion, Euler, and Axis Angle
    modes](img/Figure_4.04_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.4: Rotation attributes for the Quaternion, Euler, and Axis Angle modes'
  prefs: []
  type: TYPE_NORMAL
- en: Changing this property in the interface changes the displayed channels. In Python,
    we need to use different attributes depending on the current mode.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing rotations in Python
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `rotation_mode` attribute specifies which system is being used to rotate
    an object. It is an `TypeError`. The error message prints out the allowed keywords:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Each mode provides its attributes for setting rotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`QUATERNION`: To affect the quaternion coefficients *W*, *X*, *Y*, and *Z,*
    we use the following, respectively:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rotation_quaternion.w` or `rotation_quaternion[0]`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rotation_quaternion.x` or `rotation_quaternion[1]`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rotation_quaternion.y` or `rotation_quaternion[2]`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rotation_quaternion.z` or `rotation_quaternion[3]`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`XYZ`, `XZY`, `YXZ`, `YZX`, `ZXY`, and `ZYX` are Euler angles evaluated in
    different orders. No matter which one we choose, the Euler attributes for these
    are the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rotation_euler.x` or `rotation_euler[0]`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rotation_euler.y` or `rotation_euler[1]`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rotation_euler.z` or `rotation_euler[2]`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We should set these values in radians.
  prefs: []
  type: TYPE_NORMAL
- en: '`AXIS_ANGLE`: *Axis Angle – Axis Angle (W+XYZ)*, defines a rotation around
    some axis defined by 3D-Vector. We can set the torsion angle in radians via the
    following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rotation_axis_angle[0]`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can set the axis vector x, y, z coordinates using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`rotation_axis_angle[1]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rotation_axis_angle[2]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rotation_axis_angle[3]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `math` module provides some help in using radians as angular units.
  prefs: []
  type: TYPE_NORMAL
- en: Using radians and degrees
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Blender’s API describes angles of rotation using radians rather than degrees.
    Degrees express an angle using values between 0 and 360, while radians range between
    0 and 2π. The Greek letter π (pi) refers to the ratio between a circle and its
    diameter. 2π (approximately 6.28) measures the arc of a full circle of radius
    1.0.
  prefs: []
  type: TYPE_NORMAL
- en: In Python, we can use the `math` module’s functions to convert between the two
    systems, `radians()` and `degrees()`, and the `pi` variable for quick access to
    the value of π.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: With that in mind, when we set rotations, we can convert angular units on the
    fly.
  prefs: []
  type: TYPE_NORMAL
- en: Setting rotation attributes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we set a rotation in a script, we must ensure that we use the right
    rotation system. In the following snippet, we set the rotation mode beforehand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: When we change `rotation_mode`, Blender converts the current state to the selected
    system. That prevents an object from suddenly changing its orientation in space
    and works for most cases, but there are a few exceptions. For instance, animations
    have values set for each keyframe, so switching the rotation type of animated
    controls ends up changing the visual rotation during playback. In that case, we
    can use conversion methods in our scripts, as we will see in the next Python snippet.
  prefs: []
  type: TYPE_NORMAL
- en: Converting between rotation systems
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In the following snippet, we start with a `Euler` rotation and use conversion
    methods to change the rotation mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: At the time of writing, the Euler representation doesn’t have a `to_axis_angle()`
    method, so we convert to quaternion first. Using quaternions as a crossroad is
    common, as they are the most generic system for expressing rotations.
  prefs: []
  type: TYPE_NORMAL
- en: Rotations can also be written down as a **matrix**. The matrix form is how all
    the transforms are stored internally. We will get to that after we have learned
    more about indirect transforms, that is, moving an object without changing its
    channels.
  prefs: []
  type: TYPE_NORMAL
- en: Transforming objects indirectly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen how to transform an object by altering its channels directly. There
    are two other ways to influence an object’s position, rotation, and scale. **Object
    Constraints** are special utilities that affect the transformation either by limiting
    certain values or by copying them from another object.
  prefs: []
  type: TYPE_NORMAL
- en: Then there is the possibility to arrange more objects in a hierarchy via **Parenting**,
    that is, by making one object belong to another.
  prefs: []
  type: TYPE_NORMAL
- en: We will see how these operations are reflected in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Using Object Constraints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Constraints can move, rotate, or scale an object without changing its transform
    properties. Some of them, such as **Copy Transforms**, override the object transform
    completely; others, such as **Limit Distance**, operate on top of them.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5: Blender constraints menu](img/Figure_4.05_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.5: Blender constraints menu'
  prefs: []
  type: TYPE_NORMAL
- en: Most constraints bind the transforms of more objects together, such as **Copy
    Location**, while others, such as **Limit Location**, have their own transform
    attributes.
  prefs: []
  type: TYPE_NORMAL
- en: An object can have an unspecified number of constraints. The steps to add them
    in Python are very similar to how they work in the graphic interface.
  prefs: []
  type: TYPE_NORMAL
- en: Adding constraints in Python
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Constraints are exposed as a collection property of an object. They can be added
    by providing a constraint type to the `new(type)` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Much like with rotation mode, providing a wrong keyword will prompt an error
    and list the available options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `new` method returns the created constraint, so we can easily access its
    properties.
  prefs: []
  type: TYPE_NORMAL
- en: Setting constraint attributes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Different types of constraints have different attributes, but some common patterns
    exist. Most constraints will contain these properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Boolean** switches:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.enabled`: This enables/disables a constraint'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.use_x`, `.use_y`, `.use_z`: Use when available to enable/disable only one
    axis'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.use_offset`: Use when available to sum the constraint effect to the transform
    channels'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Object: Use `.target`, if available, to set the bind target of the constraint'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'String: Use `.subtarget`, if available, to use only part of the target (e.g.,
    a vertex group) for the actual computation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Enum switches:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.target_space`: This makes the constraint act at the `.owner_space`: This
    changes the constraint source data to the **Local**, **World,** or **Custom**
    **Object** level'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Float number: Use `.influence` to convey only a fraction of the effect'
  prefs: []
  type: TYPE_NORMAL
- en: Some properties are specific to each type, such as the `distance` attribute
    of the **Distance Constraint**. In that case, their path can be traced by hovering
    over or right-clicking in the graphic interface (see the *Copying the data path
    section in* [*Chapter 2*](B18375_02.xhtml#_idTextAnchor033)) or from the API documentation
    (see the *Accessing Blender data* section in [*Chapter 2*](B18375_02.xhtml#_idTextAnchor033)).
  prefs: []
  type: TYPE_NORMAL
- en: Limiting an object scale
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following snippet adds a **Limit Scale** constraint that limits the maximum
    height of the active object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If applied to the default cube, it will halve its height as if a scale of `[1.0,
    1.0, 0.5]` had been applied, despite its scale values still being `[1.0,` `1.0,
    1.0]`.
  prefs: []
  type: TYPE_NORMAL
- en: Objects can be part of a hierarchy. In that case, they follow the objects that
    are higher in their hierarchical tree. We will explore this concept next.
  prefs: []
  type: TYPE_NORMAL
- en: Using object hierarchies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Objects in the viewport can be arranged as **children** of other objects. In
    that case, they will be affected by the translation, rotation, and scale of their
    **parent**.
  prefs: []
  type: TYPE_NORMAL
- en: We can access hierarchical relationships in Python via the `parent`, `children`,
    and `children_recursive` attributes. Only the parent attribute is writable; the
    other two are only for listing.
  prefs: []
  type: TYPE_NORMAL
- en: The difference between `children` and `children_recursive` is that the latter
    lists every affected object down the hierarchy, including children of children
    and all the *descendants*.
  prefs: []
  type: TYPE_NORMAL
- en: 'This snippet parents all the existing objects one under the other, then it
    prints a report:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Running that code in the default scene brings the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6: Default objects reparented in one hierarchy](img/Figure_4.06_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.6: Default objects reparented in one hierarchy'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is reflected in the printout: the first object lists all the others as
    *grandchildren*, while `children_recursive` and `children` contain the same results
    for the last two, which have no other descendants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If we look at the viewport, we can see that the object positions have changed:
    parenting an object in Python applies a new reference system instantly. To replicate
    that behavior, we need to understand the transformation matrix.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the transform matrix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Three-dimensional transforms of Location, Rotation, and Scale are stored together
    inside a **matrix**. Matrices are, at large, tables of numbers arranged in rows
    and columns. Transformation matrices are combined using **linear algebra**. We
    will not go into the details here; we will just have a quick look at what a matrix
    means and how we can use it in our scripts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like with other representations, Blender provides a `Matrix` class in the `mathutils`
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: A matrix containing these default values, `1.0` in its *diagonal* entries and
    `0.0` everywhere else, represents the *rest* state. In other words, an object
    associated with this matrix was not moved, rotated, or scaled. It is known as
    an **identity matrix**, as it leaves an object in its *identical* state.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever an object is moved, rotated, or scaled, the entries of its matrix change
    to different values.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing matrices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Objects contain more than one matrix. Trying to reach an object matrix via
    autocompletion shows four different attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Each of them covers a specific aspect:'
  prefs: []
  type: TYPE_NORMAL
- en: '`matrix_basis`: This contains the local location, rotation, and scale of an
    object before it is transformed by object constraints. This matrix reflects the
    channels displayed in the object properties.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`matrix_local`: This contains the local location, rotation, and scale of an
    object, omitting the transformation inherited by the parent object but not the
    one resulting from constraints.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`matrix_parent_inverse`: Whenever we don’t want an object at rest to match
    its parent exactly, we add an offset inside this matrix.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`matrix_world`: This contains the final location, rotation, and scale in world
    coordinates, reflecting all the transformations to which an object is subject.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With that in mind, we can improve the *parent snippet* from the previous section
    and keep the object positions intact.
  prefs: []
  type: TYPE_NORMAL
- en: Storing object matrices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Assigning a parent relationship via Python previously has snapped every object
    to its parent positions.
  prefs: []
  type: TYPE_NORMAL
- en: We want them to maintain their visual transformation after the change in hierarchy.
    In matrix terms, we are saying that we want to keep their world matrix unchanged.
    To do that, we will learn how to store a matrix properly.
  prefs: []
  type: TYPE_NORMAL
- en: Copying matrices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python variables containing single values store their own data. Variables with
    aggregate values such as lists, dictionaries, and Blender `mathutils` types point
    to shared references of their values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the following example. The `b` variable has the same value as
    `a`. After `a` is changed to `5`, `b` is still `4`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The same doesn’t apply to lists, even if they consist of one single element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Despite being a different variable, the `b` list points to the same data as
    the `a` list. To free it from getting updates from the original, we must state
    explicitly that it is a copy.
  prefs: []
  type: TYPE_NORMAL
- en: Expert Python users know very well how to avert that using Python’s `copy` module.
    Blender aggregate types provide a `.copy()` method for convenience.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following snippet, changes to `matrix_a` will also change `matrix_b`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The following creates a `matrix_a`, that is, all its values are copied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We can now keep the object’s world transformations and restore them after the
    hierarchy has changed.
  prefs: []
  type: TYPE_NORMAL
- en: Restoring transformations using the world matrix
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since `matrix_world` is writeable, it can be stored and reapplied after setting
    the parent.
  prefs: []
  type: TYPE_NORMAL
- en: 'To restore the matrix *as it was*, we need to store a copy of its value, like
    in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the objects maintain their position. If we look at the transform
    channels, we will find that they have changed.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the world matrix affects the location/rotation/scale values. In their
    rest position, the objects still go back to their parent center.
  prefs: []
  type: TYPE_NORMAL
- en: If that is not what we want to achieve, we can use the `matrix_parent_inverse`
    attribute to offset the rest position.
  prefs: []
  type: TYPE_NORMAL
- en: Creating rest offsets with the parent inverse matrix
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `parent_matrix_inverse` attribute contains a transform that is hidden from
    the interface. It is used for setting a rest position away from the parent’s origin.
  prefs: []
  type: TYPE_NORMAL
- en: The idea is to counter the inherited transform, adding its inverse to the transform.
    For instance, the inverse of moving an object to the `[5.0, 5.0, 5.0]` coordinates
    is moving it to `[-5.0, -``5.0, -5.0]`.
  prefs: []
  type: TYPE_NORMAL
- en: Inverting a rotation is a little bit more complicated, but in Blender, we can
    find the inverse of any transform using the `.inverted()` method of its matrix.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how the following snippet parents the objects in `bpy.data`, while
    keeping their transform and visual coordinates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The matrix system can be scary, as many people don’t usually think of transformations
    in this form. But even this basic understanding of it provides a very powerful
    tool in our scripting bench.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we put the skills learned throughout the chapter to use
    in a single add-on. This add-on changes the positions of many objects as one and
    can optionally work through constraints.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the Elevator add-on
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know how to transform objects in Python, we can write a new add-on
    that contains a transformation operator.
  prefs: []
  type: TYPE_NORMAL
- en: This add-on allows us to move all selected objects above a certain height. It
    can be useful whenever we want to set a minimum height, that is, a *floor*, for
    our scene. As we did in [*Chapter 3*](B18375_03.xhtml#_idTextAnchor049), we start
    with a basic implementation, and we will then proceed to refine it. As usual,
    we start our work by setting a folder for the code of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we did at the beginning of [*Chapter 3*](B18375_03.xhtml#_idTextAnchor049),
    we create a folder for [*Chapter 4*](B18375_04.xhtml#_idTextAnchor075) in our
    `ch4` folder as the **Scripts** folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7: System folder for Chapter 4](img/Figure_4.07_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.7: System folder for [Chapter 4](B18375_04.xhtml#_idTextAnchor075)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it’s time to add a new file to our project:'
  prefs: []
  type: TYPE_NORMAL
- en: Select `PythonScriptingBlender/ch4/addons` in VS Code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new file by clicking the **New** **File** icon.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new file `object_elevator.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the file by double-clicking it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can now start writing our add-on.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the first draft
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we have seen in the *Add-on requirements* section in [*Chapter 3*](B18375_03.xhtml#_idTextAnchor049),
    our add-on needs the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The add-on *information* `bl_info` dictionary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An *operator* that performs the desired action
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `register`/`unregister` function for `enable`/`disable` operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s begin writing the first draft by filling in the requirements; we can
    refine the add-on in the second step:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We write down the add-on information in the `bl_info` header. That also helps
    clarify the purpose and functionality of the tool:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: object_elevator.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s nail down the main functionality: the add-on contains an operator
    that moves all the objects up to a given height. We store this height in the static
    variable floor, which, for now, is hardcoded and set to `5.0`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since it affects the selected objects, the condition to check in the `poll()`
    method is that the selection is not empty:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here’s the bulk of the code: the `execute` function checks for each object
    that its `Z` location is not less than `self.floor` (at the moment, `self.floor`
    equals `5.0`). When all the objects have been processed, it returns a `''``FINISHED''`
    status:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can add our operator to the object right-click menu; to do that, we
    need a `drawmenu` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'All the elements of our add-on are ready; all that is left is to add them to
    the registration functions. This is how we do it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our add-on is ready for its test drive. We can find it in the **Add-ons** preferences:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8: Object: Elevator enabled in the Add-ons preferences](img/Figure_4.08_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.8: Object: Elevator enabled in the Add-ons preferences'
  prefs: []
  type: TYPE_NORMAL
- en: 'When the add-on is enabled, a new entry is added to the object’s *right-click*
    menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.9: Right-clicking in the viewport shows our new menu entry](img/Figure_4.09_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.9: Right-clicking in the viewport shows our new menu entry'
  prefs: []
  type: TYPE_NORMAL
- en: If we select some objects and open the context menu via right-clicking them,
    we will find `location.z` to `5.0` unless it already has a higher value.
  prefs: []
  type: TYPE_NORMAL
- en: Setting a minimum height for a scene can be useful when it contains a ground
    level, and we want to ensure that no object ends up below it. The static value
    of `OBJECT_OT_elevator.floor` doesn’t help here, though, as it only applies to
    the case when the ground level equals `5.0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily that was only for testing: the final version of the script makes use
    of an input parameter instead.'
  prefs: []
  type: TYPE_NORMAL
- en: Using input properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Replacing the static `floor` member in our operator with an editable value requires
    Blender to channel the user input to our Python script.
  prefs: []
  type: TYPE_NORMAL
- en: For that purpose, Blender’s API provides special properties that show up as
    graphic elements in the interface and can be used as variables in Python scripts.
    These properties are part of the `bpy.props` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make `floor` an editable property of our operator:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As `OBJECT_OT_elevator.floor` is a float number, so we need to use `FloatProperty`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Since we are forcing a specific type, we will use a Python `floor = 5.0` to
    `floor:FloatProperty(name="Floor", default=0)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take note
  prefs: []
  type: TYPE_NORMAL
- en: 'Using an annotation in lieu of variables of a determined type is a best practice
    in Python, but it is required in Blender: the input property will not appear otherwise.'
  prefs: []
  type: TYPE_NORMAL
- en: Then we must keep in mind that, because of how Blender works, operators that
    accept input values must be aware of the undo system. So, we add the `bl_options
    = {'REGISTER', '``UNDO'}` property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here’s how the header of our operator looks now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Refreshing the operators by pressing *F3* + **Reload Scripts** and executing
    **Elevate Objects** again displays the input properties inside an expansion popup
    at the bottom left of the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.10: Our editable Floor property](img/Figure_4.10_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.10: Our editable Floor property'
  prefs: []
  type: TYPE_NORMAL
- en: Changing this property affects the minimum height of all selected objects.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have operated on the `location.z` attribute. This might not work
    if our object has a parent with a different orientation or scale. We can overcome
    that using the object world matrix instead.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the height in the world matrix
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Blender stores the object translation in the matrix’s last column, as seen
    in *Figure 4**.11*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.11: The entries of a transform matrix](img/Figure_4.11_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.11: The entries of a transform matrix'
  prefs: []
  type: TYPE_NORMAL
- en: The indices of `Matrix` point to its rows; so, to access location z, we need
    to get the third row and look for its fourth element. Since the enumeration starts
    with `0`, the indices we are looking for are, respectively, `[2]` and `[3]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `execute` function now uses `matrix_world[2][3]` instead of `location.z`.
    Since matrix values are not automatically updated during script execution, we’ll
    need to invoke `context.view_layer.update()` after the value is set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: This version of the script can handle the objects that inherit a parent transform,
    but what if the parent is also selected?
  prefs: []
  type: TYPE_NORMAL
- en: Moving a parent after a child has already been handled will change the positions
    of both, thus bringing the child to a wrong height.
  prefs: []
  type: TYPE_NORMAL
- en: We need to make sure that parent objects are always moved first.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding duplicate transformations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to reorder our list of objects, but with `context.selected_objects`
    being read-only, we cannot reorder it directly; we need to copy its content to
    a list.
  prefs: []
  type: TYPE_NORMAL
- en: Copying selected_objects to an editable list
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can use the `copy` module to create a **shallow copy** of that list. It
    will reference the same data but allow us to sort them at will:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the `execute` method, locate the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace it with this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Now we can order this list in a way that won’t cause the same object to be moved
    twice.
  prefs: []
  type: TYPE_NORMAL
- en: Ordering by hierarchy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To sort a list, we need a function that returns each element’s position in a
    new order.
  prefs: []
  type: TYPE_NORMAL
- en: We want to handle child objects only after their parents are already processed.
    Reordering the list so that objects with more ancestors are processed later will
    meet this condition.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need a function that returns the number of ancestors: starting with an object,
    it checks whether it has a parent, and then whether that parent has a parent,
    until none is found. The `ancestors_count` function achieves that using a `while`
    loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'We add this function to our script and use it as the `key` argument of the
    `sort` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Our add-on is now able to raise all the selected objects to a minimum height
    and avoids summing the transforms in hierarchies.
  prefs: []
  type: TYPE_NORMAL
- en: We could consider it finished, but since we know how to add constraints, we
    can use them for the same purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the constraints switch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can allow the user to use constraints and leave the transform channels unaffected.
    This is how we can do it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we want to display a checkbox for using constraints, we need to add a
    Boolean property to our operator. We need to import `BoolProperty` as we did with
    `FloatProperty` earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then we add a `BoolProperty` annotation to our operator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will use constraints when the `constr` property is set to `True`. We set
    it to `False` by default so that a new option doesn’t change the add-on’s behavior.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Using constraints makes our job easier; we don’t need to sort the objects and
    set their matrices. Our `execute` function now starts like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If we use constraints, we can just exit the function, returning a `{'FINISHED'}`
    set as soon as we are done setting them. If we don’t, the `execute` function keeps
    going with the previous code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The visual result is equivalent, but turning **Constraints** on doesn’t affect
    the transform channels. There is one last caveat: if the operator is run multiple
    times on the same objects, a new constraint is added.'
  prefs: []
  type: TYPE_NORMAL
- en: We will make **Elevate Objects** reuse an existing constraint when it is found.
    That avoids creating too many constraints for the same purpose. It also prevents
    the effects of previous constraints from interfering. When an object has more
    than one limit to its location, only the more restrictive one is effective.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding duplicate constraints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If **Limit Location** is found on an object, our operator uses it. We make
    this behavior optional in case the user wants to create new constraints anyway:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To do that, we add another Boolean property to our operator first:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then, inside our loop, we check for an existing constraint that we can use.
    If it is not found, our script creates it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This behavior can be implemented in a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'That has made our `execute` method much cleaner:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we reload the scripts and run the operator, we will see all its properties
    in the execution panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.12: All the Elevate Objects options](img/Figure_4.12_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.12: All the Elevate Objects options'
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, the **Reuse** property should be displayed only when **Constraints**
    is enabled, as it has no effect otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: This is possible if we take care of drawing the user interface of our tools,
    which will be introduced in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: For now, we have added a good deal of flexibility to a script that started as
    a very simple tool. This brings us to the end of the chapter, as we have covered
    most of the topics about writing custom tools.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to use `Vector`, `Quaternion`, and `Matrix`
    entities to our advantage, not to mention the different *rotation modes*. That
    gives us the elements for understanding and mastering the transformations in space
    and moving the objects in the scene.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned how to create constraints in Python, which is very important
    in all set-up scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we learned how our operators can get user input and display their parameters
    inside the Blender user interface during their execution.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 5*](B18375_05.xhtml#_idTextAnchor100), we will learn how to code
    our own panels for the graphic interface and make its options aware of the context.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is a rigid transformation?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can we convert coordinates between different rotation systems?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can we convert coordinates between different rotation orders?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why are quaternions useful for conversion?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In which form are transformations stored internally?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Are objects associated with only one transformation matrix?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
