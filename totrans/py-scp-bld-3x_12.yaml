- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rendering and Shaders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A process called *rendering* generates the pixels of finished images by evaluating
    the geometries, lights, and camera of the scene.
  prefs: []
  type: TYPE_NORMAL
- en: 'The renderers, or Render Engines, that handle those computations can be external
    programs, independent from the 3D application, or fully integrated features of
    the animation package. All renderers have strong and weak points and can be grouped
    into two categories: real time, which assume a few approximations to achieve immediate
    visualization, and offline, which take more time to take more details into account.'
  prefs: []
  type: TYPE_NORMAL
- en: To generate images, renderers rely on shaders – that is, instructions on how
    an object reacts to the light and position of the observer, and how that translates
    into the rendered pixels.
  prefs: []
  type: TYPE_NORMAL
- en: Shaders can be complex and are a discipline of their own, but the basic concept
    of how they work is not hard to grasp.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn where to set the render properties, how to automate
    the creation of shaders using Python, and how to use the **File Browser** for
    loading images.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the materials system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading images in the Shader Editor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting and arranging shader nodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will use Blender and Visual Studio Code in this chapter. The examples created
    for this chapter, along with the media files, can be found at [https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch12](https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch12).
  prefs: []
  type: TYPE_NORMAL
- en: Render and materials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Blender comes with two render engines: **Eevee**, the real-time renderer that
    can be used in the Viewport, and **Cycles**, an offline renderer. Additional engines,
    including most of the commercial offerings, can be installed in the form of render
    add-ons. A third option, **Workbench**, can be used for quickly and simply displaying
    renders in the Viewport.'
  prefs: []
  type: TYPE_NORMAL
- en: Setting the Render Engine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The current **Render Engine**, along with other render settings, can be found
    in the scene **Render** properties. It’s the first tab and is marked with an icon
    of a TV set:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1: Selecting the current Render Engine](img/Figure_12.01_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.1: Selecting the current Render Engine'
  prefs: []
  type: TYPE_NORMAL
- en: While **Workbench** is designed to have only a few render options and no shading
    system, **Eevee** and **Cycles** can combine images, colors, and attributes using
    a node-based system. This can be done in the **Shader Editor** area, available
    in the **Shading** workspace.
  prefs: []
  type: TYPE_NORMAL
- en: The Shading workspace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Shading involves disparate activities, such as accessing image files, checking
    the Viewport, and editing object properties. Once we set our **Render Engine**
    to Eeeve, Cycles, or an external engine that supports Blender’s shading system,
    we can carry out those tasks in the **Shading** workspace. It contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A **File Browser** for importing images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **3D Viewport** area for checking the materials
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An **Outliner**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data **Properties**; by default, the **World** settings tab is active
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Shaders** **Editor** area
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **Image** **Editor** area:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 12.2: The Shading workspace](img/Figure_12.02_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.2: The Shading workspace'
  prefs: []
  type: TYPE_NORMAL
- en: The default material presents a few color attributes that can be set in the
    **Material Properties** area. To understand how to script articulated materials
    with a proper layout, we will provide a brief overview of how the shader components
    come together in the shader graph.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding object materials
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can change the overall look of an object by specifying its material. The
    term *material* follows the analogy of real-world objects, whose look is affected
    by the material of which they are made or coated.
  prefs: []
  type: TYPE_NORMAL
- en: Object materials can be edited in the **Material Properties** area. In version
    3.3, it’s the second-to-last property tab, marked with an icon of a sphere with
    a checkerboard pattern, as shown in *Figure 12**.3*.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Material Properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Materials exist independently from objects. One material can be shared among
    multiple objects and an object can have more materials assigned to different sets
    of faces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scrolling down to the material **Settings**, we can edit how the material is
    processed by Blender – for instance, how its transparent parts are rendered over
    the background:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.3: Settings in the Material Properties area](img/Figure_12.03_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.3: Settings in the Material Properties area'
  prefs: []
  type: TYPE_NORMAL
- en: The properties commonly associated with actual materials, such as roughness,
    color, and transparency, are displayed in the **Surface** panel. Those properties
    are part of the **shader**, a generic algorithm used for computing how a surface
    should look. Every material has a shader associated with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Shaders introduce a new concept to this book: a visual framework known as the
    **nodes tree**. We can learn how it works by looking at the **Shader** **Editor**
    area.'
  prefs: []
  type: TYPE_NORMAL
- en: The Shader Editor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The shading system supports different styles: realistic, cartoon, or technical
    drawings, to mention a few. Rather than providing a single interface with defined
    widgets, the functionalities of a renderer are scattered through interconnecting
    units called **nodes**.'
  prefs: []
  type: TYPE_NORMAL
- en: Much like a function, a node performs a specific operation on one or more inputs
    and makes the results available through one or more outputs. Nodes are visual
    representations of functions, allowing non-programmers to combine logic blocks
    to get custom results.
  prefs: []
  type: TYPE_NORMAL
- en: Nodes are not unique to shading – they are used for **Compositing** and for
    generating meshes in the **Geometry** **Nodes** modifier.
  prefs: []
  type: TYPE_NORMAL
- en: By default, a Blender material presents a **Material Output** node in the **Shader
    Editor** area, with a **Principled BSDF** node as its **Surface** input. **Bidirectional
    Scattering Distribution Function** (**BSFD**) is a mathematical model of how a
    surface receives and reflects light rays. It is a form of **Physically-Based Rendering**
    (**PBR**), an approach based on how visual properties such as color, roughness,
    and permeability interact with light in the real world.
  prefs: []
  type: TYPE_NORMAL
- en: '**Material Output** is the last node of the graph and transfers the shading
    to an object.'
  prefs: []
  type: TYPE_NORMAL
- en: Only one output can be active at any time, so the shader graph is also called
    the **Node Tree**, with the output as the root from which all the other branches
    stem.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Node Tree
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The inputs and outputs of a node are displayed as colored circles called **sockets**.
    Input sockets are on the left-hand side of the node, while output sockets are
    on the right. Their color depends on the data type of the socket. For instance,
    the **Base Color** socket of a **Principled** node, which is yellow, assigns a
    color to a material, while **Roughness**, a gray socket, is a float number to
    denote how far from smooth it is.
  prefs: []
  type: TYPE_NORMAL
- en: Purple sockets, such as **Normal**, are vectors and can contain directional
    data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Output sockets are on the right-hand side of a node, and can be connected,
    or linked, to the input sockets on the left-hand side of another node:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.4: A principled node receiving color, roughness, and normal inputs](img/Figure_12.04_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.4: A principled node receiving color, roughness, and normal inputs'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the color attribute of a **Base Color** is an input socket and can be connected
    to any color output from another node. For instance, the input of a **Principled**
    node’s **Base Color** can come from an **RGB** node, as shown in *Figure 12**.4*,
    but also from an **Image Texture**, as shown in *Figure 12**.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.5: A principled node, with an image as the input of Base Color](img/Figure_12.05_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.5: A principled node, with an image as the input of Base Color'
  prefs: []
  type: TYPE_NORMAL
- en: Connection is conversion!
  prefs: []
  type: TYPE_NORMAL
- en: We can connect sockets of different types, such as vectors and colors; the data
    is converted automatically. The *X*, *Y*, and *Z* vector components are converted
    into the red, green, and blue elements of color, while the brightness of colors
    is converted into float values.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how materials work, we will write a script that helps load
    **Image Textures**.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the Textament add-on
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While creating a shader can take time, we can automate some of the simpler operations.
    For instance, we can write an add-on to ease the task of loading images from disk
    and connecting them to the shader.
  prefs: []
  type: TYPE_NORMAL
- en: Using texture images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the **Texture Image** node, we can use an image for coloring an object.
    That adds variation to how a material looks, as images can vary along the extension
    of an object and are not limited to a single color:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.6: An image texture of a Rubik’s cube, applied to a plain cube](img/Figure_12.06_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.6: An image texture of a Rubik’s cube, applied to a plain cube'
  prefs: []
  type: TYPE_NORMAL
- en: The operator that we are going to write will load multiple images from disk
    and guess their usage from the image’s filename. For instance, an image named
    `Metallic.png` would be loaded as a **Texture Image** and connected to the **Metallic**
    input of a **Principled** node.
  prefs: []
  type: TYPE_NORMAL
- en: As usual, we will set up an environment for developing a new add-on.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will create a Python script for our add-on and make it known to Blender
    by performing these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a folder called `PythonScriptingBlender/ch12/addons`. We can use the
    file manager or the file tab of our IDE for this, such as **VS Code**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new file in that folder and name it `textament.py`. We can use the
    file manager or the **New File** button of our IDE to do this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the file in your editor of choice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `PythonScriptingBlender/ch12` in Blender’s **File** **Paths** preferences.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Restart Blender to update the search paths.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we will start writing the add-on information as usual.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the Textament add-on information
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the information, we must specify what the add-on is for and where its tools
    can be found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The add-on contains just one class – an import operator for loading images.
  prefs: []
  type: TYPE_NORMAL
- en: Writing an import operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our operator loads the image textures from disk, so we will need the `os` module
    to handle disk paths. Besides `bpy`, this operator will inherit from the `ImportHelper`
    utility class so that it can access Blender’s **File Browser**
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Operators that derive from `ImportHelper` store the selected file paths in a
    few extra properties.
  prefs: []
  type: TYPE_NORMAL
- en: Using Blender’s File Browser
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Like all operators, `AddTextures` is based on `bpy.types.Operator`, but since
    it operates on files, it inherits from the `ImportHelper` class too. By inheriting
    from both classes, when it is launched, `AddTextures` runs the `invoke` method
    of `ImportHelper`, which opens the `execute` method runs as usual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Deriving from `ImportHelper` adds a `filepath` attribute to `AddTexture`, in
    which the path to the selected file is stored.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `filepath` attribute stores the disk path to a single file, which is not
    enough in our case as we intend to load multiple files at once. For that reason,
    we need to store the selected `directory` in a `StringProperty`, and the selected
    `files` as a collection of `OperatorFileListElement`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In another `StringProperty`, `filter_glob`, set the extensions of the files
    that should be displayed in the `.png` and `.jpg` images. This property is `"HIDDEN"`:
    we don’t want it to show up in the operator’s options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can write the operator method. We will start with `poll`, the method
    that checks if the operator can be launched.
  prefs: []
  type: TYPE_NORMAL
- en: Checking the existence of an active node
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This operator works on the current node, so we need to check for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An active object exists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is an active material
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A material node tree has been found
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The material tree has an active node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, the `poll` method returns `False` unless all the aforementioned conditions
    apply:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If the operator is launched and files are selected, they will be stored to be
    used in the `execute` method.
  prefs: []
  type: TYPE_NORMAL
- en: Matching texture filenames
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'At the beginning of `execute`, we store the currently active node in a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Operators that inherit from `ImportHelper` display the `execute` method after
    a choice in the **File Browser** is confirmed.
  prefs: []
  type: TYPE_NORMAL
- en: For that reason, at the time when `execute` is run, the `self.files` attribute
    will contain the file selection from the user. We can iterate `self.files` and
    compare each filename with the shader inputs. Rather than looking for an exact
    match, we will be happy to find a filename and an input name that are similar
    at large.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, `"baseColor.png"` should connect with the `"Base Color"` socket.
    In other words, we want case-insensitive and space-insensitive matching.
  prefs: []
  type: TYPE_NORMAL
- en: 'A quick way to achieve this is by using a combination of the `lower` and `replace`
    methods. We can test this in any Python console; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We will need to perform this operation for every file, on any input, so we should
    create a function for that.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `lambda` statement is a quick way to create a function by just stating
    its arguments and one expression. For instance, putting an input, *x*, into lowercase
    and as a non-spaced string can be written in this form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike `def`, `lambda` doesn’t assign a name to the function as names are not
    a requirement of the syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we are storing its result in the `match_rule` variable, our example is
    equivalent to writing the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`lambda` can be used to write more compact code, or if a function is required
    as an argument but is not supposed to be called directly.'
  prefs: []
  type: TYPE_NORMAL
- en: We will use `match_rule` on every filename and every potential socket and compare
    the results while looking for a match.
  prefs: []
  type: TYPE_NORMAL
- en: 'Node sockets are stored in `inputs`, a dictionary-like collection attribute
    of every node. We can get a list of the socket names using the `keys` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it’s time to look for textures to link. We can combine two for loops and
    scroll all the inputs for each entry in `self.files`. If a match is found, the
    input/filename pair will be added to the `matching_names` dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `break` statement aborts the `input_names` loop when a match is found so
    that we can proceed to the next file.
  prefs: []
  type: TYPE_NORMAL
- en: Once the `matching_names` dictionary contains the input for which textures were
    found and the relative filenames, we can load the images from disk and add them
    to the graph.
  prefs: []
  type: TYPE_NORMAL
- en: Loading image files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The elements of `self.file` are not full disk paths. We can build this from
    `directory` and `os.path.join` so that we can use `bpy.data.images.load`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `check_existing` parameter avoids loading the same image more than once:
    if it is already present in `bpy.data.images`, the `load` method returns the existing
    entry.'
  prefs: []
  type: TYPE_NORMAL
- en: We have mentioned that not all sockets are colors, but also that vectors, colors,
    and float sockets are converted automatically when they are connected. Therefore,
    non-color data such as metallic (a float number) or normal (a vector) can be stored
    in images.
  prefs: []
  type: TYPE_NORMAL
- en: One of the main points of a node graph is that we should be able to connect
    sockets of different, but broadly similar, types.
  prefs: []
  type: TYPE_NORMAL
- en: Getting non-color attributes from images
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The colors of an image are not different from vectors in terms of their information,
    which consists of three channels or components: **red**, **green**, and **blue**.'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting a **Color** socket to a **Vector** socket will use the red, green,
    and blue channels as the *X*, *Y*, and *Z* coordinates of a three-dimensional
    vector, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: If a color output is connected to a float socket, the brightness, also called
    its **luminance** or **value**, will be used as float input.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever an image is used for storing values rather than colors, it’s important
    to inform Blender about that; otherwise, color adjustments from the renderer would
    alter the image information.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do that by setting the image color space to `NonColor` if a socket is
    not of the `"``RGBA"` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If we don’t do that, even correct textures will produce render artifacts.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this stage, the images have been loaded into Blender but they are not present
    in the node tree yet: we need to create an **Image Texture** for that.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating image texture nodes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: New material nodes can be added to a material shading graph by accessing the
    `nodes` collection of its `node_tree`. The `new` collection method requires the
    node to be of the `argument` type. In this case, `ShaderNodeTexImage` is the type
    that we use for creating image textures, but we can find the Python type of every
    shading node by looking at the menu tooltips.
  prefs: []
  type: TYPE_NORMAL
- en: 'If **Python Tooltips** is enabled in **Edit** | **Preferences**, like we learned
    to do in [*Chapter 2*](B18375_02.xhtml#_idTextAnchor033), we can view the node
    type by hovering over the menu entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.7: Hovering over the Add menu entries displays the node type in
    the tooltip](img/Figure_12.7_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.7: Hovering over the Add menu entries displays the node type in the
    tooltip'
  prefs: []
  type: TYPE_NORMAL
- en: 'This way, we can create a new texture node and set its `image` attribute to
    the image that we have loaded from disk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The texture nodes added to the graph are now ready for connection links.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting nodes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While most texture output can be connected directly to a shading node, some
    input types might require helper nodes in between. The most prominent case is
    that of detail, or **normal maps**. Before creating new connections, our code
    should check that no additional nodes are required.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting image colors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Connection links can be created using the `node_tree.links.new` method. Its
    arguments are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The output socket of the outgoing node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The input socket of the receiving node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we are not dealing with a normal map, we can connect the `"Color"` output
    of the texture to the input of the active node. No other action is required, so
    we can use `continue` to pass to the next input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'A `normal` input would not trigger `continue`, so we don’t need an `else` statement
    for it: the normal map code follows, without additional indentation.'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting normal maps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Rendering a detailed surface using geometry alone would require so many polygons
    that the resulting model would be too heavy to store or display.
  prefs: []
  type: TYPE_NORMAL
- en: '**Normal mapping** stores geometric details in the pixels of an image using
    the RGB-to-XYZ conversion.'
  prefs: []
  type: TYPE_NORMAL
- en: Since the normals stored in this way must be merged with the original ones,
    a **Normal** texture should not connect directly to a shader node; instead, it
    should pass through a **NormalMap** node.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add a `"ShaderNodeNormalMap"` to the tree using `new`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `"Normal"` output of `normal_map` can be connected to the node input using
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we must connect `tex_img` to the `normal_map` node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the `inp, fname` loop is over, we can return the `''FINISHED''` status
    and exit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Since this script aims to make setting up the texture faster, we can add an
    operator button for quick execution.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a header button
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have used menus for most of the operators in this book, but this time, we
    will add a button in the **Shader Editor** area’s top bar – that is, its header.
    The steps are the same as those we used to add menu entries:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a function that accepts two arguments, `self` and `context`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Append that function to the header type when the add-on registers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Using `NODE_TEXTURE`. The `layout.operator` method will display `AddTextures`
    as a header button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it’s time to register the operator and the header function. We can find
    the header class we are looking for, `NODE_HT_header`, by looking in Blender’s
    source file, `space_node.py`. This file can be loaded into Blender’s text editor
    by right-clicking and choosing **Edit Source**. We can do this on any element
    of the **Shader Editor** area’s header:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.8: NODE_HT_header is the first class in space_node.py](img/Figure_12.8_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.8: NODE_HT_header is the first class in space_node.py'
  prefs: []
  type: TYPE_NORMAL
- en: 'As an alternative, we can print a list of all the header types using a `comprehension`
    in Blender’s Python console. We learned how to do this in [*Chapter 8*](B18375_08.xhtml#_idTextAnchor206):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '`NODE_HT_header` is in the middle of the list. We must append our entry to
    it inside the `register` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In `unregister`, we must remove our interface and class when the add-on is
    disabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Now that the add-on is ready, we can use it for loading textures instantly.
  prefs: []
  type: TYPE_NORMAL
- en: Using Load Textures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If the `ch12` folder was added to the **Scripts** path, we can enable **Textament**
    in the **Learning** category of the **Add-ons** preferences:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.9: Enabling the “Textament” add-on](img/Figure_12.09_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.9: Enabling the “Textament” add-on'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once it’s enabled, a button called **Load Textures** will be added to the **Shader**
    **Editor** header:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.10: The Load Textures button in the Shader Editor header](img/Figure_12.10_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.10: The Load Textures button in the Shader Editor header'
  prefs: []
  type: TYPE_NORMAL
- en: Selecting a node allows you to click the **Load Textures** button, which opens
    the **File** **Browser** area.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test this add-on on a simple model, we can apply a brick wall material to
    the default cube by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Blender or go back to the default scene via **File** | **New** | **General**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Switch to the **Shading** workspace using the tabs at the top of the window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Load Textures** in the **Shader Editor** area’s header.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **File Browser** area, navigate to a folder containing images. The textures
    accompanying this chapter can be found at [https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch12/_media_/textures](https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch12/_media_/textures).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Optionally, we can switch the **File Browser** area to **thumbnails** mode
    by clicking the thumbnails button on the top right. This is useful for looking
    for textures:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.11: “Load and connect” thumbnails in the File Browser area](img/Figure_12.11_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.11: “Load and connect” thumbnails in the File Browser area'
  prefs: []
  type: TYPE_NORMAL
- en: We can select multiple files by using the lasso, *Ctrl* + clicking, or pressing
    *A* to select all.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press **Load and connect** to add the textures to the graph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `bricks_baseColor`, `bricks_normal`, and `bricks_roughness` textures are
    now the inputs of the material and make the cube look like a brick wall:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.12: Brick textures loaded into the Shader Editor area](img/Figure_12.12_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.12: Brick textures loaded into the Shader Editor area'
  prefs: []
  type: TYPE_NORMAL
- en: The operator was successful but all the nodes were created at the center of
    the graph. We can improve this considerably by adding code that rearranges the
    nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Improving Load Textures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nodes can be moved to a different position by setting the `x` and `y` attributes
    of their `location` property. This allows us to arrange them in our scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Arranging shader nodes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Even if we can move our nodes freely, the API poses a few limitations:'
  prefs: []
  type: TYPE_NORMAL
- en: We can’t access the exact location of the sockets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The width and height of new nodes are not available in the scripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One of those two issues at a time would be tolerable, as we could either move
    our nodes at the height of their inputs or get the space required by a new node
    on the fly. Since they occur together, we will resort to a workaround.
  prefs: []
  type: TYPE_NORMAL
- en: Assuming node spacing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We cannot get the size of new nodes in a script, but we can learn the default
    size of a texture node beforehand by looking at an existing shader tree. For instance,
    after we use `dimensions` property of an `''Image` `Texture''` node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Vector` property returned by `dimensions` contains the bounding box of
    the node, not the node’s exact measures. We can verify that by querying the node’s
    `width` instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Even if it is present, the `height` attribute does not help because it hasn’t
    been updated and its value stays fixed at `100.0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Despite that weakness in the API, we have enough information to rearrange our
    tree: leaving `100.0` units between two nodes leaves enough room for connections,
    so we can use a spacing of `340.0` units between our textures and the initial
    node.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We must store that value in the declaration of our operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: To arrange our nodes vertically, we need to process them in the correct order.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting the node creation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To space the nodes vertically in the correct way, we need to process them while
    following the sockets order in the target node layout; otherwise, the connection
    links will cross each other:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.13: An unordered vertical arrangement leads to tangled, confusing
    links](img/Figure_12.13_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.13: An unordered vertical arrangement leads to tangled, confusing
    links'
  prefs: []
  type: TYPE_NORMAL
- en: 'Python dictionaries are unordered by design, so `matching_names` doesn’t follow
    any order, but the `input_names` list does. This list contains the ordered names
    of all sockets. By filtering it with `matching_names`, we can obtain an ordered
    list of the matching inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We must replace the `for inp, fname in matching_names.items()` loop with an
    iteration of `sorted_inputs`. Since we need an ordinal for vertical spacing, we
    must use `enumerate` to get the index of the current input. Here is the new image
    loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'After a texture nodes is connected, we can change its location. We start with
    the same coordinates as `target_node`, then move the texture to the left by subtracting
    `_spacing` from `location.x`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We can move the texture nodes downwards by subtracting `self._spacing` from
    `location.y`. We are stacking the nodes vertically, so their `y` coordinates depend
    on their ordinal indexes. The first node, which has an index of `0`, will not
    move at all from the initial position, the second node moves down by `self._spacing`
    times `1`, the third by `self._spacing` times `2`, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Connecting `ShaderNodeNormalMap` requires horizontal space, so, after we align
    `normal_map` with its `img_node`, we must make some room by moving the texture
    to the left and `normal_map` to the right, by an amount of half `_spacing`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we must save the add-on and update it by clicking *F3* and choosing **Reload
    Scripts**. Launching **Load Textures** sets up a properly arranged node tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.14: Texture set up, with arranged nodes](img/Figure_12.14_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.14: Texture set up, with arranged nodes'
  prefs: []
  type: TYPE_NORMAL
- en: Now that the basic functionality is complete, we can implement an option for
    customizing the color of the material.
  prefs: []
  type: TYPE_NORMAL
- en: Mixing the Base Color
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, even if we are happy with our texture setup, we want to change the
    color while retaining the texture pattern. We can do that by adding a **MixRGB**
    node before the **Base Color** property of a principled node:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.15: Affecting the material color with a MixRGB node](img/Figure_12.15_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.15: Affecting the material color with a MixRGB node'
  prefs: []
  type: TYPE_NORMAL
- en: The **MixRGB** node features a factor slider (**Fac**) for blending two colors.
    The default blending type, **Mix**, replaces **Color1** with **Color2**, but other
    blending modes known in computer graphics, such as **Multiply**, **Overlay**,
    and **Color Dodge**, are also available.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python setup for a `ShaderNodeMixRGB` node is similar to that of a `"Base
    Color"`, we create an intermediate node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we align the image texture and the **Mix** node, and make room for additional
    connection links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We connect the image color to the `"Color1"` input of the **Mix** node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we would connect the `img_node` variable instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'This way, the connection to `target_node` is made by the same line of code
    that connects all the other inputs except `"Normal"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: If we execute **Reload Scripts** and then launch **Load Textures** again, a
    mixed layout like the one displayed in *Figure 12**.15* is created. We can click
    on the **Color2** attribute and select a color from the picker or change the **Mix**
    node’s **Blending Mode** from its drop-down menu.
  prefs: []
  type: TYPE_NORMAL
- en: We can also experiment with different solutions. For instance, we can use `"ShaderNodeMixRGB"`
    with `"ShaderNodeHueSaturation"` and `"Color1"` with `"Color"`.
  prefs: []
  type: TYPE_NORMAL
- en: Node trees are interesting as they can be considered visual programming, but
    even the trivial operation of loading a few textures, if done manually, can take
    time.
  prefs: []
  type: TYPE_NORMAL
- en: This time, we didn’t have to create an interface for manipulating the blended
    color as the mix node already provides it, so we could combine the best of two
    procedural approaches.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how materials work and how nodes are created and
    connected in the **Shader Editor** area. We also learned how image textures can
    change the appearance of shaded objects and how they can store non-color data.
  prefs: []
  type: TYPE_NORMAL
- en: This was our first encounter with node trees, a generic visual programming approach
    that is not limited to shaders and is planned to expand to deformation and rigging
    in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Node-based systems are flexible and powerful, but they benefit from scripted
    tools, like all other aspects of Blender.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering is not the final step of production as compositing and editing follow
    in the computer graphics pipeline. But since this stage converts three-dimensional
    data into images, it’s usually considered the last step of the 3D workflow.
  prefs: []
  type: TYPE_NORMAL
- en: That ends our journey into how Blender scripting works. We have covered object
    creation, deformation, animation, and rendering, but most importantly, how tools
    are designed and implemented, and how the software limitations can be overcome.
  prefs: []
  type: TYPE_NORMAL
- en: Those skills, combined with individual talent and experience, allow technical
    directors to bridge between artistic needs and software capabilities, empower
    their teams, and improve their abilities and understanding in the process.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How many render engines are present in Blender?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do the words *material* and *shader* have the same meaning?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Are the shader nodes predefined values that determine how objects look or separate
    units performing independent operations?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can we use images for coloring objects?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can we make connections between different data types?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we arrange nodes in a graph?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In our shaders, can we alter the colors coming from an image?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Appendix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Blender and Python are so vast that even writing scripts for a shortlist of
    use cases encompasses a wide range of skills and disciplines. This book contains
    elements of animation, rigging, and shading and introduces programming techniques
    while exploring those processes.
  prefs: []
  type: TYPE_NORMAL
- en: This appendix contains a comprehensive summary that can be useful as a recap
    to help with the retention of the concepts explored in this book and help the
    reader navigate through the chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 1: An Introduction to Python'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section covers the fundamentals of scripting and helps you become familiar
    with Blender’s Python utilities. Besides providing a solid base for the chapters
    ahead, it contains all the information required for writing fully working tools.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 1](B18375_01.xhtml#_idTextAnchor014), Python’s Integration with Blender'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter introduces the tools used for scripting, internal and external
    text editors, and version control.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s a summary of the topics discussed in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Installing multiple versions of Blender on the main operating systems
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Blender 3.3 is the *long-term support* release used in the writing process.
    Although the content of this book is valid for all the 3\. x series of blender,
    if you want to install version 3.3 alongside other versions, the following instructions
    are provided:'
  prefs: []
  type: TYPE_NORMAL
- en: Using Windows Installer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Microsoft Store
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Downloading a portable archive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing on macOS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Python in Blender
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **Scripting** workspace is a Blender layout optimized for running Python
    quickly. It consists of an interactive console, a logger listing the commands
    of past actions, and a Text Editor that can run scripts. We will become familiar
    with it through these topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Producing console output with the *“Hello* *World!”* example
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to copy and paste Python instructions from the **Info Log**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking the current version of Blender and Python using scripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An explanation of functions and arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using external editors and version control tools
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Even though the Text Editor is quick and useful, programmers usually take advantage
    of external code editors as well. **Visual Studio Code**, a multiplatform editor
    from **Microsoft**, is used in this book, but there are plenty of alternatives.
    **Version control** tools are useful tools that for storing the history of code
    changes. We learn how to use these tools by going through the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Loading folders in Visual Studio Code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refreshing text files in the Blender Text Editor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializing and using a **Git** repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 2](B18375_02.xhtml#_idTextAnchor033), Python Entities and API'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter explains how to interact with Blender using scripts, how to take
    advantage of features for developers, and how the **Application Programming Interface**
    (**API**) works.
  prefs: []
  type: TYPE_NORMAL
- en: The following sections are a summary of the topics discussed in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: User interface features for developers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two useful options in the **Interface** section of Blender’s preferences:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Developer Extras**: This displays the **Edit Source** option when we right-click
    on an element of the interface so that we can easily access the Python source
    code of the **user interface** (**UI**). It also makes non-UI operators available
    in the search bar.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Python Tooltips**: This displays the Python property relative to the UI element
    under the mouse cursor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Console features for developers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The interactive console provides two handy features for quick scripting:'
  prefs: []
  type: TYPE_NORMAL
- en: Code auto-completion by pressing the *Tab* key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Commands history by pressing the Up-arrow key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Viewport features for developers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Math Vis (Console)** add-on included with Blender and available in the
    **3D View** section of the **Preferences** > **Add-ons** dialog displays three-dimensional
    mathematical entities such as *vectors* and *matrices* in the 3D Viewport. It
    can be useful when working with object location and rotation values.
  prefs: []
  type: TYPE_NORMAL
- en: Using Blender modules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Blender’s Python module, `bpy`, is accessed in scripts using the `import` statement.
    Each of its components covers a specific aspect of the 3D app. Most notably, `data`
    contains all the objects available in the current session, while `context` contains
    the current state of the user interaction, such as the current selection. The
    API documentation is available online but can also be viewed using the `help()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Using object collections
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Lists of objects are accessed through `bpy_collection`, an aggregate type similar
    to a Python `dictionary`. Elements of a collection can be accessed with numeral
    indices or keywords and can be iterated in Python loops.
  prefs: []
  type: TYPE_NORMAL
- en: Operations such as renaming can reorder the elements of a collection, so a conversion
    to `list` is advised when the order is critical.
  prefs: []
  type: TYPE_NORMAL
- en: 'Blender collections don’t have an `append()` method: the `new()` method is
    used for creating a new object, which is automatically appended. The `remove()`
    method removes an element from a collection and deletes it from Blender.'
  prefs: []
  type: TYPE_NORMAL
- en: Context and user activity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Users can change the current state or context of Blender by adding or selecting
    objects. The last selected object is considered *active* and is the main target
    of object-related actions.
  prefs: []
  type: TYPE_NORMAL
- en: Context information is available as properties of `bpy.context`, is read-only,
    and can only be changed indirectly. For instance, `ob.select_set(True)` is used
    to select an object, as it’s impossible to append to the `bpy.context.selected_objects`
    list.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 3](B18375_03.xhtml#_idTextAnchor049), Creating Your Add-Ons'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This chapter illustrates the process of creating Blender add-ons: Python scripts
    that can be installed as Blender plugins to add custom functions.'
  prefs: []
  type: TYPE_NORMAL
- en: Here’s a summary of the topics discussed in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Writing scripts that are add-ons
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Add-ons are Python modules or packages containing a dictionary named `bl_info`.
    This dictionary contains information such as the author and name of the add-on.
    Add-ons must provide two functions, `register()` and `unregister()`, used when
    an add-on is enabled or disabled.
  prefs: []
  type: TYPE_NORMAL
- en: Add-ons can be installed in Blender preferences, but setting the folder where
    they are developed as `Reload Scripts` in the *F3* key search bar.
  prefs: []
  type: TYPE_NORMAL
- en: Writing Object Collector, an add-on that groups objects in the Outliner
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Adding features to Blender involves the creation of an operator, that is, an
    instruction that can be launched from the user interface. The `bl_idname` and
    `bl_label` attributes determine how an operator is found and displayed in Blender,
    while the `poll()` and `execute()` functions regulate when it can be launched
    and what happens when it runs.
  prefs: []
  type: TYPE_NORMAL
- en: Add-ons add operators to Blender in their `register()` and `unregister()` functions.
  prefs: []
  type: TYPE_NORMAL
- en: Tips for working on add-ons
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When using an external editor, enabling auto-save might help ensure that the
    Python script always includes the latest changes.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling add-ons from the development folder might leave *bytecode*, that is,
    Python-compiled files in a folder named `__pycache__`. If we use Git version control,
    we can create a text file named `.gitignore` that contains `__pycache__` to avoid
    bytecode files ever being versioned.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding duplicates using try and except
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To prevent our script from creating the same collection twice, resulting in
    duplicates, we look for a collection inside a `try` statement and add an `except
    KeyError` block that is triggered when no collection is found. By creating new
    collections under the `except` statement, we ensure that collections with a given
    name are only created once. The try/except pattern is called *forgiveness rather
    than permission*, as it focuses on pulling back from non-allowed actions rather
    than checking whether an action is possible in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: We use the `title()` string method for nicely formatted names with a capital
    first letter. We can create functions for adding our operator to Blender menus.
    They accept the `self` and `context` arguments and add operators to `self.layout`.
    Menu functions are added to Blender in the `register()` and `unregister()` functions
    of the add-on.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 4](B18375_04.xhtml#_idTextAnchor075), Exploring Object Transformations'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter shows how to affect `location`, `rotation`, and `scale` of an object
    using Python and how the transform information is stored in Blender.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s a summary of the topics discussed in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Moving and scaling objects with Python
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`location` is stored as the `x`, `y`, and `z` coordinates of a three-dimensional
    vector. The coordinates of a vector can be changed individually or together, using
    tuple assignment.'
  prefs: []
  type: TYPE_NORMAL
- en: '`scale` is stored as an `x`, `y`, `z` vector too. While the rest value of `location`
    has the `(0.0, 0.0, 0.0)` coordinates, a non-scaled object’s `scale` attribute
    is `(1.0,` `1.0, 1.0)`.'
  prefs: []
  type: TYPE_NORMAL
- en: Peculiarities of rotations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Rotations are less straightforward than `location` and `scale`, as the `rotation`
    values over the three axes can affect each other, causing an issue known as *gimbal
    lock*.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is more than one way to represent rotations; some involve multidimensional
    entities such as quaternions or rotation matrices, and two measure units for angles:
    *degrees* and *radians*. Blender objects have attributes for each notation system,
    which can be set via Python. Conversion utilities are provided for switching from
    one notation system to another.'
  prefs: []
  type: TYPE_NORMAL
- en: Indirect transformations with parents and constraints
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Objects can be arranged in hierarchies. Transformations of an object higher
    in the hierarchy (*parent*) affect all the objects under them (*children*).
  prefs: []
  type: TYPE_NORMAL
- en: Constraints are another way to transform an object without affecting its channels.
    They can be added using the `new()` method of the `constraints` collection.
  prefs: []
  type: TYPE_NORMAL
- en: Transforming objects with matrices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Setting values for the `location`, `rotation`, and `scale` channels affects
    the relative coordinates of an object. Assigning a transformation matrix allows
    us to use world-space coordinates instead. Matrix values are lazy-copied unless
    stated otherwise; if we store a matrix as a variable and don’t want its values
    to change we need to use its `copy()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Parenting to a transformed object in Python changes the object location unless
    a reverse transformation is set in the `matrix_parent_inverse` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Writing Elevator, an add-on that sets a floor for the selected objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The operator from the `FloatProperty` that can be set when it’s launched. Optional
    behaviors can be enabled by switching its `BoolProperty` members.
  prefs: []
  type: TYPE_NORMAL
- en: Editable properties must be added as *annotations*, Python arbitrary attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Parent objects at the top of the hierarchy are moved first to avoid duplicate
    transformations. Constraints can be used optionally.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 5](B18375_05.xhtml#_idTextAnchor100), Designing Graphical Interfaces'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter explains how to add custom panels and add them to the Blender interface.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s a summary of the topics discussed in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Components of the UI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Blender window is structured into areas, regions, and panels. Panels have
    a layout that is populated with text, icons, and buttons using Python.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the Simple Panel add-on
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This add-on registers a simple `Panel` class that displays text and icons in
    the `row()` or `column()`methods, non-uniform columns using `split()`, and uniform
    tables using `grid_flow()`.
  prefs: []
  type: TYPE_NORMAL
- en: Blender icon names can be looked up using the **Icon Viewer** add-on or, in
    some cases, built using Python’s string formatting.
  prefs: []
  type: TYPE_NORMAL
- en: Red and gray colors can be used to give visual feedback using the `alert` or
    `enabled` flags of a widget.
  prefs: []
  type: TYPE_NORMAL
- en: Operators added to a layout using the `operator()` method are displayed as buttons.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 2: Interactive Tools and Animation'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section explains how to write add-ons as folders rather than single files,
    interact with the animation system, and write modal operators that wait for user
    input. By the end of this section, you will be able to write advanced, interactive
    tools.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 6](B18375_06.xhtml#_idTextAnchor129), Structuring Our Code and Add-Ons'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter explains how to write and distribute addons containing multiple
    files in a folder.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s a summary of the topics discussed in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The relationship between modules, packages, and add-ons
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While a single `.py` file is a Python module, a folder containing `.py` files
    is a Python package. Packages contain a file named `__init__.py`. If our package
    is an add-on, this file must contain the `bl_info` dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: Guidelines for partitioning code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Some criteria for separating the code through different `.py` files are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Media loaders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generic code versus specific code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interface code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operator modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use of imported modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, all the code used for loading custom icons, as explained in [*Chapter
    5*](B18375_05.xhtml#_idTextAnchor100), can be moved to a module named `img_loader.py`.
  prefs: []
  type: TYPE_NORMAL
- en: Only `__init__.py` is reloaded by the `importlib.reload()` function.
  prefs: []
  type: TYPE_NORMAL
- en: A panel to display the add-on preferences can be written in a `preferences.py`
    file, while `panel.py` and `operators.py` contain, respectively, the UI and the
    add-on operators.
  prefs: []
  type: TYPE_NORMAL
- en: Add-on folders compressed as `.zip` archives can be installed using the **Preferences**
    | **Addons** | **Install** button.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 7](B18375_07.xhtml#_idTextAnchor171), The Animation System'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter explains how to animate objects in Blender and how to create and
    edit animations with Python.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s a summary of the topics discussed in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The Animation system
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Layout** and **Animation** Workspaces display animation keyframes on a
    **Timeline** including the scene actions, keyframes, and range. Keyframes establish
    the value of a property at a certain time.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the Action to Range add-on
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This add-on sets the start and end of the playback to the first and last frame
    of the current action of the active object. If a timeline is displayed onscreen,
    it is recentered to the new range. To do that, `context.temp_override()` is used
    to pass a timeline region to the `bpy.ops.action.view_all()` factory operator.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the Vert Runner add-on
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This add-on animates the selected objects along the vertices of the active object.
    The vertex coordinates stored in `context.object.data.vertices` are read, while
    trigonometric functions are used for computing the shortest rotation arc that
    orients an object toward its next position.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 8](B18375_08.xhtml#_idTextAnchor206), Animation Modifiers'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter covers non-destructive modifiers for animation f-curves and their
    use in animating procedural effects.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s a summary of the topics discussed in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Adding f-curve modifiers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: F-curve modifiers can be added by selecting a curve in the graph editor and
    clicking `new()` method from the `modifiers` collection of f-curves.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the Shaker add-on
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This add-on uses a **Noise** f-modifier to add a trembling effect on the active
    object and allows to set the duration and amount of the trembling. *Soft limits*
    set an initial limitation on the noise strength parameter while still allowing
    you to type out-of-range values using the keyboard. We add a menu entry for invoking
    this operator using the right-click menu in the Viewport.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 9](B18375_09.xhtml#_idTextAnchor226), Animation Drivers'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter introduces animation drivers, which are the connections between
    different properties used to control complex actions. Drivers can incorporate
    short Python expressions in their logic.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s a summary of the topics discussed in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and setting drivers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Drivers can be created quickly by selecting **Copy As New Driver** and **Paste
    Driver** from the right-click menu of Blender properties. Using an object’s location
    as input for its rotation creates a wheel setup since the object rotates when
    it’s moved.
  prefs: []
  type: TYPE_NORMAL
- en: Using Python drivers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python expression-based drivers can be created quickly by pressing the *#* key,
    followed by Python code while editing a Blender property. Oscillatory motions
    can be created using trigonometric cyclic functions such as `sin`, and the pendulum
    equation from the physics classroom can be implemented as a driver expression.
    Object custom properties can be used as parameters in driver expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the Pendulum add-on
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This add-on instantly sets up the pendulum expression and parameters. Drivers
    are added using the `object.driver_add()` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 10](B18375_10.xhtml#_idTextAnchor247), Advanced and Modal Operators'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter explains how to write advanced operators by enriching their execution
    flow and implementing optional methods.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s a summary of the topics discussed in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Operator execution details
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `invoke()` method of `Operator`, if defined, runs when the operator is launched.
    Inside `invoke()`, we can switch either to the `execute()` method or to the `modal()`
    method. The latter listens to user inputs such as key presses or mouse movements.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the PunchClock add-on
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This add-on creates time-formatted text in the scene. Its operator sets the
    initial values of its hour and minute parameters in `invoke()` using Python `datetime`
    utilities. When adding the operator to a menu, `operator_context` of the layout
    is set to `"INVOKE_DEFAULT"` so that the execution of `invoke()` is never skipped.
  prefs: []
  type: TYPE_NORMAL
- en: Modal behavior
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The operator is added to the modal handlers so that its `modal()` method is
    run at every update of the UI. Inside the modal, the `"MOUSEMOVE"` events change
    the displayed hour and minute.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the undo panel
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The undo panel displays the operator properties after the execution is customized
    by implementing the `draw()` method. With this method, we can design a graphic
    interface using the same techniques learned in [*Chapter 5*](B18375_05.xhtml#_idTextAnchor100).
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 3: Delivering Output'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section covers the final stages of the 3D pipeline: deformation and rendering.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 11](B18375_11.xhtml#_idTextAnchor265), Object Modifiers'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter covers object modifiers and their use in animation.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s a summary of the topics discussed in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Adding object modifiers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Modifiers are grouped into four categories: **Modify**, **Generate**, **Deform**,
    and **Physics**. They are created by clicking the **Add Modifier** button in the
    **Modifiers** property.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding modifiers in Python
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `new()` method of the `object.modifiers` collection requires the `type`
    modifier as an argument. A list of the possible `type` keywords can be found by
    accessing the `bpy.types.ObjectModifiers.bl_rna.functions["new"]` function and
    querying its `parameters["type"].enum_items`.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the Latte Express add-on
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This add-on sets up a **Lattice** modifier to deform an object using a three-dimensional
    grid cage. It finds the center of the model by querying its bounding box and has
    input parameters for changing the lattice and the object’s resolutions.
  prefs: []
  type: TYPE_NORMAL
- en: Using armature deformers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Armatures affect characters using a deformation skeleton. Bones can be created
    in Python using `object.data.edit_bones.new()` after switching to `bpy.ops.object.mode_set()`.
  prefs: []
  type: TYPE_NORMAL
- en: Vertex groups are created on the lattice object to bind the lattice vertices
    to the armature bones. This way, a lattice deformed by an armature can be created
    via a script.
  prefs: []
  type: TYPE_NORMAL
- en: Creating control shapes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Replacing the default octahedral shape with custom wireframe shapes makes an
    armature more animator friendly. For that reason, a simple mesh can be created
    in Python using the `mesh.from_pydata` method, and assigned to the `pose_bone.custom_shape`
    attribute.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 12](B18375_12.xhtml#_idTextAnchor304), Rendering and Shaders'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter introduces rendering and materials, the shader editor, and its
    node tree. Although some steps such as post-processing and video encoding may
    follow, rendering is commonly regarded as the last stage of a 3D process.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s a summary of the topics discussed in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How rendering works
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A render engine such as Blender’s **Eevee** or **Cycles** converts the 3D geometry
    to finished images using *shaders* to determine how objects look. Blender shaders
    are networks of operations called nodes, that is, blocks that elaborate and exchange
    color and geometry information by connecting their input/output sockets.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the Textament add-on
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This add-on imports images from disk and creates the `ImportHelper` and `Operator`,
    and display the Blender file browser when invoked. The files the user selecteds
    are accessed as the `directory` and `files` member attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Looking for case-insensitive matches in file names
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Uppercase letters and spaces might cause unwanted mismatches, such as the `"base
    color"` strings not being associated with `"Base Color"`. A function for string
    manipulation can be written with the usual syntax or defined in one line using
    a `lambda` expression. Removing all spaces and converting all letters to lowercase
    becomes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`lambda x : x.lower().replace(" ", "")`'
  prefs: []
  type: TYPE_NORMAL
- en: Non-color data in images
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Images can contain geometric or masking information. In that case, the `colorspace_setting.name`
    image attribute must be set to `"Non-Color"`, or Blender will apply color filters
    that pollute the information.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting images in shaders
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Creating a `"ShaderNodeTexImage"` as an argument of `node_tree.nodes.new("ShaderNodeTexImage")`
    allows you to use images in shaders. The connection between a texture node and
    a shader node input is created using `node_tree.links.new()`.
  prefs: []
  type: TYPE_NORMAL
- en: '*Normal map* textures give the illusion of detail. They must connect to **Normal
    Map**, which is then connected to the **Normal** input of a shader.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding custom buttons to headers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Operators can be added to headers in the same way as they are added to menus:
    using a function that takes the `self` and `context` arguments, and adds elements
    to `self.layout`. This function is appended to a *Header Type* in the `register()`
    function of the add-on.'
  prefs: []
  type: TYPE_NORMAL
- en: Arranging nodes in the node editor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Nodes created in Python are positioned at the center of the editor and overlap
    each other. They can be moved by setting their `location` `x` and `y` coordinates.
    They should be placed on the left-hand side of their output node and sorted vertically
    according to the order of their output node sockets.
  prefs: []
  type: TYPE_NORMAL
- en: Altering texture colors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The color of a texture can be manipulated by adding a **Mix** node between a
    texture and its output node. That allows you to change the overall color of an
    object while retaining the details coming from the image.
  prefs: []
  type: TYPE_NORMAL
