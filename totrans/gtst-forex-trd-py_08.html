<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-129"><a id="_idTextAnchor130"/>8</h1>
<h1 id="_idParaDest-130"><a id="_idTextAnchor131"/>Data Visualization in FX Trading with Python</h1>
<p>In previous chapters, we learned how to receive and store market data, how to process it, and how to calculate various technical indicators. However, working with large amounts of time series data frequently leads to errors typically caused by sad mistakes – for example, using incorrect data feed or wrong timestamps. Besides that, when working with TA indicators, it’s really wise to check the result of the calculations visually – for example, you want to use a large period moving average to determine long-term price movements, but you make a mistake, enter a small period value, and then find yourself lost in debugging because no real long-term trend can be found. Making your research visual helps identify various mistakes very quickly and saves a lot of time.</p>
<p>In this chapter, we will learn how to visualize data using one of the industry standard libraries, <code>matplotlib</code>, and then go on to plotting bar and candlestick charts with the <code>mplfinance</code> library, and we will see how it’s possible to create charts with live updates and use additional graphics with price charts.</p>
<p>In this chapter, the following topics will be covered:</p>
<ul>
<li>Charting and plotting basics – how to use graphical libraries with Python</li>
<li>Quick plotting using scripts or an interactive console</li>
<li>Visualizing historical market data</li>
<li>Creating bar and candlestick charts</li>
<li>Visualizing live market data</li>
<li>Adding other objects to price charts</li>
</ul>
<h1 id="_idParaDest-131"><a id="_idTextAnchor132"/>Technical requirements</h1>
<p>To run the practical examples in this chapter, you only require Python 3.9 or above.</p>
<h1 id="_idParaDest-132"><a id="_idTextAnchor133"/>The basics of charting with Python</h1>
<p>There are many <a id="_idIndexMarker489"/>libraries that implement charting with Python but at the time of writing, two of them are industry standards – <code>matplotlib</code> and <code>plotly</code>:</p>
<ul>
<li><code>numpy</code> arrays, support numerous types of charts, including financial ones (which is what we need!), provides full control over chart objects, features almost unlimited chart customizations, and can be used with different backends.</li>
<li><code>matplotlib</code> so the choice between the two is not obvious. Plotly definitely wins when it comes to interactivity and working with chart objects via an API but loses the competition in speed and abilities for customization.</li>
</ul>
<p>Which one do we choose? Generally speaking, if you do not plan to develop a commercial-grade GUI application, then <code>matplotlib</code> is the obvious choice because it’s easy to use, is very well documented, and has decent community support.</p>
<p>Before we start, let’s quickly look at how <code>matplotlib</code> (and similar charting libraries in general) work and clearly decide what we are going to do, and especially what we are <em class="italic">not</em> going to do. We will learn about different backends, consider the peculiarities of plotting real-time and static data, and get familiar with the internal organization of graphical engines and their interaction with the <em class="italic">outer world</em> (your code).</p>
<h2 id="_idParaDest-133"><a id="_idTextAnchor134"/>Graphical backends</h2>
<p>Any charting package used with Python has various <strong class="bold">backends</strong> – the very engines that render graphics <a id="_idIndexMarker492"/>on screen. Out of the box, we have a choice of four backends: Agg, <strong class="bold">PS</strong> (<strong class="bold">postscript</strong>), PDF (yes, the standard PDF format used for documents), and <a id="_idIndexMarker493"/>SVG (the standard for vector graphics).</p>
<p>Backends have <strong class="bold">bindings</strong> – in simple terms, wrappers that facilitate calls to backends from <a id="_idIndexMarker494"/>Python. Some backends offer interactive tools and controls out of the box; in this case, you only need to draw a chart and then you can pan and zoom in using built-in controls provided by the backend. Using other backends requires full implementation of the user interface, which is great if you want to customize and polish your app to a commercial-grade level but is pretty annoying if you only want to quickly look at some piece of data.</p>
<p>We are going to use the standard <code>matplotlib</code>, so you don’t need to use any special commands in your code.</p>
<h2 id="_idParaDest-134"><a id="_idTextAnchor135"/>Static versus real-time data and related issues</h2>
<p>It is important to note the key difference between visualizing static data and dynamic data. By <strong class="bold">static data</strong>, we mean any data that is read only once, received, calculated, and so on, and is not modified in <a id="_idIndexMarker495"/>real time. Typically, it is used during the research phase when <a id="_idIndexMarker496"/>you develop, test, and optimize your <a id="_idIndexMarker497"/>trading strategy. In this case, we work with <a id="_idIndexMarker498"/>historical data saved on the disk or retrieved via an API from our broker – but in any case, it is not being modified live. This means that both charting libraries work just perfectly without any serious efforts from the developer’s side; once the dataset is formed, it can be plotted with a single command.</p>
<p>However, once we switch to real-time data visualization, we encounter problems because we need to update the chart(s) either periodically or upon an event – for example, upon receipt of a new tick. And here, we can encounter issues related to multithreading. To better understand these issues, let’s do a quick recap.</p>
<p>Do you remember the concept of multithreading that we covered in <a href="B19145_05.xhtml#_idTextAnchor086"><em class="italic">Chapter 5</em></a>, <em class="italic">Retrieving and Handling Market Data with Python</em>? Running several processes in parallel and connecting them using queues makes our trading apps universal, in the sense that we can develop all logic only once and then switch between data sources in order to go from research and development to production.</p>
<p>However, when we <a id="_idIndexMarker499"/>add graphics to our applications, we can <a id="_idIndexMarker500"/>sometimes encounter issues, and these <a id="_idIndexMarker501"/>issues are rooted in the fact that graphics are also running in a separate thread. This thread is controlled by a separate mechanism, not the one that we use to organize data-receiving and processing threads.</p>
<p>Therefore, adding charting in yet another thread to keep it completely separate from the main thread is tricky, to say the least. So, we will sacrifice the universality of our application in favor of keeping the usage of the graphics simple.</p>
<p class="callout-heading">Important note about threads, loops, and process termination</p>
<p class="callout">The problem with multithreading is the termination of a thread. If you start a thread and don’t add any check on whether to keep it running or terminate, then it will run virtually forever. To keep your code correct, you may want to always add an exit condition to any thread and/or the entire program (which is also a thread). However, when using <code>matplotlib</code>, you don’t have explicit control over the thread that renders graphics, so you may want to use callbacks from the operating system. Therefore, despite the risk of being criticized by programming purists, I personally use keyboard termination from inside an IDE to stop the graphics loop – keeping in mind that, in production, we won’t have to do that, as we never include charting in the production code. It’s up to you to choose how you handle this issue, but in my opinion, the simpler, the better.</p>
<p>So, what we <em class="italic">are</em> going to do is to integrate some basic charting as part of the main thread of the main module. It will serve the only purpose of quick visualization without any intent to be used as a universal charting software, and will be disabled or removed before switching from development mode to production.</p>
<p>What we <em class="italic">are not</em> going to do is to write complex code that would provide our app with a sophisticated GUI that would fully imitate commercial applications, such as MetaTrader or MultiCharts.</p>
<p>Enough talk – let’s get coding.</p>
<h2 id="_idParaDest-135"><a id="_idTextAnchor136"/>Installing Matplotlib</h2>
<p>Unless you use a <a id="_idIndexMarker502"/>clean Python installation, chances are that you already have <code>matplotlib</code> installed, so check before trying to install it. Just type <code>import matplotlib</code> in the <a id="_idIndexMarker503"/>console and watch the result.</p>
<p>If you don’t have <code>matplotlib</code> installed, you can use the standard installation:</p>
<pre class="source-code">
python -m pip install -U pip
python -m pip install -U matplotlib</pre>
<p>If you use Conda packages, then you can install <code>matplotlib</code> using the following command:</p>
<pre class="source-code">
conda install matplotlib</pre>
<p>Generally speaking, all major third-party Python distributions such as Anaconda, ActiveState, ActivePython, and WinPython have <code>matplotlib</code> as part of them.</p>
<h2 id="_idParaDest-136"><a id="_idTextAnchor137"/>Using Matplotlib in your code</h2>
<p><code>matplotlib</code> is quite a large <a id="_idIndexMarker504"/>library and we actually need only a <a id="_idIndexMarker505"/>part of it – the very module that does the plotting. As always, I strongly recommend using <code>import</code> rather than <code>from ... import</code> – to keep namespaces separate:</p>
<pre class="source-code">
import matplotlib.pyplot as plt</pre>
<p>This imports the <code>pyplot</code> module that actually creates and handles plots. Let’s create our first plot:</p>
<pre class="source-code">
y = range(10)
plt.plot(y)
plt.show()</pre>
<p>The result will look like the following figure:</p>
<div><div><img alt="Figure 8.1 – A basic ﻿Matplotlib plot" src="img/B19145_8_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1 – A basic Matplotlib plot</p>
<p>Let’s see what actually happened:</p>
<ol>
<li>The graphics <a id="_idIndexMarker506"/>library created a figure – the very <strong class="bold">canvas</strong> on which <a id="_idIndexMarker507"/>all the following charting should be made.</li>
<li>Then, <strong class="bold">axes</strong> were created in the figure – the rectangle box with scales from 0 to 10, in our case.</li>
<li>Then, a graph object was added to the axes – in our case, it’s the diagonal line.</li>
<li>And finally, <code>plt.show()</code> was called – the method that actually displays the chart on screen.</li>
</ol>
<p class="callout-heading">Multithreading: revisited</p>
<p class="callout">When you run this code, you will now see a separate process. This process is created by the <code>plt.show()</code> method and its name is <code>python</code>. Don’t confuse it with the Python interpreter! This new process handles only the figure that is currently being displayed on screen. If you kill it, the <code>matplotlib</code> main loop is terminated and the figure disappears, but other threads will keep running! So, a better idea is to stop the execution of your code from the IDE, to kill all threads along with this <code>python</code> process.</p>
<p>As you can see, we had 10 elements in the <code>y</code> list, and the horizontal axis is graduated accordingly, 0 to 10. It’s clear that the current plot displays the <code>y = x</code> linear function, where arguments <a id="_idIndexMarker508"/>are integer numbers. However, what if we wanted <a id="_idIndexMarker509"/>to calculate the same function for fractional arguments – say, the same 10 points, but taken between 0 and 1, not 0 and 10?</p>
<p>Let’s give it a try:</p>
<ol>
<li value="1">First, as always, we import <code>pyplot</code>:<pre class="source-code">
import matplotlib.pyplot as plt</pre></li>
<li>Then, we import <code>numpy</code> – the universal mathematical library for Python that adds support for vectors and matrices, along with myriads of math functions. We’re going to use <code>arange</code>, which is somewhat similar to the native Python range but supports fractional steps:<pre class="source-code">
import numpy as np</pre></li>
<li>Next, we form the range to display:<pre class="source-code">
y = np.arange(0, 1, 0.1)</pre></li>
<li>The rest of the code is unchanged – just creating a plot and displaying it on screen:<pre class="source-code">
plt.plot(y)</pre><pre class="source-code">
plt.show()</pre></li>
</ol>
<p>Then, you should see a figure similar to the following:</p>
<div><div><img alt="Figure 8.2 – The plot of the linear function in the range between 0 and 1 – the incorrect X-axis scale" src="img/B19145_8_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.2 – The plot of the linear function in the range between 0 and 1 – the incorrect X-axis scale</p>
<p>But wait! There’s something wrong with our chart. Yes, the <em class="italic">Y</em> axis has now graduated from 0 to 1 with a step of 0.1, but the <em class="italic">X</em> axis has still graduated from 0 to 10. This <a id="_idIndexMarker510"/>happened because we plotted the new array but did <a id="_idIndexMarker511"/>nothing to tell the <code>plt.plot()</code> method about the new scale by the <em class="italic">X</em> axis – and by default, this method assumes that we plot any array versus indices of its elements, which is always an array of integers.</p>
<ol>
<li value="5">Let’s fix this mistake by adding the correct <code>X</code>-axis data:<pre class="source-code">
x = np.arange(0, 1, 0.1)</pre></li>
</ol>
<p>Let’s also modify the call of the <code>plot()</code> method:</p>
<pre class="source-code">
plt.plot(x, y)</pre>
<p>Now, we will see the correct plot, shown in the following figure:</p>
<div><div><img alt="Figure 8.3 – The plot of the linear function in the range between 0 and 1 – now the correct X-axis scale" src="img/B19145_8_03.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.3 – The plot of the linear function in the range between 0 and 1 – now the correct X-axis scale</p>
<p>Now that we know a bit <a id="_idIndexMarker512"/>about how the <code>plot()</code> method <a id="_idIndexMarker513"/>works, let’s plot some actual market data.</p>
<h1 id="_idParaDest-137"><a id="_idTextAnchor138"/>Simple plots of market data</h1>
<p>In the following <a id="_idIndexMarker514"/>examples, we will use historical data only. We will learn how to plot live data received from a broker later in this chapter.</p>
<p>There are many ways to read and handle market data, some of which were considered in <a href="B19145_05.xhtml#_idTextAnchor086"><em class="italic">Chapter 5</em></a>, <em class="italic">Retrieving and Handling Market Data with Python</em>. Now, we are going to learn some alternative approaches so that you can best choose what suits your current research and development needs.</p>
<p>Let’s start with the most straightforward approach, which uses only native Python data structures. As we saw in <a href="B19145_05.xhtml#_idTextAnchor086"><em class="italic">Chapter 5</em></a>, the preferred way of storing and manipulating market data is a dictionary because of its full compatibility with the JSON standard and the ability to extract the necessary data by keywords. We will start with dictionaries as well:</p>
<ol>
<li value="1">First, we still need to do some imports:<pre class="source-code">
import matplotlib.pyplot as plt</pre><pre class="source-code">
import csv</pre></li>
</ol>
<p>The <code>csv</code> module <a id="_idIndexMarker515"/>contains very convenient methods to read and parse <strong class="bold">comma-separated value</strong> (<strong class="bold">CSV</strong>) files, which is the de facto standard for storing historical market data.</p>
<ol>
<li value="2">Now, let’s open a data file and create a <code>DictReader()</code> object:<pre class="source-code">
f = open("/Volumes/Storage HDD/Data/LMAX EUR_USD 1 Minute.txt")</pre><pre class="source-code">
csvFile = csv.DictReader(f)</pre></li>
</ol>
<p>The <code>DictReader()</code> method parses the CSV file into a dictionary or set of dictionaries and returns a <code>DictReader</code> object. It uses the first line of the file as the source for keywords, so make sure you have it in your source data. In the sample file I’m using, the header (the first line) looks like the following:</p>
<pre class="source-code">
Date,Time,Open,High,Low,Close,UpVolume,DownVolume,
TotalVolume,UpTicks,DownTicks,TotalTicks</pre>
<p>So, these are the very keywords that will appear in the dictionaries when I have read the file and parsed it with <code>DictReader()</code>.</p>
<ol>
<li value="3">Now, we need to convert this object into a list:<pre class="source-code">
all_data = list(csvFile)</pre></li>
</ol>
<p>If we now look at the last three elements in the list by entering <code>print(all_data[-3:])</code>, we will see something like the following:</p>
<pre class="source-code">
[{'Date': '11/12/2020', 'Time': '17:45:00', 'Open': '1.18136', 'High': '1.18143', 'Low': '1.18125', 'Close': '1.18140', 'UpVolume': '249', 'DownVolume': '494', 'TotalVolume': '743', 'UpTicks': '7', 'DownTicks': '5', 'TotalTicks': '12'}, {'Date': '11/12/2020', 'Time': '17:46:00', 'Open': '1.18140', 'High': '1.18156', 'Low': '1.18138', 'Close': '1.18154', 'UpVolume': '399', 'DownVolume': '299', 'TotalVolume': '698', 'UpTicks': '8', 'DownTicks': '4', 'TotalTicks': '12'}, {'Date': '11/12/2020', 'Time': '17:47:00', 'Open': '1.18154', 'High': '1.18156', 'Low': '1.18145', 'Close': '1.18155', 'UpVolume': '500', 'DownVolume': '650', 'TotalVolume': '1150', 'UpTicks': '5', 'DownTicks': '6', 'TotalTicks': '11'}]</pre>
<p>So, we indeed now have 1-minute data in the form of OHLC bars, along with some information <a id="_idIndexMarker516"/>about the volume and the number of ticks per interval (1 minute). Each bar is represented by a separate dictionary, and dictionaries are collected in a list.</p>
<ol>
<li value="4">Now, we need to extract only the data we want to plot – say, closing prices. In order to avoid possible issues by plotting too much data, let’s plot just the last 100 data points. There are many ways to do this; we will use list comprehensions:<pre class="source-code">
close = [float(bar['Close']) for bar in all_data[-100:]]</pre></li>
</ol>
<p>The rest of the code is the same:</p>
<pre class="source-code">
plt.plot(close)
plt.show()</pre>
<p>If you did everything correctly, you should see a chart similar to the one shown in the following screenshot:</p>
<div><div><img alt="Figure 8.4 – A simple line chart of closing prices" src="img/B19145_8_04.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.4 – A simple line chart of closing prices</p>
<ol>
<li value="5">Great, but what about the <em class="italic">X</em>-axis labels? Oh, it again just counts the data points, 0 to 100, but we <a id="_idIndexMarker517"/>want to see something more meaningful here. Let’s recall that the <code>plot()</code> method actually plots one iterable versus another, so we’ll create labels from the timestamps:<pre class="source-code">
time = [bar['Time'] for bar in all_data[-100:]]</pre><pre class="source-code">
plt.plot(time, close)</pre></li>
</ol>
<p>Now, we can see that the numbers along the <em class="italic">X</em> axis were indeed replaced with something, but this something is really hard to read and understand:</p>
<div><div><img alt="Figure 8.5 – Using timestamps as X-axis labels without proper formatting gets erratic results" src="img/B19145_8_05.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.5 – Using timestamps as X-axis labels without proper formatting gets erratic results</p>
<p>Unsurprisingly, the labels (the timestamps) are rather long, there are too many of them, and they <a id="_idIndexMarker518"/>are displayed one over another, making the result unusable. So, we want to format them somehow, printing labels only every 10, 20, or 100 ticks and rotating them to save screen space.</p>
<p>In order to do that, we should recall the sequence of events that is triggered by the call to the <code>plot()</code> method, which is explained in the <em class="italic">Using matplotlib in your code</em> section in this chapter. First, a <em class="italic">figure</em> (a blank canvas) is created, an <em class="italic">axis</em> (rectangle box with axes) is added, and then the actual <em class="italic">plot</em> is drawn. All three objects were created automatically by a single call to the <code>plot()</code> method. However, in order to be able to modify the visual representation of the plot, we need to get access to the <code>axes</code> object directly. We now want to rewrite the entire code responsible for plotting in order to separate the three aforementioned objects.</p>
<ol>
<li value="6">So, after we formed the <code>time</code> list and before the <code>plot()</code> call, we add the following:<pre class="source-code">
fig = plt.figure()</pre></li>
<li>This creates a new empty figure object and returns a handle to the <code>fig</code> variable. Then, we add the following:<pre class="source-code">
ax = fig.add_subplot()</pre></li>
<li>This one <a id="_idIndexMarker519"/>creates a new subplot, or axis – the very rectangle that we want to customize. Great – now we can access it using the <code>ax</code> variable. So, let’s limit the number of tick labels printed along the <em class="italic">X</em> axis:<pre class="source-code">
ax.set_xticks(np.arange(0, len(time) + 1, 15))</pre></li>
</ol>
<p>The <code>set_xticks()</code> method uses only one argument here – an iterable that specifies indices of only those elements in the <code>time</code> list that we want to plot. In our example, we use a <code>numpy</code> <code>arange</code> that contains integer numbers with a step of 15 to plot every 15th timestamp.</p>
<ol>
<li value="9">Finally, to make our plot even more readable, let’s turn the labels by 45° and plot the result:<pre class="source-code">
plt.xticks(rotation=45)</pre><pre class="source-code">
plt.plot(time, close)</pre><pre class="source-code">
plt.show()</pre></li>
</ol>
<p>If you did everything correctly, you should see a chart like the following:</p>
<div><div><img alt="Figure 8.6 – A slightly better-looking simple price chart" src="img/B19145_8_06.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.6 – A slightly better-looking simple price chart</p>
<p>So far, we have plotted charts only for the last 100 data points, but what if we want to plot the <a id="_idIndexMarker520"/>market data of a certain day in the past?</p>
<ol>
<li value="10">Let’s rewrite the entire code now to keep everything that we’ve learned so far together:<pre class="source-code">
import csv</pre><pre class="source-code">
import matplotlib.pyplot as plt</pre><pre class="source-code">
import numpy as np</pre><pre class="source-code">
f = open("/Volumes/Storage HDD/Data/LMAX EUR_USD 1 Minute.txt")</pre><pre class="source-code">
csvFile = csv.DictReader(f)</pre><pre class="source-code">
all_data = list(csvFile)</pre></li>
</ol>
<p>So far, there’s no difference; we just import the necessary modules and read the data file. Now, we <a id="_idIndexMarker521"/>want to plot 100 bars, starting from midnight of December 12, 2019. So, we find the position of the dictionary with the relevant value of the <code>Date</code> keyword in the <code>all_data</code> list of dictionaries:</p>
<pre class="source-code">
starting_bar_number = 0
for bar in all_data:
    if bar['Date'] == '12/12/2019':
        break
    starting_bar_number += 1</pre>
<ol>
<li value="11">Then, we extract the required data for plotting:<pre class="source-code">
close = [float(bar['Close']) for bar in all_data[starting_bar_number:starting_bar_number + 100]]</pre><pre class="source-code">
time = [bar['Time'] for bar in all_data[starting_bar_number:starting_bar_number + 100]]</pre></li>
</ol>
<p>Then, we actually plot using some nice formatting:</p>
<pre class="source-code">
fig = plt.figure()
ax = fig.add_subplot()
ax.set_xticks(np.arange(0, len(time) + 1, 15))
plt.xticks(rotation=45)
plt.plot(time, close)
plt.show()</pre>
<p>That’s it! Now, we can enjoy our chart:</p>
<div><div><img alt="Figure 8.7 – A simple price chart of data from a specified date and time" src="img/B19145_8_07.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.7 – A simple price chart of data from a specified date and time</p>
<p>Here, we omit all the <a id="_idIndexMarker522"/>capabilities of <code>matplotlib</code>, including the formatting of titles, using colors, multiple subplots, and much more – at the end of the day, this book is not a <code>matplotlib</code> tutorial. If you’re interested in learning more <a id="_idIndexMarker523"/>about this reliable charting package, I’d recommend starting with its official website (<a href="https://matplotlib.org">https://matplotlib.org</a>), where you’ll find a lot of examples, tutorials, and general documentation.</p>
<p>Alright, now we know how to plot basic price charts – simple line charts of closing (or any other) prices versus timestamps. However, we all know that the most common format for charting in the financial world is a bar chart or candlestick chart. How do we plot such a chart with <code>matplotlib</code>?</p>
<p>Well, a few years ago, <code>matplotlib</code> itself used to have a <code>finance</code> module that supported the charts in question. However, now it’s deprecated. So, we have only two options – either <a id="_idIndexMarker524"/>building financial charts bar by bar using matplotlib’s <code>bar()</code> method or opting for a relatively new but advanced package, <code>mplfinance</code>. This package offers very simplistic and straightforward methods to plot price charts, but it won’t plot data stored in native Python structures, such as lists or dictionaries. Instead, it uses <strong class="bold">pandas</strong> to handle market data.</p>
<p>So, what is pandas and how can we use it?</p>
<h1 id="_idParaDest-138"><a id="_idTextAnchor139"/>Visualizing static market data with pandas</h1>
<p>pandas is <em class="italic">“a fast, powerful, flexible, and easy to use open source data analysis and manipulation tool, built on top of the Python programming language”</em>, as declared on its <a id="_idIndexMarker525"/>official web page at <a href="https://pandas.pydata.org">https://pandas.pydata.org</a>. It was originally <a id="_idIndexMarker526"/>developed exactly for the purpose of <a id="_idIndexMarker527"/>manipulating time series data, especially market prices.</p>
<p>Instead of native Python lists or NumPy arrays, pandas uses <strong class="bold">DataFrames</strong> as a core data object. You can think of <a id="_idIndexMarker528"/>a DataFrame as a table, where columns represent various named time series (or any other series) and rows contain actual data, with the first row always containing the names of the series. Pretty much the same as with the historical market data file that we’ve used so far? Yes, and this makes the learning curve with pandas really steep.</p>
<p>pandas offers methods to add, delete, and rearrange columns, create and modify indices, slice and <a id="_idIndexMarker529"/>create subsets, merge and <a id="_idIndexMarker530"/>reshape DataFrames, and even handle missing data.</p>
<p class="callout-heading">Note</p>
<p class="callout">pandas is quite a comprehensive package that offers various methods to handle data to suit very different <a id="_idIndexMarker531"/>needs. This book is in no way a pandas tutorial; we are going to use only those methods that are required to accomplish the task of plotting market data. If you are interested in learning more about pandas, I’d recommend starting with a simple tutorial at <a href="https://www.w3schools.com/python/pandas/default.asp">https://www.w3schools.com/python/pandas/default.asp</a>.</p>
<h2 id="_idParaDest-139"><a id="_idTextAnchor140"/>Installing pandas</h2>
<p>The official pandas website <a id="_idIndexMarker532"/>recommends installing Anaconda, which comes with pandas on board, and refers to other installation methods as <em class="italic">advanced</em>. However, there’s nothing really advanced about them. You can use the standard PyPI installation:</p>
<pre class="source-code">
pip install pandas</pre>
<p>Alternatively, you can use Conda:</p>
<pre class="source-code">
conda install pandas</pre>
<h2 id="_idParaDest-140"><a id="_idTextAnchor141"/>Reading data from CSV files with pandas</h2>
<p>pandas offers a <a id="_idIndexMarker533"/>straightforward method to read data <a id="_idIndexMarker534"/>from a CSV file. Let’s try the following <a id="_idIndexMarker535"/>code:</p>
<pre class="source-code">
import mplfinance as mpf # this is for future use with charting
import pandas
file_name = "/Volumes/Storage HDD/Data/LMAX EUR_USD 1 Minute.txt"
source_data = pandas.read_csv(file_name)
print(source_data)</pre>
<p>Of course, as always, you want to replace the value of <code>file_name</code> with the actual path to the locally stored historical data CSV file.</p>
<p>If you did everything correctly, you will see output like the following:</p>
<pre class="source-code">
               Date      Time     Open  ...  UpTicks  DownTicks  
TotalTicks
0         1/27/2015  13:29:00  1.12942  ...        3          2
           8
1         1/27/2015  13:30:00  1.12947  ...        4          7
          12
2         1/27/2015  13:31:00  1.12953  ...        9          4
          14
3         1/27/2015  13:32:00  1.12944  ...        2         10
          13
4         1/27/2015  13:33:00  1.12876  ...        5          4
          12
...             ...       ...      ...  ...      ...        ...
         ...
2136274  11/12/2020  17:43:00  1.18134  ...        4          7
          11
2136275  11/12/2020  17:44:00  1.18124  ...        7          4
          11
2136276  11/12/2020  17:45:00  1.18136  ...        7          5
          12
2136277  11/12/2020  17:46:00  1.18140  ...        8          4
          12
2136278  11/12/2020  17:47:00  1.18154  ...        5          6
          11
[2136279 rows x 12 columns]</pre>
<p>You can see that <a id="_idIndexMarker536"/>the first row was used to create <a id="_idIndexMarker537"/>column names <a id="_idIndexMarker538"/>and the rest formed the actual data.</p>
<p>Note that in front of the data read from the file, there’s an additional column without a name, and it <a id="_idIndexMarker539"/>contains just integer numbers from 0 to 2,136,278 (in the example with my file). This is the <strong class="bold">DataFrame index</strong>. We can retrieve any specific records by referring to them using these <a id="_idIndexMarker540"/>numbers – again, pretty much as we <a id="_idIndexMarker541"/>would do if we <a id="_idIndexMarker542"/>used lists. Of course, it’s very inconvenient, as we want to be able to retrieve any piece of historical data by referring to a particular date or time range. Fortunately, pandas offers a way to build a custom index for a DataFrame, so let’s continue with our code.</p>
<h2 id="_idParaDest-141"><a id="_idTextAnchor142"/>Setting index for a dataframe</h2>
<p>First, let’s form <a id="_idIndexMarker543"/>the timestamps from the <code>date</code> and <code>time</code> fields:</p>
<pre class="source-code">
source_data['Timestamp'] = pandas.to_datetime(source_data['Date']) + pandas.to_timedelta(source_data['Time'])</pre>
<p>Here, we use built-in methods, <code>to_datetime()</code> and <code>to_timedelta()</code>, which convert string values into a single <code>Timestamp</code> object.</p>
<p class="callout-heading">Referencing columns in pandas</p>
<p class="callout">In the preceding code, you can see how pandas allows you to reference a certain column by its name. This is very similar to finding values by keywords in a dictionary, but in pandas, the entire column is returned, not a scalar value.</p>
<p>Assignment to a column with a non-existent name (<code>Timestamp</code>, in our case) effectively creates a new column with this name.</p>
<p>Having created the new column, let’s set it as the index:</p>
<pre class="source-code">
source_data.set_index(source_data['Timestamp'], inplace=True)</pre>
<p>If we now check the contents of <code>source_data</code>, we will see that the new index was generated and added to the DataFrame:</p>
<pre class="source-code">
                           Date      Time  ...  TotalTicks
           Timestamp
Timestamp                                  ...
2015-01-27 13:29:00   1/27/2015  13:29:00  ...           8 2015-01-27 13:29:00
2015-01-27 13:30:00   1/27/2015  13:30:00  ...          12 2015-01-27 13:30:00
2015-01-27 13:31:00   1/27/2015  13:31:00  ...          14 2015-01-27 13:31:00
2015-01-27 13:32:00   1/27/2015  13:32:00  ...          13 2015-01-27 13:32:00
2015-01-27 13:33:00   1/27/2015  13:33:00  ...          12 2015-01-27 13:33:00
...                         ...       ...  ...         ...
                 ...
2020-11-12 17:43:00  11/12/2020  17:43:00  ...          11 2020-11-12 17:43:00
2020-11-12 17:44:00  11/12/2020  17:44:00  ...          11 2020-11-12 17:44:00
2020-11-12 17:45:00  11/12/2020  17:45:00  ...          12 2020-11-12 17:45:00
2020-11-12 17:46:00  11/12/2020  17:46:00  ...          12 2020-11-12 17:46:00
2020-11-12 17:47:00  11/12/2020  17:47:00  ...          11 2020-11-12 17:47:00
[2136279 rows x 13 columns]</pre>
<p>Great! Now we <a id="_idIndexMarker544"/>have indexed all our data points (minute bars) by timestamps. Let’s now create a simple bar chart for the same 1-minute historical data that we used earlier.</p>
<h2 id="_idParaDest-142"><a id="_idTextAnchor143"/>Creating simple bar charts using pandas and mplfinance</h2>
<p>Of course, we don’t want to plot all data in one chart. The data file I’m using in this chapter <a id="_idIndexMarker545"/>contains about 5 years’ worth of 1-minute bars, or <a id="_idIndexMarker546"/>more than 2 million records, so creating <a id="_idIndexMarker547"/>a chart with more than 2 million bars in it <a id="_idIndexMarker548"/>would simply freeze rendering forever. Let’s create a chart for just a piece of history, specifying the date, the starting, and the ending time:</p>
<pre class="source-code">
sample_date = '23-03-2020'
start_time = '00:01:00'
day_close_time = '23:00:00'</pre>
<p>The data in my file is in the GMT+1 time zone, so 23:00 here equals 17:00 in New York time, which is the bank settlement time for the FX market (see the <em class="italic">Trading the FX market – what and how</em> section in <a href="B19145_03.xhtml#_idTextAnchor044"><em class="italic">Chapter 3</em></a>, <em class="italic">FX Market Overview from a Developer’s Standpoint</em>). Also, note that the first timestamp for the day (the <code>start_time</code> variable) is 1 minute past midnight; for bars, timestamps mean the time of the last tick or the closing price of the interval (see the <em class="italic">Universal data connector</em> section in <a href="B19145_05.xhtml#_idTextAnchor086"><em class="italic">Chapter 5</em></a>, <em class="italic">Retrieving and Handling Market Data with Python</em>, for a detailed explanation of data compression and timestamps).</p>
<h2 id="_idParaDest-143"><a id="_idTextAnchor144"/>Making slices and subsets in pandas</h2>
<p>The most heavily <a id="_idIndexMarker549"/>used method to extract a subset from a DataFrame is <code>.loc()</code>. Its <a id="_idIndexMarker550"/>usage is again very intuitive, as it’s <a id="_idIndexMarker551"/>very similar to making slices of native Python lists; you <a id="_idIndexMarker552"/>only need to specify the start and end indexes for the new sub-DataFrame, as shown in this pseudocode:</p>
<pre class="source-code">
sub_dataframe = original_dataframe[start : end]</pre>
<p>In our actual code, it will look like the following:</p>
<pre class="source-code">
all_day_sample = source_data.loc[sample_date + " " + start_time: sample_date + " " + day_close_time]</pre>
<p>Finally, we want to strip away all unnecessary data and keep only <code>Open</code>, <code>High</code>, <code>Low</code>, and <code>Close</code>. Again, with pandas, it can be done in the same straightforward way by just specifying the columns to retain in a list – and the rest will be thrown away:</p>
<pre class="source-code">
OHLC_data = all_day_sample[['Open', 'High', 'Low', 'Close']]</pre>
<p>Note the double <a id="_idIndexMarker553"/>brackets; the outer pair means that we create <a id="_idIndexMarker554"/>a sub-DataFrame based on the specified set of columns, and <a id="_idIndexMarker555"/>the inner pair actually specifies the columns <a id="_idIndexMarker556"/>in a list. That’s all done – now, it’s time to create our first bar chart.</p>
<h2 id="_idParaDest-144"><a id="_idTextAnchor145"/>Plotting market charts with mplfinance</h2>
<p>All charts <a id="_idIndexMarker557"/>created by <code>mplfinance</code> are, by default, bar charts, so let’s start with the most simplistic one:</p>
<pre class="source-code">
mpf.plot(OHLC_data)</pre>
<p>If you did everything correctly, you should see a figure like the following:</p>
<div><div><img alt="Figure 8.8 – A default bar chart plotted with mplfinance" src="img/B19145_8_08.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.8 – A default bar chart plotted with mplfinance</p>
<p>At first glance, it looks like the same line chart, but this is because we have a few too many bars on a relatively small canvas. Here, we can benefit from the fact that the <code>TkAgg</code> backend used by default in <code>matplotlib</code> (and <code>mplfinance</code> is built on top of <code>matplotlib</code>) is interactive; you can click the magnifying glass icon and zoom in to any part of the chart – say, the spike in the middle of the day:</p>
<div><div><img alt="Figure 8.9 – Using the interactivity of the TkAgg backend to zoom in and out" src="img/B19145_8_09.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.9 – Using the interactivity of the TkAgg backend to zoom in and out</p>
<p>There are <a id="_idIndexMarker558"/>several options to customize the <code>mplfinance</code> charts. For example, we can plot a candlestick chart instead of a bar chart and even add a number of moving averages to it:</p>
<pre class="source-code">
mpf.plot(OHLC_data, type = 'candle', mav = (20, 50, 200))</pre>
<p>Here, <code>mav</code> means <strong class="bold">moving averages</strong>, and their periods are specified in a tuple. The result is <a id="_idIndexMarker559"/>shown in the following figure:</p>
<div><div><img alt="Figure 8.10 – A candlestick chart with moving averages plotted with mplfinance" src="img/B19145_8_10.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.10 – A candlestick chart with moving averages plotted with mplfinance</p>
<p>Now, we can use both Matplotlib’s <code>pyplot</code> and <code>mplfinance</code> to create price charts in the form of simple <a id="_idIndexMarker560"/>line charts or nice-looking bar or candlestick charts. However, so far, we have worked only with saved data that is static and not updated in real time. But what do we do with data being received live from a broker or a data vendor? Let’s see how we can solve this problem using the universal data connector approach.</p>
<h1 id="_idParaDest-145"><a id="_idTextAnchor146"/>Visualizing live market data</h1>
<p>Before we move on, I strongly <a id="_idIndexMarker561"/>recommend you reread the <em class="italic">Working with saved and live data – keep your app universal</em> section in <a href="B19145_05.xhtml#_idTextAnchor086"><em class="italic">Chapter 5</em></a>, <em class="italic">Retrieving and Handling Market Data with Python</em>, and the <em class="italic">Sliding windows</em> section in <a href="B19145_07.xhtml#_idTextAnchor114"><em class="italic">Chapter 7</em></a>, <em class="italic">Technical Analysis and Its Implementation in Python</em>. We are going to use the same architecture to create live plots of market data.</p>
<p class="callout-heading">Important reminder</p>
<p class="callout">Whatever data we receive from a live data source should go into a queue. This should be done in a separate thread. Then, data is read from the queue into a sliding window that controls the actual amount of data – for any processing or plotting.</p>
<p>When we worked with static historical data, we used very convenient methods that allowed us to <a id="_idIndexMarker562"/>read an entire dataset into memory in one line of code and then navigate through it. Of course, any convenience is always paid for, and in this case, the fee is running the risk of peeking ahead (see the <em class="italic">Trading logic – this is where a small mistake may cost a fortune</em> section in <a href="B19145_04.xhtml#_idTextAnchor073"><em class="italic">Chapter 4</em></a>, <em class="italic">Trading Application – What’s Inside?</em>), which was efficiently solved in <a href="B19145_07.xhtml#_idTextAnchor114"><em class="italic">Chapter 7</em></a> by using sliding windows and threading and feeding data points into them one by one, regardless of whether they were saved locally or being received from the broker.</p>
<p>So, in other words, what we were doing so far in this chapter is convenient, but it contradicts the idea of building a universal trading application suitable for both research and live trading.</p>
<p>Why, therefore, did we do all that, you may ask?</p>
<p>There are two reasons.</p>
<p>First, don’t forget that we use charts only to <em class="italic">either</em> visually confirm an idea during the research phase <em class="italic">or</em> to check the consistency of live ordering in production. When we work on the development of a trading idea, it is infinitely more convenient to be able to immediately visualize a certain piece of historical data, especially if you work in an interactive environment such as IPython. That’s where using pandas with <code>mplfinance</code> may be the right choice.</p>
<p>Second, visualization is used not only to plot market data but also (and probably even more intensively) to plot the results of a backtest, running simulated trades over historical data. And since a backtest is by definition something <em class="italic">carved in stone</em> – that is, not updated live – then using the approaches that we considered earlier in this chapter will serve our purpose just fine.</p>
<p>All in all, we <a id="_idIndexMarker563"/>want to visualize live market data in order to check its correctness, see various indicators, and/or track the order execution. Let’s see how it’s done.</p>
<h2 id="_idParaDest-146"><a id="_idTextAnchor147"/>Plotting live tick data</h2>
<p>As always, we <a id="_idIndexMarker564"/>start with several imports:</p>
<pre class="source-code">
import json
import threading
import queue
import matplotlib.pyplot as plt</pre>
<p>The <code>json</code> module will help us parse the response from the data server; we are already familiar with the other modules</p>
<p>Then, we import a method to establish WebSocket connections from the <code>websocket</code> library:</p>
<pre class="source-code">
from websocket import create_connection</pre>
<p>Next, we create a class that implements the sliding window (see the <em class="italic">Sliding windows</em> section in <a href="B19145_06.xhtml#_idTextAnchor101"><em class="italic">Chapter 6</em></a>, <em class="italic">Basics of Fundamental Analysis and Its Possible Use in </em><em class="italic">FX Trading</em>):</p>
<pre class="source-code">
class sliding_window:
    def __init__(self, length):
        self.data = ([0]*length)
    def add(self, element):
        self.data.append(element)
        self.data.pop(0)</pre>
<p>Then, we add a function that creates and maintains the WebSocket connection with the market data server. This function has three arguments:</p>
<ul>
<li>The URL to connect</li>
<li>The message we send to the server to subscribe to market data</li>
<li>The queue in which we place incoming ticks</li>
</ul>
<p>You can also implement the function as a class method if you plan to build a complex application with multiple connections:</p>
<pre class="source-code">
def LMAX_connect(url, subscription_msg, ticks_queue):</pre>
<p>Create the connection:</p>
<pre class="source-code">
    ws = create_connection(url)</pre>
<p>Then, send <a id="_idIndexMarker565"/>the subscription message, which we will specify later, outside the function code (if you implement the function as a <code>class</code> method, you may want to pass the subscription message as a parameter or have it as a <code>class</code> attribute):</p>
<pre class="source-code">
    ws.send(subscription_msg)</pre>
<p>Upon successful subscription, the function awaits incoming ticks and places them into a queue:</p>
<pre class="source-code">
    while True:
        tick = json.loads(ws.recv())
        ticks_queue.put(tick)
        print(tick)</pre>
<p>The <code>print(tick)</code> statement is added only for debugging purposes. All preparations are done, so now, let’s proceed:</p>
<pre class="source-code">
url = "wss://public-data-api.london-demo.lmax.com/v1/web-socket"
subscription_msg = '{"type": "SUBSCRIBE","channels": [{"name": "ORDER_BOOK","instruments": ["eur-usd"]}]}'</pre>
<p>Here, we specify the server to connect to and the message we will send to subscribe to market data. Please refer to <a href="B19145_05.xhtml#_idTextAnchor086"><em class="italic">Chapter 5</em></a>, <em class="italic">Retrieving and Handling Market Data with Python</em>, for a detailed description of the LMAX data structure and the <em class="italic">Retrieving data – garbage in – garbage out</em> section in <a href="B19145_04.xhtml#_idTextAnchor073"><em class="italic">Chapter 4</em></a>, <em class="italic">Trading Application – What’s Inside?</em>, to refresh your memory on important issues regarding receiving and processing data.</p>
<p>Next, we’ll create the queue to store the incoming ticks:</p>
<pre class="source-code">
pipe = queue.Queue()</pre>
<p>We will also create a thread to retrieve data:</p>
<pre class="source-code">
data_receiver_thread = threading.Thread(target = LMAX_connect, args = (url, subscription_msg, pipe))
data_receiver_thread.start()</pre>
<p>If you did <a id="_idIndexMarker566"/>everything correctly and ran the code, you will see the order book data coming from the WebSocket:</p>
<pre class="source-code">
{'type': 'ORDER_BOOK', 'instrument_id': 'eur-usd', 'timestamp': '2022-10-28T09:12:26.000Z', 'status': 'OPEN', 'bids': [{'price': '0.995350', 'quantity': '1000000.0000'}, {'price': '0.995340', 'quantity': '2000000.0000'}, {'price': '0.995330', 'quantity': '500000.0000'}, {'price': '0.995320', 'quantity': '500000.0000'}, {'price': '0.995310', 'quantity': '1500000.0000'}, {'price': '0.987800', 'quantity': '1000000.0000'}, {'price': '0.985000', 'quantity': '13000000.0000'}, {'price': '0.980000', 'quantity': '13000000.0000'}], 'asks': [{'price': '0.995410', 'quantity': '500000.0000'}, {'price': '0.995420', 'quantity': '1000000.0000'}, {'price': '0.995430', 'quantity': '1500000.0000'}, {'price': '0.995440', 'quantity': '2000000.0000'}, {'price': '0.995450', 'quantity': '3000000.0000'}, {'price': '0.995810', 'quantity': '410000.0000'}]}</pre>
<p>We want to plot only the top of the book – that is, the current best bid and best ask – so let’s add another function that will parse incoming ticks and send <code>bid</code> and <code>ask</code> values to the respective sliding windows. We implement this function without arguments because it shares data structures (bid and ask sliding windows) with the charting part of the code:</p>
<pre class="source-code">
def get_ticks(ticks_queue):
    while True:
        tick = ticks_queue.get()
        if 'bids' in tick.keys():
            bid = float(tick['bids'][0]['price'])
            ask = float(tick['asks'][0]['price'])
            bids.add(bid)
            asks.add(ask)
            print(bid, ask)</pre>
<p>This function gets ticks from the queue, extracts bids and asks, and sends them to the respective sliding <a id="_idIndexMarker567"/>windows (<code>bids</code> and <code>asks</code>). Let’s create them – first, we specify the length of the sliding window (let’s set it to 60, which will display about 1 minute’s worth of data, given that LMAX sends an update at a rate of about 1 tick per second):</p>
<pre class="source-code">
window_size = 60</pre>
<p>Then, add two windows, for <code>bids</code> and <code>asks</code> respectively:</p>
<pre class="source-code">
bids = sliding_window(window_size)
asks = sliding_window(window_size)</pre>
<p>Now, we wrap the processing function into a thread:</p>
<pre class="source-code">
trading_algo_thread = threading.Thread(target = get_ticks, args = (pipe,))
trading_algo_thread.start()</pre>
<p>If we now run the code we have developed so far, we will see pairs of bids and asks updated about every 1 second:</p>
<pre class="source-code">
0.99626 0.99631
0.99626 0.99629
0.99624 0.9963
0.99624 0.9963
0.99624 0.99629</pre>
<p>Great job! Now, we want to plot this live data in a chart.</p>
<p>At this point, the most natural course of action would be to create the third thread and do all the plotting <a id="_idIndexMarker568"/>inside it, to keep all three processes (retrieving data, processing, and plotting) separate from each other and the main thread.</p>
<p>Alas, with <code>matplotlib</code> (and many other charting suites), to do this is very complex (although not impossible). So, unfortunately, we have to live with the fact that charting is (easily) available only in the main thread.</p>
<p>First, let’s wait till the entire data in the sliding windows is filled with meaningful values:</p>
<pre class="source-code">
while bids.data[0] == 0:
    pass</pre>
<p>Then, we create the figure and the axes separately (as we did earlier in this chapter when we customized the axis labels):</p>
<pre class="source-code">
fig = plt.figure()
ax = fig.add_subplot()</pre>
<p>Next, we add two lines for our two data series (the bids and asks):</p>
<pre class="source-code">
line1, = ax.plot(bids.data)
line2, = ax.plot(asks.data)</pre>
<p>Finally, we start <a id="_idIndexMarker569"/>the main charting loop, which will draw the lines and refresh the figure once every second:</p>
<pre class="source-code">
while True:
    line1.set_ydata(bids.data)
    line2.set_ydata(asks.data)</pre>
<p>The following command adds small margins above and below the plots, just to improve the visual perception:</p>
<pre class="source-code">
    plt.ylim(min(bids.data) - 0.0001, max(asks.data) + 0.0001)</pre>
<p>Then, we actually plot the chart:</p>
<pre class="source-code">
    fig.canvas.draw()</pre>
<p>We then wait for 1 second for the graphics to be rendered and appear on screen; otherwise, the loop blocks the rendering we don’t let it run during this pause:</p>
<pre class="source-code">
    plt.pause(1)</pre>
<p>So simple! If you did everything correctly, you should see a figure similar to the following one <a id="_idIndexMarker570"/>updating every second:</p>
<p class="callout-heading">Note</p>
<p class="callout">It takes time to fill the entire sliding window. In our example, it will be about 60 seconds before the figure appears.</p>
<div><div><img alt="Figure 8.11 – A simple live price tick chart showing both bid and ask" src="img/B19145_8_11.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.11 – A simple live price tick chart showing both bid and ask</p>
<p>Well, now we can draw live charts of market prices, and it has turned out to be quite simple and straightforward – but only in form of lines for every tick. What if we want to aggregate data and then plot a bar or candlestick chart? Let’s find the solution in the next section.</p>
<h2 id="_idParaDest-147"><a id="_idTextAnchor148"/>Plotting live bar or candlestick charts</h2>
<p>Earlier in this chapter, we worked with bar and candlestick charts, and we know that the most streamlined way <a id="_idIndexMarker571"/>of doing that is by using the <code>mplfinance</code> library. The idea <a id="_idIndexMarker572"/>is to use the <code>mplfinance.plot()</code> method in a loop and update, similar to how we just did for line plots of tick data. So, what we want to do now is add a new function that would split the incoming tick data stream into bars according to a certain rule, adds the formed bars to a DataFrame, and sends the resulting DataFrame to the charting loop:</p>
<ol>
<li value="1">Let’s start with imports. Some imported modules are the same as in the previous example because we need them to retrieve data from a WebSocket connection again:<pre class="source-code">
import json</pre><pre class="source-code">
import threading</pre><pre class="source-code">
import queue</pre><pre class="source-code">
from websocket import create_connection</pre></li>
<li>Then, we import the <code>datetime</code> method, as we will convert string timestamps into <code>datetime</code> objects:<pre class="source-code">
from datetime import datetime</pre></li>
<li>Finally, we have some imports to facilitate charting:<pre class="source-code">
import matplotlib.pyplot as plt</pre><pre class="source-code">
import pandas</pre><pre class="source-code">
import mplfinance as mpf</pre></li>
</ol>
<p>Then, we will reuse some of the code from the <em class="italic">Plotting live tick data</em> section – the assignment of the <code>sliding_window</code> class, <code>url</code>, and <code>subscription_msg</code> variables, and the initialization of <code>pipe</code>, <code>window_size</code>, <code>bids</code>, and <code>asks</code>. We will also reuse the <code>LMAX_connect()</code> function without changes.</p>
<ol>
<li value="4">Now, we will create a new queue into which we will send DataFrames for plotting:<pre class="source-code">
data_for_chart = queue.Queue()</pre></li>
</ol>
<p>We will also create a new function that will do the job of splitting the incoming tick data stream into bars:</p>
<pre class="source-code">
def make_bars():
    bars = pandas.DataFrame(columns=['Timestamp', 'Open', 'High', 'Low', 'Close'])
    bars.set_index('Timestamp', inplace=True)</pre>
<ol>
<li value="5">We’ve created an empty DataFrame, set the column titles, and assigned <code>Timestamp</code> as the index. Next, we set the time frame (resolution) to 10 seconds and initialize the timestamp:<pre class="source-code">
    resolution = 10</pre><pre class="source-code">
    last_sample_ts = 0</pre></li>
</ol>
<p>Now, as always, if we work with infinite processes in threads, we start the loop, in which we <a id="_idIndexMarker573"/>read a tick, extract its timestamp and last bid price (we assume we want to plot bids; if you want to plot any other data from the order <a id="_idIndexMarker574"/>book, just choose the appropriate key and value in the dictionary), and if this is the very first tick we received, initialize the <code>open</code>, <code>high</code>, <code>low</code>, and <code>close</code> values for the upcoming bar and set <code>last_sample_ts</code> to <code>ts</code>:</p>
<pre class="source-code">
    while True:
        tick = pipe.get()
        ts = datetime.strptime(tick['timestamp'], "%Y-%m-%dT%H:%M:%S.%fZ")
        last_bid = float(tick['bids'][0]['price'])
        if last_sample_ts == 0:
            last_sample_ts = ts
            open = high = low = close = last_bid</pre>
<ol>
<li value="6">Now, we specify the condition with which we will start a new bar. In this case, we do it as soon as the difference between the current time (<code>ts</code>) and the time of the previous bar (<code>last_bar_sample</code>) becomes greater than the value stored in the <code>resolution</code> variable:<pre class="source-code">
        delta = ts – last_sample_ts</pre><pre class="source-code">
        if delta.seconds &gt;= resolution:</pre><pre class="source-code">
            bar = pandas.DataFrame([[open, high, low, close]], columns = ['Open', 'High', 'Low', 'Close'], index = [ts])</pre><pre class="source-code">
            bars = pandas.concat([bars, bar])</pre></li>
<li>So, as soon as a new 10-second interval is started, we create a new DataFrame bar using the <code>Open</code>, <code>High</code>, <code>Low</code>, and <code>Close</code> values and the current timestamp, and add it <a id="_idIndexMarker575"/>to the main DataFrame bars. The rest of the function’s code is <a id="_idIndexMarker576"/>pretty apparent; first, we again initialize all four price variables, update the timestamp of the last bar, and put the DataFrame in the queue:<pre class="source-code">
            last_sample_ts = ts</pre><pre class="source-code">
            open = high = low = close = last_bid</pre><pre class="source-code">
            data_for_chart.put(bars)</pre></li>
</ol>
<p>Of course, if the condition is not <code>true</code> (the time since the bars opened did not exceed the resolution threshold), we just update the price variables:</p>
<pre class="source-code">
        else:
            high = max([high, last_bid])
            low = min([low, last_bid])
            close = last_bid</pre>
<ol>
<li value="8">The trick is done; now, let’s create two threads:<pre class="source-code">
data_receiver_thread = threading.Thread(target = LMAX_connect)</pre><pre class="source-code">
data_receiver_thread.start()</pre><pre class="source-code">
trading_algo_thread = threading.Thread(target = make_bars)</pre><pre class="source-code">
trading_algo_thread.start()</pre></li>
<li>Create the figure and get a handle on the axes:<pre class="source-code">
fig = mpf.figure()</pre><pre class="source-code">
ax1 = fig.add_subplot(1,1,1)</pre></li>
</ol>
<p>Then, run the plotting loop:</p>
<pre class="source-code">
while True:
    chart_data = data_for_chart.get()
    ax1.clear()
    mpf.plot(chart_data, ax = ax1, type='candle', block = False)
    plt.pause(1)</pre>
<p>The <code>block = False</code> optional argument to the <code>mpf.plot()</code> method tells the renderer <a id="_idIndexMarker577"/>to release the chart after drawing and allow adding or <a id="_idIndexMarker578"/>modifying objects in it (so that we can do live updates). Don’t forget to add a pause (<code>plt.pause(1)</code>); otherwise, the loop will always be busy and won’t let the system display the chart on screen.</p>
<p>If you run this code, the first thing you will see is a single huge candlestick because we don’t have enough data yet:</p>
<div><div><img alt="Figure 8.12 – The initial view of the live candlestick chart" src="img/B19145_8_12.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.12 – The initial view of the live candlestick chart</p>
<p>Then, the chart <a id="_idIndexMarker579"/>will update every 10 seconds, and after 4 minutes, you will <a id="_idIndexMarker580"/>see something like what is shown in the following screenshot:</p>
<div><div><img alt="Figure 8.13 – A 10-second candlestick chart made with live price data" src="img/B19145_8_13.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.13 – A 10-second candlestick chart made with live price data</p>
<ol>
<li value="10">As we receive more and more data, there will be more and more candles on the chart, so at a <a id="_idIndexMarker581"/>certain point, it will become unreadable. Therefore, you <a id="_idIndexMarker582"/>may want to add a limit and throw away the oldest row from the DataFrame as the newest one comes in, just before we place the DataFrame in the <code>data_for_chart</code> queue:</li>
</ol>
<pre class="source-code">
            if len(bars) &gt; 100:
                bars = bars.iloc[1:, :]
            data_for_chart.put(bars)</pre>
<p>Here, I specified 100 bars to display, and as soon as this limit is reached, older bars will disappear from the screen – pretty much like in MetaTrader, MultiCharts, TradeStation, or any other charting application.</p>
<p>Very frequently, we will <a id="_idIndexMarker583"/>need to plot something else along with the price data. It can be <a id="_idIndexMarker584"/>a technical indicator, a trendline, just a mark denoting an entry or exit, or anything else. Let’s see how we can do that in the next section.</p>
<h1 id="_idParaDest-148"><a id="_idTextAnchor149"/>Adding objects to price charts</h1>
<p>It is not difficult to <a id="_idIndexMarker585"/>add any objects to the chart if we know their <a id="_idIndexMarker586"/>coordinates because all <code>matplotlib</code> methods always plot one array-like object versus another. So, basically, all we need to do to add any special objects to a chart is to calculate their position in the list, or the array along the <em class="italic">X</em> axis and the corresponding value along the <em class="italic">Y</em> axis.</p>
<p>Let’s consider a simple yet valuable example. In <a href="B19145_03.xhtml#_idTextAnchor044"><em class="italic">Chapter 3</em></a>, <em class="italic">FX Market Overview from a Developer’s Standpoint</em>, we saw that price takers can only buy at the ask and sell at the bid. We also saw that a large order can move the price a few points (pips) up or down because it consumes the liquidity from several levels in the order book. So, we can assume with a good degree of confidence that if the best bid suddenly became greater than the best ask at the previous tick, then it was possibly a trace of a significant buy order. And it works vice versa – if we observe a plunge of the best ask below the previous best bid, then it may be a footprint of a significant sell order.</p>
<p>Let’s visualize these two situations by adding triangle markers, pointing up and down on the tick chart for supposed buys and sells respectively. For this purpose, we will use the code that we wrote to visualize live tick data (see the <em class="italic">Plotting live tick data</em> section) and just add a few lines:</p>
<ol>
<li value="1">First, we need to add two new objects that will display the markers. We add them just below the lines where we create objects to display bids and asks (<code>line1</code> and <code>line2</code>):<pre class="source-code">
line3, = ax.plot(buy_signals_x, buy_signals_y, 'g^')</pre><pre class="source-code">
line4, = ax.plot(sell_signals_x, sell_signals_y, 'mv')</pre></li>
</ol>
<p>Special modifiers here denote the color and the style of the graphics – <code>'g^'</code> means a green triangle pointing up and <code>'mv'</code> means a magenta triangle pointing down. You can find a comprehensive list of the optional parameters of the <code>pyplot.plot()</code> method at <a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html#matplotlib.pyplot.plot">https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html#matplotlib.pyplot.plot</a>.</p>
<ol>
<li value="2">Next, we need to calculate the coordinates (positions) of these markers. We will do it at the very beginning of the main charting loop (immediately after <code>while True:</code>). Let’s add four respective lists to store the coordinates:<pre class="source-code">
while True:</pre><pre class="source-code">
    buy_signals_x = []</pre><pre class="source-code">
    buy_signals_y = []</pre><pre class="source-code">
    sell_signals_x = []</pre><pre class="source-code">
    sell_signals_y = []</pre></li>
</ol>
<p>Then, fill them at all occurrences of the best bid being greater than the previous best ask, or the best ask being lower than the previous best bid:</p>
<pre class="source-code">
    for i in range(1, window_size):</pre>
<ol>
<li value="3">Note that <a id="_idIndexMarker587"/>we start counting from 1 and not from 0 because <a id="_idIndexMarker588"/>we want to compare a value in the list with the <code>bids.data[0]</code> to <code>bids.data[-1]</code>, which is effectively the <strong class="bold">last</strong> element in the list, not the <strong class="bold">previous</strong> one:<pre class="source-code">
        if bids.data[i] &gt; asks.data[i - 1]:</pre><pre class="source-code">
            buy_signals_x.append(i)</pre><pre class="source-code">
            buy_signals_y.append(bids.data[i] - 0.0001)</pre><pre class="source-code">
        if asks.data[i] &lt; bids.data[i - 1]:</pre><pre class="source-code">
            sell_signals_x.append(i)</pre><pre class="source-code">
            sell_signals_y.append(asks.data[i] + 0.0001)</pre></li>
</ol>
<p>We add a margin of 1 <code>pip</code> to the values along the <em class="italic">Y</em> axis so that the markers will be placed slightly away from the main chart.</p>
<ol>
<li value="4">The rest is <a id="_idIndexMarker589"/>the same as what we did for plotting bids <a id="_idIndexMarker590"/>and asks; just add calls to the <code>set_xdata()</code> and <code>set_ydata()</code> methods:<pre class="source-code">
    line3.set_xdata(buy_signals_x)</pre><pre class="source-code">
    line3.set_ydata(buy_signals_y)</pre><pre class="source-code">
    line4.set_xdata(sell_signals_x)</pre><pre class="source-code">
    line4.set_ydata(sell_signals_y)</pre></li>
</ol>
<p>That’s it! If we run our script now, we will see green and magenta markers pointing to the exact places where supposedly big buys or sells happened:</p>
<div><div><img alt="Figure 8.14 – A tick chart with spread-crossing marks added" src="img/B19145_8_14.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.14 – A tick chart with spread-crossing marks added</p>
<p>Wow! Does the chart show the exact points to buy or sell? Looks like we’ve found an excellent trading <a id="_idIndexMarker591"/>strategy. Now, is the only thing left to do to <a id="_idIndexMarker592"/>automate it and look for a bank with reliable safe deposit boxes to store the earned cash?</p>
<p>Of course not. Just look at the following screenshot, and you will see that sometimes chasing <em class="italic">big money</em> can be quite a disappointing experience:</p>
<div><div><img alt="Figure 8.15 – Another illustration of spread-crossing – the price reverses and goes in the opposite direction" src="img/B19145_8_15.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.15 – Another illustration of spread-crossing – the price reverses and goes in the opposite direction</p>
<p>So, as I have maintained throughout the book, there is no free lunch and there is no Holy Grail in trading, which means that it is impossible to make money consistently for a reasonably <a id="_idIndexMarker593"/>long period of time by using only one magical trading <a id="_idIndexMarker594"/>rule. Instead, we need to develop a trading strategy, something that will incorporate trading logic (when we enter and exit the market and why, which normally consists of plenty of rules), money management (how much we trade), and risk management (what we do if things go wrong or, preferably, how to anticipate that and avoid trading). And this is what we are going to consider in the remaining part of this book.</p>
<h1 id="_idParaDest-149"><a id="_idTextAnchor150"/>Summary</h1>
<p>In this chapter, we learned about the general principles of handling charts with Python. Now, we can quickly find the required part of historical data and plot it as line or candlestick charts. We also learned how to plot live market data and update the charts in real time. Finally, we learned how to add custom graphics to a price chart and discovered that crossing the spread can indeed be a potentially valuable trading signal. We are prepared to visualize any data, be it market prices or the performance of our trading algorithm, so it’s high time we step into the domain of trading strategies to understand how and why they work, and to make the right choice for further development. This is what we are going to consider in the next chapter.</p>
</div>


<div><h1 id="_idParaDest-150"><a id="_idTextAnchor151"/>Part 3: Orders, Trading Strategies, and Their Performance</h1>
<p>In previous parts, we learned about the FX markets, understood how they operate, and discovered how to avoid the intrinsic risks. We also considered the essential components of most trading algorithms, which aim at addressing the peculiarities of the subject domain.</p>
<p><em class="italic">Part 3</em> moves forward by explaining the ideas behind most trading strategies, including all-time classics such as trend following, momentum, and mean reversion, along with more advanced arbitrage and stat arbitrage, market making, and high-frequency trading. We will also learn about the most common types of orders, typical issues with their execution, and ways to mitigate the associated risks. Finally, we will build our first trading app, test it, and learn about one of the most common mistakes among quant traders.</p>
<p>This part comprises the following chapters:</p>
<ul>
<li><a href="B19145_09.xhtml#_idTextAnchor152"><em class="italic">Chapter 9</em></a>, <em class="italic">Trading Strategies and Their Core Elements</em></li>
<li><a href="B19145_10.xhtml#_idTextAnchor171"><em class="italic">Chapter 10</em></a>, <em class="italic">Types of Orders and Their Simulation in Python</em></li>
<li><a href="B19145_11.xhtml#_idTextAnchor186"><em class="italic">Chapter 11</em></a>, <em class="italic">Backtesting and Theoretical Performance</em></li>
</ul>
</div>
<div><div></div>
</div>
</body></html>