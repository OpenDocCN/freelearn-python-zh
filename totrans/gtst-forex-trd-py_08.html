<html><head></head><body>
<div id="_idContainer079">
<h1 class="chapter-number" id="_idParaDest-129"><a id="_idTextAnchor130"/><span class="koboSpan" id="kobo.1.1">8</span></h1>
<h1 id="_idParaDest-130"><a id="_idTextAnchor131"/><span class="koboSpan" id="kobo.2.1">Data Visualization in FX Trading with Python</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In previous chapters, we learned how to receive and store market data, how to process it, and how to calculate various technical indicators. </span><span class="koboSpan" id="kobo.3.2">However, working with large amounts of time series data frequently leads to errors typically caused by sad mistakes – for example, using incorrect data feed or wrong timestamps. </span><span class="koboSpan" id="kobo.3.3">Besides that, when working with TA indicators, it’s really wise to check the result of the calculations visually – for example, you want to use a large period moving average to determine long-term price movements, but you make a mistake, enter a small period value, and then find yourself lost in debugging because no real long-term trend can be found. </span><span class="koboSpan" id="kobo.3.4">Making your research visual helps identify various mistakes very quickly and saves a lot </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">of time.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">In this chapter, we will learn how to visualize data using one of the industry standard libraries, </span><strong class="source-inline"><span class="koboSpan" id="kobo.6.1">matplotlib</span></strong><span class="koboSpan" id="kobo.7.1">, and then go on to plotting bar and candlestick charts with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.8.1">mplfinance</span></strong><span class="koboSpan" id="kobo.9.1"> library, and we will see how it’s possible to create charts with live updates and use additional graphics with </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">price charts.</span></span></p>
<p><span class="koboSpan" id="kobo.11.1">In this chapter, the following topics will </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">be covered:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.13.1">Charting and plotting basics – how to use graphical libraries </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">with Python</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Quick plotting using scripts or an </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">interactive console</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">Visualizing historical </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">market data</span></span></li>
<li><span class="koboSpan" id="kobo.19.1">Creating bar and </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">candlestick charts</span></span></li>
<li><span class="koboSpan" id="kobo.21.1">Visualizing live </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">market data</span></span></li>
<li><span class="koboSpan" id="kobo.23.1">Adding other objects to </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">price charts</span></span></li>
</ul>
<h1 id="_idParaDest-131"><a id="_idTextAnchor132"/><span class="koboSpan" id="kobo.25.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.26.1">To run the practical examples in this chapter, you only require Python 3.9 </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">or above.</span></span></p>
<h1 id="_idParaDest-132"><a id="_idTextAnchor133"/><span class="koboSpan" id="kobo.28.1">The basics of charting with Python</span></h1>
<p><span class="koboSpan" id="kobo.29.1">There are many </span><a id="_idIndexMarker489"/><span class="koboSpan" id="kobo.30.1">libraries that implement charting with Python but at the time of writing, two of them are industry standards – </span><strong class="source-inline"><span class="koboSpan" id="kobo.31.1">matplotlib</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.32.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.33.1">plotly</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.35.1">Matplotlib</span></strong><span class="koboSpan" id="kobo.36.1"> is the oldest charting library (in heavy use since 2003), which was created in order to </span><a id="_idIndexMarker490"/><span class="koboSpan" id="kobo.37.1">bring the well-developed charting facilities of Matlab to Python. </span><span class="koboSpan" id="kobo.37.2">It can create charts based on any array-like objects, including native Python lists and </span><strong class="source-inline"><span class="koboSpan" id="kobo.38.1">numpy</span></strong><span class="koboSpan" id="kobo.39.1"> arrays, support numerous types of charts, including financial ones (which is what we need!), provides full control over chart objects, features almost unlimited chart customizations, and can be used with </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">different backends.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.41.1">plotly</span></strong><span class="koboSpan" id="kobo.42.1"> is a relatively young competitor (released in 2014). </span><span class="koboSpan" id="kobo.42.2">It offers pretty much the same charting </span><a id="_idIndexMarker491"/><span class="koboSpan" id="kobo.43.1">facilities as </span><strong class="source-inline"><span class="koboSpan" id="kobo.44.1">matplotlib</span></strong><span class="koboSpan" id="kobo.45.1"> so the choice between the two is not obvious. </span><span class="koboSpan" id="kobo.45.2">Plotly definitely wins when it comes to interactivity and working with chart objects via an API but loses the competition in speed and abilities </span><span class="No-Break"><span class="koboSpan" id="kobo.46.1">for customization.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.47.1">Which one do we choose? </span><span class="koboSpan" id="kobo.47.2">Generally speaking, if you do not plan to develop a commercial-grade GUI application, then </span><strong class="source-inline"><span class="koboSpan" id="kobo.48.1">matplotlib</span></strong><span class="koboSpan" id="kobo.49.1"> is the obvious choice because it’s easy to use, is very well documented, and has decent </span><span class="No-Break"><span class="koboSpan" id="kobo.50.1">community support.</span></span></p>
<p><span class="koboSpan" id="kobo.51.1">Before we start, let’s quickly look at how </span><strong class="source-inline"><span class="koboSpan" id="kobo.52.1">matplotlib</span></strong><span class="koboSpan" id="kobo.53.1"> (and similar charting libraries in general) work and clearly decide what we are going to do, and especially what we are </span><em class="italic"><span class="koboSpan" id="kobo.54.1">not</span></em><span class="koboSpan" id="kobo.55.1"> going to do. </span><span class="koboSpan" id="kobo.55.2">We will learn about different backends, consider the peculiarities of plotting real-time and static data, and get familiar with the internal organization of graphical engines and their interaction with the </span><em class="italic"><span class="koboSpan" id="kobo.56.1">outer world</span></em><span class="koboSpan" id="kobo.57.1"> (</span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">your code).</span></span></p>
<h2 id="_idParaDest-133"><a id="_idTextAnchor134"/><span class="koboSpan" id="kobo.59.1">Graphical backends</span></h2>
<p><span class="koboSpan" id="kobo.60.1">Any charting package used with Python has various </span><strong class="bold"><span class="koboSpan" id="kobo.61.1">backends</span></strong><span class="koboSpan" id="kobo.62.1"> – the very engines that render graphics </span><a id="_idIndexMarker492"/><span class="koboSpan" id="kobo.63.1">on screen. </span><span class="koboSpan" id="kobo.63.2">Out of the box, we have a choice of four backends: Agg, </span><strong class="bold"><span class="koboSpan" id="kobo.64.1">PS</span></strong><span class="koboSpan" id="kobo.65.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.66.1">postscript</span></strong><span class="koboSpan" id="kobo.67.1">), PDF (yes, the standard PDF format used for documents), and </span><a id="_idIndexMarker493"/><span class="koboSpan" id="kobo.68.1">SVG (the standard for </span><span class="No-Break"><span class="koboSpan" id="kobo.69.1">vector graphics).</span></span></p>
<p><span class="koboSpan" id="kobo.70.1">Backends have </span><strong class="bold"><span class="koboSpan" id="kobo.71.1">bindings</span></strong><span class="koboSpan" id="kobo.72.1"> – in simple terms, wrappers that facilitate calls to backends from </span><a id="_idIndexMarker494"/><span class="koboSpan" id="kobo.73.1">Python. </span><span class="koboSpan" id="kobo.73.2">Some backends offer interactive tools and controls out of the box; in this case, you only need to draw a chart and then you can pan and zoom in using built-in controls provided by the backend. </span><span class="koboSpan" id="kobo.73.3">Using other backends requires full implementation of the user interface, which is great if you want to customize and polish your app to a commercial-grade level but is pretty annoying if you only want to quickly look at some piece </span><span class="No-Break"><span class="koboSpan" id="kobo.74.1">of data.</span></span></p>
<p><span class="koboSpan" id="kobo.75.1">We are going to use the standard </span><strong class="bold"><span class="koboSpan" id="kobo.76.1">Agg</span></strong><span class="koboSpan" id="kobo.77.1"> backend with </span><strong class="bold"><span class="koboSpan" id="kobo.78.1">Tk</span></strong><span class="koboSpan" id="kobo.79.1"> bindings, which support some interactivity, such as the zooming and panning of plots, out of the box. </span><span class="koboSpan" id="kobo.79.2">It is the default backend for </span><strong class="source-inline"><span class="koboSpan" id="kobo.80.1">matplotlib</span></strong><span class="koboSpan" id="kobo.81.1">, so you don’t need to use any special commands in </span><span class="No-Break"><span class="koboSpan" id="kobo.82.1">your code.</span></span></p>
<h2 id="_idParaDest-134"><a id="_idTextAnchor135"/><span class="koboSpan" id="kobo.83.1">Static versus real-time data and related issues</span></h2>
<p><span class="koboSpan" id="kobo.84.1">It is important to note the key difference between visualizing static data and dynamic data. </span><span class="koboSpan" id="kobo.84.2">By </span><strong class="bold"><span class="koboSpan" id="kobo.85.1">static data</span></strong><span class="koboSpan" id="kobo.86.1">, we mean any data that is read only once, received, calculated, and so on, and is not modified in </span><a id="_idIndexMarker495"/><span class="koboSpan" id="kobo.87.1">real time. </span><span class="koboSpan" id="kobo.87.2">Typically, it is used during the research phase when </span><a id="_idIndexMarker496"/><span class="koboSpan" id="kobo.88.1">you develop, test, and optimize your </span><a id="_idIndexMarker497"/><span class="koboSpan" id="kobo.89.1">trading strategy. </span><span class="koboSpan" id="kobo.89.2">In this case, we work with </span><a id="_idIndexMarker498"/><span class="koboSpan" id="kobo.90.1">historical data saved on the disk or retrieved via an API from our broker – but in any case, it is not being modified live. </span><span class="koboSpan" id="kobo.90.2">This means that both charting libraries work just perfectly without any serious efforts from the developer’s side; once the dataset is formed, it can be plotted with a </span><span class="No-Break"><span class="koboSpan" id="kobo.91.1">single command.</span></span></p>
<p><span class="koboSpan" id="kobo.92.1">However, once we switch to real-time data visualization, we encounter problems because we need to update the chart(s) either periodically or upon an event – for example, upon receipt of a new tick. </span><span class="koboSpan" id="kobo.92.2">And here, we can encounter issues related to multithreading. </span><span class="koboSpan" id="kobo.92.3">To better understand these issues, let’s do a </span><span class="No-Break"><span class="koboSpan" id="kobo.93.1">quick recap.</span></span></p>
<p><span class="koboSpan" id="kobo.94.1">Do you remember the concept of multithreading that we covered in </span><a href="B19145_05.xhtml#_idTextAnchor086"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.95.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.96.1">, </span><em class="italic"><span class="koboSpan" id="kobo.97.1">Retrieving and Handling Market Data with Python</span></em><span class="koboSpan" id="kobo.98.1">? </span><span class="koboSpan" id="kobo.98.2">Running several processes in parallel and connecting them using queues makes our trading apps universal, in the sense that we can develop all logic only once and then switch between data sources in order to go from research and development </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">to production.</span></span></p>
<p><span class="koboSpan" id="kobo.100.1">However, when we </span><a id="_idIndexMarker499"/><span class="koboSpan" id="kobo.101.1">add graphics to our applications, we can </span><a id="_idIndexMarker500"/><span class="koboSpan" id="kobo.102.1">sometimes encounter issues, and these </span><a id="_idIndexMarker501"/><span class="koboSpan" id="kobo.103.1">issues are rooted in the fact that graphics are also running in a separate thread. </span><span class="koboSpan" id="kobo.103.2">This thread is controlled by a separate mechanism, not the one that we use to organize data-receiving and </span><span class="No-Break"><span class="koboSpan" id="kobo.104.1">processing threads.</span></span></p>
<p><span class="koboSpan" id="kobo.105.1">Therefore, adding charting in yet another thread to keep it completely separate from the main thread is tricky, to say the least. </span><span class="koboSpan" id="kobo.105.2">So, we will sacrifice the universality of our application in favor of keeping the usage of the </span><span class="No-Break"><span class="koboSpan" id="kobo.106.1">graphics simple.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.107.1">Important note about threads, loops, and process termination</span></p>
<p class="callout"><span class="koboSpan" id="kobo.108.1">The problem with multithreading is the termination of a thread. </span><span class="koboSpan" id="kobo.108.2">If you start a thread and don’t add any check on whether to keep it running or terminate, then it will run virtually forever. </span><span class="koboSpan" id="kobo.108.3">To keep your code correct, you may want to always add an exit condition to any thread and/or the entire program (which is also a thread). </span><span class="koboSpan" id="kobo.108.4">However, when using </span><strong class="source-inline"><span class="koboSpan" id="kobo.109.1">matplotlib</span></strong><span class="koboSpan" id="kobo.110.1">, you don’t have explicit control over the thread that renders graphics, so you may want to use callbacks from the operating system. </span><span class="koboSpan" id="kobo.110.2">Therefore, despite the risk of being criticized by programming purists, I personally use keyboard termination from inside an IDE to stop the graphics loop – keeping in mind that, in production, we won’t have to do that, as we never include charting in the production code. </span><span class="koboSpan" id="kobo.110.3">It’s up to you to choose how you handle this issue, but in my opinion, the simpler, </span><span class="No-Break"><span class="koboSpan" id="kobo.111.1">the better.</span></span></p>
<p><span class="koboSpan" id="kobo.112.1">So, what we </span><em class="italic"><span class="koboSpan" id="kobo.113.1">are</span></em><span class="koboSpan" id="kobo.114.1"> going to do is to integrate some basic charting as part of the main thread of the main module. </span><span class="koboSpan" id="kobo.114.2">It will serve the only purpose of quick visualization without any intent to be used as a universal charting software, and will be disabled or removed before switching from development mode </span><span class="No-Break"><span class="koboSpan" id="kobo.115.1">to production.</span></span></p>
<p><span class="koboSpan" id="kobo.116.1">What we </span><em class="italic"><span class="koboSpan" id="kobo.117.1">are not</span></em><span class="koboSpan" id="kobo.118.1"> going to do is to write complex code that would provide our app with a sophisticated GUI that would fully imitate commercial applications, such as MetaTrader </span><span class="No-Break"><span class="koboSpan" id="kobo.119.1">or MultiCharts.</span></span></p>
<p><span class="koboSpan" id="kobo.120.1">Enough talk – let’s </span><span class="No-Break"><span class="koboSpan" id="kobo.121.1">get coding.</span></span></p>
<h2 id="_idParaDest-135"><a id="_idTextAnchor136"/><span class="koboSpan" id="kobo.122.1">Installing Matplotlib</span></h2>
<p><span class="koboSpan" id="kobo.123.1">Unless you use a </span><a id="_idIndexMarker502"/><span class="koboSpan" id="kobo.124.1">clean Python installation, chances are that you already have </span><strong class="source-inline"><span class="koboSpan" id="kobo.125.1">matplotlib</span></strong><span class="koboSpan" id="kobo.126.1"> installed, so check before trying to install it. </span><span class="koboSpan" id="kobo.126.2">Just type </span><strong class="source-inline"><span class="koboSpan" id="kobo.127.1">import matplotlib</span></strong><span class="koboSpan" id="kobo.128.1"> in the </span><a id="_idIndexMarker503"/><span class="koboSpan" id="kobo.129.1">console and watch </span><span class="No-Break"><span class="koboSpan" id="kobo.130.1">the result.</span></span></p>
<p><span class="koboSpan" id="kobo.131.1">If you don’t have </span><strong class="source-inline"><span class="koboSpan" id="kobo.132.1">matplotlib</span></strong><span class="koboSpan" id="kobo.133.1"> installed, you can use the </span><span class="No-Break"><span class="koboSpan" id="kobo.134.1">standard installation:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.135.1">
python -m pip install -U pip
python -m pip install -U matplotlib</span></pre>
<p><span class="koboSpan" id="kobo.136.1">If you use Conda packages, then you can install </span><strong class="source-inline"><span class="koboSpan" id="kobo.137.1">matplotlib</span></strong><span class="koboSpan" id="kobo.138.1"> using the </span><span class="No-Break"><span class="koboSpan" id="kobo.139.1">following command:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.140.1">
conda install matplotlib</span></pre>
<p><span class="koboSpan" id="kobo.141.1">Generally speaking, all major third-party Python distributions such as Anaconda, ActiveState, ActivePython, and WinPython have </span><strong class="source-inline"><span class="koboSpan" id="kobo.142.1">matplotlib</span></strong><span class="koboSpan" id="kobo.143.1"> as part </span><span class="No-Break"><span class="koboSpan" id="kobo.144.1">of them.</span></span></p>
<h2 id="_idParaDest-136"><a id="_idTextAnchor137"/><span class="koboSpan" id="kobo.145.1">Using Matplotlib in your code</span></h2>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.146.1">matplotlib</span></strong><span class="koboSpan" id="kobo.147.1"> is quite a large </span><a id="_idIndexMarker504"/><span class="koboSpan" id="kobo.148.1">library and we actually need only a </span><a id="_idIndexMarker505"/><span class="koboSpan" id="kobo.149.1">part of it – the very module that does the plotting. </span><span class="koboSpan" id="kobo.149.2">As always, I strongly recommend using </span><strong class="source-inline"><span class="koboSpan" id="kobo.150.1">import</span></strong><span class="koboSpan" id="kobo.151.1"> rather than </span><strong class="source-inline"><span class="koboSpan" id="kobo.152.1">from ... </span><span class="koboSpan" id="kobo.152.2">import</span></strong><span class="koboSpan" id="kobo.153.1"> – to keep </span><span class="No-Break"><span class="koboSpan" id="kobo.154.1">namespaces separate:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.155.1">
import matplotlib.pyplot as plt</span></pre>
<p><span class="koboSpan" id="kobo.156.1">This imports the </span><strong class="source-inline"><span class="koboSpan" id="kobo.157.1">pyplot</span></strong><span class="koboSpan" id="kobo.158.1"> module that actually creates and handles plots. </span><span class="koboSpan" id="kobo.158.2">Let’s create our </span><span class="No-Break"><span class="koboSpan" id="kobo.159.1">first plot:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.160.1">
y = range(10)
plt.plot(y)
plt.show()</span></pre>
<p><span class="koboSpan" id="kobo.161.1">The result will look like the </span><span class="No-Break"><span class="koboSpan" id="kobo.162.1">following figure:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer064">
<span class="koboSpan" id="kobo.163.1"><img alt="Figure 8.1 – A basic ﻿Matplotlib plot" src="image/B19145_8_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.164.1">Figure 8.1 – A basic Matplotlib plot</span></p>
<p><span class="koboSpan" id="kobo.165.1">Let’s see what </span><span class="No-Break"><span class="koboSpan" id="kobo.166.1">actually happened:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.167.1">The graphics </span><a id="_idIndexMarker506"/><span class="koboSpan" id="kobo.168.1">library created a figure – the very </span><strong class="bold"><span class="koboSpan" id="kobo.169.1">canvas</span></strong><span class="koboSpan" id="kobo.170.1"> on which </span><a id="_idIndexMarker507"/><span class="koboSpan" id="kobo.171.1">all the following charting should </span><span class="No-Break"><span class="koboSpan" id="kobo.172.1">be made.</span></span></li>
<li><span class="koboSpan" id="kobo.173.1">Then, </span><strong class="bold"><span class="koboSpan" id="kobo.174.1">axes</span></strong><span class="koboSpan" id="kobo.175.1"> were created in the figure – the rectangle box with scales from 0 to 10, in </span><span class="No-Break"><span class="koboSpan" id="kobo.176.1">our case.</span></span></li>
<li><span class="koboSpan" id="kobo.177.1">Then, a graph object was added to the axes – in our case, it’s the </span><span class="No-Break"><span class="koboSpan" id="kobo.178.1">diagonal line.</span></span></li>
<li><span class="koboSpan" id="kobo.179.1">And finally, </span><strong class="source-inline"><span class="koboSpan" id="kobo.180.1">plt.show()</span></strong><span class="koboSpan" id="kobo.181.1"> was called – the method that actually displays the chart </span><span class="No-Break"><span class="koboSpan" id="kobo.182.1">on screen.</span></span></li>
</ol>
<p class="callout-heading"><span class="koboSpan" id="kobo.183.1">Multithreading: revisited</span></p>
<p class="callout"><span class="koboSpan" id="kobo.184.1">When you run this code, you will now see a separate process. </span><span class="koboSpan" id="kobo.184.2">This process is created by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.185.1">plt.show()</span></strong><span class="koboSpan" id="kobo.186.1"> method and its name is </span><strong class="source-inline"><span class="koboSpan" id="kobo.187.1">python</span></strong><span class="koboSpan" id="kobo.188.1">. </span><span class="koboSpan" id="kobo.188.2">Don’t confuse it with the Python interpreter! </span><span class="koboSpan" id="kobo.188.3">This new process handles only the figure that is currently being displayed on screen. </span><span class="koboSpan" id="kobo.188.4">If you kill it, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.189.1">matplotlib</span></strong><span class="koboSpan" id="kobo.190.1"> main loop is terminated and the figure disappears, but other threads will keep running! </span><span class="koboSpan" id="kobo.190.2">So, a better idea is to stop the execution of your code from the IDE, to kill all threads along with this </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.191.1">python</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.192.1"> process.</span></span></p>
<p><span class="koboSpan" id="kobo.193.1">As you can see, we had 10 elements in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.194.1">y</span></strong><span class="koboSpan" id="kobo.195.1"> list, and the horizontal axis is graduated accordingly, 0 to 10. </span><span class="koboSpan" id="kobo.195.2">It’s clear that the current plot displays the </span><strong class="source-inline"><span class="koboSpan" id="kobo.196.1">y = x</span></strong><span class="koboSpan" id="kobo.197.1"> linear function, where arguments </span><a id="_idIndexMarker508"/><span class="koboSpan" id="kobo.198.1">are integer numbers. </span><span class="koboSpan" id="kobo.198.2">However, what if we wanted </span><a id="_idIndexMarker509"/><span class="koboSpan" id="kobo.199.1">to calculate the same function for fractional arguments – say, the same 10 points, but taken between 0 and 1, not 0 </span><span class="No-Break"><span class="koboSpan" id="kobo.200.1">and 10?</span></span></p>
<p><span class="koboSpan" id="kobo.201.1">Let’s give it </span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">a try:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.203.1">First, as always, we </span><span class="No-Break"><span class="koboSpan" id="kobo.204.1">import </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.205.1">pyplot</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.206.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.207.1">
import matplotlib.pyplot as plt</span></pre></li>
<li><span class="koboSpan" id="kobo.208.1">Then, we import </span><strong class="source-inline"><span class="koboSpan" id="kobo.209.1">numpy</span></strong><span class="koboSpan" id="kobo.210.1"> – the universal mathematical library for Python that adds support for vectors and matrices, along with myriads of math functions. </span><span class="koboSpan" id="kobo.210.2">We’re going to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.211.1">arange</span></strong><span class="koboSpan" id="kobo.212.1">, which is somewhat similar to the native Python range but supports </span><span class="No-Break"><span class="koboSpan" id="kobo.213.1">fractional steps:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.214.1">
import numpy as np</span></pre></li>
<li><span class="koboSpan" id="kobo.215.1">Next, we form the range </span><span class="No-Break"><span class="koboSpan" id="kobo.216.1">to display:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.217.1">
y = np.arange(0, 1, 0.1)</span></pre></li>
<li><span class="koboSpan" id="kobo.218.1">The rest of the code is unchanged – just creating a plot and displaying it </span><span class="No-Break"><span class="koboSpan" id="kobo.219.1">on screen:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.220.1">
plt.plot(y)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.221.1">
plt.show()</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.222.1">Then, you should see a figure similar to </span><span class="No-Break"><span class="koboSpan" id="kobo.223.1">the following:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer065">
<span class="koboSpan" id="kobo.224.1"><img alt="Figure 8.2 – The plot of the linear function in the range between 0 and 1 – the incorrect X-axis scale" src="image/B19145_8_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.225.1">Figure 8.2 – The plot of the linear function in the range between 0 and 1 – the incorrect X-axis scale</span></p>
<p><span class="koboSpan" id="kobo.226.1">But wait! </span><span class="koboSpan" id="kobo.226.2">There’s something wrong with our chart. </span><span class="koboSpan" id="kobo.226.3">Yes, the </span><em class="italic"><span class="koboSpan" id="kobo.227.1">Y</span></em><span class="koboSpan" id="kobo.228.1"> axis has now graduated from 0 to 1 with a step of 0.1, but the </span><em class="italic"><span class="koboSpan" id="kobo.229.1">X</span></em><span class="koboSpan" id="kobo.230.1"> axis has still graduated from 0 to 10. </span><span class="koboSpan" id="kobo.230.2">This </span><a id="_idIndexMarker510"/><span class="koboSpan" id="kobo.231.1">happened because we plotted the new array but did </span><a id="_idIndexMarker511"/><span class="koboSpan" id="kobo.232.1">nothing to tell the </span><strong class="source-inline"><span class="koboSpan" id="kobo.233.1">plt.plot()</span></strong><span class="koboSpan" id="kobo.234.1"> method about the new scale by the </span><em class="italic"><span class="koboSpan" id="kobo.235.1">X</span></em><span class="koboSpan" id="kobo.236.1"> axis – and by default, this method assumes that we plot any array versus indices of its elements, which is always an array </span><span class="No-Break"><span class="koboSpan" id="kobo.237.1">of integers.</span></span></p>
<ol>
<li value="5"><span class="koboSpan" id="kobo.238.1">Let’s fix this mistake by adding the correct </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.239.1">X</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.240.1">-axis data:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.241.1">
x = np.arange(0, 1, 0.1)</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.242.1">Let’s also modify the call of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.243.1">plot()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.244.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.245.1">
plt.plot(x, y)</span></pre>
<p><span class="koboSpan" id="kobo.246.1">Now, we will see the correct plot, shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.247.1">following figure:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer066">
<span class="koboSpan" id="kobo.248.1"><img alt="Figure 8.3 – The plot of the linear function in the range between 0 and 1 – now the correct X-axis scale" src="image/B19145_8_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.249.1">Figure 8.3 – The plot of the linear function in the range between 0 and 1 – now the correct X-axis scale</span></p>
<p><span class="koboSpan" id="kobo.250.1">Now that we know a bit </span><a id="_idIndexMarker512"/><span class="koboSpan" id="kobo.251.1">about how the </span><strong class="source-inline"><span class="koboSpan" id="kobo.252.1">plot()</span></strong><span class="koboSpan" id="kobo.253.1"> method </span><a id="_idIndexMarker513"/><span class="koboSpan" id="kobo.254.1">works, let’s plot some actual </span><span class="No-Break"><span class="koboSpan" id="kobo.255.1">market data.</span></span></p>
<h1 id="_idParaDest-137"><a id="_idTextAnchor138"/><span class="koboSpan" id="kobo.256.1">Simple plots of market data</span></h1>
<p><span class="koboSpan" id="kobo.257.1">In the following </span><a id="_idIndexMarker514"/><span class="koboSpan" id="kobo.258.1">examples, we will use historical data only. </span><span class="koboSpan" id="kobo.258.2">We will learn how to plot live data received from a broker later in </span><span class="No-Break"><span class="koboSpan" id="kobo.259.1">this chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.260.1">There are many ways to read and handle market data, some of which were considered in </span><a href="B19145_05.xhtml#_idTextAnchor086"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.261.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.262.1">, </span><em class="italic"><span class="koboSpan" id="kobo.263.1">Retrieving and Handling Market Data with Python</span></em><span class="koboSpan" id="kobo.264.1">. </span><span class="koboSpan" id="kobo.264.2">Now, we are going to learn some alternative approaches so that you can best choose what suits your current research and </span><span class="No-Break"><span class="koboSpan" id="kobo.265.1">development needs.</span></span></p>
<p><span class="koboSpan" id="kobo.266.1">Let’s start with the most straightforward approach, which uses only native Python data structures. </span><span class="koboSpan" id="kobo.266.2">As we saw in </span><a href="B19145_05.xhtml#_idTextAnchor086"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.267.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.268.1">, the preferred way of storing and manipulating market data is a dictionary because of its full compatibility with the JSON standard and the ability to extract the necessary data by keywords. </span><span class="koboSpan" id="kobo.268.2">We will start with dictionaries </span><span class="No-Break"><span class="koboSpan" id="kobo.269.1">as well:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.270.1">First, we still need to do </span><span class="No-Break"><span class="koboSpan" id="kobo.271.1">some imports:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.272.1">
import matplotlib.pyplot as plt</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.273.1">
import csv</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.274.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.275.1">csv</span></strong><span class="koboSpan" id="kobo.276.1"> module </span><a id="_idIndexMarker515"/><span class="koboSpan" id="kobo.277.1">contains very convenient methods to read and parse </span><strong class="bold"><span class="koboSpan" id="kobo.278.1">comma-separated value</span></strong><span class="koboSpan" id="kobo.279.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.280.1">CSV</span></strong><span class="koboSpan" id="kobo.281.1">) files, which is the de facto standard for storing historical </span><span class="No-Break"><span class="koboSpan" id="kobo.282.1">market data.</span></span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.283.1">Now, let’s open a data file and create a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">DictReader()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.285.1"> object:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.286.1">
f = open("/Volumes/Storage HDD/Data/LMAX EUR_USD 1 Minute.txt")</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.287.1">
csvFile = csv.DictReader(f)</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.288.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">DictReader()</span></strong><span class="koboSpan" id="kobo.290.1"> method parses the CSV file into a dictionary or set of dictionaries and returns a </span><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">DictReader</span></strong><span class="koboSpan" id="kobo.292.1"> object. </span><span class="koboSpan" id="kobo.292.2">It uses the first line of the file as the source for keywords, so make sure you have it in your source data. </span><span class="koboSpan" id="kobo.292.3">In the sample file I’m using, the header (the first line) looks like </span><span class="No-Break"><span class="koboSpan" id="kobo.293.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.294.1">
Date,Time,Open,High,Low,Close,UpVolume,DownVolume,
TotalVolume,UpTicks,DownTicks,TotalTicks</span></pre>
<p><span class="koboSpan" id="kobo.295.1">So, these are the very keywords that will appear in the dictionaries when I have read the file and parsed it </span><span class="No-Break"><span class="koboSpan" id="kobo.296.1">with </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">DictReader()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.298.1">.</span></span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.299.1">Now, we need to convert this object into </span><span class="No-Break"><span class="koboSpan" id="kobo.300.1">a list:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.301.1">
all_data = list(csvFile)</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.302.1">If we now look at the last three elements in the list by entering </span><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">print(all_data[-3:])</span></strong><span class="koboSpan" id="kobo.304.1">, we will see something like </span><span class="No-Break"><span class="koboSpan" id="kobo.305.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.306.1">
[{'Date': '11/12/2020', 'Time': '17:45:00', 'Open': '1.18136', 'High': '1.18143', 'Low': '1.18125', 'Close': '1.18140', 'UpVolume': '249', 'DownVolume': '494', 'TotalVolume': '743', 'UpTicks': '7', 'DownTicks': '5', 'TotalTicks': '12'}, {'Date': '11/12/2020', 'Time': '17:46:00', 'Open': '1.18140', 'High': '1.18156', 'Low': '1.18138', 'Close': '1.18154', 'UpVolume': '399', 'DownVolume': '299', 'TotalVolume': '698', 'UpTicks': '8', 'DownTicks': '4', 'TotalTicks': '12'}, {'Date': '11/12/2020', 'Time': '17:47:00', 'Open': '1.18154', 'High': '1.18156', 'Low': '1.18145', 'Close': '1.18155', 'UpVolume': '500', 'DownVolume': '650', 'TotalVolume': '1150', 'UpTicks': '5', 'DownTicks': '6', 'TotalTicks': '11'}]</span></pre>
<p><span class="koboSpan" id="kobo.307.1">So, we indeed now have 1-minute data in the form of OHLC bars, along with some information </span><a id="_idIndexMarker516"/><span class="koboSpan" id="kobo.308.1">about the volume and the number of ticks per interval (1 minute). </span><span class="koboSpan" id="kobo.308.2">Each bar is represented by a separate dictionary, and dictionaries are collected in </span><span class="No-Break"><span class="koboSpan" id="kobo.309.1">a list.</span></span></p>
<ol>
<li value="4"><span class="koboSpan" id="kobo.310.1">Now, we need to extract only the data we want to plot – say, closing prices. </span><span class="koboSpan" id="kobo.310.2">In order to avoid possible issues by plotting too much data, let’s plot just the last 100 data points. </span><span class="koboSpan" id="kobo.310.3">There are many ways to do this; we will use </span><span class="No-Break"><span class="koboSpan" id="kobo.311.1">list comprehensions:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.312.1">
close = [float(bar['Close']) for bar in all_data[-100:]]</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.313.1">The rest of the code is </span><span class="No-Break"><span class="koboSpan" id="kobo.314.1">the same:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.315.1">
plt.plot(close)
plt.show()</span></pre>
<p><span class="koboSpan" id="kobo.316.1">If you did everything correctly, you should see a chart similar to the one shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.317.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer067">
<span class="koboSpan" id="kobo.318.1"><img alt="Figure 8.4 – A simple line chart of closing prices" src="image/B19145_8_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.319.1">Figure 8.4 – A simple line chart of closing prices</span></p>
<ol>
<li value="5"><span class="koboSpan" id="kobo.320.1">Great, but what about the </span><em class="italic"><span class="koboSpan" id="kobo.321.1">X</span></em><span class="koboSpan" id="kobo.322.1">-axis labels? </span><span class="koboSpan" id="kobo.322.2">Oh, it again just counts the data points, 0 to 100, but we </span><a id="_idIndexMarker517"/><span class="koboSpan" id="kobo.323.1">want to see something more meaningful here. </span><span class="koboSpan" id="kobo.323.2">Let’s recall that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.324.1">plot()</span></strong><span class="koboSpan" id="kobo.325.1"> method actually plots one iterable versus another, so we’ll create labels from </span><span class="No-Break"><span class="koboSpan" id="kobo.326.1">the timestamps:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.327.1">
time = [bar['Time'] for bar in all_data[-100:]]</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.328.1">
plt.plot(time, close)</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.329.1">Now, we can see that the numbers along the </span><em class="italic"><span class="koboSpan" id="kobo.330.1">X</span></em><span class="koboSpan" id="kobo.331.1"> axis were indeed replaced with something, but this something is really hard to read </span><span class="No-Break"><span class="koboSpan" id="kobo.332.1">and understand:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer068">
<span class="koboSpan" id="kobo.333.1"><img alt="Figure 8.5 – Using timestamps as X-axis labels without proper formatting gets erratic results" src="image/B19145_8_05.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.334.1">Figure 8.5 – Using timestamps as X-axis labels without proper formatting gets erratic results</span></p>
<p><span class="koboSpan" id="kobo.335.1">Unsurprisingly, the labels (the timestamps) are rather long, there are too many of them, and they </span><a id="_idIndexMarker518"/><span class="koboSpan" id="kobo.336.1">are displayed one over another, making the result unusable. </span><span class="koboSpan" id="kobo.336.2">So, we want to format them somehow, printing labels only every 10, 20, or 100 ticks and rotating them to save </span><span class="No-Break"><span class="koboSpan" id="kobo.337.1">screen space.</span></span></p>
<p><span class="koboSpan" id="kobo.338.1">In order to do that, we should recall the sequence of events that is triggered by the call to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.339.1">plot()</span></strong><span class="koboSpan" id="kobo.340.1"> method, which is explained in the </span><em class="italic"><span class="koboSpan" id="kobo.341.1">Using matplotlib in your code</span></em><span class="koboSpan" id="kobo.342.1"> section in this chapter. </span><span class="koboSpan" id="kobo.342.2">First, a </span><em class="italic"><span class="koboSpan" id="kobo.343.1">figure</span></em><span class="koboSpan" id="kobo.344.1"> (a blank canvas) is created, an </span><em class="italic"><span class="koboSpan" id="kobo.345.1">axis</span></em><span class="koboSpan" id="kobo.346.1"> (rectangle box with axes) is added, and then the actual </span><em class="italic"><span class="koboSpan" id="kobo.347.1">plot</span></em><span class="koboSpan" id="kobo.348.1"> is drawn. </span><span class="koboSpan" id="kobo.348.2">All three objects were created automatically by a single call to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">plot()</span></strong><span class="koboSpan" id="kobo.350.1"> method. </span><span class="koboSpan" id="kobo.350.2">However, in order to be able to modify the visual representation of the plot, we need to get access to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.351.1">axes</span></strong><span class="koboSpan" id="kobo.352.1"> object directly. </span><span class="koboSpan" id="kobo.352.2">We now want to rewrite the entire code responsible for plotting in order to separate the three </span><span class="No-Break"><span class="koboSpan" id="kobo.353.1">aforementioned objects.</span></span></p>
<ol>
<li value="6"><span class="koboSpan" id="kobo.354.1">So, after we formed the </span><strong class="source-inline"><span class="koboSpan" id="kobo.355.1">time</span></strong><span class="koboSpan" id="kobo.356.1"> list and before the </span><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">plot()</span></strong><span class="koboSpan" id="kobo.358.1"> call, we add </span><span class="No-Break"><span class="koboSpan" id="kobo.359.1">the following:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.360.1">
fig = plt.figure()</span></pre></li>
<li><span class="koboSpan" id="kobo.361.1">This creates a new empty figure object and returns a handle to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.362.1">fig</span></strong><span class="koboSpan" id="kobo.363.1"> variable. </span><span class="koboSpan" id="kobo.363.2">Then, we add </span><span class="No-Break"><span class="koboSpan" id="kobo.364.1">the following:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.365.1">
ax = fig.add_subplot()</span></pre></li>
<li><span class="koboSpan" id="kobo.366.1">This one </span><a id="_idIndexMarker519"/><span class="koboSpan" id="kobo.367.1">creates a new subplot, or axis – the very rectangle that we want to customize. </span><span class="koboSpan" id="kobo.367.2">Great – now we can access it using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">ax</span></strong><span class="koboSpan" id="kobo.369.1"> variable. </span><span class="koboSpan" id="kobo.369.2">So, let’s limit the number of tick labels printed along the </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.370.1">X</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.371.1"> axis:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.372.1">
ax.set_xticks(np.arange(0, len(time) + 1, 15))</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.373.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.374.1">set_xticks()</span></strong><span class="koboSpan" id="kobo.375.1"> method uses only one argument here – an iterable that specifies indices of only those elements in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.376.1">time</span></strong><span class="koboSpan" id="kobo.377.1"> list that we want to plot. </span><span class="koboSpan" id="kobo.377.2">In our example, we use a </span><strong class="source-inline"><span class="koboSpan" id="kobo.378.1">numpy</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.379.1">arange</span></strong><span class="koboSpan" id="kobo.380.1"> that contains integer numbers with a step of 15 to plot every </span><span class="No-Break"><span class="koboSpan" id="kobo.381.1">15th timestamp.</span></span></p>
<ol>
<li value="9"><span class="koboSpan" id="kobo.382.1">Finally, to make our plot even more readable, let’s turn the labels by 45° and plot </span><span class="No-Break"><span class="koboSpan" id="kobo.383.1">the result:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.384.1">
plt.xticks(rotation=45)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.385.1">
plt.plot(time, close)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.386.1">
plt.show()</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.387.1">If you did everything correctly, you should see a chart like </span><span class="No-Break"><span class="koboSpan" id="kobo.388.1">the following:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer069">
<span class="koboSpan" id="kobo.389.1"><img alt="Figure 8.6 – A slightly better-looking simple price chart" src="image/B19145_8_06.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.390.1">Figure 8.6 – A slightly better-looking simple price chart</span></p>
<p><span class="koboSpan" id="kobo.391.1">So far, we have plotted charts only for the last 100 data points, but what if we want to plot the </span><a id="_idIndexMarker520"/><span class="koboSpan" id="kobo.392.1">market data of a certain day in </span><span class="No-Break"><span class="koboSpan" id="kobo.393.1">the past?</span></span></p>
<ol>
<li value="10"><span class="koboSpan" id="kobo.394.1">Let’s rewrite the entire code now to keep everything that we’ve learned so </span><span class="No-Break"><span class="koboSpan" id="kobo.395.1">far together:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.396.1">
import csv</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.397.1">
import matplotlib.pyplot as plt</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.398.1">
import numpy as np</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.399.1">
f = open("/Volumes/Storage HDD/Data/LMAX EUR_USD 1 Minute.txt")</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.400.1">
csvFile = csv.DictReader(f)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.401.1">
all_data = list(csvFile)</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.402.1">So far, there’s no difference; we just import the necessary modules and read the data file. </span><span class="koboSpan" id="kobo.402.2">Now, we </span><a id="_idIndexMarker521"/><span class="koboSpan" id="kobo.403.1">want to plot 100 bars, starting from midnight of December 12, 2019. </span><span class="koboSpan" id="kobo.403.2">So, we find the position of the dictionary with the relevant value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.404.1">Date</span></strong><span class="koboSpan" id="kobo.405.1"> keyword in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.406.1">all_data</span></strong><span class="koboSpan" id="kobo.407.1"> list </span><span class="No-Break"><span class="koboSpan" id="kobo.408.1">of dictionaries:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.409.1">
starting_bar_number = 0
for bar in all_data:
    if bar['Date'] == '12/12/2019':
        break
    starting_bar_number += 1</span></pre>
<ol>
<li value="11"><span class="koboSpan" id="kobo.410.1">Then, we extract the required data </span><span class="No-Break"><span class="koboSpan" id="kobo.411.1">for plotting:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.412.1">
close = [float(bar['Close']) for bar in all_data[starting_bar_number:starting_bar_number + 100]]</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.413.1">
time = [bar['Time'] for bar in all_data[starting_bar_number:starting_bar_number + 100]]</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.414.1">Then, we actually plot using some </span><span class="No-Break"><span class="koboSpan" id="kobo.415.1">nice formatting:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.416.1">
fig = plt.figure()
ax = fig.add_subplot()
ax.set_xticks(np.arange(0, len(time) + 1, 15))
plt.xticks(rotation=45)
plt.plot(time, close)
plt.show()</span></pre>
<p><span class="koboSpan" id="kobo.417.1">That’s it! </span><span class="koboSpan" id="kobo.417.2">Now, we can enjoy </span><span class="No-Break"><span class="koboSpan" id="kobo.418.1">our chart:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer070">
<span class="koboSpan" id="kobo.419.1"><img alt="Figure 8.7 – A simple price chart of data from a specified date and time" src="image/B19145_8_07.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.420.1">Figure 8.7 – A simple price chart of data from a specified date and time</span></p>
<p><span class="koboSpan" id="kobo.421.1">Here, we omit all the </span><a id="_idIndexMarker522"/><span class="koboSpan" id="kobo.422.1">capabilities of </span><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">matplotlib</span></strong><span class="koboSpan" id="kobo.424.1">, including the formatting of titles, using colors, multiple subplots, and much more – at the end of the day, this book is not a </span><strong class="source-inline"><span class="koboSpan" id="kobo.425.1">matplotlib</span></strong><span class="koboSpan" id="kobo.426.1"> tutorial. </span><span class="koboSpan" id="kobo.426.2">If you’re interested in learning more </span><a id="_idIndexMarker523"/><span class="koboSpan" id="kobo.427.1">about this reliable charting package, I’d recommend starting with its official website (</span><a href="https://matplotlib.org"><span class="koboSpan" id="kobo.428.1">https://matplotlib.org</span></a><span class="koboSpan" id="kobo.429.1">), where you’ll find a lot of examples, tutorials, and </span><span class="No-Break"><span class="koboSpan" id="kobo.430.1">general documentation.</span></span></p>
<p><span class="koboSpan" id="kobo.431.1">Alright, now we know how to plot basic price charts – simple line charts of closing (or any other) prices versus timestamps. </span><span class="koboSpan" id="kobo.431.2">However, we all know that the most common format for charting in the financial world is a bar chart or candlestick chart. </span><span class="koboSpan" id="kobo.431.3">How do we plot such a chart </span><span class="No-Break"><span class="koboSpan" id="kobo.432.1">with </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.433.1">matplotlib</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.434.1">?</span></span></p>
<p><span class="koboSpan" id="kobo.435.1">Well, a few years ago, </span><strong class="source-inline"><span class="koboSpan" id="kobo.436.1">matplotlib</span></strong><span class="koboSpan" id="kobo.437.1"> itself used to have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.438.1">finance</span></strong><span class="koboSpan" id="kobo.439.1"> module that supported the charts in question. </span><span class="koboSpan" id="kobo.439.2">However, now it’s deprecated. </span><span class="koboSpan" id="kobo.439.3">So, we have only two options – either </span><a id="_idIndexMarker524"/><span class="koboSpan" id="kobo.440.1">building financial charts bar by bar using matplotlib’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.441.1">bar()</span></strong><span class="koboSpan" id="kobo.442.1"> method or opting for a relatively new but advanced package, </span><strong class="source-inline"><span class="koboSpan" id="kobo.443.1">mplfinance</span></strong><span class="koboSpan" id="kobo.444.1">. </span><span class="koboSpan" id="kobo.444.2">This package offers very simplistic and straightforward methods to plot price charts, but it won’t plot data stored in native Python structures, such as lists or dictionaries. </span><span class="koboSpan" id="kobo.444.3">Instead, it uses </span><strong class="bold"><span class="koboSpan" id="kobo.445.1">pandas</span></strong><span class="koboSpan" id="kobo.446.1"> to handle </span><span class="No-Break"><span class="koboSpan" id="kobo.447.1">market data.</span></span></p>
<p><span class="koboSpan" id="kobo.448.1">So, what is pandas and how can we </span><span class="No-Break"><span class="koboSpan" id="kobo.449.1">use it?</span></span></p>
<h1 id="_idParaDest-138"><a id="_idTextAnchor139"/><span class="koboSpan" id="kobo.450.1">Visualizing static market data with pandas</span></h1>
<p><span class="koboSpan" id="kobo.451.1">pandas is </span><em class="italic"><span class="koboSpan" id="kobo.452.1">“a fast, powerful, flexible, and easy to use open source data analysis and manipulation tool, built on top of the Python programming language”</span></em><span class="koboSpan" id="kobo.453.1">, as declared on its </span><a id="_idIndexMarker525"/><span class="koboSpan" id="kobo.454.1">official web page at </span><a href="https://pandas.pydata.org"><span class="koboSpan" id="kobo.455.1">https://pandas.pydata.org</span></a><span class="koboSpan" id="kobo.456.1">. </span><span class="koboSpan" id="kobo.456.2">It was originally </span><a id="_idIndexMarker526"/><span class="koboSpan" id="kobo.457.1">developed exactly for the purpose of </span><a id="_idIndexMarker527"/><span class="koboSpan" id="kobo.458.1">manipulating time series data, especially </span><span class="No-Break"><span class="koboSpan" id="kobo.459.1">market prices.</span></span></p>
<p><span class="koboSpan" id="kobo.460.1">Instead of native Python lists or NumPy arrays, pandas uses </span><strong class="bold"><span class="koboSpan" id="kobo.461.1">DataFrames</span></strong><span class="koboSpan" id="kobo.462.1"> as a core data object. </span><span class="koboSpan" id="kobo.462.2">You can think of </span><a id="_idIndexMarker528"/><span class="koboSpan" id="kobo.463.1">a DataFrame as a table, where columns represent various named time series (or any other series) and rows contain actual data, with the first row always containing the names of the series. </span><span class="koboSpan" id="kobo.463.2">Pretty much the same as with the historical market data file that we’ve used so far? </span><span class="koboSpan" id="kobo.463.3">Yes, and this makes the learning curve with pandas </span><span class="No-Break"><span class="koboSpan" id="kobo.464.1">really steep.</span></span></p>
<p><span class="koboSpan" id="kobo.465.1">pandas offers methods to add, delete, and rearrange columns, create and modify indices, slice and </span><a id="_idIndexMarker529"/><span class="koboSpan" id="kobo.466.1">create subsets, merge and </span><a id="_idIndexMarker530"/><span class="koboSpan" id="kobo.467.1">reshape DataFrames, and even handle </span><span class="No-Break"><span class="koboSpan" id="kobo.468.1">missing data.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.469.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.470.1">pandas is quite a comprehensive package that offers various methods to handle data to suit very different </span><a id="_idIndexMarker531"/><span class="koboSpan" id="kobo.471.1">needs. </span><span class="koboSpan" id="kobo.471.2">This book is in no way a pandas tutorial; we are going to use only those methods that are required to accomplish the task of plotting market data. </span><span class="koboSpan" id="kobo.471.3">If you are interested in learning more about pandas, I’d recommend starting with a simple tutorial </span><span class="No-Break"><span class="koboSpan" id="kobo.472.1">at </span></span><a href="https://www.w3schools.com/python/pandas/default.asp"><span class="No-Break"><span class="koboSpan" id="kobo.473.1">https://www.w3schools.com/python/pandas/default.asp</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.474.1">.</span></span></p>
<h2 id="_idParaDest-139"><a id="_idTextAnchor140"/><span class="koboSpan" id="kobo.475.1">Installing pandas</span></h2>
<p><span class="koboSpan" id="kobo.476.1">The official pandas website </span><a id="_idIndexMarker532"/><span class="koboSpan" id="kobo.477.1">recommends installing Anaconda, which comes with pandas on board, and refers to other installation methods as </span><em class="italic"><span class="koboSpan" id="kobo.478.1">advanced</span></em><span class="koboSpan" id="kobo.479.1">. </span><span class="koboSpan" id="kobo.479.2">However, there’s nothing really advanced about them. </span><span class="koboSpan" id="kobo.479.3">You can use the standard </span><span class="No-Break"><span class="koboSpan" id="kobo.480.1">PyPI installation:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.481.1">
pip install pandas</span></pre>
<p><span class="koboSpan" id="kobo.482.1">Alternatively, you can </span><span class="No-Break"><span class="koboSpan" id="kobo.483.1">use Conda:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.484.1">
conda install pandas</span></pre>
<h2 id="_idParaDest-140"><a id="_idTextAnchor141"/><span class="koboSpan" id="kobo.485.1">Reading data from CSV files with pandas</span></h2>
<p><span class="koboSpan" id="kobo.486.1">pandas offers a </span><a id="_idIndexMarker533"/><span class="koboSpan" id="kobo.487.1">straightforward method to read data </span><a id="_idIndexMarker534"/><span class="koboSpan" id="kobo.488.1">from a CSV file. </span><span class="koboSpan" id="kobo.488.2">Let’s try the </span><span class="No-Break"><span class="koboSpan" id="kobo.489.1">following </span></span><span class="No-Break"><a id="_idIndexMarker535"/></span><span class="No-Break"><span class="koboSpan" id="kobo.490.1">code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.491.1">
import mplfinance as mpf # this is for future use with charting
import pandas
file_name = "/Volumes/Storage HDD/Data/LMAX EUR_USD 1 Minute.txt"
source_data = pandas.read_csv(file_name)
print(source_data)</span></pre>
<p><span class="koboSpan" id="kobo.492.1">Of course, as always, you want to replace the value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.493.1">file_name</span></strong><span class="koboSpan" id="kobo.494.1"> with the actual path to the locally stored historical data </span><span class="No-Break"><span class="koboSpan" id="kobo.495.1">CSV file.</span></span></p>
<p><span class="koboSpan" id="kobo.496.1">If you did everything correctly, you will see output like </span><span class="No-Break"><span class="koboSpan" id="kobo.497.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.498.1">
               Date      Time     Open  ...  UpTicks  DownTicks  
TotalTicks
0         1/27/2015  13:29:00  1.12942  ...        3          2
           8
1         1/27/2015  13:30:00  1.12947  ...        4          7
          12
2         1/27/2015  13:31:00  1.12953  ...        9          4
          14
3         1/27/2015  13:32:00  1.12944  ...        2         10
          13
4         1/27/2015  13:33:00  1.12876  ...        5          4
          12
...             ...       ...      ...  ...      ...        ...
</span><span class="koboSpan" id="kobo.498.2">         ...
</span><span class="koboSpan" id="kobo.498.3">2136274  11/12/2020  17:43:00  1.18134  ...        4          7
          11
2136275  11/12/2020  17:44:00  1.18124  ...        7          4
          11
2136276  11/12/2020  17:45:00  1.18136  ...        7          5
          12
2136277  11/12/2020  17:46:00  1.18140  ...        8          4
          12
2136278  11/12/2020  17:47:00  1.18154  ...        5          6
          11
[2136279 rows x 12 columns]</span></pre>
<p><span class="koboSpan" id="kobo.499.1">You can see that </span><a id="_idIndexMarker536"/><span class="koboSpan" id="kobo.500.1">the first row was used to create </span><a id="_idIndexMarker537"/><span class="koboSpan" id="kobo.501.1">column names </span><a id="_idIndexMarker538"/><span class="koboSpan" id="kobo.502.1">and the rest formed the </span><span class="No-Break"><span class="koboSpan" id="kobo.503.1">actual data.</span></span></p>
<p><span class="koboSpan" id="kobo.504.1">Note that in front of the data read from the file, there’s an additional column without a name, and it </span><a id="_idIndexMarker539"/><span class="koboSpan" id="kobo.505.1">contains just integer numbers from 0 to 2,136,278 (in the example with my file). </span><span class="koboSpan" id="kobo.505.2">This is the </span><strong class="bold"><span class="koboSpan" id="kobo.506.1">DataFrame index</span></strong><span class="koboSpan" id="kobo.507.1">. </span><span class="koboSpan" id="kobo.507.2">We can retrieve any specific records by referring to them using these </span><a id="_idIndexMarker540"/><span class="koboSpan" id="kobo.508.1">numbers – again, pretty much as we </span><a id="_idIndexMarker541"/><span class="koboSpan" id="kobo.509.1">would do if we </span><a id="_idIndexMarker542"/><span class="koboSpan" id="kobo.510.1">used lists. </span><span class="koboSpan" id="kobo.510.2">Of course, it’s very inconvenient, as we want to be able to retrieve any piece of historical data by referring to a particular date or time range. </span><span class="koboSpan" id="kobo.510.3">Fortunately, pandas offers a way to build a custom index for a DataFrame, so let’s continue with </span><span class="No-Break"><span class="koboSpan" id="kobo.511.1">our code.</span></span></p>
<h2 id="_idParaDest-141"><a id="_idTextAnchor142"/><span class="koboSpan" id="kobo.512.1">Setting index for a dataframe</span></h2>
<p><span class="koboSpan" id="kobo.513.1">First, let’s form </span><a id="_idIndexMarker543"/><span class="koboSpan" id="kobo.514.1">the timestamps from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.515.1">date</span></strong><span class="koboSpan" id="kobo.516.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.517.1">time</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.518.1"> fields:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.519.1">
source_data['Timestamp'] = pandas.to_datetime(source_data['Date']) + pandas.to_timedelta(source_data['Time'])</span></pre>
<p><span class="koboSpan" id="kobo.520.1">Here, we use built-in methods, </span><strong class="source-inline"><span class="koboSpan" id="kobo.521.1">to_datetime()</span></strong><span class="koboSpan" id="kobo.522.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.523.1">to_timedelta()</span></strong><span class="koboSpan" id="kobo.524.1">, which convert string values into a single </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.525.1">Timestamp</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.526.1"> object.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.527.1">Referencing columns in pandas</span></p>
<p class="callout"><span class="koboSpan" id="kobo.528.1">In the preceding code, you can see how pandas allows you to reference a certain column by its name. </span><span class="koboSpan" id="kobo.528.2">This is very similar to finding values by keywords in a dictionary, but in pandas, the entire column is returned, not a </span><span class="No-Break"><span class="koboSpan" id="kobo.529.1">scalar value.</span></span></p>
<p><span class="koboSpan" id="kobo.530.1">Assignment to a column with a non-existent name (</span><strong class="source-inline"><span class="koboSpan" id="kobo.531.1">Timestamp</span></strong><span class="koboSpan" id="kobo.532.1">, in our case) effectively creates a new column with </span><span class="No-Break"><span class="koboSpan" id="kobo.533.1">this name.</span></span></p>
<p><span class="koboSpan" id="kobo.534.1">Having created the new column, let’s set it as </span><span class="No-Break"><span class="koboSpan" id="kobo.535.1">the index:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.536.1">
source_data.set_index(source_data['Timestamp'], inplace=True)</span></pre>
<p><span class="koboSpan" id="kobo.537.1">If we now check the contents of </span><strong class="source-inline"><span class="koboSpan" id="kobo.538.1">source_data</span></strong><span class="koboSpan" id="kobo.539.1">, we will see that the new index was generated and added to </span><span class="No-Break"><span class="koboSpan" id="kobo.540.1">the DataFrame:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.541.1">
                           Date      Time  ...  TotalTicks
           Timestamp
Timestamp                                  ...
</span><span class="koboSpan" id="kobo.541.2">2015-01-27 13:29:00   1/27/2015  13:29:00  ...           8 2015-01-27 13:29:00
2015-01-27 13:30:00   1/27/2015  13:30:00  ...          12 2015-01-27 13:30:00
2015-01-27 13:31:00   1/27/2015  13:31:00  ...          14 2015-01-27 13:31:00
2015-01-27 13:32:00   1/27/2015  13:32:00  ...          13 2015-01-27 13:32:00
2015-01-27 13:33:00   1/27/2015  13:33:00  ...          12 2015-01-27 13:33:00
...                         ...       ...  ...         ...
</span><span class="koboSpan" id="kobo.541.3">                 ...
</span><span class="koboSpan" id="kobo.541.4">2020-11-12 17:43:00  11/12/2020  17:43:00  ...          11 2020-11-12 17:43:00
2020-11-12 17:44:00  11/12/2020  17:44:00  ...          11 2020-11-12 17:44:00
2020-11-12 17:45:00  11/12/2020  17:45:00  ...          12 2020-11-12 17:45:00
2020-11-12 17:46:00  11/12/2020  17:46:00  ...          12 2020-11-12 17:46:00
2020-11-12 17:47:00  11/12/2020  17:47:00  ...          11 2020-11-12 17:47:00
[2136279 rows x 13 columns]</span></pre>
<p><span class="koboSpan" id="kobo.542.1">Great! </span><span class="koboSpan" id="kobo.542.2">Now we </span><a id="_idIndexMarker544"/><span class="koboSpan" id="kobo.543.1">have indexed all our data points (minute bars) by timestamps. </span><span class="koboSpan" id="kobo.543.2">Let’s now create a simple bar chart for the same 1-minute historical data that we </span><span class="No-Break"><span class="koboSpan" id="kobo.544.1">used earlier.</span></span></p>
<h2 id="_idParaDest-142"><a id="_idTextAnchor143"/><span class="koboSpan" id="kobo.545.1">Creating simple bar charts using pandas and mplfinance</span></h2>
<p><span class="koboSpan" id="kobo.546.1">Of course, we don’t want to plot all data in one chart. </span><span class="koboSpan" id="kobo.546.2">The data file I’m using in this chapter </span><a id="_idIndexMarker545"/><span class="koboSpan" id="kobo.547.1">contains about 5 years’ worth of 1-minute bars, or </span><a id="_idIndexMarker546"/><span class="koboSpan" id="kobo.548.1">more than 2 million records, so creating </span><a id="_idIndexMarker547"/><span class="koboSpan" id="kobo.549.1">a chart with more than 2 million bars in it </span><a id="_idIndexMarker548"/><span class="koboSpan" id="kobo.550.1">would simply freeze rendering forever. </span><span class="koboSpan" id="kobo.550.2">Let’s create a chart for just a piece of history, specifying the date, the starting, and the </span><span class="No-Break"><span class="koboSpan" id="kobo.551.1">ending time:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.552.1">
sample_date = '23-03-2020'
start_time = '00:01:00'
day_close_time = '23:00:00'</span></pre>
<p><span class="koboSpan" id="kobo.553.1">The data in my file is in the GMT+1 time zone, so 23:00 here equals 17:00 in New York time, which is the bank settlement time for the FX market (see the </span><em class="italic"><span class="koboSpan" id="kobo.554.1">Trading the FX market – what and how</span></em><span class="koboSpan" id="kobo.555.1"> section in </span><a href="B19145_03.xhtml#_idTextAnchor044"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.556.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.557.1">, </span><em class="italic"><span class="koboSpan" id="kobo.558.1">FX Market Overview from a Developer’s Standpoint</span></em><span class="koboSpan" id="kobo.559.1">). </span><span class="koboSpan" id="kobo.559.2">Also, note that the first timestamp for the day (the </span><strong class="source-inline"><span class="koboSpan" id="kobo.560.1">start_time</span></strong><span class="koboSpan" id="kobo.561.1"> variable) is 1 minute past midnight; for bars, timestamps mean the time of the last tick or the closing price of the interval (see the </span><em class="italic"><span class="koboSpan" id="kobo.562.1">Universal data connector</span></em><span class="koboSpan" id="kobo.563.1"> section in </span><a href="B19145_05.xhtml#_idTextAnchor086"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.564.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.565.1">, </span><em class="italic"><span class="koboSpan" id="kobo.566.1">Retrieving and Handling Market Data with Python</span></em><span class="koboSpan" id="kobo.567.1">, for a detailed explanation of data compression </span><span class="No-Break"><span class="koboSpan" id="kobo.568.1">and timestamps).</span></span></p>
<h2 id="_idParaDest-143"><a id="_idTextAnchor144"/><span class="koboSpan" id="kobo.569.1">Making slices and subsets in pandas</span></h2>
<p><span class="koboSpan" id="kobo.570.1">The most heavily </span><a id="_idIndexMarker549"/><span class="koboSpan" id="kobo.571.1">used method to extract a subset from a DataFrame is </span><strong class="source-inline"><span class="koboSpan" id="kobo.572.1">.loc()</span></strong><span class="koboSpan" id="kobo.573.1">. </span><span class="koboSpan" id="kobo.573.2">Its </span><a id="_idIndexMarker550"/><span class="koboSpan" id="kobo.574.1">usage is again very intuitive, as it’s </span><a id="_idIndexMarker551"/><span class="koboSpan" id="kobo.575.1">very similar to making slices of native Python lists; you </span><a id="_idIndexMarker552"/><span class="koboSpan" id="kobo.576.1">only need to specify the start and end indexes for the new sub-DataFrame, as shown in </span><span class="No-Break"><span class="koboSpan" id="kobo.577.1">this pseudocode:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.578.1">
sub_dataframe = original_dataframe[start : end]</span></pre>
<p><span class="koboSpan" id="kobo.579.1">In our actual code, it will look like </span><span class="No-Break"><span class="koboSpan" id="kobo.580.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.581.1">
all_day_sample = source_data.loc[sample_date + " " + start_time: sample_date + " " + day_close_time]</span></pre>
<p><span class="koboSpan" id="kobo.582.1">Finally, we want to strip away all unnecessary data and keep only </span><strong class="source-inline"><span class="koboSpan" id="kobo.583.1">Open</span></strong><span class="koboSpan" id="kobo.584.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.585.1">High</span></strong><span class="koboSpan" id="kobo.586.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.587.1">Low</span></strong><span class="koboSpan" id="kobo.588.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.589.1">Close</span></strong><span class="koboSpan" id="kobo.590.1">. </span><span class="koboSpan" id="kobo.590.2">Again, with pandas, it can be done in the same straightforward way by just specifying the columns to retain in a list – and the rest will be </span><span class="No-Break"><span class="koboSpan" id="kobo.591.1">thrown away:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.592.1">
OHLC_data = all_day_sample[['Open', 'High', 'Low', 'Close']]</span></pre>
<p><span class="koboSpan" id="kobo.593.1">Note the double </span><a id="_idIndexMarker553"/><span class="koboSpan" id="kobo.594.1">brackets; the outer pair means that we create </span><a id="_idIndexMarker554"/><span class="koboSpan" id="kobo.595.1">a sub-DataFrame based on the specified set of columns, and </span><a id="_idIndexMarker555"/><span class="koboSpan" id="kobo.596.1">the inner pair actually specifies the columns </span><a id="_idIndexMarker556"/><span class="koboSpan" id="kobo.597.1">in a list. </span><span class="koboSpan" id="kobo.597.2">That’s all done – now, it’s time to create our first </span><span class="No-Break"><span class="koboSpan" id="kobo.598.1">bar chart.</span></span></p>
<h2 id="_idParaDest-144"><a id="_idTextAnchor145"/><span class="koboSpan" id="kobo.599.1">Plotting market charts with mplfinance</span></h2>
<p><span class="koboSpan" id="kobo.600.1">All charts </span><a id="_idIndexMarker557"/><span class="koboSpan" id="kobo.601.1">created by </span><strong class="source-inline"><span class="koboSpan" id="kobo.602.1">mplfinance</span></strong><span class="koboSpan" id="kobo.603.1"> are, by default, bar charts, so let’s start with the most </span><span class="No-Break"><span class="koboSpan" id="kobo.604.1">simplistic one:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.605.1">
mpf.plot(OHLC_data)</span></pre>
<p><span class="koboSpan" id="kobo.606.1">If you did everything correctly, you should see a figure like </span><span class="No-Break"><span class="koboSpan" id="kobo.607.1">the following:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer071">
<span class="koboSpan" id="kobo.608.1"><img alt="Figure 8.8 – A default bar chart plotted with mplfinance" src="image/B19145_8_08.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.609.1">Figure 8.8 – A default bar chart plotted with mplfinance</span></p>
<p><span class="koboSpan" id="kobo.610.1">At first glance, it looks like the same line chart, but this is because we have a few too many bars on a relatively small canvas. </span><span class="koboSpan" id="kobo.610.2">Here, we can benefit from the fact that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.611.1">TkAgg</span></strong><span class="koboSpan" id="kobo.612.1"> backend used by default in </span><strong class="source-inline"><span class="koboSpan" id="kobo.613.1">matplotlib</span></strong><span class="koboSpan" id="kobo.614.1"> (and </span><strong class="source-inline"><span class="koboSpan" id="kobo.615.1">mplfinance</span></strong><span class="koboSpan" id="kobo.616.1"> is built on top of </span><strong class="source-inline"><span class="koboSpan" id="kobo.617.1">matplotlib</span></strong><span class="koboSpan" id="kobo.618.1">) is interactive; you can click the magnifying glass icon and zoom in to any part of the chart – say, the spike in the middle of </span><span class="No-Break"><span class="koboSpan" id="kobo.619.1">the day:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer072">
<span class="koboSpan" id="kobo.620.1"><img alt="Figure 8.9 – Using the interactivity of the TkAgg backend to zoom in and out" src="image/B19145_8_09.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.621.1">Figure 8.9 – Using the interactivity of the TkAgg backend to zoom in and out</span></p>
<p><span class="koboSpan" id="kobo.622.1">There are </span><a id="_idIndexMarker558"/><span class="koboSpan" id="kobo.623.1">several options to customize the </span><strong class="source-inline"><span class="koboSpan" id="kobo.624.1">mplfinance</span></strong><span class="koboSpan" id="kobo.625.1"> charts. </span><span class="koboSpan" id="kobo.625.2">For example, we can plot a candlestick chart instead of a bar chart and even add a number of moving averages </span><span class="No-Break"><span class="koboSpan" id="kobo.626.1">to it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.627.1">
mpf.plot(OHLC_data, type = 'candle', mav = (20, 50, 200))</span></pre>
<p><span class="koboSpan" id="kobo.628.1">Here, </span><strong class="source-inline"><span class="koboSpan" id="kobo.629.1">mav</span></strong><span class="koboSpan" id="kobo.630.1"> means </span><strong class="bold"><span class="koboSpan" id="kobo.631.1">moving averages</span></strong><span class="koboSpan" id="kobo.632.1">, and their periods are specified in a tuple. </span><span class="koboSpan" id="kobo.632.2">The result is </span><a id="_idIndexMarker559"/><span class="koboSpan" id="kobo.633.1">shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.634.1">following figure:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer073">
<span class="koboSpan" id="kobo.635.1"><img alt="Figure 8.10 – A candlestick chart with moving averages plotted with mplfinance" src="image/B19145_8_10.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.636.1">Figure 8.10 – A candlestick chart with moving averages plotted with mplfinance</span></p>
<p><span class="koboSpan" id="kobo.637.1">Now, we can use both Matplotlib’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.638.1">pyplot</span></strong><span class="koboSpan" id="kobo.639.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.640.1">mplfinance</span></strong><span class="koboSpan" id="kobo.641.1"> to create price charts in the form of simple </span><a id="_idIndexMarker560"/><span class="koboSpan" id="kobo.642.1">line charts or nice-looking bar or candlestick charts. </span><span class="koboSpan" id="kobo.642.2">However, so far, we have worked only with saved data that is static and not updated in real time. </span><span class="koboSpan" id="kobo.642.3">But what do we do with data being received live from a broker or a data vendor? </span><span class="koboSpan" id="kobo.642.4">Let’s see how we can solve this problem using the universal data </span><span class="No-Break"><span class="koboSpan" id="kobo.643.1">connector approach.</span></span></p>
<h1 id="_idParaDest-145"><a id="_idTextAnchor146"/><span class="koboSpan" id="kobo.644.1">Visualizing live market data</span></h1>
<p><span class="koboSpan" id="kobo.645.1">Before we move on, I strongly </span><a id="_idIndexMarker561"/><span class="koboSpan" id="kobo.646.1">recommend you reread the </span><em class="italic"><span class="koboSpan" id="kobo.647.1">Working with saved and live data – keep your app universal</span></em><span class="koboSpan" id="kobo.648.1"> section in </span><a href="B19145_05.xhtml#_idTextAnchor086"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.649.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.650.1">, </span><em class="italic"><span class="koboSpan" id="kobo.651.1">Retrieving and Handling Market Data with Python</span></em><span class="koboSpan" id="kobo.652.1">, and the </span><em class="italic"><span class="koboSpan" id="kobo.653.1">Sliding windows</span></em><span class="koboSpan" id="kobo.654.1"> section in </span><a href="B19145_07.xhtml#_idTextAnchor114"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.655.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.656.1">, </span><em class="italic"><span class="koboSpan" id="kobo.657.1">Technical Analysis and Its Implementation in Python</span></em><span class="koboSpan" id="kobo.658.1">. </span><span class="koboSpan" id="kobo.658.2">We are going to use the same architecture to create live plots of </span><span class="No-Break"><span class="koboSpan" id="kobo.659.1">market data.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.660.1">Important reminder</span></p>
<p class="callout"><span class="koboSpan" id="kobo.661.1">Whatever data we receive from a live data source should go into a queue. </span><span class="koboSpan" id="kobo.661.2">This should be done in a separate thread. </span><span class="koboSpan" id="kobo.661.3">Then, data is read from the queue into a sliding window that controls the actual amount of data – for any processing </span><span class="No-Break"><span class="koboSpan" id="kobo.662.1">or plotting.</span></span></p>
<p><span class="koboSpan" id="kobo.663.1">When we worked with static historical data, we used very convenient methods that allowed us to </span><a id="_idIndexMarker562"/><span class="koboSpan" id="kobo.664.1">read an entire dataset into memory in one line of code and then navigate through it. </span><span class="koboSpan" id="kobo.664.2">Of course, any convenience is always paid for, and in this case, the fee is running the risk of peeking ahead (see the </span><em class="italic"><span class="koboSpan" id="kobo.665.1">Trading logic – this is where a small mistake may cost a fortune</span></em><span class="koboSpan" id="kobo.666.1"> section in </span><a href="B19145_04.xhtml#_idTextAnchor073"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.667.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.668.1">, </span><em class="italic"><span class="koboSpan" id="kobo.669.1">Trading Application – What’s Inside?</span></em><span class="koboSpan" id="kobo.670.1">), which was efficiently solved in </span><a href="B19145_07.xhtml#_idTextAnchor114"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.671.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.672.1"> by using sliding windows and threading and feeding data points into them one by one, regardless of whether they were saved locally or being received from </span><span class="No-Break"><span class="koboSpan" id="kobo.673.1">the broker.</span></span></p>
<p><span class="koboSpan" id="kobo.674.1">So, in other words, what we were doing so far in this chapter is convenient, but it contradicts the idea of building a universal trading application suitable for both research and </span><span class="No-Break"><span class="koboSpan" id="kobo.675.1">live trading.</span></span></p>
<p><span class="koboSpan" id="kobo.676.1">Why, therefore, did we do all that, you </span><span class="No-Break"><span class="koboSpan" id="kobo.677.1">may ask?</span></span></p>
<p><span class="koboSpan" id="kobo.678.1">There are </span><span class="No-Break"><span class="koboSpan" id="kobo.679.1">two reasons.</span></span></p>
<p><span class="koboSpan" id="kobo.680.1">First, don’t forget that we use charts only to </span><em class="italic"><span class="koboSpan" id="kobo.681.1">either</span></em><span class="koboSpan" id="kobo.682.1"> visually confirm an idea during the research phase </span><em class="italic"><span class="koboSpan" id="kobo.683.1">or</span></em><span class="koboSpan" id="kobo.684.1"> to check the consistency of live ordering in production. </span><span class="koboSpan" id="kobo.684.2">When we work on the development of a trading idea, it is infinitely more convenient to be able to immediately visualize a certain piece of historical data, especially if you work in an interactive environment such as IPython. </span><span class="koboSpan" id="kobo.684.3">That’s where using pandas with </span><strong class="source-inline"><span class="koboSpan" id="kobo.685.1">mplfinance</span></strong><span class="koboSpan" id="kobo.686.1"> may be the </span><span class="No-Break"><span class="koboSpan" id="kobo.687.1">right choice.</span></span></p>
<p><span class="koboSpan" id="kobo.688.1">Second, visualization is used not only to plot market data but also (and probably even more intensively) to plot the results of a backtest, running simulated trades over historical data. </span><span class="koboSpan" id="kobo.688.2">And since a backtest is by definition something </span><em class="italic"><span class="koboSpan" id="kobo.689.1">carved in stone</span></em><span class="koboSpan" id="kobo.690.1"> – that is, not updated live – then using the approaches that we considered earlier in this chapter will serve our purpose </span><span class="No-Break"><span class="koboSpan" id="kobo.691.1">just fine.</span></span></p>
<p><span class="koboSpan" id="kobo.692.1">All in all, we </span><a id="_idIndexMarker563"/><span class="koboSpan" id="kobo.693.1">want to visualize live market data in order to check its correctness, see various indicators, and/or track the order execution. </span><span class="koboSpan" id="kobo.693.2">Let’s see how </span><span class="No-Break"><span class="koboSpan" id="kobo.694.1">it’s done.</span></span></p>
<h2 id="_idParaDest-146"><a id="_idTextAnchor147"/><span class="koboSpan" id="kobo.695.1">Plotting live tick data</span></h2>
<p><span class="koboSpan" id="kobo.696.1">As always, we </span><a id="_idIndexMarker564"/><span class="koboSpan" id="kobo.697.1">start with </span><span class="No-Break"><span class="koboSpan" id="kobo.698.1">several imports:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.699.1">
import json
import threading
import queue
import matplotlib.pyplot as plt</span></pre>
<p><span class="koboSpan" id="kobo.700.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.701.1">json</span></strong><span class="koboSpan" id="kobo.702.1"> module will help us parse the response from the data server; we are already familiar with the </span><span class="No-Break"><span class="koboSpan" id="kobo.703.1">other modules</span></span></p>
<p><span class="koboSpan" id="kobo.704.1">Then, we import a method to establish WebSocket connections from the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.705.1">websocket</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.706.1"> library:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.707.1">
from websocket import create_connection</span></pre>
<p><span class="koboSpan" id="kobo.708.1">Next, we create a class that implements the sliding window (see the </span><em class="italic"><span class="koboSpan" id="kobo.709.1">Sliding windows</span></em><span class="koboSpan" id="kobo.710.1"> section in </span><a href="B19145_06.xhtml#_idTextAnchor101"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.711.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.712.1">, </span><em class="italic"><span class="koboSpan" id="kobo.713.1">Basics of Fundamental Analysis and Its Possible Use in </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.714.1">FX Trading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.715.1">):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.716.1">
class sliding_window:
    def __init__(self, length):
        self.data = ([0]*length)
    def add(self, element):
        self.data.append(element)
        self.data.pop(0)</span></pre>
<p><span class="koboSpan" id="kobo.717.1">Then, we add a function that creates and maintains the WebSocket connection with the market data server. </span><span class="koboSpan" id="kobo.717.2">This function has </span><span class="No-Break"><span class="koboSpan" id="kobo.718.1">three arguments:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.719.1">The URL </span><span class="No-Break"><span class="koboSpan" id="kobo.720.1">to connect</span></span></li>
<li><span class="koboSpan" id="kobo.721.1">The message we send to the server to subscribe to </span><span class="No-Break"><span class="koboSpan" id="kobo.722.1">market data</span></span></li>
<li><span class="koboSpan" id="kobo.723.1">The queue in which we place </span><span class="No-Break"><span class="koboSpan" id="kobo.724.1">incoming ticks</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.725.1">You can also implement the function as a class method if you plan to build a complex application with </span><span class="No-Break"><span class="koboSpan" id="kobo.726.1">multiple connections:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.727.1">
def LMAX_connect(url, subscription_msg, ticks_queue):</span></pre>
<p><span class="koboSpan" id="kobo.728.1">Create </span><span class="No-Break"><span class="koboSpan" id="kobo.729.1">the connection:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.730.1">
    ws = create_connection(url)</span></pre>
<p><span class="koboSpan" id="kobo.731.1">Then, send </span><a id="_idIndexMarker565"/><span class="koboSpan" id="kobo.732.1">the subscription message, which we will specify later, outside the function code (if you implement the function as a </span><strong class="source-inline"><span class="koboSpan" id="kobo.733.1">class</span></strong><span class="koboSpan" id="kobo.734.1"> method, you may want to pass the subscription message as a parameter or have it as a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.735.1">class</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.736.1"> attribute):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.737.1">
    ws.send(subscription_msg)</span></pre>
<p><span class="koboSpan" id="kobo.738.1">Upon successful subscription, the function awaits incoming ticks and places them into </span><span class="No-Break"><span class="koboSpan" id="kobo.739.1">a queue:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.740.1">
    while True:
        tick = json.loads(ws.recv())
        ticks_queue.put(tick)
        print(tick)</span></pre>
<p><span class="koboSpan" id="kobo.741.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.742.1">print(tick)</span></strong><span class="koboSpan" id="kobo.743.1"> statement is added only for debugging purposes. </span><span class="koboSpan" id="kobo.743.2">All preparations are done, so now, </span><span class="No-Break"><span class="koboSpan" id="kobo.744.1">let’s proceed:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.745.1">
url = "wss://public-data-api.london-demo.lmax.com/v1/web-socket"
subscription_msg = '{"type": "SUBSCRIBE","channels": [{"name": "ORDER_BOOK","instruments": ["eur-usd"]}]}'</span></pre>
<p><span class="koboSpan" id="kobo.746.1">Here, we specify the server to connect to and the message we will send to subscribe to market data. </span><span class="koboSpan" id="kobo.746.2">Please refer to </span><a href="B19145_05.xhtml#_idTextAnchor086"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.747.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.748.1">, </span><em class="italic"><span class="koboSpan" id="kobo.749.1">Retrieving and Handling Market Data with Python</span></em><span class="koboSpan" id="kobo.750.1">, for a detailed description of the LMAX data structure and the </span><em class="italic"><span class="koboSpan" id="kobo.751.1">Retrieving data – garbage in – garbage out</span></em><span class="koboSpan" id="kobo.752.1"> section in </span><a href="B19145_04.xhtml#_idTextAnchor073"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.753.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.754.1">, </span><em class="italic"><span class="koboSpan" id="kobo.755.1">Trading Application – What’s Inside?</span></em><span class="koboSpan" id="kobo.756.1">, to refresh your memory on important issues regarding receiving and </span><span class="No-Break"><span class="koboSpan" id="kobo.757.1">processing data.</span></span></p>
<p><span class="koboSpan" id="kobo.758.1">Next, we’ll create the queue to store the </span><span class="No-Break"><span class="koboSpan" id="kobo.759.1">incoming ticks:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.760.1">
pipe = queue.Queue()</span></pre>
<p><span class="koboSpan" id="kobo.761.1">We will also create a thread to </span><span class="No-Break"><span class="koboSpan" id="kobo.762.1">retrieve data:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.763.1">
data_receiver_thread = threading.Thread(target = LMAX_connect, args = (url, subscription_msg, pipe))
data_receiver_thread.start()</span></pre>
<p><span class="koboSpan" id="kobo.764.1">If you did </span><a id="_idIndexMarker566"/><span class="koboSpan" id="kobo.765.1">everything correctly and ran the code, you will see the order book data coming from </span><span class="No-Break"><span class="koboSpan" id="kobo.766.1">the WebSocket:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.767.1">
{'type': 'ORDER_BOOK', 'instrument_id': 'eur-usd', 'timestamp': '2022-10-28T09:12:26.000Z', 'status': 'OPEN', 'bids': [{'price': '0.995350', 'quantity': '1000000.0000'}, {'price': '0.995340', 'quantity': '2000000.0000'}, {'price': '0.995330', 'quantity': '500000.0000'}, {'price': '0.995320', 'quantity': '500000.0000'}, {'price': '0.995310', 'quantity': '1500000.0000'}, {'price': '0.987800', 'quantity': '1000000.0000'}, {'price': '0.985000', 'quantity': '13000000.0000'}, {'price': '0.980000', 'quantity': '13000000.0000'}], 'asks': [{'price': '0.995410', 'quantity': '500000.0000'}, {'price': '0.995420', 'quantity': '1000000.0000'}, {'price': '0.995430', 'quantity': '1500000.0000'}, {'price': '0.995440', 'quantity': '2000000.0000'}, {'price': '0.995450', 'quantity': '3000000.0000'}, {'price': '0.995810', 'quantity': '410000.0000'}]}</span></pre>
<p><span class="koboSpan" id="kobo.768.1">We want to plot only the top of the book – that is, the current best bid and best ask – so let’s add another function that will parse incoming ticks and send </span><strong class="source-inline"><span class="koboSpan" id="kobo.769.1">bid</span></strong><span class="koboSpan" id="kobo.770.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.771.1">ask</span></strong><span class="koboSpan" id="kobo.772.1"> values to the respective sliding windows. </span><span class="koboSpan" id="kobo.772.2">We implement this function without arguments because it shares data structures (bid and ask sliding windows) with the charting part of </span><span class="No-Break"><span class="koboSpan" id="kobo.773.1">the code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.774.1">
def get_ticks(ticks_queue):
    while True:
        tick = ticks_queue.get()
        if 'bids' in tick.keys():
            bid = float(tick['bids'][0]['price'])
            ask = float(tick['asks'][0]['price'])
            bids.add(bid)
            asks.add(ask)
            print(bid, ask)</span></pre>
<p><span class="koboSpan" id="kobo.775.1">This function gets ticks from the queue, extracts bids and asks, and sends them to the respective sliding </span><a id="_idIndexMarker567"/><span class="koboSpan" id="kobo.776.1">windows (</span><strong class="source-inline"><span class="koboSpan" id="kobo.777.1">bids</span></strong><span class="koboSpan" id="kobo.778.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.779.1">asks</span></strong><span class="koboSpan" id="kobo.780.1">). </span><span class="koboSpan" id="kobo.780.2">Let’s create them – first, we specify the length of the sliding window (let’s set it to 60, which will display about 1 minute’s worth of data, given that LMAX sends an update at a rate of about 1 tick </span><span class="No-Break"><span class="koboSpan" id="kobo.781.1">per second):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.782.1">
window_size = 60</span></pre>
<p><span class="koboSpan" id="kobo.783.1">Then, add two windows, for </span><strong class="source-inline"><span class="koboSpan" id="kobo.784.1">bids</span></strong><span class="koboSpan" id="kobo.785.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.786.1">asks</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.787.1"> respectively:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.788.1">
bids = sliding_window(window_size)
asks = sliding_window(window_size)</span></pre>
<p><span class="koboSpan" id="kobo.789.1">Now, we wrap the processing function into </span><span class="No-Break"><span class="koboSpan" id="kobo.790.1">a thread:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.791.1">
trading_algo_thread = threading.Thread(target = get_ticks, args = (pipe,))
trading_algo_thread.start()</span></pre>
<p><span class="koboSpan" id="kobo.792.1">If we now run the code we have developed so far, we will see pairs of bids and asks updated about every </span><span class="No-Break"><span class="koboSpan" id="kobo.793.1">1 second:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.794.1">
0.99626 0.99631
0.99626 0.99629
0.99624 0.9963
0.99624 0.9963
0.99624 0.99629</span></pre>
<p><span class="koboSpan" id="kobo.795.1">Great job! </span><span class="koboSpan" id="kobo.795.2">Now, we want to plot this live data in </span><span class="No-Break"><span class="koboSpan" id="kobo.796.1">a chart.</span></span></p>
<p><span class="koboSpan" id="kobo.797.1">At this point, the most natural course of action would be to create the third thread and do all the plotting </span><a id="_idIndexMarker568"/><span class="koboSpan" id="kobo.798.1">inside it, to keep all three processes (retrieving data, processing, and plotting) separate from each other and the </span><span class="No-Break"><span class="koboSpan" id="kobo.799.1">main thread.</span></span></p>
<p><span class="koboSpan" id="kobo.800.1">Alas, with </span><strong class="source-inline"><span class="koboSpan" id="kobo.801.1">matplotlib</span></strong><span class="koboSpan" id="kobo.802.1"> (and many other charting suites), to do this is very complex (although not impossible). </span><span class="koboSpan" id="kobo.802.2">So, unfortunately, we have to live with the fact that charting is (easily) available only in the </span><span class="No-Break"><span class="koboSpan" id="kobo.803.1">main thread.</span></span></p>
<p><span class="koboSpan" id="kobo.804.1">First, let’s wait till the entire data in the sliding windows is filled with </span><span class="No-Break"><span class="koboSpan" id="kobo.805.1">meaningful values:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.806.1">
while bids.data[0] == 0:
    pass</span></pre>
<p><span class="koboSpan" id="kobo.807.1">Then, we create the figure and the axes separately (as we did earlier in this chapter when we customized the </span><span class="No-Break"><span class="koboSpan" id="kobo.808.1">axis labels):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.809.1">
fig = plt.figure()
ax = fig.add_subplot()</span></pre>
<p><span class="koboSpan" id="kobo.810.1">Next, we add two lines for our two data series (the bids </span><span class="No-Break"><span class="koboSpan" id="kobo.811.1">and asks):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.812.1">
line1, = ax.plot(bids.data)
line2, = ax.plot(asks.data)</span></pre>
<p><span class="koboSpan" id="kobo.813.1">Finally, we start </span><a id="_idIndexMarker569"/><span class="koboSpan" id="kobo.814.1">the main charting loop, which will draw the lines and refresh the figure once </span><span class="No-Break"><span class="koboSpan" id="kobo.815.1">every second:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.816.1">
while True:
    line1.set_ydata(bids.data)
    line2.set_ydata(asks.data)</span></pre>
<p><span class="koboSpan" id="kobo.817.1">The following command adds small margins above and below the plots, just to improve the </span><span class="No-Break"><span class="koboSpan" id="kobo.818.1">visual perception:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.819.1">
    plt.ylim(min(bids.data) - 0.0001, max(asks.data) + 0.0001)</span></pre>
<p><span class="koboSpan" id="kobo.820.1">Then, we actually plot </span><span class="No-Break"><span class="koboSpan" id="kobo.821.1">the chart:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.822.1">
    fig.canvas.draw()</span></pre>
<p><span class="koboSpan" id="kobo.823.1">We then wait for 1 second for the graphics to be rendered and appear on screen; otherwise, the loop blocks the rendering we don’t let it run during </span><span class="No-Break"><span class="koboSpan" id="kobo.824.1">this pause:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.825.1">
    plt.pause(1)</span></pre>
<p><span class="koboSpan" id="kobo.826.1">So simple! </span><span class="koboSpan" id="kobo.826.2">If you did everything correctly, you should see a figure similar to the following one </span><a id="_idIndexMarker570"/><span class="koboSpan" id="kobo.827.1">updating </span><span class="No-Break"><span class="koboSpan" id="kobo.828.1">every second:</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.829.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.830.1">It takes time to fill the entire sliding window. </span><span class="koboSpan" id="kobo.830.2">In our example, it will be about 60 seconds before the </span><span class="No-Break"><span class="koboSpan" id="kobo.831.1">figure appears.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer074">
<span class="koboSpan" id="kobo.832.1"><img alt="Figure 8.11 – A simple live price tick chart showing both bid and ask" src="image/B19145_8_11.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.833.1">Figure 8.11 – A simple live price tick chart showing both bid and ask</span></p>
<p><span class="koboSpan" id="kobo.834.1">Well, now we can draw live charts of market prices, and it has turned out to be quite simple and straightforward – but only in form of lines for every tick. </span><span class="koboSpan" id="kobo.834.2">What if we want to aggregate data and then plot a bar or candlestick chart? </span><span class="koboSpan" id="kobo.834.3">Let’s find the solution in the </span><span class="No-Break"><span class="koboSpan" id="kobo.835.1">next section.</span></span></p>
<h2 id="_idParaDest-147"><a id="_idTextAnchor148"/><span class="koboSpan" id="kobo.836.1">Plotting live bar or candlestick charts</span></h2>
<p><span class="koboSpan" id="kobo.837.1">Earlier in this chapter, we worked with bar and candlestick charts, and we know that the most streamlined way </span><a id="_idIndexMarker571"/><span class="koboSpan" id="kobo.838.1">of doing that is by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.839.1">mplfinance</span></strong><span class="koboSpan" id="kobo.840.1"> library. </span><span class="koboSpan" id="kobo.840.2">The idea </span><a id="_idIndexMarker572"/><span class="koboSpan" id="kobo.841.1">is to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.842.1">mplfinance.plot()</span></strong><span class="koboSpan" id="kobo.843.1"> method in a loop and update, similar to how we just did for line plots of tick data. </span><span class="koboSpan" id="kobo.843.2">So, what we want to do now is add a new function that would split the incoming tick data stream into bars according to a certain rule, adds the formed bars to a DataFrame, and sends the resulting DataFrame to the </span><span class="No-Break"><span class="koboSpan" id="kobo.844.1">charting loop:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.845.1">Let’s start with imports. </span><span class="koboSpan" id="kobo.845.2">Some imported modules are the same as in the previous example because we need them to retrieve data from a WebSocket </span><span class="No-Break"><span class="koboSpan" id="kobo.846.1">connection again:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.847.1">
import json</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.848.1">
import threading</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.849.1">
import queue</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.850.1">
from websocket import create_connection</span></pre></li>
<li><span class="koboSpan" id="kobo.851.1">Then, we import the </span><strong class="source-inline"><span class="koboSpan" id="kobo.852.1">datetime</span></strong><span class="koboSpan" id="kobo.853.1"> method, as we will convert string timestamps into </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.854.1">datetime</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.855.1"> objects:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.856.1">
from datetime import datetime</span></pre></li>
<li><span class="koboSpan" id="kobo.857.1">Finally, we have some imports to </span><span class="No-Break"><span class="koboSpan" id="kobo.858.1">facilitate charting:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.859.1">
import matplotlib.pyplot as plt</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.860.1">
import pandas</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.861.1">
import mplfinance as mpf</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.862.1">Then, we will reuse some of the code from the </span><em class="italic"><span class="koboSpan" id="kobo.863.1">Plotting live tick data</span></em><span class="koboSpan" id="kobo.864.1"> section – the assignment of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.865.1">sliding_window</span></strong><span class="koboSpan" id="kobo.866.1"> class, </span><strong class="source-inline"><span class="koboSpan" id="kobo.867.1">url</span></strong><span class="koboSpan" id="kobo.868.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.869.1">subscription_msg</span></strong><span class="koboSpan" id="kobo.870.1"> variables, and the initialization of </span><strong class="source-inline"><span class="koboSpan" id="kobo.871.1">pipe</span></strong><span class="koboSpan" id="kobo.872.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.873.1">window_size</span></strong><span class="koboSpan" id="kobo.874.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.875.1">bids</span></strong><span class="koboSpan" id="kobo.876.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.877.1">asks</span></strong><span class="koboSpan" id="kobo.878.1">. </span><span class="koboSpan" id="kobo.878.2">We will also reuse the </span><strong class="source-inline"><span class="koboSpan" id="kobo.879.1">LMAX_connect()</span></strong><span class="koboSpan" id="kobo.880.1"> function </span><span class="No-Break"><span class="koboSpan" id="kobo.881.1">without changes.</span></span></p>
<ol>
<li value="4"><span class="koboSpan" id="kobo.882.1">Now, we will create a new queue into which we will send DataFrames </span><span class="No-Break"><span class="koboSpan" id="kobo.883.1">for plotting:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.884.1">
data_for_chart = queue.Queue()</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.885.1">We will also create a new function that will do the job of splitting the incoming tick data stream </span><span class="No-Break"><span class="koboSpan" id="kobo.886.1">into bars:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.887.1">
def make_bars():
    bars = pandas.DataFrame(columns=['Timestamp', 'Open', 'High', 'Low', 'Close'])
    bars.set_index('Timestamp', inplace=True)</span></pre>
<ol>
<li value="5"><span class="koboSpan" id="kobo.888.1">We’ve created an empty DataFrame, set the column titles, and assigned </span><strong class="source-inline"><span class="koboSpan" id="kobo.889.1">Timestamp</span></strong><span class="koboSpan" id="kobo.890.1"> as the index. </span><span class="koboSpan" id="kobo.890.2">Next, we set the time frame (resolution) to 10 seconds and initialize </span><span class="No-Break"><span class="koboSpan" id="kobo.891.1">the timestamp:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.892.1">
    resolution = 10</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.893.1">
    last_sample_ts = 0</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.894.1">Now, as always, if we work with infinite processes in threads, we start the loop, in which we </span><a id="_idIndexMarker573"/><span class="koboSpan" id="kobo.895.1">read a tick, extract its timestamp and last bid price (we assume we want to plot bids; if you want to plot any other data from the order </span><a id="_idIndexMarker574"/><span class="koboSpan" id="kobo.896.1">book, just choose the appropriate key and value in the dictionary), and if this is the very first tick we received, initialize the </span><strong class="source-inline"><span class="koboSpan" id="kobo.897.1">open</span></strong><span class="koboSpan" id="kobo.898.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.899.1">high</span></strong><span class="koboSpan" id="kobo.900.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.901.1">low</span></strong><span class="koboSpan" id="kobo.902.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.903.1">close</span></strong><span class="koboSpan" id="kobo.904.1"> values for the upcoming bar and set </span><strong class="source-inline"><span class="koboSpan" id="kobo.905.1">last_sample_ts</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.906.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.907.1">ts</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.908.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.909.1">
    while True:
        tick = pipe.get()
        ts = datetime.strptime(tick['timestamp'], "%Y-%m-%dT%H:%M:%S.%fZ")
        last_bid = float(tick['bids'][0]['price'])
        if last_sample_ts == 0:
            last_sample_ts = ts
            open = high = low = close = last_bid</span></pre>
<ol>
<li value="6"><span class="koboSpan" id="kobo.910.1">Now, we specify the condition with which we will start a new bar. </span><span class="koboSpan" id="kobo.910.2">In this case, we do it as soon as the difference between the current time (</span><strong class="source-inline"><span class="koboSpan" id="kobo.911.1">ts</span></strong><span class="koboSpan" id="kobo.912.1">) and the time of the previous bar (</span><strong class="source-inline"><span class="koboSpan" id="kobo.913.1">last_bar_sample</span></strong><span class="koboSpan" id="kobo.914.1">) becomes greater than the value stored in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.915.1">resolution</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.916.1"> variable:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.917.1">
        delta = ts – last_sample_ts</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.918.1">
        if delta.seconds &gt;= resolution:</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.919.1">
            bar = pandas.DataFrame([[open, high, low, close]], columns = ['Open', 'High', 'Low', 'Close'], index = [ts])</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.920.1">
            bars = pandas.concat([bars, bar])</span></pre></li>
<li><span class="koboSpan" id="kobo.921.1">So, as soon as a new 10-second interval is started, we create a new DataFrame bar using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.922.1">Open</span></strong><span class="koboSpan" id="kobo.923.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.924.1">High</span></strong><span class="koboSpan" id="kobo.925.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.926.1">Low</span></strong><span class="koboSpan" id="kobo.927.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.928.1">Close</span></strong><span class="koboSpan" id="kobo.929.1"> values and the current timestamp, and add it </span><a id="_idIndexMarker575"/><span class="koboSpan" id="kobo.930.1">to the main DataFrame bars. </span><span class="koboSpan" id="kobo.930.2">The rest of the function’s code is </span><a id="_idIndexMarker576"/><span class="koboSpan" id="kobo.931.1">pretty apparent; first, we again initialize all four price variables, update the timestamp of the last bar, and put the DataFrame in </span><span class="No-Break"><span class="koboSpan" id="kobo.932.1">the queue:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.933.1">
            last_sample_ts = ts</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.934.1">
            open = high = low = close = last_bid</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.935.1">
            data_for_chart.put(bars)</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.936.1">Of course, if the condition is not </span><strong class="source-inline"><span class="koboSpan" id="kobo.937.1">true</span></strong><span class="koboSpan" id="kobo.938.1"> (the time since the bars opened did not exceed the resolution threshold), we just update the </span><span class="No-Break"><span class="koboSpan" id="kobo.939.1">price variables:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.940.1">
        else:
            high = max([high, last_bid])
            low = min([low, last_bid])
            close = last_bid</span></pre>
<ol>
<li value="8"><span class="koboSpan" id="kobo.941.1">The trick is done; now, let’s create </span><span class="No-Break"><span class="koboSpan" id="kobo.942.1">two threads:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.943.1">
data_receiver_thread = threading.Thread(target = LMAX_connect)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.944.1">
data_receiver_thread.start()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.945.1">
trading_algo_thread = threading.Thread(target = make_bars)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.946.1">
trading_algo_thread.start()</span></pre></li>
<li><span class="koboSpan" id="kobo.947.1">Create the figure and get a handle on </span><span class="No-Break"><span class="koboSpan" id="kobo.948.1">the axes:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.949.1">
fig = mpf.figure()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.950.1">
ax1 = fig.add_subplot(1,1,1)</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.951.1">Then, run the </span><span class="No-Break"><span class="koboSpan" id="kobo.952.1">plotting loop:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.953.1">
while True:
    chart_data = data_for_chart.get()
    ax1.clear()
    mpf.plot(chart_data, ax = ax1, type='candle', block = False)
    plt.pause(1)</span></pre>
<p><span class="koboSpan" id="kobo.954.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.955.1">block = False</span></strong><span class="koboSpan" id="kobo.956.1"> optional argument to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.957.1">mpf.plot()</span></strong><span class="koboSpan" id="kobo.958.1"> method tells the renderer </span><a id="_idIndexMarker577"/><span class="koboSpan" id="kobo.959.1">to release the chart after drawing and allow adding or </span><a id="_idIndexMarker578"/><span class="koboSpan" id="kobo.960.1">modifying objects in it (so that we can do live updates). </span><span class="koboSpan" id="kobo.960.2">Don’t forget to add a pause (</span><strong class="source-inline"><span class="koboSpan" id="kobo.961.1">plt.pause(1)</span></strong><span class="koboSpan" id="kobo.962.1">); otherwise, the loop will always be busy and won’t let the system display the chart </span><span class="No-Break"><span class="koboSpan" id="kobo.963.1">on screen.</span></span></p>
<p><span class="koboSpan" id="kobo.964.1">If you run this code, the first thing you will see is a single huge candlestick because we don’t have enough </span><span class="No-Break"><span class="koboSpan" id="kobo.965.1">data yet:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer075">
<span class="koboSpan" id="kobo.966.1"><img alt="Figure 8.12 – The initial view of the live candlestick chart" src="image/B19145_8_12.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.967.1">Figure 8.12 – The initial view of the live candlestick chart</span></p>
<p><span class="koboSpan" id="kobo.968.1">Then, the chart </span><a id="_idIndexMarker579"/><span class="koboSpan" id="kobo.969.1">will update every 10 seconds, and after 4 minutes, you will </span><a id="_idIndexMarker580"/><span class="koboSpan" id="kobo.970.1">see something like what is shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.971.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer076">
<span class="koboSpan" id="kobo.972.1"><img alt="Figure 8.13 – A 10-second candlestick chart made with live price data" src="image/B19145_8_13.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.973.1">Figure 8.13 – A 10-second candlestick chart made with live price data</span></p>
<ol>
<li value="10"><span class="koboSpan" id="kobo.974.1">As we receive more and more data, there will be more and more candles on the chart, so at a </span><a id="_idIndexMarker581"/><span class="koboSpan" id="kobo.975.1">certain point, it will become unreadable. </span><span class="koboSpan" id="kobo.975.2">Therefore, you </span><a id="_idIndexMarker582"/><span class="koboSpan" id="kobo.976.1">may want to add a limit and throw away the oldest row from the DataFrame as the newest one comes in, just before we place the DataFrame in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.977.1">data_for_chart</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.978.1"> queue:</span></span></li>
</ol>
<pre class="source-code"><span class="koboSpan" id="kobo.979.1">
            if len(bars) &gt; 100:
                bars = bars.iloc[1:, :]
            data_for_chart.put(bars)</span></pre>
<p><span class="koboSpan" id="kobo.980.1">Here, I specified 100 bars to display, and as soon as this limit is reached, older bars will disappear from the screen – pretty much like in MetaTrader, MultiCharts, TradeStation, or any other </span><span class="No-Break"><span class="koboSpan" id="kobo.981.1">charting application.</span></span></p>
<p><span class="koboSpan" id="kobo.982.1">Very frequently, we will </span><a id="_idIndexMarker583"/><span class="koboSpan" id="kobo.983.1">need to plot something else along with the price data. </span><span class="koboSpan" id="kobo.983.2">It can be </span><a id="_idIndexMarker584"/><span class="koboSpan" id="kobo.984.1">a technical indicator, a trendline, just a mark denoting an entry or exit, or anything else. </span><span class="koboSpan" id="kobo.984.2">Let’s see how we can do that in the </span><span class="No-Break"><span class="koboSpan" id="kobo.985.1">next section.</span></span></p>
<h1 id="_idParaDest-148"><a id="_idTextAnchor149"/><span class="koboSpan" id="kobo.986.1">Adding objects to price charts</span></h1>
<p><span class="koboSpan" id="kobo.987.1">It is not difficult to </span><a id="_idIndexMarker585"/><span class="koboSpan" id="kobo.988.1">add any objects to the chart if we know their </span><a id="_idIndexMarker586"/><span class="koboSpan" id="kobo.989.1">coordinates because all </span><strong class="source-inline"><span class="koboSpan" id="kobo.990.1">matplotlib</span></strong><span class="koboSpan" id="kobo.991.1"> methods always plot one array-like object versus another. </span><span class="koboSpan" id="kobo.991.2">So, basically, all we need to do to add any special objects to a chart is to calculate their position in the list, or the array along the </span><em class="italic"><span class="koboSpan" id="kobo.992.1">X</span></em><span class="koboSpan" id="kobo.993.1"> axis and the corresponding value along the </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.994.1">Y</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.995.1"> axis.</span></span></p>
<p><span class="koboSpan" id="kobo.996.1">Let’s consider a simple yet valuable example. </span><span class="koboSpan" id="kobo.996.2">In </span><a href="B19145_03.xhtml#_idTextAnchor044"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.997.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.998.1">, </span><em class="italic"><span class="koboSpan" id="kobo.999.1">FX Market Overview from a Developer’s Standpoint</span></em><span class="koboSpan" id="kobo.1000.1">, we saw that price takers can only buy at the ask and sell at the bid. </span><span class="koboSpan" id="kobo.1000.2">We also saw that a large order can move the price a few points (pips) up or down because it consumes the liquidity from several levels in the order book. </span><span class="koboSpan" id="kobo.1000.3">So, we can assume with a good degree of confidence that if the best bid suddenly became greater than the best ask at the previous tick, then it was possibly a trace of a significant buy order. </span><span class="koboSpan" id="kobo.1000.4">And it works vice versa – if we observe a plunge of the best ask below the previous best bid, then it may be a footprint of a significant </span><span class="No-Break"><span class="koboSpan" id="kobo.1001.1">sell order.</span></span></p>
<p><span class="koboSpan" id="kobo.1002.1">Let’s visualize these two situations by adding triangle markers, pointing up and down on the tick chart for supposed buys and sells respectively. </span><span class="koboSpan" id="kobo.1002.2">For this purpose, we will use the code that we wrote to visualize live tick data (see the </span><em class="italic"><span class="koboSpan" id="kobo.1003.1">Plotting live tick data</span></em><span class="koboSpan" id="kobo.1004.1"> section) and just add a </span><span class="No-Break"><span class="koboSpan" id="kobo.1005.1">few lines:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.1006.1">First, we need to add two new objects that will display the markers. </span><span class="koboSpan" id="kobo.1006.2">We add them just below the lines where we create objects to display bids and asks (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1007.1">line1</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1008.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1009.1">line2</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1010.1">):</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1011.1">
line3, = ax.plot(buy_signals_x, buy_signals_y, 'g^')</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1012.1">
line4, = ax.plot(sell_signals_x, sell_signals_y, 'mv')</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.1013.1">Special modifiers here denote the color and the style of the graphics – </span><strong class="source-inline"><span class="koboSpan" id="kobo.1014.1">'g^'</span></strong><span class="koboSpan" id="kobo.1015.1"> means a green triangle pointing up and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1016.1">'mv'</span></strong><span class="koboSpan" id="kobo.1017.1"> means a magenta triangle pointing down. </span><span class="koboSpan" id="kobo.1017.2">You can find a comprehensive list of the optional parameters of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1018.1">pyplot.plot()</span></strong><span class="koboSpan" id="kobo.1019.1"> method </span><span class="No-Break"><span class="koboSpan" id="kobo.1020.1">at </span></span><a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html#matplotlib.pyplot.plot"><span class="No-Break"><span class="koboSpan" id="kobo.1021.1">https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html#matplotlib.pyplot.plot</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1022.1">.</span></span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.1023.1">Next, we need to calculate the coordinates (positions) of these markers. </span><span class="koboSpan" id="kobo.1023.2">We will do it at the very beginning of the main charting loop (immediately after </span><strong class="source-inline"><span class="koboSpan" id="kobo.1024.1">while True:</span></strong><span class="koboSpan" id="kobo.1025.1">). </span><span class="koboSpan" id="kobo.1025.2">Let’s add four respective lists to store </span><span class="No-Break"><span class="koboSpan" id="kobo.1026.1">the coordinates:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1027.1">
while True:</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1028.1">
    buy_signals_x = []</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1029.1">
    buy_signals_y = []</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1030.1">
    sell_signals_x = []</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1031.1">
    sell_signals_y = []</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.1032.1">Then, fill them at all occurrences of the best bid being greater than the previous best ask, or the best ask being lower than the previous </span><span class="No-Break"><span class="koboSpan" id="kobo.1033.1">best bid:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1034.1">
    for i in range(1, window_size):</span></pre>
<ol>
<li value="3"><span class="koboSpan" id="kobo.1035.1">Note that </span><a id="_idIndexMarker587"/><span class="koboSpan" id="kobo.1036.1">we start counting from 1 and not from 0 because </span><a id="_idIndexMarker588"/><span class="koboSpan" id="kobo.1037.1">we want to compare a value in the list with the </span><strong class="bold"><span class="koboSpan" id="kobo.1038.1">previous</span></strong><span class="koboSpan" id="kobo.1039.1"> value, and starting from 0 would compare </span><strong class="source-inline"><span class="koboSpan" id="kobo.1040.1">bids.data[0]</span></strong><span class="koboSpan" id="kobo.1041.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1042.1">bids.data[-1]</span></strong><span class="koboSpan" id="kobo.1043.1">, which is effectively the </span><strong class="bold"><span class="koboSpan" id="kobo.1044.1">last</span></strong><span class="koboSpan" id="kobo.1045.1"> element in the list, not the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1046.1">previous</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1047.1"> one:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1048.1">
        if bids.data[i] &gt; asks.data[i - 1]:</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1049.1">
            buy_signals_x.append(i)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1050.1">
            buy_signals_y.append(bids.data[i] - 0.0001)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1051.1">
        if asks.data[i] &lt; bids.data[i - 1]:</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1052.1">
            sell_signals_x.append(i)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1053.1">
            sell_signals_y.append(asks.data[i] + 0.0001)</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.1054.1">We add a margin of 1 </span><strong class="source-inline"><span class="koboSpan" id="kobo.1055.1">pip</span></strong><span class="koboSpan" id="kobo.1056.1"> to the values along the </span><em class="italic"><span class="koboSpan" id="kobo.1057.1">Y</span></em><span class="koboSpan" id="kobo.1058.1"> axis so that the markers will be placed slightly away from the </span><span class="No-Break"><span class="koboSpan" id="kobo.1059.1">main chart.</span></span></p>
<ol>
<li value="4"><span class="koboSpan" id="kobo.1060.1">The rest is </span><a id="_idIndexMarker589"/><span class="koboSpan" id="kobo.1061.1">the same as what we did for plotting bids </span><a id="_idIndexMarker590"/><span class="koboSpan" id="kobo.1062.1">and asks; just add calls to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1063.1">set_xdata()</span></strong><span class="koboSpan" id="kobo.1064.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1065.1">set_ydata()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1066.1"> methods:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1067.1">
    line3.set_xdata(buy_signals_x)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1068.1">
    line3.set_ydata(buy_signals_y)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1069.1">
    line4.set_xdata(sell_signals_x)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1070.1">
    line4.set_ydata(sell_signals_y)</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.1071.1">That’s it! </span><span class="koboSpan" id="kobo.1071.2">If we run our script now, we will see green and magenta markers pointing to the exact places where supposedly big buys or </span><span class="No-Break"><span class="koboSpan" id="kobo.1072.1">sells happened:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer077">
<span class="koboSpan" id="kobo.1073.1"><img alt="Figure 8.14 – A tick chart with spread-crossing marks added" src="image/B19145_8_14.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1074.1">Figure 8.14 – A tick chart with spread-crossing marks added</span></p>
<p><span class="koboSpan" id="kobo.1075.1">Wow! </span><span class="koboSpan" id="kobo.1075.2">Does the chart show the exact points to buy or sell? </span><span class="koboSpan" id="kobo.1075.3">Looks like we’ve found an excellent trading </span><a id="_idIndexMarker591"/><span class="koboSpan" id="kobo.1076.1">strategy. </span><span class="koboSpan" id="kobo.1076.2">Now, is the only thing left to do to </span><a id="_idIndexMarker592"/><span class="koboSpan" id="kobo.1077.1">automate it and look for a bank with reliable safe deposit boxes to store the </span><span class="No-Break"><span class="koboSpan" id="kobo.1078.1">earned cash?</span></span></p>
<p><span class="koboSpan" id="kobo.1079.1">Of course not. </span><span class="koboSpan" id="kobo.1079.2">Just look at the following screenshot, and you will see that sometimes chasing </span><em class="italic"><span class="koboSpan" id="kobo.1080.1">big money</span></em><span class="koboSpan" id="kobo.1081.1"> can be quite a </span><span class="No-Break"><span class="koboSpan" id="kobo.1082.1">disappointing experience:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer078">
<span class="koboSpan" id="kobo.1083.1"><img alt="Figure 8.15 – Another illustration of spread-crossing – the price reverses and goes in the opposite direction" src="image/B19145_8_15.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1084.1">Figure 8.15 – Another illustration of spread-crossing – the price reverses and goes in the opposite direction</span></p>
<p><span class="koboSpan" id="kobo.1085.1">So, as I have maintained throughout the book, there is no free lunch and there is no Holy Grail in trading, which means that it is impossible to make money consistently for a reasonably </span><a id="_idIndexMarker593"/><span class="koboSpan" id="kobo.1086.1">long period of time by using only one magical trading </span><a id="_idIndexMarker594"/><span class="koboSpan" id="kobo.1087.1">rule. </span><span class="koboSpan" id="kobo.1087.2">Instead, we need to develop a trading strategy, something that will incorporate trading logic (when we enter and exit the market and why, which normally consists of plenty of rules), money management (how much we trade), and risk management (what we do if things go wrong or, preferably, how to anticipate that and avoid trading). </span><span class="koboSpan" id="kobo.1087.3">And this is what we are going to consider in the remaining part of </span><span class="No-Break"><span class="koboSpan" id="kobo.1088.1">this book.</span></span></p>
<h1 id="_idParaDest-149"><a id="_idTextAnchor150"/><span class="koboSpan" id="kobo.1089.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1090.1">In this chapter, we learned about the general principles of handling charts with Python. </span><span class="koboSpan" id="kobo.1090.2">Now, we can quickly find the required part of historical data and plot it as line or candlestick charts. </span><span class="koboSpan" id="kobo.1090.3">We also learned how to plot live market data and update the charts in real time. </span><span class="koboSpan" id="kobo.1090.4">Finally, we learned how to add custom graphics to a price chart and discovered that crossing the spread can indeed be a potentially valuable trading signal. </span><span class="koboSpan" id="kobo.1090.5">We are prepared to visualize any data, be it market prices or the performance of our trading algorithm, so it’s high time we step into the domain of trading strategies to understand how and why they work, and to make the right choice for further development. </span><span class="koboSpan" id="kobo.1090.6">This is what we are going to consider in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1091.1">next chapter.</span></span></p>
</div>


<div class="Content" id="_idContainer080">
<h1 id="_idParaDest-150"><a id="_idTextAnchor151"/><span class="koboSpan" id="kobo.1.1">Part 3: Orders, Trading Strategies, and Their Performance</span></h1>
<p><span class="koboSpan" id="kobo.2.1">In previous parts, we learned about the FX markets, understood how they operate, and discovered how to avoid the intrinsic risks. </span><span class="koboSpan" id="kobo.2.2">We also considered the essential components of most trading algorithms, which aim at addressing the peculiarities of the </span><span class="No-Break"><span class="koboSpan" id="kobo.3.1">subject domain.</span></span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.4.1">Part 3</span></em><span class="koboSpan" id="kobo.5.1"> moves forward by explaining the ideas behind most trading strategies, including all-time classics such as trend following, momentum, and mean reversion, along with more advanced arbitrage and stat arbitrage, market making, and high-frequency trading. </span><span class="koboSpan" id="kobo.5.2">We will also learn about the most common types of orders, typical issues with their execution, and ways to mitigate the associated risks. </span><span class="koboSpan" id="kobo.5.3">Finally, we will build our first trading app, test it, and learn about one of the most common mistakes among </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">quant traders.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">This part comprises the </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">following chapters:</span></span></p>
<ul>
<li><a href="B19145_09.xhtml#_idTextAnchor152"><em class="italic"><span class="koboSpan" id="kobo.9.1">Chapter 9</span></em></a><span class="koboSpan" id="kobo.10.1">, </span><em class="italic"><span class="koboSpan" id="kobo.11.1">Trading Strategies and Their Core Elements</span></em></li>
<li><a href="B19145_10.xhtml#_idTextAnchor171"><em class="italic"><span class="koboSpan" id="kobo.12.1">Chapter 10</span></em></a><span class="koboSpan" id="kobo.13.1">, </span><em class="italic"><span class="koboSpan" id="kobo.14.1">Types of Orders and Their Simulation in Python</span></em></li>
<li><a href="B19145_11.xhtml#_idTextAnchor186"><em class="italic"><span class="koboSpan" id="kobo.15.1">Chapter 11</span></em></a><span class="koboSpan" id="kobo.16.1">, </span><em class="italic"><span class="koboSpan" id="kobo.17.1">Backtesting and Theoretical Performance</span></em></li>
</ul>
</div>
<div>
<div id="_idContainer081">
</div>
</div>
</body></html>